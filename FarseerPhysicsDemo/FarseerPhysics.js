/**
 * @version 1.0.0.0
 * @copyright Copyright Â©  2018
 * @compiler Bridge.NET 17.2.0
 */
Bridge.assembly("FarseerPhysics", function ($asm, globals) {
    "use strict";

    Bridge.define("Element$1", function (T) { return {
        fields: {
            Parent: null,
            Span: null,
            Value: Bridge.getDefaultValue(T)
        },
        ctors: {
            init: function () {
                this.Span = new FarseerPhysics.Collision.AABB();
            },
            ctor: function (value, span) {
                this.$initialize();
                this.Span = span.$clone();
                this.Value = value;
                this.Parent = null;
            }
        }
    }; });

    /** @namespace FarseerPhysics.Collision */

    /**
     * An axis aligned bounding box.
     *
     * @public
     * @class FarseerPhysics.Collision.AABB
     */
    Bridge.define("FarseerPhysics.Collision.AABB", {
        $kind: "struct",
        statics: {
            fields: {
                _input: null
            },
            ctors: {
                init: function () {
                    this._input = new FarseerPhysics.Collision.DistanceInput();
                }
            },
            methods: {
                TestOverlap: function (a, b) {
                    a = {v:a};
                    b = {v:b};
                    return FarseerPhysics.Collision.AABB.TestOverlap$1(a, b);
                },
                TestOverlap$1: function (a, b) {
                    var d1 = Microsoft.Xna.Framework.Vector2.op_Subtraction(b.v.LowerBound.$clone(), a.v.UpperBound.$clone());
                    var d2 = Microsoft.Xna.Framework.Vector2.op_Subtraction(a.v.LowerBound.$clone(), b.v.UpperBound.$clone());

                    if (d1.X > 0.0 || d1.Y > 0.0) {
                        return false;
                    }

                    if (d2.X > 0.0 || d2.Y > 0.0) {
                        return false;
                    }

                    return true;
                },
                TestOverlap$2: function (shapeA, indexA, shapeB, indexB, xfA, xfB) {
                    FarseerPhysics.Collision.AABB._input.ProxyA.Set(shapeA, indexA);
                    FarseerPhysics.Collision.AABB._input.ProxyB.Set(shapeB, indexB);
                    FarseerPhysics.Collision.AABB._input.TransformA = xfA.v.$clone();
                    FarseerPhysics.Collision.AABB._input.TransformB = xfB.v.$clone();
                    FarseerPhysics.Collision.AABB._input.UseRadii = true;

                    var cache = { v : new FarseerPhysics.Collision.SimplexCache() };
                    var output = { v : new FarseerPhysics.Collision.DistanceOutput() };
                    FarseerPhysics.Collision.Distance.ComputeDistance(output, cache, FarseerPhysics.Collision.AABB._input);

                    return output.v.Distance < 1.1920929E-06;
                },
                getDefaultValue: function () { return new FarseerPhysics.Collision.AABB(); }
            }
        },
        fields: {
            /**
             * The lower vertex
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Collision.AABB
             * @type Microsoft.Xna.Framework.Vector2
             */
            LowerBound: null,
            /**
             * The upper vertex
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Collision.AABB
             * @type Microsoft.Xna.Framework.Vector2
             */
            UpperBound: null
        },
        props: {
            /**
             * Get the center of the AABB.
             *
             * @instance
             * @public
             * @readonly
             * @memberof FarseerPhysics.Collision.AABB
             * @function Center
             * @type Microsoft.Xna.Framework.Vector2
             */
            Center: {
                get: function () {
                    return Microsoft.Xna.Framework.Vector2.op_Multiply$2(0.5, (Microsoft.Xna.Framework.Vector2.op_Addition(this.LowerBound.$clone(), this.UpperBound.$clone())));
                }
            },
            /**
             * Get the extents of the AABB (half-widths).
             *
             * @instance
             * @public
             * @readonly
             * @memberof FarseerPhysics.Collision.AABB
             * @function Extents
             * @type Microsoft.Xna.Framework.Vector2
             */
            Extents: {
                get: function () {
                    return Microsoft.Xna.Framework.Vector2.op_Multiply$2(0.5, (Microsoft.Xna.Framework.Vector2.op_Subtraction(this.UpperBound.$clone(), this.LowerBound.$clone())));
                }
            },
            /**
             * Get the perimeter length
             *
             * @instance
             * @public
             * @readonly
             * @memberof FarseerPhysics.Collision.AABB
             * @function Perimeter
             * @type number
             */
            Perimeter: {
                get: function () {
                    var wx = this.UpperBound.X - this.LowerBound.X;
                    var wy = this.UpperBound.Y - this.LowerBound.Y;
                    return 2.0 * (wx + wy);
                }
            },
            /**
             * Gets the vertices of the AABB.
             *
             * @instance
             * @public
             * @readonly
             * @memberof FarseerPhysics.Collision.AABB
             * @function Vertices
             * @type FarseerPhysics.Common.Vertices
             */
            Vertices: {
                get: function () {
                    var vertices = new FarseerPhysics.Common.Vertices.ctor();
                    vertices.add(this.LowerBound.$clone());
                    vertices.add(new Microsoft.Xna.Framework.Vector2.$ctor2(this.LowerBound.X, this.UpperBound.Y));
                    vertices.add(this.UpperBound.$clone());
                    vertices.add(new Microsoft.Xna.Framework.Vector2.$ctor2(this.UpperBound.X, this.LowerBound.Y));
                    return vertices;
                }
            },
            /**
             * first quadrant
             *
             * @instance
             * @public
             * @readonly
             * @memberof FarseerPhysics.Collision.AABB
             * @function Q1
             * @type FarseerPhysics.Collision.AABB
             */
            Q1: {
                get: function () {
                    return new FarseerPhysics.Collision.AABB.$ctor1(this.Center.$clone(), this.UpperBound.$clone());
                }
            },
            Q2: {
                get: function () {
                    return new FarseerPhysics.Collision.AABB.$ctor1(new Microsoft.Xna.Framework.Vector2.$ctor2(this.LowerBound.X, this.Center.Y), new Microsoft.Xna.Framework.Vector2.$ctor2(this.Center.X, this.UpperBound.Y));
                }
            },
            Q3: {
                get: function () {
                    return new FarseerPhysics.Collision.AABB.$ctor1(this.LowerBound.$clone(), this.Center.$clone());
                }
            },
            Q4: {
                get: function () {
                    return new FarseerPhysics.Collision.AABB.$ctor1(new Microsoft.Xna.Framework.Vector2.$ctor2(this.Center.X, this.LowerBound.Y), new Microsoft.Xna.Framework.Vector2.$ctor2(this.UpperBound.X, this.Center.Y));
                }
            }
        },
        ctors: {
            init: function () {
                this.LowerBound = new Microsoft.Xna.Framework.Vector2();
                this.UpperBound = new Microsoft.Xna.Framework.Vector2();
            },
            $ctor1: function (min, max) {
                FarseerPhysics.Collision.AABB.$ctor3.call(this, min, max);
            },
            $ctor3: function (min, max) {
                this.$initialize();
                this.LowerBound = min.v.$clone();
                this.UpperBound = max.v.$clone();
            },
            $ctor2: function (center, width, height) {
                this.$initialize();
                this.LowerBound = Microsoft.Xna.Framework.Vector2.op_Subtraction(center.$clone(), new Microsoft.Xna.Framework.Vector2.$ctor2(width / 2, height / 2));
                this.UpperBound = Microsoft.Xna.Framework.Vector2.op_Addition(center.$clone(), new Microsoft.Xna.Framework.Vector2.$ctor2(width / 2, height / 2));
            },
            ctor: function () {
                this.$initialize();
            }
        },
        methods: {
            GetVertices: function () {
                var p1 = this.UpperBound.$clone();
                var p2 = new Microsoft.Xna.Framework.Vector2.$ctor2(this.UpperBound.X, this.LowerBound.Y);
                var p3 = this.LowerBound.$clone();
                var p4 = new Microsoft.Xna.Framework.Vector2.$ctor2(this.LowerBound.X, this.UpperBound.Y);
                return System.Array.init([p1.$clone(), p2.$clone(), p3.$clone(), p4.$clone()], Microsoft.Xna.Framework.Vector2);
            },
            /**
             * Verify that the bounds are sorted.
             *
             * @instance
             * @public
             * @this FarseerPhysics.Collision.AABB
             * @memberof FarseerPhysics.Collision.AABB
             * @return  {boolean}        <pre><code>true</code></pre> if this instance is valid; otherwise, <pre><code>false</code></pre>.
             */
            IsValid: function () {
                var d = Microsoft.Xna.Framework.Vector2.op_Subtraction(this.UpperBound.$clone(), this.LowerBound.$clone());
                var valid = d.X >= 0.0 && d.Y >= 0.0;
                valid = valid && FarseerPhysics.Common.MathUtils.IsValid(this.LowerBound) && FarseerPhysics.Common.MathUtils.IsValid(this.UpperBound);
                return valid;
            },
            /**
             * Combine an AABB into this one.
             *
             * @instance
             * @public
             * @this FarseerPhysics.Collision.AABB
             * @memberof FarseerPhysics.Collision.AABB
             * @param   {FarseerPhysics.Collision.AABB}    aabb    The aabb.
             * @return  {void}
             */
            Combine: function (aabb) {
                this.LowerBound = Microsoft.Xna.Framework.Vector2.Min(this.LowerBound.$clone(), aabb.v.LowerBound.$clone());
                this.UpperBound = Microsoft.Xna.Framework.Vector2.Max(this.UpperBound.$clone(), aabb.v.UpperBound.$clone());
            },
            /**
             * Combine two AABBs into this one.
             *
             * @instance
             * @public
             * @this FarseerPhysics.Collision.AABB
             * @memberof FarseerPhysics.Collision.AABB
             * @param   {FarseerPhysics.Collision.AABB}    aabb1    The aabb1.
             * @param   {FarseerPhysics.Collision.AABB}    aabb2    The aabb2.
             * @return  {void}
             */
            Combine$1: function (aabb1, aabb2) {
                this.LowerBound = Microsoft.Xna.Framework.Vector2.Min(aabb1.v.LowerBound.$clone(), aabb2.v.LowerBound.$clone());
                this.UpperBound = Microsoft.Xna.Framework.Vector2.Max(aabb1.v.UpperBound.$clone(), aabb2.v.UpperBound.$clone());
            },
            /**
             * Does this aabb contain the provided AABB.
             *
             * @instance
             * @public
             * @this FarseerPhysics.Collision.AABB
             * @memberof FarseerPhysics.Collision.AABB
             * @param   {FarseerPhysics.Collision.AABB}    aabb    The aabb.
             * @return  {boolean}                                  <pre><code>true</code></pre> if it contains the specified aabb; otherwise, <pre><code>false</code></pre>.
             */
            Contains: function (aabb) {
                var result = true;
                result = result && this.LowerBound.X <= aabb.v.LowerBound.X;
                result = result && this.LowerBound.Y <= aabb.v.LowerBound.Y;
                result = result && aabb.v.UpperBound.X <= this.UpperBound.X;
                result = result && aabb.v.UpperBound.Y <= this.UpperBound.Y;
                return result;
            },
            /**
             * Determines whether the AAABB contains the specified point.
             *
             * @instance
             * @public
             * @this FarseerPhysics.Collision.AABB
             * @memberof FarseerPhysics.Collision.AABB
             * @param   {Microsoft.Xna.Framework.Vector2}    point    The point.
             * @return  {boolean}                                     <pre><code>true</code></pre> if it contains the specified point; otherwise, <pre><code>false</code></pre>.
             */
            Contains$1: function (point) {
                if ((point.v.X > (this.LowerBound.X + FarseerPhysics.Settings.Epsilon) && point.v.X < (this.UpperBound.X - FarseerPhysics.Settings.Epsilon) && (point.v.Y > (this.LowerBound.Y + FarseerPhysics.Settings.Epsilon) && point.v.Y < (this.UpperBound.Y - FarseerPhysics.Settings.Epsilon)))) {
                    return true;
                }
                return false;
            },
            RayCast: function (output, input) {
                output.v = new FarseerPhysics.Collision.RayCastOutput();

                var tmin = -3.40282347E+38;
                var tmax = FarseerPhysics.Settings.MaxFloat;

                var p = input.v.Point1.$clone();
                var d = Microsoft.Xna.Framework.Vector2.op_Subtraction(input.v.Point2.$clone(), input.v.Point1.$clone());
                var absD = FarseerPhysics.Common.MathUtils.Abs(d.$clone());

                var normal = Microsoft.Xna.Framework.Vector2.Zero.$clone();

                for (var i = 0; i < 2; i = (i + 1) | 0) {
                    var absD_i = i === 0 ? absD.X : absD.Y;
                    var lowerBound_i = i === 0 ? this.LowerBound.X : this.LowerBound.Y;
                    var upperBound_i = i === 0 ? this.UpperBound.X : this.UpperBound.Y;
                    var p_i = i === 0 ? p.X : p.Y;

                    if (absD_i < FarseerPhysics.Settings.Epsilon) {
                        if (p_i < lowerBound_i || upperBound_i < p_i) {
                            return false;
                        }
                    } else {
                        var d_i = i === 0 ? d.X : d.Y;

                        var inv_d = 1.0 / d_i;
                        var t1 = { v : (lowerBound_i - p_i) * inv_d };
                        var t2 = { v : (upperBound_i - p_i) * inv_d };

                        var s = -1.0;

                        if (t1.v > t2.v) {
                            FarseerPhysics.Common.MathUtils.Swap(System.Single, t1, t2);
                            s = 1.0;
                        }

                        if (t1.v > tmin) {
                            if (i === 0) {
                                normal.X = s;
                            } else {
                                normal.Y = s;
                            }

                            tmin = t1.v;
                        }

                        tmax = Math.min(tmax, t2.v);

                        if (tmin > tmax) {
                            return false;
                        }
                    }
                }

                if (tmin < 0.0 || input.v.MaxFraction < tmin) {
                    return false;
                }

                output.v.Fraction = tmin;
                output.v.Normal = normal.$clone();
                return true;
            },
            getHashCode: function () {
                var h = Bridge.addHash([1111638337, this.LowerBound, this.UpperBound]);
                return h;
            },
            equals: function (o) {
                if (!Bridge.is(o, FarseerPhysics.Collision.AABB)) {
                    return false;
                }
                return Bridge.equals(this.LowerBound, o.LowerBound) && Bridge.equals(this.UpperBound, o.UpperBound);
            },
            $clone: function (to) {
                var s = to || new FarseerPhysics.Collision.AABB();
                s.LowerBound = this.LowerBound.$clone();
                s.UpperBound = this.UpperBound.$clone();
                return s;
            }
        }
    });

    /**
     * Used for computing contact manifolds.
     *
     * @public
     * @class FarseerPhysics.Collision.ClipVertex
     */
    Bridge.define("FarseerPhysics.Collision.ClipVertex", {
        $kind: "struct",
        statics: {
            methods: {
                getDefaultValue: function () { return new FarseerPhysics.Collision.ClipVertex(); }
            }
        },
        fields: {
            ID: null,
            V: null
        },
        ctors: {
            init: function () {
                this.ID = new FarseerPhysics.Collision.ContactID();
                this.V = new Microsoft.Xna.Framework.Vector2();
            },
            ctor: function () {
                this.$initialize();
            }
        },
        methods: {
            getHashCode: function () {
                var h = Bridge.addHash([3839642110, this.ID, this.V]);
                return h;
            },
            equals: function (o) {
                if (!Bridge.is(o, FarseerPhysics.Collision.ClipVertex)) {
                    return false;
                }
                return Bridge.equals(this.ID, o.ID) && Bridge.equals(this.V, o.V);
            },
            $clone: function (to) {
                var s = to || new FarseerPhysics.Collision.ClipVertex();
                s.ID = this.ID.$clone();
                s.V = this.V.$clone();
                return s;
            }
        }
    });

    Bridge.define("FarseerPhysics.Collision.Collision", {
        statics: {
            fields: {
                _edgeA: null,
                _proxyA: null,
                _proxyB: null,
                _xf: null,
                _limit11: null,
                _limit12: null,
                _limit21: null,
                _limit22: null,
                _radius: 0,
                _tmpNormals: null
            },
            ctors: {
                init: function () {
                    this._edgeA = new FarseerPhysics.Collision.FatEdge();
                    this._xf = new FarseerPhysics.Common.Transform();
                    this._limit11 = new Microsoft.Xna.Framework.Vector2();
                    this._limit12 = new Microsoft.Xna.Framework.Vector2();
                    this._limit21 = new Microsoft.Xna.Framework.Vector2();
                    this._limit22 = new Microsoft.Xna.Framework.Vector2();
                    this._proxyA = new FarseerPhysics.Collision.EPProxy();
                    this._proxyB = new FarseerPhysics.Collision.EPProxy();
                    this._tmpNormals = System.Array.init(2, function (){
                        return new Microsoft.Xna.Framework.Vector2();
                    }, Microsoft.Xna.Framework.Vector2);
                }
            },
            methods: {
                /**
                 * Evaluate the manifold with supplied transforms. This assumes
                 modest motion from the original state. This does not change the
                 point count, impulses, etc. The radii must come from the Shapes
                 that generated the manifold.
                 *
                 * @static
                 * @public
                 * @this FarseerPhysics.Collision.Collision
                 * @memberof FarseerPhysics.Collision.Collision
                 * @param   {FarseerPhysics.Collision.Manifold}    manifold      The manifold.
                 * @param   {FarseerPhysics.Common.Transform}      transformA    The transform for A.
                 * @param   {number}                               radiusA       The radius for A.
                 * @param   {FarseerPhysics.Common.Transform}      transformB    The transform for B.
                 * @param   {number}                               radiusB       The radius for B.
                 * @param   {Microsoft.Xna.Framework.Vector2}      normal        World vector pointing from A to B
                 * @param   {FarseerPhysics.Common.FixedArray2}    points        Torld contact point (point of intersection).
                 * @return  {void}
                 */
                GetWorldManifold: function (manifold, transformA, radiusA, transformB, radiusB, normal, points) {
                    points.v = new (FarseerPhysics.Common.FixedArray2$1(Microsoft.Xna.Framework.Vector2))();
                    normal.v = Microsoft.Xna.Framework.Vector2.Zero.$clone();

                    if (manifold.v.PointCount === 0) {
                        normal.v = Microsoft.Xna.Framework.Vector2.UnitY.$clone();
                        return;
                    }

                    switch (manifold.v.Type) {
                        case FarseerPhysics.Collision.ManifoldType.Circles: 
                            {
                                var tmp = manifold.v.Points.getItem(0).$clone().LocalPoint.$clone();
                                var pointAx = transformA.v.Position.X + transformA.v.R.Col1.X * manifold.v.LocalPoint.X + transformA.v.R.Col2.X * manifold.v.LocalPoint.Y;

                                var pointAy = transformA.v.Position.Y + transformA.v.R.Col1.Y * manifold.v.LocalPoint.X + transformA.v.R.Col2.Y * manifold.v.LocalPoint.Y;

                                var pointBx = transformB.v.Position.X + transformB.v.R.Col1.X * tmp.X + transformB.v.R.Col2.X * tmp.Y;

                                var pointBy = transformB.v.Position.Y + transformB.v.R.Col1.Y * tmp.X + transformB.v.R.Col2.Y * tmp.Y;

                                normal.v.X = 1;
                                normal.v.Y = 0;

                                var result = (pointAx - pointBx) * (pointAx - pointBx) + (pointAy - pointBy) * (pointAy - pointBy);
                                if (result > 1.42108547E-14) {
                                    var tmpNormalx = pointBx - pointAx;
                                    var tmpNormaly = pointBy - pointAy;
                                    var factor = 1.0 / Math.sqrt(tmpNormalx * tmpNormalx + tmpNormaly * tmpNormaly);
                                    normal.v.X = tmpNormalx * factor;
                                    normal.v.Y = tmpNormaly * factor;
                                }

                                var c = Microsoft.Xna.Framework.Vector2.Zero.$clone();
                                c.X = (pointAx + radiusA * normal.v.X) + (pointBx - radiusB * normal.v.X);
                                c.Y = (pointAy + radiusA * normal.v.Y) + (pointBy - radiusB * normal.v.Y);

                                points.v.setItem(0, Microsoft.Xna.Framework.Vector2.op_Multiply$2(0.5, c.$clone()));
                            }
                            break;
                        case FarseerPhysics.Collision.ManifoldType.FaceA: 
                            {
                                normal.v.X = transformA.v.R.Col1.X * manifold.v.LocalNormal.X + transformA.v.R.Col2.X * manifold.v.LocalNormal.Y;
                                normal.v.Y = transformA.v.R.Col1.Y * manifold.v.LocalNormal.X + transformA.v.R.Col2.Y * manifold.v.LocalNormal.Y;

                                var planePointx = transformA.v.Position.X + transformA.v.R.Col1.X * manifold.v.LocalPoint.X + transformA.v.R.Col2.X * manifold.v.LocalPoint.Y;

                                var planePointy = transformA.v.Position.Y + transformA.v.R.Col1.Y * manifold.v.LocalPoint.X + transformA.v.R.Col2.Y * manifold.v.LocalPoint.Y;

                                for (var i = 0; i < manifold.v.PointCount; i = (i + 1) | 0) {
                                    var tmp1 = manifold.v.Points.getItem(i).$clone().LocalPoint.$clone();

                                    var clipPointx = transformB.v.Position.X + transformB.v.R.Col1.X * tmp1.X + transformB.v.R.Col2.X * tmp1.Y;

                                    var clipPointy = transformB.v.Position.Y + transformB.v.R.Col1.Y * tmp1.X + transformB.v.R.Col2.Y * tmp1.Y;

                                    var value = (clipPointx - planePointx) * normal.v.X + (clipPointy - planePointy) * normal.v.Y;

                                    var c1 = Microsoft.Xna.Framework.Vector2.Zero.$clone();
                                    c1.X = (clipPointx + (radiusA - value) * normal.v.X) + (clipPointx - radiusB * normal.v.X);
                                    c1.Y = (clipPointy + (radiusA - value) * normal.v.Y) + (clipPointy - radiusB * normal.v.Y);

                                    points.v.setItem(i, Microsoft.Xna.Framework.Vector2.op_Multiply$2(0.5, c1.$clone()));
                                }
                            }
                            break;
                        case FarseerPhysics.Collision.ManifoldType.FaceB: 
                            {
                                normal.v.X = transformB.v.R.Col1.X * manifold.v.LocalNormal.X + transformB.v.R.Col2.X * manifold.v.LocalNormal.Y;
                                normal.v.Y = transformB.v.R.Col1.Y * manifold.v.LocalNormal.X + transformB.v.R.Col2.Y * manifold.v.LocalNormal.Y;

                                var planePointx1 = transformB.v.Position.X + transformB.v.R.Col1.X * manifold.v.LocalPoint.X + transformB.v.R.Col2.X * manifold.v.LocalPoint.Y;

                                var planePointy1 = transformB.v.Position.Y + transformB.v.R.Col1.Y * manifold.v.LocalPoint.X + transformB.v.R.Col2.Y * manifold.v.LocalPoint.Y;

                                for (var i1 = 0; i1 < manifold.v.PointCount; i1 = (i1 + 1) | 0) {
                                    var tmp2 = manifold.v.Points.getItem(i1).$clone().LocalPoint.$clone();

                                    var clipPointx1 = transformA.v.Position.X + transformA.v.R.Col1.X * tmp2.X + transformA.v.R.Col2.X * tmp2.Y;

                                    var clipPointy1 = transformA.v.Position.Y + transformA.v.R.Col1.Y * tmp2.X + transformA.v.R.Col2.Y * tmp2.Y;

                                    var value1 = (clipPointx1 - planePointx1) * normal.v.X + (clipPointy1 - planePointy1) * normal.v.Y;

                                    var c2 = Microsoft.Xna.Framework.Vector2.Zero.$clone();
                                    c2.X = (clipPointx1 - radiusA * normal.v.X) + (clipPointx1 + (radiusB - value1) * normal.v.X);
                                    c2.Y = (clipPointy1 - radiusA * normal.v.Y) + (clipPointy1 + (radiusB - value1) * normal.v.Y);

                                    points.v.setItem(i1, Microsoft.Xna.Framework.Vector2.op_Multiply$2(0.5, c2.$clone()));
                                }
                                normal.v = Microsoft.Xna.Framework.Vector2.op_Multiply$1(normal.v.$clone(), -1);
                            }
                            break;
                        default: 
                            normal.v = Microsoft.Xna.Framework.Vector2.UnitY.$clone();
                            break;
                    }
                },
                GetPointStates: function (state1, state2, manifold1, manifold2) {
                    state1.v = new (FarseerPhysics.Common.FixedArray2$1(FarseerPhysics.Collision.PointState))();
                    state2.v = new (FarseerPhysics.Common.FixedArray2$1(FarseerPhysics.Collision.PointState))();

                    for (var i = 0; i < manifold1.v.PointCount; i = (i + 1) | 0) {
                        var id = manifold1.v.Points.getItem(i).$clone().Id.$clone();

                        state1.v.setItem(i, FarseerPhysics.Collision.PointState.Remove);

                        for (var j = 0; j < manifold2.v.PointCount; j = (j + 1) | 0) {
                            if (manifold2.v.Points.getItem(j).$clone().Id.Key === id.Key) {
                                state1.v.setItem(i, FarseerPhysics.Collision.PointState.Persist);
                                break;
                            }
                        }
                    }

                    for (var i1 = 0; i1 < manifold2.v.PointCount; i1 = (i1 + 1) | 0) {
                        var id1 = manifold2.v.Points.getItem(i1).$clone().Id.$clone();

                        state2.v.setItem(i1, FarseerPhysics.Collision.PointState.Add);

                        for (var j1 = 0; j1 < manifold1.v.PointCount; j1 = (j1 + 1) | 0) {
                            if (manifold1.v.Points.getItem(j1).$clone().Id.Key === id1.Key) {
                                state2.v.setItem(i1, FarseerPhysics.Collision.PointState.Persist);
                                break;
                            }
                        }
                    }
                },
                /**
                 * @static
                 * @public
                 * @this FarseerPhysics.Collision.Collision
                 * @memberof FarseerPhysics.Collision.Collision
                 * @param   {FarseerPhysics.Collision.Manifold}              manifold    
                 * @param   {FarseerPhysics.Collision.Shapes.CircleShape}    circleA     
                 * @param   {FarseerPhysics.Common.Transform}                xfA         
                 * @param   {FarseerPhysics.Collision.Shapes.CircleShape}    circleB     
                 * @param   {FarseerPhysics.Common.Transform}                xfB
                 * @return  {void}
                 */
                CollideCircles: function (manifold, circleA, xfA, circleB, xfB) {
                    manifold.v.PointCount = 0;

                    var pAx = xfA.v.Position.X + xfA.v.R.Col1.X * circleA.Position.X + xfA.v.R.Col2.X * circleA.Position.Y;
                    var pAy = xfA.v.Position.Y + xfA.v.R.Col1.Y * circleA.Position.X + xfA.v.R.Col2.Y * circleA.Position.Y;
                    var pBx = xfB.v.Position.X + xfB.v.R.Col1.X * circleB.Position.X + xfB.v.R.Col2.X * circleB.Position.Y;
                    var pBy = xfB.v.Position.Y + xfB.v.R.Col1.Y * circleB.Position.X + xfB.v.R.Col2.Y * circleB.Position.Y;

                    var distSqr = (pBx - pAx) * (pBx - pAx) + (pBy - pAy) * (pBy - pAy);
                    var radius = circleA.Radius + circleB.Radius;
                    if (distSqr > radius * radius) {
                        return;
                    }

                    manifold.v.Type = FarseerPhysics.Collision.ManifoldType.Circles;
                    manifold.v.LocalPoint = circleA.Position.$clone();
                    manifold.v.LocalNormal = Microsoft.Xna.Framework.Vector2.Zero.$clone();
                    manifold.v.PointCount = 1;

                    var p0 = manifold.v.Points.getItem(0).$clone();

                    p0.LocalPoint = circleB.Position.$clone();
                    p0.Id.Key = 0;

                    manifold.v.Points.setItem(0, p0.$clone());
                },
                /**
                 * Compute the collision manifold between a polygon and a circle.
                 *
                 * @static
                 * @public
                 * @this FarseerPhysics.Collision.Collision
                 * @memberof FarseerPhysics.Collision.Collision
                 * @param   {FarseerPhysics.Collision.Manifold}               manifold      The manifold.
                 * @param   {FarseerPhysics.Collision.Shapes.PolygonShape}    polygonA      The polygon A.
                 * @param   {FarseerPhysics.Common.Transform}                 transformA    The transform of A.
                 * @param   {FarseerPhysics.Collision.Shapes.CircleShape}     circleB       The circle B.
                 * @param   {FarseerPhysics.Common.Transform}                 transformB    The transform of B.
                 * @return  {void}
                 */
                CollidePolygonAndCircle: function (manifold, polygonA, transformA, circleB, transformB) {
                    manifold.v.PointCount = 0;

                    var c = new Microsoft.Xna.Framework.Vector2.$ctor2(transformB.v.Position.X + transformB.v.R.Col1.X * circleB.Position.X + transformB.v.R.Col2.X * circleB.Position.Y, transformB.v.Position.Y + transformB.v.R.Col1.Y * circleB.Position.X + transformB.v.R.Col2.Y * circleB.Position.Y);
                    var cLocal = new Microsoft.Xna.Framework.Vector2.$ctor2((c.X - transformA.v.Position.X) * transformA.v.R.Col1.X + (c.Y - transformA.v.Position.Y) * transformA.v.R.Col1.Y, (c.X - transformA.v.Position.X) * transformA.v.R.Col2.X + (c.Y - transformA.v.Position.Y) * transformA.v.R.Col2.Y);

                    var normalIndex = 0;
                    var separation = -3.40282347E+38;
                    var radius = polygonA.Radius + circleB.Radius;
                    var vertexCount = polygonA.Vertices.Count;

                    for (var i = 0; i < vertexCount; i = (i + 1) | 0) {
                        var value1 = polygonA.Normals.getItem(i).$clone();
                        var value2 = Microsoft.Xna.Framework.Vector2.op_Subtraction(cLocal.$clone(), polygonA.Vertices.getItem(i).$clone());
                        var s = value1.X * value2.X + value1.Y * value2.Y;

                        if (s > radius) {
                            return;
                        }

                        if (s > separation) {
                            separation = s;
                            normalIndex = i;
                        }
                    }

                    var vertIndex1 = normalIndex;
                    var vertIndex2 = ((vertIndex1 + 1) | 0) < vertexCount ? ((vertIndex1 + 1) | 0) : 0;
                    var v1 = polygonA.Vertices.getItem(vertIndex1).$clone();
                    var v2 = polygonA.Vertices.getItem(vertIndex2).$clone();

                    if (separation < FarseerPhysics.Settings.Epsilon) {
                        manifold.v.PointCount = 1;
                        manifold.v.Type = FarseerPhysics.Collision.ManifoldType.FaceA;
                        manifold.v.LocalNormal = polygonA.Normals.getItem(normalIndex).$clone();
                        manifold.v.LocalPoint = Microsoft.Xna.Framework.Vector2.op_Multiply$2(0.5, (Microsoft.Xna.Framework.Vector2.op_Addition(v1.$clone(), v2.$clone())));

                        var p0 = manifold.v.Points.getItem(0).$clone();

                        p0.LocalPoint = circleB.Position.$clone();
                        p0.Id.Key = 0;

                        manifold.v.Points.setItem(0, p0.$clone());

                        return;
                    }

                    var u1 = (cLocal.X - v1.X) * (v2.X - v1.X) + (cLocal.Y - v1.Y) * (v2.Y - v1.Y);
                    var u2 = (cLocal.X - v2.X) * (v1.X - v2.X) + (cLocal.Y - v2.Y) * (v1.Y - v2.Y);

                    if (u1 <= 0.0) {
                        var r = (cLocal.X - v1.X) * (cLocal.X - v1.X) + (cLocal.Y - v1.Y) * (cLocal.Y - v1.Y);
                        if (r > radius * radius) {
                            return;
                        }

                        manifold.v.PointCount = 1;
                        manifold.v.Type = FarseerPhysics.Collision.ManifoldType.FaceA;
                        manifold.v.LocalNormal = Microsoft.Xna.Framework.Vector2.op_Subtraction(cLocal.$clone(), v1.$clone());
                        var factor = 1.0 / Math.sqrt(manifold.v.LocalNormal.X * manifold.v.LocalNormal.X + manifold.v.LocalNormal.Y * manifold.v.LocalNormal.Y);
                        manifold.v.LocalNormal.X = manifold.v.LocalNormal.X * factor;
                        manifold.v.LocalNormal.Y = manifold.v.LocalNormal.Y * factor;
                        manifold.v.LocalPoint = v1.$clone();

                        var p0b = manifold.v.Points.getItem(0).$clone();

                        p0b.LocalPoint = circleB.Position.$clone();
                        p0b.Id.Key = 0;

                        manifold.v.Points.setItem(0, p0b.$clone());
                    } else if (u2 <= 0.0) {
                        var r1 = (cLocal.X - v2.X) * (cLocal.X - v2.X) + (cLocal.Y - v2.Y) * (cLocal.Y - v2.Y);
                        if (r1 > radius * radius) {
                            return;
                        }

                        manifold.v.PointCount = 1;
                        manifold.v.Type = FarseerPhysics.Collision.ManifoldType.FaceA;
                        manifold.v.LocalNormal = Microsoft.Xna.Framework.Vector2.op_Subtraction(cLocal.$clone(), v2.$clone());
                        var factor1 = 1.0 / Math.sqrt(manifold.v.LocalNormal.X * manifold.v.LocalNormal.X + manifold.v.LocalNormal.Y * manifold.v.LocalNormal.Y);
                        manifold.v.LocalNormal.X = manifold.v.LocalNormal.X * factor1;
                        manifold.v.LocalNormal.Y = manifold.v.LocalNormal.Y * factor1;
                        manifold.v.LocalPoint = v2.$clone();

                        var p0c = manifold.v.Points.getItem(0).$clone();

                        p0c.LocalPoint = circleB.Position.$clone();
                        p0c.Id.Key = 0;

                        manifold.v.Points.setItem(0, p0c.$clone());
                    } else {
                        var faceCenter = Microsoft.Xna.Framework.Vector2.op_Multiply$2(0.5, (Microsoft.Xna.Framework.Vector2.op_Addition(v1.$clone(), v2.$clone())));
                        var value11 = Microsoft.Xna.Framework.Vector2.op_Subtraction(cLocal.$clone(), faceCenter.$clone());
                        var value21 = polygonA.Normals.getItem(vertIndex1).$clone();
                        var separation2 = value11.X * value21.X + value11.Y * value21.Y;
                        if (separation2 > radius) {
                            return;
                        }

                        manifold.v.PointCount = 1;
                        manifold.v.Type = FarseerPhysics.Collision.ManifoldType.FaceA;
                        manifold.v.LocalNormal = polygonA.Normals.getItem(vertIndex1).$clone();
                        manifold.v.LocalPoint = faceCenter.$clone();

                        var p0d = manifold.v.Points.getItem(0).$clone();

                        p0d.LocalPoint = circleB.Position.$clone();
                        p0d.Id.Key = 0;

                        manifold.v.Points.setItem(0, p0d.$clone());
                    }
                },
                /**
                 * Compute the collision manifold between two polygons.
                 *
                 * @static
                 * @public
                 * @this FarseerPhysics.Collision.Collision
                 * @memberof FarseerPhysics.Collision.Collision
                 * @param   {FarseerPhysics.Collision.Manifold}               manifold      The manifold.
                 * @param   {FarseerPhysics.Collision.Shapes.PolygonShape}    polyA         The poly A.
                 * @param   {FarseerPhysics.Common.Transform}                 transformA    The transform A.
                 * @param   {FarseerPhysics.Collision.Shapes.PolygonShape}    polyB         The poly B.
                 * @param   {FarseerPhysics.Common.Transform}                 transformB    The transform B.
                 * @return  {void}
                 */
                CollidePolygons: function (manifold, polyA, transformA, polyB, transformB) {
                    manifold.v.PointCount = 0;
                    var totalRadius = polyA.Radius + polyB.Radius;

                    var edgeA = { v : 0 };
                    var separationA = FarseerPhysics.Collision.Collision.FindMaxSeparation(edgeA, polyA, transformA, polyB, transformB);
                    if (separationA > totalRadius) {
                        return;
                    }

                    var edgeB = { v : 0 };
                    var separationB = FarseerPhysics.Collision.Collision.FindMaxSeparation(edgeB, polyB, transformB, polyA, transformA);
                    if (separationB > totalRadius) {
                        return;
                    }

                    var poly1;
                    var poly2;
                    var xf1 = { v : new FarseerPhysics.Common.Transform() }, xf2 = { v : new FarseerPhysics.Common.Transform() };
                    var edge1;
                    var flip;
                    var k_relativeTol = 0.98;
                    var k_absoluteTol = 0.001;

                    if (separationB > k_relativeTol * separationA + k_absoluteTol) {
                        poly1 = polyB;
                        poly2 = polyA;
                        xf1.v = transformB.v.$clone();
                        xf2.v = transformA.v.$clone();
                        edge1 = edgeB.v;
                        manifold.v.Type = FarseerPhysics.Collision.ManifoldType.FaceB;
                        flip = true;
                    } else {
                        poly1 = polyA;
                        poly2 = polyB;
                        xf1.v = transformA.v.$clone();
                        xf2.v = transformB.v.$clone();
                        edge1 = edgeA.v;
                        manifold.v.Type = FarseerPhysics.Collision.ManifoldType.FaceA;
                        flip = false;
                    }

                    var incidentEdge = { v : new (FarseerPhysics.Common.FixedArray2$1(FarseerPhysics.Collision.ClipVertex))() };
                    FarseerPhysics.Collision.Collision.FindIncidentEdge$1(incidentEdge, poly1, xf1, edge1, poly2, xf2);

                    var count1 = poly1.Vertices.Count;

                    var iv1 = edge1;
                    var iv2 = ((edge1 + 1) | 0) < count1 ? ((edge1 + 1) | 0) : 0;

                    var v11 = poly1.Vertices.getItem(iv1).$clone();
                    var v12 = poly1.Vertices.getItem(iv2).$clone();

                    var localTangentX = v12.X - v11.X;
                    var localTangentY = v12.Y - v11.Y;

                    var factor = 1.0 / Math.sqrt(localTangentX * localTangentX + localTangentY * localTangentY);
                    localTangentX = localTangentX * factor;
                    localTangentY = localTangentY * factor;

                    var localNormal = new Microsoft.Xna.Framework.Vector2.$ctor2(localTangentY, -localTangentX);
                    var planePoint = Microsoft.Xna.Framework.Vector2.op_Multiply$2(0.5, (Microsoft.Xna.Framework.Vector2.op_Addition(v11.$clone(), v12.$clone())));

                    var tangent = new Microsoft.Xna.Framework.Vector2.$ctor2(xf1.v.R.Col1.X * localTangentX + xf1.v.R.Col2.X * localTangentY, xf1.v.R.Col1.Y * localTangentX + xf1.v.R.Col2.Y * localTangentY);
                    var normalx = tangent.Y;
                    var normaly = -tangent.X;

                    v11 = new Microsoft.Xna.Framework.Vector2.$ctor2(xf1.v.Position.X + xf1.v.R.Col1.X * v11.X + xf1.v.R.Col2.X * v11.Y, xf1.v.Position.Y + xf1.v.R.Col1.Y * v11.X + xf1.v.R.Col2.Y * v11.Y);
                    v12 = new Microsoft.Xna.Framework.Vector2.$ctor2(xf1.v.Position.X + xf1.v.R.Col1.X * v12.X + xf1.v.R.Col2.X * v12.Y, xf1.v.Position.Y + xf1.v.R.Col1.Y * v12.X + xf1.v.R.Col2.Y * v12.Y);

                    var frontOffset = normalx * v11.X + normaly * v11.Y;

                    var sideOffset1 = -(tangent.X * v11.X + tangent.Y * v11.Y) + totalRadius;
                    var sideOffset2 = tangent.X * v12.X + tangent.Y * v12.Y + totalRadius;

                    var clipPoints1 = { v : new (FarseerPhysics.Common.FixedArray2$1(FarseerPhysics.Collision.ClipVertex))() };
                    var clipPoints2 = { v : new (FarseerPhysics.Common.FixedArray2$1(FarseerPhysics.Collision.ClipVertex))() };

                    var np = FarseerPhysics.Collision.Collision.ClipSegmentToLine(clipPoints1, incidentEdge, Microsoft.Xna.Framework.Vector2.op_UnaryNegation(tangent.$clone()), sideOffset1, iv1);

                    if (np < 2) {
                        return;
                    }

                    np = FarseerPhysics.Collision.Collision.ClipSegmentToLine(clipPoints2, clipPoints1, tangent.$clone(), sideOffset2, iv2);

                    if (np < 2) {
                        return;
                    }

                    manifold.v.LocalNormal = localNormal.$clone();
                    manifold.v.LocalPoint = planePoint.$clone();

                    var pointCount = 0;
                    for (var i = 0; i < FarseerPhysics.Settings.MaxManifoldPoints; i = (i + 1) | 0) {
                        var value = clipPoints2.v.getItem(i).$clone().V.$clone();
                        var separation = normalx * value.X + normaly * value.Y - frontOffset;

                        if (separation <= totalRadius) {
                            var cp = manifold.v.Points.getItem(pointCount).$clone();
                            var tmp = clipPoints2.v.getItem(i).$clone().V.$clone();
                            var tmp1X = tmp.X - xf2.v.Position.X;
                            var tmp1Y = tmp.Y - xf2.v.Position.Y;
                            cp.LocalPoint.X = tmp1X * xf2.v.R.Col1.X + tmp1Y * xf2.v.R.Col1.Y;
                            cp.LocalPoint.Y = tmp1X * xf2.v.R.Col2.X + tmp1Y * xf2.v.R.Col2.Y;
                            cp.Id = clipPoints2.v.getItem(i).$clone().ID.$clone();

                            if (flip) {
                                var cf = cp.Id.Features.$clone();
                                cp.Id.Features.IndexA = cf.IndexB;
                                cp.Id.Features.IndexB = cf.IndexA;
                                cp.Id.Features.TypeA = cf.TypeB;
                                cp.Id.Features.TypeB = cf.TypeA;
                            }

                            manifold.v.Points.setItem(pointCount, cp.$clone());

                            pointCount = (pointCount + 1) | 0;
                        }
                    }

                    manifold.v.PointCount = pointCount;
                },
                /**
                 * Compute contact points for edge versus circle.
                 This accounts for edge connectivity.
                 *
                 * @static
                 * @public
                 * @this FarseerPhysics.Collision.Collision
                 * @memberof FarseerPhysics.Collision.Collision
                 * @param   {FarseerPhysics.Collision.Manifold}              manifold      The manifold.
                 * @param   {FarseerPhysics.Collision.Shapes.EdgeShape}      edgeA         The edge A.
                 * @param   {FarseerPhysics.Common.Transform}                transformA    The transform A.
                 * @param   {FarseerPhysics.Collision.Shapes.CircleShape}    circleB       The circle B.
                 * @param   {FarseerPhysics.Common.Transform}                transformB    The transform B.
                 * @return  {void}
                 */
                CollideEdgeAndCircle: function (manifold, edgeA, transformA, circleB, transformB) {
                    manifold.v.PointCount = 0;

                    var Q = FarseerPhysics.Common.MathUtils.MultiplyT$2(transformA, FarseerPhysics.Common.MathUtils.Multiply$3(transformB, Bridge.ref(circleB, "_position")));

                    var A = edgeA.Vertex1.$clone(), B = edgeA.Vertex2.$clone();
                    var e = { v : Microsoft.Xna.Framework.Vector2.op_Subtraction(B.$clone(), A.$clone()) };

                    var u = Microsoft.Xna.Framework.Vector2.Dot(e.v.$clone(), Microsoft.Xna.Framework.Vector2.op_Subtraction(B.$clone(), Q.$clone()));
                    var v = Microsoft.Xna.Framework.Vector2.Dot(e.v.$clone(), Microsoft.Xna.Framework.Vector2.op_Subtraction(Q.$clone(), A.$clone()));

                    var radius = edgeA.Radius + circleB.Radius;

                    var cf = new FarseerPhysics.Collision.ContactFeature();
                    cf.IndexB = 0;
                    cf.TypeB = FarseerPhysics.Collision.ContactFeatureType.Vertex;

                    var P = new Microsoft.Xna.Framework.Vector2(), d = { v : new Microsoft.Xna.Framework.Vector2() };

                    if (v <= 0.0) {
                        P = A.$clone();
                        d.v = Microsoft.Xna.Framework.Vector2.op_Subtraction(Q.$clone(), P.$clone());
                        var dd = { };
                        Microsoft.Xna.Framework.Vector2.Dot$1(d, d, dd);
                        if (dd.v > radius * radius) {
                            return;
                        }

                        if (edgeA.HasVertex0) {
                            var A1 = edgeA.Vertex0.$clone();
                            var B1 = A.$clone();
                            var e1 = Microsoft.Xna.Framework.Vector2.op_Subtraction(B1.$clone(), A1.$clone());
                            var u1 = Microsoft.Xna.Framework.Vector2.Dot(e1.$clone(), Microsoft.Xna.Framework.Vector2.op_Subtraction(B1.$clone(), Q.$clone()));

                            if (u1 > 0.0) {
                                return;
                            }
                        }

                        cf.IndexA = 0;
                        cf.TypeA = FarseerPhysics.Collision.ContactFeatureType.Vertex;
                        manifold.v.PointCount = 1;
                        manifold.v.Type = FarseerPhysics.Collision.ManifoldType.Circles;
                        manifold.v.LocalNormal = Microsoft.Xna.Framework.Vector2.Zero.$clone();
                        manifold.v.LocalPoint = P.$clone();
                        var mp = new FarseerPhysics.Collision.ManifoldPoint();
                        mp.Id.Key = 0;
                        mp.Id.Features = cf.$clone();
                        mp.LocalPoint = circleB.Position.$clone();
                        manifold.v.Points.setItem(0, mp.$clone());
                        return;
                    }

                    if (u <= 0.0) {
                        P = B.$clone();
                        d.v = Microsoft.Xna.Framework.Vector2.op_Subtraction(Q.$clone(), P.$clone());
                        var dd1 = { };
                        Microsoft.Xna.Framework.Vector2.Dot$1(d, d, dd1);
                        if (dd1.v > radius * radius) {
                            return;
                        }

                        if (edgeA.HasVertex3) {
                            var B2 = edgeA.Vertex3.$clone();
                            var A2 = B.$clone();
                            var e2 = Microsoft.Xna.Framework.Vector2.op_Subtraction(B2.$clone(), A2.$clone());
                            var v2 = Microsoft.Xna.Framework.Vector2.Dot(e2.$clone(), Microsoft.Xna.Framework.Vector2.op_Subtraction(Q.$clone(), A2.$clone()));

                            if (v2 > 0.0) {
                                return;
                            }
                        }

                        cf.IndexA = 1;
                        cf.TypeA = FarseerPhysics.Collision.ContactFeatureType.Vertex;
                        manifold.v.PointCount = 1;
                        manifold.v.Type = FarseerPhysics.Collision.ManifoldType.Circles;
                        manifold.v.LocalNormal = Microsoft.Xna.Framework.Vector2.Zero.$clone();
                        manifold.v.LocalPoint = P.$clone();
                        var mp1 = new FarseerPhysics.Collision.ManifoldPoint();
                        mp1.Id.Key = 0;
                        mp1.Id.Features = cf.$clone();
                        mp1.LocalPoint = circleB.Position.$clone();
                        manifold.v.Points.setItem(0, mp1.$clone());
                        return;
                    }

                    var den = { };
                    Microsoft.Xna.Framework.Vector2.Dot$1(e, e, den);
                    System.Diagnostics.Debug.Assert(den.v > 0.0);
                    P = Microsoft.Xna.Framework.Vector2.op_Multiply$2((1.0 / den.v), (Microsoft.Xna.Framework.Vector2.op_Addition(Microsoft.Xna.Framework.Vector2.op_Multiply$2(u, A.$clone()), Microsoft.Xna.Framework.Vector2.op_Multiply$2(v, B.$clone()))));
                    d.v = Microsoft.Xna.Framework.Vector2.op_Subtraction(Q.$clone(), P.$clone());
                    var dd2 = { };
                    Microsoft.Xna.Framework.Vector2.Dot$1(d, d, dd2);
                    if (dd2.v > radius * radius) {
                        return;
                    }

                    var n = new Microsoft.Xna.Framework.Vector2.$ctor2(-e.v.Y, e.v.X);
                    if (Microsoft.Xna.Framework.Vector2.Dot(n.$clone(), Microsoft.Xna.Framework.Vector2.op_Subtraction(Q.$clone(), A.$clone())) < 0.0) {
                        n = new Microsoft.Xna.Framework.Vector2.$ctor2(-n.X, -n.Y);
                    }
                    n.Normalize();

                    cf.IndexA = 0;
                    cf.TypeA = FarseerPhysics.Collision.ContactFeatureType.Face;
                    manifold.v.PointCount = 1;
                    manifold.v.Type = FarseerPhysics.Collision.ManifoldType.FaceA;
                    manifold.v.LocalNormal = n.$clone();
                    manifold.v.LocalPoint = A.$clone();
                    var mp2 = new FarseerPhysics.Collision.ManifoldPoint();
                    mp2.Id.Key = 0;
                    mp2.Id.Features = cf.$clone();
                    mp2.LocalPoint = circleB.Position.$clone();
                    manifold.v.Points.setItem(0, mp2.$clone());
                },
                /**
                 * Collides and edge and a polygon, taking into account edge adjacency.
                 *
                 * @static
                 * @public
                 * @this FarseerPhysics.Collision.Collision
                 * @memberof FarseerPhysics.Collision.Collision
                 * @param   {FarseerPhysics.Collision.Manifold}               manifold    The manifold.
                 * @param   {FarseerPhysics.Collision.Shapes.EdgeShape}       edgeA       The edge A.
                 * @param   {FarseerPhysics.Common.Transform}                 xfA         The xf A.
                 * @param   {FarseerPhysics.Collision.Shapes.PolygonShape}    polygonB    The polygon B.
                 * @param   {FarseerPhysics.Common.Transform}                 xfB         The xf B.
                 * @return  {void}
                 */
                CollideEdgeAndPolygon: function (manifold, edgeA, xfA, polygonB, xfB) {
                    var $t, $t1, $t2, $t3, $t4, $t5;
                    FarseerPhysics.Common.MathUtils.MultiplyT$5(xfA, xfB, Bridge.ref(FarseerPhysics.Collision.Collision, "_xf"));

                    FarseerPhysics.Collision.Collision._edgeA.V0 = edgeA.Vertex0.$clone();
                    FarseerPhysics.Collision.Collision._edgeA.V1 = edgeA.Vertex1.$clone();
                    FarseerPhysics.Collision.Collision._edgeA.V2 = edgeA.Vertex2.$clone();
                    FarseerPhysics.Collision.Collision._edgeA.V3 = edgeA.Vertex3.$clone();
                    var e = Microsoft.Xna.Framework.Vector2.op_Subtraction(FarseerPhysics.Collision.Collision._edgeA.V2.$clone(), FarseerPhysics.Collision.Collision._edgeA.V1.$clone());

                    FarseerPhysics.Collision.Collision._edgeA.Normal = new Microsoft.Xna.Framework.Vector2.$ctor2(e.Y, -e.X);
                    FarseerPhysics.Collision.Collision._edgeA.Normal.Normalize();
                    FarseerPhysics.Collision.Collision._edgeA.HasVertex0 = edgeA.HasVertex0;
                    FarseerPhysics.Collision.Collision._edgeA.HasVertex3 = edgeA.HasVertex3;

                    ($t = FarseerPhysics.Collision.Collision._proxyA.Vertices)[System.Array.index(0, $t)] = FarseerPhysics.Collision.Collision._edgeA.V1.$clone();
                    ($t1 = FarseerPhysics.Collision.Collision._proxyA.Vertices)[System.Array.index(1, $t1)] = FarseerPhysics.Collision.Collision._edgeA.V2.$clone();
                    ($t2 = FarseerPhysics.Collision.Collision._proxyA.Normals)[System.Array.index(0, $t2)] = FarseerPhysics.Collision.Collision._edgeA.Normal.$clone();
                    ($t3 = FarseerPhysics.Collision.Collision._proxyA.Normals)[System.Array.index(1, $t3)] = Microsoft.Xna.Framework.Vector2.op_UnaryNegation(FarseerPhysics.Collision.Collision._edgeA.Normal.$clone());
                    FarseerPhysics.Collision.Collision._proxyA.Centroid = Microsoft.Xna.Framework.Vector2.op_Multiply$2(0.5, (Microsoft.Xna.Framework.Vector2.op_Addition(FarseerPhysics.Collision.Collision._edgeA.V1.$clone(), FarseerPhysics.Collision.Collision._edgeA.V2.$clone())));
                    FarseerPhysics.Collision.Collision._proxyA.Count = 2;

                    FarseerPhysics.Collision.Collision._proxyB.Count = polygonB.Vertices.Count;
                    FarseerPhysics.Collision.Collision._proxyB.Centroid = FarseerPhysics.Common.MathUtils.Multiply$3(Bridge.ref(FarseerPhysics.Collision.Collision, "_xf"), Bridge.ref(polygonB.MassData, "Centroid"));
                    for (var i = 0; i < polygonB.Vertices.Count; i = (i + 1) | 0) {
                        ($t4 = FarseerPhysics.Collision.Collision._proxyB.Vertices)[System.Array.index(i, $t4)] = FarseerPhysics.Common.MathUtils.Multiply$2(Bridge.ref(FarseerPhysics.Collision.Collision, "_xf"), polygonB.Vertices.getItem(i).$clone());
                        ($t5 = FarseerPhysics.Collision.Collision._proxyB.Normals)[System.Array.index(i, $t5)] = FarseerPhysics.Common.MathUtils.Multiply(Bridge.ref(FarseerPhysics.Collision.Collision._xf, "R"), polygonB.Normals.getItem(i).$clone());
                    }

                    FarseerPhysics.Collision.Collision._radius = 0.02;

                    FarseerPhysics.Collision.Collision._limit11 = Microsoft.Xna.Framework.Vector2.Zero.$clone();
                    FarseerPhysics.Collision.Collision._limit12 = Microsoft.Xna.Framework.Vector2.Zero.$clone();
                    FarseerPhysics.Collision.Collision._limit21 = Microsoft.Xna.Framework.Vector2.Zero.$clone();
                    FarseerPhysics.Collision.Collision._limit22 = Microsoft.Xna.Framework.Vector2.Zero.$clone();

                    manifold.v.PointCount = 0;

                    var v0 = FarseerPhysics.Collision.Collision._edgeA.V0.$clone();
                    var v1 = FarseerPhysics.Collision.Collision._edgeA.V1.$clone();
                    var v2 = FarseerPhysics.Collision.Collision._edgeA.V2.$clone();
                    var v3 = FarseerPhysics.Collision.Collision._edgeA.V3.$clone();

                    var centerB = FarseerPhysics.Collision.Collision._proxyB.Centroid.$clone();
                    if (FarseerPhysics.Collision.Collision._edgeA.HasVertex0) {
                        var e0 = Microsoft.Xna.Framework.Vector2.op_Subtraction(v1.$clone(), v0.$clone());
                        var e1 = Microsoft.Xna.Framework.Vector2.op_Subtraction(v2.$clone(), v1.$clone());
                        var n0 = new Microsoft.Xna.Framework.Vector2.$ctor2(e0.Y, -e0.X);
                        var n1 = new Microsoft.Xna.Framework.Vector2.$ctor2(e1.Y, -e1.X);
                        n0.Normalize();
                        n1.Normalize();

                        var convex = FarseerPhysics.Common.MathUtils.Cross$2(n0.$clone(), n1.$clone()) >= 0.0;
                        var front0 = Microsoft.Xna.Framework.Vector2.Dot(n0.$clone(), Microsoft.Xna.Framework.Vector2.op_Subtraction(centerB.$clone(), v0.$clone())) >= 0.0;
                        var front1 = Microsoft.Xna.Framework.Vector2.Dot(n1.$clone(), Microsoft.Xna.Framework.Vector2.op_Subtraction(centerB.$clone(), v1.$clone())) >= 0.0;

                        if (convex) {
                            if (front0 || front1) {
                                FarseerPhysics.Collision.Collision._limit11 = n1.$clone();
                                FarseerPhysics.Collision.Collision._limit12 = n0.$clone();
                            } else {
                                FarseerPhysics.Collision.Collision._limit11 = Microsoft.Xna.Framework.Vector2.op_UnaryNegation(n1.$clone());
                                FarseerPhysics.Collision.Collision._limit12 = Microsoft.Xna.Framework.Vector2.op_UnaryNegation(n0.$clone());
                            }
                        } else {
                            if (front0 && front1) {
                                FarseerPhysics.Collision.Collision._limit11 = n0.$clone();
                                FarseerPhysics.Collision.Collision._limit12 = n1.$clone();
                            } else {
                                FarseerPhysics.Collision.Collision._limit11 = Microsoft.Xna.Framework.Vector2.op_UnaryNegation(n0.$clone());
                                FarseerPhysics.Collision.Collision._limit12 = Microsoft.Xna.Framework.Vector2.op_UnaryNegation(n1.$clone());
                            }
                        }
                    } else {
                        FarseerPhysics.Collision.Collision._limit11 = Microsoft.Xna.Framework.Vector2.Zero.$clone();
                        FarseerPhysics.Collision.Collision._limit12 = Microsoft.Xna.Framework.Vector2.Zero.$clone();
                    }

                    if (FarseerPhysics.Collision.Collision._edgeA.HasVertex3) {
                        var e11 = Microsoft.Xna.Framework.Vector2.op_Subtraction(v2.$clone(), v1.$clone());
                        var e2 = Microsoft.Xna.Framework.Vector2.op_Subtraction(v3.$clone(), v2.$clone());
                        var n11 = new Microsoft.Xna.Framework.Vector2.$ctor2(e11.Y, -e11.X);
                        var n2 = new Microsoft.Xna.Framework.Vector2.$ctor2(e2.Y, -e2.X);
                        n11.Normalize();
                        n2.Normalize();

                        var convex1 = FarseerPhysics.Common.MathUtils.Cross$2(n11.$clone(), n2.$clone()) >= 0.0;
                        var front11 = Microsoft.Xna.Framework.Vector2.Dot(n11.$clone(), Microsoft.Xna.Framework.Vector2.op_Subtraction(centerB.$clone(), v1.$clone())) >= 0.0;
                        var front2 = Microsoft.Xna.Framework.Vector2.Dot(n2.$clone(), Microsoft.Xna.Framework.Vector2.op_Subtraction(centerB.$clone(), v2.$clone())) >= 0.0;

                        if (convex1) {
                            if (front11 || front2) {
                                FarseerPhysics.Collision.Collision._limit21 = n2.$clone();
                                FarseerPhysics.Collision.Collision._limit22 = n11.$clone();
                            } else {
                                FarseerPhysics.Collision.Collision._limit21 = Microsoft.Xna.Framework.Vector2.op_UnaryNegation(n2.$clone());
                                FarseerPhysics.Collision.Collision._limit22 = Microsoft.Xna.Framework.Vector2.op_UnaryNegation(n11.$clone());
                            }
                        } else {
                            if (front11 && front2) {
                                FarseerPhysics.Collision.Collision._limit21 = n11.$clone();
                                FarseerPhysics.Collision.Collision._limit22 = n2.$clone();
                            } else {
                                FarseerPhysics.Collision.Collision._limit21 = Microsoft.Xna.Framework.Vector2.op_UnaryNegation(n11.$clone());
                                FarseerPhysics.Collision.Collision._limit22 = Microsoft.Xna.Framework.Vector2.op_UnaryNegation(n2.$clone());
                            }
                        }
                    } else {
                        FarseerPhysics.Collision.Collision._limit21 = Microsoft.Xna.Framework.Vector2.Zero.$clone();
                        FarseerPhysics.Collision.Collision._limit22 = Microsoft.Xna.Framework.Vector2.Zero.$clone();
                    }


                    var edgeAxis = FarseerPhysics.Collision.Collision.ComputeEdgeSeparation();

                    if (edgeAxis.Type === FarseerPhysics.Collision.EPAxisType.Unknown) {
                        return;
                    }

                    if (edgeAxis.Separation > FarseerPhysics.Collision.Collision._radius) {
                        return;
                    }

                    var polygonAxis = FarseerPhysics.Collision.Collision.ComputePolygonSeparation();
                    if (polygonAxis.Type !== FarseerPhysics.Collision.EPAxisType.Unknown && polygonAxis.Separation > FarseerPhysics.Collision.Collision._radius) {
                        return;
                    }

                    var k_relativeTol = 0.98;
                    var k_absoluteTol = 0.001;

                    var primaryAxis = new FarseerPhysics.Collision.EPAxis();
                    if (polygonAxis.Type === FarseerPhysics.Collision.EPAxisType.Unknown) {
                        primaryAxis = edgeAxis.$clone();
                    } else if (polygonAxis.Separation > k_relativeTol * edgeAxis.Separation + k_absoluteTol) {
                        primaryAxis = polygonAxis.$clone();
                    } else {
                        primaryAxis = edgeAxis.$clone();
                    }

                    var proxy1;
                    var proxy2;
                    var incidentEdge = { v : new (FarseerPhysics.Common.FixedArray2$1(FarseerPhysics.Collision.ClipVertex))() };
                    if (primaryAxis.Type === FarseerPhysics.Collision.EPAxisType.EdgeA) {
                        proxy1 = FarseerPhysics.Collision.Collision._proxyA;
                        proxy2 = FarseerPhysics.Collision.Collision._proxyB;
                        manifold.v.Type = FarseerPhysics.Collision.ManifoldType.FaceA;
                    } else {
                        proxy1 = FarseerPhysics.Collision.Collision._proxyB;
                        proxy2 = FarseerPhysics.Collision.Collision._proxyA;
                        manifold.v.Type = FarseerPhysics.Collision.ManifoldType.FaceB;
                    }

                    var edge1 = primaryAxis.Index;

                    FarseerPhysics.Collision.Collision.FindIncidentEdge(incidentEdge, proxy1, primaryAxis.Index, proxy2);
                    var count1 = proxy1.Count;

                    var iv1 = edge1;
                    var iv2 = ((edge1 + 1) | 0) < count1 ? ((edge1 + 1) | 0) : 0;

                    var v11 = proxy1.Vertices[System.Array.index(iv1, proxy1.Vertices)].$clone();
                    var v12 = proxy1.Vertices[System.Array.index(iv2, proxy1.Vertices)].$clone();

                    var tangent = Microsoft.Xna.Framework.Vector2.op_Subtraction(v12.$clone(), v11.$clone());
                    tangent.Normalize();

                    var normal = { v : FarseerPhysics.Common.MathUtils.Cross(tangent.$clone(), 1.0) };
                    var planePoint = { v : Microsoft.Xna.Framework.Vector2.op_Multiply$2(0.5, (Microsoft.Xna.Framework.Vector2.op_Addition(v11.$clone(), v12.$clone()))) };

                    var frontOffset = Microsoft.Xna.Framework.Vector2.Dot(normal.v.$clone(), v11.$clone());

                    var sideOffset1 = -Microsoft.Xna.Framework.Vector2.Dot(tangent.$clone(), v11.$clone()) + FarseerPhysics.Collision.Collision._radius;
                    var sideOffset2 = Microsoft.Xna.Framework.Vector2.Dot(tangent.$clone(), v12.$clone()) + FarseerPhysics.Collision.Collision._radius;

                    var clipPoints1 = { v : new (FarseerPhysics.Common.FixedArray2$1(FarseerPhysics.Collision.ClipVertex))() };
                    var clipPoints2 = { v : new (FarseerPhysics.Common.FixedArray2$1(FarseerPhysics.Collision.ClipVertex))() };
                    var np;

                    np = FarseerPhysics.Collision.Collision.ClipSegmentToLine(clipPoints1, incidentEdge, Microsoft.Xna.Framework.Vector2.op_UnaryNegation(tangent.$clone()), sideOffset1, iv1);

                    if (np < FarseerPhysics.Settings.MaxManifoldPoints) {
                        return;
                    }

                    np = FarseerPhysics.Collision.Collision.ClipSegmentToLine(clipPoints2, clipPoints1, tangent.$clone(), sideOffset2, iv2);

                    if (np < FarseerPhysics.Settings.MaxManifoldPoints) {
                        return;
                    }

                    if (primaryAxis.Type === FarseerPhysics.Collision.EPAxisType.EdgeA) {
                        manifold.v.LocalNormal = normal.v.$clone();
                        manifold.v.LocalPoint = planePoint.v.$clone();
                    } else {
                        manifold.v.LocalNormal = FarseerPhysics.Common.MathUtils.MultiplyT$1(Bridge.ref(FarseerPhysics.Collision.Collision._xf, "R"), normal);
                        manifold.v.LocalPoint = FarseerPhysics.Common.MathUtils.MultiplyT$3(Bridge.ref(FarseerPhysics.Collision.Collision, "_xf"), planePoint);
                    }

                    var pointCount = 0;
                    for (var i1 = 0; i1 < FarseerPhysics.Settings.MaxManifoldPoints; i1 = (i1 + 1) | 0) {
                        var separation = Microsoft.Xna.Framework.Vector2.Dot(normal.v.$clone(), clipPoints2.v.getItem(i1).$clone().V.$clone()) - frontOffset;

                        if (separation <= FarseerPhysics.Collision.Collision._radius) {
                            var cp = manifold.v.Points.getItem(pointCount).$clone();

                            if (primaryAxis.Type === FarseerPhysics.Collision.EPAxisType.EdgeA) {
                                cp.LocalPoint = FarseerPhysics.Common.MathUtils.MultiplyT$2(Bridge.ref(FarseerPhysics.Collision.Collision, "_xf"), clipPoints2.v.getItem(i1).$clone().V.$clone());
                                cp.Id = clipPoints2.v.getItem(i1).$clone().ID.$clone();
                            } else {
                                cp.LocalPoint = clipPoints2.v.getItem(i1).$clone().V.$clone();
                                cp.Id.Features.TypeA = clipPoints2.v.getItem(i1).$clone().ID.Features.TypeB;
                                cp.Id.Features.TypeB = clipPoints2.v.getItem(i1).$clone().ID.Features.TypeA;
                                cp.Id.Features.IndexA = clipPoints2.v.getItem(i1).$clone().ID.Features.IndexB;
                                cp.Id.Features.IndexB = clipPoints2.v.getItem(i1).$clone().ID.Features.IndexA;
                            }

                            manifold.v.Points.setItem(pointCount, cp.$clone());

                            pointCount = (pointCount + 1) | 0;
                        }
                    }

                    manifold.v.PointCount = pointCount;

                },
                ComputeEdgeSeparation: function () {
                    var $t;
                    var bestAxis = new FarseerPhysics.Collision.EPAxis();
                    bestAxis.Type = FarseerPhysics.Collision.EPAxisType.Unknown;
                    bestAxis.Index = -1;
                    bestAxis.Separation = -3.40282347E+38;
                    FarseerPhysics.Collision.Collision._tmpNormals[System.Array.index(0, FarseerPhysics.Collision.Collision._tmpNormals)] = FarseerPhysics.Collision.Collision._edgeA.Normal.$clone();
                    FarseerPhysics.Collision.Collision._tmpNormals[System.Array.index(1, FarseerPhysics.Collision.Collision._tmpNormals)] = Microsoft.Xna.Framework.Vector2.op_UnaryNegation(FarseerPhysics.Collision.Collision._edgeA.Normal.$clone());

                    for (var i = 0; i < 2; i = (i + 1) | 0) {
                        var n = FarseerPhysics.Collision.Collision._tmpNormals[System.Array.index(i, FarseerPhysics.Collision.Collision._tmpNormals)].$clone();

                        var valid1 = FarseerPhysics.Common.MathUtils.Cross$2(n.$clone(), FarseerPhysics.Collision.Collision._limit11.$clone()) >= -0.03490659 && FarseerPhysics.Common.MathUtils.Cross$2(FarseerPhysics.Collision.Collision._limit12.$clone(), n.$clone()) >= -0.03490659;
                        var valid2 = FarseerPhysics.Common.MathUtils.Cross$2(n.$clone(), FarseerPhysics.Collision.Collision._limit21.$clone()) >= -0.03490659 && FarseerPhysics.Common.MathUtils.Cross$2(FarseerPhysics.Collision.Collision._limit22.$clone(), n.$clone()) >= -0.03490659;

                        if (valid1 === false || valid2 === false) {
                            continue;
                        }

                        var axis = new FarseerPhysics.Collision.EPAxis();
                        axis.Type = FarseerPhysics.Collision.EPAxisType.EdgeA;
                        axis.Index = i;
                        axis.Separation = FarseerPhysics.Settings.MaxFloat;

                        for (var j = 0; j < FarseerPhysics.Collision.Collision._proxyB.Count; j = (j + 1) | 0) {
                            var s = Microsoft.Xna.Framework.Vector2.Dot(n.$clone(), Microsoft.Xna.Framework.Vector2.op_Subtraction(($t = FarseerPhysics.Collision.Collision._proxyB.Vertices)[System.Array.index(j, $t)].$clone(), FarseerPhysics.Collision.Collision._edgeA.V1.$clone()));
                            if (s < axis.Separation) {
                                axis.Separation = s;
                            }
                        }

                        if (axis.Separation > FarseerPhysics.Collision.Collision._radius) {
                            return axis.$clone();
                        }

                        if (axis.Separation > bestAxis.Separation) {
                            bestAxis = axis.$clone();
                        }
                    }

                    return bestAxis.$clone();
                },
                ComputePolygonSeparation: function () {
                    var $t, $t1, $t2;
                    var axis = new FarseerPhysics.Collision.EPAxis();
                    axis.Type = FarseerPhysics.Collision.EPAxisType.Unknown;
                    axis.Index = -1;
                    axis.Separation = -3.40282347E+38;
                    for (var i = 0; i < FarseerPhysics.Collision.Collision._proxyB.Count; i = (i + 1) | 0) {
                        var n = Microsoft.Xna.Framework.Vector2.op_UnaryNegation(($t = FarseerPhysics.Collision.Collision._proxyB.Normals)[System.Array.index(i, $t)].$clone());

                        var valid1 = FarseerPhysics.Common.MathUtils.Cross$2(n.$clone(), FarseerPhysics.Collision.Collision._limit11.$clone()) >= -0.03490659 && FarseerPhysics.Common.MathUtils.Cross$2(FarseerPhysics.Collision.Collision._limit12.$clone(), n.$clone()) >= -0.03490659;
                        var valid2 = FarseerPhysics.Common.MathUtils.Cross$2(n.$clone(), FarseerPhysics.Collision.Collision._limit21.$clone()) >= -0.03490659 && FarseerPhysics.Common.MathUtils.Cross$2(FarseerPhysics.Collision.Collision._limit22.$clone(), n.$clone()) >= -0.03490659;

                        if (valid1 === false && valid2 === false) {
                            continue;
                        }

                        var s1 = Microsoft.Xna.Framework.Vector2.Dot(n.$clone(), Microsoft.Xna.Framework.Vector2.op_Subtraction(($t1 = FarseerPhysics.Collision.Collision._proxyB.Vertices)[System.Array.index(i, $t1)].$clone(), FarseerPhysics.Collision.Collision._edgeA.V1.$clone()));
                        var s2 = Microsoft.Xna.Framework.Vector2.Dot(n.$clone(), Microsoft.Xna.Framework.Vector2.op_Subtraction(($t2 = FarseerPhysics.Collision.Collision._proxyB.Vertices)[System.Array.index(i, $t2)].$clone(), FarseerPhysics.Collision.Collision._edgeA.V2.$clone()));
                        var s = Math.min(s1, s2);

                        if (s > FarseerPhysics.Collision.Collision._radius) {
                            axis.Type = FarseerPhysics.Collision.EPAxisType.EdgeB;
                            axis.Index = i;
                            axis.Separation = s;
                        }

                        if (s > axis.Separation) {
                            axis.Type = FarseerPhysics.Collision.EPAxisType.EdgeB;
                            axis.Index = i;
                            axis.Separation = s;
                        }
                    }

                    return axis.$clone();
                },
                FindIncidentEdge: function (c, proxy1, edge1, proxy2) {
                    var count2 = proxy2.Count;

                    System.Diagnostics.Debug.Assert(0 <= edge1 && edge1 < proxy1.Count);

                    var normal1 = proxy1.Normals[System.Array.index(edge1, proxy1.Normals)].$clone();

                    var index = 0;
                    var minDot = 3.40282347E+38;
                    for (var i = 0; i < count2; i = (i + 1) | 0) {
                        var dot = Microsoft.Xna.Framework.Vector2.Dot(normal1.$clone(), proxy2.Normals[System.Array.index(i, proxy2.Normals)].$clone());
                        if (dot < minDot) {
                            minDot = dot;
                            index = i;
                        }
                    }

                    var i1 = index;
                    var i2 = ((i1 + 1) | 0) < count2 ? ((i1 + 1) | 0) : 0;

                    var cTemp = new FarseerPhysics.Collision.ClipVertex();
                    cTemp.V = proxy2.Vertices[System.Array.index(i1, proxy2.Vertices)].$clone();
                    cTemp.ID.Features.IndexA = edge1 & 255;
                    cTemp.ID.Features.IndexB = i1 & 255;
                    cTemp.ID.Features.TypeA = FarseerPhysics.Collision.ContactFeatureType.Face;
                    cTemp.ID.Features.TypeB = FarseerPhysics.Collision.ContactFeatureType.Vertex;
                    c.v.setItem(0, cTemp.$clone());

                    cTemp.V = proxy2.Vertices[System.Array.index(i2, proxy2.Vertices)].$clone();
                    cTemp.ID.Features.IndexA = edge1 & 255;
                    cTemp.ID.Features.IndexB = i2 & 255;
                    cTemp.ID.Features.TypeA = FarseerPhysics.Collision.ContactFeatureType.Face;
                    cTemp.ID.Features.TypeB = FarseerPhysics.Collision.ContactFeatureType.Vertex;
                    c.v.setItem(1, cTemp.$clone());
                },
                FindIncidentEdge$1: function (c, poly1, xf1, edge1, poly2, xf2) {
                    c.v = new (FarseerPhysics.Common.FixedArray2$1(FarseerPhysics.Collision.ClipVertex))();

                    var count2 = poly2.Vertices.Count;

                    System.Diagnostics.Debug.Assert(0 <= edge1 && edge1 < poly1.Vertices.Count);

                    var v = poly1.Normals.getItem(edge1).$clone();
                    var tmpx = xf1.v.R.Col1.X * v.X + xf1.v.R.Col2.X * v.Y;
                    var tmpy = xf1.v.R.Col1.Y * v.X + xf1.v.R.Col2.Y * v.Y;
                    var normal1 = new Microsoft.Xna.Framework.Vector2.$ctor2(tmpx * xf2.v.R.Col1.X + tmpy * xf2.v.R.Col1.Y, tmpx * xf2.v.R.Col2.X + tmpy * xf2.v.R.Col2.Y);

                    var index = 0;
                    var minDot = FarseerPhysics.Settings.MaxFloat;
                    for (var i = 0; i < count2; i = (i + 1) | 0) {
                        var dot = Microsoft.Xna.Framework.Vector2.Dot(normal1.$clone(), poly2.Normals.getItem(i).$clone());
                        if (dot < minDot) {
                            minDot = dot;
                            index = i;
                        }
                    }

                    var i1 = index;
                    var i2 = ((i1 + 1) | 0) < count2 ? ((i1 + 1) | 0) : 0;

                    var cv0 = c.v.getItem(0).$clone();

                    var v1 = poly2.Vertices.getItem(i1).$clone();
                    cv0.V.X = xf2.v.Position.X + xf2.v.R.Col1.X * v1.X + xf2.v.R.Col2.X * v1.Y;
                    cv0.V.Y = xf2.v.Position.Y + xf2.v.R.Col1.Y * v1.X + xf2.v.R.Col2.Y * v1.Y;
                    cv0.ID.Features.IndexA = edge1 & 255;
                    cv0.ID.Features.IndexB = i1 & 255;
                    cv0.ID.Features.TypeA = FarseerPhysics.Collision.ContactFeatureType.Face;
                    cv0.ID.Features.TypeB = FarseerPhysics.Collision.ContactFeatureType.Vertex;

                    c.v.setItem(0, cv0.$clone());

                    var cv1 = c.v.getItem(1).$clone();
                    var v2 = poly2.Vertices.getItem(i2).$clone();
                    cv1.V.X = xf2.v.Position.X + xf2.v.R.Col1.X * v2.X + xf2.v.R.Col2.X * v2.Y;
                    cv1.V.Y = xf2.v.Position.Y + xf2.v.R.Col1.Y * v2.X + xf2.v.R.Col2.Y * v2.Y;
                    cv1.ID.Features.IndexA = edge1 & 255;
                    cv1.ID.Features.IndexB = i2 & 255;
                    cv1.ID.Features.TypeA = FarseerPhysics.Collision.ContactFeatureType.Face;
                    cv1.ID.Features.TypeB = FarseerPhysics.Collision.ContactFeatureType.Vertex;

                    c.v.setItem(1, cv1.$clone());
                },
                /**
                 * Clipping for contact manifolds.
                 *
                 * @static
                 * @private
                 * @this FarseerPhysics.Collision.Collision
                 * @memberof FarseerPhysics.Collision.Collision
                 * @param   {FarseerPhysics.Common.FixedArray2}    vOut            The v out.
                 * @param   {FarseerPhysics.Common.FixedArray2}    vIn             The v in.
                 * @param   {Microsoft.Xna.Framework.Vector2}      normal          The normal.
                 * @param   {number}                               offset          The offset.
                 * @param   {number}                               vertexIndexA    The vertex index A.
                 * @return  {number}
                 */
                ClipSegmentToLine: function (vOut, vIn, normal, offset, vertexIndexA) {
                    vOut.v = new (FarseerPhysics.Common.FixedArray2$1(FarseerPhysics.Collision.ClipVertex))();

                    var v0 = vIn.v.getItem(0).$clone();
                    var v1 = vIn.v.getItem(1).$clone();

                    var numOut = 0;

                    var distance0 = normal.X * v0.V.X + normal.Y * v0.V.Y - offset;
                    var distance1 = normal.X * v1.V.X + normal.Y * v1.V.Y - offset;

                    if (distance0 <= 0.0) {
                        vOut.v.setItem(Bridge.identity(numOut, (numOut = (numOut + 1) | 0)), v0.$clone());
                    }
                    if (distance1 <= 0.0) {
                        vOut.v.setItem(Bridge.identity(numOut, (numOut = (numOut + 1) | 0)), v1.$clone());
                    }

                    if (distance0 * distance1 < 0.0) {
                        var interp = distance0 / (distance0 - distance1);

                        var cv = vOut.v.getItem(numOut).$clone();

                        cv.V.X = v0.V.X + interp * (v1.V.X - v0.V.X);
                        cv.V.Y = v0.V.Y + interp * (v1.V.Y - v0.V.Y);

                        cv.ID.Features.IndexA = vertexIndexA & 255;
                        cv.ID.Features.IndexB = v0.ID.Features.IndexB;
                        cv.ID.Features.TypeA = FarseerPhysics.Collision.ContactFeatureType.Vertex;
                        cv.ID.Features.TypeB = FarseerPhysics.Collision.ContactFeatureType.Face;

                        vOut.v.setItem(numOut, cv.$clone());

                        numOut = (numOut + 1) | 0;
                    }

                    return numOut;
                },
                /**
                 * Find the separation between poly1 and poly2 for a give edge normal on poly1.
                 *
                 * @static
                 * @private
                 * @this FarseerPhysics.Collision.Collision
                 * @memberof FarseerPhysics.Collision.Collision
                 * @param   {FarseerPhysics.Collision.Shapes.PolygonShape}    poly1    The poly1.
                 * @param   {FarseerPhysics.Common.Transform}                 xf1      The XF1.
                 * @param   {number}                                          edge1    The edge1.
                 * @param   {FarseerPhysics.Collision.Shapes.PolygonShape}    poly2    The poly2.
                 * @param   {FarseerPhysics.Common.Transform}                 xf2      The XF2.
                 * @return  {number}
                 */
                EdgeSeparation: function (poly1, xf1, edge1, poly2, xf2) {
                    var count2 = poly2.Vertices.Count;

                    System.Diagnostics.Debug.Assert(0 <= edge1 && edge1 < poly1.Vertices.Count);

                    var p1n = poly1.Normals.getItem(edge1).$clone();

                    var normalWorldx = xf1.v.R.Col1.X * p1n.X + xf1.v.R.Col2.X * p1n.Y;
                    var normalWorldy = xf1.v.R.Col1.Y * p1n.X + xf1.v.R.Col2.Y * p1n.Y;

                    var normal = new Microsoft.Xna.Framework.Vector2.$ctor2(normalWorldx * xf2.v.R.Col1.X + normalWorldy * xf2.v.R.Col1.Y, normalWorldx * xf2.v.R.Col2.X + normalWorldy * xf2.v.R.Col2.Y);

                    var index = 0;
                    var minDot = FarseerPhysics.Settings.MaxFloat;

                    for (var i = 0; i < count2; i = (i + 1) | 0) {
                        var dot = Microsoft.Xna.Framework.Vector2.Dot(poly2.Vertices.getItem(i).$clone(), normal.$clone());

                        if (dot < minDot) {
                            minDot = dot;
                            index = i;
                        }
                    }

                    var p1ve = poly1.Vertices.getItem(edge1).$clone();
                    var p2vi = poly2.Vertices.getItem(index).$clone();

                    return ((xf2.v.Position.X + xf2.v.R.Col1.X * p2vi.X + xf2.v.R.Col2.X * p2vi.Y) - (xf1.v.Position.X + xf1.v.R.Col1.X * p1ve.X + xf1.v.R.Col2.X * p1ve.Y)) * normalWorldx + ((xf2.v.Position.Y + xf2.v.R.Col1.Y * p2vi.X + xf2.v.R.Col2.Y * p2vi.Y) - (xf1.v.Position.Y + xf1.v.R.Col1.Y * p1ve.X + xf1.v.R.Col2.Y * p1ve.Y)) * normalWorldy;
                },
                /**
                 * Find the max separation between poly1 and poly2 using edge normals from poly1.
                 *
                 * @static
                 * @private
                 * @this FarseerPhysics.Collision.Collision
                 * @memberof FarseerPhysics.Collision.Collision
                 * @param   {System.Int32}                                    edgeIndex    Index of the edge.
                 * @param   {FarseerPhysics.Collision.Shapes.PolygonShape}    poly1        The poly1.
                 * @param   {FarseerPhysics.Common.Transform}                 xf1          The XF1.
                 * @param   {FarseerPhysics.Collision.Shapes.PolygonShape}    poly2        The poly2.
                 * @param   {FarseerPhysics.Common.Transform}                 xf2          The XF2.
                 * @return  {number}
                 */
                FindMaxSeparation: function (edgeIndex, poly1, xf1, poly2, xf2) {
                    var count1 = poly1.Vertices.Count;

                    var dx = (xf2.v.Position.X + xf2.v.R.Col1.X * poly2.MassData.Centroid.X + xf2.v.R.Col2.X * poly2.MassData.Centroid.Y) - (xf1.v.Position.X + xf1.v.R.Col1.X * poly1.MassData.Centroid.X + xf1.v.R.Col2.X * poly1.MassData.Centroid.Y);
                    var dy = (xf2.v.Position.Y + xf2.v.R.Col1.Y * poly2.MassData.Centroid.X + xf2.v.R.Col2.Y * poly2.MassData.Centroid.Y) - (xf1.v.Position.Y + xf1.v.R.Col1.Y * poly1.MassData.Centroid.X + xf1.v.R.Col2.Y * poly1.MassData.Centroid.Y);
                    var dLocal1 = new Microsoft.Xna.Framework.Vector2.$ctor2(dx * xf1.v.R.Col1.X + dy * xf1.v.R.Col1.Y, dx * xf1.v.R.Col2.X + dy * xf1.v.R.Col2.Y);

                    var edge = 0;
                    var maxDot = -3.40282347E+38;
                    for (var i = 0; i < count1; i = (i + 1) | 0) {
                        var dot = Microsoft.Xna.Framework.Vector2.Dot(poly1.Normals.getItem(i).$clone(), dLocal1.$clone());
                        if (dot > maxDot) {
                            maxDot = dot;
                            edge = i;
                        }
                    }

                    var s = FarseerPhysics.Collision.Collision.EdgeSeparation(poly1, xf1, edge, poly2, xf2);

                    var prevEdge = ((edge - 1) | 0) >= 0 ? ((edge - 1) | 0) : ((count1 - 1) | 0);
                    var sPrev = FarseerPhysics.Collision.Collision.EdgeSeparation(poly1, xf1, prevEdge, poly2, xf2);

                    var nextEdge = ((edge + 1) | 0) < count1 ? ((edge + 1) | 0) : 0;
                    var sNext = FarseerPhysics.Collision.Collision.EdgeSeparation(poly1, xf1, nextEdge, poly2, xf2);

                    var bestEdge;
                    var bestSeparation;
                    var increment;
                    if (sPrev > s && sPrev > sNext) {
                        increment = -1;
                        bestEdge = prevEdge;
                        bestSeparation = sPrev;
                    } else if (sNext > s) {
                        increment = 1;
                        bestEdge = nextEdge;
                        bestSeparation = sNext;
                    } else {
                        edgeIndex.v = edge;
                        return s;
                    }

                    for (; ; ) {
                        if (increment === -1) {
                            edge = ((bestEdge - 1) | 0) >= 0 ? ((bestEdge - 1) | 0) : ((count1 - 1) | 0);
                        } else {
                            edge = ((bestEdge + 1) | 0) < count1 ? ((bestEdge + 1) | 0) : 0;
                        }

                        s = FarseerPhysics.Collision.Collision.EdgeSeparation(poly1, xf1, edge, poly2, xf2);

                        if (s > bestSeparation) {
                            bestEdge = edge;
                            bestSeparation = s;
                        } else {
                            break;
                        }
                    }

                    edgeIndex.v = bestEdge;
                    return bestSeparation;
                }
            }
        }
    });

    /**
     * The features that intersect to form the contact point
     This must be 4 bytes or less.
     *
     * @public
     * @class FarseerPhysics.Collision.ContactFeature
     */
    Bridge.define("FarseerPhysics.Collision.ContactFeature", {
        $kind: "struct",
        statics: {
            methods: {
                getDefaultValue: function () { return new FarseerPhysics.Collision.ContactFeature(); }
            }
        },
        fields: {
            /**
             * Feature index on ShapeA
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Collision.ContactFeature
             * @type number
             */
            IndexA: 0,
            /**
             * Feature index on ShapeB
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Collision.ContactFeature
             * @type number
             */
            IndexB: 0,
            /**
             * The feature type on ShapeA
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Collision.ContactFeature
             * @type number
             */
            TypeA: 0,
            /**
             * The feature type on ShapeB
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Collision.ContactFeature
             * @type number
             */
            TypeB: 0
        },
        ctors: {
            ctor: function () {
                this.$initialize();
            }
        },
        methods: {
            getHashCode: function () {
                var h = Bridge.addHash([5106014587, this.IndexA, this.IndexB, this.TypeA, this.TypeB]);
                return h;
            },
            equals: function (o) {
                if (!Bridge.is(o, FarseerPhysics.Collision.ContactFeature)) {
                    return false;
                }
                return Bridge.equals(this.IndexA, o.IndexA) && Bridge.equals(this.IndexB, o.IndexB) && Bridge.equals(this.TypeA, o.TypeA) && Bridge.equals(this.TypeB, o.TypeB);
            },
            $clone: function (to) {
                var s = to || new FarseerPhysics.Collision.ContactFeature();
                s.IndexA = this.IndexA;
                s.IndexB = this.IndexB;
                s.TypeA = this.TypeA;
                s.TypeB = this.TypeB;
                return s;
            }
        }
    });

    Bridge.define("FarseerPhysics.Collision.ContactFeatureType", {
        $kind: "enum",
        statics: {
            fields: {
                Vertex: 0,
                Face: 1
            }
        },
        $utype: System.Byte
    });

    /**
     * Contact ids to facilitate warm starting.
     *
     * @public
     * @class FarseerPhysics.Collision.ContactID
     */
    Bridge.define("FarseerPhysics.Collision.ContactID", {
        $kind: "struct",
        statics: {
            methods: {
                getDefaultValue: function () { return new FarseerPhysics.Collision.ContactID(); }
            }
        },
        fields: {
            /**
             * The features that intersect to form the contact point
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Collision.ContactID
             * @type FarseerPhysics.Collision.ContactFeature
             */
            Features: null,
            /**
             * Used to quickly compare contact ids.
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Collision.ContactID
             * @type number
             */
            Key: 0
        },
        ctors: {
            init: function () {
                this.Features = new FarseerPhysics.Collision.ContactFeature();
            },
            ctor: function () {
                this.$initialize();
            }
        },
        methods: {
            getHashCode: function () {
                var h = Bridge.addHash([3185758952, this.Features, this.Key]);
                return h;
            },
            equals: function (o) {
                if (!Bridge.is(o, FarseerPhysics.Collision.ContactID)) {
                    return false;
                }
                return Bridge.equals(this.Features, o.Features) && Bridge.equals(this.Key, o.Key);
            },
            $clone: function (to) {
                var s = to || new FarseerPhysics.Collision.ContactID();
                s.Features = this.Features.$clone();
                s.Key = this.Key;
                return s;
            }
        }
    });

    Bridge.define("FarseerPhysics.Collision.Distance", {
        statics: {
            fields: {
                GJKCalls: 0,
                GJKIters: 0,
                GJKMaxIters: 0
            },
            methods: {
                ComputeDistance: function (output, cache, input) {
                    cache.v = new FarseerPhysics.Collision.SimplexCache();
                    FarseerPhysics.Collision.Distance.GJKCalls = (FarseerPhysics.Collision.Distance.GJKCalls + 1) | 0;

                    var simplex = new FarseerPhysics.Collision.Simplex();
                    simplex.ReadCache(cache, input.ProxyA, Bridge.ref(input, "TransformA"), input.ProxyB, Bridge.ref(input, "TransformB"));

                    var k_maxIters = 20;

                    var saveA = new (FarseerPhysics.Common.FixedArray3$1(System.Int32))();
                    var saveB = new (FarseerPhysics.Common.FixedArray3$1(System.Int32))();

                    var closestPoint = simplex.GetClosestPoint();
                    var distanceSqr1 = closestPoint.LengthSquared();
                    var distanceSqr2 = distanceSqr1;

                    var iter = 0;
                    while (iter < k_maxIters) {
                        var saveCount = simplex.Count;
                        for (var i = 0; i < saveCount; i = (i + 1) | 0) {
                            saveA.setItem(i, simplex.V.getItem(i).$clone().IndexA);
                            saveB.setItem(i, simplex.V.getItem(i).$clone().IndexB);
                        }

                        switch (simplex.Count) {
                            case 1: 
                                break;
                            case 2: 
                                simplex.Solve2();
                                break;
                            case 3: 
                                simplex.Solve3();
                                break;
                            default: 
                                System.Diagnostics.Debug.Assert(false);
                                break;
                        }

                        if (simplex.Count === 3) {
                            break;
                        }

                        var p = simplex.GetClosestPoint();
                        distanceSqr2 = p.LengthSquared();

                        if (distanceSqr2 >= distanceSqr1) {
                        }
                        distanceSqr1 = distanceSqr2;

                        var d = simplex.GetSearchDirection();

                        if (d.LengthSquared() < 1.42108547E-14) {

                            break;
                        }

                        var vertex = simplex.V.getItem(simplex.Count).$clone();
                        vertex.IndexA = input.ProxyA.GetSupport(FarseerPhysics.Common.MathUtils.MultiplyT(Bridge.ref(input.TransformA, "R"), Microsoft.Xna.Framework.Vector2.op_UnaryNegation(d.$clone())));
                        vertex.WA = FarseerPhysics.Common.MathUtils.Multiply$2(Bridge.ref(input, "TransformA"), input.ProxyA.Vertices.getItem(vertex.IndexA).$clone());

                        vertex.IndexB = input.ProxyB.GetSupport(FarseerPhysics.Common.MathUtils.MultiplyT(Bridge.ref(input.TransformB, "R"), d.$clone()));
                        vertex.WB = FarseerPhysics.Common.MathUtils.Multiply$2(Bridge.ref(input, "TransformB"), input.ProxyB.Vertices.getItem(vertex.IndexB).$clone());
                        vertex.W = Microsoft.Xna.Framework.Vector2.op_Subtraction(vertex.WB.$clone(), vertex.WA.$clone());
                        simplex.V.setItem(simplex.Count, vertex.$clone());

                        iter = (iter + 1) | 0;
                        FarseerPhysics.Collision.Distance.GJKIters = (FarseerPhysics.Collision.Distance.GJKIters + 1) | 0;

                        var duplicate = false;
                        for (var i1 = 0; i1 < saveCount; i1 = (i1 + 1) | 0) {
                            if (vertex.IndexA === saveA.getItem(i1) && vertex.IndexB === saveB.getItem(i1)) {
                                duplicate = true;
                                break;
                            }
                        }

                        if (duplicate) {
                            break;
                        }

                        simplex.Count = (simplex.Count + 1) | 0;
                    }

                    FarseerPhysics.Collision.Distance.GJKMaxIters = Math.max(FarseerPhysics.Collision.Distance.GJKMaxIters, iter);

                    simplex.GetWitnessPoints(Bridge.ref(output.v, "PointA"), Bridge.ref(output.v, "PointB"));
                    output.v.Distance = (Microsoft.Xna.Framework.Vector2.op_Subtraction(output.v.PointA.$clone(), output.v.PointB.$clone())).Length();
                    output.v.Iterations = iter;

                    simplex.WriteCache(cache);

                    if (input.UseRadii) {
                        var rA = input.ProxyA.Radius;
                        var rB = input.ProxyB.Radius;

                        if (output.v.Distance > rA + rB && output.v.Distance > FarseerPhysics.Settings.Epsilon) {
                            output.v.Distance -= rA + rB;
                            var normal = Microsoft.Xna.Framework.Vector2.op_Subtraction(output.v.PointB.$clone(), output.v.PointA.$clone());
                            normal.Normalize();
                            output.v.PointA = Microsoft.Xna.Framework.Vector2.op_Addition(output.v.PointA.$clone(), Microsoft.Xna.Framework.Vector2.op_Multiply$2(rA, normal.$clone()));
                            output.v.PointB = Microsoft.Xna.Framework.Vector2.op_Subtraction(output.v.PointB.$clone(), Microsoft.Xna.Framework.Vector2.op_Multiply$2(rB, normal.$clone()));
                        } else {
                            var p1 = Microsoft.Xna.Framework.Vector2.op_Multiply$2(0.5, (Microsoft.Xna.Framework.Vector2.op_Addition(output.v.PointA.$clone(), output.v.PointB.$clone())));
                            output.v.PointA = p1.$clone();
                            output.v.PointB = p1.$clone();
                            output.v.Distance = 0.0;
                        }
                    }
                }
            }
        }
    });

    /**
     * Input for ComputeDistance.
     You have to option to use the shape radii
     in the computation.
     *
     * @public
     * @class FarseerPhysics.Collision.DistanceInput
     */
    Bridge.define("FarseerPhysics.Collision.DistanceInput", {
        fields: {
            ProxyA: null,
            ProxyB: null,
            TransformA: null,
            TransformB: null,
            UseRadii: false
        },
        ctors: {
            init: function () {
                this.TransformA = new FarseerPhysics.Common.Transform();
                this.TransformB = new FarseerPhysics.Common.Transform();
                this.ProxyA = new FarseerPhysics.Collision.DistanceProxy();
                this.ProxyB = new FarseerPhysics.Collision.DistanceProxy();
            }
        }
    });

    /**
     * Output for ComputeDistance.
     *
     * @public
     * @class FarseerPhysics.Collision.DistanceOutput
     */
    Bridge.define("FarseerPhysics.Collision.DistanceOutput", {
        $kind: "struct",
        statics: {
            methods: {
                getDefaultValue: function () { return new FarseerPhysics.Collision.DistanceOutput(); }
            }
        },
        fields: {
            Distance: 0,
            /**
             * Number of GJK iterations used
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Collision.DistanceOutput
             * @type number
             */
            Iterations: 0,
            /**
             * Closest point on shapeA
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Collision.DistanceOutput
             * @type Microsoft.Xna.Framework.Vector2
             */
            PointA: null,
            /**
             * Closest point on shapeB
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Collision.DistanceOutput
             * @type Microsoft.Xna.Framework.Vector2
             */
            PointB: null
        },
        ctors: {
            init: function () {
                this.PointA = new Microsoft.Xna.Framework.Vector2();
                this.PointB = new Microsoft.Xna.Framework.Vector2();
            },
            ctor: function () {
                this.$initialize();
            }
        },
        methods: {
            getHashCode: function () {
                var h = Bridge.addHash([5541445993, this.Distance, this.Iterations, this.PointA, this.PointB]);
                return h;
            },
            equals: function (o) {
                if (!Bridge.is(o, FarseerPhysics.Collision.DistanceOutput)) {
                    return false;
                }
                return Bridge.equals(this.Distance, o.Distance) && Bridge.equals(this.Iterations, o.Iterations) && Bridge.equals(this.PointA, o.PointA) && Bridge.equals(this.PointB, o.PointB);
            },
            $clone: function (to) {
                var s = to || new FarseerPhysics.Collision.DistanceOutput();
                s.Distance = this.Distance;
                s.Iterations = this.Iterations;
                s.PointA = this.PointA.$clone();
                s.PointB = this.PointB.$clone();
                return s;
            }
        }
    });

    /**
     * A distance proxy is used by the GJK algorithm.
     It encapsulates any shape.
     *
     * @public
     * @class FarseerPhysics.Collision.DistanceProxy
     */
    Bridge.define("FarseerPhysics.Collision.DistanceProxy", {
        fields: {
            Radius: 0,
            Vertices: null
        },
        ctors: {
            init: function () {
                this.Vertices = new FarseerPhysics.Common.Vertices.ctor();
            }
        },
        methods: {
            /**
             * Initialize the proxy using the given shape. The shape
             must remain in scope while the proxy is in use.
             *
             * @instance
             * @public
             * @this FarseerPhysics.Collision.DistanceProxy
             * @memberof FarseerPhysics.Collision.DistanceProxy
             * @param   {FarseerPhysics.Collision.Shapes.Shape}    shape    The shape.
             * @param   {number}                                   index    The index.
             * @return  {void}
             */
            Set: function (shape, index) {
                switch (shape.ShapeType) {
                    case FarseerPhysics.Collision.Shapes.ShapeType.Circle: 
                        {
                            var circle = Bridge.cast(shape, FarseerPhysics.Collision.Shapes.CircleShape);
                            this.Vertices.clear();
                            this.Vertices.add(circle.Position.$clone());
                            this.Radius = circle.Radius;
                        }
                        break;
                    case FarseerPhysics.Collision.Shapes.ShapeType.Polygon: 
                        {
                            var polygon = Bridge.cast(shape, FarseerPhysics.Collision.Shapes.PolygonShape);
                            this.Vertices.clear();
                            for (var i = 0; i < polygon.Vertices.Count; i = (i + 1) | 0) {
                                this.Vertices.add(polygon.Vertices.getItem(i).$clone());
                            }
                            this.Radius = polygon.Radius;
                        }
                        break;
                    case FarseerPhysics.Collision.Shapes.ShapeType.Loop: 
                        {
                            var loop = Bridge.cast(shape, FarseerPhysics.Collision.Shapes.LoopShape);
                            System.Diagnostics.Debug.Assert(0 <= index && index < loop.Vertices.Count);
                            this.Vertices.clear();
                            this.Vertices.add(loop.Vertices.getItem(index).$clone());
                            this.Vertices.add(((index + 1) | 0) < loop.Vertices.Count ? loop.Vertices.getItem(((index + 1) | 0)).$clone() : loop.Vertices.getItem(0).$clone());

                            this.Radius = loop.Radius;
                        }
                        break;
                    case FarseerPhysics.Collision.Shapes.ShapeType.Edge: 
                        {
                            var edge = Bridge.cast(shape, FarseerPhysics.Collision.Shapes.EdgeShape);
                            this.Vertices.clear();
                            this.Vertices.add(edge.Vertex1.$clone());
                            this.Vertices.add(edge.Vertex2.$clone());
                            this.Radius = edge.Radius;
                        }
                        break;
                    default: 
                        System.Diagnostics.Debug.Assert(false);
                        break;
                }
            },
            /**
             * Get the supporting vertex index in the given direction.
             *
             * @instance
             * @public
             * @this FarseerPhysics.Collision.DistanceProxy
             * @memberof FarseerPhysics.Collision.DistanceProxy
             * @param   {Microsoft.Xna.Framework.Vector2}    direction    The direction.
             * @return  {number}
             */
            GetSupport: function (direction) {
                var bestIndex = 0;
                var bestValue = Microsoft.Xna.Framework.Vector2.Dot(this.Vertices.getItem(0).$clone(), direction.$clone());
                for (var i = 1; i < this.Vertices.Count; i = (i + 1) | 0) {
                    var value = Microsoft.Xna.Framework.Vector2.Dot(this.Vertices.getItem(i).$clone(), direction.$clone());
                    if (value > bestValue) {
                        bestIndex = i;
                        bestValue = value;
                    }
                }

                return bestIndex;
            },
            /**
             * Get the supporting vertex in the given direction.
             *
             * @instance
             * @public
             * @this FarseerPhysics.Collision.DistanceProxy
             * @memberof FarseerPhysics.Collision.DistanceProxy
             * @param   {Microsoft.Xna.Framework.Vector2}    direction    The direction.
             * @return  {Microsoft.Xna.Framework.Vector2}
             */
            GetSupportVertex: function (direction) {
                var bestIndex = 0;
                var bestValue = Microsoft.Xna.Framework.Vector2.Dot(this.Vertices.getItem(0).$clone(), direction.$clone());
                for (var i = 1; i < this.Vertices.Count; i = (i + 1) | 0) {
                    var value = Microsoft.Xna.Framework.Vector2.Dot(this.Vertices.getItem(i).$clone(), direction.$clone());
                    if (value > bestValue) {
                        bestIndex = i;
                        bestValue = value;
                    }
                }

                return this.Vertices.getItem(bestIndex).$clone();
            }
        }
    });

    /** @namespace System */

    /**
     * @memberof System
     * @callback System.Func
     * @param   {number}     arg
     * @return  {boolean}
     */

    /**
     * A dynamic tree arranges data in a binary tree to accelerate
     queries such as volume queries and ray casts. Leafs are proxies
     with an AABB. In the tree we expand the proxy AABB by Settings.b2_fatAABBFactor
     so that the proxy AABB is bigger than the client object. This allows the client
     object to move by small amounts without triggering a tree update.
     Nodes are pooled and relocatable, so we use node indices rather than pointers.
     *
     * @public
     * @class FarseerPhysics.Collision.DynamicTree$1
     */
    Bridge.define("FarseerPhysics.Collision.DynamicTree$1", function (T) { return {
        statics: {
            fields: {
                NullNode: 0,
                _stack: null
            },
            ctors: {
                init: function () {
                    this.NullNode = -1;
                    this._stack = new (System.Collections.Generic.Stack$1(System.Int32)).$ctor2(256);
                }
            }
        },
        fields: {
            _freeList: 0,
            _insertionCount: 0,
            _nodeCapacity: 0,
            _nodeCount: 0,
            _nodes: null,
            /**
             * This is used incrementally traverse the tree for re-balancing.
             *
             * @instance
             * @private
             * @memberof FarseerPhysics.Collision.DynamicTree$1
             * @type number
             */
            _path: 0,
            _root: 0
        },
        ctors: {
            /**
             * Constructing the tree initializes the node pool.
             *
             * @instance
             * @public
             * @this FarseerPhysics.Collision.DynamicTree$1
             * @memberof FarseerPhysics.Collision.DynamicTree$1
             * @return  {void}
             */
            ctor: function () {
                this.$initialize();
                this._root = FarseerPhysics.Collision.DynamicTree$1(T).NullNode;

                this._nodeCapacity = 16;
                this._nodes = System.Array.init(this._nodeCapacity, function (){
                    return new (FarseerPhysics.Collision.DynamicTreeNode$1(T))();
                }, FarseerPhysics.Collision.DynamicTreeNode$1(T));

                for (var i = 0; i < ((this._nodeCapacity - 1) | 0); i = (i + 1) | 0) {
                    this._nodes[System.Array.index(i, this._nodes)].ParentOrNext = (i + 1) | 0;
                }
                this._nodes[System.Array.index(((this._nodeCapacity - 1) | 0), this._nodes)].ParentOrNext = FarseerPhysics.Collision.DynamicTree$1(T).NullNode;
            }
        },
        methods: {
            /**
             * Create a proxy in the tree as a leaf node. We return the index
             of the node instead of a pointer so that we can grow
             the node pool.
             *
             * @instance
             * @public
             * @this FarseerPhysics.Collision.DynamicTree$1
             * @memberof FarseerPhysics.Collision.DynamicTree$1
             * @param   {FarseerPhysics.Collision.AABB}    aabb        The aabb.
             * @param   {T}                                userData    The user data.
             * @return  {number}                                       Index of the created proxy
             */
            AddProxy: function (aabb, userData) {
                var proxyId = this.AllocateNode();

                var r = new Microsoft.Xna.Framework.Vector2.$ctor2(FarseerPhysics.Settings.AABBExtension, FarseerPhysics.Settings.AABBExtension);
                this._nodes[System.Array.index(proxyId, this._nodes)].AABB.LowerBound = Microsoft.Xna.Framework.Vector2.op_Subtraction(aabb.v.LowerBound.$clone(), r.$clone());
                this._nodes[System.Array.index(proxyId, this._nodes)].AABB.UpperBound = Microsoft.Xna.Framework.Vector2.op_Addition(aabb.v.UpperBound.$clone(), r.$clone());
                this._nodes[System.Array.index(proxyId, this._nodes)].UserData = userData;
                this._nodes[System.Array.index(proxyId, this._nodes)].LeafCount = 1;

                this.InsertLeaf(proxyId);

                return proxyId;
            },
            /**
             * Destroy a proxy. This asserts if the id is invalid.
             *
             * @instance
             * @public
             * @this FarseerPhysics.Collision.DynamicTree$1
             * @memberof FarseerPhysics.Collision.DynamicTree$1
             * @param   {number}    proxyId    The proxy id.
             * @return  {void}
             */
            RemoveProxy: function (proxyId) {
                System.Diagnostics.Debug.Assert(0 <= proxyId && proxyId < this._nodeCapacity);
                System.Diagnostics.Debug.Assert(this._nodes[System.Array.index(proxyId, this._nodes)].IsLeaf());

                this.RemoveLeaf(proxyId);
                this.FreeNode(proxyId);
            },
            /**
             * Move a proxy with a swepted AABB. If the proxy has moved outside of its fattened AABB,
             then the proxy is removed from the tree and re-inserted. Otherwise
             the function returns immediately.
             *
             * @instance
             * @public
             * @this FarseerPhysics.Collision.DynamicTree$1
             * @memberof FarseerPhysics.Collision.DynamicTree$1
             * @param   {number}                             proxyId         The proxy id.
             * @param   {FarseerPhysics.Collision.AABB}      aabb            The aabb.
             * @param   {Microsoft.Xna.Framework.Vector2}    displacement    The displacement.
             * @return  {boolean}                                            true if the proxy was re-inserted.
             */
            MoveProxy: function (proxyId, aabb, displacement) {
                System.Diagnostics.Debug.Assert(0 <= proxyId && proxyId < this._nodeCapacity);

                System.Diagnostics.Debug.Assert(this._nodes[System.Array.index(proxyId, this._nodes)].IsLeaf());

                if (this._nodes[System.Array.index(proxyId, this._nodes)].AABB.Contains(aabb)) {
                    return false;
                }

                this.RemoveLeaf(proxyId);

                var b = aabb.v.$clone();
                var r = new Microsoft.Xna.Framework.Vector2.$ctor2(FarseerPhysics.Settings.AABBExtension, FarseerPhysics.Settings.AABBExtension);
                b.LowerBound = Microsoft.Xna.Framework.Vector2.op_Subtraction(b.LowerBound.$clone(), r.$clone());
                b.UpperBound = Microsoft.Xna.Framework.Vector2.op_Addition(b.UpperBound.$clone(), r.$clone());

                var d = Microsoft.Xna.Framework.Vector2.op_Multiply$2(FarseerPhysics.Settings.AABBMultiplier, displacement.$clone());

                if (d.X < 0.0) {
                    b.LowerBound.X += d.X;
                } else {
                    b.UpperBound.X += d.X;
                }

                if (d.Y < 0.0) {
                    b.LowerBound.Y += d.Y;
                } else {
                    b.UpperBound.Y += d.Y;
                }

                this._nodes[System.Array.index(proxyId, this._nodes)].AABB = b.$clone();

                this.InsertLeaf(proxyId);
                return true;
            },
            /**
             * Perform some iterations to re-balance the tree.
             *
             * @instance
             * @public
             * @this FarseerPhysics.Collision.DynamicTree$1
             * @memberof FarseerPhysics.Collision.DynamicTree$1
             * @param   {number}    iterations    The iterations.
             * @return  {void}
             */
            Rebalance: function (iterations) {
                if (this._root === FarseerPhysics.Collision.DynamicTree$1(T).NullNode) {
                    return;
                }

                for (var i = 0; i < iterations; i = (i + 1) | 0) {
                    var node = this._root;

                    var bit = 0;
                    while (this._nodes[System.Array.index(node, this._nodes)].IsLeaf() === false) {
                        var selector = (this._path >> bit) & 1;

                        node = (selector === 0) ? this._nodes[System.Array.index(node, this._nodes)].Child1 : this._nodes[System.Array.index(node, this._nodes)].Child2;

                        bit = (((bit + 1) | 0)) & 31;
                    }
                    this._path = (this._path + 1) | 0;

                    this.RemoveLeaf(node);
                    this.InsertLeaf(node);
                }
            },
            /**
             * Get proxy user data.
             *
             * @instance
             * @public
             * @this FarseerPhysics.Collision.DynamicTree$1
             * @memberof FarseerPhysics.Collision.DynamicTree$1
             * @param   {number}      proxyId    The proxy id.
             * @param   {Function}    [name]
             * @return  {T}                      the proxy user data or 0 if the id is invalid.
             */
            GetUserData: function (proxyId) {
                System.Diagnostics.Debug.Assert(0 <= proxyId && proxyId < this._nodeCapacity);
                return this._nodes[System.Array.index(proxyId, this._nodes)].UserData;
            },
            /**
             * Get the fat AABB for a proxy.
             *
             * @instance
             * @public
             * @this FarseerPhysics.Collision.DynamicTree$1
             * @memberof FarseerPhysics.Collision.DynamicTree$1
             * @param   {number}                           proxyId    The proxy id.
             * @param   {FarseerPhysics.Collision.AABB}    fatAABB    The fat AABB.
             * @return  {void}
             */
            GetFatAABB: function (proxyId, fatAABB) {
                System.Diagnostics.Debug.Assert(0 <= proxyId && proxyId < this._nodeCapacity);
                fatAABB.v = this._nodes[System.Array.index(proxyId, this._nodes)].AABB.$clone();
            },
            /**
             * Compute the height of the binary tree in O(N) time. Should not be
             called often.
             *
             * @instance
             * @public
             * @this FarseerPhysics.Collision.DynamicTree$1
             * @memberof FarseerPhysics.Collision.DynamicTree$1
             * @return  {number}
             */
            ComputeHeight: function () {
                return this.ComputeHeight$1(this._root);
            },
            ComputeHeight$1: function (nodeId) {
                if (nodeId === FarseerPhysics.Collision.DynamicTree$1(T).NullNode) {
                    return 0;
                }

                System.Diagnostics.Debug.Assert(0 <= nodeId && nodeId < this._nodeCapacity);
                var node = this._nodes[System.Array.index(nodeId, this._nodes)].$clone();
                var height1 = this.ComputeHeight$1(node.Child1);
                var height2 = this.ComputeHeight$1(node.Child2);
                return ((1 + Math.max(height1, height2)) | 0);
            },
            /**
             * Query an AABB for overlapping proxies. The callback class
             is called for each proxy that overlaps the supplied AABB.
             *
             * @instance
             * @public
             * @this FarseerPhysics.Collision.DynamicTree$1
             * @memberof FarseerPhysics.Collision.DynamicTree$1
             * @param   {System.Func}                      callback    The callback.
             * @param   {FarseerPhysics.Collision.AABB}    aabb        The aabb.
             * @return  {void}
             */
            Query: function (callback, aabb) {
                FarseerPhysics.Collision.DynamicTree$1(T)._stack.Clear();
                FarseerPhysics.Collision.DynamicTree$1(T)._stack.Push(this._root);

                while (FarseerPhysics.Collision.DynamicTree$1(T)._stack.Count > 0) {
                    var nodeId = FarseerPhysics.Collision.DynamicTree$1(T)._stack.Pop();
                    if (nodeId === FarseerPhysics.Collision.DynamicTree$1(T).NullNode) {
                        continue;
                    }

                    var node = this._nodes[System.Array.index(nodeId, this._nodes)].$clone();

                    if (FarseerPhysics.Collision.AABB.TestOverlap$1(Bridge.ref(node, "AABB"), aabb)) {
                        if (node.IsLeaf()) {
                            var proceed = callback(nodeId);
                            if (proceed === false) {
                                return;
                            }
                        } else {
                            FarseerPhysics.Collision.DynamicTree$1(T)._stack.Push(node.Child1);
                            FarseerPhysics.Collision.DynamicTree$1(T)._stack.Push(node.Child2);
                        }
                    }
                }
            },
            /**
             * Ray-cast against the proxies in the tree. This relies on the callback
             to perform a exact ray-cast in the case were the proxy contains a Shape.
             The callback also performs the any collision filtering. This has performance
             roughly equal to k * log(n), where k is the number of collisions and n is the
             number of proxies in the tree.
             *
             * @instance
             * @public
             * @this FarseerPhysics.Collision.DynamicTree$1
             * @memberof FarseerPhysics.Collision.DynamicTree$1
             * @param   {System.Func}                              callback    A callback class that is called for each proxy that is hit by the ray.
             * @param   {FarseerPhysics.Collision.RayCastInput}    input       The ray-cast input data. The ray extends from p1 to p1 + maxFraction * (p2 - p1).
             * @return  {void}
             */
            RayCast: function (callback, input) {
                var p1 = { v : input.v.Point1.$clone() };
                var p2 = input.v.Point2.$clone();
                var r = Microsoft.Xna.Framework.Vector2.op_Subtraction(p2.$clone(), p1.v.$clone());
                System.Diagnostics.Debug.Assert(r.LengthSquared() > 0.0);
                r.Normalize();

                var absV = FarseerPhysics.Common.MathUtils.Abs(new Microsoft.Xna.Framework.Vector2.$ctor2(-r.Y, r.X));


                var maxFraction = input.v.MaxFraction;

                var segmentAABB = { v : new FarseerPhysics.Collision.AABB.ctor() };
                {
                    var t = { v : Microsoft.Xna.Framework.Vector2.op_Addition(p1.v.$clone(), Microsoft.Xna.Framework.Vector2.op_Multiply$2(maxFraction, (Microsoft.Xna.Framework.Vector2.op_Subtraction(p2.$clone(), p1.v.$clone())))) };
                    Microsoft.Xna.Framework.Vector2.Min$1(p1, t, Bridge.ref(segmentAABB.v, "LowerBound"));
                    Microsoft.Xna.Framework.Vector2.Max$1(p1, t, Bridge.ref(segmentAABB.v, "UpperBound"));
                }

                FarseerPhysics.Collision.DynamicTree$1(T)._stack.Clear();
                FarseerPhysics.Collision.DynamicTree$1(T)._stack.Push(this._root);

                while (FarseerPhysics.Collision.DynamicTree$1(T)._stack.Count > 0) {
                    var nodeId = FarseerPhysics.Collision.DynamicTree$1(T)._stack.Pop();
                    if (nodeId === FarseerPhysics.Collision.DynamicTree$1(T).NullNode) {
                        continue;
                    }

                    var node = this._nodes[System.Array.index(nodeId, this._nodes)].$clone();

                    if (FarseerPhysics.Collision.AABB.TestOverlap$1(Bridge.ref(node, "AABB"), segmentAABB) === false) {
                        continue;
                    }

                    var c = node.AABB.Center.$clone();
                    var h = node.AABB.Extents.$clone();
                    var separation = Math.abs(Microsoft.Xna.Framework.Vector2.Dot(new Microsoft.Xna.Framework.Vector2.$ctor2(-r.Y, r.X), Microsoft.Xna.Framework.Vector2.op_Subtraction(p1.v.$clone(), c.$clone()))) - Microsoft.Xna.Framework.Vector2.Dot(absV.$clone(), h.$clone());
                    if (separation > 0.0) {
                        continue;
                    }

                    if (node.IsLeaf()) {
                        var subInput = new FarseerPhysics.Collision.RayCastInput();
                        subInput.Point1 = input.v.Point1.$clone();
                        subInput.Point2 = input.v.Point2.$clone();
                        subInput.MaxFraction = maxFraction;

                        var value = callback(subInput.$clone(), nodeId);

                        if (value === 0.0) {
                            return;
                        }

                        if (value > 0.0) {
                            maxFraction = value;
                            var t1 = Microsoft.Xna.Framework.Vector2.op_Addition(p1.v.$clone(), Microsoft.Xna.Framework.Vector2.op_Multiply$2(maxFraction, (Microsoft.Xna.Framework.Vector2.op_Subtraction(p2.$clone(), p1.v.$clone()))));
                            segmentAABB.v.LowerBound = Microsoft.Xna.Framework.Vector2.Min(p1.v.$clone(), t1.$clone());
                            segmentAABB.v.UpperBound = Microsoft.Xna.Framework.Vector2.Max(p1.v.$clone(), t1.$clone());
                        }
                    } else {
                        FarseerPhysics.Collision.DynamicTree$1(T)._stack.Push(node.Child1);
                        FarseerPhysics.Collision.DynamicTree$1(T)._stack.Push(node.Child2);
                    }
                }
            },
            CountLeaves: function (nodeId) {
                if (nodeId === FarseerPhysics.Collision.DynamicTree$1(T).NullNode) {
                    return 0;
                }

                System.Diagnostics.Debug.Assert(0 <= nodeId && nodeId < this._nodeCapacity);
                var node = this._nodes[System.Array.index(nodeId, this._nodes)].$clone();

                if (node.IsLeaf()) {
                    System.Diagnostics.Debug.Assert(node.LeafCount === 1);
                    return 1;
                }

                var count1 = this.CountLeaves(node.Child1);
                var count2 = this.CountLeaves(node.Child2);
                var count = (count1 + count2) | 0;
                System.Diagnostics.Debug.Assert(count === node.LeafCount);
                return count;
            },
            Validate: function () {
                this.CountLeaves(this._root);
            },
            AllocateNode: function () {
                if (this._freeList === FarseerPhysics.Collision.DynamicTree$1(T).NullNode) {
                    System.Diagnostics.Debug.Assert(this._nodeCount === this._nodeCapacity);

                    var oldNodes = this._nodes;
                    this._nodeCapacity = Bridge.Int.mul(this._nodeCapacity, 2);
                    this._nodes = System.Array.init(this._nodeCapacity, function (){
                        return new (FarseerPhysics.Collision.DynamicTreeNode$1(T))();
                    }, FarseerPhysics.Collision.DynamicTreeNode$1(T));
                    System.Array.copy(oldNodes, 0, this._nodes, 0, this._nodeCount);

                    for (var i = this._nodeCount; i < ((this._nodeCapacity - 1) | 0); i = (i + 1) | 0) {
                        this._nodes[System.Array.index(i, this._nodes)].ParentOrNext = (i + 1) | 0;
                    }
                    this._nodes[System.Array.index(((this._nodeCapacity - 1) | 0), this._nodes)].ParentOrNext = FarseerPhysics.Collision.DynamicTree$1(T).NullNode;
                    this._freeList = this._nodeCount;
                }

                var nodeId = this._freeList;
                this._freeList = this._nodes[System.Array.index(nodeId, this._nodes)].ParentOrNext;
                this._nodes[System.Array.index(nodeId, this._nodes)].ParentOrNext = FarseerPhysics.Collision.DynamicTree$1(T).NullNode;
                this._nodes[System.Array.index(nodeId, this._nodes)].Child1 = FarseerPhysics.Collision.DynamicTree$1(T).NullNode;
                this._nodes[System.Array.index(nodeId, this._nodes)].Child2 = FarseerPhysics.Collision.DynamicTree$1(T).NullNode;
                this._nodes[System.Array.index(nodeId, this._nodes)].LeafCount = 0;
                this._nodeCount = (this._nodeCount + 1) | 0;
                return nodeId;
            },
            FreeNode: function (nodeId) {
                System.Diagnostics.Debug.Assert(0 <= nodeId && nodeId < this._nodeCapacity);
                System.Diagnostics.Debug.Assert(0 < this._nodeCount);
                this._nodes[System.Array.index(nodeId, this._nodes)].ParentOrNext = this._freeList;
                this._freeList = nodeId;
                this._nodeCount = (this._nodeCount - 1) | 0;
            },
            InsertLeaf: function (leaf) {
                this._insertionCount = (this._insertionCount + 1) | 0;

                if (this._root === FarseerPhysics.Collision.DynamicTree$1(T).NullNode) {
                    this._root = leaf;
                    this._nodes[System.Array.index(this._root, this._nodes)].ParentOrNext = FarseerPhysics.Collision.DynamicTree$1(T).NullNode;
                    return;
                }

                var leafAABB = { v : this._nodes[System.Array.index(leaf, this._nodes)].AABB.$clone() };
                var sibling = this._root;
                while (this._nodes[System.Array.index(sibling, this._nodes)].IsLeaf() === false) {
                    var child1 = this._nodes[System.Array.index(sibling, this._nodes)].Child1;
                    var child2 = this._nodes[System.Array.index(sibling, this._nodes)].Child2;

                    this._nodes[System.Array.index(sibling, this._nodes)].AABB.Combine(leafAABB);
                    this._nodes[System.Array.index(sibling, this._nodes)].LeafCount = (this._nodes[System.Array.index(sibling, this._nodes)].LeafCount + 1) | 0;

                    var siblingArea = this._nodes[System.Array.index(sibling, this._nodes)].AABB.Perimeter;
                    var parentAABB = new FarseerPhysics.Collision.AABB.ctor();
                    parentAABB.Combine$1(Bridge.ref(this._nodes[System.Array.index(sibling, this._nodes)], "AABB"), leafAABB);
                    var parentArea = parentAABB.Perimeter;
                    var cost1 = 2.0 * parentArea;

                    var inheritanceCost = 2.0 * (parentArea - siblingArea);

                    var cost2;
                    if (this._nodes[System.Array.index(child1, this._nodes)].IsLeaf()) {
                        var aabb = new FarseerPhysics.Collision.AABB.ctor();
                        aabb.Combine$1(leafAABB, Bridge.ref(this._nodes[System.Array.index(child1, this._nodes)], "AABB"));
                        cost2 = aabb.Perimeter + inheritanceCost;
                    } else {
                        var aabb1 = new FarseerPhysics.Collision.AABB.ctor();
                        aabb1.Combine$1(leafAABB, Bridge.ref(this._nodes[System.Array.index(child1, this._nodes)], "AABB"));
                        var oldArea = this._nodes[System.Array.index(child1, this._nodes)].AABB.Perimeter;
                        var newArea = aabb1.Perimeter;
                        cost2 = (newArea - oldArea) + inheritanceCost;
                    }

                    var cost3;
                    if (this._nodes[System.Array.index(child2, this._nodes)].IsLeaf()) {
                        var aabb2 = new FarseerPhysics.Collision.AABB.ctor();
                        aabb2.Combine$1(leafAABB, Bridge.ref(this._nodes[System.Array.index(child2, this._nodes)], "AABB"));
                        cost3 = aabb2.Perimeter + inheritanceCost;
                    } else {
                        var aabb3 = new FarseerPhysics.Collision.AABB.ctor();
                        aabb3.Combine$1(leafAABB, Bridge.ref(this._nodes[System.Array.index(child2, this._nodes)], "AABB"));
                        var oldArea1 = this._nodes[System.Array.index(child2, this._nodes)].AABB.Perimeter;
                        var newArea1 = aabb3.Perimeter;
                        cost3 = newArea1 - oldArea1 + inheritanceCost;
                    }

                    if (cost1 < cost2 && cost1 < cost3) {
                        break;
                    }

                    this._nodes[System.Array.index(sibling, this._nodes)].AABB.Combine(leafAABB);

                    if (cost2 < cost3) {
                        sibling = child1;
                    } else {
                        sibling = child2;
                    }
                }

                var oldParent = this._nodes[System.Array.index(sibling, this._nodes)].ParentOrNext;
                var newParent = this.AllocateNode();
                this._nodes[System.Array.index(newParent, this._nodes)].ParentOrNext = oldParent;
                this._nodes[System.Array.index(newParent, this._nodes)].UserData = Bridge.getDefaultValue(T);
                this._nodes[System.Array.index(newParent, this._nodes)].AABB.Combine$1(leafAABB, Bridge.ref(this._nodes[System.Array.index(sibling, this._nodes)], "AABB"));
                this._nodes[System.Array.index(newParent, this._nodes)].LeafCount = (this._nodes[System.Array.index(sibling, this._nodes)].LeafCount + 1) | 0;

                if (oldParent !== FarseerPhysics.Collision.DynamicTree$1(T).NullNode) {
                    if (this._nodes[System.Array.index(oldParent, this._nodes)].Child1 === sibling) {
                        this._nodes[System.Array.index(oldParent, this._nodes)].Child1 = newParent;
                    } else {
                        this._nodes[System.Array.index(oldParent, this._nodes)].Child2 = newParent;
                    }

                    this._nodes[System.Array.index(newParent, this._nodes)].Child1 = sibling;
                    this._nodes[System.Array.index(newParent, this._nodes)].Child2 = leaf;
                    this._nodes[System.Array.index(sibling, this._nodes)].ParentOrNext = newParent;
                    this._nodes[System.Array.index(leaf, this._nodes)].ParentOrNext = newParent;
                } else {
                    this._nodes[System.Array.index(newParent, this._nodes)].Child1 = sibling;
                    this._nodes[System.Array.index(newParent, this._nodes)].Child2 = leaf;
                    this._nodes[System.Array.index(sibling, this._nodes)].ParentOrNext = newParent;
                    this._nodes[System.Array.index(leaf, this._nodes)].ParentOrNext = newParent;
                    this._root = newParent;
                }
            },
            RemoveLeaf: function (leaf) {
                if (leaf === this._root) {
                    this._root = FarseerPhysics.Collision.DynamicTree$1(T).NullNode;
                    return;
                }

                var parent = this._nodes[System.Array.index(leaf, this._nodes)].ParentOrNext;
                var grandParent = this._nodes[System.Array.index(parent, this._nodes)].ParentOrNext;
                var sibling;
                if (this._nodes[System.Array.index(parent, this._nodes)].Child1 === leaf) {
                    sibling = this._nodes[System.Array.index(parent, this._nodes)].Child2;
                } else {
                    sibling = this._nodes[System.Array.index(parent, this._nodes)].Child1;
                }

                if (grandParent !== FarseerPhysics.Collision.DynamicTree$1(T).NullNode) {
                    if (this._nodes[System.Array.index(grandParent, this._nodes)].Child1 === parent) {
                        this._nodes[System.Array.index(grandParent, this._nodes)].Child1 = sibling;
                    } else {
                        this._nodes[System.Array.index(grandParent, this._nodes)].Child2 = sibling;
                    }
                    this._nodes[System.Array.index(sibling, this._nodes)].ParentOrNext = grandParent;
                    this.FreeNode(parent);

                    parent = grandParent;
                    while (parent !== FarseerPhysics.Collision.DynamicTree$1(T).NullNode) {
                        this._nodes[System.Array.index(parent, this._nodes)].AABB.Combine$1(Bridge.ref(this._nodes[System.Array.index(this._nodes[System.Array.index(parent, this._nodes)].Child1, this._nodes)], "AABB"), Bridge.ref(this._nodes[System.Array.index(this._nodes[System.Array.index(parent, this._nodes)].Child2, this._nodes)], "AABB"));

                        System.Diagnostics.Debug.Assert(this._nodes[System.Array.index(parent, this._nodes)].LeafCount > 0);
                        this._nodes[System.Array.index(parent, this._nodes)].LeafCount = (this._nodes[System.Array.index(parent, this._nodes)].LeafCount - 1) | 0;

                        parent = this._nodes[System.Array.index(parent, this._nodes)].ParentOrNext;
                    }
                } else {
                    this._root = sibling;
                    this._nodes[System.Array.index(sibling, this._nodes)].ParentOrNext = FarseerPhysics.Collision.DynamicTree$1(T).NullNode;
                    this.FreeNode(parent);
                }
            }
        }
    }; });

    Bridge.define("FarseerPhysics.Collision.IBroadPhase", {
        $kind: "interface"
    });

    /**
     * A node in the dynamic tree. The client does not interact with this directly.
     *
     * @class FarseerPhysics.Collision.DynamicTreeNode$1
     */
    Bridge.define("FarseerPhysics.Collision.DynamicTreeNode$1", function (T) { return {
        $kind: "struct",
        statics: {
            methods: {
                getDefaultValue: function () { return new (FarseerPhysics.Collision.DynamicTreeNode$1(T))(); }
            }
        },
        fields: {
            /**
             * This is the fattened AABB.
             *
             * @instance
             * @memberof FarseerPhysics.Collision.DynamicTreeNode$1
             * @type FarseerPhysics.Collision.AABB
             */
            AABB: null,
            Child1: 0,
            Child2: 0,
            LeafCount: 0,
            ParentOrNext: 0,
            UserData: Bridge.getDefaultValue(T)
        },
        ctors: {
            init: function () {
                this.AABB = new FarseerPhysics.Collision.AABB();
            },
            ctor: function () {
                this.$initialize();
            }
        },
        methods: {
            IsLeaf: function () {
                return this.Child1 === FarseerPhysics.Collision.DynamicTree$1(T).NullNode;
            },
            getHashCode: function () {
                var h = Bridge.addHash([4372343954, this.AABB, this.Child1, this.Child2, this.LeafCount, this.ParentOrNext, this.UserData]);
                return h;
            },
            equals: function (o) {
                if (!Bridge.is(o, FarseerPhysics.Collision.DynamicTreeNode$1(T))) {
                    return false;
                }
                return Bridge.equals(this.AABB, o.AABB) && Bridge.equals(this.Child1, o.Child1) && Bridge.equals(this.Child2, o.Child2) && Bridge.equals(this.LeafCount, o.LeafCount) && Bridge.equals(this.ParentOrNext, o.ParentOrNext) && Bridge.equals(this.UserData, o.UserData);
            },
            $clone: function (to) {
                var s = to || new (FarseerPhysics.Collision.DynamicTreeNode$1(T))();
                s.AABB = this.AABB.$clone();
                s.Child1 = this.Child1;
                s.Child2 = this.Child2;
                s.LeafCount = this.LeafCount;
                s.ParentOrNext = this.ParentOrNext;
                s.UserData = this.UserData;
                return s;
            }
        }
    }; });

    Bridge.define("FarseerPhysics.Collision.EPAxis", {
        $kind: "struct",
        statics: {
            methods: {
                getDefaultValue: function () { return new FarseerPhysics.Collision.EPAxis(); }
            }
        },
        fields: {
            Index: 0,
            Separation: 0,
            Type: 0
        },
        ctors: {
            ctor: function () {
                this.$initialize();
            }
        },
        methods: {
            getHashCode: function () {
                var h = Bridge.addHash([2017575854, this.Index, this.Separation, this.Type]);
                return h;
            },
            equals: function (o) {
                if (!Bridge.is(o, FarseerPhysics.Collision.EPAxis)) {
                    return false;
                }
                return Bridge.equals(this.Index, o.Index) && Bridge.equals(this.Separation, o.Separation) && Bridge.equals(this.Type, o.Type);
            },
            $clone: function (to) {
                var s = to || new FarseerPhysics.Collision.EPAxis();
                s.Index = this.Index;
                s.Separation = this.Separation;
                s.Type = this.Type;
                return s;
            }
        }
    });

    Bridge.define("FarseerPhysics.Collision.EPAxisType", {
        $kind: "enum",
        statics: {
            fields: {
                Unknown: 0,
                EdgeA: 1,
                EdgeB: 2
            }
        }
    });

    /**
     * This lets us treate and edge shape and a polygon in the same
     way in the SAT collider.
     *
     * @public
     * @class FarseerPhysics.Collision.EPProxy
     */
    Bridge.define("FarseerPhysics.Collision.EPProxy", {
        fields: {
            Centroid: null,
            Count: 0,
            Normals: null,
            Vertices: null
        },
        ctors: {
            init: function () {
                this.Centroid = new Microsoft.Xna.Framework.Vector2();
                this.Normals = System.Array.init(FarseerPhysics.Settings.MaxPolygonVertices, function (){
                    return new Microsoft.Xna.Framework.Vector2();
                }, Microsoft.Xna.Framework.Vector2);
                this.Vertices = System.Array.init(FarseerPhysics.Settings.MaxPolygonVertices, function (){
                    return new Microsoft.Xna.Framework.Vector2();
                }, Microsoft.Xna.Framework.Vector2);
            }
        }
    });

    /**
     * Edge shape plus more stuff.
     *
     * @public
     * @class FarseerPhysics.Collision.FatEdge
     */
    Bridge.define("FarseerPhysics.Collision.FatEdge", {
        $kind: "struct",
        statics: {
            methods: {
                getDefaultValue: function () { return new FarseerPhysics.Collision.FatEdge(); }
            }
        },
        fields: {
            HasVertex0: false,
            HasVertex3: false,
            Normal: null,
            V0: null,
            V1: null,
            V2: null,
            V3: null
        },
        ctors: {
            init: function () {
                this.Normal = new Microsoft.Xna.Framework.Vector2();
                this.V0 = new Microsoft.Xna.Framework.Vector2();
                this.V1 = new Microsoft.Xna.Framework.Vector2();
                this.V2 = new Microsoft.Xna.Framework.Vector2();
                this.V3 = new Microsoft.Xna.Framework.Vector2();
            },
            ctor: function () {
                this.$initialize();
            }
        },
        methods: {
            getHashCode: function () {
                var h = Bridge.addHash([1171900586, this.HasVertex0, this.HasVertex3, this.Normal, this.V0, this.V1, this.V2, this.V3]);
                return h;
            },
            equals: function (o) {
                if (!Bridge.is(o, FarseerPhysics.Collision.FatEdge)) {
                    return false;
                }
                return Bridge.equals(this.HasVertex0, o.HasVertex0) && Bridge.equals(this.HasVertex3, o.HasVertex3) && Bridge.equals(this.Normal, o.Normal) && Bridge.equals(this.V0, o.V0) && Bridge.equals(this.V1, o.V1) && Bridge.equals(this.V2, o.V2) && Bridge.equals(this.V3, o.V3);
            },
            $clone: function (to) {
                var s = to || new FarseerPhysics.Collision.FatEdge();
                s.HasVertex0 = this.HasVertex0;
                s.HasVertex3 = this.HasVertex3;
                s.Normal = this.Normal.$clone();
                s.V0 = this.V0.$clone();
                s.V1 = this.V1.$clone();
                s.V2 = this.V2.$clone();
                s.V3 = this.V3.$clone();
                return s;
            }
        }
    });

    /**
     * A manifold for two touching convex Shapes.
     Box2D supports multiple types of contact:
     - clip point versus plane with radius
     - point versus point with radius (circles)
     The local point usage depends on the manifold type:
     -ShapeType.Circles: the local center of circleA
     -SeparationFunction.FaceA: the center of faceA
     -SeparationFunction.FaceB: the center of faceB
     Similarly the local normal usage:
     -ShapeType.Circles: not used
     -SeparationFunction.FaceA: the normal on polygonA
     -SeparationFunction.FaceB: the normal on polygonB
     We store contacts in this way so that position correction can
     account for movement, which is critical for continuous physics.
     All contact scenarios must be expressed in one of these types.
     This structure is stored across time steps, so we keep it small.
     *
     * @public
     * @class FarseerPhysics.Collision.Manifold
     */
    Bridge.define("FarseerPhysics.Collision.Manifold", {
        $kind: "struct",
        statics: {
            methods: {
                getDefaultValue: function () { return new FarseerPhysics.Collision.Manifold(); }
            }
        },
        fields: {
            /**
             * Not use for Type.SeparationFunction.Points
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Collision.Manifold
             * @type Microsoft.Xna.Framework.Vector2
             */
            LocalNormal: null,
            /**
             * Usage depends on manifold type
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Collision.Manifold
             * @type Microsoft.Xna.Framework.Vector2
             */
            LocalPoint: null,
            /**
             * The number of manifold points
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Collision.Manifold
             * @type number
             */
            PointCount: 0,
            /**
             * The points of contact
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Collision.Manifold
             * @type FarseerPhysics.Common.FixedArray2$1
             */
            Points: null,
            Type: 0
        },
        ctors: {
            init: function () {
                this.LocalNormal = new Microsoft.Xna.Framework.Vector2();
                this.LocalPoint = new Microsoft.Xna.Framework.Vector2();
                this.Points = new (FarseerPhysics.Common.FixedArray2$1(FarseerPhysics.Collision.ManifoldPoint))();
            },
            ctor: function () {
                this.$initialize();
            }
        },
        methods: {
            getHashCode: function () {
                var h = Bridge.addHash([3453669555, this.LocalNormal, this.LocalPoint, this.PointCount, this.Points, this.Type]);
                return h;
            },
            equals: function (o) {
                if (!Bridge.is(o, FarseerPhysics.Collision.Manifold)) {
                    return false;
                }
                return Bridge.equals(this.LocalNormal, o.LocalNormal) && Bridge.equals(this.LocalPoint, o.LocalPoint) && Bridge.equals(this.PointCount, o.PointCount) && Bridge.equals(this.Points, o.Points) && Bridge.equals(this.Type, o.Type);
            },
            $clone: function (to) {
                var s = to || new FarseerPhysics.Collision.Manifold();
                s.LocalNormal = this.LocalNormal.$clone();
                s.LocalPoint = this.LocalPoint.$clone();
                s.PointCount = this.PointCount;
                s.Points = this.Points.$clone();
                s.Type = this.Type;
                return s;
            }
        }
    });

    /**
     * A manifold point is a contact point belonging to a contact
     manifold. It holds details related to the geometry and dynamics
     of the contact points.
     The local point usage depends on the manifold type:
     -ShapeType.Circles: the local center of circleB
     -SeparationFunction.FaceA: the local center of cirlceB or the clip point of polygonB
     -SeparationFunction.FaceB: the clip point of polygonA
     This structure is stored across time steps, so we keep it small.
     Note: the impulses are used for internal caching and may not
     provide reliable contact forces, especially for high speed collisions.
     *
     * @public
     * @class FarseerPhysics.Collision.ManifoldPoint
     */
    Bridge.define("FarseerPhysics.Collision.ManifoldPoint", {
        $kind: "struct",
        statics: {
            methods: {
                getDefaultValue: function () { return new FarseerPhysics.Collision.ManifoldPoint(); }
            }
        },
        fields: {
            /**
             * Uniquely identifies a contact point between two Shapes
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Collision.ManifoldPoint
             * @type FarseerPhysics.Collision.ContactID
             */
            Id: null,
            LocalPoint: null,
            NormalImpulse: 0,
            TangentImpulse: 0
        },
        ctors: {
            init: function () {
                this.Id = new FarseerPhysics.Collision.ContactID();
                this.LocalPoint = new Microsoft.Xna.Framework.Vector2();
            },
            ctor: function () {
                this.$initialize();
            }
        },
        methods: {
            getHashCode: function () {
                var h = Bridge.addHash([5306073207, this.Id, this.LocalPoint, this.NormalImpulse, this.TangentImpulse]);
                return h;
            },
            equals: function (o) {
                if (!Bridge.is(o, FarseerPhysics.Collision.ManifoldPoint)) {
                    return false;
                }
                return Bridge.equals(this.Id, o.Id) && Bridge.equals(this.LocalPoint, o.LocalPoint) && Bridge.equals(this.NormalImpulse, o.NormalImpulse) && Bridge.equals(this.TangentImpulse, o.TangentImpulse);
            },
            $clone: function (to) {
                var s = to || new FarseerPhysics.Collision.ManifoldPoint();
                s.Id = this.Id.$clone();
                s.LocalPoint = this.LocalPoint.$clone();
                s.NormalImpulse = this.NormalImpulse;
                s.TangentImpulse = this.TangentImpulse;
                return s;
            }
        }
    });

    Bridge.define("FarseerPhysics.Collision.ManifoldType", {
        $kind: "enum",
        statics: {
            fields: {
                Circles: 0,
                FaceA: 1,
                FaceB: 2
            }
        }
    });

    Bridge.define("FarseerPhysics.Collision.Pair", {
        inherits: function () { return [System.IComparable$1(FarseerPhysics.Collision.Pair)]; },
        $kind: "struct",
        statics: {
            methods: {
                getDefaultValue: function () { return new FarseerPhysics.Collision.Pair(); }
            }
        },
        fields: {
            ProxyIdA: 0,
            ProxyIdB: 0
        },
        alias: ["compareTo", ["System$IComparable$1$FarseerPhysics$Collision$Pair$compareTo", "System$IComparable$1$compareTo"]],
        ctors: {
            ctor: function () {
                this.$initialize();
            }
        },
        methods: {
            compareTo: function (other) {
                if (this.ProxyIdA < other.ProxyIdA) {
                    return -1;
                }
                if (this.ProxyIdA === other.ProxyIdA) {
                    if (this.ProxyIdB < other.ProxyIdB) {
                        return -1;
                    }
                    if (this.ProxyIdB === other.ProxyIdB) {
                        return 0;
                    }
                }

                return 1;
            },
            getHashCode: function () {
                var h = Bridge.addHash([1919508816, this.ProxyIdA, this.ProxyIdB]);
                return h;
            },
            equals: function (o) {
                if (!Bridge.is(o, FarseerPhysics.Collision.Pair)) {
                    return false;
                }
                return Bridge.equals(this.ProxyIdA, o.ProxyIdA) && Bridge.equals(this.ProxyIdB, o.ProxyIdB);
            },
            $clone: function (to) {
                var s = to || new FarseerPhysics.Collision.Pair();
                s.ProxyIdA = this.ProxyIdA;
                s.ProxyIdB = this.ProxyIdB;
                return s;
            }
        }
    });

    /**
     * This is used for determining the state of contact points.
     *
     * @public
     * @class FarseerPhysics.Collision.PointState
     */
    Bridge.define("FarseerPhysics.Collision.PointState", {
        $kind: "enum",
        statics: {
            fields: {
                /**
                 * Point does not exist
                 *
                 * @static
                 * @public
                 * @memberof FarseerPhysics.Collision.PointState
                 * @constant
                 * @default 0
                 * @type FarseerPhysics.Collision.PointState
                 */
                Null: 0,
                /**
                 * Point was added in the update
                 *
                 * @static
                 * @public
                 * @memberof FarseerPhysics.Collision.PointState
                 * @constant
                 * @default 1
                 * @type FarseerPhysics.Collision.PointState
                 */
                Add: 1,
                /**
                 * Point persisted across the update
                 *
                 * @static
                 * @public
                 * @memberof FarseerPhysics.Collision.PointState
                 * @constant
                 * @default 2
                 * @type FarseerPhysics.Collision.PointState
                 */
                Persist: 2,
                /**
                 * Point was removed in the update
                 *
                 * @static
                 * @public
                 * @memberof FarseerPhysics.Collision.PointState
                 * @constant
                 * @default 3
                 * @type FarseerPhysics.Collision.PointState
                 */
                Remove: 3
            }
        }
    });

    /**
     * Ray-cast input data. The ray extends from p1 to p1 + maxFraction * (p2 - p1).
     *
     * @public
     * @class FarseerPhysics.Collision.RayCastInput
     */
    Bridge.define("FarseerPhysics.Collision.RayCastInput", {
        $kind: "struct",
        statics: {
            methods: {
                getDefaultValue: function () { return new FarseerPhysics.Collision.RayCastInput(); }
            }
        },
        fields: {
            MaxFraction: 0,
            Point1: null,
            Point2: null
        },
        ctors: {
            init: function () {
                this.Point1 = new Microsoft.Xna.Framework.Vector2();
                this.Point2 = new Microsoft.Xna.Framework.Vector2();
            },
            ctor: function () {
                this.$initialize();
            }
        },
        methods: {
            getHashCode: function () {
                var h = Bridge.addHash([4318250273, this.MaxFraction, this.Point1, this.Point2]);
                return h;
            },
            equals: function (o) {
                if (!Bridge.is(o, FarseerPhysics.Collision.RayCastInput)) {
                    return false;
                }
                return Bridge.equals(this.MaxFraction, o.MaxFraction) && Bridge.equals(this.Point1, o.Point1) && Bridge.equals(this.Point2, o.Point2);
            },
            $clone: function (to) {
                var s = to || new FarseerPhysics.Collision.RayCastInput();
                s.MaxFraction = this.MaxFraction;
                s.Point1 = this.Point1.$clone();
                s.Point2 = this.Point2.$clone();
                return s;
            }
        }
    });

    /**
     * Ray-cast output data.  The ray hits at p1 + fraction * (p2 - p1), where p1 and p2
     come from RayCastInput.
     *
     * @public
     * @class FarseerPhysics.Collision.RayCastOutput
     */
    Bridge.define("FarseerPhysics.Collision.RayCastOutput", {
        $kind: "struct",
        statics: {
            methods: {
                getDefaultValue: function () { return new FarseerPhysics.Collision.RayCastOutput(); }
            }
        },
        fields: {
            Fraction: 0,
            Normal: null
        },
        ctors: {
            init: function () {
                this.Normal = new Microsoft.Xna.Framework.Vector2();
            },
            ctor: function () {
                this.$initialize();
            }
        },
        methods: {
            getHashCode: function () {
                var h = Bridge.addHash([4435364252, this.Fraction, this.Normal]);
                return h;
            },
            equals: function (o) {
                if (!Bridge.is(o, FarseerPhysics.Collision.RayCastOutput)) {
                    return false;
                }
                return Bridge.equals(this.Fraction, o.Fraction) && Bridge.equals(this.Normal, o.Normal);
            },
            $clone: function (to) {
                var s = to || new FarseerPhysics.Collision.RayCastOutput();
                s.Fraction = this.Fraction;
                s.Normal = this.Normal.$clone();
                return s;
            }
        }
    });

    Bridge.define("FarseerPhysics.Collision.SeparationFunction", {
        statics: {
            fields: {
                _axis: null,
                _localPoint: null,
                _proxyA: null,
                _proxyB: null,
                _sweepA: null,
                _sweepB: null,
                _type: 0
            },
            ctors: {
                init: function () {
                    this._axis = new Microsoft.Xna.Framework.Vector2();
                    this._localPoint = new Microsoft.Xna.Framework.Vector2();
                    this._sweepA = new FarseerPhysics.Common.Sweep();
                    this._sweepB = new FarseerPhysics.Common.Sweep();
                    this._proxyA = new FarseerPhysics.Collision.DistanceProxy();
                    this._proxyB = new FarseerPhysics.Collision.DistanceProxy();
                }
            },
            methods: {
                Set: function (cache, proxyA, sweepA, proxyB, sweepB, t1) {
                    FarseerPhysics.Collision.SeparationFunction._localPoint = Microsoft.Xna.Framework.Vector2.Zero.$clone();
                    FarseerPhysics.Collision.SeparationFunction._proxyA = proxyA;
                    FarseerPhysics.Collision.SeparationFunction._proxyB = proxyB;
                    var count = cache.v.Count;
                    System.Diagnostics.Debug.Assert(0 < count && count < 3);

                    FarseerPhysics.Collision.SeparationFunction._sweepA = sweepA.v.$clone();
                    FarseerPhysics.Collision.SeparationFunction._sweepB = sweepB.v.$clone();

                    var xfA = { v : new FarseerPhysics.Common.Transform() }, xfB = { v : new FarseerPhysics.Common.Transform() };
                    FarseerPhysics.Collision.SeparationFunction._sweepA.GetTransform(xfA, t1);
                    FarseerPhysics.Collision.SeparationFunction._sweepB.GetTransform(xfB, t1);

                    if (count === 1) {
                        FarseerPhysics.Collision.SeparationFunction._type = FarseerPhysics.Collision.SeparationFunctionType.Points;
                        var localPointA = FarseerPhysics.Collision.SeparationFunction._proxyA.Vertices.getItem(cache.v.IndexA.getItem(0)).$clone();
                        var localPointB = FarseerPhysics.Collision.SeparationFunction._proxyB.Vertices.getItem(cache.v.IndexB.getItem(0)).$clone();
                        var pointA = FarseerPhysics.Common.MathUtils.Multiply$2(xfA, localPointA.$clone());
                        var pointB = FarseerPhysics.Common.MathUtils.Multiply$2(xfB, localPointB.$clone());
                        FarseerPhysics.Collision.SeparationFunction._axis = Microsoft.Xna.Framework.Vector2.op_Subtraction(pointB.$clone(), pointA.$clone());
                        FarseerPhysics.Collision.SeparationFunction._axis.Normalize();
                        return;
                    } else if (cache.v.IndexA.getItem(0) === cache.v.IndexA.getItem(1)) {
                        FarseerPhysics.Collision.SeparationFunction._type = FarseerPhysics.Collision.SeparationFunctionType.FaceB;
                        var localPointB1 = proxyB.Vertices.getItem(cache.v.IndexB.getItem(0)).$clone();
                        var localPointB2 = proxyB.Vertices.getItem(cache.v.IndexB.getItem(1)).$clone();

                        var a = Microsoft.Xna.Framework.Vector2.op_Subtraction(localPointB2.$clone(), localPointB1.$clone());
                        FarseerPhysics.Collision.SeparationFunction._axis = new Microsoft.Xna.Framework.Vector2.$ctor2(a.Y, -a.X);
                        FarseerPhysics.Collision.SeparationFunction._axis.Normalize();
                        var normal = FarseerPhysics.Common.MathUtils.Multiply(Bridge.ref(xfB.v, "R"), FarseerPhysics.Collision.SeparationFunction._axis.$clone());

                        FarseerPhysics.Collision.SeparationFunction._localPoint = Microsoft.Xna.Framework.Vector2.op_Multiply$2(0.5, (Microsoft.Xna.Framework.Vector2.op_Addition(localPointB1.$clone(), localPointB2.$clone())));
                        var pointB1 = FarseerPhysics.Common.MathUtils.Multiply$2(xfB, FarseerPhysics.Collision.SeparationFunction._localPoint.$clone());

                        var localPointA1 = proxyA.Vertices.getItem(cache.v.IndexA.getItem(0)).$clone();
                        var pointA1 = FarseerPhysics.Common.MathUtils.Multiply$2(xfA, localPointA1.$clone());

                        var s = Microsoft.Xna.Framework.Vector2.Dot(Microsoft.Xna.Framework.Vector2.op_Subtraction(pointA1.$clone(), pointB1.$clone()), normal.$clone());
                        if (s < 0.0) {
                            FarseerPhysics.Collision.SeparationFunction._axis = Microsoft.Xna.Framework.Vector2.op_UnaryNegation(FarseerPhysics.Collision.SeparationFunction._axis.$clone());
                            s = -s;
                        }
                        return;
                    } else {
                        FarseerPhysics.Collision.SeparationFunction._type = FarseerPhysics.Collision.SeparationFunctionType.FaceA;
                        var localPointA11 = FarseerPhysics.Collision.SeparationFunction._proxyA.Vertices.getItem(cache.v.IndexA.getItem(0)).$clone();
                        var localPointA2 = FarseerPhysics.Collision.SeparationFunction._proxyA.Vertices.getItem(cache.v.IndexA.getItem(1)).$clone();

                        var a1 = Microsoft.Xna.Framework.Vector2.op_Subtraction(localPointA2.$clone(), localPointA11.$clone());
                        FarseerPhysics.Collision.SeparationFunction._axis = new Microsoft.Xna.Framework.Vector2.$ctor2(a1.Y, -a1.X);
                        FarseerPhysics.Collision.SeparationFunction._axis.Normalize();
                        var normal1 = FarseerPhysics.Common.MathUtils.Multiply(Bridge.ref(xfA.v, "R"), FarseerPhysics.Collision.SeparationFunction._axis.$clone());

                        FarseerPhysics.Collision.SeparationFunction._localPoint = Microsoft.Xna.Framework.Vector2.op_Multiply$2(0.5, (Microsoft.Xna.Framework.Vector2.op_Addition(localPointA11.$clone(), localPointA2.$clone())));
                        var pointA2 = FarseerPhysics.Common.MathUtils.Multiply$2(xfA, FarseerPhysics.Collision.SeparationFunction._localPoint.$clone());

                        var localPointB3 = FarseerPhysics.Collision.SeparationFunction._proxyB.Vertices.getItem(cache.v.IndexB.getItem(0)).$clone();
                        var pointB2 = FarseerPhysics.Common.MathUtils.Multiply$2(xfB, localPointB3.$clone());

                        var s1 = Microsoft.Xna.Framework.Vector2.Dot(Microsoft.Xna.Framework.Vector2.op_Subtraction(pointB2.$clone(), pointA2.$clone()), normal1.$clone());
                        if (s1 < 0.0) {
                            FarseerPhysics.Collision.SeparationFunction._axis = Microsoft.Xna.Framework.Vector2.op_UnaryNegation(FarseerPhysics.Collision.SeparationFunction._axis.$clone());
                            s1 = -s1;
                        }
                        return;
                    }
                },
                FindMinSeparation: function (indexA, indexB, t) {
                    var xfA = { v : new FarseerPhysics.Common.Transform() }, xfB = { v : new FarseerPhysics.Common.Transform() };
                    FarseerPhysics.Collision.SeparationFunction._sweepA.GetTransform(xfA, t);
                    FarseerPhysics.Collision.SeparationFunction._sweepB.GetTransform(xfB, t);

                    switch (FarseerPhysics.Collision.SeparationFunction._type) {
                        case FarseerPhysics.Collision.SeparationFunctionType.Points: 
                            {
                                var axisA = FarseerPhysics.Common.MathUtils.MultiplyT(Bridge.ref(xfA.v, "R"), FarseerPhysics.Collision.SeparationFunction._axis.$clone());
                                var axisB = FarseerPhysics.Common.MathUtils.MultiplyT(Bridge.ref(xfB.v, "R"), Microsoft.Xna.Framework.Vector2.op_UnaryNegation(FarseerPhysics.Collision.SeparationFunction._axis.$clone()));

                                indexA.v = FarseerPhysics.Collision.SeparationFunction._proxyA.GetSupport(axisA.$clone());
                                indexB.v = FarseerPhysics.Collision.SeparationFunction._proxyB.GetSupport(axisB.$clone());

                                var localPointA = FarseerPhysics.Collision.SeparationFunction._proxyA.Vertices.getItem(indexA.v).$clone();
                                var localPointB = FarseerPhysics.Collision.SeparationFunction._proxyB.Vertices.getItem(indexB.v).$clone();

                                var pointA = FarseerPhysics.Common.MathUtils.Multiply$2(xfA, localPointA.$clone());
                                var pointB = FarseerPhysics.Common.MathUtils.Multiply$2(xfB, localPointB.$clone());

                                var separation = Microsoft.Xna.Framework.Vector2.Dot(Microsoft.Xna.Framework.Vector2.op_Subtraction(pointB.$clone(), pointA.$clone()), FarseerPhysics.Collision.SeparationFunction._axis.$clone());
                                return separation;
                            }
                        case FarseerPhysics.Collision.SeparationFunctionType.FaceA: 
                            {
                                var normal = FarseerPhysics.Common.MathUtils.Multiply(Bridge.ref(xfA.v, "R"), FarseerPhysics.Collision.SeparationFunction._axis.$clone());
                                var pointA1 = FarseerPhysics.Common.MathUtils.Multiply$2(xfA, FarseerPhysics.Collision.SeparationFunction._localPoint.$clone());

                                var axisB1 = FarseerPhysics.Common.MathUtils.MultiplyT(Bridge.ref(xfB.v, "R"), Microsoft.Xna.Framework.Vector2.op_UnaryNegation(normal.$clone()));

                                indexA.v = -1;
                                indexB.v = FarseerPhysics.Collision.SeparationFunction._proxyB.GetSupport(axisB1.$clone());

                                var localPointB1 = FarseerPhysics.Collision.SeparationFunction._proxyB.Vertices.getItem(indexB.v).$clone();
                                var pointB1 = FarseerPhysics.Common.MathUtils.Multiply$2(xfB, localPointB1.$clone());

                                var separation1 = Microsoft.Xna.Framework.Vector2.Dot(Microsoft.Xna.Framework.Vector2.op_Subtraction(pointB1.$clone(), pointA1.$clone()), normal.$clone());
                                return separation1;
                            }
                        case FarseerPhysics.Collision.SeparationFunctionType.FaceB: 
                            {
                                var normal1 = FarseerPhysics.Common.MathUtils.Multiply(Bridge.ref(xfB.v, "R"), FarseerPhysics.Collision.SeparationFunction._axis.$clone());
                                var pointB2 = FarseerPhysics.Common.MathUtils.Multiply$2(xfB, FarseerPhysics.Collision.SeparationFunction._localPoint.$clone());

                                var axisA1 = FarseerPhysics.Common.MathUtils.MultiplyT(Bridge.ref(xfA.v, "R"), Microsoft.Xna.Framework.Vector2.op_UnaryNegation(normal1.$clone()));

                                indexB.v = -1;
                                indexA.v = FarseerPhysics.Collision.SeparationFunction._proxyA.GetSupport(axisA1.$clone());

                                var localPointA1 = FarseerPhysics.Collision.SeparationFunction._proxyA.Vertices.getItem(indexA.v).$clone();
                                var pointA2 = FarseerPhysics.Common.MathUtils.Multiply$2(xfA, localPointA1.$clone());

                                var separation2 = Microsoft.Xna.Framework.Vector2.Dot(Microsoft.Xna.Framework.Vector2.op_Subtraction(pointA2.$clone(), pointB2.$clone()), normal1.$clone());
                                return separation2;
                            }
                        default: 
                            System.Diagnostics.Debug.Assert(false);
                            indexA.v = -1;
                            indexB.v = -1;
                            return 0.0;
                    }
                },
                Evaluate: function (indexA, indexB, t) {
                    var xfA = { v : new FarseerPhysics.Common.Transform() }, xfB = { v : new FarseerPhysics.Common.Transform() };
                    FarseerPhysics.Collision.SeparationFunction._sweepA.GetTransform(xfA, t);
                    FarseerPhysics.Collision.SeparationFunction._sweepB.GetTransform(xfB, t);

                    switch (FarseerPhysics.Collision.SeparationFunction._type) {
                        case FarseerPhysics.Collision.SeparationFunctionType.Points: 
                            {
                                var axisA = FarseerPhysics.Common.MathUtils.MultiplyT(Bridge.ref(xfA.v, "R"), FarseerPhysics.Collision.SeparationFunction._axis.$clone());
                                var axisB = FarseerPhysics.Common.MathUtils.MultiplyT(Bridge.ref(xfB.v, "R"), Microsoft.Xna.Framework.Vector2.op_UnaryNegation(FarseerPhysics.Collision.SeparationFunction._axis.$clone()));

                                var localPointA = FarseerPhysics.Collision.SeparationFunction._proxyA.Vertices.getItem(indexA).$clone();
                                var localPointB = FarseerPhysics.Collision.SeparationFunction._proxyB.Vertices.getItem(indexB).$clone();

                                var pointA = FarseerPhysics.Common.MathUtils.Multiply$2(xfA, localPointA.$clone());
                                var pointB = FarseerPhysics.Common.MathUtils.Multiply$2(xfB, localPointB.$clone());
                                var separation = Microsoft.Xna.Framework.Vector2.Dot(Microsoft.Xna.Framework.Vector2.op_Subtraction(pointB.$clone(), pointA.$clone()), FarseerPhysics.Collision.SeparationFunction._axis.$clone());

                                return separation;
                            }
                        case FarseerPhysics.Collision.SeparationFunctionType.FaceA: 
                            {
                                var normal = FarseerPhysics.Common.MathUtils.Multiply(Bridge.ref(xfA.v, "R"), FarseerPhysics.Collision.SeparationFunction._axis.$clone());
                                var pointA1 = FarseerPhysics.Common.MathUtils.Multiply$2(xfA, FarseerPhysics.Collision.SeparationFunction._localPoint.$clone());

                                var axisB1 = FarseerPhysics.Common.MathUtils.MultiplyT(Bridge.ref(xfB.v, "R"), Microsoft.Xna.Framework.Vector2.op_UnaryNegation(normal.$clone()));

                                var localPointB1 = FarseerPhysics.Collision.SeparationFunction._proxyB.Vertices.getItem(indexB).$clone();
                                var pointB1 = FarseerPhysics.Common.MathUtils.Multiply$2(xfB, localPointB1.$clone());

                                var separation1 = Microsoft.Xna.Framework.Vector2.Dot(Microsoft.Xna.Framework.Vector2.op_Subtraction(pointB1.$clone(), pointA1.$clone()), normal.$clone());
                                return separation1;
                            }
                        case FarseerPhysics.Collision.SeparationFunctionType.FaceB: 
                            {
                                var normal1 = FarseerPhysics.Common.MathUtils.Multiply(Bridge.ref(xfB.v, "R"), FarseerPhysics.Collision.SeparationFunction._axis.$clone());
                                var pointB2 = FarseerPhysics.Common.MathUtils.Multiply$2(xfB, FarseerPhysics.Collision.SeparationFunction._localPoint.$clone());

                                var axisA1 = FarseerPhysics.Common.MathUtils.MultiplyT(Bridge.ref(xfA.v, "R"), Microsoft.Xna.Framework.Vector2.op_UnaryNegation(normal1.$clone()));

                                var localPointA1 = FarseerPhysics.Collision.SeparationFunction._proxyA.Vertices.getItem(indexA).$clone();
                                var pointA2 = FarseerPhysics.Common.MathUtils.Multiply$2(xfA, localPointA1.$clone());

                                var separation2 = Microsoft.Xna.Framework.Vector2.Dot(Microsoft.Xna.Framework.Vector2.op_Subtraction(pointA2.$clone(), pointB2.$clone()), normal1.$clone());
                                return separation2;
                            }
                        default: 
                            System.Diagnostics.Debug.Assert(false);
                            return 0.0;
                    }
                }
            }
        }
    });

    Bridge.define("FarseerPhysics.Collision.SeparationFunctionType", {
        $kind: "enum",
        statics: {
            fields: {
                Points: 0,
                FaceA: 1,
                FaceB: 2
            }
        }
    });

    /** @namespace FarseerPhysics.Collision.Shapes */

    /**
     * A shape is used for collision detection. You can create a shape however you like.
     Shapes used for simulation in World are created automatically when a Fixture
     is created. Shapes may encapsulate a one or more child shapes.
     *
     * @abstract
     * @public
     * @class FarseerPhysics.Collision.Shapes.Shape
     */
    Bridge.define("FarseerPhysics.Collision.Shapes.Shape", {
        statics: {
            fields: {
                _shapeIdCounter: 0
            }
        },
        fields: {
            MassData: null,
            ShapeId: 0,
            _density: 0,
            _radius: 0,
            /**
             * Get the type of this shape.
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Collision.Shapes.Shape
             * @function ShapeType
             * @type FarseerPhysics.Collision.Shapes.ShapeType
             */
            ShapeType: 0
        },
        props: {
            /**
             * Gets or sets the density.
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Collision.Shapes.Shape
             * @function Density
             * @type number
             */
            Density: {
                get: function () {
                    return this._density;
                },
                set: function (value) {
                    this._density = value;
                    this.ComputeProperties();
                }
            },
            /**
             * Radius of the Shape
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Collision.Shapes.Shape
             * @function Radius
             * @type number
             */
            Radius: {
                get: function () {
                    return this._radius;
                },
                set: function (value) {
                    this._radius = value;
                    this.ComputeProperties();
                }
            }
        },
        ctors: {
            init: function () {
                this.MassData = new FarseerPhysics.Collision.Shapes.MassData();
            },
            ctor: function (density) {
                var $t;
                this.$initialize();
                this._density = density;
                this.ShapeType = FarseerPhysics.Collision.Shapes.ShapeType.Unknown;
                this.ShapeId = Bridge.identity(FarseerPhysics.Collision.Shapes.Shape._shapeIdCounter, ($t = (FarseerPhysics.Collision.Shapes.Shape._shapeIdCounter + 1) | 0, FarseerPhysics.Collision.Shapes.Shape._shapeIdCounter = $t, $t));
            }
        },
        methods: {
            CompareTo: function (shape) {
                if (Bridge.is(shape, FarseerPhysics.Collision.Shapes.PolygonShape) && Bridge.is(this, FarseerPhysics.Collision.Shapes.PolygonShape)) {
                    return Bridge.cast(this, FarseerPhysics.Collision.Shapes.PolygonShape).CompareTo$1(Bridge.cast(shape, FarseerPhysics.Collision.Shapes.PolygonShape));
                }

                if (Bridge.is(shape, FarseerPhysics.Collision.Shapes.CircleShape) && Bridge.is(this, FarseerPhysics.Collision.Shapes.CircleShape)) {
                    return Bridge.cast(this, FarseerPhysics.Collision.Shapes.CircleShape).CompareTo$1(Bridge.cast(shape, FarseerPhysics.Collision.Shapes.CircleShape));
                }

                if (Bridge.is(shape, FarseerPhysics.Collision.Shapes.EdgeShape) && Bridge.is(this, FarseerPhysics.Collision.Shapes.EdgeShape)) {
                    return Bridge.cast(this, FarseerPhysics.Collision.Shapes.EdgeShape).CompareTo$1(Bridge.cast(shape, FarseerPhysics.Collision.Shapes.EdgeShape));
                }

                return false;
            }
        }
    });

    /**
     * This holds the mass data computed for a shape.
     *
     * @public
     * @class FarseerPhysics.Collision.Shapes.MassData
     * @implements  System.IEquatable$1
     */
    Bridge.define("FarseerPhysics.Collision.Shapes.MassData", {
        inherits: function () { return [System.IEquatable$1(FarseerPhysics.Collision.Shapes.MassData)]; },
        $kind: "struct",
        statics: {
            methods: {
                op_Equality: function (left, right) {
                    return (left.Area === right.Area && left.Mass === right.Mass && Microsoft.Xna.Framework.Vector2.op_Equality(left.Centroid.$clone(), right.Centroid.$clone()) && left.Inertia === right.Inertia);
                },
                op_Inequality: function (left, right) {
                    return !(FarseerPhysics.Collision.Shapes.MassData.op_Equality(left.$clone(), right.$clone()));
                },
                getDefaultValue: function () { return new FarseerPhysics.Collision.Shapes.MassData(); }
            }
        },
        fields: {
            /**
             * The area of the shape
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Collision.Shapes.MassData
             * @type number
             */
            Area: 0,
            /**
             * The position of the shape's centroid relative to the shape's origin.
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Collision.Shapes.MassData
             * @type Microsoft.Xna.Framework.Vector2
             */
            Centroid: null,
            /**
             * The rotational inertia of the shape about the local origin.
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Collision.Shapes.MassData
             * @type number
             */
            Inertia: 0,
            /**
             * The mass of the shape, usually in kilograms.
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Collision.Shapes.MassData
             * @type number
             */
            Mass: 0
        },
        alias: ["equalsT", "System$IEquatable$1$FarseerPhysics$Collision$Shapes$MassData$equalsT"],
        ctors: {
            init: function () {
                this.Centroid = new Microsoft.Xna.Framework.Vector2();
            },
            ctor: function () {
                this.$initialize();
            }
        },
        methods: {
            equalsT: function (other) {
                return FarseerPhysics.Collision.Shapes.MassData.op_Equality(this, other.$clone());
            },
            equals: function (obj) {
                if (Bridge.referenceEquals(null, obj)) {
                    return false;
                }
                if (!Bridge.referenceEquals(Bridge.getType(obj), FarseerPhysics.Collision.Shapes.MassData)) {
                    return false;
                }
                return this.equalsT(System.Nullable.getValue(Bridge.cast(Bridge.unbox(obj, FarseerPhysics.Collision.Shapes.MassData), FarseerPhysics.Collision.Shapes.MassData)));
            },
            getHashCode: function () {
                var result = System.Single.getHashCode(this.Area);
                result = (Bridge.Int.mul(result, 397)) ^ this.Centroid.getHashCode();
                result = (Bridge.Int.mul(result, 397)) ^ System.Single.getHashCode(this.Inertia);
                result = (Bridge.Int.mul(result, 397)) ^ System.Single.getHashCode(this.Mass);
                return result;
            },
            $clone: function (to) {
                var s = to || new FarseerPhysics.Collision.Shapes.MassData();
                s.Area = this.Area;
                s.Centroid = this.Centroid.$clone();
                s.Inertia = this.Inertia;
                s.Mass = this.Mass;
                return s;
            }
        }
    });

    Bridge.define("FarseerPhysics.Collision.Shapes.ShapeType", {
        $kind: "enum",
        statics: {
            fields: {
                Unknown: -1,
                Circle: 0,
                Edge: 1,
                Polygon: 2,
                Loop: 3,
                TypeCount: 4
            }
        }
    });

    Bridge.define("FarseerPhysics.Collision.Simplex", {
        $kind: "struct",
        statics: {
            methods: {
                getDefaultValue: function () { return new FarseerPhysics.Collision.Simplex(); }
            }
        },
        fields: {
            Count: 0,
            V: null
        },
        ctors: {
            init: function () {
                this.V = new (FarseerPhysics.Common.FixedArray3$1(FarseerPhysics.Collision.SimplexVertex))();
            },
            ctor: function () {
                this.$initialize();
            }
        },
        methods: {
            ReadCache: function (cache, proxyA, transformA, proxyB, transformB) {
                System.Diagnostics.Debug.Assert(cache.v.Count <= 3);

                this.Count = cache.v.Count;
                for (var i = 0; i < this.Count; i = (i + 1) | 0) {
                    var v = this.V.getItem(i).$clone();
                    v.IndexA = cache.v.IndexA.getItem(i);
                    v.IndexB = cache.v.IndexB.getItem(i);
                    var wALocal = proxyA.Vertices.getItem(v.IndexA).$clone();
                    var wBLocal = proxyB.Vertices.getItem(v.IndexB).$clone();
                    v.WA = FarseerPhysics.Common.MathUtils.Multiply$2(transformA, wALocal.$clone());
                    v.WB = FarseerPhysics.Common.MathUtils.Multiply$2(transformB, wBLocal.$clone());
                    v.W = Microsoft.Xna.Framework.Vector2.op_Subtraction(v.WB.$clone(), v.WA.$clone());
                    v.A = 0.0;
                    this.V.setItem(i, v.$clone());
                }

                if (this.Count > 1) {
                    var metric1 = cache.v.Metric;
                    var metric2 = this.GetMetric();
                    if (metric2 < 0.5 * metric1 || 2.0 * metric1 < metric2 || metric2 < FarseerPhysics.Settings.Epsilon) {
                        this.Count = 0;
                    }
                }

                if (this.Count === 0) {
                    var v1 = this.V.getItem(0).$clone();
                    v1.IndexA = 0;
                    v1.IndexB = 0;
                    var wALocal1 = proxyA.Vertices.getItem(0).$clone();
                    var wBLocal1 = proxyB.Vertices.getItem(0).$clone();
                    v1.WA = FarseerPhysics.Common.MathUtils.Multiply$2(transformA, wALocal1.$clone());
                    v1.WB = FarseerPhysics.Common.MathUtils.Multiply$2(transformB, wBLocal1.$clone());
                    v1.W = Microsoft.Xna.Framework.Vector2.op_Subtraction(v1.WB.$clone(), v1.WA.$clone());
                    this.V.setItem(0, v1.$clone());
                    this.Count = 1;
                }
            },
            WriteCache: function (cache) {
                cache.v.Metric = this.GetMetric();
                cache.v.Count = this.Count & 65535;
                for (var i = 0; i < this.Count; i = (i + 1) | 0) {
                    cache.v.IndexA.setItem(i, (this.V.getItem(i).$clone().IndexA) & 255);
                    cache.v.IndexB.setItem(i, (this.V.getItem(i).$clone().IndexB) & 255);
                }
            },
            GetSearchDirection: function () {
                switch (this.Count) {
                    case 1: 
                        return Microsoft.Xna.Framework.Vector2.op_UnaryNegation(this.V.getItem(0).$clone().W.$clone());
                    case 2: 
                        {
                            var e12 = Microsoft.Xna.Framework.Vector2.op_Subtraction(this.V.getItem(1).$clone().W.$clone(), this.V.getItem(0).$clone().W.$clone());
                            var sgn = FarseerPhysics.Common.MathUtils.Cross$2(e12.$clone(), Microsoft.Xna.Framework.Vector2.op_UnaryNegation(this.V.getItem(0).$clone().W.$clone()));
                            if (sgn > 0.0) {
                                return new Microsoft.Xna.Framework.Vector2.$ctor2(-e12.Y, e12.X);
                            } else {
                                return new Microsoft.Xna.Framework.Vector2.$ctor2(e12.Y, -e12.X);
                            }
                        }
                    default: 
                        System.Diagnostics.Debug.Assert(false);
                        return Microsoft.Xna.Framework.Vector2.Zero.$clone();
                }
            },
            GetClosestPoint: function () {
                switch (this.Count) {
                    case 0: 
                        System.Diagnostics.Debug.Assert(false);
                        return Microsoft.Xna.Framework.Vector2.Zero.$clone();
                    case 1: 
                        return this.V.getItem(0).$clone().W.$clone();
                    case 2: 
                        return Microsoft.Xna.Framework.Vector2.op_Addition(Microsoft.Xna.Framework.Vector2.op_Multiply$2(this.V.getItem(0).$clone().A, this.V.getItem(0).$clone().W.$clone()), Microsoft.Xna.Framework.Vector2.op_Multiply$2(this.V.getItem(1).$clone().A, this.V.getItem(1).$clone().W.$clone()));
                    case 3: 
                        return Microsoft.Xna.Framework.Vector2.Zero.$clone();
                    default: 
                        System.Diagnostics.Debug.Assert(false);
                        return Microsoft.Xna.Framework.Vector2.Zero.$clone();
                }
            },
            GetWitnessPoints: function (pA, pB) {
                switch (this.Count) {
                    case 0: 
                        pA.v = Microsoft.Xna.Framework.Vector2.Zero.$clone();
                        pB.v = Microsoft.Xna.Framework.Vector2.Zero.$clone();
                        System.Diagnostics.Debug.Assert(false);
                        break;
                    case 1: 
                        pA.v = this.V.getItem(0).$clone().WA.$clone();
                        pB.v = this.V.getItem(0).$clone().WB.$clone();
                        break;
                    case 2: 
                        pA.v = Microsoft.Xna.Framework.Vector2.op_Addition(Microsoft.Xna.Framework.Vector2.op_Multiply$2(this.V.getItem(0).$clone().A, this.V.getItem(0).$clone().WA.$clone()), Microsoft.Xna.Framework.Vector2.op_Multiply$2(this.V.getItem(1).$clone().A, this.V.getItem(1).$clone().WA.$clone()));
                        pB.v = Microsoft.Xna.Framework.Vector2.op_Addition(Microsoft.Xna.Framework.Vector2.op_Multiply$2(this.V.getItem(0).$clone().A, this.V.getItem(0).$clone().WB.$clone()), Microsoft.Xna.Framework.Vector2.op_Multiply$2(this.V.getItem(1).$clone().A, this.V.getItem(1).$clone().WB.$clone()));
                        break;
                    case 3: 
                        pA.v = Microsoft.Xna.Framework.Vector2.op_Addition(Microsoft.Xna.Framework.Vector2.op_Addition(Microsoft.Xna.Framework.Vector2.op_Multiply$2(this.V.getItem(0).$clone().A, this.V.getItem(0).$clone().WA.$clone()), Microsoft.Xna.Framework.Vector2.op_Multiply$2(this.V.getItem(1).$clone().A, this.V.getItem(1).$clone().WA.$clone())), Microsoft.Xna.Framework.Vector2.op_Multiply$2(this.V.getItem(2).$clone().A, this.V.getItem(2).$clone().WA.$clone()));
                        pB.v = pA.v.$clone();
                        break;
                    default: 
                        throw new System.Exception();
                }
            },
            GetMetric: function () {
                switch (this.Count) {
                    case 0: 
                        System.Diagnostics.Debug.Assert(false);
                        return 0.0;
                    case 1: 
                        return 0.0;
                    case 2: 
                        return (Microsoft.Xna.Framework.Vector2.op_Subtraction(this.V.getItem(0).$clone().W.$clone(), this.V.getItem(1).$clone().W.$clone())).Length();
                    case 3: 
                        return FarseerPhysics.Common.MathUtils.Cross$2(Microsoft.Xna.Framework.Vector2.op_Subtraction(this.V.getItem(1).$clone().W.$clone(), this.V.getItem(0).$clone().W.$clone()), Microsoft.Xna.Framework.Vector2.op_Subtraction(this.V.getItem(2).$clone().W.$clone(), this.V.getItem(0).$clone().W.$clone()));
                    default: 
                        System.Diagnostics.Debug.Assert(false);
                        return 0.0;
                }
            },
            Solve2: function () {
                var w1 = this.V.getItem(0).$clone().W.$clone();
                var w2 = this.V.getItem(1).$clone().W.$clone();
                var e12 = Microsoft.Xna.Framework.Vector2.op_Subtraction(w2.$clone(), w1.$clone());

                var d12_2 = -Microsoft.Xna.Framework.Vector2.Dot(w1.$clone(), e12.$clone());
                if (d12_2 <= 0.0) {
                    var v0 = this.V.getItem(0).$clone();
                    v0.A = 1.0;
                    this.V.setItem(0, v0.$clone());
                    this.Count = 1;
                    return;
                }

                var d12_1 = Microsoft.Xna.Framework.Vector2.Dot(w2.$clone(), e12.$clone());
                if (d12_1 <= 0.0) {
                    var v1 = this.V.getItem(1).$clone();
                    v1.A = 1.0;
                    this.V.setItem(1, v1.$clone());
                    this.Count = 1;
                    this.V.setItem(0, this.V.getItem(1).$clone());
                    return;
                }

                var inv_d12 = 1.0 / (d12_1 + d12_2);
                var v0_2 = this.V.getItem(0).$clone();
                var v1_2 = this.V.getItem(1).$clone();
                v0_2.A = d12_1 * inv_d12;
                v1_2.A = d12_2 * inv_d12;
                this.V.setItem(0, v0_2.$clone());
                this.V.setItem(1, v1_2.$clone());
                this.Count = 2;
            },
            Solve3: function () {
                var w1 = this.V.getItem(0).$clone().W.$clone();
                var w2 = this.V.getItem(1).$clone().W.$clone();
                var w3 = this.V.getItem(2).$clone().W.$clone();

                var e12 = Microsoft.Xna.Framework.Vector2.op_Subtraction(w2.$clone(), w1.$clone());
                var w1e12 = Microsoft.Xna.Framework.Vector2.Dot(w1.$clone(), e12.$clone());
                var w2e12 = Microsoft.Xna.Framework.Vector2.Dot(w2.$clone(), e12.$clone());
                var d12_1 = w2e12;
                var d12_2 = -w1e12;

                var e13 = Microsoft.Xna.Framework.Vector2.op_Subtraction(w3.$clone(), w1.$clone());
                var w1e13 = Microsoft.Xna.Framework.Vector2.Dot(w1.$clone(), e13.$clone());
                var w3e13 = Microsoft.Xna.Framework.Vector2.Dot(w3.$clone(), e13.$clone());
                var d13_1 = w3e13;
                var d13_2 = -w1e13;

                var e23 = Microsoft.Xna.Framework.Vector2.op_Subtraction(w3.$clone(), w2.$clone());
                var w2e23 = Microsoft.Xna.Framework.Vector2.Dot(w2.$clone(), e23.$clone());
                var w3e23 = Microsoft.Xna.Framework.Vector2.Dot(w3.$clone(), e23.$clone());
                var d23_1 = w3e23;
                var d23_2 = -w2e23;

                var n123 = FarseerPhysics.Common.MathUtils.Cross$2(e12.$clone(), e13.$clone());

                var d123_1 = n123 * FarseerPhysics.Common.MathUtils.Cross$2(w2.$clone(), w3.$clone());
                var d123_2 = n123 * FarseerPhysics.Common.MathUtils.Cross$2(w3.$clone(), w1.$clone());
                var d123_3 = n123 * FarseerPhysics.Common.MathUtils.Cross$2(w1.$clone(), w2.$clone());

                if (d12_2 <= 0.0 && d13_2 <= 0.0) {
                    var v0_1 = this.V.getItem(0).$clone();
                    v0_1.A = 1.0;
                    this.V.setItem(0, v0_1.$clone());
                    this.Count = 1;
                    return;
                }

                if (d12_1 > 0.0 && d12_2 > 0.0 && d123_3 <= 0.0) {
                    var inv_d12 = 1.0 / (d12_1 + d12_2);
                    var v0_2 = this.V.getItem(0).$clone();
                    var v1_2 = this.V.getItem(1).$clone();
                    v0_2.A = d12_1 * inv_d12;
                    v1_2.A = d12_2 * inv_d12;
                    this.V.setItem(0, v0_2.$clone());
                    this.V.setItem(1, v1_2.$clone());
                    this.Count = 2;
                    return;
                }

                if (d13_1 > 0.0 && d13_2 > 0.0 && d123_2 <= 0.0) {
                    var inv_d13 = 1.0 / (d13_1 + d13_2);
                    var v0_3 = this.V.getItem(0).$clone();
                    var v2_3 = this.V.getItem(2).$clone();
                    v0_3.A = d13_1 * inv_d13;
                    v2_3.A = d13_2 * inv_d13;
                    this.V.setItem(0, v0_3.$clone());
                    this.V.setItem(2, v2_3.$clone());
                    this.Count = 2;
                    this.V.setItem(1, this.V.getItem(2).$clone());
                    return;
                }

                if (d12_1 <= 0.0 && d23_2 <= 0.0) {
                    var v1_4 = this.V.getItem(1).$clone();
                    v1_4.A = 1.0;
                    this.V.setItem(1, v1_4.$clone());
                    this.Count = 1;
                    this.V.setItem(0, this.V.getItem(1).$clone());
                    return;
                }

                if (d13_1 <= 0.0 && d23_1 <= 0.0) {
                    var v2_5 = this.V.getItem(2).$clone();
                    v2_5.A = 1.0;
                    this.V.setItem(2, v2_5.$clone());
                    this.Count = 1;
                    this.V.setItem(0, this.V.getItem(2).$clone());
                    return;
                }

                if (d23_1 > 0.0 && d23_2 > 0.0 && d123_1 <= 0.0) {
                    var inv_d23 = 1.0 / (d23_1 + d23_2);
                    var v1_6 = this.V.getItem(1).$clone();
                    var v2_6 = this.V.getItem(2).$clone();
                    v1_6.A = d23_1 * inv_d23;
                    v2_6.A = d23_2 * inv_d23;
                    this.V.setItem(1, v1_6.$clone());
                    this.V.setItem(2, v2_6.$clone());
                    this.Count = 2;
                    this.V.setItem(0, this.V.getItem(2).$clone());
                    return;
                }

                var inv_d123 = 1.0 / (d123_1 + d123_2 + d123_3);
                var v0_7 = this.V.getItem(0).$clone();
                var v1_7 = this.V.getItem(1).$clone();
                var v2_7 = this.V.getItem(2).$clone();
                v0_7.A = d123_1 * inv_d123;
                v1_7.A = d123_2 * inv_d123;
                v2_7.A = d123_3 * inv_d123;
                this.V.setItem(0, v0_7.$clone());
                this.V.setItem(1, v1_7.$clone());
                this.V.setItem(2, v2_7.$clone());
                this.Count = 3;
            },
            getHashCode: function () {
                var h = Bridge.addHash([1894108863, this.Count, this.V]);
                return h;
            },
            equals: function (o) {
                if (!Bridge.is(o, FarseerPhysics.Collision.Simplex)) {
                    return false;
                }
                return Bridge.equals(this.Count, o.Count) && Bridge.equals(this.V, o.V);
            },
            $clone: function (to) {
                var s = to || new FarseerPhysics.Collision.Simplex();
                s.Count = this.Count;
                s.V = this.V.$clone();
                return s;
            }
        }
    });

    /**
     * Used to warm start ComputeDistance.
     Set count to zero on first call.
     *
     * @public
     * @class FarseerPhysics.Collision.SimplexCache
     */
    Bridge.define("FarseerPhysics.Collision.SimplexCache", {
        $kind: "struct",
        statics: {
            methods: {
                getDefaultValue: function () { return new FarseerPhysics.Collision.SimplexCache(); }
            }
        },
        fields: {
            /**
             * Length or area
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Collision.SimplexCache
             * @type number
             */
            Count: 0,
            /**
             * Vertices on shape A
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Collision.SimplexCache
             * @type FarseerPhysics.Common.FixedArray3$1
             */
            IndexA: null,
            /**
             * Vertices on shape B
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Collision.SimplexCache
             * @type FarseerPhysics.Common.FixedArray3$1
             */
            IndexB: null,
            Metric: 0
        },
        ctors: {
            init: function () {
                this.IndexA = new (FarseerPhysics.Common.FixedArray3$1(System.Byte))();
                this.IndexB = new (FarseerPhysics.Common.FixedArray3$1(System.Byte))();
            },
            ctor: function () {
                this.$initialize();
            }
        },
        methods: {
            getHashCode: function () {
                var h = Bridge.addHash([4719522336, this.Count, this.IndexA, this.IndexB, this.Metric]);
                return h;
            },
            equals: function (o) {
                if (!Bridge.is(o, FarseerPhysics.Collision.SimplexCache)) {
                    return false;
                }
                return Bridge.equals(this.Count, o.Count) && Bridge.equals(this.IndexA, o.IndexA) && Bridge.equals(this.IndexB, o.IndexB) && Bridge.equals(this.Metric, o.Metric);
            },
            $clone: function (to) {
                var s = to || new FarseerPhysics.Collision.SimplexCache();
                s.Count = this.Count;
                s.IndexA = this.IndexA.$clone();
                s.IndexB = this.IndexB.$clone();
                s.Metric = this.Metric;
                return s;
            }
        }
    });

    Bridge.define("FarseerPhysics.Collision.SimplexVertex", {
        $kind: "struct",
        statics: {
            methods: {
                getDefaultValue: function () { return new FarseerPhysics.Collision.SimplexVertex(); }
            }
        },
        fields: {
            /**
             * Barycentric coordinate for closest point
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Collision.SimplexVertex
             * @type number
             */
            A: 0,
            /**
             * wA index
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Collision.SimplexVertex
             * @type number
             */
            IndexA: 0,
            /**
             * wB index
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Collision.SimplexVertex
             * @type number
             */
            IndexB: 0,
            /**
             * wB - wA
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Collision.SimplexVertex
             * @type Microsoft.Xna.Framework.Vector2
             */
            W: null,
            /**
             * Support point in proxyA
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Collision.SimplexVertex
             * @type Microsoft.Xna.Framework.Vector2
             */
            WA: null,
            /**
             * Support point in proxyB
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Collision.SimplexVertex
             * @type Microsoft.Xna.Framework.Vector2
             */
            WB: null
        },
        ctors: {
            init: function () {
                this.W = new Microsoft.Xna.Framework.Vector2();
                this.WA = new Microsoft.Xna.Framework.Vector2();
                this.WB = new Microsoft.Xna.Framework.Vector2();
            },
            ctor: function () {
                this.$initialize();
            }
        },
        methods: {
            getHashCode: function () {
                var h = Bridge.addHash([5039079836, this.A, this.IndexA, this.IndexB, this.W, this.WA, this.WB]);
                return h;
            },
            equals: function (o) {
                if (!Bridge.is(o, FarseerPhysics.Collision.SimplexVertex)) {
                    return false;
                }
                return Bridge.equals(this.A, o.A) && Bridge.equals(this.IndexA, o.IndexA) && Bridge.equals(this.IndexB, o.IndexB) && Bridge.equals(this.W, o.W) && Bridge.equals(this.WA, o.WA) && Bridge.equals(this.WB, o.WB);
            },
            $clone: function (to) {
                var s = to || new FarseerPhysics.Collision.SimplexVertex();
                s.A = this.A;
                s.IndexA = this.IndexA;
                s.IndexB = this.IndexB;
                s.W = this.W.$clone();
                s.WA = this.WA.$clone();
                s.WB = this.WB.$clone();
                return s;
            }
        }
    });

    Bridge.define("FarseerPhysics.Collision.TimeOfImpact", {
        statics: {
            fields: {
                TOICalls: 0,
                TOIIters: 0,
                TOIMaxIters: 0,
                TOIRootIters: 0,
                TOIMaxRootIters: 0,
                _distanceInput: null
            },
            ctors: {
                init: function () {
                    this._distanceInput = new FarseerPhysics.Collision.DistanceInput();
                }
            },
            methods: {
                /**
                 * Compute the upper bound on time before two shapes penetrate. Time is represented as
                 a fraction between [0,tMax]. This uses a swept separating axis and may miss some intermediate,
                 non-tunneling collision. If you change the time interval, you should call this function
                 again.
                 Note: use Distance() to compute the contact point and normal at the time of impact.
                 *
                 * @static
                 * @public
                 * @this FarseerPhysics.Collision.TimeOfImpact
                 * @memberof FarseerPhysics.Collision.TimeOfImpact
                 * @param   {FarseerPhysics.Collision.TOIOutput}    output    The output.
                 * @param   {FarseerPhysics.Collision.TOIInput}     input     The input.
                 * @return  {void}
                 */
                CalculateTimeOfImpact: function (output, input) {
                    FarseerPhysics.Collision.TimeOfImpact.TOICalls = (FarseerPhysics.Collision.TimeOfImpact.TOICalls + 1) | 0;

                    output.v = new FarseerPhysics.Collision.TOIOutput();
                    output.v.State = FarseerPhysics.Collision.TOIOutputState.Unknown;
                    output.v.T = input.TMax;

                    var sweepA = { v : input.SweepA.$clone() };
                    var sweepB = { v : input.SweepB.$clone() };

                    sweepA.v.Normalize();
                    sweepB.v.Normalize();

                    var tMax = input.TMax;

                    var totalRadius = input.ProxyA.Radius + input.ProxyB.Radius;
                    var target = Math.max(FarseerPhysics.Settings.LinearSlop, totalRadius - 0.015);
                    var tolerance = 0.00125;
                    System.Diagnostics.Debug.Assert(target > tolerance);

                    var t1 = 0.0;
                    var k_maxIterations = 20;
                    var iter = 0;

                    var cache = { v : new FarseerPhysics.Collision.SimplexCache() };
                    FarseerPhysics.Collision.TimeOfImpact._distanceInput.ProxyA = input.ProxyA;
                    FarseerPhysics.Collision.TimeOfImpact._distanceInput.ProxyB = input.ProxyB;
                    FarseerPhysics.Collision.TimeOfImpact._distanceInput.UseRadii = false;

                    for (; ; ) {
                        var xfA = { v : new FarseerPhysics.Common.Transform() }, xfB = { v : new FarseerPhysics.Common.Transform() };
                        sweepA.v.GetTransform(xfA, t1);
                        sweepB.v.GetTransform(xfB, t1);

                        FarseerPhysics.Collision.TimeOfImpact._distanceInput.TransformA = xfA.v.$clone();
                        FarseerPhysics.Collision.TimeOfImpact._distanceInput.TransformB = xfB.v.$clone();
                        var distanceOutput = { v : new FarseerPhysics.Collision.DistanceOutput() };
                        FarseerPhysics.Collision.Distance.ComputeDistance(distanceOutput, cache, FarseerPhysics.Collision.TimeOfImpact._distanceInput);

                        if (distanceOutput.v.Distance <= 0.0) {
                            output.v.State = FarseerPhysics.Collision.TOIOutputState.Overlapped;
                            output.v.T = 0.0;
                            break;
                        }

                        if (distanceOutput.v.Distance < target + tolerance) {
                            output.v.State = FarseerPhysics.Collision.TOIOutputState.Touching;
                            output.v.T = t1;
                            break;
                        }

                        FarseerPhysics.Collision.SeparationFunction.Set(cache, input.ProxyA, sweepA, input.ProxyB, sweepB, t1);

                        var done = false;
                        var t2 = tMax;
                        var pushBackIter = 0;
                        for (; ; ) {
                            var indexA = { }, indexB = { };
                            var s2 = FarseerPhysics.Collision.SeparationFunction.FindMinSeparation(indexA, indexB, t2);

                            if (s2 > target + tolerance) {
                                output.v.State = FarseerPhysics.Collision.TOIOutputState.Seperated;
                                output.v.T = tMax;
                                done = true;
                                break;
                            }

                            if (s2 > target - tolerance) {
                                t1 = t2;
                                break;
                            }

                            var s1 = FarseerPhysics.Collision.SeparationFunction.Evaluate(indexA.v, indexB.v, t1);

                            if (s1 < target - tolerance) {
                                output.v.State = FarseerPhysics.Collision.TOIOutputState.Failed;
                                output.v.T = t1;
                                done = true;
                                break;
                            }

                            if (s1 <= target + tolerance) {
                                output.v.State = FarseerPhysics.Collision.TOIOutputState.Touching;
                                output.v.T = t1;
                                done = true;
                                break;
                            }

                            var rootIterCount = 0;
                            var a1 = t1, a2 = t2;
                            for (; ; ) {
                                var t;
                                if ((rootIterCount & 1) !== 0) {
                                    t = a1 + (target - s1) * (a2 - a1) / (s2 - s1);
                                } else {
                                    t = 0.5 * (a1 + a2);
                                }

                                var s = FarseerPhysics.Collision.SeparationFunction.Evaluate(indexA.v, indexB.v, t);

                                if (Math.abs(s - target) < tolerance) {
                                    t2 = t;
                                    break;
                                }

                                if (s > target) {
                                    a1 = t;
                                    s1 = s;
                                } else {
                                    a2 = t;
                                    s2 = s;
                                }

                                rootIterCount = (rootIterCount + 1) | 0;
                                FarseerPhysics.Collision.TimeOfImpact.TOIRootIters = (FarseerPhysics.Collision.TimeOfImpact.TOIRootIters + 1) | 0;

                                if (rootIterCount === 50) {
                                    break;
                                }
                            }

                            FarseerPhysics.Collision.TimeOfImpact.TOIMaxRootIters = Math.max(FarseerPhysics.Collision.TimeOfImpact.TOIMaxRootIters, rootIterCount);

                            pushBackIter = (pushBackIter + 1) | 0;

                            if (pushBackIter === FarseerPhysics.Settings.MaxPolygonVertices) {
                                break;
                            }
                        }

                        iter = (iter + 1) | 0;
                        FarseerPhysics.Collision.TimeOfImpact.TOIIters = (FarseerPhysics.Collision.TimeOfImpact.TOIIters + 1) | 0;

                        if (done) {
                            break;
                        }

                        if (iter === k_maxIterations) {
                            output.v.State = FarseerPhysics.Collision.TOIOutputState.Failed;
                            output.v.T = t1;
                            break;
                        }
                    }

                    FarseerPhysics.Collision.TimeOfImpact.TOIMaxIters = Math.max(FarseerPhysics.Collision.TimeOfImpact.TOIMaxIters, iter);
                }
            }
        }
    });

    /**
     * Input parameters for CalculateTimeOfImpact
     *
     * @public
     * @class FarseerPhysics.Collision.TOIInput
     */
    Bridge.define("FarseerPhysics.Collision.TOIInput", {
        fields: {
            ProxyA: null,
            ProxyB: null,
            SweepA: null,
            SweepB: null,
            TMax: 0
        },
        ctors: {
            init: function () {
                this.SweepA = new FarseerPhysics.Common.Sweep();
                this.SweepB = new FarseerPhysics.Common.Sweep();
                this.ProxyA = new FarseerPhysics.Collision.DistanceProxy();
                this.ProxyB = new FarseerPhysics.Collision.DistanceProxy();
            }
        }
    });

    Bridge.define("FarseerPhysics.Collision.TOIOutput", {
        $kind: "struct",
        statics: {
            methods: {
                getDefaultValue: function () { return new FarseerPhysics.Collision.TOIOutput(); }
            }
        },
        fields: {
            State: 0,
            T: 0
        },
        ctors: {
            ctor: function () {
                this.$initialize();
            }
        },
        methods: {
            getHashCode: function () {
                var h = Bridge.addHash([3300508733, this.State, this.T]);
                return h;
            },
            equals: function (o) {
                if (!Bridge.is(o, FarseerPhysics.Collision.TOIOutput)) {
                    return false;
                }
                return Bridge.equals(this.State, o.State) && Bridge.equals(this.T, o.T);
            },
            $clone: function (to) {
                var s = to || new FarseerPhysics.Collision.TOIOutput();
                s.State = this.State;
                s.T = this.T;
                return s;
            }
        }
    });

    Bridge.define("FarseerPhysics.Collision.TOIOutputState", {
        $kind: "enum",
        statics: {
            fields: {
                Unknown: 0,
                Failed: 1,
                Overlapped: 2,
                Touching: 3,
                Seperated: 4
            }
        }
    });

    Bridge.define("FarseerPhysics.Common.ConvexHull.ChainHull", {
        statics: {
            methods: {
                /**
                 * Gets the convex hull.
                 *
                 * @static
                 * @public
                 * @this FarseerPhysics.Common.ConvexHull.ChainHull
                 * @memberof FarseerPhysics.Common.ConvexHull.ChainHull
                 * @param   {FarseerPhysics.Common.Vertices}    P
                 * @return  {FarseerPhysics.Common.Vertices}
                 */
                GetConvexHull: function (P) {
                    P.Sort$1(new FarseerPhysics.Common.ConvexHull.ChainHull.PointComparer());

                    var H = System.Array.init(P.Count, function (){
                        return new Microsoft.Xna.Framework.Vector2();
                    }, Microsoft.Xna.Framework.Vector2);
                    var res = new FarseerPhysics.Common.Vertices.ctor();

                    var n = P.Count;

                    var bot, top = -1;
                    var i;

                    var minmin = 0, minmax;
                    var xmin = P.getItem(0).$clone().X;
                    for (i = 1; i < n; i = (i + 1) | 0) {
                        if (P.getItem(i).$clone().X !== xmin) {
                            break;
                        }
                    }
                    minmax = (i - 1) | 0;
                    if (minmax === ((n - 1) | 0)) {
                        H[System.Array.index(((top = (top + 1) | 0)), H)] = P.getItem(minmin).$clone();
                        if (P.getItem(minmax).$clone().Y !== P.getItem(minmin).$clone().Y) {
                            H[System.Array.index(((top = (top + 1) | 0)), H)] = P.getItem(minmax).$clone();
                        }
                        H[System.Array.index(((top = (top + 1) | 0)), H)] = P.getItem(minmin).$clone();

                        for (var j = 0; j < ((top + 1) | 0); j = (j + 1) | 0) {
                            res.add(H[System.Array.index(j, H)].$clone());
                        }

                        return res;
                    }

                    top = (res.Count - 1) | 0;

                    var maxmin, maxmax = (n - 1) | 0;
                    var xmax = P.getItem(((n - 1) | 0)).$clone().X;
                    for (i = (n - 2) | 0; i >= 0; i = (i - 1) | 0) {
                        if (P.getItem(i).$clone().X !== xmax) {
                            break;
                        }
                    }
                    maxmin = (i + 1) | 0;

                    H[System.Array.index(((top = (top + 1) | 0)), H)] = P.getItem(minmin).$clone();
                    i = minmax;
                    while (((i = (i + 1) | 0)) <= maxmin) {
                        if (FarseerPhysics.Common.MathUtils.Area(P.getItem(minmin).$clone(), P.getItem(maxmin).$clone(), P.getItem(i).$clone()) >= 0 && i < maxmin) {
                            continue;
                        }

                        while (top > 0) {
                            if (FarseerPhysics.Common.MathUtils.Area(H[System.Array.index(((top - 1) | 0), H)].$clone(), H[System.Array.index(top, H)].$clone(), P.getItem(i).$clone()) > 0) {
                                break;
                            } else {
                                top = (top - 1) | 0;
                            }
                        }
                        H[System.Array.index(((top = (top + 1) | 0)), H)] = P.getItem(i).$clone();
                    }

                    if (maxmax !== maxmin) {
                        H[System.Array.index(((top = (top + 1) | 0)), H)] = P.getItem(maxmax).$clone();
                    }
                    bot = top;
                    i = maxmin;
                    while (((i = (i - 1) | 0)) >= minmax) {
                        if (FarseerPhysics.Common.MathUtils.Area(P.getItem(maxmax).$clone(), P.getItem(minmax).$clone(), P.getItem(i).$clone()) >= 0 && i > minmax) {
                            continue;
                        }

                        while (top > bot) {
                            if (FarseerPhysics.Common.MathUtils.Area(H[System.Array.index(((top - 1) | 0), H)].$clone(), H[System.Array.index(top, H)].$clone(), P.getItem(i).$clone()) > 0) {
                                break;
                            } else {
                                top = (top - 1) | 0;
                            }
                        }
                        H[System.Array.index(((top = (top + 1) | 0)), H)] = P.getItem(i).$clone();
                    }
                    if (minmax !== minmin) {
                        H[System.Array.index(((top = (top + 1) | 0)), H)] = P.getItem(minmin).$clone();
                    }

                    for (var j1 = 0; j1 < ((top + 1) | 0); j1 = (j1 + 1) | 0) {
                        res.add(H[System.Array.index(j1, H)].$clone());
                    }

                    return res;
                }
            }
        }
    });

    Bridge.define("FarseerPhysics.Common.ConvexHull.ChainHull.PointComparer", {
        inherits: [System.Collections.Generic.Comparer$1(Microsoft.Xna.Framework.Vector2)],
        $kind: "nested class",
        alias: ["compare", ["System$Collections$Generic$IComparer$1$Microsoft$Xna$Framework$Vector2$compare", "System$Collections$Generic$IComparer$1$compare"]],
        methods: {
            compare: function (a, b) {
                var f = Bridge.compare(a.X, b.X);
                return f !== 0 ? f : Bridge.compare(a.Y, b.Y);
            }
        }
    });

    Bridge.define("FarseerPhysics.Common.ConvexHull.GiftWrap", {
        statics: {
            methods: {
                /**
                 * Find the convex hull of a point cloud using "Gift-wrap" algorithm - start
                 with an extremal point, and walk around the outside edge by testing
                 angles.
                 Runs in O(N*S) time where S is number of sides of resulting polygon.
                 Worst case: point cloud is all vertices of convex polygon: O(N^2).
                 There may be faster algorithms to do this, should you need one -
                 this is just the simplest. You can get O(N log N) expected time if you
                 try, I think, and O(N) if you restrict inputs to simple polygons.
                 Returns null if number of vertices passed is less than 3.
                 Results should be passed through convex decomposition afterwards
                 to ensure that each shape has few enough points to be used in Box2d.
                 Warning: May be buggy with colinear points on hull.
                 *
                 * @static
                 * @public
                 * @this FarseerPhysics.Common.ConvexHull.GiftWrap
                 * @memberof FarseerPhysics.Common.ConvexHull.GiftWrap
                 * @param   {FarseerPhysics.Common.Vertices}    vertices    The vertices.
                 * @return  {FarseerPhysics.Common.Vertices}
                 */
                GetConvexHull: function (vertices) {
                    if (vertices.Count < 3) {
                        return vertices;
                    }

                    var edgeList = System.Array.init(vertices.Count, 0, System.Int32);
                    var numEdges = 0;

                    var minY = 3.40282347E+38;
                    var minYIndex = vertices.Count;
                    for (var i = 0; i < vertices.Count; i = (i + 1) | 0) {
                        if (vertices.getItem(i).$clone().Y < minY) {
                            minY = vertices.getItem(i).$clone().Y;
                            minYIndex = i;
                        }
                    }

                    var startIndex = minYIndex;
                    var winIndex = -1;
                    var dx = -1.0;
                    var dy = 0.0;
                    while (winIndex !== minYIndex) {
                        var maxDot = -2.0;
                        var nrm;

                        for (var i1 = 0; i1 < vertices.Count; i1 = (i1 + 1) | 0) {
                            if (i1 === startIndex) {
                                continue;
                            }
                            var newdx = vertices.getItem(i1).$clone().X - vertices.getItem(startIndex).$clone().X;
                            var newdy = vertices.getItem(i1).$clone().Y - vertices.getItem(startIndex).$clone().Y;
                            nrm = Math.sqrt(newdx * newdx + newdy * newdy);
                            nrm = (nrm === 0.0) ? 1.0 : nrm;
                            newdx /= nrm;
                            newdy /= nrm;

                            var newDot = newdx * dx + newdy * dy;
                            if (newDot > maxDot) {
                                maxDot = newDot;
                                winIndex = i1;
                            }
                        }
                        edgeList[System.Array.index(Bridge.identity(numEdges, (numEdges = (numEdges + 1) | 0)), edgeList)] = winIndex;
                        dx = vertices.getItem(winIndex).$clone().X - vertices.getItem(startIndex).$clone().X;
                        dy = vertices.getItem(winIndex).$clone().Y - vertices.getItem(startIndex).$clone().Y;
                        nrm = Math.sqrt(dx * dx + dy * dy);
                        nrm = (nrm === 0.0) ? 1.0 : nrm;
                        dx /= nrm;
                        dy /= nrm;
                        startIndex = winIndex;
                    }

                    var returnVal = new FarseerPhysics.Common.Vertices.$ctor3(numEdges);

                    for (var i2 = 0; i2 < numEdges; i2 = (i2 + 1) | 0) {
                        returnVal.add(vertices.getItem(edgeList[System.Array.index(i2, edgeList)]).$clone());
                    }


                    return returnVal;
                }
            }
        }
    });

    Bridge.define("FarseerPhysics.Common.ConvexHull.Melkman", {
        statics: {
            methods: {
                /**
                 * Creates a convex hull.
                 Note:
                 1. Vertices must be of a simple polygon, i.e. edges do not overlap.
                 2. Melkman does not work on point clouds
                 *
                 * @static
                 * @public
                 * @this FarseerPhysics.Common.ConvexHull.Melkman
                 * @memberof FarseerPhysics.Common.ConvexHull.Melkman
                 * @param   {FarseerPhysics.Common.Vertices}    vertices
                 * @return  {FarseerPhysics.Common.Vertices}                A convex hull in counterclockwise winding order.
                 */
                GetConvexHull: function (vertices) {
                    var $t;
                    if (vertices.Count < 3) {
                        return vertices;
                    }

                    var deque = System.Array.init(((vertices.Count + 1) | 0), function (){
                        return new Microsoft.Xna.Framework.Vector2();
                    }, Microsoft.Xna.Framework.Vector2);
                    var qf = 3, qb = 0;
                    var qfm1, qbm1;

                    var startIndex = 3;
                    var k = FarseerPhysics.Common.MathUtils.Area(vertices.getItem(0).$clone(), vertices.getItem(1).$clone(), vertices.getItem(2).$clone());
                    if (k === 0) {
                        deque[System.Array.index(0, deque)] = vertices.getItem(0).$clone();
                        deque[System.Array.index(1, deque)] = vertices.getItem(2).$clone();
                        deque[System.Array.index(2, deque)] = vertices.getItem(0).$clone();
                        qf = 2;

                        for (startIndex = 3; startIndex < vertices.Count; startIndex = (startIndex + 1) | 0) {
                            var tmp = { v : vertices.getItem(startIndex).$clone() };
                            if (FarseerPhysics.Common.MathUtils.Area$1(Bridge.ref(deque, 0), Bridge.ref(deque, 1), tmp) === 0) {
                                deque[System.Array.index(1, deque)] = vertices.getItem(startIndex).$clone();
                            } else {
                                break;
                            }
                        }
                    } else {
                        deque[System.Array.index(0, deque)] = ($t = vertices.getItem(2).$clone(), deque[System.Array.index(3, deque)] = $t.$clone(), $t);
                        if (k > 0) {
                            deque[System.Array.index(1, deque)] = vertices.getItem(0).$clone();
                            deque[System.Array.index(2, deque)] = vertices.getItem(1).$clone();
                        } else {
                            deque[System.Array.index(1, deque)] = vertices.getItem(1).$clone();
                            deque[System.Array.index(2, deque)] = vertices.getItem(0).$clone();
                        }
                    }

                    qfm1 = qf === 0 ? ((deque.length - 1) | 0) : ((qf - 1) | 0);
                    qbm1 = qb === ((deque.length - 1) | 0) ? 0 : ((qb + 1) | 0);

                    for (var i = startIndex; i < vertices.Count; i = (i + 1) | 0) {
                        var nextPt = { v : vertices.getItem(i).$clone() };

                        if (FarseerPhysics.Common.MathUtils.Area$1(Bridge.ref(deque, qfm1), Bridge.ref(deque, qf), nextPt) > 0 && FarseerPhysics.Common.MathUtils.Area$1(Bridge.ref(deque, qb), Bridge.ref(deque, qbm1), nextPt) > 0) {
                            continue;
                        }

                        while (!(FarseerPhysics.Common.MathUtils.Area$1(Bridge.ref(deque, qfm1), Bridge.ref(deque, qf), nextPt) > 0)) {
                            qf = qfm1;
                            qfm1 = qf === 0 ? ((deque.length - 1) | 0) : ((qf - 1) | 0);
                        }
                        qf = qf === ((deque.length - 1) | 0) ? 0 : ((qf + 1) | 0);
                        qfm1 = qf === 0 ? ((deque.length - 1) | 0) : ((qf - 1) | 0);
                        deque[System.Array.index(qf, deque)] = nextPt.v.$clone();

                        while (!(FarseerPhysics.Common.MathUtils.Area$1(Bridge.ref(deque, qb), Bridge.ref(deque, qbm1), nextPt) > 0)) {
                            qb = qbm1;
                            qbm1 = qb === ((deque.length - 1) | 0) ? 0 : ((qb + 1) | 0);
                        }
                        qb = qb === 0 ? ((deque.length - 1) | 0) : ((qb - 1) | 0);
                        qbm1 = qb === ((deque.length - 1) | 0) ? 0 : ((qb + 1) | 0);
                        deque[System.Array.index(qb, deque)] = nextPt.v.$clone();
                    }

                    var convexHull = new FarseerPhysics.Common.Vertices.$ctor3(((vertices.Count + 1) | 0));
                    if (qb < qf) {
                        for (var i1 = qb; i1 < qf; i1 = (i1 + 1) | 0) {
                            convexHull.add(deque[System.Array.index(i1, deque)].$clone());
                        }
                    } else {
                        for (var i2 = 0; i2 < qf; i2 = (i2 + 1) | 0) {
                            convexHull.add(deque[System.Array.index(i2, deque)].$clone());
                        }
                        for (var i3 = qb; i3 < deque.length; i3 = (i3 + 1) | 0) {
                            convexHull.add(deque[System.Array.index(i3, deque)].$clone());
                        }
                    }
                    return convexHull;
                }
            }
        }
    });

    Bridge.define("FarseerPhysics.Common.Decomposer", {
        $kind: "enum",
        statics: {
            fields: {
                Bayazit: 0,
                CDT: 1,
                Earclip: 2,
                Flipcode: 3,
                Seidel: 4
            }
        }
    });

    /** @namespace FarseerPhysics.Common.Decomposition */

    /**
     * Convex decomposition algorithm created by Mark Bayazit (http://mnbayazit.com/)
     For more information about this algorithm, see http://mnbayazit.com/406/bayazit
     *
     * @static
     * @abstract
     * @public
     * @class FarseerPhysics.Common.Decomposition.BayazitDecomposer
     */
    Bridge.define("FarseerPhysics.Common.Decomposition.BayazitDecomposer", {
        statics: {
            methods: {
                At: function (i, vertices) {
                    var s = vertices.Count;
                    return vertices.getItem(i < 0 ? ((s - (((-i) | 0) % s)) | 0) : i % s).$clone();
                },
                Copy: function (i, j, vertices) {
                    var p = new FarseerPhysics.Common.Vertices.ctor();
                    while (j < i) {
                        j = (j + vertices.Count) | 0;
                    }
                    for (; i <= j; i = (i + 1) | 0) {
                        p.add(FarseerPhysics.Common.Decomposition.BayazitDecomposer.At(i, vertices));
                    }
                    return p;
                },
                /**
                 * Decompose the polygon into several smaller non-concave polygon.
                 If the polygon is already convex, it will return the original polygon, unless it is over Settings.MaxPolygonVertices.
                 Precondition: Counter Clockwise polygon
                 *
                 * @static
                 * @public
                 * @this FarseerPhysics.Common.Decomposition.BayazitDecomposer
                 * @memberof FarseerPhysics.Common.Decomposition.BayazitDecomposer
                 * @param   {FarseerPhysics.Common.Vertices}       vertices
                 * @return  {System.Collections.Generic.List$1}
                 */
                ConvexPartition: function (vertices) {
                    vertices.ForceCounterClockWise();

                    var list = new (System.Collections.Generic.List$1(FarseerPhysics.Common.Vertices)).ctor();
                    var d, lowerDist, upperDist;
                    var p = new Microsoft.Xna.Framework.Vector2();
                    var lowerInt = new Microsoft.Xna.Framework.Vector2.ctor();
                    var upperInt = new Microsoft.Xna.Framework.Vector2.ctor();
                    var lowerIndex = 0, upperIndex = 0;
                    var lowerPoly, upperPoly;

                    for (var i = 0; i < vertices.Count; i = (i + 1) | 0) {
                        if (FarseerPhysics.Common.Decomposition.BayazitDecomposer.Reflex(i, vertices)) {
                            lowerDist = (upperDist = 3.40282347E+38);
                            for (var j = 0; j < vertices.Count; j = (j + 1) | 0) {
                                if (FarseerPhysics.Common.Decomposition.BayazitDecomposer.Left(FarseerPhysics.Common.Decomposition.BayazitDecomposer.At(((i - 1) | 0), vertices), FarseerPhysics.Common.Decomposition.BayazitDecomposer.At(i, vertices), FarseerPhysics.Common.Decomposition.BayazitDecomposer.At(j, vertices)) && FarseerPhysics.Common.Decomposition.BayazitDecomposer.RightOn(FarseerPhysics.Common.Decomposition.BayazitDecomposer.At(((i - 1) | 0), vertices), FarseerPhysics.Common.Decomposition.BayazitDecomposer.At(i, vertices), FarseerPhysics.Common.Decomposition.BayazitDecomposer.At(((j - 1) | 0), vertices))) {
                                    p = FarseerPhysics.Common.LineTools.LineIntersect(FarseerPhysics.Common.Decomposition.BayazitDecomposer.At(((i - 1) | 0), vertices), FarseerPhysics.Common.Decomposition.BayazitDecomposer.At(i, vertices), FarseerPhysics.Common.Decomposition.BayazitDecomposer.At(j, vertices), FarseerPhysics.Common.Decomposition.BayazitDecomposer.At(((j - 1) | 0), vertices));
                                    if (FarseerPhysics.Common.Decomposition.BayazitDecomposer.Right(FarseerPhysics.Common.Decomposition.BayazitDecomposer.At(((i + 1) | 0), vertices), FarseerPhysics.Common.Decomposition.BayazitDecomposer.At(i, vertices), p.$clone())) {
                                        d = FarseerPhysics.Common.Decomposition.BayazitDecomposer.SquareDist(FarseerPhysics.Common.Decomposition.BayazitDecomposer.At(i, vertices), p.$clone());
                                        if (d < lowerDist) {
                                            lowerDist = d;
                                            lowerInt = p.$clone();
                                            lowerIndex = j;
                                        }
                                    }
                                }

                                if (FarseerPhysics.Common.Decomposition.BayazitDecomposer.Left(FarseerPhysics.Common.Decomposition.BayazitDecomposer.At(((i + 1) | 0), vertices), FarseerPhysics.Common.Decomposition.BayazitDecomposer.At(i, vertices), FarseerPhysics.Common.Decomposition.BayazitDecomposer.At(((j + 1) | 0), vertices)) && FarseerPhysics.Common.Decomposition.BayazitDecomposer.RightOn(FarseerPhysics.Common.Decomposition.BayazitDecomposer.At(((i + 1) | 0), vertices), FarseerPhysics.Common.Decomposition.BayazitDecomposer.At(i, vertices), FarseerPhysics.Common.Decomposition.BayazitDecomposer.At(j, vertices))) {
                                    p = FarseerPhysics.Common.LineTools.LineIntersect(FarseerPhysics.Common.Decomposition.BayazitDecomposer.At(((i + 1) | 0), vertices), FarseerPhysics.Common.Decomposition.BayazitDecomposer.At(i, vertices), FarseerPhysics.Common.Decomposition.BayazitDecomposer.At(j, vertices), FarseerPhysics.Common.Decomposition.BayazitDecomposer.At(((j + 1) | 0), vertices));
                                    if (FarseerPhysics.Common.Decomposition.BayazitDecomposer.Left(FarseerPhysics.Common.Decomposition.BayazitDecomposer.At(((i - 1) | 0), vertices), FarseerPhysics.Common.Decomposition.BayazitDecomposer.At(i, vertices), p.$clone())) {
                                        d = FarseerPhysics.Common.Decomposition.BayazitDecomposer.SquareDist(FarseerPhysics.Common.Decomposition.BayazitDecomposer.At(i, vertices), p.$clone());
                                        if (d < upperDist) {
                                            upperDist = d;
                                            upperIndex = j;
                                            upperInt = p.$clone();
                                        }
                                    }
                                }
                            }

                            if (lowerIndex === (((upperIndex + 1) | 0)) % vertices.Count) {
                                var sp = (Microsoft.Xna.Framework.Vector2.op_Division$1((Microsoft.Xna.Framework.Vector2.op_Addition(lowerInt.$clone(), upperInt.$clone())), 2));

                                lowerPoly = FarseerPhysics.Common.Decomposition.BayazitDecomposer.Copy(i, upperIndex, vertices);
                                lowerPoly.add(sp.$clone());
                                upperPoly = FarseerPhysics.Common.Decomposition.BayazitDecomposer.Copy(lowerIndex, i, vertices);
                                upperPoly.add(sp.$clone());
                            } else {
                                var highestScore = 0, bestIndex = lowerIndex;
                                while (upperIndex < lowerIndex) {
                                    upperIndex = (upperIndex + vertices.Count) | 0;
                                }
                                for (var j1 = lowerIndex; j1 <= upperIndex; j1 = (j1 + 1) | 0) {
                                    if (FarseerPhysics.Common.Decomposition.BayazitDecomposer.CanSee(i, j1, vertices)) {
                                        var score = 1 / (FarseerPhysics.Common.Decomposition.BayazitDecomposer.SquareDist(FarseerPhysics.Common.Decomposition.BayazitDecomposer.At(i, vertices), FarseerPhysics.Common.Decomposition.BayazitDecomposer.At(j1, vertices)) + 1);
                                        if (FarseerPhysics.Common.Decomposition.BayazitDecomposer.Reflex(j1, vertices)) {
                                            if (FarseerPhysics.Common.Decomposition.BayazitDecomposer.RightOn(FarseerPhysics.Common.Decomposition.BayazitDecomposer.At(((j1 - 1) | 0), vertices), FarseerPhysics.Common.Decomposition.BayazitDecomposer.At(j1, vertices), FarseerPhysics.Common.Decomposition.BayazitDecomposer.At(i, vertices)) && FarseerPhysics.Common.Decomposition.BayazitDecomposer.LeftOn(FarseerPhysics.Common.Decomposition.BayazitDecomposer.At(((j1 + 1) | 0), vertices), FarseerPhysics.Common.Decomposition.BayazitDecomposer.At(j1, vertices), FarseerPhysics.Common.Decomposition.BayazitDecomposer.At(i, vertices))) {
                                                score += 3;
                                            } else {
                                                score += 2;
                                            }
                                        } else {
                                            score += 1;
                                        }
                                        if (score > highestScore) {
                                            bestIndex = j1;
                                            highestScore = score;
                                        }
                                    }
                                }
                                lowerPoly = FarseerPhysics.Common.Decomposition.BayazitDecomposer.Copy(i, Bridge.Int.clip32(bestIndex), vertices);
                                upperPoly = FarseerPhysics.Common.Decomposition.BayazitDecomposer.Copy(Bridge.Int.clip32(bestIndex), i, vertices);
                            }
                            list.AddRange(FarseerPhysics.Common.Decomposition.BayazitDecomposer.ConvexPartition(lowerPoly));
                            list.AddRange(FarseerPhysics.Common.Decomposition.BayazitDecomposer.ConvexPartition(upperPoly));
                            return list;
                        }
                    }

                    if (vertices.Count > FarseerPhysics.Settings.MaxPolygonVertices) {
                        lowerPoly = FarseerPhysics.Common.Decomposition.BayazitDecomposer.Copy(0, ((Bridge.Int.div(vertices.Count, 2)) | 0), vertices);
                        upperPoly = FarseerPhysics.Common.Decomposition.BayazitDecomposer.Copy(((Bridge.Int.div(vertices.Count, 2)) | 0), 0, vertices);
                        list.AddRange(FarseerPhysics.Common.Decomposition.BayazitDecomposer.ConvexPartition(lowerPoly));
                        list.AddRange(FarseerPhysics.Common.Decomposition.BayazitDecomposer.ConvexPartition(upperPoly));
                    } else {
                        list.add(vertices);
                    }

                    for (var i1 = 0; i1 < list.Count; i1 = (i1 + 1) | 0) {
                        list.setItem(i1, FarseerPhysics.Common.PolygonManipulation.SimplifyTools.CollinearSimplify$1(list.getItem(i1), 0));
                    }

                    for (var i2 = (list.Count - 1) | 0; i2 >= 0; i2 = (i2 - 1) | 0) {
                        if (list.getItem(i2).Count === 0) {
                            list.removeAt(i2);
                        }
                    }

                    return list;
                },
                CanSee: function (i, j, vertices) {
                    if (FarseerPhysics.Common.Decomposition.BayazitDecomposer.Reflex(i, vertices)) {
                        if (FarseerPhysics.Common.Decomposition.BayazitDecomposer.LeftOn(FarseerPhysics.Common.Decomposition.BayazitDecomposer.At(i, vertices), FarseerPhysics.Common.Decomposition.BayazitDecomposer.At(((i - 1) | 0), vertices), FarseerPhysics.Common.Decomposition.BayazitDecomposer.At(j, vertices)) && FarseerPhysics.Common.Decomposition.BayazitDecomposer.RightOn(FarseerPhysics.Common.Decomposition.BayazitDecomposer.At(i, vertices), FarseerPhysics.Common.Decomposition.BayazitDecomposer.At(((i + 1) | 0), vertices), FarseerPhysics.Common.Decomposition.BayazitDecomposer.At(j, vertices))) {
                            return false;
                        }
                    } else {
                        if (FarseerPhysics.Common.Decomposition.BayazitDecomposer.RightOn(FarseerPhysics.Common.Decomposition.BayazitDecomposer.At(i, vertices), FarseerPhysics.Common.Decomposition.BayazitDecomposer.At(((i + 1) | 0), vertices), FarseerPhysics.Common.Decomposition.BayazitDecomposer.At(j, vertices)) || FarseerPhysics.Common.Decomposition.BayazitDecomposer.LeftOn(FarseerPhysics.Common.Decomposition.BayazitDecomposer.At(i, vertices), FarseerPhysics.Common.Decomposition.BayazitDecomposer.At(((i - 1) | 0), vertices), FarseerPhysics.Common.Decomposition.BayazitDecomposer.At(j, vertices))) {
                            return false;
                        }
                    }
                    if (FarseerPhysics.Common.Decomposition.BayazitDecomposer.Reflex(j, vertices)) {
                        if (FarseerPhysics.Common.Decomposition.BayazitDecomposer.LeftOn(FarseerPhysics.Common.Decomposition.BayazitDecomposer.At(j, vertices), FarseerPhysics.Common.Decomposition.BayazitDecomposer.At(((j - 1) | 0), vertices), FarseerPhysics.Common.Decomposition.BayazitDecomposer.At(i, vertices)) && FarseerPhysics.Common.Decomposition.BayazitDecomposer.RightOn(FarseerPhysics.Common.Decomposition.BayazitDecomposer.At(j, vertices), FarseerPhysics.Common.Decomposition.BayazitDecomposer.At(((j + 1) | 0), vertices), FarseerPhysics.Common.Decomposition.BayazitDecomposer.At(i, vertices))) {
                            return false;
                        }
                    } else {
                        if (FarseerPhysics.Common.Decomposition.BayazitDecomposer.RightOn(FarseerPhysics.Common.Decomposition.BayazitDecomposer.At(j, vertices), FarseerPhysics.Common.Decomposition.BayazitDecomposer.At(((j + 1) | 0), vertices), FarseerPhysics.Common.Decomposition.BayazitDecomposer.At(i, vertices)) || FarseerPhysics.Common.Decomposition.BayazitDecomposer.LeftOn(FarseerPhysics.Common.Decomposition.BayazitDecomposer.At(j, vertices), FarseerPhysics.Common.Decomposition.BayazitDecomposer.At(((j - 1) | 0), vertices), FarseerPhysics.Common.Decomposition.BayazitDecomposer.At(i, vertices))) {
                            return false;
                        }
                    }
                    for (var k = 0; k < vertices.Count; k = (k + 1) | 0) {
                        if ((((k + 1) | 0)) % vertices.Count === i || k === i || (((k + 1) | 0)) % vertices.Count === j || k === j) {
                            continue;
                        }
                        var intersectionPoint = { v : new Microsoft.Xna.Framework.Vector2() };
                        if (FarseerPhysics.Common.LineTools.LineIntersect$1(FarseerPhysics.Common.Decomposition.BayazitDecomposer.At(i, vertices), FarseerPhysics.Common.Decomposition.BayazitDecomposer.At(j, vertices), FarseerPhysics.Common.Decomposition.BayazitDecomposer.At(k, vertices), FarseerPhysics.Common.Decomposition.BayazitDecomposer.At(((k + 1) | 0), vertices), intersectionPoint)) {
                            return false;
                        }
                    }
                    return true;
                },
                Reflex: function (i, vertices) {
                    return FarseerPhysics.Common.Decomposition.BayazitDecomposer.Right$1(i, vertices);
                },
                Right$1: function (i, vertices) {
                    return FarseerPhysics.Common.Decomposition.BayazitDecomposer.Right(FarseerPhysics.Common.Decomposition.BayazitDecomposer.At(((i - 1) | 0), vertices), FarseerPhysics.Common.Decomposition.BayazitDecomposer.At(i, vertices), FarseerPhysics.Common.Decomposition.BayazitDecomposer.At(((i + 1) | 0), vertices));
                },
                Right: function (a, b, c) {
                    a = {v:a};
                    b = {v:b};
                    c = {v:c};
                    return FarseerPhysics.Common.MathUtils.Area$1(a, b, c) < 0;
                },
                Left: function (a, b, c) {
                    a = {v:a};
                    b = {v:b};
                    c = {v:c};
                    return FarseerPhysics.Common.MathUtils.Area$1(a, b, c) > 0;
                },
                LeftOn: function (a, b, c) {
                    a = {v:a};
                    b = {v:b};
                    c = {v:c};
                    return FarseerPhysics.Common.MathUtils.Area$1(a, b, c) >= 0;
                },
                RightOn: function (a, b, c) {
                    a = {v:a};
                    b = {v:b};
                    c = {v:c};
                    return FarseerPhysics.Common.MathUtils.Area$1(a, b, c) <= 0;
                },
                SquareDist: function (a, b) {
                    var dx = b.X - a.X;
                    var dy = b.Y - a.Y;
                    return dx * dx + dy * dy;
                }
            }
        }
    });

    Bridge.define("FarseerPhysics.Common.Decomposition.CDT.Orientation", {
        $kind: "enum",
        statics: {
            fields: {
                CW: 0,
                CCW: 1,
                Collinear: 2
            }
        }
    });

    Bridge.define("FarseerPhysics.Common.Decomposition.CDTDecomposer", {
        statics: {
            methods: {
                ConvexPartition$1: function (vertices) {
                    var $t, $t1, $t2;
                    var poly = new Poly2Tri.Triangulation.Polygon.Polygon.ctor();

                    $t = Bridge.getEnumerator(vertices);
                    try {
                        while ($t.moveNext()) {
                            var vertex = $t.Current.$clone();
                            System.Array.add(poly.Points, new Poly2Tri.Triangulation.TriangulationPoint(vertex.X, vertex.Y), Poly2Tri.Triangulation.TriangulationPoint);
                        }
                    } finally {
                        if (Bridge.is($t, System.IDisposable)) {
                            $t.System$IDisposable$Dispose();
                        }
                    }
                    var tcx = new Poly2Tri.Triangulation.Delaunay.Sweep.DTSweepContext();
                    tcx.PrepareTriangulation(poly);
                    Poly2Tri.Triangulation.Delaunay.Sweep.DTSweep.Triangulate(tcx);

                    var results = new (System.Collections.Generic.List$1(FarseerPhysics.Common.Vertices)).ctor();

                    $t1 = Bridge.getEnumerator(poly.Triangles, Poly2Tri.Triangulation.Delaunay.DelaunayTriangle);
                    try {
                        while ($t1.moveNext()) {
                            var triangle = $t1.Current;
                            var v = new FarseerPhysics.Common.Vertices.ctor();
                            $t2 = Bridge.getEnumerator(triangle.Points);
                            try {
                                while ($t2.moveNext()) {
                                    var p = $t2.Current;
                                    v.add(new Microsoft.Xna.Framework.Vector2.$ctor2(p.X, p.Y));
                                }
                            } finally {
                                if (Bridge.is($t2, System.IDisposable)) {
                                    $t2.System$IDisposable$Dispose();
                                }
                            }results.add(v);
                        }
                    } finally {
                        if (Bridge.is($t1, System.IDisposable)) {
                            $t1.System$IDisposable$Dispose();
                        }
                    }
                    return results;
                },
                ConvexPartition: function (vertices) {
                    var $t, $t1, $t2, $t3, $t4;
                    var poly = new Poly2Tri.Triangulation.Polygon.Polygon.ctor();
                    $t = Bridge.getEnumerator(vertices);
                    try {
                        while ($t.moveNext()) {
                            var vertex = $t.Current.$clone();
                            System.Array.add(poly.Points, new Poly2Tri.Triangulation.TriangulationPoint(vertex.X, vertex.Y), Poly2Tri.Triangulation.TriangulationPoint);
                        }
                    } finally {
                        if (Bridge.is($t, System.IDisposable)) {
                            $t.System$IDisposable$Dispose();
                        }
                    }
                    if (vertices.Holes != null) {
                        $t1 = Bridge.getEnumerator(vertices.Holes);
                        try {
                            while ($t1.moveNext()) {
                                var holeVertices = $t1.Current;
                                var hole = new Poly2Tri.Triangulation.Polygon.Polygon.ctor();
                                $t2 = Bridge.getEnumerator(holeVertices);
                                try {
                                    while ($t2.moveNext()) {
                                        var vertex1 = $t2.Current.$clone();
                                        System.Array.add(hole.Points, new Poly2Tri.Triangulation.TriangulationPoint(vertex1.X, vertex1.Y), Poly2Tri.Triangulation.TriangulationPoint);
                                    }
                                } finally {
                                    if (Bridge.is($t2, System.IDisposable)) {
                                        $t2.System$IDisposable$Dispose();
                                    }
                                }
                                poly.AddHole(hole);
                            }
                        } finally {
                            if (Bridge.is($t1, System.IDisposable)) {
                                $t1.System$IDisposable$Dispose();
                            }
                        }}

                    var tcx = new Poly2Tri.Triangulation.Delaunay.Sweep.DTSweepContext();
                    tcx.PrepareTriangulation(poly);
                    Poly2Tri.Triangulation.Delaunay.Sweep.DTSweep.Triangulate(tcx);

                    var results = new (System.Collections.Generic.List$1(FarseerPhysics.Common.Vertices)).ctor();

                    $t3 = Bridge.getEnumerator(poly.Triangles, Poly2Tri.Triangulation.Delaunay.DelaunayTriangle);
                    try {
                        while ($t3.moveNext()) {
                            var triangle = $t3.Current;
                            var v = new FarseerPhysics.Common.Vertices.ctor();
                            $t4 = Bridge.getEnumerator(triangle.Points);
                            try {
                                while ($t4.moveNext()) {
                                    var p = $t4.Current;
                                    v.add(new Microsoft.Xna.Framework.Vector2.$ctor2(p.X, p.Y));
                                }
                            } finally {
                                if (Bridge.is($t4, System.IDisposable)) {
                                    $t4.System$IDisposable$Dispose();
                                }
                            }results.add(v);
                        }
                    } finally {
                        if (Bridge.is($t3, System.IDisposable)) {
                            $t3.System$IDisposable$Dispose();
                        }
                    }
                    return results;
                }
            }
        }
    });

    /**
     * Ported from jBox2D. Original author: ewjordan 
     Triangulates a polygon using simple ear-clipping algorithm.
     Only works on simple polygons.
     Triangles may be degenerate, especially if you have identical points
     in the input to the algorithm.  Check this before you use them.
     *
     * @static
     * @abstract
     * @public
     * @class FarseerPhysics.Common.Decomposition.EarclipDecomposer
     */
    Bridge.define("FarseerPhysics.Common.Decomposition.EarclipDecomposer", {
        statics: {
            fields: {
                Tol: 0
            },
            ctors: {
                init: function () {
                    this.Tol = 0.001;
                }
            },
            methods: {
                /**
                 * Decomposes a non-convex polygon into a number of convex polygons, up
                 to maxPolys (remaining pieces are thrown out).
                 Each resulting polygon will have no more than Settings.MaxPolygonVertices
                 vertices.
                 Warning: Only works on simple polygons
                 *
                 * @static
                 * @public
                 * @this FarseerPhysics.Common.Decomposition.EarclipDecomposer
                 * @memberof FarseerPhysics.Common.Decomposition.EarclipDecomposer
                 * @param   {FarseerPhysics.Common.Vertices}       vertices    The vertices.
                 * @return  {System.Collections.Generic.List$1}
                 */
                ConvexPartition: function (vertices) {
                    return FarseerPhysics.Common.Decomposition.EarclipDecomposer.ConvexPartition$1(vertices, 2147483647, 0);
                },
                /**
                 * Decomposes a non-convex polygon into a number of convex polygons, up
                 to maxPolys (remaining pieces are thrown out).
                 Each resulting polygon will have no more than Settings.MaxPolygonVertices
                 vertices.
                 Warning: Only works on simple polygons
                 *
                 * @static
                 * @public
                 * @this FarseerPhysics.Common.Decomposition.EarclipDecomposer
                 * @memberof FarseerPhysics.Common.Decomposition.EarclipDecomposer
                 * @param   {FarseerPhysics.Common.Vertices}       vertices     The vertices.
                 * @param   {number}                               maxPolys     The maximum number of polygons.
                 * @param   {number}                               tolerance    The tolerance.
                 * @return  {System.Collections.Generic.List$1}
                 */
                ConvexPartition$1: function (vertices, maxPolys, tolerance) {
                    if (vertices.Count < 3) {
                        return function (_o1) {
                                _o1.add(vertices);
                                return _o1;
                            }(new (System.Collections.Generic.List$1(FarseerPhysics.Common.Vertices)).ctor());
                    }
                    /* 
                    if (vertices.IsConvex() && vertices.Count <= Settings.MaxPolygonVertices)
                    {
                       if (vertices.IsCounterClockWise())
                       {
                           Vertices tempP = new Vertices(vertices);
                           tempP.Reverse();
                           tempP = SimplifyTools.CollinearSimplify(tempP);
                           tempP.ForceCounterClockWise();
                           return new List<Vertices> { tempP };
                       }
                       vertices = SimplifyTools.CollinearSimplify(vertices);
                       vertices.ForceCounterClockWise();
                       return new List<Vertices> { vertices };
                    }
                    */
                    var triangulated;

                    if (vertices.IsCounterClockWise()) {
                        var tempP = new FarseerPhysics.Common.Vertices.$ctor2(vertices);
                        tempP.Reverse();
                        triangulated = FarseerPhysics.Common.Decomposition.EarclipDecomposer.TriangulatePolygon(tempP);
                    } else {
                        triangulated = FarseerPhysics.Common.Decomposition.EarclipDecomposer.TriangulatePolygon(vertices);
                    }
                    if (triangulated.Count < 1) {
                        throw new System.Exception("Can't triangulate your polygon.");
                    }

                    var polygonizedTriangles = FarseerPhysics.Common.Decomposition.EarclipDecomposer.PolygonizeTriangles(triangulated, maxPolys, tolerance);

                    for (var i = 0; i < polygonizedTriangles.Count; i = (i + 1) | 0) {
                        polygonizedTriangles.setItem(i, FarseerPhysics.Common.PolygonManipulation.SimplifyTools.CollinearSimplify$1(polygonizedTriangles.getItem(i), 0));
                    }

                    for (var i1 = (polygonizedTriangles.Count - 1) | 0; i1 >= 0; i1 = (i1 - 1) | 0) {
                        if (polygonizedTriangles.getItem(i1).Count === 0) {
                            polygonizedTriangles.removeAt(i1);
                        }
                    }

                    return polygonizedTriangles;
                },
                /**
                 * Turns a list of triangles into a list of convex polygons. Very simple
                 method - start with a seed triangle, keep adding triangles to it until
                 you can't add any more without making the polygon non-convex.
                 Returns an integer telling how many polygons were created.  Will fill
                 polys array up to polysLength entries, which may be smaller or larger
                 than the return value.
                 Takes O(NP) where P is the number of resultant polygons, N is triangle
                 count.
                 The final polygon list will not necessarily be minimal, though in
                 practice it works fairly well.
                 *
                 * @static
                 * @public
                 * @this FarseerPhysics.Common.Decomposition.EarclipDecomposer
                 * @memberof FarseerPhysics.Common.Decomposition.EarclipDecomposer
                 * @param   {System.Collections.Generic.List$1}    triangulated    The triangulated.
                 * @param   {number}                               maxPolys        The maximun number of polygons
                 * @param   {number}                               tolerance       The tolerance
                 * @return  {System.Collections.Generic.List$1}
                 */
                PolygonizeTriangles: function (triangulated, maxPolys, tolerance) {
                    var $t, $t1, $t2, $t3, $t4, $t5, $t6, $t7, $t8, $t9, $t10, $t11, $t12, $t13;
                    var polys = new (System.Collections.Generic.List$1(FarseerPhysics.Common.Vertices)).$ctor2(50);

                    var polyIndex = 0;

                    if (triangulated.Count <= 0) {
                        return polys;
                    }

                    var covered = System.Array.init(triangulated.Count, false, System.Boolean);
                    for (var i = 0; i < triangulated.Count; i = (i + 1) | 0) {
                        covered[System.Array.index(i, covered)] = false;

                        if (((($t = triangulated.getItem(i).X)[System.Array.index(0, $t)] === ($t1 = triangulated.getItem(i).X)[System.Array.index(1, $t1)]) && (($t2 = triangulated.getItem(i).Y)[System.Array.index(0, $t2)] === ($t3 = triangulated.getItem(i).Y)[System.Array.index(1, $t3)])) || ((($t4 = triangulated.getItem(i).X)[System.Array.index(1, $t4)] === ($t5 = triangulated.getItem(i).X)[System.Array.index(2, $t5)]) && (($t6 = triangulated.getItem(i).Y)[System.Array.index(1, $t6)] === ($t7 = triangulated.getItem(i).Y)[System.Array.index(2, $t7)])) || ((($t8 = triangulated.getItem(i).X)[System.Array.index(0, $t8)] === ($t9 = triangulated.getItem(i).X)[System.Array.index(2, $t9)]) && (($t10 = triangulated.getItem(i).Y)[System.Array.index(0, $t10)] === ($t11 = triangulated.getItem(i).Y)[System.Array.index(2, $t11)]))) {
                            covered[System.Array.index(i, covered)] = true;
                        }
                    }

                    var notDone = true;
                    while (notDone) {
                        var currTri = -1;
                        for (var i1 = 0; i1 < triangulated.Count; i1 = (i1 + 1) | 0) {
                            if (covered[System.Array.index(i1, covered)]) {
                                continue;
                            }
                            currTri = i1;
                            break;
                        }
                        if (currTri === -1) {
                            notDone = false;
                        } else {
                            var poly = new FarseerPhysics.Common.Vertices.$ctor3(3);

                            for (var i2 = 0; i2 < 3; i2 = (i2 + 1) | 0) {
                                poly.add(new Microsoft.Xna.Framework.Vector2.$ctor2(($t12 = triangulated.getItem(currTri).X)[System.Array.index(i2, $t12)], ($t13 = triangulated.getItem(currTri).Y)[System.Array.index(i2, $t13)]));
                            }

                            covered[System.Array.index(currTri, covered)] = true;
                            var index = 0;
                            for (var i3 = 0; i3 < Bridge.Int.mul(2, triangulated.Count); i3 = (i3 + 1) | 0, index = (index + 1) | 0) {
                                while (index >= triangulated.Count) {
                                    index = (index - triangulated.Count) | 0;
                                }
                                if (covered[System.Array.index(index, covered)]) {
                                    continue;
                                }
                                var newP = FarseerPhysics.Common.Decomposition.EarclipDecomposer.AddTriangle(triangulated.getItem(index), poly);
                                if (newP == null) {
                                    continue;
                                }

                                if (newP.Count > FarseerPhysics.Settings.MaxPolygonVertices) {
                                    continue;
                                }

                                if (newP.IsConvex()) {
                                    poly = new FarseerPhysics.Common.Vertices.$ctor2(newP);
                                    covered[System.Array.index(index, covered)] = true;
                                }
                            }

                            if (polyIndex < maxPolys) {

                                if (poly.Count >= 3) {
                                    polys.add(new FarseerPhysics.Common.Vertices.$ctor2(poly));
                                }
                            }
                            if (poly.Count >= 3) {
                                polyIndex = (polyIndex + 1) | 0;
                            }
                        }
                    }

                    return polys;
                },
                /**
                 * Triangulates a polygon using simple ear-clipping algorithm. Returns
                 size of Triangle array unless the polygon can't be triangulated.
                 This should only happen if the polygon self-intersects,
                 though it will not _always_ return null for a bad polygon - it is the
                 caller's responsibility to check for self-intersection, and if it
                 doesn't, it should at least check that the return value is non-null
                 before using. You're warned!
                 Triangles may be degenerate, especially if you have identical points
                 in the input to the algorithm.  Check this before you use them.
                 This is totally unoptimized, so for large polygons it should not be part
                 of the simulation loop.
                 Warning: Only works on simple polygons.
                 *
                 * @static
                 * @public
                 * @this FarseerPhysics.Common.Decomposition.EarclipDecomposer
                 * @memberof FarseerPhysics.Common.Decomposition.EarclipDecomposer
                 * @param   {FarseerPhysics.Common.Vertices}       vertices
                 * @return  {System.Collections.Generic.List$1}
                 */
                TriangulatePolygon: function (vertices) {
                    var results = new (System.Collections.Generic.List$1(FarseerPhysics.Common.Decomposition.Triangle)).ctor();
                    if (vertices.Count < 3) {
                        return new (System.Collections.Generic.List$1(FarseerPhysics.Common.Decomposition.Triangle)).ctor();
                    }

                    var pA = { }, pB = { };
                    var pin = new FarseerPhysics.Common.Vertices.$ctor2(vertices);
                    if (FarseerPhysics.Common.Decomposition.EarclipDecomposer.ResolvePinchPoint(pin, pA, pB)) {
                        var mergeA = FarseerPhysics.Common.Decomposition.EarclipDecomposer.TriangulatePolygon(pA.v);
                        var mergeB = FarseerPhysics.Common.Decomposition.EarclipDecomposer.TriangulatePolygon(pB.v);

                        if (mergeA.Count === -1 || mergeB.Count === -1) {
                            throw new System.Exception("Can't triangulate your polygon.");
                        }

                        for (var i = 0; i < mergeA.Count; i = (i + 1) | 0) {
                            results.add(new FarseerPhysics.Common.Decomposition.Triangle.ctor(mergeA.getItem(i)));
                        }
                        for (var i1 = 0; i1 < mergeB.Count; i1 = (i1 + 1) | 0) {
                            results.add(new FarseerPhysics.Common.Decomposition.Triangle.ctor(mergeB.getItem(i1)));
                        }

                        return results;
                    }

                    var buffer = System.Array.init(((vertices.Count - 2) | 0), null, FarseerPhysics.Common.Decomposition.Triangle);
                    var bufferSize = 0;
                    var xrem = System.Array.init(vertices.Count, 0, System.Single);
                    var yrem = System.Array.init(vertices.Count, 0, System.Single);
                    for (var i2 = 0; i2 < vertices.Count; i2 = (i2 + 1) | 0) {
                        xrem[System.Array.index(i2, xrem)] = vertices.getItem(i2).$clone().X;
                        yrem[System.Array.index(i2, yrem)] = vertices.getItem(i2).$clone().Y;
                    }

                    var vNum = vertices.Count;

                    while (vNum > 3) {
                        var earIndex = -1;
                        var earMaxMinCross = -10.0;
                        for (var i3 = 0; i3 < vNum; i3 = (i3 + 1) | 0) {
                            if (FarseerPhysics.Common.Decomposition.EarclipDecomposer.IsEar(i3, xrem, yrem, vNum)) {
                                var lower = FarseerPhysics.Common.Decomposition.EarclipDecomposer.Remainder(((i3 - 1) | 0), vNum);
                                var upper = FarseerPhysics.Common.Decomposition.EarclipDecomposer.Remainder(((i3 + 1) | 0), vNum);
                                var d1 = { v : new Microsoft.Xna.Framework.Vector2.$ctor2(xrem[System.Array.index(upper, xrem)] - xrem[System.Array.index(i3, xrem)], yrem[System.Array.index(upper, yrem)] - yrem[System.Array.index(i3, yrem)]) };
                                var d2 = { v : new Microsoft.Xna.Framework.Vector2.$ctor2(xrem[System.Array.index(i3, xrem)] - xrem[System.Array.index(lower, xrem)], yrem[System.Array.index(i3, yrem)] - yrem[System.Array.index(lower, yrem)]) };
                                var d3 = { v : new Microsoft.Xna.Framework.Vector2.$ctor2(xrem[System.Array.index(lower, xrem)] - xrem[System.Array.index(upper, xrem)], yrem[System.Array.index(lower, yrem)] - yrem[System.Array.index(upper, yrem)]) };

                                d1.v.Normalize();
                                d2.v.Normalize();
                                d3.v.Normalize();
                                var cross12 = { };
                                FarseerPhysics.Common.MathUtils.Cross$3(d1, d2, cross12);
                                cross12.v = Math.abs(cross12.v);

                                var cross23 = { };
                                FarseerPhysics.Common.MathUtils.Cross$3(d2, d3, cross23);
                                cross23.v = Math.abs(cross23.v);

                                var cross31 = { };
                                FarseerPhysics.Common.MathUtils.Cross$3(d3, d1, cross31);
                                cross31.v = Math.abs(cross31.v);

                                var minCross = Math.min(cross12.v, Math.min(cross23.v, cross31.v));
                                if (minCross > earMaxMinCross) {
                                    earIndex = i3;
                                    earMaxMinCross = minCross;
                                }
                            }
                        }

                        if (earIndex === -1) {
                            for (var i4 = 0; i4 < bufferSize; i4 = (i4 + 1) | 0) {
                                results.add(new FarseerPhysics.Common.Decomposition.Triangle.ctor(buffer[System.Array.index(i4, buffer)]));
                            }

                            return results;
                        }


                        vNum = (vNum - 1) | 0;
                        var newx = System.Array.init(vNum, 0, System.Single);
                        var newy = System.Array.init(vNum, 0, System.Single);
                        var currDest = 0;
                        for (var i5 = 0; i5 < vNum; i5 = (i5 + 1) | 0) {
                            if (currDest === earIndex) {
                                currDest = (currDest + 1) | 0;
                            }
                            newx[System.Array.index(i5, newx)] = xrem[System.Array.index(currDest, xrem)];
                            newy[System.Array.index(i5, newy)] = yrem[System.Array.index(currDest, yrem)];
                            currDest = (currDest + 1) | 0;
                        }

                        var under = (earIndex === 0) ? (vNum) : (((earIndex - 1) | 0));
                        var over = (earIndex === vNum) ? 0 : (((earIndex + 1) | 0));
                        var toAdd = new FarseerPhysics.Common.Decomposition.Triangle.$ctor1(xrem[System.Array.index(earIndex, xrem)], yrem[System.Array.index(earIndex, yrem)], xrem[System.Array.index(over, xrem)], yrem[System.Array.index(over, yrem)], xrem[System.Array.index(under, xrem)], yrem[System.Array.index(under, yrem)]);
                        buffer[System.Array.index(bufferSize, buffer)] = toAdd;
                        bufferSize = (bufferSize + 1) | 0;

                        xrem = newx;
                        yrem = newy;
                    }

                    var tooAdd = new FarseerPhysics.Common.Decomposition.Triangle.$ctor1(xrem[System.Array.index(1, xrem)], yrem[System.Array.index(1, yrem)], xrem[System.Array.index(2, xrem)], yrem[System.Array.index(2, yrem)], xrem[System.Array.index(0, xrem)], yrem[System.Array.index(0, yrem)]);
                    buffer[System.Array.index(bufferSize, buffer)] = tooAdd;
                    bufferSize = (bufferSize + 1) | 0;

                    for (var i6 = 0; i6 < bufferSize; i6 = (i6 + 1) | 0) {
                        results.add(new FarseerPhysics.Common.Decomposition.Triangle.ctor(buffer[System.Array.index(i6, buffer)]));
                    }

                    return results;
                },
                /**
                 * Finds and fixes "pinch points," points where two polygon
                 vertices are at the same point.
                 If a pinch point is found, pin is broken up into poutA and poutB
                 and true is returned; otherwise, returns false.
                 Mostly for internal use.
                 O(N^2) time, which sucks...
                 *
                 * @static
                 * @private
                 * @this FarseerPhysics.Common.Decomposition.EarclipDecomposer
                 * @memberof FarseerPhysics.Common.Decomposition.EarclipDecomposer
                 * @param   {FarseerPhysics.Common.Vertices}    pin      The pin.
                 * @param   {FarseerPhysics.Common.Vertices}    poutA    The pout A.
                 * @param   {FarseerPhysics.Common.Vertices}    poutB    The pout B.
                 * @return  {boolean}
                 */
                ResolvePinchPoint: function (pin, poutA, poutB) {
                    poutA.v = new FarseerPhysics.Common.Vertices.ctor();
                    poutB.v = new FarseerPhysics.Common.Vertices.ctor();

                    if (pin.Count < 3) {
                        return false;
                    }

                    var hasPinchPoint = false;
                    var pinchIndexA = -1;
                    var pinchIndexB = -1;
                    for (var i = 0; i < pin.Count; i = (i + 1) | 0) {
                        for (var j = (i + 1) | 0; j < pin.Count; j = (j + 1) | 0) {
                            if (Math.abs(pin.getItem(i).$clone().X - pin.getItem(j).$clone().X) < FarseerPhysics.Common.Decomposition.EarclipDecomposer.Tol && Math.abs(pin.getItem(i).$clone().Y - pin.getItem(j).$clone().Y) < FarseerPhysics.Common.Decomposition.EarclipDecomposer.Tol && j !== ((i + 1) | 0)) {
                                pinchIndexA = i;
                                pinchIndexB = j;
                                hasPinchPoint = true;
                                break;
                            }
                        }
                        if (hasPinchPoint) {
                            break;
                        }
                    }
                    if (hasPinchPoint) {
                        var sizeA = (pinchIndexB - pinchIndexA) | 0;
                        if (sizeA === pin.Count) {
                            return false;
                        }
                        for (var i1 = 0; i1 < sizeA; i1 = (i1 + 1) | 0) {
                            var ind = FarseerPhysics.Common.Decomposition.EarclipDecomposer.Remainder(((pinchIndexA + i1) | 0), pin.Count);
                            poutA.v.add(pin.getItem(ind).$clone());
                        }

                        var sizeB = (pin.Count - sizeA) | 0;
                        for (var i2 = 0; i2 < sizeB; i2 = (i2 + 1) | 0) {
                            var ind1 = FarseerPhysics.Common.Decomposition.EarclipDecomposer.Remainder(((pinchIndexB + i2) | 0), pin.Count);
                            poutB.v.add(pin.getItem(ind1).$clone());
                        }
                    }
                    return hasPinchPoint;
                },
                /**
                 * Fix for obnoxious behavior for the % operator for negative numbers...
                 *
                 * @static
                 * @private
                 * @this FarseerPhysics.Common.Decomposition.EarclipDecomposer
                 * @memberof FarseerPhysics.Common.Decomposition.EarclipDecomposer
                 * @param   {number}    x          The x.
                 * @param   {number}    modulus    The modulus.
                 * @return  {number}
                 */
                Remainder: function (x, modulus) {
                    var rem = x % modulus;
                    while (rem < 0) {
                        rem = (rem + modulus) | 0;
                    }
                    return rem;
                },
                AddTriangle: function (t, vertices) {
                    var firstP = -1;
                    var firstT = -1;
                    var secondP = -1;
                    var secondT = -1;
                    for (var i = 0; i < vertices.Count; i = (i + 1) | 0) {
                        if (t.X[System.Array.index(0, t.X)] === vertices.getItem(i).$clone().X && t.Y[System.Array.index(0, t.Y)] === vertices.getItem(i).$clone().Y) {
                            if (firstP === -1) {
                                firstP = i;
                                firstT = 0;
                            } else {
                                secondP = i;
                                secondT = 0;
                            }
                        } else if (t.X[System.Array.index(1, t.X)] === vertices.getItem(i).$clone().X && t.Y[System.Array.index(1, t.Y)] === vertices.getItem(i).$clone().Y) {
                            if (firstP === -1) {
                                firstP = i;
                                firstT = 1;
                            } else {
                                secondP = i;
                                secondT = 1;
                            }
                        } else if (t.X[System.Array.index(2, t.X)] === vertices.getItem(i).$clone().X && t.Y[System.Array.index(2, t.Y)] === vertices.getItem(i).$clone().Y) {
                            if (firstP === -1) {
                                firstP = i;
                                firstT = 2;
                            } else {
                                secondP = i;
                                secondT = 2;
                            }
                        }
                    }
                    if (firstP === 0 && secondP === ((vertices.Count - 1) | 0)) {
                        firstP = (vertices.Count - 1) | 0;
                        secondP = 0;
                    }

                    if (secondP === -1) {
                        return null;
                    }

                    var tipT = 0;
                    if (tipT === firstT || tipT === secondT) {
                        tipT = 1;
                    }
                    if (tipT === firstT || tipT === secondT) {
                        tipT = 2;
                    }

                    var result = new FarseerPhysics.Common.Vertices.$ctor3(((vertices.Count + 1) | 0));
                    for (var i1 = 0; i1 < vertices.Count; i1 = (i1 + 1) | 0) {
                        result.add(vertices.getItem(i1).$clone());

                        if (i1 === firstP) {
                            result.add(new Microsoft.Xna.Framework.Vector2.$ctor2(t.X[System.Array.index(tipT, t.X)], t.Y[System.Array.index(tipT, t.Y)]));
                        }
                    }

                    return result;
                },
                /**
                 * Checks if vertex i is the tip of an ear in polygon defined by xv[] and
                 yv[].
                 Assumes clockwise orientation of polygon...ick
                 *
                 * @static
                 * @private
                 * @this FarseerPhysics.Common.Decomposition.EarclipDecomposer
                 * @memberof FarseerPhysics.Common.Decomposition.EarclipDecomposer
                 * @param   {number}            i           The i.
                 * @param   {Array.<number>}    xv          The xv.
                 * @param   {Array.<number>}    yv          The yv.
                 * @param   {number}            xvLength    Length of the xv.
                 * @return  {boolean}                       <pre><code>true</code></pre> if the specified i is ear; otherwise, <pre><code>false</code></pre>.
                 */
                IsEar: function (i, xv, yv, xvLength) {
                    var dx0, dy0, dx1, dy1;
                    if (i >= xvLength || i < 0 || xvLength < 3) {
                        return false;
                    }
                    var upper = (i + 1) | 0;
                    var lower = (i - 1) | 0;
                    if (i === 0) {
                        dx0 = xv[System.Array.index(0, xv)] - xv[System.Array.index(((xvLength - 1) | 0), xv)];
                        dy0 = yv[System.Array.index(0, yv)] - yv[System.Array.index(((xvLength - 1) | 0), yv)];
                        dx1 = xv[System.Array.index(1, xv)] - xv[System.Array.index(0, xv)];
                        dy1 = yv[System.Array.index(1, yv)] - yv[System.Array.index(0, yv)];
                        lower = (xvLength - 1) | 0;
                    } else if (i === ((xvLength - 1) | 0)) {
                        dx0 = xv[System.Array.index(i, xv)] - xv[System.Array.index(((i - 1) | 0), xv)];
                        dy0 = yv[System.Array.index(i, yv)] - yv[System.Array.index(((i - 1) | 0), yv)];
                        dx1 = xv[System.Array.index(0, xv)] - xv[System.Array.index(i, xv)];
                        dy1 = yv[System.Array.index(0, yv)] - yv[System.Array.index(i, yv)];
                        upper = 0;
                    } else {
                        dx0 = xv[System.Array.index(i, xv)] - xv[System.Array.index(((i - 1) | 0), xv)];
                        dy0 = yv[System.Array.index(i, yv)] - yv[System.Array.index(((i - 1) | 0), yv)];
                        dx1 = xv[System.Array.index(((i + 1) | 0), xv)] - xv[System.Array.index(i, xv)];
                        dy1 = yv[System.Array.index(((i + 1) | 0), yv)] - yv[System.Array.index(i, yv)];
                    }
                    var cross = dx0 * dy1 - dx1 * dy0;
                    if (cross > 0) {
                        return false;
                    }
                    var myTri = new FarseerPhysics.Common.Decomposition.Triangle.$ctor1(xv[System.Array.index(i, xv)], yv[System.Array.index(i, yv)], xv[System.Array.index(upper, xv)], yv[System.Array.index(upper, yv)], xv[System.Array.index(lower, xv)], yv[System.Array.index(lower, yv)]);
                    for (var j = 0; j < xvLength; j = (j + 1) | 0) {
                        if (j === i || j === lower || j === upper) {
                            continue;
                        }
                        if (myTri.IsInside(xv[System.Array.index(j, xv)], yv[System.Array.index(j, yv)])) {
                            return false;
                        }
                    }
                    return true;
                }
            }
        }
    });

    Bridge.define("FarseerPhysics.Common.Decomposition.Edge", {
        fields: {
            Above: null,
            B: 0,
            Below: null,
            MPoints: null,
            P: null,
            Q: null,
            Slope: 0
        },
        ctors: {
            ctor: function (p, q) {
                this.$initialize();
                this.P = p;
                this.Q = q;

                if (q.X - p.X !== 0) {
                    this.Slope = (q.Y - p.Y) / (q.X - p.X);
                } else {
                    this.Slope = 0;
                }

                this.B = p.Y - (p.X * this.Slope);
                this.Above = null;
                this.Below = null;
                this.MPoints = new (System.Collections.Generic.HashSet$1(FarseerPhysics.Common.Decomposition.Point)).ctor();
                this.MPoints.add(p);
                this.MPoints.add(q);
            }
        },
        methods: {
            IsAbove: function (point) {
                return this.P.Orient2D(this.Q, point) < 0;
            },
            IsBelow: function (point) {
                return this.P.Orient2D(this.Q, point) > 0;
            },
            AddMpoint: function (point) {
                var $t;
                $t = Bridge.getEnumerator(this.MPoints);
                try {
                    while ($t.moveNext()) {
                        var mp = $t.Current;
                        if (!mp.Neq(point)) {
                            return;
                        }
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }
                this.MPoints.add(point);
            }
        }
    });

    /**
     * Triangulates a polygon into triangles.
     Doesn't handle holes.
     *
     * @static
     * @abstract
     * @public
     * @class FarseerPhysics.Common.Decomposition.FlipcodeDecomposer
     */
    Bridge.define("FarseerPhysics.Common.Decomposition.FlipcodeDecomposer", {
        statics: {
            fields: {
                _tmpA: null,
                _tmpB: null,
                _tmpC: null
            },
            ctors: {
                init: function () {
                    this._tmpA = new Microsoft.Xna.Framework.Vector2();
                    this._tmpB = new Microsoft.Xna.Framework.Vector2();
                    this._tmpC = new Microsoft.Xna.Framework.Vector2();
                }
            },
            methods: {
                /**
                 * Check if the point P is inside the triangle defined by
                 the points A, B, C
                 *
                 * @static
                 * @private
                 * @this FarseerPhysics.Common.Decomposition.FlipcodeDecomposer
                 * @memberof FarseerPhysics.Common.Decomposition.FlipcodeDecomposer
                 * @param   {Microsoft.Xna.Framework.Vector2}    a    The A point.
                 * @param   {Microsoft.Xna.Framework.Vector2}    b    The B point.
                 * @param   {Microsoft.Xna.Framework.Vector2}    c    The C point.
                 * @param   {Microsoft.Xna.Framework.Vector2}    p    The point to be tested.
                 * @return  {boolean}                                 True if the point is inside the triangle
                 */
                InsideTriangle: function (a, b, c, p) {
                    var abp = (c.v.X - b.v.X) * (p.v.Y - b.v.Y) - (c.v.Y - b.v.Y) * (p.v.X - b.v.X);

                    var aap = (b.v.X - a.v.X) * (p.v.Y - a.v.Y) - (b.v.Y - a.v.Y) * (p.v.X - a.v.X);

                    var bcp = (a.v.X - c.v.X) * (p.v.Y - c.v.Y) - (a.v.Y - c.v.Y) * (p.v.X - c.v.X);

                    return ((abp >= 0.0) && (bcp >= 0.0) && (aap >= 0.0));
                },
                /**
                 * Cut a the contour and add a triangle into V to describe the 
                 location of the cut
                 *
                 * @static
                 * @private
                 * @this FarseerPhysics.Common.Decomposition.FlipcodeDecomposer
                 * @memberof FarseerPhysics.Common.Decomposition.FlipcodeDecomposer
                 * @param   {FarseerPhysics.Common.Vertices}    contour    The list of points defining the polygon
                 * @param   {number}                            u          The index of the first point
                 * @param   {number}                            v          The index of the second point
                 * @param   {number}                            w          The index of the third point
                 * @param   {number}                            n          The number of elements in the array.
                 * @param   {Array.<number>}                    V          The array to populate with indicies of triangles.
                 * @return  {boolean}                                      True if a triangle was found
                 */
                Snip: function (contour, u, v, w, n, V) {
                    if (FarseerPhysics.Settings.Epsilon > FarseerPhysics.Common.MathUtils.Area$1(Bridge.ref(FarseerPhysics.Common.Decomposition.FlipcodeDecomposer, "_tmpA"), Bridge.ref(FarseerPhysics.Common.Decomposition.FlipcodeDecomposer, "_tmpB"), Bridge.ref(FarseerPhysics.Common.Decomposition.FlipcodeDecomposer, "_tmpC"))) {
                        return false;
                    }

                    for (var p = 0; p < n; p = (p + 1) | 0) {
                        if ((p === u) || (p === v) || (p === w)) {
                            continue;
                        }

                        var point = { v : contour.getItem(V[System.Array.index(p, V)]).$clone() };

                        if (FarseerPhysics.Common.Decomposition.FlipcodeDecomposer.InsideTriangle(Bridge.ref(FarseerPhysics.Common.Decomposition.FlipcodeDecomposer, "_tmpA"), Bridge.ref(FarseerPhysics.Common.Decomposition.FlipcodeDecomposer, "_tmpB"), Bridge.ref(FarseerPhysics.Common.Decomposition.FlipcodeDecomposer, "_tmpC"), point)) {
                            return false;
                        }
                    }

                    return true;
                },
                /**
                 * Decompose the polygon into triangles
                 *
                 * @static
                 * @public
                 * @this FarseerPhysics.Common.Decomposition.FlipcodeDecomposer
                 * @memberof FarseerPhysics.Common.Decomposition.FlipcodeDecomposer
                 * @param   {FarseerPhysics.Common.Vertices}       contour    The list of points describing the polygon
                 * @return  {System.Collections.Generic.List$1}
                 */
                ConvexPartition: function (contour) {
                    var n = contour.Count;
                    if (n < 3) {
                        return new (System.Collections.Generic.List$1(FarseerPhysics.Common.Vertices)).ctor();
                    }

                    var V = System.Array.init(n, 0, System.Int32);

                    if (contour.IsCounterClockWise()) {
                        for (var v = 0; v < n; v = (v + 1) | 0) {
                            V[System.Array.index(v, V)] = v;
                        }
                    } else {
                        for (var v1 = 0; v1 < n; v1 = (v1 + 1) | 0) {
                            V[System.Array.index(v1, V)] = ((((n - 1) | 0)) - v1) | 0;
                        }
                    }

                    var nv = n;

                    var count = Bridge.Int.mul(2, nv); /* error detection */

                    var result = new (System.Collections.Generic.List$1(FarseerPhysics.Common.Vertices)).ctor();

                    for (var v2 = (nv - 1) | 0; nv > 2; ) {
                        if (0 >= (Bridge.identity(count, (count = (count - 1) | 0)))) {
                            return new (System.Collections.Generic.List$1(FarseerPhysics.Common.Vertices)).ctor();
                        }

                        var u = v2;
                        if (nv <= u) {
                            u = 0;
                        }
                        v2 = (u + 1) | 0;
                        if (nv <= v2) {
                            v2 = 0;
                        }
                        var w = (v2 + 1) | 0;
                        if (nv <= w) {
                            w = 0;
                        }

                        FarseerPhysics.Common.Decomposition.FlipcodeDecomposer._tmpA = contour.getItem(V[System.Array.index(u, V)]).$clone();
                        FarseerPhysics.Common.Decomposition.FlipcodeDecomposer._tmpB = contour.getItem(V[System.Array.index(v2, V)]).$clone();
                        FarseerPhysics.Common.Decomposition.FlipcodeDecomposer._tmpC = contour.getItem(V[System.Array.index(w, V)]).$clone();

                        if (FarseerPhysics.Common.Decomposition.FlipcodeDecomposer.Snip(contour, u, v2, w, nv, V)) {
                            var s, t;

                            var triangle = new FarseerPhysics.Common.Vertices.$ctor3(3);
                            triangle.add(FarseerPhysics.Common.Decomposition.FlipcodeDecomposer._tmpA.$clone());
                            triangle.add(FarseerPhysics.Common.Decomposition.FlipcodeDecomposer._tmpB.$clone());
                            triangle.add(FarseerPhysics.Common.Decomposition.FlipcodeDecomposer._tmpC.$clone());
                            result.add(triangle);

                            for (s = v2, t = (v2 + 1) | 0; t < nv; s = (s + 1) | 0, t = (t + 1) | 0) {
                                V[System.Array.index(s, V)] = V[System.Array.index(t, V)];
                            }
                            nv = (nv - 1) | 0;

                            count = Bridge.Int.mul(2, nv);
                        }
                    }

                    return result;
                }
            }
        }
    });

    Bridge.define("FarseerPhysics.Common.Decomposition.MonotoneMountain", {
        statics: {
            fields: {
                PiSlop: 0
            },
            ctors: {
                init: function () {
                    this.PiSlop = 3.1;
                }
            }
        },
        fields: {
            Triangles: null,
            _convexPoints: null,
            _head: null,
            _monoPoly: null,
            _positive: false,
            _size: 0,
            _tail: null
        },
        ctors: {
            ctor: function () {
                this.$initialize();
                this._size = 0;
                this._tail = null;
                this._head = null;
                this._positive = false;
                this._convexPoints = new (System.Collections.Generic.HashSet$1(FarseerPhysics.Common.Decomposition.Point)).ctor();
                this._monoPoly = new (System.Collections.Generic.List$1(FarseerPhysics.Common.Decomposition.Point)).ctor();
                this.Triangles = new (System.Collections.Generic.List$1(System.Collections.Generic.List$1(FarseerPhysics.Common.Decomposition.Point))).ctor();
            }
        },
        methods: {
            Add: function (point) {
                if (this._size === 0) {
                    this._head = point;
                    this._size = 1;
                } else if (this._size === 1) {
                    this._tail = point;
                    this._tail.Prev = this._head;
                    this._head.Next = this._tail;
                    this._size = 2;
                } else {
                    this._tail.Next = point;
                    point.Prev = this._tail;
                    this._tail = point;
                    this._size = (this._size + 1) | 0;
                }
            },
            Remove: function (point) {
                var next = point.Next;
                var prev = point.Prev;
                point.Prev.Next = next;
                point.Next.Prev = prev;
                this._size = (this._size - 1) | 0;
            },
            Process: function () {
                this._positive = this.AngleSign();
                this.GenMonoPoly();

                var p = this._head.Next;
                while (p.Neq(this._tail)) {
                    var a = this.Angle(p);
                    if (a >= FarseerPhysics.Common.Decomposition.MonotoneMountain.PiSlop || a <= -3.1 || a === 0.0) {
                        this.Remove(p);
                    } else {
                        if (this.IsConvex(p)) {
                            this._convexPoints.add(p);
                        }
                    }
                    p = p.Next;
                }

                this.Triangulate();
            },
            Triangulate: function () {
                while (this._convexPoints.Count !== 0) {
                    var e = this._convexPoints.GetEnumerator().$clone();
                    e.System$Collections$IEnumerator$moveNext();
                    var ear = e[Bridge.geti(e, "System$Collections$Generic$IEnumerator$1$FarseerPhysics$Common$Decomposition$Point$Current$1", "System$Collections$Generic$IEnumerator$1$Current$1")];

                    this._convexPoints.remove(ear);
                    var a = ear.Prev;
                    var b = ear;
                    var c = ear.Next;
                    var triangle = new (System.Collections.Generic.List$1(FarseerPhysics.Common.Decomposition.Point)).$ctor2(3);
                    triangle.add(a);
                    triangle.add(b);
                    triangle.add(c);

                    this.Triangles.add(triangle);

                    this.Remove(ear);
                    if (this.Valid(a)) {
                        this._convexPoints.add(a);
                    }
                    if (this.Valid(c)) {
                        this._convexPoints.add(c);
                    }
                }

                System.Diagnostics.Debug.Assert$1(this._size <= 3, "Triangulation bug, please report");
            },
            Valid: function (p) {
                return p.Neq(this._head) && p.Neq(this._tail) && this.IsConvex(p);
            },
            GenMonoPoly: function () {
                var p = this._head;
                while (p != null) {
                    this._monoPoly.add(p);
                    p = p.Next;
                }
            },
            Angle: function (p) {
                var a = (FarseerPhysics.Common.Decomposition.Point.op_Subtraction(p.Next, p));
                var b = (FarseerPhysics.Common.Decomposition.Point.op_Subtraction(p.Prev, p));
                return Math.atan2(a.Cross(b), a.Dot(b));
            },
            AngleSign: function () {
                var a = (FarseerPhysics.Common.Decomposition.Point.op_Subtraction(this._head.Next, this._head));
                var b = (FarseerPhysics.Common.Decomposition.Point.op_Subtraction(this._tail, this._head));
                return Math.atan2(a.Cross(b), a.Dot(b)) >= 0;
            },
            IsConvex: function (p) {
                if (this._positive !== (this.Angle(p) >= 0)) {
                    return false;
                }
                return true;
            }
        }
    });

    Bridge.define("FarseerPhysics.Common.Decomposition.Node", {
        fields: {
            LeftChild: null,
            ParentList: null,
            RightChild: null
        },
        ctors: {
            ctor: function (left, right) {
                this.$initialize();
                this.ParentList = new (System.Collections.Generic.List$1(FarseerPhysics.Common.Decomposition.Node)).ctor();
                this.LeftChild = left;
                this.RightChild = right;

                if (left != null) {
                    left.ParentList.add(this);
                }
                if (right != null) {
                    right.ParentList.add(this);
                }
            }
        },
        methods: {
            Replace: function (node) {
                var $t;
                $t = Bridge.getEnumerator(node.ParentList);
                try {
                    while ($t.moveNext()) {
                        var parent = $t.Current;
                        if (Bridge.referenceEquals(parent.LeftChild, node)) {
                            parent.LeftChild = this;
                        } else {
                            parent.RightChild = this;
                        }
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }this.ParentList.AddRange(node.ParentList);
            }
        }
    });

    Bridge.define("FarseerPhysics.Common.Decomposition.Point", {
        statics: {
            methods: {
                op_Subtraction: function (p1, p2) {
                    return new FarseerPhysics.Common.Decomposition.Point(p1.X - p2.X, p1.Y - p2.Y);
                },
                op_Subtraction$1: function (p1, f) {
                    return new FarseerPhysics.Common.Decomposition.Point(p1.X - f, p1.Y - f);
                },
                op_Addition: function (p1, p2) {
                    return new FarseerPhysics.Common.Decomposition.Point(p1.X + p2.X, p1.Y + p2.Y);
                },
                op_Addition$1: function (p1, f) {
                    return new FarseerPhysics.Common.Decomposition.Point(p1.X + f, p1.Y + f);
                }
            }
        },
        fields: {
            Next: null,
            Prev: null,
            X: 0,
            Y: 0
        },
        ctors: {
            ctor: function (x, y) {
                this.$initialize();
                this.X = x;
                this.Y = y;
                this.Next = null;
                this.Prev = null;
            }
        },
        methods: {
            Cross: function (p) {
                return this.X * p.Y - this.Y * p.X;
            },
            Dot: function (p) {
                return this.X * p.X + this.Y * p.Y;
            },
            Neq: function (p) {
                return p.X !== this.X || p.Y !== this.Y;
            },
            Orient2D: function (pb, pc) {
                var acx = this.X - pc.X;
                var bcx = pb.X - pc.X;
                var acy = this.Y - pc.Y;
                var bcy = pb.Y - pc.Y;
                return acx * bcy - acy * bcx;
            }
        }
    });

    Bridge.define("FarseerPhysics.Common.Decomposition.QueryGraph", {
        fields: {
            _head: null
        },
        ctors: {
            ctor: function (head) {
                this.$initialize();
                this._head = head;
            }
        },
        methods: {
            Locate: function (edge) {
                return this._head.Locate(edge).Trapezoid;
            },
            FollowEdge: function (edge) {
                var trapezoids = new (System.Collections.Generic.List$1(FarseerPhysics.Common.Decomposition.Trapezoid)).ctor();
                trapezoids.add(this.Locate(edge));
                var j = 0;

                while (edge.Q.X > trapezoids.getItem(j).RightPoint.X) {
                    if (edge.IsAbove(trapezoids.getItem(j).RightPoint)) {
                        trapezoids.add(trapezoids.getItem(j).UpperRight);
                    } else {
                        trapezoids.add(trapezoids.getItem(j).LowerRight);
                    }
                    j = (j + 1) | 0;
                }
                return trapezoids;
            },
            Replace: function (sink, node) {
                if (sink.ParentList.Count === 0) {
                    this._head = node;
                } else {
                    node.Replace(sink);
                }
            },
            Case1: function (sink, edge, tList) {
                var yNode = new FarseerPhysics.Common.Decomposition.YNode(edge, FarseerPhysics.Common.Decomposition.Sink.Isink(tList[System.Array.index(1, tList)]), FarseerPhysics.Common.Decomposition.Sink.Isink(tList[System.Array.index(2, tList)]));
                var qNode = new FarseerPhysics.Common.Decomposition.XNode(edge.Q, yNode, FarseerPhysics.Common.Decomposition.Sink.Isink(tList[System.Array.index(3, tList)]));
                var pNode = new FarseerPhysics.Common.Decomposition.XNode(edge.P, FarseerPhysics.Common.Decomposition.Sink.Isink(tList[System.Array.index(0, tList)]), qNode);
                this.Replace(sink, pNode);
            },
            Case2: function (sink, edge, tList) {
                var yNode = new FarseerPhysics.Common.Decomposition.YNode(edge, FarseerPhysics.Common.Decomposition.Sink.Isink(tList[System.Array.index(1, tList)]), FarseerPhysics.Common.Decomposition.Sink.Isink(tList[System.Array.index(2, tList)]));
                var pNode = new FarseerPhysics.Common.Decomposition.XNode(edge.P, FarseerPhysics.Common.Decomposition.Sink.Isink(tList[System.Array.index(0, tList)]), yNode);
                this.Replace(sink, pNode);
            },
            Case3: function (sink, edge, tList) {
                var yNode = new FarseerPhysics.Common.Decomposition.YNode(edge, FarseerPhysics.Common.Decomposition.Sink.Isink(tList[System.Array.index(0, tList)]), FarseerPhysics.Common.Decomposition.Sink.Isink(tList[System.Array.index(1, tList)]));
                this.Replace(sink, yNode);
            },
            Case4: function (sink, edge, tList) {
                var yNode = new FarseerPhysics.Common.Decomposition.YNode(edge, FarseerPhysics.Common.Decomposition.Sink.Isink(tList[System.Array.index(0, tList)]), FarseerPhysics.Common.Decomposition.Sink.Isink(tList[System.Array.index(1, tList)]));
                var qNode = new FarseerPhysics.Common.Decomposition.XNode(edge.Q, yNode, FarseerPhysics.Common.Decomposition.Sink.Isink(tList[System.Array.index(2, tList)]));
                this.Replace(sink, qNode);
            }
        }
    });

    /**
     * Convex decomposition algorithm based on Raimund Seidel's paper "A simple and fast incremental randomized
     algorithm for computing trapezoidal decompositions and for triangulating polygons"
     See also: "Computational Geometry", 3rd edition, by Mark de Berg et al, Chapter 6.2
               "Computational Geometry in C", 2nd edition, by Joseph O'Rourke
     *
     * @static
     * @abstract
     * @public
     * @class FarseerPhysics.Common.Decomposition.SeidelDecomposer
     */
    Bridge.define("FarseerPhysics.Common.Decomposition.SeidelDecomposer", {
        statics: {
            methods: {
                /**
                 * Decompose the polygon into several smaller non-concave polygon.
                 *
                 * @static
                 * @public
                 * @this FarseerPhysics.Common.Decomposition.SeidelDecomposer
                 * @memberof FarseerPhysics.Common.Decomposition.SeidelDecomposer
                 * @param   {FarseerPhysics.Common.Vertices}       vertices    The polygon to decompose.
                 * @param   {number}                               sheer       The sheer to use. If you get bad results, try using a higher value. The default value is 0.001
                 * @return  {System.Collections.Generic.List$1}                A list of triangles
                 */
                ConvexPartition: function (vertices, sheer) {
                    var $t, $t1, $t2;
                    var compatList = new (System.Collections.Generic.List$1(FarseerPhysics.Common.Decomposition.Point)).$ctor2(vertices.Count);

                    $t = Bridge.getEnumerator(vertices);
                    try {
                        while ($t.moveNext()) {
                            var vertex = $t.Current.$clone();
                            compatList.add(new FarseerPhysics.Common.Decomposition.Point(vertex.X, vertex.Y));
                        }
                    } finally {
                        if (Bridge.is($t, System.IDisposable)) {
                            $t.System$IDisposable$Dispose();
                        }
                    }
                    var t = new FarseerPhysics.Common.Decomposition.Triangulator(compatList, sheer);

                    var list = new (System.Collections.Generic.List$1(FarseerPhysics.Common.Vertices)).ctor();

                    $t1 = Bridge.getEnumerator(t.Triangles);
                    try {
                        while ($t1.moveNext()) {
                            var triangle = $t1.Current;
                            var verts = new FarseerPhysics.Common.Vertices.$ctor3(triangle.Count);

                            $t2 = Bridge.getEnumerator(triangle);
                            try {
                                while ($t2.moveNext()) {
                                    var point = $t2.Current;
                                    verts.add(new Microsoft.Xna.Framework.Vector2.$ctor2(point.X, point.Y));
                                }
                            } finally {
                                if (Bridge.is($t2, System.IDisposable)) {
                                    $t2.System$IDisposable$Dispose();
                                }
                            }
                            list.add(verts);
                        }
                    } finally {
                        if (Bridge.is($t1, System.IDisposable)) {
                            $t1.System$IDisposable$Dispose();
                        }
                    }
                    return list;
                },
                /**
                 * Decompose the polygon into several smaller non-concave polygon.
                 *
                 * @static
                 * @public
                 * @this FarseerPhysics.Common.Decomposition.SeidelDecomposer
                 * @memberof FarseerPhysics.Common.Decomposition.SeidelDecomposer
                 * @param   {FarseerPhysics.Common.Vertices}       vertices    The polygon to decompose.
                 * @param   {number}                               sheer       The sheer to use. If you get bad results, try using a higher value. The default value is 0.001
                 * @return  {System.Collections.Generic.List$1}                A list of trapezoids
                 */
                ConvexPartitionTrapezoid: function (vertices, sheer) {
                    var $t, $t1, $t2;
                    var compatList = new (System.Collections.Generic.List$1(FarseerPhysics.Common.Decomposition.Point)).$ctor2(vertices.Count);

                    $t = Bridge.getEnumerator(vertices);
                    try {
                        while ($t.moveNext()) {
                            var vertex = $t.Current.$clone();
                            compatList.add(new FarseerPhysics.Common.Decomposition.Point(vertex.X, vertex.Y));
                        }
                    } finally {
                        if (Bridge.is($t, System.IDisposable)) {
                            $t.System$IDisposable$Dispose();
                        }
                    }
                    var t = new FarseerPhysics.Common.Decomposition.Triangulator(compatList, sheer);

                    var list = new (System.Collections.Generic.List$1(FarseerPhysics.Common.Vertices)).ctor();

                    $t1 = Bridge.getEnumerator(t.Trapezoids);
                    try {
                        while ($t1.moveNext()) {
                            var trapezoid = $t1.Current;
                            var verts = new FarseerPhysics.Common.Vertices.ctor();

                            var points = trapezoid.Vertices();
                            $t2 = Bridge.getEnumerator(points);
                            try {
                                while ($t2.moveNext()) {
                                    var point = $t2.Current;
                                    verts.add(new Microsoft.Xna.Framework.Vector2.$ctor2(point.X, point.Y));
                                }
                            } finally {
                                if (Bridge.is($t2, System.IDisposable)) {
                                    $t2.System$IDisposable$Dispose();
                                }
                            }
                            list.add(verts);
                        }
                    } finally {
                        if (Bridge.is($t1, System.IDisposable)) {
                            $t1.System$IDisposable$Dispose();
                        }
                    }
                    return list;
                }
            }
        }
    });

    Bridge.define("FarseerPhysics.Common.Decomposition.Trapezoid", {
        fields: {
            Bottom: null,
            Inside: false,
            LeftPoint: null,
            LowerLeft: null,
            LowerRight: null,
            RightPoint: null,
            Sink: null,
            Top: null,
            UpperLeft: null,
            UpperRight: null
        },
        ctors: {
            ctor: function (leftPoint, rightPoint, top, bottom) {
                this.$initialize();
                this.LeftPoint = leftPoint;
                this.RightPoint = rightPoint;
                this.Top = top;
                this.Bottom = bottom;
                this.UpperLeft = null;
                this.UpperRight = null;
                this.LowerLeft = null;
                this.LowerRight = null;
                this.Inside = true;
                this.Sink = null;
            }
        },
        methods: {
            UpdateLeft: function (ul, ll) {
                this.UpperLeft = ul;
                if (ul != null) {
                    ul.UpperRight = this;
                }
                this.LowerLeft = ll;
                if (ll != null) {
                    ll.LowerRight = this;
                }
            },
            UpdateRight: function (ur, lr) {
                this.UpperRight = ur;
                if (ur != null) {
                    ur.UpperLeft = this;
                }
                this.LowerRight = lr;
                if (lr != null) {
                    lr.LowerLeft = this;
                }
            },
            UpdateLeftRight: function (ul, ll, ur, lr) {
                this.UpperLeft = ul;
                if (ul != null) {
                    ul.UpperRight = this;
                }
                this.LowerLeft = ll;
                if (ll != null) {
                    ll.LowerRight = this;
                }
                this.UpperRight = ur;
                if (ur != null) {
                    ur.UpperLeft = this;
                }
                this.LowerRight = lr;
                if (lr != null) {
                    lr.LowerLeft = this;
                }
            },
            TrimNeighbors: function () {
                if (this.Inside) {
                    this.Inside = false;
                    if (this.UpperLeft != null) {
                        this.UpperLeft.TrimNeighbors();
                    }
                    if (this.LowerLeft != null) {
                        this.LowerLeft.TrimNeighbors();
                    }
                    if (this.UpperRight != null) {
                        this.UpperRight.TrimNeighbors();
                    }
                    if (this.LowerRight != null) {
                        this.LowerRight.TrimNeighbors();
                    }
                }
            },
            Contains: function (point) {
                return (point.X > this.LeftPoint.X && point.X < this.RightPoint.X && this.Top.IsAbove(point) && this.Bottom.IsBelow(point));
            },
            Vertices: function () {
                var verts = new (System.Collections.Generic.List$1(FarseerPhysics.Common.Decomposition.Point)).$ctor2(4);
                verts.add(this.LineIntersect(this.Top, this.LeftPoint.X));
                verts.add(this.LineIntersect(this.Bottom, this.LeftPoint.X));
                verts.add(this.LineIntersect(this.Bottom, this.RightPoint.X));
                verts.add(this.LineIntersect(this.Top, this.RightPoint.X));
                return verts;
            },
            LineIntersect: function (edge, x) {
                var y = edge.Slope * x + edge.B;
                return new FarseerPhysics.Common.Decomposition.Point(x, y);
            },
            AddPoints: function () {
                if (!Bridge.referenceEquals(this.LeftPoint, this.Bottom.P)) {
                    this.Bottom.AddMpoint(this.LeftPoint);
                }
                if (!Bridge.referenceEquals(this.RightPoint, this.Bottom.Q)) {
                    this.Bottom.AddMpoint(this.RightPoint);
                }
                if (!Bridge.referenceEquals(this.LeftPoint, this.Top.P)) {
                    this.Top.AddMpoint(this.LeftPoint);
                }
                if (!Bridge.referenceEquals(this.RightPoint, this.Top.Q)) {
                    this.Top.AddMpoint(this.RightPoint);
                }
            }
        }
    });

    Bridge.define("FarseerPhysics.Common.Decomposition.TrapezoidalMap", {
        fields: {
            Map: null,
            _bCross: null,
            _cross: null,
            _margin: 0
        },
        ctors: {
            ctor: function () {
                this.$initialize();
                this.Map = new (System.Collections.Generic.HashSet$1(FarseerPhysics.Common.Decomposition.Trapezoid)).ctor();
                this._margin = 50.0;
                this._bCross = null;
                this._cross = null;
            }
        },
        methods: {
            Clear: function () {
                this._bCross = null;
                this._cross = null;
            },
            Case1: function (t, e) {
                var trapezoids = System.Array.init(4, null, FarseerPhysics.Common.Decomposition.Trapezoid);
                trapezoids[System.Array.index(0, trapezoids)] = new FarseerPhysics.Common.Decomposition.Trapezoid(t.LeftPoint, e.P, t.Top, t.Bottom);
                trapezoids[System.Array.index(1, trapezoids)] = new FarseerPhysics.Common.Decomposition.Trapezoid(e.P, e.Q, t.Top, e);
                trapezoids[System.Array.index(2, trapezoids)] = new FarseerPhysics.Common.Decomposition.Trapezoid(e.P, e.Q, e, t.Bottom);
                trapezoids[System.Array.index(3, trapezoids)] = new FarseerPhysics.Common.Decomposition.Trapezoid(e.Q, t.RightPoint, t.Top, t.Bottom);

                trapezoids[System.Array.index(0, trapezoids)].UpdateLeft(t.UpperLeft, t.LowerLeft);
                trapezoids[System.Array.index(1, trapezoids)].UpdateLeftRight(trapezoids[System.Array.index(0, trapezoids)], null, trapezoids[System.Array.index(3, trapezoids)], null);
                trapezoids[System.Array.index(2, trapezoids)].UpdateLeftRight(null, trapezoids[System.Array.index(0, trapezoids)], null, trapezoids[System.Array.index(3, trapezoids)]);
                trapezoids[System.Array.index(3, trapezoids)].UpdateRight(t.UpperRight, t.LowerRight);

                return trapezoids;
            },
            Case2: function (t, e) {
                var rp;
                if (e.Q.X === t.RightPoint.X) {
                    rp = e.Q;
                } else {
                    rp = t.RightPoint;
                }

                var trapezoids = System.Array.init(3, null, FarseerPhysics.Common.Decomposition.Trapezoid);
                trapezoids[System.Array.index(0, trapezoids)] = new FarseerPhysics.Common.Decomposition.Trapezoid(t.LeftPoint, e.P, t.Top, t.Bottom);
                trapezoids[System.Array.index(1, trapezoids)] = new FarseerPhysics.Common.Decomposition.Trapezoid(e.P, rp, t.Top, e);
                trapezoids[System.Array.index(2, trapezoids)] = new FarseerPhysics.Common.Decomposition.Trapezoid(e.P, rp, e, t.Bottom);

                trapezoids[System.Array.index(0, trapezoids)].UpdateLeft(t.UpperLeft, t.LowerLeft);
                trapezoids[System.Array.index(1, trapezoids)].UpdateLeftRight(trapezoids[System.Array.index(0, trapezoids)], null, t.UpperRight, null);
                trapezoids[System.Array.index(2, trapezoids)].UpdateLeftRight(null, trapezoids[System.Array.index(0, trapezoids)], null, t.LowerRight);

                this._bCross = t.Bottom;
                this._cross = t.Top;

                e.Above = trapezoids[System.Array.index(1, trapezoids)];
                e.Below = trapezoids[System.Array.index(2, trapezoids)];

                return trapezoids;
            },
            Case3: function (t, e) {
                var lp;
                if (e.P.X === t.LeftPoint.X) {
                    lp = e.P;
                } else {
                    lp = t.LeftPoint;
                }

                var rp;
                if (e.Q.X === t.RightPoint.X) {
                    rp = e.Q;
                } else {
                    rp = t.RightPoint;
                }

                var trapezoids = System.Array.init(2, null, FarseerPhysics.Common.Decomposition.Trapezoid);

                if (Bridge.referenceEquals(this._cross, t.Top)) {
                    trapezoids[System.Array.index(0, trapezoids)] = t.UpperLeft;
                    trapezoids[System.Array.index(0, trapezoids)].UpdateRight(t.UpperRight, null);
                    trapezoids[System.Array.index(0, trapezoids)].RightPoint = rp;
                } else {
                    trapezoids[System.Array.index(0, trapezoids)] = new FarseerPhysics.Common.Decomposition.Trapezoid(lp, rp, t.Top, e);
                    trapezoids[System.Array.index(0, trapezoids)].UpdateLeftRight(t.UpperLeft, e.Above, t.UpperRight, null);
                }

                if (Bridge.referenceEquals(this._bCross, t.Bottom)) {
                    trapezoids[System.Array.index(1, trapezoids)] = t.LowerLeft;
                    trapezoids[System.Array.index(1, trapezoids)].UpdateRight(null, t.LowerRight);
                    trapezoids[System.Array.index(1, trapezoids)].RightPoint = rp;
                } else {
                    trapezoids[System.Array.index(1, trapezoids)] = new FarseerPhysics.Common.Decomposition.Trapezoid(lp, rp, e, t.Bottom);
                    trapezoids[System.Array.index(1, trapezoids)].UpdateLeftRight(e.Below, t.LowerLeft, null, t.LowerRight);
                }

                this._bCross = t.Bottom;
                this._cross = t.Top;

                e.Above = trapezoids[System.Array.index(0, trapezoids)];
                e.Below = trapezoids[System.Array.index(1, trapezoids)];

                return trapezoids;
            },
            Case4: function (t, e) {
                var lp;
                if (e.P.X === t.LeftPoint.X) {
                    lp = e.P;
                } else {
                    lp = t.LeftPoint;
                }

                var trapezoids = System.Array.init(3, null, FarseerPhysics.Common.Decomposition.Trapezoid);

                if (Bridge.referenceEquals(this._cross, t.Top)) {
                    trapezoids[System.Array.index(0, trapezoids)] = t.UpperLeft;
                    trapezoids[System.Array.index(0, trapezoids)].RightPoint = e.Q;
                } else {
                    trapezoids[System.Array.index(0, trapezoids)] = new FarseerPhysics.Common.Decomposition.Trapezoid(lp, e.Q, t.Top, e);
                    trapezoids[System.Array.index(0, trapezoids)].UpdateLeft(t.UpperLeft, e.Above);
                }

                if (Bridge.referenceEquals(this._bCross, t.Bottom)) {
                    trapezoids[System.Array.index(1, trapezoids)] = t.LowerLeft;
                    trapezoids[System.Array.index(1, trapezoids)].RightPoint = e.Q;
                } else {
                    trapezoids[System.Array.index(1, trapezoids)] = new FarseerPhysics.Common.Decomposition.Trapezoid(lp, e.Q, e, t.Bottom);
                    trapezoids[System.Array.index(1, trapezoids)].UpdateLeft(e.Below, t.LowerLeft);
                }

                trapezoids[System.Array.index(2, trapezoids)] = new FarseerPhysics.Common.Decomposition.Trapezoid(e.Q, t.RightPoint, t.Top, t.Bottom);
                trapezoids[System.Array.index(2, trapezoids)].UpdateLeftRight(trapezoids[System.Array.index(0, trapezoids)], trapezoids[System.Array.index(1, trapezoids)], t.UpperRight, t.LowerRight);

                return trapezoids;
            },
            BoundingBox: function (edges) {
                var $t;
                var max = FarseerPhysics.Common.Decomposition.Point.op_Addition$1(edges.getItem(0).P, this._margin);
                var min = FarseerPhysics.Common.Decomposition.Point.op_Subtraction$1(edges.getItem(0).Q, this._margin);

                $t = Bridge.getEnumerator(edges);
                try {
                    while ($t.moveNext()) {
                        var e = $t.Current;
                        if (e.P.X > max.X) {
                            max = new FarseerPhysics.Common.Decomposition.Point(e.P.X + this._margin, max.Y);
                        }
                        if (e.P.Y > max.Y) {
                            max = new FarseerPhysics.Common.Decomposition.Point(max.X, e.P.Y + this._margin);
                        }
                        if (e.Q.X > max.X) {
                            max = new FarseerPhysics.Common.Decomposition.Point(e.Q.X + this._margin, max.Y);
                        }
                        if (e.Q.Y > max.Y) {
                            max = new FarseerPhysics.Common.Decomposition.Point(max.X, e.Q.Y + this._margin);
                        }
                        if (e.P.X < min.X) {
                            min = new FarseerPhysics.Common.Decomposition.Point(e.P.X - this._margin, min.Y);
                        }
                        if (e.P.Y < min.Y) {
                            min = new FarseerPhysics.Common.Decomposition.Point(min.X, e.P.Y - this._margin);
                        }
                        if (e.Q.X < min.X) {
                            min = new FarseerPhysics.Common.Decomposition.Point(e.Q.X - this._margin, min.Y);
                        }
                        if (e.Q.Y < min.Y) {
                            min = new FarseerPhysics.Common.Decomposition.Point(min.X, e.Q.Y - this._margin);
                        }
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }
                var top = new FarseerPhysics.Common.Decomposition.Edge(new FarseerPhysics.Common.Decomposition.Point(min.X, max.Y), new FarseerPhysics.Common.Decomposition.Point(max.X, max.Y));
                var bottom = new FarseerPhysics.Common.Decomposition.Edge(new FarseerPhysics.Common.Decomposition.Point(min.X, min.Y), new FarseerPhysics.Common.Decomposition.Point(max.X, min.Y));
                var left = bottom.P;
                var right = top.Q;

                return new FarseerPhysics.Common.Decomposition.Trapezoid(left, right, top, bottom);
            }
        }
    });

    Bridge.define("FarseerPhysics.Common.Decomposition.Triangle", {
        fields: {
            X: null,
            Y: null
        },
        ctors: {
            $ctor1: function (x1, y1, x2, y2, x3, y3) {
                this.$initialize();
                this.X = System.Array.init(3, 0, System.Single);
                this.Y = System.Array.init(3, 0, System.Single);
                var dx1 = x2 - x1;
                var dx2 = x3 - x1;
                var dy1 = y2 - y1;
                var dy2 = y3 - y1;
                var cross = dx1 * dy2 - dx2 * dy1;
                var ccw = (cross > 0);
                if (ccw) {
                    this.X[System.Array.index(0, this.X)] = x1;
                    this.X[System.Array.index(1, this.X)] = x2;
                    this.X[System.Array.index(2, this.X)] = x3;
                    this.Y[System.Array.index(0, this.Y)] = y1;
                    this.Y[System.Array.index(1, this.Y)] = y2;
                    this.Y[System.Array.index(2, this.Y)] = y3;
                } else {
                    this.X[System.Array.index(0, this.X)] = x1;
                    this.X[System.Array.index(1, this.X)] = x3;
                    this.X[System.Array.index(2, this.X)] = x2;
                    this.Y[System.Array.index(0, this.Y)] = y1;
                    this.Y[System.Array.index(1, this.Y)] = y3;
                    this.Y[System.Array.index(2, this.Y)] = y2;
                }
            },
            ctor: function (t) {
                this.$initialize();
                this.X = System.Array.init(3, 0, System.Single);
                this.Y = System.Array.init(3, 0, System.Single);

                this.X[System.Array.index(0, this.X)] = t.X[System.Array.index(0, t.X)];
                this.X[System.Array.index(1, this.X)] = t.X[System.Array.index(1, t.X)];
                this.X[System.Array.index(2, this.X)] = t.X[System.Array.index(2, t.X)];
                this.Y[System.Array.index(0, this.Y)] = t.Y[System.Array.index(0, t.Y)];
                this.Y[System.Array.index(1, this.Y)] = t.Y[System.Array.index(1, t.Y)];
                this.Y[System.Array.index(2, this.Y)] = t.Y[System.Array.index(2, t.Y)];
            }
        },
        methods: {
            IsInside: function (x, y) {
                if (x < this.X[System.Array.index(0, this.X)] && x < this.X[System.Array.index(1, this.X)] && x < this.X[System.Array.index(2, this.X)]) {
                    return false;
                }
                if (x > this.X[System.Array.index(0, this.X)] && x > this.X[System.Array.index(1, this.X)] && x > this.X[System.Array.index(2, this.X)]) {
                    return false;
                }
                if (y < this.Y[System.Array.index(0, this.Y)] && y < this.Y[System.Array.index(1, this.Y)] && y < this.Y[System.Array.index(2, this.Y)]) {
                    return false;
                }
                if (y > this.Y[System.Array.index(0, this.Y)] && y > this.Y[System.Array.index(1, this.Y)] && y > this.Y[System.Array.index(2, this.Y)]) {
                    return false;
                }

                var vx2 = x - this.X[System.Array.index(0, this.X)];
                var vy2 = y - this.Y[System.Array.index(0, this.Y)];
                var vx1 = this.X[System.Array.index(1, this.X)] - this.X[System.Array.index(0, this.X)];
                var vy1 = this.Y[System.Array.index(1, this.Y)] - this.Y[System.Array.index(0, this.Y)];
                var vx0 = this.X[System.Array.index(2, this.X)] - this.X[System.Array.index(0, this.X)];
                var vy0 = this.Y[System.Array.index(2, this.Y)] - this.Y[System.Array.index(0, this.Y)];

                var dot00 = vx0 * vx0 + vy0 * vy0;
                var dot01 = vx0 * vx1 + vy0 * vy1;
                var dot02 = vx0 * vx2 + vy0 * vy2;
                var dot11 = vx1 * vx1 + vy1 * vy1;
                var dot12 = vx1 * vx2 + vy1 * vy2;
                var invDenom = 1.0 / (dot00 * dot11 - dot01 * dot01);
                var u = (dot11 * dot02 - dot01 * dot12) * invDenom;
                var v = (dot00 * dot12 - dot01 * dot02) * invDenom;

                return ((u > 0) && (v > 0) && (u + v < 1));
            }
        }
    });

    Bridge.define("FarseerPhysics.Common.Decomposition.Triangulator", {
        statics: {
            methods: {
                Shuffle: function (T, list) {
                    var rng = new System.Random.ctor();
                    var n = System.Array.getCount(list, T);
                    while (n > 1) {
                        n = (n - 1) | 0;
                        var k = rng.Next$1(((n + 1) | 0));
                        var value = System.Array.getItem(list, k, T);
                        System.Array.setItem(list, k, System.Array.getItem(list, n, T), T);
                        System.Array.setItem(list, n, value, T);
                    }
                }
            }
        },
        fields: {
            Trapezoids: null,
            Triangles: null,
            _boundingBox: null,
            _edgeList: null,
            _queryGraph: null,
            _sheer: 0,
            _trapezoidalMap: null,
            _xMonoPoly: null
        },
        ctors: {
            init: function () {
                this._sheer = 0.001;
            },
            ctor: function (polyLine, sheer) {
                this.$initialize();
                this._sheer = sheer;
                this.Triangles = new (System.Collections.Generic.List$1(System.Collections.Generic.List$1(FarseerPhysics.Common.Decomposition.Point))).ctor();
                this.Trapezoids = new (System.Collections.Generic.List$1(FarseerPhysics.Common.Decomposition.Trapezoid)).ctor();
                this._xMonoPoly = new (System.Collections.Generic.List$1(FarseerPhysics.Common.Decomposition.MonotoneMountain)).ctor();
                this._edgeList = this.InitEdges(polyLine);
                this._trapezoidalMap = new FarseerPhysics.Common.Decomposition.TrapezoidalMap();
                this._boundingBox = this._trapezoidalMap.BoundingBox(this._edgeList);
                this._queryGraph = new FarseerPhysics.Common.Decomposition.QueryGraph(FarseerPhysics.Common.Decomposition.Sink.Isink(this._boundingBox));

                this.Process();
            }
        },
        methods: {
            Process: function () {
                var $t, $t1, $t2, $t3, $t4;
                $t = Bridge.getEnumerator(this._edgeList);
                try {
                    while ($t.moveNext()) {
                        var edge = $t.Current;
                        var traps = this._queryGraph.FollowEdge(edge);

                        $t1 = Bridge.getEnumerator(traps);
                        try {
                            while ($t1.moveNext()) {
                                var t = $t1.Current;
                                this._trapezoidalMap.Map.remove(t);

                                var cp = t.Contains(edge.P);
                                var cq = t.Contains(edge.Q);
                                var tList;

                                if (cp && cq) {
                                    tList = this._trapezoidalMap.Case1(t, edge);
                                    this._queryGraph.Case1(t.Sink, edge, tList);
                                } else if (cp && !cq) {
                                    tList = this._trapezoidalMap.Case2(t, edge);
                                    this._queryGraph.Case2(t.Sink, edge, tList);
                                } else if (!cp && !cq) {
                                    tList = this._trapezoidalMap.Case3(t, edge);
                                    this._queryGraph.Case3(t.Sink, edge, tList);
                                } else {
                                    tList = this._trapezoidalMap.Case4(t, edge);
                                    this._queryGraph.Case4(t.Sink, edge, tList);
                                }
                                $t2 = Bridge.getEnumerator(tList);
                                try {
                                    while ($t2.moveNext()) {
                                        var y = $t2.Current;
                                        this._trapezoidalMap.Map.add(y);
                                    }
                                } finally {
                                    if (Bridge.is($t2, System.IDisposable)) {
                                        $t2.System$IDisposable$Dispose();
                                    }
                                }
                            }
                        } finally {
                            if (Bridge.is($t1, System.IDisposable)) {
                                $t1.System$IDisposable$Dispose();
                            }
                        }this._trapezoidalMap.Clear();
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }
                $t3 = Bridge.getEnumerator(this._trapezoidalMap.Map);
                try {
                    while ($t3.moveNext()) {
                        var t1 = $t3.Current;
                        this.MarkOutside(t1);
                    }
                } finally {
                    if (Bridge.is($t3, System.IDisposable)) {
                        $t3.System$IDisposable$Dispose();
                    }
                }
                $t4 = Bridge.getEnumerator(this._trapezoidalMap.Map);
                try {
                    while ($t4.moveNext()) {
                        var t2 = $t4.Current;
                        if (t2.Inside) {
                            this.Trapezoids.add(t2);
                            t2.AddPoints();
                        }
                    }
                } finally {
                    if (Bridge.is($t4, System.IDisposable)) {
                        $t4.System$IDisposable$Dispose();
                    }
                }
                this.CreateMountains();
            },
            CreateMountains: function () {
                var $t, $t1, $t2;
                $t = Bridge.getEnumerator(this._edgeList);
                try {
                    while ($t.moveNext()) {
                        var edge = $t.Current;
                        if (edge.MPoints.Count > 2) {
                            var mountain = new FarseerPhysics.Common.Decomposition.MonotoneMountain();



                            var points = new (System.Collections.Generic.List$1(FarseerPhysics.Common.Decomposition.Point)).$ctor1(edge.MPoints);
                            points.Sort$2(function (p1, p2) {
                                return Bridge.compare(p1.X, p2.X);
                            });

                            $t1 = Bridge.getEnumerator(points);
                            try {
                                while ($t1.moveNext()) {
                                    var p = $t1.Current;
                                    mountain.Add(p);
                                }
                            } finally {
                                if (Bridge.is($t1, System.IDisposable)) {
                                    $t1.System$IDisposable$Dispose();
                                }
                            }
                            mountain.Process();

                            $t2 = Bridge.getEnumerator(mountain.Triangles);
                            try {
                                while ($t2.moveNext()) {
                                    var t = $t2.Current;
                                    this.Triangles.add(t);
                                }
                            } finally {
                                if (Bridge.is($t2, System.IDisposable)) {
                                    $t2.System$IDisposable$Dispose();
                                }
                            }
                            this._xMonoPoly.add(mountain);
                        }
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }},
            MarkOutside: function (t) {
                if (Bridge.referenceEquals(t.Top, this._boundingBox.Top) || Bridge.referenceEquals(t.Bottom, this._boundingBox.Bottom)) {
                    t.TrimNeighbors();
                }
            },
            InitEdges: function (points) {
                var edges = new (System.Collections.Generic.List$1(FarseerPhysics.Common.Decomposition.Edge)).ctor();

                for (var i = 0; i < ((points.Count - 1) | 0); i = (i + 1) | 0) {
                    edges.add(new FarseerPhysics.Common.Decomposition.Edge(points.getItem(i), points.getItem(((i + 1) | 0))));
                }
                edges.add(new FarseerPhysics.Common.Decomposition.Edge(points.getItem(0), points.getItem(((points.Count - 1) | 0))));
                return this.OrderSegments(edges);
            },
            OrderSegments: function (edgeInput) {
                var $t;
                var edges = new (System.Collections.Generic.List$1(FarseerPhysics.Common.Decomposition.Edge)).ctor();

                $t = Bridge.getEnumerator(edgeInput);
                try {
                    while ($t.moveNext()) {
                        var e = $t.Current;
                        var p = this.ShearTransform(e.P);
                        var q = this.ShearTransform(e.Q);

                        if (p.X > q.X) {
                            edges.add(new FarseerPhysics.Common.Decomposition.Edge(q, p));
                        } else if (p.X < q.X) {
                            edges.add(new FarseerPhysics.Common.Decomposition.Edge(p, q));
                        }
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }
                FarseerPhysics.Common.Decomposition.Triangulator.Shuffle(Bridge.global.FarseerPhysics.Common.Decomposition.Edge, edges);
                return edges;
            },
            ShearTransform: function (point) {
                return new FarseerPhysics.Common.Decomposition.Point(point.X + this._sheer * point.Y, point.Y);
            }
        }
    });

    Bridge.define("FarseerPhysics.Common.Vertices", {
        inherits: [System.Collections.Generic.List$1(Microsoft.Xna.Framework.Vector2)],
        ctors: {
            ctor: function () {
                this.$initialize();
                System.Collections.Generic.List$1(Microsoft.Xna.Framework.Vector2).ctor.call(this);
            },
            $ctor3: function (capacity) {
                this.$initialize();
                System.Collections.Generic.List$1(Microsoft.Xna.Framework.Vector2).ctor.call(this);
                this.Capacity = capacity;
            },
            $ctor1: function (vector2) {
                this.$initialize();
                System.Collections.Generic.List$1(Microsoft.Xna.Framework.Vector2).ctor.call(this);
                for (var i = 0; i < vector2.length; i = (i + 1) | 0) {
                    this.add(vector2[System.Array.index(i, vector2)].$clone());
                }
            },
            $ctor2: function (vertices) {
                this.$initialize();
                System.Collections.Generic.List$1(Microsoft.Xna.Framework.Vector2).ctor.call(this);
                for (var i = 0; i < System.Array.getCount(vertices, Microsoft.Xna.Framework.Vector2); i = (i + 1) | 0) {
                    this.add(System.Array.getItem(vertices, i, Microsoft.Xna.Framework.Vector2).$clone());
                }
            }
        },
        methods: {
            /**
             * Nexts the index.
             *
             * @instance
             * @public
             * @this FarseerPhysics.Common.Vertices
             * @memberof FarseerPhysics.Common.Vertices
             * @param   {number}    index    The index.
             * @return  {number}
             */
            NextIndex: function (index) {
                if (index === ((this.Count - 1) | 0)) {
                    return 0;
                }
                return ((index + 1) | 0);
            },
            NextVertex: function (index) {
                return this.getItem(this.NextIndex(index)).$clone();
            },
            /**
             * Gets the previous index.
             *
             * @instance
             * @public
             * @this FarseerPhysics.Common.Vertices
             * @memberof FarseerPhysics.Common.Vertices
             * @param   {number}    index    The index.
             * @return  {number}
             */
            PreviousIndex: function (index) {
                if (index === 0) {
                    return ((this.Count - 1) | 0);
                }
                return ((index - 1) | 0);
            },
            PreviousVertex: function (index) {
                return this.getItem(this.PreviousIndex(index)).$clone();
            },
            /**
             * Gets the signed area.
             *
             * @instance
             * @public
             * @this FarseerPhysics.Common.Vertices
             * @memberof FarseerPhysics.Common.Vertices
             * @return  {number}
             */
            GetSignedArea: function () {
                var i;
                var area = 0;

                for (i = 0; i < this.Count; i = (i + 1) | 0) {
                    var j = (((i + 1) | 0)) % this.Count;
                    area += this.getItem(i).$clone().X * this.getItem(j).$clone().Y;
                    area -= this.getItem(i).$clone().Y * this.getItem(j).$clone().X;
                }
                area /= 2.0;
                return area;
            },
            /**
             * Gets the area.
             *
             * @instance
             * @public
             * @this FarseerPhysics.Common.Vertices
             * @memberof FarseerPhysics.Common.Vertices
             * @return  {number}
             */
            GetArea: function () {
                var i;
                var area = 0;

                for (i = 0; i < this.Count; i = (i + 1) | 0) {
                    var j = (((i + 1) | 0)) % this.Count;
                    area += this.getItem(i).$clone().X * this.getItem(j).$clone().Y;
                    area -= this.getItem(i).$clone().Y * this.getItem(j).$clone().X;
                }
                area /= 2.0;
                return (area < 0 ? -area : area);
            },
            /**
             * Gets the centroid.
             *
             * @instance
             * @public
             * @this FarseerPhysics.Common.Vertices
             * @memberof FarseerPhysics.Common.Vertices
             * @return  {Microsoft.Xna.Framework.Vector2}
             */
            GetCentroid: function () {

                var c = Microsoft.Xna.Framework.Vector2.Zero.$clone();
                var area = 0.0;

                var inv3 = 0.333333343;
                var pRef = Microsoft.Xna.Framework.Vector2.Zero.$clone();
                for (var i = 0; i < this.Count; i = (i + 1) | 0) {
                    var p1 = pRef.$clone();
                    var p2 = this.getItem(i).$clone();
                    var p3 = ((i + 1) | 0) < this.Count ? this.getItem(((i + 1) | 0)).$clone() : this.getItem(0).$clone();

                    var e1 = Microsoft.Xna.Framework.Vector2.op_Subtraction(p2.$clone(), p1.$clone());
                    var e2 = Microsoft.Xna.Framework.Vector2.op_Subtraction(p3.$clone(), p1.$clone());

                    var D = FarseerPhysics.Common.MathUtils.Cross$2(e1.$clone(), e2.$clone());

                    var triangleArea = 0.5 * D;
                    area += triangleArea;

                    c = Microsoft.Xna.Framework.Vector2.op_Addition(c.$clone(), Microsoft.Xna.Framework.Vector2.op_Multiply$2(triangleArea * inv3, (Microsoft.Xna.Framework.Vector2.op_Addition(Microsoft.Xna.Framework.Vector2.op_Addition(p1.$clone(), p2.$clone()), p3.$clone()))));
                }

                c = Microsoft.Xna.Framework.Vector2.op_Multiply$1(c.$clone(), 1.0 / area);
                return c.$clone();
            },
            /**
             * Gets the radius based on area.
             *
             * @instance
             * @public
             * @this FarseerPhysics.Common.Vertices
             * @memberof FarseerPhysics.Common.Vertices
             * @return  {number}
             */
            GetRadius: function () {
                var area = this.GetSignedArea();

                var radiusSqrd = area / Microsoft.Xna.Framework.MathHelper.Pi;
                if (radiusSqrd < 0) {
                    radiusSqrd *= -1;
                }

                return Math.sqrt(radiusSqrd);
            },
            /**
             * Returns an AABB for vertex.
             *
             * @instance
             * @public
             * @this FarseerPhysics.Common.Vertices
             * @memberof FarseerPhysics.Common.Vertices
             * @return  {FarseerPhysics.Collision.AABB}
             */
            GetCollisionBox: function () {
                var aabb = new FarseerPhysics.Collision.AABB();
                var lowerBound = new Microsoft.Xna.Framework.Vector2.$ctor2(3.40282347E+38, 3.40282347E+38);
                var upperBound = new Microsoft.Xna.Framework.Vector2.$ctor2(-3.40282347E+38, -3.40282347E+38);

                for (var i = 0; i < this.Count; i = (i + 1) | 0) {
                    if (this.getItem(i).$clone().X < lowerBound.X) {
                        lowerBound.X = this.getItem(i).$clone().X;
                    }
                    if (this.getItem(i).$clone().X > upperBound.X) {
                        upperBound.X = this.getItem(i).$clone().X;
                    }

                    if (this.getItem(i).$clone().Y < lowerBound.Y) {
                        lowerBound.Y = this.getItem(i).$clone().Y;
                    }
                    if (this.getItem(i).$clone().Y > upperBound.Y) {
                        upperBound.Y = this.getItem(i).$clone().Y;
                    }
                }

                aabb.LowerBound = lowerBound.$clone();
                aabb.UpperBound = upperBound.$clone();

                return aabb.$clone();
            },
            Translate: function (vector) {
                vector = {v:vector};
                this.Translate$1(vector);
            },
            /**
             * Translates the vertices with the specified vector.
             *
             * @instance
             * @public
             * @this FarseerPhysics.Common.Vertices
             * @memberof FarseerPhysics.Common.Vertices
             * @param   {Microsoft.Xna.Framework.Vector2}    vector    The vector.
             * @return  {void}
             */
            Translate$1: function (vector) {
                for (var i = 0; i < this.Count; i = (i + 1) | 0) {
                    this.setItem(i, Microsoft.Xna.Framework.Vector2.Add(this.getItem(i).$clone(), vector.v.$clone()));
                }
            },
            /**
             * Scales the vertices with the specified vector.
             *
             * @instance
             * @public
             * @this FarseerPhysics.Common.Vertices
             * @memberof FarseerPhysics.Common.Vertices
             * @param   {Microsoft.Xna.Framework.Vector2}    value    The Value.
             * @return  {void}
             */
            Scale: function (value) {
                for (var i = 0; i < this.Count; i = (i + 1) | 0) {
                    this.setItem(i, Microsoft.Xna.Framework.Vector2.Multiply(this.getItem(i).$clone(), value.v.$clone()));
                }
            },
            /**
             * Rotate the vertices with the defined value in radians.
             *
             * @instance
             * @public
             * @this FarseerPhysics.Common.Vertices
             * @memberof FarseerPhysics.Common.Vertices
             * @param   {number}    value    The amount to rotate by in radians.
             * @return  {void}
             */
            Rotate: function (value) {
                var rotationMatrix = { v : new Microsoft.Xna.Framework.Matrix() };
                Microsoft.Xna.Framework.Matrix.CreateRotationZ$1(value, rotationMatrix);

                for (var i = 0; i < this.Count; i = (i + 1) | 0) {
                    this.setItem(i, Microsoft.Xna.Framework.Vector2.Transform(this.getItem(i).$clone(), rotationMatrix.v.$clone()));
                }
            },
            /**
             * Assuming the polygon is simple; determines whether the polygon is convex.
             NOTE: It will also return false if the input contains colinear edges.
             *
             * @instance
             * @public
             * @this FarseerPhysics.Common.Vertices
             * @memberof FarseerPhysics.Common.Vertices
             * @return  {boolean}        <pre><code>true</code></pre> if it is convex; otherwise, <pre><code>false</code></pre>.
             */
            IsConvex: function () {
                for (var i = 0; i < this.Count; i = (i + 1) | 0) {
                    var i1 = i;
                    var i2 = ((i + 1) | 0) < this.Count ? ((i + 1) | 0) : 0;
                    var edge = Microsoft.Xna.Framework.Vector2.op_Subtraction(this.getItem(i2).$clone(), this.getItem(i1).$clone());

                    for (var j = 0; j < this.Count; j = (j + 1) | 0) {
                        if (j === i1 || j === i2) {
                            continue;
                        }

                        var r = Microsoft.Xna.Framework.Vector2.op_Subtraction(this.getItem(j).$clone(), this.getItem(i1).$clone());

                        var s = edge.X * r.Y - edge.Y * r.X;

                        if (s <= 0.0) {
                            return false;
                        }
                    }
                }
                return true;
            },
            IsCounterClockWise: function () {
                if (this.Count < 3) {
                    return true;
                }

                return (this.GetSignedArea() > 0.0);
            },
            /**
             * Forces counter clock wise order.
             *
             * @instance
             * @public
             * @this FarseerPhysics.Common.Vertices
             * @memberof FarseerPhysics.Common.Vertices
             * @return  {void}
             */
            ForceCounterClockWise: function () {
                if (!this.IsCounterClockWise()) {
                    this.Reverse();
                }
            },
            /**
             * Check for edge crossings
             *
             * @instance
             * @public
             * @this FarseerPhysics.Common.Vertices
             * @memberof FarseerPhysics.Common.Vertices
             * @return  {boolean}
             */
            IsSimple: function () {
                for (var i = 0; i < this.Count; i = (i + 1) | 0) {
                    var iplus = (((i + 1) | 0) > ((this.Count - 1) | 0)) ? 0 : ((i + 1) | 0);
                    var a1 = new Microsoft.Xna.Framework.Vector2.$ctor2(this.getItem(i).$clone().X, this.getItem(i).$clone().Y);
                    var a2 = new Microsoft.Xna.Framework.Vector2.$ctor2(this.getItem(iplus).$clone().X, this.getItem(iplus).$clone().Y);
                    for (var j = (i + 1) | 0; j < this.Count; j = (j + 1) | 0) {
                        var jplus = (((j + 1) | 0) > ((this.Count - 1) | 0)) ? 0 : ((j + 1) | 0);
                        var b1 = new Microsoft.Xna.Framework.Vector2.$ctor2(this.getItem(j).$clone().X, this.getItem(j).$clone().Y);
                        var b2 = new Microsoft.Xna.Framework.Vector2.$ctor2(this.getItem(jplus).$clone().X, this.getItem(jplus).$clone().Y);

                        var temp = { v : new Microsoft.Xna.Framework.Vector2() };

                        if (FarseerPhysics.Common.LineTools.LineIntersect2(a1.$clone(), a2.$clone(), b1.$clone(), b2.$clone(), temp)) {
                            return false;
                        }
                    }
                }
                return true;
            },
            IsSimple2: function () {
                for (var i = 0; i < this.Count; i = (i + 1) | 0) {
                    if (i < ((this.Count - 1) | 0)) {
                        for (var h = (i + 1) | 0; h < this.Count; h = (h + 1) | 0) {
                            if (Microsoft.Xna.Framework.Vector2.op_Equality(this.getItem(i).$clone(), this.getItem(h).$clone())) {
                                return true;
                            }
                        }
                    }

                    var j = (((i + 1) | 0)) % this.Count;
                    var iToj = Microsoft.Xna.Framework.Vector2.op_Subtraction(this.getItem(j).$clone(), this.getItem(i).$clone());
                    var iTojNormal = new Microsoft.Xna.Framework.Vector2.$ctor2(iToj.Y, -iToj.X);

                    var startK = (((j + 1) | 0)) % this.Count;
                    var endK = (((((i - 1) | 0) + this.Count) | 0)) % this.Count;
                    endK = (endK + (startK < endK ? 0 : ((startK + 1) | 0))) | 0;
                    var k = startK;
                    var iTok = Microsoft.Xna.Framework.Vector2.op_Subtraction(this.getItem(k).$clone(), this.getItem(i).$clone());
                    var onLeftSide = Microsoft.Xna.Framework.Vector2.Dot(iTok.$clone(), iTojNormal.$clone()) >= 0;
                    var prevK = this.getItem(k).$clone();
                    k = (k + 1) | 0;
                    for (; k <= endK; k = (k + 1) | 0) {
                        var modK = k % this.Count;
                        iTok = Microsoft.Xna.Framework.Vector2.op_Subtraction(this.getItem(modK).$clone(), this.getItem(i).$clone());
                        if (onLeftSide !== Microsoft.Xna.Framework.Vector2.Dot(iTok.$clone(), iTojNormal.$clone()) >= 0) {
                            var prevKtoK = Microsoft.Xna.Framework.Vector2.op_Subtraction(this.getItem(modK).$clone(), prevK.$clone());
                            var prevKtoKNormal = new Microsoft.Xna.Framework.Vector2.$ctor2(prevKtoK.Y, -prevKtoK.X);
                            if ((Microsoft.Xna.Framework.Vector2.Dot(Microsoft.Xna.Framework.Vector2.op_Subtraction(this.getItem(i).$clone(), prevK.$clone()), prevKtoKNormal.$clone()) >= 0) !== (Microsoft.Xna.Framework.Vector2.Dot(Microsoft.Xna.Framework.Vector2.op_Subtraction(this.getItem(j).$clone(), prevK.$clone()), prevKtoKNormal.$clone()) >= 0)) {
                                return true;
                            }
                        }
                        onLeftSide = Microsoft.Xna.Framework.Vector2.Dot(iTok.$clone(), iTojNormal.$clone()) > 0;
                        prevK = this.getItem(modK).$clone();
                    }
                }
                return false;
            },
            /**
             * Checks if polygon is valid for use in Box2d engine.
             Last ditch effort to ensure no invalid polygons are
             added to world geometry.
             Performs a full check, for simplicity, convexity,
             orientation, minimum angle, and volume.  This won't
             be very efficient, and a lot of it is redundant when
             other tools in this section are used.
             *
             * @instance
             * @public
             * @this FarseerPhysics.Common.Vertices
             * @memberof FarseerPhysics.Common.Vertices
             * @return  {boolean}
             */
            CheckPolygon: function () {
                var error = -1;
                if (this.Count < 3 || this.Count > FarseerPhysics.Settings.MaxPolygonVertices) {
                    error = 0;
                }
                if (!this.IsConvex()) {
                    error = 1;
                }
                if (!this.IsSimple()) {
                    error = 2;
                }
                if (this.GetArea() < FarseerPhysics.Settings.Epsilon) {
                    error = 3;
                }

                var normals = System.Array.init(this.Count, function (){
                    return new Microsoft.Xna.Framework.Vector2();
                }, Microsoft.Xna.Framework.Vector2);
                var vertices = new FarseerPhysics.Common.Vertices.$ctor3(this.Count);
                for (var i = 0; i < this.Count; i = (i + 1) | 0) {
                    vertices.add(new Microsoft.Xna.Framework.Vector2.$ctor2(this.getItem(i).$clone().X, this.getItem(i).$clone().Y));
                    var i1 = i;
                    var i2 = ((i + 1) | 0) < this.Count ? ((i + 1) | 0) : 0;
                    var edge = new Microsoft.Xna.Framework.Vector2.$ctor2(this.getItem(i2).$clone().X - this.getItem(i1).$clone().X, this.getItem(i2).$clone().Y - this.getItem(i1).$clone().Y);
                    normals[System.Array.index(i, normals)] = FarseerPhysics.Common.MathUtils.Cross(edge.$clone(), 1.0);
                    normals[System.Array.index(i, normals)].Normalize();
                }

                for (var i3 = 0; i3 < this.Count; i3 = (i3 + 1) | 0) {
                    var iminus = (i3 === 0) ? ((this.Count - 1) | 0) : ((i3 - 1) | 0);

                    var cross = FarseerPhysics.Common.MathUtils.Cross$2(normals[System.Array.index(iminus, normals)].$clone(), normals[System.Array.index(i3, normals)].$clone());
                    cross = FarseerPhysics.Common.MathUtils.Clamp$2(cross, -1.0, 1.0);
                    var angle = Math.asin(cross);
                    if (angle <= FarseerPhysics.Settings.AngularSlop) {
                        error = 4;
                        break;
                    }

                    for (var j = 0; j < this.Count; j = (j + 1) | 0) {
                        if (j === i3 || j === (((i3 + 1) | 0)) % this.Count) {
                            continue;
                        }
                        var s = Microsoft.Xna.Framework.Vector2.Dot(normals[System.Array.index(i3, normals)].$clone(), Microsoft.Xna.Framework.Vector2.op_Subtraction(vertices.getItem(j).$clone(), vertices.getItem(i3).$clone()));
                        if (s >= -0.005) {
                            error = 5;
                        }
                    }


                    var centroid = vertices.GetCentroid();
                    var n1 = normals[System.Array.index(iminus, normals)].$clone();
                    var n2 = normals[System.Array.index(i3, normals)].$clone();
                    var v = Microsoft.Xna.Framework.Vector2.op_Subtraction(vertices.getItem(i3).$clone(), centroid.$clone());

                    var d = new Microsoft.Xna.Framework.Vector2.ctor();
                    d.X = Microsoft.Xna.Framework.Vector2.Dot(n1.$clone(), v.$clone());
                    d.Y = Microsoft.Xna.Framework.Vector2.Dot(n2.$clone(), v.$clone());

                    if ((d.X < 0.0) || (d.Y < 0.0)) {
                        error = 6;
                    }
                }

                if (error !== -1) {
                    System.Diagnostics.Debug.WriteLine$2("Found invalid polygon, ");
                    switch (error) {
                        case 0: 
                            System.Diagnostics.Debug.WriteLine$2(System.String.format("must have between 3 and {0} vertices.\n", [Bridge.box(FarseerPhysics.Settings.MaxPolygonVertices, System.Int32)]));
                            break;
                        case 1: 
                            System.Diagnostics.Debug.WriteLine$2("must be convex.\n");
                            break;
                        case 2: 
                            System.Diagnostics.Debug.WriteLine$2("must be simple (cannot intersect itself).\n");
                            break;
                        case 3: 
                            System.Diagnostics.Debug.WriteLine$2("area is too small.\n");
                            break;
                        case 4: 
                            System.Diagnostics.Debug.WriteLine$2("sides are too close to parallel.\n");
                            break;
                        case 5: 
                            System.Diagnostics.Debug.WriteLine$2("polygon is too thin.\n");
                            break;
                        case 6: 
                            System.Diagnostics.Debug.WriteLine$2("core shape generation would move edge past centroid (too thin).\n");
                            break;
                        default: 
                            System.Diagnostics.Debug.WriteLine$2("don't know why.\n");
                            break;
                    }
                }
                return error !== -1;
            },
            /**
             * Trace the edge of a non-simple polygon and return a simple polygon.
             Method:
             Start at vertex with minimum y (pick maximum x one if there are two).
             We aim our "lastDir" vector at (1.0, 0)
             We look at the two rays going off from our start vertex, and follow whichever
             has the smallest angle (in -Pi . Pi) wrt lastDir ("rightest" turn)
             Loop until we hit starting vertex:
             We add our current vertex to the list.
             We check the seg from current vertex to next vertex for intersections
             - if no intersections, follow to next vertex and continue
             - if intersections, pick one with minimum distance
             - if more than one, pick one with "rightest" next point (two possibilities for each)
             *
             * @instance
             * @public
             * @this FarseerPhysics.Common.Vertices
             * @memberof FarseerPhysics.Common.Vertices
             * @param   {FarseerPhysics.Common.Vertices}    verts    The vertices.
             * @return  {FarseerPhysics.Common.Vertices}
             */
            TraceEdge: function (verts) {
                var $step = 0,
                    $jumpFromFinally, 
                    nodes, 
                    nNodes, 
                    i, 
                    pos, 
                    iplus, 
                    iminus, 
                    dirty, 
                    counter, 
                    i1, 
                    j, 
                    k, 
                    $t, 
                    l, 
                    $t1, 
                    $t2, 
                    $t3, 
                    intersectPt, 
                    crosses, 
                    $t4, 
                    $t5, 
                    connj, 
                    $t6, 
                    connl, 
                    $t7, 
                    $t8, 
                    $t9, 
                    foundDupe, 
                    nActive, 
                    i2, 
                    j1, 
                    diff, 
                    inode, 
                    jnode, 
                    njConn, 
                    k1, 
                    knode, 
                    minY, 
                    maxX, 
                    minYIndex, 
                    i3, 
                    origDir, 
                    resultVecs, 
                    nResultVecs, 
                    currentNode, 
                    startNode, 
                    nextNode, 
                    vertices, 
                    i4, 
                    oldNode, 
                    vertices1, 
                    i5, 
                    $asyncBody = Bridge.fn.bind(this, function () {
                        for (;;) {
                            $step = System.Array.min([0,1,2,3,4,5,6,7,8,9,10,11,13,15,17,19,20,21,22], $step);
                            switch ($step) {
                                case 0: {
                                    nodes = System.Array.init(Bridge.Int.mul(verts.Count, verts.Count), null, FarseerPhysics.Common.Vertices.PolyNode);
                                    nNodes = 0;

                                    for (i = 0; i < verts.Count; i = (i + 1) | 0) {
                                        pos = new Microsoft.Xna.Framework.Vector2.$ctor2(verts.getItem(i).$clone().X, verts.getItem(i).$clone().Y);
                                        nodes[System.Array.index(i, nodes)].Position = pos.$clone();
                                        nNodes = (nNodes + 1) | 0;
                                        iplus = (i === ((verts.Count - 1) | 0)) ? 0 : ((i + 1) | 0);
                                        iminus = (i === 0) ? ((verts.Count - 1) | 0) : ((i - 1) | 0);
                                        nodes[System.Array.index(i, nodes)].AddConnection(nodes[System.Array.index(iplus, nodes)]);
                                        nodes[System.Array.index(i, nodes)].AddConnection(nodes[System.Array.index(iminus, nodes)]);
                                    }

                                    dirty = true;
                                    counter = 0;
                                    
                                    $step = 1;
                                    continue;
                                }
                                case 1: {
                                    if ( dirty ) {
                                        $step = 2;
                                        continue;
                                    } 
                                    $step = 22;
                                    continue;
                                }
                                case 2: {
                                    dirty = false;
                                    i1 = 0;
                                    $step = 3;
                                    continue;
                                }
                                case 3: {
                                    if ( i1 < nNodes ) {
                                        $step = 4;
                                        continue;
                                    }
                                    $step = 20;
                                    continue;
                                }
                                case 4: {
                                    j = 0;
                                    $step = 5;
                                    continue;
                                }
                                case 5: {
                                    if ( j < nodes[System.Array.index(i1, nodes)].NConnected ) {
                                        $step = 6;
                                        continue;
                                    }
                                    $step = 18;
                                    continue;
                                }
                                case 6: {
                                    k = 0;
                                    $step = 7;
                                    continue;
                                }
                                case 7: {
                                    if ( k < nNodes ) {
                                        $step = 8;
                                        continue;
                                    }
                                    $step = 16;
                                    continue;
                                }
                                case 8: {
                                    if (k === i1 || Bridge.referenceEquals(nodes[System.Array.index(k, nodes)], ($t = nodes[System.Array.index(i1, nodes)].Connected)[System.Array.index(j, $t)])) {
                                        $step = 15;
                                        continue;
                                    }
                                    l = 0;
                                    $step = 9;
                                    continue;
                                }
                                case 9: {
                                    if ( l < nodes[System.Array.index(k, nodes)].NConnected ) {
                                        $step = 10;
                                        continue;
                                    }
                                    $step = 14;
                                    continue;
                                }
                                case 10: {
                                    if (Bridge.referenceEquals(($t1 = nodes[System.Array.index(k, nodes)].Connected)[System.Array.index(l, $t1)], ($t2 = nodes[System.Array.index(i1, nodes)].Connected)[System.Array.index(j, $t2)]) || Bridge.referenceEquals(($t3 = nodes[System.Array.index(k, nodes)].Connected)[System.Array.index(l, $t3)], nodes[System.Array.index(i1, nodes)])) {
                                        $step = 13;
                                        continue;
                                    }

                                    intersectPt = { v : new Microsoft.Xna.Framework.Vector2() };

                                    crosses = FarseerPhysics.Common.LineTools.LineIntersect$1(nodes[System.Array.index(i1, nodes)].Position.$clone(), ($t4 = nodes[System.Array.index(i1, nodes)].Connected)[System.Array.index(j, $t4)].Position.$clone(), nodes[System.Array.index(k, nodes)].Position.$clone(), ($t5 = nodes[System.Array.index(k, nodes)].Connected)[System.Array.index(l, $t5)].Position.$clone(), intersectPt);
                                    if (crosses) {
                                        $step = 11;
                                        continue;
                                    } 
                                    $step = 12;
                                    continue;
                                }
                                case 11: {
                                    dirty = true;
                                    connj = ($t6 = nodes[System.Array.index(i1, nodes)].Connected)[System.Array.index(j, $t6)];
                                    connl = ($t7 = nodes[System.Array.index(k, nodes)].Connected)[System.Array.index(l, $t7)];
                                    ($t8 = nodes[System.Array.index(i1, nodes)].Connected)[System.Array.index(j, $t8)].RemoveConnection(nodes[System.Array.index(i1, nodes)]);
                                    nodes[System.Array.index(i1, nodes)].RemoveConnection(connj);
                                    ($t9 = nodes[System.Array.index(k, nodes)].Connected)[System.Array.index(l, $t9)].RemoveConnection(nodes[System.Array.index(k, nodes)]);
                                    nodes[System.Array.index(k, nodes)].RemoveConnection(connl);
                                    nodes[System.Array.index(nNodes, nodes)] = new FarseerPhysics.Common.Vertices.PolyNode(intersectPt.v.$clone());
                                    nodes[System.Array.index(nNodes, nodes)].AddConnection(nodes[System.Array.index(i1, nodes)]);
                                    nodes[System.Array.index(i1, nodes)].AddConnection(nodes[System.Array.index(nNodes, nodes)]);
                                    nodes[System.Array.index(nNodes, nodes)].AddConnection(nodes[System.Array.index(k, nodes)]);
                                    nodes[System.Array.index(k, nodes)].AddConnection(nodes[System.Array.index(nNodes, nodes)]);
                                    nodes[System.Array.index(nNodes, nodes)].AddConnection(connj);
                                    connj.AddConnection(nodes[System.Array.index(nNodes, nodes)]);
                                    nodes[System.Array.index(nNodes, nodes)].AddConnection(connl);
                                    connl.AddConnection(nodes[System.Array.index(nNodes, nodes)]);
                                    nNodes = (nNodes + 1) | 0;
                                    $step = 21;
                                    continue;
                                }

                                case 13: {
                                    l = (l + 1) | 0;
                                    $step = 9;
                                    continue;
                                }

                                case 15: {
                                    k = (k + 1) | 0;
                                    $step = 7;
                                    continue;
                                }

                                case 17: {
                                    j = (j + 1) | 0;
                                    $step = 5;
                                    continue;
                                }

                                case 19: {
                                    i1 = (i1 + 1) | 0;
                                    $step = 3;
                                    continue;
                                }
                                case 20: {

                                }
                                case 21: {
                                    counter = (counter + 1) | 0;

                                    $step = 1;
                                    continue;
                                }
                                case 22: {
                                    foundDupe = true;
                                    nActive = nNodes;
                                    while (foundDupe) {
                                        foundDupe = false;
                                        for (i2 = 0; i2 < nNodes; i2 = (i2 + 1) | 0) {
                                            if (nodes[System.Array.index(i2, nodes)].NConnected === 0) {
                                                continue;
                                            }
                                            for (j1 = (i2 + 1) | 0; j1 < nNodes; j1 = (j1 + 1) | 0) {
                                                if (nodes[System.Array.index(j1, nodes)].NConnected === 0) {
                                                    continue;
                                                }
                                                diff = Microsoft.Xna.Framework.Vector2.op_Subtraction(nodes[System.Array.index(i2, nodes)].Position.$clone(), nodes[System.Array.index(j1, nodes)].Position.$clone());
                                                if (diff.LengthSquared() <= 1.42108547E-14) {
                                                    if (nActive <= 3) {
                                                        return new FarseerPhysics.Common.Vertices.ctor();
                                                    }

                                                    nActive = (nActive - 1) | 0;
                                                    foundDupe = true;
                                                    inode = nodes[System.Array.index(i2, nodes)];
                                                    jnode = nodes[System.Array.index(j1, nodes)];
                                                    njConn = jnode.NConnected;
                                                    for (k1 = 0; k1 < njConn; k1 = (k1 + 1) | 0) {
                                                        knode = jnode.Connected[System.Array.index(k1, jnode.Connected)];
                                                        System.Diagnostics.Debug.Assert(!Bridge.referenceEquals(knode, jnode));
                                                        if (!Bridge.referenceEquals(knode, inode)) {
                                                            inode.AddConnection(knode);
                                                            knode.AddConnection(inode);
                                                        }
                                                        knode.RemoveConnection(jnode);
                                                    }
                                                    jnode.NConnected = 0;
                                                }
                                            }
                                        }
                                    }


                                    minY = 3.40282347E+38;
                                    maxX = -3.40282347E+38;
                                    minYIndex = -1;
                                    for (i3 = 0; i3 < nNodes; i3 = (i3 + 1) | 0) {
                                        if (nodes[System.Array.index(i3, nodes)].Position.Y < minY && nodes[System.Array.index(i3, nodes)].NConnected > 1) {
                                            minY = nodes[System.Array.index(i3, nodes)].Position.Y;
                                            minYIndex = i3;
                                            maxX = nodes[System.Array.index(i3, nodes)].Position.X;
                                        } else if (nodes[System.Array.index(i3, nodes)].Position.Y === minY && nodes[System.Array.index(i3, nodes)].Position.X > maxX && nodes[System.Array.index(i3, nodes)].NConnected > 1) {
                                            minYIndex = i3;
                                            maxX = nodes[System.Array.index(i3, nodes)].Position.X;
                                        }
                                    }

                                    origDir = new Microsoft.Xna.Framework.Vector2.$ctor2(1.0, 0.0);
                                    resultVecs = System.Array.init(Bridge.Int.mul(4, nNodes), function (){
                                        return new Microsoft.Xna.Framework.Vector2();
                                    }, Microsoft.Xna.Framework.Vector2);
                                    nResultVecs = 0;
                                    currentNode = nodes[System.Array.index(minYIndex, nodes)];
                                    startNode = currentNode;
                                    System.Diagnostics.Debug.Assert(currentNode.NConnected > 0);
                                    nextNode = currentNode.GetRightestConnection$1(origDir.$clone());
                                    if (nextNode == null) {
                                        vertices = new FarseerPhysics.Common.Vertices.$ctor3(nResultVecs);

                                        for (i4 = 0; i4 < nResultVecs; i4 = (i4 + 1) | 0) {
                                            vertices.add(resultVecs[System.Array.index(i4, resultVecs)].$clone());
                                        }

                                        return vertices;
                                    }

                                    resultVecs[System.Array.index(0, resultVecs)] = startNode.Position.$clone();
                                    nResultVecs = (nResultVecs + 1) | 0;
                                    while (!Bridge.referenceEquals(nextNode, startNode)) {
                                        if (nResultVecs > Bridge.Int.mul(4, nNodes)) {
                                            System.Diagnostics.Debug.Assert(false);
                                        }
                                        resultVecs[System.Array.index(Bridge.identity(nResultVecs, (nResultVecs = (nResultVecs + 1) | 0)), resultVecs)] = nextNode.Position.$clone();
                                        oldNode = currentNode;
                                        currentNode = nextNode;
                                        nextNode = currentNode.GetRightestConnection(oldNode);
                                        if (nextNode == null) {
                                            vertices1 = new FarseerPhysics.Common.Vertices.$ctor3(nResultVecs);
                                            for (i5 = 0; i5 < nResultVecs; i5 = (i5 + 1) | 0) {
                                                vertices1.add(resultVecs[System.Array.index(i5, resultVecs)].$clone());
                                            }
                                            return vertices1;
                                        }
                                    }

                                    return new FarseerPhysics.Common.Vertices.ctor();
                                }
                                default: {
                                    return;
                                }
                            }
                        }
                    }, arguments);

                return $asyncBody();
            },
            toString: function () {
                var builder = new System.Text.StringBuilder();
                for (var i = 0; i < this.Count; i = (i + 1) | 0) {
                    builder.append(this.getItem(i).$clone().toString());
                    if (i < ((this.Count - 1) | 0)) {
                        builder.append(" ");
                    }
                }
                return builder.toString();
            },
            /**
             * Projects to axis.
             *
             * @instance
             * @public
             * @this FarseerPhysics.Common.Vertices
             * @memberof FarseerPhysics.Common.Vertices
             * @param   {Microsoft.Xna.Framework.Vector2}    axis    The axis.
             * @param   {System.Single}                      min     The min.
             * @param   {System.Single}                      max     The max.
             * @return  {void}
             */
            ProjectToAxis: function (axis, min, max) {
                var dotProduct = Microsoft.Xna.Framework.Vector2.Dot(axis.v.$clone(), this.getItem(0).$clone());
                min.v = dotProduct;
                max.v = dotProduct;

                for (var i = 0; i < this.Count; i = (i + 1) | 0) {
                    dotProduct = Microsoft.Xna.Framework.Vector2.Dot(this.getItem(i).$clone(), axis.v.$clone());
                    if (dotProduct < min.v) {
                        min.v = dotProduct;
                    } else {
                        if (dotProduct > max.v) {
                            max.v = dotProduct;
                        }
                    }
                }
            },
            /**
             * Winding number test for a point in a polygon.
             *
             * @instance
             * @public
             * @this FarseerPhysics.Common.Vertices
             * @memberof FarseerPhysics.Common.Vertices
             * @param   {Microsoft.Xna.Framework.Vector2}    point    The point to be tested.
             * @return  {number}                                      -1 if the winding number is zero and the point is outside
             the polygon, 1 if the point is inside the polygon, and 0 if the point
             is on the polygons edge.
             */
            PointInPolygon: function (point) {
                var wn = 0;

                for (var i = 0; i < this.Count; i = (i + 1) | 0) {
                    var p1 = { v : this.getItem(i).$clone() };
                    var p2 = { v : this.getItem(this.NextIndex(i)).$clone() };

                    var edge = Microsoft.Xna.Framework.Vector2.op_Subtraction(p2.v.$clone(), p1.v.$clone());
                    var area = FarseerPhysics.Common.MathUtils.Area$1(p1, p2, point);
                    if (area === 0.0 && Microsoft.Xna.Framework.Vector2.Dot(Microsoft.Xna.Framework.Vector2.op_Subtraction(point.v.$clone(), p1.v.$clone()), edge.$clone()) >= 0.0 && Microsoft.Xna.Framework.Vector2.Dot(Microsoft.Xna.Framework.Vector2.op_Subtraction(point.v.$clone(), p2.v.$clone()), edge.$clone()) <= 0.0) {
                        return 0;
                    }
                    if (p1.v.Y <= point.v.Y) {
                        if (p2.v.Y > point.v.Y && area > 0.0) {
                            wn = (wn + 1) | 0;
                        }
                    } else {
                        if (p2.v.Y <= point.v.Y && area < 0.0) {
                            wn = (wn - 1) | 0;
                        }
                    }
                }
                return (wn === 0 ? -1 : 1);
            },
            /**
             * Compute the sum of the angles made between the test point and each pair of points making up the polygon. 
             If this sum is 2pi then the point is an interior point, if 0 then the point is an exterior point. 
             ref: http://ozviz.wasp.uwa.edu.au/~pbourke/geometry/insidepoly/  - Solution 2
             *
             * @instance
             * @public
             * @this FarseerPhysics.Common.Vertices
             * @memberof FarseerPhysics.Common.Vertices
             * @param   {Microsoft.Xna.Framework.Vector2}    point
             * @return  {boolean}
             */
            PointInPolygonAngle: function (point) {
                var angle = 0;

                for (var i = 0; i < this.Count; i = (i + 1) | 0) {
                    var p1 = { v : Microsoft.Xna.Framework.Vector2.op_Subtraction(this.getItem(i).$clone(), point.v.$clone()) };
                    var p2 = { v : Microsoft.Xna.Framework.Vector2.op_Subtraction(this.getItem(this.NextIndex(i)).$clone(), point.v.$clone()) };

                    angle += FarseerPhysics.Common.MathUtils.VectorAngle$1(p1, p2);
                }

                if (Math.abs(angle) < Math.PI) {
                    return false;
                }

                return true;
            }
        }
    });

    Bridge.define("FarseerPhysics.Common.FixedArray2$1", function (T) { return {
        $kind: "struct",
        statics: {
            methods: {
                getDefaultValue: function () { return new (FarseerPhysics.Common.FixedArray2$1(T))(); }
            }
        },
        fields: {
            _value0: Bridge.getDefaultValue(T),
            _value1: Bridge.getDefaultValue(T)
        },
        ctors: {
            ctor: function () {
                this.$initialize();
            }
        },
        methods: {
            getItem: function (index) {
                switch (index) {
                    case 0: 
                        return this._value0;
                    case 1: 
                        return this._value1;
                    default: 
                        throw new System.IndexOutOfRangeException.ctor();
                }
            },
            setItem: function (index, value) {
                switch (index) {
                    case 0: 
                        this._value0 = value;
                        break;
                    case 1: 
                        this._value1 = value;
                        break;
                    default: 
                        throw new System.IndexOutOfRangeException.ctor();
                }
            },
            getHashCode: function () {
                var h = Bridge.addHash([3625788427, this._value0, this._value1]);
                return h;
            },
            equals: function (o) {
                if (!Bridge.is(o, FarseerPhysics.Common.FixedArray2$1(T))) {
                    return false;
                }
                return Bridge.equals(this._value0, o._value0) && Bridge.equals(this._value1, o._value1);
            },
            $clone: function (to) {
                var s = to || new (FarseerPhysics.Common.FixedArray2$1(T))();
                s._value0 = this._value0;
                s._value1 = this._value1;
                return s;
            }
        }
    }; });

    Bridge.define("FarseerPhysics.Common.FixedArray3$1", function (T) { return {
        $kind: "struct",
        statics: {
            methods: {
                getDefaultValue: function () { return new (FarseerPhysics.Common.FixedArray3$1(T))(); }
            }
        },
        fields: {
            _value0: Bridge.getDefaultValue(T),
            _value1: Bridge.getDefaultValue(T),
            _value2: Bridge.getDefaultValue(T)
        },
        ctors: {
            ctor: function () {
                this.$initialize();
            }
        },
        methods: {
            getItem: function (index) {
                switch (index) {
                    case 0: 
                        return this._value0;
                    case 1: 
                        return this._value1;
                    case 2: 
                        return this._value2;
                    default: 
                        throw new System.IndexOutOfRangeException.ctor();
                }
            },
            setItem: function (index, value) {
                switch (index) {
                    case 0: 
                        this._value0 = value;
                        break;
                    case 1: 
                        this._value1 = value;
                        break;
                    case 2: 
                        this._value2 = value;
                        break;
                    default: 
                        throw new System.IndexOutOfRangeException.ctor();
                }
            },
            getHashCode: function () {
                var h = Bridge.addHash([3625853963, this._value0, this._value1, this._value2]);
                return h;
            },
            equals: function (o) {
                if (!Bridge.is(o, FarseerPhysics.Common.FixedArray3$1(T))) {
                    return false;
                }
                return Bridge.equals(this._value0, o._value0) && Bridge.equals(this._value1, o._value1) && Bridge.equals(this._value2, o._value2);
            },
            $clone: function (to) {
                var s = to || new (FarseerPhysics.Common.FixedArray3$1(T))();
                s._value0 = this._value0;
                s._value1 = this._value1;
                s._value2 = this._value2;
                return s;
            }
        }
    }; });

    Bridge.define("FarseerPhysics.Common.FixedArray4$1", function (T) { return {
        $kind: "struct",
        statics: {
            methods: {
                getDefaultValue: function () { return new (FarseerPhysics.Common.FixedArray4$1(T))(); }
            }
        },
        fields: {
            _value0: Bridge.getDefaultValue(T),
            _value1: Bridge.getDefaultValue(T),
            _value2: Bridge.getDefaultValue(T),
            _value3: Bridge.getDefaultValue(T)
        },
        ctors: {
            ctor: function () {
                this.$initialize();
            }
        },
        methods: {
            getItem: function (index) {
                switch (index) {
                    case 0: 
                        return this._value0;
                    case 1: 
                        return this._value1;
                    case 2: 
                        return this._value2;
                    case 3: 
                        return this._value3;
                    default: 
                        throw new System.IndexOutOfRangeException.ctor();
                }
            },
            setItem: function (index, value) {
                switch (index) {
                    case 0: 
                        this._value0 = value;
                        break;
                    case 1: 
                        this._value1 = value;
                        break;
                    case 2: 
                        this._value2 = value;
                        break;
                    case 3: 
                        this._value3 = value;
                        break;
                    default: 
                        throw new System.IndexOutOfRangeException.ctor();
                }
            },
            getHashCode: function () {
                var h = Bridge.addHash([3625919499, this._value0, this._value1, this._value2, this._value3]);
                return h;
            },
            equals: function (o) {
                if (!Bridge.is(o, FarseerPhysics.Common.FixedArray4$1(T))) {
                    return false;
                }
                return Bridge.equals(this._value0, o._value0) && Bridge.equals(this._value1, o._value1) && Bridge.equals(this._value2, o._value2) && Bridge.equals(this._value3, o._value3);
            },
            $clone: function (to) {
                var s = to || new (FarseerPhysics.Common.FixedArray4$1(T))();
                s._value0 = this._value0;
                s._value1 = this._value1;
                s._value2 = this._value2;
                s._value3 = this._value3;
                return s;
            }
        }
    }; });

    Bridge.define("FarseerPhysics.Common.FixedArray8$1", function (T) { return {
        $kind: "struct",
        statics: {
            methods: {
                getDefaultValue: function () { return new (FarseerPhysics.Common.FixedArray8$1(T))(); }
            }
        },
        fields: {
            _value0: Bridge.getDefaultValue(T),
            _value1: Bridge.getDefaultValue(T),
            _value2: Bridge.getDefaultValue(T),
            _value3: Bridge.getDefaultValue(T),
            _value4: Bridge.getDefaultValue(T),
            _value5: Bridge.getDefaultValue(T),
            _value6: Bridge.getDefaultValue(T),
            _value7: Bridge.getDefaultValue(T)
        },
        ctors: {
            ctor: function () {
                this.$initialize();
            }
        },
        methods: {
            getItem: function (index) {
                switch (index) {
                    case 0: 
                        return this._value0;
                    case 1: 
                        return this._value1;
                    case 2: 
                        return this._value2;
                    case 3: 
                        return this._value3;
                    case 4: 
                        return this._value4;
                    case 5: 
                        return this._value5;
                    case 6: 
                        return this._value6;
                    case 7: 
                        return this._value7;
                    default: 
                        throw new System.IndexOutOfRangeException.ctor();
                }
            },
            setItem: function (index, value) {
                switch (index) {
                    case 0: 
                        this._value0 = value;
                        break;
                    case 1: 
                        this._value1 = value;
                        break;
                    case 2: 
                        this._value2 = value;
                        break;
                    case 3: 
                        this._value3 = value;
                        break;
                    case 4: 
                        this._value4 = value;
                        break;
                    case 5: 
                        this._value5 = value;
                        break;
                    case 6: 
                        this._value6 = value;
                        break;
                    case 7: 
                        this._value7 = value;
                        break;
                    default: 
                        throw new System.IndexOutOfRangeException.ctor();
                }
            },
            getHashCode: function () {
                var h = Bridge.addHash([3626181643, this._value0, this._value1, this._value2, this._value3, this._value4, this._value5, this._value6, this._value7]);
                return h;
            },
            equals: function (o) {
                if (!Bridge.is(o, FarseerPhysics.Common.FixedArray8$1(T))) {
                    return false;
                }
                return Bridge.equals(this._value0, o._value0) && Bridge.equals(this._value1, o._value1) && Bridge.equals(this._value2, o._value2) && Bridge.equals(this._value3, o._value3) && Bridge.equals(this._value4, o._value4) && Bridge.equals(this._value5, o._value5) && Bridge.equals(this._value6, o._value6) && Bridge.equals(this._value7, o._value7);
            },
            $clone: function (to) {
                var s = to || new (FarseerPhysics.Common.FixedArray8$1(T))();
                s._value0 = this._value0;
                s._value1 = this._value1;
                s._value2 = this._value2;
                s._value3 = this._value3;
                s._value4 = this._value4;
                s._value5 = this._value5;
                s._value6 = this._value6;
                s._value7 = this._value7;
                return s;
            }
        }
    }; });

    /** @namespace FarseerPhysics.Common */

    /**
     * Collection of helper methods for misc collisions.
     Does float tolerance and line collisions with lines and AABBs.
     *
     * @static
     * @abstract
     * @public
     * @class FarseerPhysics.Common.LineTools
     */
    Bridge.define("FarseerPhysics.Common.LineTools", {
        statics: {
            methods: {
                DistanceBetweenPointAndPoint: function (point1, point2) {
                    var v = { v : new Microsoft.Xna.Framework.Vector2() };
                    Microsoft.Xna.Framework.Vector2.Subtract$1(point1, point2, v);
                    return v.v.Length();
                },
                DistanceBetweenPointAndLineSegment: function (point, lineEndPoint1, lineEndPoint2) {
                    var v = Microsoft.Xna.Framework.Vector2.Subtract(lineEndPoint2.v.$clone(), lineEndPoint1.v.$clone());
                    var w = Microsoft.Xna.Framework.Vector2.Subtract(point.v.$clone(), lineEndPoint1.v.$clone());

                    var c1 = Microsoft.Xna.Framework.Vector2.Dot(w.$clone(), v.$clone());
                    if (c1 <= 0) {
                        return FarseerPhysics.Common.LineTools.DistanceBetweenPointAndPoint(point, lineEndPoint1);
                    }

                    var c2 = Microsoft.Xna.Framework.Vector2.Dot(v.$clone(), v.$clone());
                    if (c2 <= c1) {
                        return FarseerPhysics.Common.LineTools.DistanceBetweenPointAndPoint(point, lineEndPoint2);
                    }

                    var b = c1 / c2;
                    var pointOnLine = { v : Microsoft.Xna.Framework.Vector2.Add(lineEndPoint1.v.$clone(), Microsoft.Xna.Framework.Vector2.Multiply$1(v.$clone(), b)) };
                    return FarseerPhysics.Common.LineTools.DistanceBetweenPointAndPoint(point, pointOnLine);
                },
                /**
                 * Check if the lines a0-&gt;a1 and b0-&gt;b1 cross.
                If they do, intersectionPoint will be filled
                with the point of crossing.
                Grazing lines should not return true.
                 *
                 * @static
                 * @public
                 * @this FarseerPhysics.Common.LineTools
                 * @memberof FarseerPhysics.Common.LineTools
                 * @param   {Microsoft.Xna.Framework.Vector2}    a0                   
                 * @param   {Microsoft.Xna.Framework.Vector2}    a1                   
                 * @param   {Microsoft.Xna.Framework.Vector2}    b0                   
                 * @param   {Microsoft.Xna.Framework.Vector2}    b1                   
                 * @param   {Microsoft.Xna.Framework.Vector2}    intersectionPoint
                 * @return  {boolean}
                 */
                LineIntersect2: function (a0, a1, b0, b1, intersectionPoint) {
                    intersectionPoint.v = Microsoft.Xna.Framework.Vector2.Zero.$clone();

                    if (Microsoft.Xna.Framework.Vector2.op_Equality(a0.$clone(), b0.$clone()) || Microsoft.Xna.Framework.Vector2.op_Equality(a0.$clone(), b1.$clone()) || Microsoft.Xna.Framework.Vector2.op_Equality(a1.$clone(), b0.$clone()) || Microsoft.Xna.Framework.Vector2.op_Equality(a1.$clone(), b1.$clone())) {
                        return false;
                    }

                    var x1 = a0.X;
                    var y1 = a0.Y;
                    var x2 = a1.X;
                    var y2 = a1.Y;
                    var x3 = b0.X;
                    var y3 = b0.Y;
                    var x4 = b1.X;
                    var y4 = b1.Y;

                    if (Math.max(x1, x2) < Math.min(x3, x4) || Math.max(x3, x4) < Math.min(x1, x2)) {
                        return false;
                    }

                    if (Math.max(y1, y2) < Math.min(y3, y4) || Math.max(y3, y4) < Math.min(y1, y2)) {
                        return false;
                    }

                    var ua = ((x4 - x3) * (y1 - y3) - (y4 - y3) * (x1 - x3));
                    var ub = ((x2 - x1) * (y1 - y3) - (y2 - y1) * (x1 - x3));
                    var denom = (y4 - y3) * (x2 - x1) - (x4 - x3) * (y2 - y1);
                    if (Math.abs(denom) < FarseerPhysics.Settings.Epsilon) {
                        return false;
                    }
                    ua /= denom;
                    ub /= denom;

                    if ((0 < ua) && (ua < 1) && (0 < ub) && (ub < 1)) {
                        intersectionPoint.v.X = (x1 + ua * (x2 - x1));
                        intersectionPoint.v.Y = (y1 + ua * (y2 - y1));
                        return true;
                    }

                    return false;
                },
                LineIntersect: function (p1, p2, q1, q2) {
                    var i = Microsoft.Xna.Framework.Vector2.Zero.$clone();
                    var a1 = p2.Y - p1.Y;
                    var b1 = p1.X - p2.X;
                    var c1 = a1 * p1.X + b1 * p1.Y;
                    var a2 = q2.Y - q1.Y;
                    var b2 = q1.X - q2.X;
                    var c2 = a2 * q1.X + b2 * q1.Y;
                    var det = a1 * b2 - a2 * b1;

                    if (!FarseerPhysics.Common.MathUtils.FloatEquals(det, 0)) {
                        i.X = (b2 * c1 - b1 * c2) / det;
                        i.Y = (a1 * c2 - a2 * c1) / det;
                    }
                    return i.$clone();
                },
                /**
                 * This method detects if two line segments (or lines) intersect,
                 and, if so, the point of intersection. Use the <b /> and
                 <b /> parameters to set whether the intersection point
                 must be on the first and second line segments. Setting these
                 both to true means you are doing a line-segment to line-segment
                 intersection. Setting one of them to true means you are doing a
                 line to line-segment intersection test, and so on.
                 Note: If two line segments are coincident, then 
                 no intersection is detected (there are actually
                 infinite intersection points).
                 Author: Jeremy Bell
                 *
                 * @static
                 * @public
                 * @this FarseerPhysics.Common.LineTools
                 * @memberof FarseerPhysics.Common.LineTools
                 * @param   {Microsoft.Xna.Framework.Vector2}    point1             The first point of the first line segment.
                 * @param   {Microsoft.Xna.Framework.Vector2}    point2             The second point of the first line segment.
                 * @param   {Microsoft.Xna.Framework.Vector2}    point3             The first point of the second line segment.
                 * @param   {Microsoft.Xna.Framework.Vector2}    point4             The second point of the second line segment.
                 * @param   {boolean}                            firstIsSegment     Set this to true to require that the 
                 intersection point be on the first line segment.
                 * @param   {boolean}                            secondIsSegment    Set this to true to require that the
                 intersection point be on the second line segment.
                 * @param   {Microsoft.Xna.Framework.Vector2}    point              This is set to the intersection
                 point if an intersection is detected.
                 * @return  {boolean}                                               True if an intersection is detected, false otherwise.
                 */
                LineIntersect$4: function (point1, point2, point3, point4, firstIsSegment, secondIsSegment, point) {
                    point.v = new Microsoft.Xna.Framework.Vector2.ctor();

                    var a = point4.v.Y - point3.v.Y;
                    var b = point2.v.X - point1.v.X;
                    var c = point4.v.X - point3.v.X;
                    var d = point2.v.Y - point1.v.Y;

                    var denom = (a * b) - (c * d);

                    if (!(denom >= -1.1920929E-07 && denom <= FarseerPhysics.Settings.Epsilon)) {
                        var e = point1.v.Y - point3.v.Y;
                        var f = point1.v.X - point3.v.X;
                        var oneOverDenom = 1.0 / denom;

                        var ua = (c * e) - (a * f);
                        ua *= oneOverDenom;

                        if (!firstIsSegment || ua >= 0.0 && ua <= 1.0) {
                            var ub = (b * e) - (d * f);
                            ub *= oneOverDenom;

                            if (!secondIsSegment || ub >= 0.0 && ub <= 1.0) {
                                if (ua !== 0.0 || ub !== 0.0) {
                                    point.v.X = point1.v.X + ua * b;
                                    point.v.Y = point1.v.Y + ua * d;
                                    return true;
                                }
                            }
                        }
                    }

                    return false;
                },
                /**
                 * This method detects if two line segments (or lines) intersect,
                 and, if so, the point of intersection. Use the <b /> and
                 <b /> parameters to set whether the intersection point
                 must be on the first and second line segments. Setting these
                 both to true means you are doing a line-segment to line-segment
                 intersection. Setting one of them to true means you are doing a
                 line to line-segment intersection test, and so on.
                 Note: If two line segments are coincident, then 
                 no intersection is detected (there are actually
                 infinite intersection points).
                 Author: Jeremy Bell
                 *
                 * @static
                 * @public
                 * @this FarseerPhysics.Common.LineTools
                 * @memberof FarseerPhysics.Common.LineTools
                 * @param   {Microsoft.Xna.Framework.Vector2}    point1               The first point of the first line segment.
                 * @param   {Microsoft.Xna.Framework.Vector2}    point2               The second point of the first line segment.
                 * @param   {Microsoft.Xna.Framework.Vector2}    point3               The first point of the second line segment.
                 * @param   {Microsoft.Xna.Framework.Vector2}    point4               The second point of the second line segment.
                 * @param   {boolean}                            firstIsSegment       Set this to true to require that the 
                 intersection point be on the first line segment.
                 * @param   {boolean}                            secondIsSegment      Set this to true to require that the
                 intersection point be on the second line segment.
                 * @param   {Microsoft.Xna.Framework.Vector2}    intersectionPoint    This is set to the intersection
                 point if an intersection is detected.
                 * @return  {boolean}                                                 True if an intersection is detected, false otherwise.
                 */
                LineIntersect$2: function (point1, point2, point3, point4, firstIsSegment, secondIsSegment, intersectionPoint) {
                    point1 = {v:point1};
                    point2 = {v:point2};
                    point3 = {v:point3};
                    point4 = {v:point4};
                    return FarseerPhysics.Common.LineTools.LineIntersect$4(point1, point2, point3, point4, firstIsSegment, secondIsSegment, intersectionPoint);
                },
                /**
                 * This method detects if two line segments intersect,
                 and, if so, the point of intersection. 
                 Note: If two line segments are coincident, then 
                 no intersection is detected (there are actually
                 infinite intersection points).
                 *
                 * @static
                 * @public
                 * @this FarseerPhysics.Common.LineTools
                 * @memberof FarseerPhysics.Common.LineTools
                 * @param   {Microsoft.Xna.Framework.Vector2}    point1               The first point of the first line segment.
                 * @param   {Microsoft.Xna.Framework.Vector2}    point2               The second point of the first line segment.
                 * @param   {Microsoft.Xna.Framework.Vector2}    point3               The first point of the second line segment.
                 * @param   {Microsoft.Xna.Framework.Vector2}    point4               The second point of the second line segment.
                 * @param   {Microsoft.Xna.Framework.Vector2}    intersectionPoint    This is set to the intersection
                 point if an intersection is detected.
                 * @return  {boolean}                                                 True if an intersection is detected, false otherwise.
                 */
                LineIntersect$3: function (point1, point2, point3, point4, intersectionPoint) {
                    return FarseerPhysics.Common.LineTools.LineIntersect$4(point1, point2, point3, point4, true, true, intersectionPoint);
                },
                /**
                 * This method detects if two line segments intersect,
                 and, if so, the point of intersection. 
                 Note: If two line segments are coincident, then 
                 no intersection is detected (there are actually
                 infinite intersection points).
                 *
                 * @static
                 * @public
                 * @this FarseerPhysics.Common.LineTools
                 * @memberof FarseerPhysics.Common.LineTools
                 * @param   {Microsoft.Xna.Framework.Vector2}    point1               The first point of the first line segment.
                 * @param   {Microsoft.Xna.Framework.Vector2}    point2               The second point of the first line segment.
                 * @param   {Microsoft.Xna.Framework.Vector2}    point3               The first point of the second line segment.
                 * @param   {Microsoft.Xna.Framework.Vector2}    point4               The second point of the second line segment.
                 * @param   {Microsoft.Xna.Framework.Vector2}    intersectionPoint    This is set to the intersection
                 point if an intersection is detected.
                 * @return  {boolean}                                                 True if an intersection is detected, false otherwise.
                 */
                LineIntersect$1: function (point1, point2, point3, point4, intersectionPoint) {
                    point1 = {v:point1};
                    point2 = {v:point2};
                    point3 = {v:point3};
                    point4 = {v:point4};
                    return FarseerPhysics.Common.LineTools.LineIntersect$4(point1, point2, point3, point4, true, true, intersectionPoint);
                },
                /**
                 * Get all intersections between a line segment and a list of vertices
                 representing a polygon. The vertices reuse adjacent points, so for example
                 edges one and two are between the first and second vertices and between the
                 second and third vertices. The last edge is between vertex vertices.Count - 1
                 and verts0. (ie, vertices from a Geometry or AABB)
                 *
                 * @static
                 * @public
                 * @this FarseerPhysics.Common.LineTools
                 * @memberof FarseerPhysics.Common.LineTools
                 * @param   {Microsoft.Xna.Framework.Vector2}      point1                The first point of the line segment to test
                 * @param   {Microsoft.Xna.Framework.Vector2}      point2                The second point of the line segment to test.
                 * @param   {FarseerPhysics.Common.Vertices}       vertices              The vertices, as described above
                 * @param   {System.Collections.Generic.List$1}    intersectionPoints    An list of intersection points. Any intersection points
                 found will be added to this list.
                 * @return  {void}
                 */
                LineSegmentVerticesIntersect: function (point1, point2, vertices, intersectionPoints) {
                    for (var i = 0; i < vertices.Count; i = (i + 1) | 0) {
                        var point = { v : new Microsoft.Xna.Framework.Vector2() };
                        if (FarseerPhysics.Common.LineTools.LineIntersect$2(vertices.getItem(i).$clone(), vertices.getItem(vertices.NextIndex(i)).$clone(), point1.v.$clone(), point2.v.$clone(), true, true, point)) {
                            intersectionPoints.v.add(point.v.$clone());
                        }
                    }
                },
                /**
                 * Get all intersections between a line segment and an AABB.
                 *
                 * @static
                 * @public
                 * @this FarseerPhysics.Common.LineTools
                 * @memberof FarseerPhysics.Common.LineTools
                 * @param   {Microsoft.Xna.Framework.Vector2}      point1                The first point of the line segment to test
                 * @param   {Microsoft.Xna.Framework.Vector2}      point2                The second point of the line segment to test.
                 * @param   {FarseerPhysics.Collision.AABB}        aabb                  The AABB that is used for testing intersection.
                 * @param   {System.Collections.Generic.List$1}    intersectionPoints    An list of intersection points. Any intersection points found will be added to this list.
                 * @return  {void}
                 */
                LineSegmentAABBIntersect: function (point1, point2, aabb, intersectionPoints) {
                    FarseerPhysics.Common.LineTools.LineSegmentVerticesIntersect(point1, point2, aabb.Vertices, intersectionPoints);
                }
            }
        }
    });

    Bridge.define("FarseerPhysics.Common.MarchingSquares", {
        statics: {
            fields: {
                _lookMarch: null
            },
            ctors: {
                init: function () {
                    this._lookMarch = System.Array.init([
                        0, 
                        224, 
                        56, 
                        216, 
                        14, 
                        238, 
                        54, 
                        214, 
                        131, 
                        99, 
                        187, 
                        91, 
                        141, 
                        109, 
                        181, 
                        85
                    ], System.Int32);
                }
            },
            methods: {
                /**
                 * Marching squares over the given domain using the mesh defined via the dimensions
                    (wid,hei) to build a set of polygons such that f(x,y) less than 0, using the given number
                    'bin' for recursive linear inteprolation along cell boundaries.
                    if 'comb' is true, then the polygons will also be composited into larger possible concave
                    polygons.
                 *
                 * @static
                 * @public
                 * @this FarseerPhysics.Common.MarchingSquares
                 * @memberof FarseerPhysics.Common.MarchingSquares
                 * @param   {FarseerPhysics.Collision.AABB}        domain        
                 * @param   {number}                               cellWidth     
                 * @param   {number}                               cellHeight    
                 * @param   {Array.<number>}                       f             
                 * @param   {number}                               lerpCount     
                 * @param   {boolean}                              combine
                 * @return  {System.Collections.Generic.List$1}
                 */
                DetectSquares: function (domain, cellWidth, cellHeight, f, lerpCount, combine) {
                    var $t, $t1;
                    var ret = new (FarseerPhysics.Common.MarchingSquares.CxFastList$1(FarseerPhysics.Common.MarchingSquares.GeomPoly))();

                    var verticesList = new (System.Collections.Generic.List$1(FarseerPhysics.Common.Vertices)).ctor();

                    var polyList;
                    var gp = { };

                    var xn = Bridge.Int.clip32(domain.Extents.X * 2 / cellWidth);
                    var xp = xn === (domain.Extents.X * 2 / cellWidth);
                    var yn = Bridge.Int.clip32(domain.Extents.Y * 2 / cellHeight);
                    var yp = yn === (domain.Extents.Y * 2 / cellHeight);
                    if (!xp) {
                        xn = (xn + 1) | 0;
                    }
                    if (!yp) {
                        yn = (yn + 1) | 0;
                    }

                    var fs = System.Array.create(0, null, System.SByte, ((xn + 1) | 0), ((yn + 1) | 0));
                    var ps = System.Array.create(null, null, FarseerPhysics.Common.MarchingSquares.GeomPolyVal, ((xn + 1) | 0), ((yn + 1) | 0));

                    for (var x = 0; x < ((xn + 1) | 0); x = (x + 1) | 0) {
                        var x0;
                        if (x === xn) {
                            x0 = Bridge.Int.clip32(domain.UpperBound.X);
                        } else {
                            x0 = Bridge.Int.clip32(x * cellWidth + domain.LowerBound.X);
                        }
                        for (var y = 0; y < ((yn + 1) | 0); y = (y + 1) | 0) {
                            var y0;
                            if (y === yn) {
                                y0 = Bridge.Int.clip32(domain.UpperBound.Y);
                            } else {
                                y0 = Bridge.Int.clip32(y * cellHeight + domain.LowerBound.Y);
                            }
                            fs.set([x, y], f.get([x0, y0]));
                        }
                    }

                    for (var y1 = 0; y1 < yn; y1 = (y1 + 1) | 0) {
                        var y01 = y1 * cellHeight + domain.LowerBound.Y;
                        var y11;
                        if (y1 === ((yn - 1) | 0)) {
                            y11 = domain.UpperBound.Y;
                        } else {
                            y11 = y01 + cellHeight;
                        }
                        var pre = { v : null };
                        for (var x1 = 0; x1 < xn; x1 = (x1 + 1) | 0) {
                            var x01 = x1 * cellWidth + domain.LowerBound.X;
                            var x11;
                            if (x1 === ((xn - 1) | 0)) {
                                x11 = domain.UpperBound.X;
                            } else {
                                x11 = x01 + cellWidth;
                            }

                            gp.v = new FarseerPhysics.Common.MarchingSquares.GeomPoly();

                            var key = FarseerPhysics.Common.MarchingSquares.MarchSquare(f, fs, gp, x1, y1, x01, y01, x11, y11, lerpCount);
                            if (gp.v.Length !== 0) {
                                if (combine && pre.v != null && (key & 9) !== 0) {
                                    FarseerPhysics.Common.MarchingSquares.combLeft(pre, gp);
                                    gp.v = pre.v;
                                } else {
                                    ret.Add(gp.v);
                                }
                                ps.set([x1, y1], new FarseerPhysics.Common.MarchingSquares.GeomPolyVal(gp.v, key));
                            } else {
                                gp.v = null;
                            }
                            pre.v = gp.v;
                        }
                    }
                    if (!combine) {
                        polyList = ret.GetListOfElements();

                        $t = Bridge.getEnumerator(polyList);
                        try {
                            while ($t.moveNext()) {
                                var poly = $t.Current;
                                verticesList.add(new FarseerPhysics.Common.Vertices.$ctor2(poly.Points.GetListOfElements()));
                            }
                        } finally {
                            if (Bridge.is($t, System.IDisposable)) {
                                $t.System$IDisposable$Dispose();
                            }
                        }
                        return verticesList;
                    }

                    for (var y2 = 1; y2 < yn; y2 = (y2 + 1) | 0) {
                        var x2 = 0;
                        while (x2 < xn) {
                            var p = ps.get([x2, y2]);

                            if (p == null) {
                                x2 = (x2 + 1) | 0;
                                continue;
                            }

                            if ((p.Key & 12) === 0) {
                                x2 = (x2 + 1) | 0;
                                continue;
                            }

                            var u = ps.get([x2, ((y2 - 1) | 0)]);
                            if (u == null) {
                                x2 = (x2 + 1) | 0;
                                continue;
                            }

                            if ((u.Key & 3) === 0) {
                                x2 = (x2 + 1) | 0;
                                continue;
                            }

                            var ax = x2 * cellWidth + domain.LowerBound.X;
                            var ay = y2 * cellHeight + domain.LowerBound.Y;

                            var bp = p.GeomP.Points;
                            var ap = u.GeomP.Points;

                            if (Bridge.referenceEquals(u.GeomP, p.GeomP)) {
                                x2 = (x2 + 1) | 0;
                                continue;
                            }

                            var bi = bp.Begin();
                            while (FarseerPhysics.Common.MarchingSquares.Square(bi.Elem().Y - ay) > FarseerPhysics.Settings.Epsilon || bi.Elem().X < ax) {
                                bi = bi.Next();
                            }

                            var b1 = bi.Next().Elem().$clone();
                            if (FarseerPhysics.Common.MarchingSquares.Square(b1.Y - ay) > FarseerPhysics.Settings.Epsilon) {
                                x2 = (x2 + 1) | 0;
                                continue;
                            }

                            var brk = true;
                            var ai = ap.Begin();
                            while (!Bridge.referenceEquals(ai, ap.End())) {
                                if (FarseerPhysics.Common.MarchingSquares.VecDsq(ai.Elem().$clone(), b1.$clone()) < FarseerPhysics.Settings.Epsilon) {
                                    brk = false;
                                    break;
                                }
                                ai = ai.Next();
                            }
                            if (brk) {
                                x2 = (x2 + 1) | 0;
                                continue;
                            }

                            var bj = bi.Next().Next();
                            if (Bridge.referenceEquals(bj, bp.End())) {
                                bj = bp.Begin();
                            }
                            while (!Bridge.referenceEquals(bj, bi)) {
                                ai = ap.Insert(ai, bj.Elem().$clone());
                                bj = bj.Next();
                                if (Bridge.referenceEquals(bj, bp.End())) {
                                    bj = bp.Begin();
                                }
                                u.GeomP.Length = (u.GeomP.Length + 1) | 0;
                            }
                            ax = (x2 + 1) | 0;
                            while (ax < xn) {
                                var p2 = ps.get([Bridge.Int.clip32(ax), y2]);
                                if (p2 == null || !Bridge.referenceEquals(p2.GeomP, p.GeomP)) {
                                    ax++;
                                    continue;
                                }
                                p2.GeomP = u.GeomP;
                                ax++;
                            }
                            ax = (x2 - 1) | 0;
                            while (ax >= 0) {
                                var p21 = ps.get([Bridge.Int.clip32(ax), y2]);
                                if (p21 == null || !Bridge.referenceEquals(p21.GeomP, p.GeomP)) {
                                    ax--;
                                    continue;
                                }
                                p21.GeomP = u.GeomP;
                                ax--;
                            }
                            ret.Remove(p.GeomP);
                            p.GeomP = u.GeomP;

                            x2 = (Bridge.Int.clip32(((bi.Next().Elem().X - domain.LowerBound.X) / cellWidth)) + 1) | 0;
                        }
                    }

                    polyList = ret.GetListOfElements();

                    $t1 = Bridge.getEnumerator(polyList);
                    try {
                        while ($t1.moveNext()) {
                            var poly1 = $t1.Current;
                            verticesList.add(new FarseerPhysics.Common.Vertices.$ctor2(poly1.Points.GetListOfElements()));
                        }
                    } finally {
                        if (Bridge.is($t1, System.IDisposable)) {
                            $t1.System$IDisposable$Dispose();
                        }
                    }
                    return verticesList;
                },
                Lerp: function (x0, x1, v0, v1) {
                    var dv = v0 - v1;
                    var t;
                    if (dv * dv < FarseerPhysics.Settings.Epsilon) {
                        t = 0.5;
                    } else {
                        t = v0 / dv;
                    }
                    return x0 + t * (x1 - x0);
                },
                Xlerp: function (x0, x1, y, v0, v1, f, c) {
                    var xm = FarseerPhysics.Common.MarchingSquares.Lerp(x0, x1, v0, v1);
                    if (c === 0) {
                        return xm;
                    }

                    var vm = f.get([Bridge.Int.clip32(xm), Bridge.Int.clip32(y)]);

                    if (v0 * vm < 0) {
                        return FarseerPhysics.Common.MarchingSquares.Xlerp(x0, xm, y, v0, vm, f, ((c - 1) | 0));
                    }

                    return FarseerPhysics.Common.MarchingSquares.Xlerp(xm, x1, y, vm, v1, f, ((c - 1) | 0));
                },
                Ylerp: function (y0, y1, x, v0, v1, f, c) {
                    var ym = FarseerPhysics.Common.MarchingSquares.Lerp(y0, y1, v0, v1);
                    if (c === 0) {
                        return ym;
                    }

                    var vm = f.get([Bridge.Int.clip32(x), Bridge.Int.clip32(ym)]);

                    if (v0 * vm < 0) {
                        return FarseerPhysics.Common.MarchingSquares.Ylerp(y0, ym, x, v0, vm, f, ((c - 1) | 0));
                    }

                    return FarseerPhysics.Common.MarchingSquares.Ylerp(ym, y1, x, vm, v1, f, ((c - 1) | 0));
                },
                Square: function (x) {
                    return x * x;
                },
                VecDsq: function (a, b) {
                    var d = Microsoft.Xna.Framework.Vector2.op_Subtraction(a.$clone(), b.$clone());
                    return d.X * d.X + d.Y * d.Y;
                },
                VecCross: function (a, b) {
                    return a.X * b.Y - a.Y * b.X;
                },
                MarchSquare: function (f, fs, poly, ax, ay, x0, y0, x1, y1, bin) {
                    var key = 0;
                    var v0 = fs.get([ax, ay]);
                    if (v0 < 0) {
                        key = key | 8;
                    }
                    var v1 = fs.get([((ax + 1) | 0), ay]);
                    if (v1 < 0) {
                        key = key | 4;
                    }
                    var v2 = fs.get([((ax + 1) | 0), ((ay + 1) | 0)]);
                    if (v2 < 0) {
                        key = key | 2;
                    }
                    var v3 = fs.get([ax, ((ay + 1) | 0)]);
                    if (v3 < 0) {
                        key = key | 1;
                    }

                    var val = FarseerPhysics.Common.MarchingSquares._lookMarch[System.Array.index(key, FarseerPhysics.Common.MarchingSquares._lookMarch)];
                    if (val !== 0) {
                        var pi = null;
                        for (var i = 0; i < 8; i = (i + 1) | 0) {
                            var p = new Microsoft.Xna.Framework.Vector2();
                            if ((val & (1 << i)) !== 0) {
                                if (i === 7 && (val & 1) === 0) {
                                    poly.v.Points.Add((p = new Microsoft.Xna.Framework.Vector2.$ctor2(x0, FarseerPhysics.Common.MarchingSquares.Ylerp(y0, y1, x0, v0, v3, f, bin))).$clone());
                                } else {
                                    if (i === 0) {
                                        p = new Microsoft.Xna.Framework.Vector2.$ctor2(x0, y0);
                                    } else {
                                        if (i === 2) {
                                            p = new Microsoft.Xna.Framework.Vector2.$ctor2(x1, y0);
                                        } else {
                                            if (i === 4) {
                                                p = new Microsoft.Xna.Framework.Vector2.$ctor2(x1, y1);
                                            } else {
                                                if (i === 6) {
                                                    p = new Microsoft.Xna.Framework.Vector2.$ctor2(x0, y1);
                                                } else {
                                                    if (i === 1) {
                                                        p = new Microsoft.Xna.Framework.Vector2.$ctor2(FarseerPhysics.Common.MarchingSquares.Xlerp(x0, x1, y0, v0, v1, f, bin), y0);
                                                    } else {
                                                        if (i === 5) {
                                                            p = new Microsoft.Xna.Framework.Vector2.$ctor2(FarseerPhysics.Common.MarchingSquares.Xlerp(x0, x1, y1, v3, v2, f, bin), y1);
                                                        } else {
                                                            if (i === 3) {
                                                                p = new Microsoft.Xna.Framework.Vector2.$ctor2(x1, FarseerPhysics.Common.MarchingSquares.Ylerp(y0, y1, x1, v1, v2, f, bin));
                                                            } else {
                                                                p = new Microsoft.Xna.Framework.Vector2.$ctor2(x0, FarseerPhysics.Common.MarchingSquares.Ylerp(y0, y1, x0, v0, v3, f, bin));
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }

                                    pi = poly.v.Points.Insert(pi, p.$clone());
                                }
                                poly.v.Length = (poly.v.Length + 1) | 0;
                            }
                        }
                    }
                    return key;
                },
                combLeft: function (polya, polyb) {
                    var ap = polya.v.Points;
                    var bp = polyb.v.Points;
                    var ai = ap.Begin();
                    var bi = bp.Begin();

                    var b = bi.Elem().$clone();
                    var prea = null;
                    while (!Bridge.referenceEquals(ai, ap.End())) {
                        var a = ai.Elem().$clone();
                        if (FarseerPhysics.Common.MarchingSquares.VecDsq(a.$clone(), b.$clone()) < FarseerPhysics.Settings.Epsilon) {
                            if (prea != null) {
                                var a0 = prea.Elem().$clone();
                                b = bi.Next().Elem().$clone();

                                var u = Microsoft.Xna.Framework.Vector2.op_Subtraction(a.$clone(), a0.$clone());
                                var v = Microsoft.Xna.Framework.Vector2.op_Subtraction(b.$clone(), a.$clone());
                                var dot = FarseerPhysics.Common.MarchingSquares.VecCross(u.$clone(), v.$clone());
                                if (dot * dot < FarseerPhysics.Settings.Epsilon) {
                                    ap.Erase(prea, ai);
                                    polya.v.Length = (polya.v.Length - 1) | 0;
                                    ai = prea;
                                }
                            }

                            var fst = true;
                            var preb = null;
                            while (!bp.Empty()) {
                                var bb = bp.Front().$clone();
                                bp.Pop();
                                if (!fst && !bp.Empty()) {
                                    ai = ap.Insert(ai, bb.$clone());
                                    polya.v.Length = (polya.v.Length + 1) | 0;
                                    preb = ai;
                                }
                                fst = false;
                            }

                            ai = ai.Next();
                            var a1 = ai.Elem().$clone();
                            ai = ai.Next();
                            if (Bridge.referenceEquals(ai, ap.End())) {
                                ai = ap.Begin();
                            }
                            var a2 = ai.Elem().$clone();
                            var a00 = preb.Elem().$clone();
                            var uu = Microsoft.Xna.Framework.Vector2.op_Subtraction(a1.$clone(), a00.$clone());
                            var vv = Microsoft.Xna.Framework.Vector2.op_Subtraction(a2.$clone(), a1.$clone());
                            var dot1 = FarseerPhysics.Common.MarchingSquares.VecCross(uu.$clone(), vv.$clone());
                            if (dot1 * dot1 < FarseerPhysics.Settings.Epsilon) {
                                ap.Erase(preb, preb.Next());
                                polya.v.Length = (polya.v.Length - 1) | 0;
                            }

                            return;
                        }
                        prea = ai;
                        ai = ai.Next();
                    }
                }
            }
        }
    });

    /**
     * Designed as a complete port of CxFastList from CxStd.
     *
     * @class FarseerPhysics.Common.MarchingSquares.CxFastList$1
     */
    Bridge.define("FarseerPhysics.Common.MarchingSquares.CxFastList$1", function (T) { return {
        $kind: "nested class",
        fields: {
            _head: null,
            _count: 0
        },
        methods: {
            /**
             * Iterator to start of list (O(1))
             *
             * @instance
             * @public
             * @this FarseerPhysics.Common.MarchingSquares.CxFastList$1
             * @memberof FarseerPhysics.Common.MarchingSquares.CxFastList$1
             * @return  {FarseerPhysics.Common.MarchingSquares.CxFastListNode$1}
             */
            Begin: function () {
                return this._head;
            },
            /**
             * Iterator to end of list (O(1))
             *
             * @instance
             * @public
             * @this FarseerPhysics.Common.MarchingSquares.CxFastList$1
             * @memberof FarseerPhysics.Common.MarchingSquares.CxFastList$1
             * @return  {FarseerPhysics.Common.MarchingSquares.CxFastListNode$1}
             */
            End: function () {
                return null;
            },
            /**
             * Returns first element of list (O(1))
             *
             * @instance
             * @public
             * @this FarseerPhysics.Common.MarchingSquares.CxFastList$1
             * @memberof FarseerPhysics.Common.MarchingSquares.CxFastList$1
             * @return  {T}
             */
            Front: function () {
                return this._head.Elem();
            },
            /**
             * add object to list (O(1))
             *
             * @instance
             * @public
             * @this FarseerPhysics.Common.MarchingSquares.CxFastList$1
             * @memberof FarseerPhysics.Common.MarchingSquares.CxFastList$1
             * @param   {T}                                                         value
             * @return  {FarseerPhysics.Common.MarchingSquares.CxFastListNode$1}
             */
            Add: function (value) {
                var newNode = new (FarseerPhysics.Common.MarchingSquares.CxFastListNode$1(T))(value);
                if (this._head == null) {
                    newNode._next = null;
                    this._head = newNode;
                    this._count = (this._count + 1) | 0;
                    return newNode;
                }
                newNode._next = this._head;
                this._head = newNode;

                this._count = (this._count + 1) | 0;

                return newNode;
            },
            /**
             * remove object from list, returns true if an element was removed (O(n))
             *
             * @instance
             * @public
             * @this FarseerPhysics.Common.MarchingSquares.CxFastList$1
             * @memberof FarseerPhysics.Common.MarchingSquares.CxFastList$1
             * @param   {T}          value
             * @return  {boolean}
             */
            Remove: function (value) {
                var head = this._head;
                var prev = this._head;

                var comparer = System.Collections.Generic.EqualityComparer$1(T).def;

                if (head != null) {
                    if (value != null) {
                        do {
                            if (comparer.equals2(head._elt, value)) {
                                if (Bridge.referenceEquals(head, this._head)) {
                                    this._head = head._next;
                                    this._count = (this._count - 1) | 0;
                                    return true;
                                } else {
                                    prev._next = head._next;
                                    this._count = (this._count - 1) | 0;
                                    return true;
                                }
                            }
                            prev = head;
                            head = head._next;
                        } while (head != null);
                    }
                }
                return false;
            },
            /**
             * pop element from head of list (O(1)) Note: this does not return the object popped! 
             There is good reason to this, and it regards the Alloc list variants which guarantee 
             objects are released to the object pool. You do not want to retrieve an element 
             through pop or else that object may suddenly be used by another piece of code which 
             retrieves it from the object pool.
             *
             * @instance
             * @public
             * @this FarseerPhysics.Common.MarchingSquares.CxFastList$1
             * @memberof FarseerPhysics.Common.MarchingSquares.CxFastList$1
             * @return  {FarseerPhysics.Common.MarchingSquares.CxFastListNode$1}
             */
            Pop: function () {
                return this.Erase(null, this._head);
            },
            /**
             * insert object after 'node' returning an iterator to the inserted object.
             *
             * @instance
             * @public
             * @this FarseerPhysics.Common.MarchingSquares.CxFastList$1
             * @memberof FarseerPhysics.Common.MarchingSquares.CxFastList$1
             * @param   {FarseerPhysics.Common.MarchingSquares.CxFastListNode$1}    node     
             * @param   {T}                                                         value
             * @return  {FarseerPhysics.Common.MarchingSquares.CxFastListNode$1}
             */
            Insert: function (node, value) {
                if (node == null) {
                    return this.Add(value);
                }
                var newNode = new (FarseerPhysics.Common.MarchingSquares.CxFastListNode$1(T))(value);
                var nextNode = node._next;
                newNode._next = nextNode;
                node._next = newNode;

                this._count = (this._count + 1) | 0;

                return newNode;
            },
            /**
             * removes the element pointed to by 'node' with 'prev' being the previous iterator, 
             returning an iterator to the element following that of 'node' (O(1))
             *
             * @instance
             * @public
             * @this FarseerPhysics.Common.MarchingSquares.CxFastList$1
             * @memberof FarseerPhysics.Common.MarchingSquares.CxFastList$1
             * @param   {FarseerPhysics.Common.MarchingSquares.CxFastListNode$1}    prev    
             * @param   {FarseerPhysics.Common.MarchingSquares.CxFastListNode$1}    node
             * @return  {FarseerPhysics.Common.MarchingSquares.CxFastListNode$1}
             */
            Erase: function (prev, node) {
                var nextNode = node._next;
                if (prev != null) {
                    prev._next = nextNode;
                } else {
                    if (this._head != null) {
                        this._head = this._head._next;
                    } else {
                        return null;
                    }
                }

                this._count = (this._count - 1) | 0;
                return nextNode;
            },
            /**
             * whether the list is empty (O(1))
             *
             * @instance
             * @public
             * @this FarseerPhysics.Common.MarchingSquares.CxFastList$1
             * @memberof FarseerPhysics.Common.MarchingSquares.CxFastList$1
             * @return  {boolean}
             */
            Empty: function () {
                if (this._head == null) {
                    return true;
                }
                return false;
            },
            /**
             * computes size of list (O(n))
             *
             * @instance
             * @public
             * @this FarseerPhysics.Common.MarchingSquares.CxFastList$1
             * @memberof FarseerPhysics.Common.MarchingSquares.CxFastList$1
             * @return  {number}
             */
            Size: function () {
                var i = this.Begin();
                var count = 0;

                do {
                    count = (count + 1) | 0;
                } while (i.Next() != null);

                return count;
            },
            /**
             * empty the list (O(1) if CxMixList, O(n) otherwise)
             *
             * @instance
             * @public
             * @this FarseerPhysics.Common.MarchingSquares.CxFastList$1
             * @memberof FarseerPhysics.Common.MarchingSquares.CxFastList$1
             * @return  {void}
             */
            Clear: function () {
                var head = this._head;
                while (head != null) {
                    var node2 = head;
                    head = head._next;
                    node2._next = null;
                }
                this._head = null;
                this._count = 0;
            },
            /**
             * returns true if 'value' is an element of the list (O(n))
             *
             * @instance
             * @public
             * @this FarseerPhysics.Common.MarchingSquares.CxFastList$1
             * @memberof FarseerPhysics.Common.MarchingSquares.CxFastList$1
             * @param   {T}          value
             * @return  {boolean}
             */
            Has: function (value) {
                return (this.Find(value) != null);
            },
            Find: function (value) {
                var head = this._head;
                var comparer = System.Collections.Generic.EqualityComparer$1(T).def;
                if (head != null) {
                    if (value != null) {
                        do {
                            if (comparer.equals2(head._elt, value)) {
                                return head;
                            }
                            head = head._next;
                        } while (!Bridge.referenceEquals(head, this._head));
                    } else {
                        do {
                            if (head._elt == null) {
                                return head;
                            }
                            head = head._next;
                        } while (!Bridge.referenceEquals(head, this._head));
                    }
                }
                return null;
            },
            GetListOfElements: function () {
                var list = new (System.Collections.Generic.List$1(T)).ctor();

                var iter = this.Begin();

                if (iter != null) {
                    do {
                        list.add(iter._elt);
                        iter = iter._next;
                    } while (iter != null);
                }
                return list;
            }
        }
    }; });

    Bridge.define("FarseerPhysics.Common.MarchingSquares.CxFastListNode$1", function (T) { return {
        $kind: "nested class",
        fields: {
            _elt: Bridge.getDefaultValue(T),
            _next: null
        },
        ctors: {
            ctor: function (obj) {
                this.$initialize();
                this._elt = obj;
            }
        },
        methods: {
            Elem: function () {
                return this._elt;
            },
            Next: function () {
                return this._next;
            }
        }
    }; });

    Bridge.define("FarseerPhysics.Common.MarchingSquares.GeomPoly", {
        $kind: "nested class",
        fields: {
            Length: 0,
            Points: null
        },
        ctors: {
            ctor: function () {
                this.$initialize();
                this.Points = new (FarseerPhysics.Common.MarchingSquares.CxFastList$1(Microsoft.Xna.Framework.Vector2))();
                this.Length = 0;
            }
        }
    });

    Bridge.define("FarseerPhysics.Common.MarchingSquares.GeomPolyVal", {
        $kind: "nested class",
        fields: {
            Key: 0,
            GeomP: null
        },
        ctors: {
            ctor: function (geomP, K) {
                this.$initialize();
                this.GeomP = geomP;
                this.Key = K;
            }
        }
    });

    /**
     * A 2-by-2 matrix. Stored in column-major order.
     *
     * @public
     * @class FarseerPhysics.Common.Mat22
     */
    Bridge.define("FarseerPhysics.Common.Mat22", {
        $kind: "struct",
        statics: {
            methods: {
                Add: function (A, B, R) {
                    R.v.Col1 = Microsoft.Xna.Framework.Vector2.op_Addition(A.v.Col1.$clone(), B.v.Col1.$clone());
                    R.v.Col2 = Microsoft.Xna.Framework.Vector2.op_Addition(A.v.Col2.$clone(), B.v.Col2.$clone());
                },
                getDefaultValue: function () { return new FarseerPhysics.Common.Mat22(); }
            }
        },
        fields: {
            Col1: null,
            Col2: null
        },
        props: {
            /**
             * Extract the angle from this matrix (assumed to be
             a rotation matrix).
             *
             * @instance
             * @public
             * @readonly
             * @memberof FarseerPhysics.Common.Mat22
             * @function Angle
             * @type number
             */
            Angle: {
                get: function () {
                    return Math.atan2(this.Col1.Y, this.Col1.X);
                }
            },
            Inverse: {
                get: function () {
                    var a = this.Col1.X, b = this.Col2.X, c = this.Col1.Y, d = this.Col2.Y;
                    var det = a * d - b * c;
                    if (det !== 0.0) {
                        det = 1.0 / det;
                    }

                    var result = new FarseerPhysics.Common.Mat22.ctor();
                    result.Col1.X = det * d;
                    result.Col1.Y = -det * c;

                    result.Col2.X = -det * b;
                    result.Col2.Y = det * a;

                    return result.$clone();
                }
            }
        },
        ctors: {
            init: function () {
                this.Col1 = new Microsoft.Xna.Framework.Vector2();
                this.Col2 = new Microsoft.Xna.Framework.Vector2();
            },
            /**
             * Construct this matrix using columns.
             *
             * @instance
             * @public
             * @this FarseerPhysics.Common.Mat22
             * @memberof FarseerPhysics.Common.Mat22
             * @param   {Microsoft.Xna.Framework.Vector2}    c1    The c1.
             * @param   {Microsoft.Xna.Framework.Vector2}    c2    The c2.
             * @return  {void}
             */
            $ctor1: function (c1, c2) {
                this.$initialize();
                this.Col1 = c1.$clone();
                this.Col2 = c2.$clone();
            },
            /**
             * Construct this matrix using scalars.
             *
             * @instance
             * @public
             * @this FarseerPhysics.Common.Mat22
             * @memberof FarseerPhysics.Common.Mat22
             * @param   {number}    a11    The a11.
             * @param   {number}    a12    The a12.
             * @param   {number}    a21    The a21.
             * @param   {number}    a22    The a22.
             * @return  {void}
             */
            $ctor3: function (a11, a12, a21, a22) {
                this.$initialize();
                this.Col1 = new Microsoft.Xna.Framework.Vector2.$ctor2(a11, a21);
                this.Col2 = new Microsoft.Xna.Framework.Vector2.$ctor2(a12, a22);
            },
            /**
             * Construct this matrix using an angle. This matrix becomes
             an orthonormal rotation matrix.
             *
             * @instance
             * @public
             * @this FarseerPhysics.Common.Mat22
             * @memberof FarseerPhysics.Common.Mat22
             * @param   {number}    angle    The angle.
             * @return  {void}
             */
            $ctor2: function (angle) {
                this.$initialize();
                var c = Math.cos(angle), s = Math.sin(angle);
                this.Col1 = new Microsoft.Xna.Framework.Vector2.$ctor2(c, s);
                this.Col2 = new Microsoft.Xna.Framework.Vector2.$ctor2(-s, c);
            },
            ctor: function () {
                this.$initialize();
            }
        },
        methods: {
            /**
             * Initialize this matrix using columns.
             *
             * @instance
             * @public
             * @this FarseerPhysics.Common.Mat22
             * @memberof FarseerPhysics.Common.Mat22
             * @param   {Microsoft.Xna.Framework.Vector2}    c1    The c1.
             * @param   {Microsoft.Xna.Framework.Vector2}    c2    The c2.
             * @return  {void}
             */
            Set: function (c1, c2) {
                this.Col1 = c1.$clone();
                this.Col2 = c2.$clone();
            },
            /**
             * Initialize this matrix using an angle. This matrix becomes
             an orthonormal rotation matrix.
             *
             * @instance
             * @public
             * @this FarseerPhysics.Common.Mat22
             * @memberof FarseerPhysics.Common.Mat22
             * @param   {number}    angle    The angle.
             * @return  {void}
             */
            Set$1: function (angle) {
                var c = Math.cos(angle), s = Math.sin(angle);
                this.Col1.X = c;
                this.Col2.X = -s;
                this.Col1.Y = s;
                this.Col2.Y = c;
            },
            /**
             * Set this to the identity matrix.
             *
             * @instance
             * @public
             * @this FarseerPhysics.Common.Mat22
             * @memberof FarseerPhysics.Common.Mat22
             * @return  {void}
             */
            SetIdentity: function () {
                this.Col1.X = 1.0;
                this.Col2.X = 0.0;
                this.Col1.Y = 0.0;
                this.Col2.Y = 1.0;
            },
            /**
             * Set this matrix to all zeros.
             *
             * @instance
             * @public
             * @this FarseerPhysics.Common.Mat22
             * @memberof FarseerPhysics.Common.Mat22
             * @return  {void}
             */
            SetZero: function () {
                this.Col1.X = 0.0;
                this.Col2.X = 0.0;
                this.Col1.Y = 0.0;
                this.Col2.Y = 0.0;
            },
            /**
             * Solve A * x = b, where b is a column vector. This is more efficient
             than computing the inverse in one-shot cases.
             *
             * @instance
             * @public
             * @this FarseerPhysics.Common.Mat22
             * @memberof FarseerPhysics.Common.Mat22
             * @param   {Microsoft.Xna.Framework.Vector2}    b    The b.
             * @return  {Microsoft.Xna.Framework.Vector2}
             */
            Solve: function (b) {
                var a11 = this.Col1.X, a12 = this.Col2.X, a21 = this.Col1.Y, a22 = this.Col2.Y;
                var det = a11 * a22 - a12 * a21;
                if (det !== 0.0) {
                    det = 1.0 / det;
                }

                return new Microsoft.Xna.Framework.Vector2.$ctor2(det * (a22 * b.X - a12 * b.Y), det * (a11 * b.Y - a21 * b.X));
            },
            getHashCode: function () {
                var h = Bridge.addHash([846487935, this.Col1, this.Col2]);
                return h;
            },
            equals: function (o) {
                if (!Bridge.is(o, FarseerPhysics.Common.Mat22)) {
                    return false;
                }
                return Bridge.equals(this.Col1, o.Col1) && Bridge.equals(this.Col2, o.Col2);
            },
            $clone: function (to) {
                var s = to || new FarseerPhysics.Common.Mat22();
                s.Col1 = this.Col1.$clone();
                s.Col2 = this.Col2.$clone();
                return s;
            }
        }
    });

    /**
     * A 3-by-3 matrix. Stored in column-major order.
     *
     * @public
     * @class FarseerPhysics.Common.Mat33
     */
    Bridge.define("FarseerPhysics.Common.Mat33", {
        $kind: "struct",
        statics: {
            methods: {
                getDefaultValue: function () { return new FarseerPhysics.Common.Mat33(); }
            }
        },
        fields: {
            Col1: null,
            Col2: null,
            Col3: null
        },
        ctors: {
            init: function () {
                this.Col1 = new Microsoft.Xna.Framework.Vector3();
                this.Col2 = new Microsoft.Xna.Framework.Vector3();
                this.Col3 = new Microsoft.Xna.Framework.Vector3();
            },
            /**
             * Construct this matrix using columns.
             *
             * @instance
             * @public
             * @this FarseerPhysics.Common.Mat33
             * @memberof FarseerPhysics.Common.Mat33
             * @param   {Microsoft.Xna.Framework.Vector3}    c1    The c1.
             * @param   {Microsoft.Xna.Framework.Vector3}    c2    The c2.
             * @param   {Microsoft.Xna.Framework.Vector3}    c3    The c3.
             * @return  {void}
             */
            $ctor1: function (c1, c2, c3) {
                this.$initialize();
                this.Col1 = c1.$clone();
                this.Col2 = c2.$clone();
                this.Col3 = c3.$clone();
            },
            ctor: function () {
                this.$initialize();
            }
        },
        methods: {
            /**
             * Set this matrix to all zeros.
             *
             * @instance
             * @public
             * @this FarseerPhysics.Common.Mat33
             * @memberof FarseerPhysics.Common.Mat33
             * @return  {void}
             */
            SetZero: function () {
                this.Col1 = Microsoft.Xna.Framework.Vector3.Zero.$clone();
                this.Col2 = Microsoft.Xna.Framework.Vector3.Zero.$clone();
                this.Col3 = Microsoft.Xna.Framework.Vector3.Zero.$clone();
            },
            /**
             * Solve A * x = b, where b is a column vector. This is more efficient
             than computing the inverse in one-shot cases.
             *
             * @instance
             * @public
             * @this FarseerPhysics.Common.Mat33
             * @memberof FarseerPhysics.Common.Mat33
             * @param   {Microsoft.Xna.Framework.Vector3}    b    The b.
             * @return  {Microsoft.Xna.Framework.Vector3}
             */
            Solve33: function (b) {
                var det = Microsoft.Xna.Framework.Vector3.Dot(this.Col1.$clone(), Microsoft.Xna.Framework.Vector3.Cross(this.Col2.$clone(), this.Col3.$clone()));
                if (det !== 0.0) {
                    det = 1.0 / det;
                }

                return new Microsoft.Xna.Framework.Vector3.$ctor3(det * Microsoft.Xna.Framework.Vector3.Dot(b.$clone(), Microsoft.Xna.Framework.Vector3.Cross(this.Col2.$clone(), this.Col3.$clone())), det * Microsoft.Xna.Framework.Vector3.Dot(this.Col1.$clone(), Microsoft.Xna.Framework.Vector3.Cross(b.$clone(), this.Col3.$clone())), det * Microsoft.Xna.Framework.Vector3.Dot(this.Col1.$clone(), Microsoft.Xna.Framework.Vector3.Cross(this.Col2.$clone(), b.$clone())));
            },
            /**
             * Solve A * x = b, where b is a column vector. This is more efficient
             than computing the inverse in one-shot cases. Solve only the upper
             2-by-2 matrix equation.
             *
             * @instance
             * @public
             * @this FarseerPhysics.Common.Mat33
             * @memberof FarseerPhysics.Common.Mat33
             * @param   {Microsoft.Xna.Framework.Vector2}    b    The b.
             * @return  {Microsoft.Xna.Framework.Vector2}
             */
            Solve22: function (b) {
                var a11 = this.Col1.X, a12 = this.Col2.X, a21 = this.Col1.Y, a22 = this.Col2.Y;
                var det = a11 * a22 - a12 * a21;

                if (det !== 0.0) {
                    det = 1.0 / det;
                }

                return new Microsoft.Xna.Framework.Vector2.$ctor2(det * (a22 * b.X - a12 * b.Y), det * (a11 * b.Y - a21 * b.X));
            },
            getHashCode: function () {
                var h = Bridge.addHash([863265152, this.Col1, this.Col2, this.Col3]);
                return h;
            },
            equals: function (o) {
                if (!Bridge.is(o, FarseerPhysics.Common.Mat33)) {
                    return false;
                }
                return Bridge.equals(this.Col1, o.Col1) && Bridge.equals(this.Col2, o.Col2) && Bridge.equals(this.Col3, o.Col3);
            },
            $clone: function (to) {
                var s = to || new FarseerPhysics.Common.Mat33();
                s.Col1 = this.Col1.$clone();
                s.Col2 = this.Col2.$clone();
                s.Col3 = this.Col3.$clone();
                return s;
            }
        }
    });

    Bridge.define("FarseerPhysics.Common.MathUtils", {
        statics: {
            methods: {
                IsClose: function (v1, v2, tolerence) {
                    return (Microsoft.Xna.Framework.Vector2.Distance(v1.$clone(), v2.$clone()) < tolerence);
                },
                IsEqual: function (v1, v2) {
                    return (v1.X === v2.X && v1.Y === v2.Y);
                },
                CloneVector: function (vector) {
                    return new Microsoft.Xna.Framework.Vector2.$ctor2(vector.X, vector.Y);
                },
                VectorAngle$2: function (vector) {
                    return Math.atan2(vector.Y, vector.X);
                },
                /**
                 * Return the angle between two vectors on a plane
                 The angle is from vector 1 to vector 2, positive anticlockwise
                 The result is between -pi -&gt; pi
                 *
                 * @static
                 * @public
                 * @this FarseerPhysics.Common.MathUtils
                 * @memberof FarseerPhysics.Common.MathUtils
                 * @param   {Microsoft.Xna.Framework.Vector2}    p1    
                 * @param   {Microsoft.Xna.Framework.Vector2}    p2
                 * @return  {number}
                 */
                VectorAngle$1: function (p1, p2) {
                    var theta1 = Math.atan2(p1.v.Y, p1.v.X);
                    var theta2 = Math.atan2(p2.v.Y, p2.v.X);
                    var dtheta = theta2 - theta1;
                    while (dtheta > Math.PI) {
                        dtheta -= (6.2831853071795862);
                    }
                    while (dtheta < -3.1415926535897931) {
                        dtheta += (6.2831853071795862);
                    }

                    return (dtheta);
                },
                VectorAngle: function (p1, p2) {
                    p1 = {v:p1};
                    p2 = {v:p2};
                    return FarseerPhysics.Common.MathUtils.VectorAngle$1(p1, p2);
                },
                /**
                 * Initialize a Vector using polar coordinate
                 *
                 * @static
                 * @public
                 * @this FarseerPhysics.Common.MathUtils
                 * @memberof FarseerPhysics.Common.MathUtils
                 * @param   {number}                             radius    
                 * @param   {number}                             angle
                 * @return  {Microsoft.Xna.Framework.Vector2}
                 */
                VectorPolar: function (radius, angle) {
                    return new Microsoft.Xna.Framework.Vector2.$ctor2(radius * Math.cos(angle), radius * Math.sin(angle));
                },
                Cross$2: function (a, b) {
                    return a.X * b.Y - a.Y * b.X;
                },
                Cross: function (a, s) {
                    return new Microsoft.Xna.Framework.Vector2.$ctor2(s * a.Y, -s * a.X);
                },
                Cross$1: function (s, a) {
                    return new Microsoft.Xna.Framework.Vector2.$ctor2(-s * a.Y, s * a.X);
                },
                Cross$3: function (a, b, c) {
                    c.v = a.v.X * b.v.Y - a.v.Y * b.v.X;
                },
                Cross$4: function (s, a, b) {
                    b.v = new Microsoft.Xna.Framework.Vector2.$ctor2(-s * a.v.Y, s * a.v.X);
                },
                Abs: function (v) {
                    return new Microsoft.Xna.Framework.Vector2.$ctor2(Math.abs(v.X), Math.abs(v.Y));
                },
                Multiply: function (A, v) {
                    v = {v:v};
                    return FarseerPhysics.Common.MathUtils.Multiply$1(A, v);
                },
                Multiply$1: function (A, v) {
                    return new Microsoft.Xna.Framework.Vector2.$ctor2(A.v.Col1.X * v.v.X + A.v.Col2.X * v.v.Y, A.v.Col1.Y * v.v.X + A.v.Col2.Y * v.v.Y);
                },
                Multiply$2: function (T, v) {
                    v = {v:v};
                    return FarseerPhysics.Common.MathUtils.Multiply$3(T, v);
                },
                Multiply$3: function (T, v) {
                    return new Microsoft.Xna.Framework.Vector2.$ctor2(T.v.Position.X + T.v.R.Col1.X * v.v.X + T.v.R.Col2.X * v.v.Y, T.v.Position.Y + T.v.R.Col1.Y * v.v.X + T.v.R.Col2.Y * v.v.Y);
                },
                MultiplyT: function (A, v) {
                    v = {v:v};
                    return FarseerPhysics.Common.MathUtils.MultiplyT$1(A, v);
                },
                MultiplyT$1: function (A, v) {
                    return new Microsoft.Xna.Framework.Vector2.$ctor2(v.v.X * A.v.Col1.X + v.v.Y * A.v.Col1.Y, v.v.X * A.v.Col2.X + v.v.Y * A.v.Col2.Y);
                },
                MultiplyT$2: function (T, v) {
                    v = {v:v};
                    return FarseerPhysics.Common.MathUtils.MultiplyT$3(T, v);
                },
                MultiplyT$3: function (T, v) {
                    var tmp = { v : Microsoft.Xna.Framework.Vector2.Zero.$clone() };
                    tmp.v.X = v.v.X - T.v.Position.X;
                    tmp.v.Y = v.v.Y - T.v.Position.Y;
                    return FarseerPhysics.Common.MathUtils.MultiplyT$1(Bridge.ref(T.v, "R"), tmp);
                },
                MultiplyT$4: function (A, B, C) {
                    C.v = new FarseerPhysics.Common.Mat22.ctor();
                    C.v.Col1.X = A.v.Col1.X * B.v.Col1.X + A.v.Col1.Y * B.v.Col1.Y;
                    C.v.Col1.Y = A.v.Col2.X * B.v.Col1.X + A.v.Col2.Y * B.v.Col1.Y;
                    C.v.Col2.X = A.v.Col1.X * B.v.Col2.X + A.v.Col1.Y * B.v.Col2.Y;
                    C.v.Col2.Y = A.v.Col2.X * B.v.Col2.X + A.v.Col2.Y * B.v.Col2.Y;
                },
                MultiplyT$5: function (A, B, C) {
                    C.v = new FarseerPhysics.Common.Transform.ctor();
                    FarseerPhysics.Common.MathUtils.MultiplyT$4(Bridge.ref(A.v, "R"), Bridge.ref(B.v, "R"), Bridge.ref(C.v, "R"));
                    C.v.Position.X = B.v.Position.X - A.v.Position.X;
                    C.v.Position.Y = B.v.Position.Y - A.v.Position.Y;
                },
                Swap: function (T, a, b) {
                    var tmp = a.v;
                    a.v = b.v;
                    b.v = tmp;
                },
                /**
                 * This function is used to ensure that a floating point number is
                 not a NaN or infinity.
                 *
                 * @static
                 * @public
                 * @this FarseerPhysics.Common.MathUtils
                 * @memberof FarseerPhysics.Common.MathUtils
                 * @param   {number}     x    The x.
                 * @return  {boolean}         <pre><code>true</code></pre> if the specified x is valid; otherwise, <pre><code>false</code></pre>.
                 */
                IsValid$1: function (x) {
                    if (isNaN(x)) {
                        return false;
                    }

                    return !(Math.abs(x) === Number.POSITIVE_INFINITY);
                },
                IsValid: function (x) {
                    return FarseerPhysics.Common.MathUtils.IsValid$1(x.X) && FarseerPhysics.Common.MathUtils.IsValid$1(x.Y);
                },
                /**
                 * This is a approximate yet fast inverse square-root.
                 *
                 * @static
                 * @public
                 * @this FarseerPhysics.Common.MathUtils
                 * @memberof FarseerPhysics.Common.MathUtils
                 * @param   {number}    x    The x.
                 * @return  {number}
                 */
                InvSqrt: function (x) {
                    var convert = new FarseerPhysics.Common.MathUtils.FloatConverter();
                    convert.x = x;
                    var xhalf = 0.5 * x;
                    convert.i = (1597463007 - (convert.i >> 1)) | 0;
                    x = convert.x;
                    x = x * (1.5 - xhalf * x * x);
                    return x;
                },
                Clamp$1: function (a, low, high) {
                    return Math.max(low, Math.min(a, high));
                },
                Clamp$2: function (a, low, high) {
                    return Math.max(low, Math.min(a, high));
                },
                Clamp: function (a, low, high) {
                    return Microsoft.Xna.Framework.Vector2.Max(low.$clone(), Microsoft.Xna.Framework.Vector2.Min(a.$clone(), high.$clone()));
                },
                /**
                 * Returns a positive number if c is to the left of the line going from a to b.
                 *
                 * @static
                 * @public
                 * @this FarseerPhysics.Common.MathUtils
                 * @memberof FarseerPhysics.Common.MathUtils
                 * @param   {Microsoft.Xna.Framework.Vector2}    a    
                 * @param   {Microsoft.Xna.Framework.Vector2}    b    
                 * @param   {Microsoft.Xna.Framework.Vector2}    c
                 * @return  {number}                                  Positive number if point is left, negative if point is right, 
                 and 0 if points are collinear.
                 */
                Area: function (a, b, c) {
                    a = {v:a};
                    b = {v:b};
                    c = {v:c};
                    return FarseerPhysics.Common.MathUtils.Area$1(a, b, c);
                },
                /**
                 * Returns a positive number if c is to the left of the line going from a to b.
                 *
                 * @static
                 * @public
                 * @this FarseerPhysics.Common.MathUtils
                 * @memberof FarseerPhysics.Common.MathUtils
                 * @param   {Microsoft.Xna.Framework.Vector2}    a    
                 * @param   {Microsoft.Xna.Framework.Vector2}    b    
                 * @param   {Microsoft.Xna.Framework.Vector2}    c
                 * @return  {number}                                  Positive number if point is left, negative if point is right, 
                 and 0 if points are collinear.
                 */
                Area$1: function (a, b, c) {
                    return a.v.X * (b.v.Y - c.v.Y) + b.v.X * (c.v.Y - a.v.Y) + c.v.X * (a.v.Y - b.v.Y);
                },
                /**
                 * Determines if three vertices are collinear (ie. on a straight line)
                 *
                 * @static
                 * @public
                 * @this FarseerPhysics.Common.MathUtils
                 * @memberof FarseerPhysics.Common.MathUtils
                 * @param   {Microsoft.Xna.Framework.Vector2}    a    First vertex
                 * @param   {Microsoft.Xna.Framework.Vector2}    b    Second vertex
                 * @param   {Microsoft.Xna.Framework.Vector2}    c    Third vertex
                 * @return  {boolean}
                 */
                Collinear: function (a, b, c) {
                    return FarseerPhysics.Common.MathUtils.Collinear$1(a, b, c, 0);
                },
                Collinear$1: function (a, b, c, tolerance) {
                    return FarseerPhysics.Common.MathUtils.FloatInRange(FarseerPhysics.Common.MathUtils.Area$1(a, b, c), -tolerance, tolerance);
                },
                FloatEquals: function (value1, value2) {
                    return Math.abs(value1 - value2) <= FarseerPhysics.Settings.Epsilon;
                },
                /**
                 * Checks if a floating point Value is equal to another,
                 within a certain tolerance.
                 *
                 * @static
                 * @public
                 * @this FarseerPhysics.Common.MathUtils
                 * @memberof FarseerPhysics.Common.MathUtils
                 * @param   {number}     value1    The first floating point Value.
                 * @param   {number}     value2    The second floating point Value.
                 * @param   {number}     delta     The floating point tolerance.
                 * @return  {boolean}              True if the values are "equal", false otherwise.
                 */
                FloatEquals$1: function (value1, value2, delta) {
                    return FarseerPhysics.Common.MathUtils.FloatInRange(value1, value2 - delta, value2 + delta);
                },
                /**
                 * Checks if a floating point Value is within a specified
                 range of values (inclusive).
                 *
                 * @static
                 * @public
                 * @this FarseerPhysics.Common.MathUtils
                 * @memberof FarseerPhysics.Common.MathUtils
                 * @param   {number}     value    The Value to check.
                 * @param   {number}     min      The minimum Value.
                 * @param   {number}     max      The maximum Value.
                 * @return  {boolean}             True if the Value is within the range specified,
                 false otherwise.
                 */
                FloatInRange: function (value, min, max) {
                    return (value >= min && value <= max);
                }
            }
        }
    });

    Bridge.define("FarseerPhysics.Common.MathUtils.FloatConverter", {
        $kind: "nested struct",
        statics: {
            methods: {
                getDefaultValue: function () { return new FarseerPhysics.Common.MathUtils.FloatConverter(); }
            }
        },
        fields: {
            x: 0,
            i: 0
        },
        ctors: {
            ctor: function () {
                this.$initialize();
            }
        },
        methods: {
            getHashCode: function () {
                var h = Bridge.addHash([5441161109, this.x, this.i]);
                return h;
            },
            equals: function (o) {
                if (!Bridge.is(o, FarseerPhysics.Common.MathUtils.FloatConverter)) {
                    return false;
                }
                return Bridge.equals(this.x, o.x) && Bridge.equals(this.i, o.i);
            },
            $clone: function (to) {
                var s = to || new FarseerPhysics.Common.MathUtils.FloatConverter();
                s.x = this.x;
                s.i = this.i;
                return s;
            }
        }
    });

    /**
     * @memberof FarseerPhysics.Common
     * @callback FarseerPhysics.Common.TerrainTester
     * @param   {Microsoft.Xna.Framework.Color}    Color
     * @return  {boolean}
     */

    /**
     * Simple class to maintain a terrain.
     *
     * @public
     * @class FarseerPhysics.Common.MSTerrain
     */
    Bridge.define("FarseerPhysics.Common.MSTerrain", {
        statics: {
            methods: {
                /**
                 * Convert a texture to an sbtye array compatible with ApplyData().
                 *
                 * @static
                 * @public
                 * @this FarseerPhysics.Common.MSTerrain
                 * @memberof FarseerPhysics.Common.MSTerrain
                 * @param   {Microsoft.Xna.Framework.Graphics.Texture2D}    texture    Texture to convert.
                 * @param   {FarseerPhysics.Common.TerrainTester}           tester
                 * @return  {Array.<number>}
                 */
                ConvertTextureToData: function (texture, tester) {
                    var data = System.Array.create(0, null, System.SByte, texture.Width, texture.Height);
                    var colorData = System.Array.init(Bridge.Int.mul(texture.Width, texture.Height), function (){
                        return new Microsoft.Xna.Framework.Color();
                    }, Microsoft.Xna.Framework.Color);

                    texture.GetData(Bridge.global.Microsoft.Xna.Framework.Color, colorData);

                    for (var y = 0; y < texture.Height; y = (y + 1) | 0) {
                        for (var x = 0; x < texture.Width; x = (x + 1) | 0) {
                            var inside = tester(colorData[System.Array.index((((Bridge.Int.mul(y, texture.Width)) + x) | 0), colorData)].$clone());

                            if (!inside) {
                                data.set([x, y], 1);
                            } else {
                                data.set([x, y], -1);
                            }
                        }
                    }

                    return data;
                }
            }
        },
        fields: {
            /**
             * World to manage terrain in.
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Common.MSTerrain
             * @type FarseerPhysics.Dynamics.World
             */
            World: null,
            /**
             * Center of terrain in world units.
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Common.MSTerrain
             * @type Microsoft.Xna.Framework.Vector2
             */
            Center: null,
            /**
             * Width of terrain in world units.
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Common.MSTerrain
             * @type number
             */
            Width: 0,
            /**
             * Height of terrain in world units.
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Common.MSTerrain
             * @type number
             */
            Height: 0,
            /**
             * Points per each world unit used to define the terrain in the point cloud.
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Common.MSTerrain
             * @type number
             */
            PointsPerUnit: 0,
            /**
             * Points per cell.
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Common.MSTerrain
             * @type number
             */
            CellSize: 0,
            /**
             * Points per sub cell.
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Common.MSTerrain
             * @type number
             */
            SubCellSize: 0,
            /**
             * Number of iterations to perform in the Marching Squares algorithm.
             Note: More then 3 has almost no effect on quality.
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Common.MSTerrain
             * @default 2
             * @type number
             */
            Iterations: 0,
            /**
             * Decomposer to use when regenerating terrain. Can be changed on the fly without consequence.
             Note: Some decomposerers are unstable.
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Common.MSTerrain
             * @type FarseerPhysics.Common.Decomposer
             */
            Decomposer: 0,
            /**
             * Point cloud defining the terrain.
             *
             * @instance
             * @private
             * @memberof FarseerPhysics.Common.MSTerrain
             * @type Array.<number>
             */
            _terrainMap: null,
            /**
             * Generated bodies.
             *
             * @instance
             * @private
             * @memberof FarseerPhysics.Common.MSTerrain
             * @type Array.<System.Collections.Generic.List$1>
             */
            _bodyMap: null,
            _localWidth: 0,
            _localHeight: 0,
            _xnum: 0,
            _ynum: 0,
            _dirtyArea: null,
            _topLeft: null
        },
        ctors: {
            init: function () {
                this.Center = new Microsoft.Xna.Framework.Vector2();
                this._dirtyArea = new FarseerPhysics.Collision.AABB();
                this._topLeft = new Microsoft.Xna.Framework.Vector2();
                this.Iterations = 2;
            },
            ctor: function (world, area) {
                this.$initialize();
                this.World = world;
                this.Width = area.Extents.X * 2;
                this.Height = area.Extents.Y * 2;
                this.Center = area.Center.$clone();
            }
        },
        methods: {
            /**
             * Initialize the terrain for use.
             *
             * @instance
             * @public
             * @this FarseerPhysics.Common.MSTerrain
             * @memberof FarseerPhysics.Common.MSTerrain
             * @return  {void}
             */
            Initialize: function () {
                this._topLeft = new Microsoft.Xna.Framework.Vector2.$ctor2(this.Center.X - (this.Width * 0.5), this.Center.Y - (-this.Height * 0.5));

                this._localWidth = this.Width * this.PointsPerUnit;
                this._localHeight = this.Height * this.PointsPerUnit;

                this._terrainMap = System.Array.create(0, null, System.SByte, ((Bridge.Int.clip32(this._localWidth) + 1) | 0), ((Bridge.Int.clip32(this._localHeight) + 1) | 0));

                for (var x = 0; x < this._localWidth; x = (x + 1) | 0) {
                    for (var y = 0; y < this._localHeight; y = (y + 1) | 0) {
                        this._terrainMap.set([x, y], 1);
                    }
                }

                this._xnum = Bridge.Int.clip32(this._localWidth / this.CellSize);
                this._ynum = Bridge.Int.clip32(this._localHeight / this.CellSize);
                this._bodyMap = System.Array.create(null, null, System.Collections.Generic.List$1(FarseerPhysics.Dynamics.Body), this._xnum, this._ynum);

                this._dirtyArea = new FarseerPhysics.Collision.AABB.$ctor1(new Microsoft.Xna.Framework.Vector2.$ctor2(3.40282347E+38, 3.40282347E+38), new Microsoft.Xna.Framework.Vector2.$ctor2(-3.40282347E+38, -3.40282347E+38));
            },
            /**
             * Apply a texture to the terrain using the specified TerrainTester.
             *
             * @instance
             * @public
             * @this FarseerPhysics.Common.MSTerrain
             * @memberof FarseerPhysics.Common.MSTerrain
             * @param   {Microsoft.Xna.Framework.Graphics.Texture2D}    texture     Texture to apply.
             * @param   {Microsoft.Xna.Framework.Vector2}               position    Top left position of the texture relative to the terrain.
             * @param   {FarseerPhysics.Common.TerrainTester}           tester      Delegate method used to determine what colors should be included in the terrain.
             * @return  {void}
             */
            ApplyTexture: function (texture, position, tester) {
                var colorData = System.Array.init(Bridge.Int.mul(texture.Width, texture.Height), function (){
                    return new Microsoft.Xna.Framework.Color();
                }, Microsoft.Xna.Framework.Color);

                texture.GetData(Bridge.global.Microsoft.Xna.Framework.Color, colorData);

                for (var y = Bridge.Int.clip32(position.Y); y < ((texture.Height + Bridge.Int.clip32(position.Y)) | 0); y = (y + 1) | 0) {
                    for (var x = Bridge.Int.clip32(position.X); x < ((texture.Width + Bridge.Int.clip32(position.X)) | 0); x = (x + 1) | 0) {
                        if (x >= 0 && x < this._localWidth && y >= 0 && y < this._localHeight) {
                            var inside = tester(colorData[System.Array.index((((Bridge.Int.mul((((y - Bridge.Int.clip32(position.Y)) | 0)), texture.Width)) + (((x - Bridge.Int.clip32(position.X)) | 0))) | 0), colorData)].$clone());

                            if (!inside) {
                                this._terrainMap.set([x, y], 1);
                            } else {
                                this._terrainMap.set([x, y], -1);
                            }
                        }
                    }
                }

                for (var gy = 0; gy < this._ynum; gy = (gy + 1) | 0) {
                    for (var gx = 0; gx < this._xnum; gx = (gx + 1) | 0) {
                        if (this._bodyMap.get([gx, gy]) != null) {
                            for (var i = 0; i < this._bodyMap.get([gx, gy]).Count; i = (i + 1) | 0) {
                                this.World.RemoveBody(this._bodyMap.get([gx, gy]).getItem(i));
                            }
                        }

                        this._bodyMap.set([gx, gy], null);

                        this.GenerateTerrain(gx, gy);
                    }
                }
            },
            /**
             * Apply a texture to the terrain using the specified TerrainTester.
             *
             * @instance
             * @public
             * @this FarseerPhysics.Common.MSTerrain
             * @memberof FarseerPhysics.Common.MSTerrain
             * @param   {Array.<number>}                     data        
             * @param   {Microsoft.Xna.Framework.Vector2}    position    Top left position of the texture relative to the terrain.
             * @return  {void}
             */
            ApplyData: function (data, position) {
                for (var y = Bridge.Int.clip32(position.Y); y < (((System.Array.getLength(data, 1) - 1) + Bridge.Int.clip32(position.Y)) | 0); y = (y + 1) | 0) {
                    for (var x = Bridge.Int.clip32(position.X); x < (((System.Array.getLength(data, 0) - 1) + Bridge.Int.clip32(position.X)) | 0); x = (x + 1) | 0) {
                        if (x >= 0 && x < this._localWidth && y >= 0 && y < this._localHeight) {
                            this._terrainMap.set([x, y], data.get([x, y]));
                        }
                    }
                }

                for (var gy = 0; gy < this._ynum; gy = (gy + 1) | 0) {
                    for (var gx = 0; gx < this._xnum; gx = (gx + 1) | 0) {
                        if (this._bodyMap.get([gx, gy]) != null) {
                            for (var i = 0; i < this._bodyMap.get([gx, gy]).Count; i = (i + 1) | 0) {
                                this.World.RemoveBody(this._bodyMap.get([gx, gy]).getItem(i));
                            }
                        }

                        this._bodyMap.set([gx, gy], null);

                        this.GenerateTerrain(gx, gy);
                    }
                }
            },
            /**
             * Modify a single point in the terrain.
             *
             * @instance
             * @public
             * @this FarseerPhysics.Common.MSTerrain
             * @memberof FarseerPhysics.Common.MSTerrain
             * @param   {Microsoft.Xna.Framework.Vector2}    location    World location to modify. Automatically clipped.
             * @param   {number}                             value       -1 = inside terrain, 1 = outside terrain
             * @return  {void}
             */
            ModifyTerrain: function (location, value) {
                var p = Microsoft.Xna.Framework.Vector2.op_Subtraction(location.$clone(), this._topLeft.$clone());

                p.X = p.X * this._localWidth / this.Width;
                p.Y = p.Y * -this._localHeight / this.Height;

                if (p.X >= 0 && p.X < this._localWidth && p.Y >= 0 && p.Y < this._localHeight) {
                    this._terrainMap.set([Bridge.Int.clip32(p.X), Bridge.Int.clip32(p.Y)], value);

                    if (p.X < this._dirtyArea.LowerBound.X) {
                        this._dirtyArea.LowerBound.X = p.X;
                    }
                    if (p.X > this._dirtyArea.UpperBound.X) {
                        this._dirtyArea.UpperBound.X = p.X;
                    }

                    if (p.Y < this._dirtyArea.LowerBound.Y) {
                        this._dirtyArea.LowerBound.Y = p.Y;
                    }
                    if (p.Y > this._dirtyArea.UpperBound.Y) {
                        this._dirtyArea.UpperBound.Y = p.Y;
                    }
                }
            },
            /**
             * Regenerate the terrain.
             *
             * @instance
             * @public
             * @this FarseerPhysics.Common.MSTerrain
             * @memberof FarseerPhysics.Common.MSTerrain
             * @return  {void}
             */
            RegenerateTerrain: function () {
                var gx0 = Bridge.Int.clip32(this._dirtyArea.LowerBound.X / this.CellSize);
                var gx1 = (Bridge.Int.clip32((this._dirtyArea.UpperBound.X / this.CellSize)) + 1) | 0;
                if (gx0 < 0) {
                    gx0 = 0;
                }
                if (gx1 > this._xnum) {
                    gx1 = this._xnum;
                }
                var gy0 = Bridge.Int.clip32(this._dirtyArea.LowerBound.Y / this.CellSize);
                var gy1 = (Bridge.Int.clip32((this._dirtyArea.UpperBound.Y / this.CellSize)) + 1) | 0;
                if (gy0 < 0) {
                    gy0 = 0;
                }
                if (gy1 > this._ynum) {
                    gy1 = this._ynum;
                }

                for (var gx = gx0; gx < gx1; gx = (gx + 1) | 0) {
                    for (var gy = gy0; gy < gy1; gy = (gy + 1) | 0) {
                        if (this._bodyMap.get([gx, gy]) != null) {
                            for (var i = 0; i < this._bodyMap.get([gx, gy]).Count; i = (i + 1) | 0) {
                                this.World.RemoveBody(this._bodyMap.get([gx, gy]).getItem(i));
                            }
                        }

                        this._bodyMap.set([gx, gy], null);

                        this.GenerateTerrain(gx, gy);
                    }
                }

                this._dirtyArea = new FarseerPhysics.Collision.AABB.$ctor1(new Microsoft.Xna.Framework.Vector2.$ctor2(3.40282347E+38, 3.40282347E+38), new Microsoft.Xna.Framework.Vector2.$ctor2(-3.40282347E+38, -3.40282347E+38));
            },
            GenerateTerrain: function (gx, gy) {
                var $t, $t1;
                var ax = Bridge.Int.mul(gx, this.CellSize);
                var ay = Bridge.Int.mul(gy, this.CellSize);

                var polys = FarseerPhysics.Common.MarchingSquares.DetectSquares(new FarseerPhysics.Collision.AABB.$ctor1(new Microsoft.Xna.Framework.Vector2.$ctor2(ax, ay), new Microsoft.Xna.Framework.Vector2.$ctor2(ax + this.CellSize, ay + this.CellSize)), this.SubCellSize, this.SubCellSize, this._terrainMap, this.Iterations, true);
                if (polys.Count === 0) {
                    return;
                }

                this._bodyMap.set([gx, gy], new (System.Collections.Generic.List$1(FarseerPhysics.Dynamics.Body)).ctor());

                var scale = { v : new Microsoft.Xna.Framework.Vector2.$ctor2(1.0 / this.PointsPerUnit, 1.0 / ((-this.PointsPerUnit) | 0)) };

                $t = Bridge.getEnumerator(polys);
                try {
                    while ($t.moveNext()) {
                        var item = $t.Current;
                        item.Scale(scale);
                        item.Translate$1(Bridge.ref(this, "_topLeft"));
                        item.ForceCounterClockWise();
                        var p = FarseerPhysics.Common.PolygonManipulation.SimplifyTools.CollinearSimplify(item);
                        var decompPolys = new (System.Collections.Generic.List$1(FarseerPhysics.Common.Vertices)).ctor();

                        switch (this.Decomposer) {
                            case FarseerPhysics.Common.Decomposer.Bayazit: 
                                decompPolys = FarseerPhysics.Common.Decomposition.BayazitDecomposer.ConvexPartition(p);
                                break;
                            case FarseerPhysics.Common.Decomposer.CDT: 
                                decompPolys = FarseerPhysics.Common.Decomposition.CDTDecomposer.ConvexPartition$1(p);
                                break;
                            case FarseerPhysics.Common.Decomposer.Earclip: 
                                decompPolys = FarseerPhysics.Common.Decomposition.EarclipDecomposer.ConvexPartition(p);
                                break;
                            case FarseerPhysics.Common.Decomposer.Flipcode: 
                                decompPolys = FarseerPhysics.Common.Decomposition.FlipcodeDecomposer.ConvexPartition(p);
                                break;
                            case FarseerPhysics.Common.Decomposer.Seidel: 
                                decompPolys = FarseerPhysics.Common.Decomposition.SeidelDecomposer.ConvexPartition(p, 0.001);
                                break;
                            default: 
                                break;
                        }

                        $t1 = Bridge.getEnumerator(decompPolys);
                        try {
                            while ($t1.moveNext()) {
                                var poly = $t1.Current;
                                if (poly.Count > 2) {
                                    this._bodyMap.get([gx, gy]).add(FarseerPhysics.Factories.BodyFactory.CreatePolygon(this.World, poly, 1));
                                }
                            }
                        } finally {
                            if (Bridge.is($t1, System.IDisposable)) {
                                $t1.System$IDisposable$Dispose();
                            }
                        }
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }}
        }
    });

    /** @namespace FarseerPhysics.Dynamics */

    /**
     * Contains filter data that can determine whether an object should be processed or not.
     *
     * @abstract
     * @public
     * @class FarseerPhysics.Dynamics.FilterData
     */
    Bridge.define("FarseerPhysics.Dynamics.FilterData", {
        fields: {
            DisabledOnCategories: 0,
            DisabledOnGroup: 0,
            EnabledOnCategories: 0,
            EnabledOnGroup: 0
        },
        ctors: {
            init: function () {
                this.DisabledOnCategories = FarseerPhysics.Dynamics.Category.None;
                this.EnabledOnCategories = FarseerPhysics.Dynamics.Category.All;
            }
        },
        methods: {
            IsActiveOn: function (body) {
                var $t;
                if (body == null || !body.Enabled || body.IsStatic) {
                    return false;
                }

                if (body.FixtureList == null) {
                    return false;
                }

                $t = Bridge.getEnumerator(body.FixtureList);
                try {
                    while ($t.moveNext()) {
                        var fixture = $t.Current;
                        if ((fixture.CollisionGroup === this.DisabledOnGroup) && fixture.CollisionGroup !== 0 && this.DisabledOnGroup !== 0) {
                            return false;
                        }

                        if ((fixture.CollisionCategories & this.DisabledOnCategories) !== FarseerPhysics.Dynamics.Category.None) {
                            return false;
                        }

                        if (this.EnabledOnGroup !== 0 || this.EnabledOnCategories !== FarseerPhysics.Dynamics.Category.All) {
                            if ((fixture.CollisionGroup === this.EnabledOnGroup) && fixture.CollisionGroup !== 0 && this.EnabledOnGroup !== 0) {
                                return true;
                            }

                            if ((fixture.CollisionCategories & this.EnabledOnCategories) !== FarseerPhysics.Dynamics.Category.None && this.EnabledOnCategories !== FarseerPhysics.Dynamics.Category.All) {
                                return true;
                            }
                        } else {
                            return true;
                        }
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }
                return false;
            },
            /**
             * Adds the category.
             *
             * @instance
             * @public
             * @this FarseerPhysics.Dynamics.FilterData
             * @memberof FarseerPhysics.Dynamics.FilterData
             * @param   {FarseerPhysics.Dynamics.Category}    category    The category.
             * @return  {void}
             */
            AddDisabledCategory: function (category) {
                this.DisabledOnCategories |= category;
            },
            /**
             * Removes the category.
             *
             * @instance
             * @public
             * @this FarseerPhysics.Dynamics.FilterData
             * @memberof FarseerPhysics.Dynamics.FilterData
             * @param   {FarseerPhysics.Dynamics.Category}    category    The category.
             * @return  {void}
             */
            RemoveDisabledCategory: function (category) {
                this.DisabledOnCategories &= ~category;
            },
            /**
             * Determines whether this body ignores the the specified controller.
             *
             * @instance
             * @public
             * @this FarseerPhysics.Dynamics.FilterData
             * @memberof FarseerPhysics.Dynamics.FilterData
             * @param   {FarseerPhysics.Dynamics.Category}    category    The category.
             * @return  {boolean}                                         <pre><code>true</code></pre> if the object has the specified category; otherwise, <pre><code>false</code></pre>.
             */
            IsInDisabledCategory: function (category) {
                return (this.DisabledOnCategories & category) === category;
            },
            /**
             * Adds the category.
             *
             * @instance
             * @public
             * @this FarseerPhysics.Dynamics.FilterData
             * @memberof FarseerPhysics.Dynamics.FilterData
             * @param   {FarseerPhysics.Dynamics.Category}    category    The category.
             * @return  {void}
             */
            AddEnabledCategory: function (category) {
                this.EnabledOnCategories |= category;
            },
            /**
             * Removes the category.
             *
             * @instance
             * @public
             * @this FarseerPhysics.Dynamics.FilterData
             * @memberof FarseerPhysics.Dynamics.FilterData
             * @param   {FarseerPhysics.Dynamics.Category}    category    The category.
             * @return  {void}
             */
            RemoveEnabledCategory: function (category) {
                this.EnabledOnCategories &= ~category;
            },
            /**
             * Determines whether this body ignores the the specified controller.
             *
             * @instance
             * @public
             * @this FarseerPhysics.Dynamics.FilterData
             * @memberof FarseerPhysics.Dynamics.FilterData
             * @param   {FarseerPhysics.Dynamics.Category}    category    The category.
             * @return  {boolean}                                         <pre><code>true</code></pre> if the object has the specified category; otherwise, <pre><code>false</code></pre>.
             */
            IsInEnabledCategory: function (category) {
                return (this.EnabledOnCategories & category) === category;
            }
        }
    });

    Bridge.define("FarseerPhysics.Common.PhysicsLogic.PhysicsLogicFilter", {
        $kind: "struct",
        statics: {
            methods: {
                getDefaultValue: function () { return new FarseerPhysics.Common.PhysicsLogic.PhysicsLogicFilter(); }
            }
        },
        fields: {
            ControllerIgnores: 0
        },
        ctors: {
            ctor: function () {
                this.$initialize();
            }
        },
        methods: {
            /**
             * Ignores the controller. The controller has no effect on this body.
             *
             * @instance
             * @public
             * @this FarseerPhysics.Common.PhysicsLogic.PhysicsLogicFilter
             * @memberof FarseerPhysics.Common.PhysicsLogic.PhysicsLogicFilter
             * @param   {FarseerPhysics.Common.PhysicsLogic.PhysicsLogicType}    type    The logic type.
             * @return  {void}
             */
            IgnorePhysicsLogic: function (type) {
                this.ControllerIgnores |= type;
            },
            /**
             * Restore the controller. The controller affects this body.
             *
             * @instance
             * @public
             * @this FarseerPhysics.Common.PhysicsLogic.PhysicsLogicFilter
             * @memberof FarseerPhysics.Common.PhysicsLogic.PhysicsLogicFilter
             * @param   {FarseerPhysics.Common.PhysicsLogic.PhysicsLogicType}    type    The logic type.
             * @return  {void}
             */
            RestorePhysicsLogic: function (type) {
                this.ControllerIgnores &= ~type;
            },
            /**
             * Determines whether this body ignores the the specified controller.
             *
             * @instance
             * @public
             * @this FarseerPhysics.Common.PhysicsLogic.PhysicsLogicFilter
             * @memberof FarseerPhysics.Common.PhysicsLogic.PhysicsLogicFilter
             * @param   {FarseerPhysics.Common.PhysicsLogic.PhysicsLogicType}    type    The logic type.
             * @return  {boolean}                                                        <pre><code>true</code></pre> if the body has the specified flag; otherwise, <pre><code>false</code></pre>.
             */
            IsPhysicsLogicIgnored: function (type) {
                return (this.ControllerIgnores & type) === type;
            },
            getHashCode: function () {
                var h = Bridge.addHash([6841110227, this.ControllerIgnores]);
                return h;
            },
            equals: function (o) {
                if (!Bridge.is(o, FarseerPhysics.Common.PhysicsLogic.PhysicsLogicFilter)) {
                    return false;
                }
                return Bridge.equals(this.ControllerIgnores, o.ControllerIgnores);
            },
            $clone: function (to) {
                var s = to || new FarseerPhysics.Common.PhysicsLogic.PhysicsLogicFilter();
                s.ControllerIgnores = this.ControllerIgnores;
                return s;
            }
        }
    });

    Bridge.define("FarseerPhysics.Common.PhysicsLogic.PhysicsLogicType", {
        $kind: "enum",
        statics: {
            fields: {
                Explosion: 1
            }
        },
        $flags: true
    });

    /** @namespace FarseerPhysics.Common.PhysicsLogic */

    /**
     * This is a comprarer used for 
     detecting angle difference between rays
     *
     * @class FarseerPhysics.Common.PhysicsLogic.RayDataComparer
     * @implements  System.Collections.Generic.IComparer$1
     */
    Bridge.define("FarseerPhysics.Common.PhysicsLogic.RayDataComparer", {
        inherits: [System.Collections.Generic.IComparer$1(System.Single)],
        alias: ["System$Collections$Generic$IComparer$1$System$Single$compare", "System$Collections$Generic$IComparer$1$compare"],
        methods: {
            System$Collections$Generic$IComparer$1$System$Single$compare: function (a, b) {
                var diff = (a - b);
                if (diff > 0) {
                    return 1;
                }
                if (diff < 0) {
                    return -1;
                }
                return 0;
            }
        }
    });

    Bridge.define("FarseerPhysics.Common.PhysicsLogic.ShapeData", {
        $kind: "struct",
        statics: {
            methods: {
                getDefaultValue: function () { return new FarseerPhysics.Common.PhysicsLogic.ShapeData(); }
            }
        },
        fields: {
            Body: null,
            Max: 0,
            Min: 0
        },
        ctors: {
            ctor: function () {
                this.$initialize();
            }
        },
        methods: {
            getHashCode: function () {
                var h = Bridge.addHash([3837963545, this.Body, this.Max, this.Min]);
                return h;
            },
            equals: function (o) {
                if (!Bridge.is(o, FarseerPhysics.Common.PhysicsLogic.ShapeData)) {
                    return false;
                }
                return Bridge.equals(this.Body, o.Body) && Bridge.equals(this.Max, o.Max) && Bridge.equals(this.Min, o.Min);
            },
            $clone: function (to) {
                var s = to || new FarseerPhysics.Common.PhysicsLogic.ShapeData();
                s.Body = this.Body;
                s.Max = this.Max;
                s.Min = this.Min;
                return s;
            }
        }
    });

    Bridge.define("FarseerPhysics.Common.PolygonManipulation.CuttingTools", {
        statics: {
            methods: {
                /**
                 * Split a fixture into 2 vertice collections using the given entry and exit-point.
                 *
                 * @static
                 * @public
                 * @this FarseerPhysics.Common.PolygonManipulation.CuttingTools
                 * @memberof FarseerPhysics.Common.PolygonManipulation.CuttingTools
                 * @param   {FarseerPhysics.Dynamics.Fixture}    fixture       The Fixture to split
                 * @param   {Microsoft.Xna.Framework.Vector2}    entryPoint    The entry point - The start point
                 * @param   {Microsoft.Xna.Framework.Vector2}    exitPoint     The exit point - The end point
                 * @param   {number}                             splitSize     The size of the split. Think of this as the laser-width
                 * @param   {FarseerPhysics.Common.Vertices}     first         The first collection of vertexes
                 * @param   {FarseerPhysics.Common.Vertices}     second        The second collection of vertexes
                 * @return  {void}
                 */
                SplitShape: function (fixture, entryPoint, exitPoint, splitSize, first, second) {
                    entryPoint = {v:entryPoint};
                    exitPoint = {v:exitPoint};
                    var localEntryPoint = fixture.Body.GetLocalPoint$1(entryPoint);
                    var localExitPoint = fixture.Body.GetLocalPoint$1(exitPoint);

                    var shape = Bridge.as(fixture.Shape, FarseerPhysics.Collision.Shapes.PolygonShape);

                    if (shape == null) {
                        first.v = new FarseerPhysics.Common.Vertices.ctor();
                        second.v = new FarseerPhysics.Common.Vertices.ctor();
                        return;
                    }

                    var vertices = new FarseerPhysics.Common.Vertices.$ctor2(shape.Vertices);
                    var newPolygon = System.Array.init(2, null, FarseerPhysics.Common.Vertices);

                    for (var i = 0; i < newPolygon.length; i = (i + 1) | 0) {
                        newPolygon[System.Array.index(i, newPolygon)] = new FarseerPhysics.Common.Vertices.$ctor3(vertices.Count);
                    }

                    var cutAdded = System.Array.init([-1, -1], System.Int32);
                    var last = -1;
                    for (var i1 = 0; i1 < vertices.Count; i1 = (i1 + 1) | 0) {
                        var n;
                        if (Microsoft.Xna.Framework.Vector2.Dot(FarseerPhysics.Common.MathUtils.Cross(Microsoft.Xna.Framework.Vector2.op_Subtraction(localExitPoint.$clone(), localEntryPoint.$clone()), 1), Microsoft.Xna.Framework.Vector2.op_Subtraction(vertices.getItem(i1).$clone(), localEntryPoint.$clone())) > FarseerPhysics.Settings.Epsilon) {
                            n = 0;
                        } else {
                            n = 1;
                        }

                        if (last !== n) {
                            if (last === 0) {
                                System.Diagnostics.Debug.Assert(cutAdded[System.Array.index(0, cutAdded)] === -1);
                                cutAdded[System.Array.index(0, cutAdded)] = newPolygon[System.Array.index(last, newPolygon)].Count;
                                newPolygon[System.Array.index(last, newPolygon)].add(localExitPoint.$clone());
                                newPolygon[System.Array.index(last, newPolygon)].add(localEntryPoint.$clone());
                            }
                            if (last === 1) {
                                System.Diagnostics.Debug.Assert(cutAdded[System.Array.index(last, cutAdded)] === -1);
                                cutAdded[System.Array.index(last, cutAdded)] = newPolygon[System.Array.index(last, newPolygon)].Count;
                                newPolygon[System.Array.index(last, newPolygon)].add(localEntryPoint.$clone());
                                newPolygon[System.Array.index(last, newPolygon)].add(localExitPoint.$clone());
                            }
                        }

                        newPolygon[System.Array.index(n, newPolygon)].add(vertices.getItem(i1).$clone());
                        last = n;
                    }

                    if (cutAdded[System.Array.index(0, cutAdded)] === -1) {
                        cutAdded[System.Array.index(0, cutAdded)] = newPolygon[System.Array.index(0, newPolygon)].Count;
                        newPolygon[System.Array.index(0, newPolygon)].add(localExitPoint.$clone());
                        newPolygon[System.Array.index(0, newPolygon)].add(localEntryPoint.$clone());
                    }
                    if (cutAdded[System.Array.index(1, cutAdded)] === -1) {
                        cutAdded[System.Array.index(1, cutAdded)] = newPolygon[System.Array.index(1, newPolygon)].Count;
                        newPolygon[System.Array.index(1, newPolygon)].add(localEntryPoint.$clone());
                        newPolygon[System.Array.index(1, newPolygon)].add(localExitPoint.$clone());
                    }

                    for (var n1 = 0; n1 < 2; n1 = (n1 + 1) | 0) {
                        var offset = new Microsoft.Xna.Framework.Vector2();
                        if (cutAdded[System.Array.index(n1, cutAdded)] > 0) {
                            offset = (Microsoft.Xna.Framework.Vector2.op_Subtraction(newPolygon[System.Array.index(n1, newPolygon)].getItem(((cutAdded[System.Array.index(n1, cutAdded)] - 1) | 0)).$clone(), newPolygon[System.Array.index(n1, newPolygon)].getItem(cutAdded[System.Array.index(n1, cutAdded)]).$clone()));
                        } else {
                            offset = (Microsoft.Xna.Framework.Vector2.op_Subtraction(newPolygon[System.Array.index(n1, newPolygon)].getItem(((newPolygon[System.Array.index(n1, newPolygon)].Count - 1) | 0)).$clone(), newPolygon[System.Array.index(n1, newPolygon)].getItem(0).$clone()));
                        }
                        offset.Normalize();

                        newPolygon[System.Array.index(n1, newPolygon)].setItem(cutAdded[System.Array.index(n1, cutAdded)], Microsoft.Xna.Framework.Vector2.op_Addition(newPolygon[System.Array.index(n1, newPolygon)].getItem(cutAdded[System.Array.index(n1, cutAdded)]).$clone(), Microsoft.Xna.Framework.Vector2.op_Multiply$2(splitSize, offset.$clone())));

                        if (cutAdded[System.Array.index(n1, cutAdded)] < ((newPolygon[System.Array.index(n1, newPolygon)].Count - 2) | 0)) {
                            offset = (Microsoft.Xna.Framework.Vector2.op_Subtraction(newPolygon[System.Array.index(n1, newPolygon)].getItem(((cutAdded[System.Array.index(n1, cutAdded)] + 2) | 0)).$clone(), newPolygon[System.Array.index(n1, newPolygon)].getItem(((cutAdded[System.Array.index(n1, cutAdded)] + 1) | 0)).$clone()));
                        } else {
                            offset = (Microsoft.Xna.Framework.Vector2.op_Subtraction(newPolygon[System.Array.index(n1, newPolygon)].getItem(0).$clone(), newPolygon[System.Array.index(n1, newPolygon)].getItem(((newPolygon[System.Array.index(n1, newPolygon)].Count - 1) | 0)).$clone()));
                        }
                        offset.Normalize();

                        newPolygon[System.Array.index(n1, newPolygon)].setItem(((cutAdded[System.Array.index(n1, cutAdded)] + 1) | 0), Microsoft.Xna.Framework.Vector2.op_Addition(newPolygon[System.Array.index(n1, newPolygon)].getItem(((cutAdded[System.Array.index(n1, cutAdded)] + 1) | 0)).$clone(), Microsoft.Xna.Framework.Vector2.op_Multiply$2(splitSize, offset.$clone())));
                    }

                    first.v = newPolygon[System.Array.index(0, newPolygon)];
                    second.v = newPolygon[System.Array.index(1, newPolygon)];
                },
                /**
                 * This is a high-level function to cuts fixtures inside the given world, using the start and end points.
                 Note: We don't support cutting when the start or end is inside a shape.
                 *
                 * @static
                 * @public
                 * @this FarseerPhysics.Common.PolygonManipulation.CuttingTools
                 * @memberof FarseerPhysics.Common.PolygonManipulation.CuttingTools
                 * @param   {FarseerPhysics.Dynamics.World}      world        The world.
                 * @param   {Microsoft.Xna.Framework.Vector2}    start        The startpoint.
                 * @param   {Microsoft.Xna.Framework.Vector2}    end          The endpoint.
                 * @param   {number}                             thickness    The thickness of the cut
                 * @return  {void}
                 */
                Cut: function (world, start, end, thickness) {
                    var fixtures = new (System.Collections.Generic.List$1(FarseerPhysics.Dynamics.Fixture)).ctor();
                    var entryPoints = new (System.Collections.Generic.List$1(Microsoft.Xna.Framework.Vector2)).ctor();
                    var exitPoints = new (System.Collections.Generic.List$1(Microsoft.Xna.Framework.Vector2)).ctor();

                    if (world.TestPoint(start.$clone()) != null || world.TestPoint(end.$clone()) != null) {
                        return;
                    }

                    world.RayCast(function (f, p, n, fr) {
                        fixtures.add(f);
                        entryPoints.add(p.$clone());
                        return 1;
                    }, start.$clone(), end.$clone());

                    world.RayCast(function (f, p, n, fr) {
                        exitPoints.add(p.$clone());
                        return 1;
                    }, end.$clone(), start.$clone());

                    if (((entryPoints.Count + exitPoints.Count) | 0) < 2) {
                        return;
                    }

                    for (var i = 0; i < fixtures.Count; i = (i + 1) | 0) {
                        if (fixtures.getItem(i).Shape.ShapeType !== FarseerPhysics.Collision.Shapes.ShapeType.Polygon) {
                            continue;
                        }

                        if (fixtures.getItem(i).Body.BodyType !== FarseerPhysics.Dynamics.BodyType.Static) {
                            var first = { };
                            var second = { };
                            FarseerPhysics.Common.PolygonManipulation.CuttingTools.SplitShape(fixtures.getItem(i), entryPoints.getItem(i).$clone(), exitPoints.getItem(i).$clone(), thickness, first, second);

                            if (FarseerPhysics.Common.PolygonManipulation.CuttingTools.SanityCheck(first.v)) {
                                var firstFixture = FarseerPhysics.Factories.BodyFactory.CreatePolygon$1(world, first.v, fixtures.getItem(i).Shape.Density, fixtures.getItem(i).Body.Position.$clone());
                                firstFixture.Rotation = fixtures.getItem(i).Body.Rotation;
                                firstFixture.LinearVelocity = fixtures.getItem(i).Body.LinearVelocity.$clone();
                                firstFixture.AngularVelocity = fixtures.getItem(i).Body.AngularVelocity;
                                firstFixture.BodyType = FarseerPhysics.Dynamics.BodyType.Dynamic;
                            }

                            if (FarseerPhysics.Common.PolygonManipulation.CuttingTools.SanityCheck(second.v)) {
                                var secondFixture = FarseerPhysics.Factories.BodyFactory.CreatePolygon$1(world, second.v, fixtures.getItem(i).Shape.Density, fixtures.getItem(i).Body.Position.$clone());
                                secondFixture.Rotation = fixtures.getItem(i).Body.Rotation;
                                secondFixture.LinearVelocity = fixtures.getItem(i).Body.LinearVelocity.$clone();
                                secondFixture.AngularVelocity = fixtures.getItem(i).Body.AngularVelocity;
                                secondFixture.BodyType = FarseerPhysics.Dynamics.BodyType.Dynamic;
                            }
                            world.RemoveBody(fixtures.getItem(i).Body);
                        }
                    }
                },
                SanityCheck: function (vertices) {
                    if (vertices.Count < 3) {
                        return false;
                    }

                    if (vertices.GetArea() < 1E-05) {
                        return false;
                    }

                    for (var i = 0; i < vertices.Count; i = (i + 1) | 0) {
                        var i1 = i;
                        var i2 = ((i + 1) | 0) < vertices.Count ? ((i + 1) | 0) : 0;
                        var edge = Microsoft.Xna.Framework.Vector2.op_Subtraction(vertices.getItem(i2).$clone(), vertices.getItem(i1).$clone());
                        if (edge.LengthSquared() < 1.42108547E-14) {
                            return false;
                        }
                    }

                    for (var i3 = 0; i3 < vertices.Count; i3 = (i3 + 1) | 0) {
                        var i11 = i3;
                        var i21 = ((i3 + 1) | 0) < vertices.Count ? ((i3 + 1) | 0) : 0;
                        var edge1 = Microsoft.Xna.Framework.Vector2.op_Subtraction(vertices.getItem(i21).$clone(), vertices.getItem(i11).$clone());

                        for (var j = 0; j < vertices.Count; j = (j + 1) | 0) {
                            if (j === i11 || j === i21) {
                                continue;
                            }

                            var r = Microsoft.Xna.Framework.Vector2.op_Subtraction(vertices.getItem(j).$clone(), vertices.getItem(i11).$clone());

                            var s = edge1.X * r.Y - edge1.Y * r.X;

                            if (s < 0.0) {
                                return false;
                            }
                        }
                    }

                    return true;
                }
            }
        }
    });

    Bridge.define("FarseerPhysics.Common.PolygonManipulation.PolyClipError", {
        $kind: "enum",
        statics: {
            fields: {
                None: 0,
                DegeneratedOutput: 1,
                NonSimpleInput: 2,
                BrokenResult: 3
            }
        }
    });

    Bridge.define("FarseerPhysics.Common.PolygonManipulation.PolyClipType", {
        $kind: "enum",
        statics: {
            fields: {
                Intersect: 0,
                Union: 1,
                Difference: 2
            }
        }
    });

    Bridge.define("FarseerPhysics.Common.PolygonManipulation.SimplifyTools", {
        statics: {
            fields: {
                _usePt: null,
                _distanceTolerance: 0
            },
            methods: {
                /**
                 * Removes all collinear points on the polygon.
                 *
                 * @static
                 * @public
                 * @this FarseerPhysics.Common.PolygonManipulation.SimplifyTools
                 * @memberof FarseerPhysics.Common.PolygonManipulation.SimplifyTools
                 * @param   {FarseerPhysics.Common.Vertices}    vertices                 The polygon that needs simplification.
                 * @param   {number}                            collinearityTolerance    The collinearity tolerance.
                 * @return  {FarseerPhysics.Common.Vertices}                             A simplified polygon.
                 */
                CollinearSimplify$1: function (vertices, collinearityTolerance) {
                    if (vertices.Count < 3) {
                        return vertices;
                    }

                    var simplified = new FarseerPhysics.Common.Vertices.ctor();

                    for (var i = 0; i < vertices.Count; i = (i + 1) | 0) {
                        var prevId = vertices.PreviousIndex(i);
                        var nextId = vertices.NextIndex(i);

                        var prev = { v : vertices.getItem(prevId).$clone() };
                        var current = { v : vertices.getItem(i).$clone() };
                        var next = { v : vertices.getItem(nextId).$clone() };

                        if (FarseerPhysics.Common.MathUtils.Collinear$1(prev, current, next, collinearityTolerance)) {
                            continue;
                        }

                        simplified.add(current.v.$clone());
                    }

                    return simplified;
                },
                /**
                 * Removes all collinear points on the polygon.
                 Has a default bias of 0
                 *
                 * @static
                 * @public
                 * @this FarseerPhysics.Common.PolygonManipulation.SimplifyTools
                 * @memberof FarseerPhysics.Common.PolygonManipulation.SimplifyTools
                 * @param   {FarseerPhysics.Common.Vertices}    vertices    The polygon that needs simplification.
                 * @return  {FarseerPhysics.Common.Vertices}                A simplified polygon.
                 */
                CollinearSimplify: function (vertices) {
                    return FarseerPhysics.Common.PolygonManipulation.SimplifyTools.CollinearSimplify$1(vertices, 0);
                },
                /**
                 * Ramer-Douglas-Peucker polygon simplification algorithm. This is the general recursive version that does not use the
                 speed-up technique by using the Melkman convex hull.
                 If you pass in 0, it will remove all collinear points
                 *
                 * @static
                 * @public
                 * @this FarseerPhysics.Common.PolygonManipulation.SimplifyTools
                 * @memberof FarseerPhysics.Common.PolygonManipulation.SimplifyTools
                 * @param   {FarseerPhysics.Common.Vertices}    vertices             
                 * @param   {number}                            distanceTolerance
                 * @return  {FarseerPhysics.Common.Vertices}                         The simplified polygon
                 */
                DouglasPeuckerSimplify: function (vertices, distanceTolerance) {
                    FarseerPhysics.Common.PolygonManipulation.SimplifyTools._distanceTolerance = distanceTolerance;

                    FarseerPhysics.Common.PolygonManipulation.SimplifyTools._usePt = System.Array.init(vertices.Count, false, System.Boolean);
                    for (var i = 0; i < vertices.Count; i = (i + 1) | 0) {
                        FarseerPhysics.Common.PolygonManipulation.SimplifyTools._usePt[System.Array.index(i, FarseerPhysics.Common.PolygonManipulation.SimplifyTools._usePt)] = true;
                    }

                    FarseerPhysics.Common.PolygonManipulation.SimplifyTools.SimplifySection(vertices, 0, ((vertices.Count - 1) | 0));
                    var result = new FarseerPhysics.Common.Vertices.ctor();

                    for (var i1 = 0; i1 < vertices.Count; i1 = (i1 + 1) | 0) {
                        if (FarseerPhysics.Common.PolygonManipulation.SimplifyTools._usePt[System.Array.index(i1, FarseerPhysics.Common.PolygonManipulation.SimplifyTools._usePt)]) {
                            result.add(vertices.getItem(i1).$clone());
                        }
                    }

                    return result;
                },
                SimplifySection: function (vertices, i, j) {
                    if ((((i + 1) | 0)) === j) {
                        return;
                    }

                    var A = vertices.getItem(i).$clone();
                    var B = vertices.getItem(j).$clone();
                    var maxDistance = -1.0;
                    var maxIndex = i;
                    for (var k = (i + 1) | 0; k < j; k = (k + 1) | 0) {
                        var distance = FarseerPhysics.Common.PolygonManipulation.SimplifyTools.DistancePointLine(vertices.getItem(k).$clone(), A.$clone(), B.$clone());

                        if (distance > maxDistance) {
                            maxDistance = distance;
                            maxIndex = k;
                        }
                    }
                    if (maxDistance <= FarseerPhysics.Common.PolygonManipulation.SimplifyTools._distanceTolerance) {
                        for (var k1 = (i + 1) | 0; k1 < j; k1 = (k1 + 1) | 0) {
                            FarseerPhysics.Common.PolygonManipulation.SimplifyTools._usePt[System.Array.index(k1, FarseerPhysics.Common.PolygonManipulation.SimplifyTools._usePt)] = false;
                        }
                    } else {
                        FarseerPhysics.Common.PolygonManipulation.SimplifyTools.SimplifySection(vertices, i, maxIndex);
                        FarseerPhysics.Common.PolygonManipulation.SimplifyTools.SimplifySection(vertices, maxIndex, j);
                    }
                },
                DistancePointPoint: function (p, p2) {
                    var dx = p.X - p2.X;
                    var dy = p.Y - p2.X;
                    return Math.sqrt(dx * dx + dy * dy);
                },
                DistancePointLine: function (p, A, B) {
                    if (A.X === B.X && A.Y === B.Y) {
                        return FarseerPhysics.Common.PolygonManipulation.SimplifyTools.DistancePointPoint(p.$clone(), A.$clone());
                    }

                    /* (1)     	      AC dot AB
                               r =   ---------
                                     ||AB||^2

                    		                r has the following meaning:
                    		                r=0 Point = A
                    		                r=1 Point = B
                    		                r<0 Point is on the backward extension of AB
                    		                r>1 Point is on the forward extension of AB
                    		                0<r<1 Point is interior to AB
                    	        */

                    var r = ((p.X - A.X) * (B.X - A.X) + (p.Y - A.Y) * (B.Y - A.Y)) / ((B.X - A.X) * (B.X - A.X) + (B.Y - A.Y) * (B.Y - A.Y));

                    if (r <= 0.0) {
                        return FarseerPhysics.Common.PolygonManipulation.SimplifyTools.DistancePointPoint(p.$clone(), A.$clone());
                    }
                    if (r >= 1.0) {
                        return FarseerPhysics.Common.PolygonManipulation.SimplifyTools.DistancePointPoint(p.$clone(), B.$clone());
                    }


                    /* (2)
                    		                    (Ay-Cy)(Bx-Ax)-(Ax-Cx)(By-Ay)
                    		                s = -----------------------------
                    		             	                Curve^2

                    		                Then the distance from C to Point = |s|*Curve.
                    	        */

                    var s = ((A.Y - p.Y) * (B.X - A.X) - (A.X - p.X) * (B.Y - A.Y)) / ((B.X - A.X) * (B.X - A.X) + (B.Y - A.Y) * (B.Y - A.Y));

                    return Math.abs(s) * Math.sqrt(((B.X - A.X) * (B.X - A.X) + (B.Y - A.Y) * (B.Y - A.Y)));
                },
                ReduceByArea: function (vertices, areaTolerance) {
                    if (vertices.Count <= 3) {
                        return vertices;
                    }

                    if (areaTolerance < 0) {
                        throw new System.ArgumentOutOfRangeException.$ctor4("areaTolerance", "must be equal to or greater then zero.");
                    }

                    var result = new FarseerPhysics.Common.Vertices.ctor();
                    var v1 = { v : new Microsoft.Xna.Framework.Vector2() }, v2 = { v : new Microsoft.Xna.Framework.Vector2() }, v3 = { v : new Microsoft.Xna.Framework.Vector2() };
                    var old1 = { }, old2 = { }, new1 = { };
                    v1.v = vertices.getItem(((vertices.Count - 2) | 0)).$clone();
                    v2.v = vertices.getItem(((vertices.Count - 1) | 0)).$clone();
                    areaTolerance *= 2;
                    for (var index = 0; index < vertices.Count; index = (index + 1) | 0, v2.v = v3.v.$clone()) {
                        if (index === ((vertices.Count - 1) | 0)) {
                            if (result.Count === 0) {
                                throw new System.ArgumentOutOfRangeException.$ctor4("areaTolerance", "The tolerance is too high!");
                            }
                            v3.v = result.getItem(0).$clone();
                        } else {
                            v3.v = vertices.getItem(index).$clone();
                        }
                        FarseerPhysics.Common.MathUtils.Cross$3(v1, v2, old1);
                        FarseerPhysics.Common.MathUtils.Cross$3(v2, v3, old2);
                        FarseerPhysics.Common.MathUtils.Cross$3(v1, v3, new1);
                        if (Math.abs(new1.v - (old1.v + old2.v)) > areaTolerance) {
                            result.add(v2.v.$clone());
                            v1.v = v2.v.$clone();
                        }
                    }
                    return result;
                },
                /**
                 * Merges all parallel edges in the list of vertices
                 *
                 * @static
                 * @public
                 * @this FarseerPhysics.Common.PolygonManipulation.SimplifyTools
                 * @memberof FarseerPhysics.Common.PolygonManipulation.SimplifyTools
                 * @param   {FarseerPhysics.Common.Vertices}    vertices     The vertices.
                 * @param   {number}                            tolerance    The tolerance.
                 * @return  {void}
                 */
                MergeParallelEdges: function (vertices, tolerance) {
                    if (vertices.Count <= 3) {
                        return;
                    }

                    var mergeMe = System.Array.init(vertices.Count, false, System.Boolean);
                    var newNVertices = vertices.Count;

                    for (var i = 0; i < vertices.Count; i = (i + 1) | 0) {
                        var lower = (i === 0) ? (((vertices.Count - 1) | 0)) : (((i - 1) | 0));
                        var middle = i;
                        var upper = (i === ((vertices.Count - 1) | 0)) ? (0) : (((i + 1) | 0));

                        var dx0 = vertices.getItem(middle).$clone().X - vertices.getItem(lower).$clone().X;
                        var dy0 = vertices.getItem(middle).$clone().Y - vertices.getItem(lower).$clone().Y;
                        var dx1 = vertices.getItem(upper).$clone().Y - vertices.getItem(middle).$clone().X;
                        var dy1 = vertices.getItem(upper).$clone().Y - vertices.getItem(middle).$clone().Y;
                        var norm0 = Math.sqrt(dx0 * dx0 + dy0 * dy0);
                        var norm1 = Math.sqrt(dx1 * dx1 + dy1 * dy1);

                        if (!(norm0 > 0.0 && norm1 > 0.0) && newNVertices > 3) {
                            mergeMe[System.Array.index(i, mergeMe)] = true;
                            newNVertices = (newNVertices - 1) | 0;
                        }

                        dx0 /= norm0;
                        dy0 /= norm0;
                        dx1 /= norm1;
                        dy1 /= norm1;
                        var cross = dx0 * dy1 - dx1 * dy0;
                        var dot = dx0 * dx1 + dy0 * dy1;

                        if (Math.abs(cross) < tolerance && dot > 0 && newNVertices > 3) {
                            mergeMe[System.Array.index(i, mergeMe)] = true;
                            newNVertices = (newNVertices - 1) | 0;
                        } else {
                            mergeMe[System.Array.index(i, mergeMe)] = false;
                        }
                    }

                    if (newNVertices === vertices.Count || newNVertices === 0) {
                        return;
                    }

                    var currIndex = 0;

                    var oldVertices = new FarseerPhysics.Common.Vertices.$ctor2(vertices);
                    vertices.clear();

                    for (var i1 = 0; i1 < oldVertices.Count; i1 = (i1 + 1) | 0) {
                        if (mergeMe[System.Array.index(i1, mergeMe)] || newNVertices === 0 || currIndex === newNVertices) {
                            continue;
                        }

                        System.Diagnostics.Debug.Assert(currIndex < newNVertices);

                        vertices.add(oldVertices.getItem(i1).$clone());
                        currIndex = (currIndex + 1) | 0;
                    }
                },
                /**
                 * Merges the identical points in the polygon.
                 *
                 * @static
                 * @public
                 * @this FarseerPhysics.Common.PolygonManipulation.SimplifyTools
                 * @memberof FarseerPhysics.Common.PolygonManipulation.SimplifyTools
                 * @param   {FarseerPhysics.Common.Vertices}    vertices    The vertices.
                 * @return  {FarseerPhysics.Common.Vertices}
                 */
                MergeIdenticalPoints: function (vertices) {
                    var $t;
                    var results = new (System.Collections.Generic.HashSet$1(Microsoft.Xna.Framework.Vector2)).ctor();

                    for (var i = 0; i < vertices.Count; i = (i + 1) | 0) {
                        results.add(vertices.getItem(i).$clone());
                    }

                    var returnResults = new FarseerPhysics.Common.Vertices.ctor();
                    $t = Bridge.getEnumerator(results);
                    try {
                        while ($t.moveNext()) {
                            var v = $t.Current.$clone();
                            returnResults.add(v.$clone());
                        }
                    } finally {
                        if (Bridge.is($t, System.IDisposable)) {
                            $t.System$IDisposable$Dispose();
                        }
                    }
                    return returnResults;
                },
                /**
                 * Reduces the polygon by distance.
                 *
                 * @static
                 * @public
                 * @this FarseerPhysics.Common.PolygonManipulation.SimplifyTools
                 * @memberof FarseerPhysics.Common.PolygonManipulation.SimplifyTools
                 * @param   {FarseerPhysics.Common.Vertices}    vertices    The vertices.
                 * @param   {number}                            distance    The distance between points. Points closer than this will be 'joined'.
                 * @return  {FarseerPhysics.Common.Vertices}
                 */
                ReduceByDistance: function (vertices, distance) {
                    if (vertices.Count < 3) {
                        return vertices;
                    }

                    var simplified = new FarseerPhysics.Common.Vertices.ctor();

                    for (var i = 0; i < vertices.Count; i = (i + 1) | 0) {
                        var current = vertices.getItem(i).$clone();
                        var next = vertices.NextVertex(i);

                        if ((Microsoft.Xna.Framework.Vector2.op_Subtraction(next.$clone(), current.$clone())).LengthSquared() <= distance) {
                            continue;
                        }

                        simplified.add(current.$clone());
                    }

                    return simplified;
                },
                /**
                 * Reduces the polygon by removing the Nth vertex in the vertices list.
                 *
                 * @static
                 * @public
                 * @this FarseerPhysics.Common.PolygonManipulation.SimplifyTools
                 * @memberof FarseerPhysics.Common.PolygonManipulation.SimplifyTools
                 * @param   {FarseerPhysics.Common.Vertices}    vertices    The vertices.
                 * @param   {number}                            nth         The Nth point to remove. Example: 5.
                 * @return  {FarseerPhysics.Common.Vertices}
                 */
                ReduceByNth: function (vertices, nth) {
                    if (vertices.Count < 3) {
                        return vertices;
                    }

                    if (nth === 0) {
                        return vertices;
                    }

                    var result = new FarseerPhysics.Common.Vertices.$ctor3(vertices.Count);

                    for (var i = 0; i < vertices.Count; i = (i + 1) | 0) {
                        if (i % nth === 0) {
                            continue;
                        }

                        result.add(vertices.getItem(i).$clone());
                    }

                    return result;
                }
            }
        }
    });

    Bridge.define("FarseerPhysics.Common.PolygonManipulation.YuPengClipper", {
        statics: {
            fields: {
                ClipperEpsilonSquared: 0
            },
            ctors: {
                init: function () {
                    this.ClipperEpsilonSquared = 1.1920929E-07;
                }
            },
            methods: {
                Union: function (polygon1, polygon2, error) {
                    return FarseerPhysics.Common.PolygonManipulation.YuPengClipper.Execute(polygon1, polygon2, FarseerPhysics.Common.PolygonManipulation.PolyClipType.Union, error);
                },
                Difference: function (polygon1, polygon2, error) {
                    return FarseerPhysics.Common.PolygonManipulation.YuPengClipper.Execute(polygon1, polygon2, FarseerPhysics.Common.PolygonManipulation.PolyClipType.Difference, error);
                },
                Intersect: function (polygon1, polygon2, error) {
                    return FarseerPhysics.Common.PolygonManipulation.YuPengClipper.Execute(polygon1, polygon2, FarseerPhysics.Common.PolygonManipulation.PolyClipType.Intersect, error);
                },
                /**
                 * Implements "A new algorithm for Boolean operations on general polygons" 
                 available here: http://liama.ia.ac.cn/wiki/_media/user:dong:dong_cg_05.pdf
                 Merges two polygons, a subject and a clip with the specified operation. Polygons may not be 
                 self-intersecting.
                 Warning: May yield incorrect results or even crash if polygons contain collinear points.
                 *
                 * @static
                 * @private
                 * @this FarseerPhysics.Common.PolygonManipulation.YuPengClipper
                 * @memberof FarseerPhysics.Common.PolygonManipulation.YuPengClipper
                 * @param   {FarseerPhysics.Common.Vertices}                             subject     The subject polygon.
                 * @param   {FarseerPhysics.Common.Vertices}                             clip        The clip polygon, which is added, 
                 substracted or intersected with the subject
                 * @param   {FarseerPhysics.Common.PolygonManipulation.PolyClipType}     clipType    The operation to be performed. Either
                 Union, Difference or Intersection.
                 * @param   {FarseerPhysics.Common.PolygonManipulation.PolyClipError}    error       The error generated (if any)
                 * @return  {System.Collections.Generic.List$1}                                      A list of closed polygons, which make up the result of the clipping operation.
                 Outer contours are ordered counter clockwise, holes are ordered clockwise.
                 */
                Execute: function (subject, clip, clipType, error) {
                    System.Diagnostics.Debug.Assert$2(subject.IsSimple() && clip.IsSimple(), "Non simple input!", "Input polygons must be simple (cannot intersect themselves).");

                    var slicedSubject = { };
                    var slicedClip = { };
                    FarseerPhysics.Common.PolygonManipulation.YuPengClipper.CalculateIntersections(subject, clip, slicedSubject, slicedClip);

                    var lbSubject = { v : subject.GetCollisionBox().LowerBound.$clone() };
                    var lbClip = { v : clip.GetCollisionBox().LowerBound.$clone() };
                    var translate = { v : new Microsoft.Xna.Framework.Vector2() };
                    Microsoft.Xna.Framework.Vector2.Min$1(lbSubject, lbClip, translate);
                    translate.v = Microsoft.Xna.Framework.Vector2.op_Subtraction(Microsoft.Xna.Framework.Vector2.One.$clone(), translate.v.$clone());
                    if (Microsoft.Xna.Framework.Vector2.op_Inequality(translate.v.$clone(), Microsoft.Xna.Framework.Vector2.Zero.$clone())) {
                        slicedSubject.v.Translate$1(translate);
                        slicedClip.v.Translate$1(translate);
                    }

                    slicedSubject.v.ForceCounterClockWise();
                    slicedClip.v.ForceCounterClockWise();

                    var subjectSimplices = { };
                    var subjectCoeff = { };
                    var clipSimplices = { };
                    var clipCoeff = { };
                    FarseerPhysics.Common.PolygonManipulation.YuPengClipper.CalculateSimplicalChain(slicedSubject.v, subjectCoeff, subjectSimplices);
                    FarseerPhysics.Common.PolygonManipulation.YuPengClipper.CalculateSimplicalChain(slicedClip.v, clipCoeff, clipSimplices);

                    var resultSimplices = { };

                    FarseerPhysics.Common.PolygonManipulation.YuPengClipper.CalculateResultChain(subjectCoeff.v, subjectSimplices.v, clipCoeff.v, clipSimplices.v, clipType, resultSimplices);

                    var result = { };
                    error.v = FarseerPhysics.Common.PolygonManipulation.YuPengClipper.BuildPolygonsFromChain(resultSimplices.v, result);

                    translate.v = Microsoft.Xna.Framework.Vector2.op_Multiply$1(translate.v.$clone(), -1.0);
                    for (var i = 0; i < result.v.Count; i = (i + 1) | 0) {
                        result.v.getItem(i).Translate$1(translate);
                        FarseerPhysics.Common.PolygonManipulation.SimplifyTools.CollinearSimplify(result.v.getItem(i));
                    }
                    return result.v;
                },
                /**
                 * Calculates all intersections between two polygons.
                 *
                 * @static
                 * @private
                 * @this FarseerPhysics.Common.PolygonManipulation.YuPengClipper
                 * @memberof FarseerPhysics.Common.PolygonManipulation.YuPengClipper
                 * @param   {FarseerPhysics.Common.Vertices}    polygon1       The first polygon.
                 * @param   {FarseerPhysics.Common.Vertices}    polygon2       The second polygon.
                 * @param   {FarseerPhysics.Common.Vertices}    slicedPoly1    Returns the first polygon with added intersection points.
                 * @param   {FarseerPhysics.Common.Vertices}    slicedPoly2    Returns the second polygon with added intersection points.
                 * @return  {void}
                 */
                CalculateIntersections: function (polygon1, polygon2, slicedPoly1, slicedPoly2) {
                    slicedPoly1.v = new FarseerPhysics.Common.Vertices.$ctor2(polygon1);
                    slicedPoly2.v = new FarseerPhysics.Common.Vertices.$ctor2(polygon2);

                    for (var i = 0; i < polygon1.Count; i = (i + 1) | 0) {
                        var a = polygon1.getItem(i).$clone();
                        var b = polygon1.getItem(polygon1.NextIndex(i)).$clone();

                        for (var j = 0; j < polygon2.Count; j = (j + 1) | 0) {
                            var c = polygon2.getItem(j).$clone();
                            var d = polygon2.getItem(polygon2.NextIndex(j)).$clone();

                            var intersectionPoint = { v : new Microsoft.Xna.Framework.Vector2() };
                            if (FarseerPhysics.Common.LineTools.LineIntersect$1(a.$clone(), b.$clone(), c.$clone(), d.$clone(), intersectionPoint)) {
                                var alpha;
                                alpha = FarseerPhysics.Common.PolygonManipulation.YuPengClipper.GetAlpha(a.$clone(), b.$clone(), intersectionPoint.v.$clone());
                                if (alpha > 0.0 && alpha < 1.0) {
                                    var index = (slicedPoly1.v.indexOf(a.$clone()) + 1) | 0;
                                    while (index < slicedPoly1.v.Count && FarseerPhysics.Common.PolygonManipulation.YuPengClipper.GetAlpha(a.$clone(), b.$clone(), slicedPoly1.v.getItem(index).$clone()) <= alpha) {
                                        index = (index + 1) | 0;
                                    }
                                    slicedPoly1.v.insert(index, intersectionPoint.v.$clone());
                                }
                                alpha = FarseerPhysics.Common.PolygonManipulation.YuPengClipper.GetAlpha(c.$clone(), d.$clone(), intersectionPoint.v.$clone());
                                if (alpha > 0.0 && alpha < 1.0) {
                                    var index1 = (slicedPoly2.v.indexOf(c.$clone()) + 1) | 0;
                                    while (index1 < slicedPoly2.v.Count && FarseerPhysics.Common.PolygonManipulation.YuPengClipper.GetAlpha(c.$clone(), d.$clone(), slicedPoly2.v.getItem(index1).$clone()) <= alpha) {
                                        index1 = (index1 + 1) | 0;
                                    }
                                    slicedPoly2.v.insert(index1, intersectionPoint.v.$clone());
                                }
                            }
                        }
                    }
                    for (var i1 = 0; i1 < slicedPoly1.v.Count; i1 = (i1 + 1) | 0) {
                        var iNext = slicedPoly1.v.NextIndex(i1);
                        if ((Microsoft.Xna.Framework.Vector2.op_Subtraction(slicedPoly1.v.getItem(iNext).$clone(), slicedPoly1.v.getItem(i1).$clone())).LengthSquared() <= FarseerPhysics.Common.PolygonManipulation.YuPengClipper.ClipperEpsilonSquared) {
                            slicedPoly1.v.removeAt(i1);
                            i1 = (i1 - 1) | 0;
                        }
                    }
                    for (var i2 = 0; i2 < slicedPoly2.v.Count; i2 = (i2 + 1) | 0) {
                        var iNext1 = slicedPoly2.v.NextIndex(i2);
                        if ((Microsoft.Xna.Framework.Vector2.op_Subtraction(slicedPoly2.v.getItem(iNext1).$clone(), slicedPoly2.v.getItem(i2).$clone())).LengthSquared() <= FarseerPhysics.Common.PolygonManipulation.YuPengClipper.ClipperEpsilonSquared) {
                            slicedPoly2.v.removeAt(i2);
                            i2 = (i2 - 1) | 0;
                        }
                    }
                },
                /**
                 * Calculates the simplical chain corresponding to the input polygon.
                 *
                 * @static
                 * @private
                 * @this FarseerPhysics.Common.PolygonManipulation.YuPengClipper
                 * @memberof FarseerPhysics.Common.PolygonManipulation.YuPengClipper
                 * @param   {FarseerPhysics.Common.Vertices}     poly          
                 * @param   {System.Collections.Generic.List}    coeff         
                 * @param   {System.Collections.Generic.List}    simplicies
                 * @return  {void}
                 */
                CalculateSimplicalChain: function (poly, coeff, simplicies) {
                    simplicies.v = new (System.Collections.Generic.List$1(FarseerPhysics.Common.PolygonManipulation.YuPengClipper.Edge)).ctor();
                    coeff.v = new (System.Collections.Generic.List$1(System.Single)).ctor();
                    for (var i = 0; i < poly.Count; i = (i + 1) | 0) {
                        simplicies.v.add(new FarseerPhysics.Common.PolygonManipulation.YuPengClipper.Edge(poly.getItem(i).$clone(), poly.getItem(poly.NextIndex(i)).$clone()));
                        coeff.v.add(FarseerPhysics.Common.PolygonManipulation.YuPengClipper.CalculateSimplexCoefficient(Microsoft.Xna.Framework.Vector2.Zero.$clone(), poly.getItem(i).$clone(), poly.getItem(poly.NextIndex(i)).$clone()));
                    }
                },
                /**
                 * Calculates the characteristics function for all edges of
                 the given simplical chains and builds the result chain.
                 *
                 * @static
                 * @private
                 * @this FarseerPhysics.Common.PolygonManipulation.YuPengClipper
                 * @memberof FarseerPhysics.Common.PolygonManipulation.YuPengClipper
                 * @param   {System.Collections.Generic.List$1}                         poly1Coeff         
                 * @param   {System.Collections.Generic.List$1}                         poly1Simplicies    
                 * @param   {System.Collections.Generic.List$1}                         poly2Coeff         
                 * @param   {System.Collections.Generic.List$1}                         poly2Simplicies    
                 * @param   {FarseerPhysics.Common.PolygonManipulation.PolyClipType}    clipType           
                 * @param   {System.Collections.Generic.List}                           resultSimplices
                 * @return  {void}
                 */
                CalculateResultChain: function (poly1Coeff, poly1Simplicies, poly2Coeff, poly2Simplicies, clipType, resultSimplices) {
                    resultSimplices.v = new (System.Collections.Generic.List$1(FarseerPhysics.Common.PolygonManipulation.YuPengClipper.Edge)).ctor();

                    for (var i = 0; i < poly1Simplicies.Count; i = (i + 1) | 0) {
                        var edgeCharacter = 0.0;
                        if (poly2Simplicies.contains(poly1Simplicies.getItem(i)) || (poly2Simplicies.contains(FarseerPhysics.Common.PolygonManipulation.YuPengClipper.Edge.op_UnaryNegation(poly1Simplicies.getItem(i))) && clipType === FarseerPhysics.Common.PolygonManipulation.PolyClipType.Union)) {
                            edgeCharacter = 1.0;
                        } else {
                            for (var j = 0; j < poly2Simplicies.Count; j = (j + 1) | 0) {
                                if (!poly2Simplicies.contains(FarseerPhysics.Common.PolygonManipulation.YuPengClipper.Edge.op_UnaryNegation(poly1Simplicies.getItem(i)))) {
                                    edgeCharacter += FarseerPhysics.Common.PolygonManipulation.YuPengClipper.CalculateBeta(poly1Simplicies.getItem(i).GetCenter(), poly2Simplicies.getItem(j), poly2Coeff.getItem(j));
                                }
                            }
                        }
                        if (clipType === FarseerPhysics.Common.PolygonManipulation.PolyClipType.Intersect) {
                            if (edgeCharacter === 1.0) {
                                resultSimplices.v.add(poly1Simplicies.getItem(i));
                            }
                        } else {
                            if (edgeCharacter === 0.0) {
                                resultSimplices.v.add(poly1Simplicies.getItem(i));
                            }
                        }
                    }
                    for (var i1 = 0; i1 < poly2Simplicies.Count; i1 = (i1 + 1) | 0) {
                        if (!resultSimplices.v.contains(poly2Simplicies.getItem(i1)) && !resultSimplices.v.contains(FarseerPhysics.Common.PolygonManipulation.YuPengClipper.Edge.op_UnaryNegation(poly2Simplicies.getItem(i1)))) {
                            var edgeCharacter1 = 0.0;
                            if (poly1Simplicies.contains(poly2Simplicies.getItem(i1)) || (poly1Simplicies.contains(FarseerPhysics.Common.PolygonManipulation.YuPengClipper.Edge.op_UnaryNegation(poly2Simplicies.getItem(i1))) && clipType === FarseerPhysics.Common.PolygonManipulation.PolyClipType.Union)) {
                                edgeCharacter1 = 1.0;
                            } else {
                                for (var j1 = 0; j1 < poly1Simplicies.Count; j1 = (j1 + 1) | 0) {
                                    if (!poly1Simplicies.contains(FarseerPhysics.Common.PolygonManipulation.YuPengClipper.Edge.op_UnaryNegation(poly2Simplicies.getItem(i1)))) {
                                        edgeCharacter1 += FarseerPhysics.Common.PolygonManipulation.YuPengClipper.CalculateBeta(poly2Simplicies.getItem(i1).GetCenter(), poly1Simplicies.getItem(j1), poly1Coeff.getItem(j1));
                                    }
                                }
                            }
                            if (clipType === FarseerPhysics.Common.PolygonManipulation.PolyClipType.Intersect || clipType === FarseerPhysics.Common.PolygonManipulation.PolyClipType.Difference) {
                                if (edgeCharacter1 === 1.0) {
                                    resultSimplices.v.add(FarseerPhysics.Common.PolygonManipulation.YuPengClipper.Edge.op_UnaryNegation(poly2Simplicies.getItem(i1)));
                                }
                            } else {
                                if (edgeCharacter1 === 0.0) {
                                    resultSimplices.v.add(poly2Simplicies.getItem(i1));
                                }
                            }
                        }
                    }
                },
                /**
                 * Calculates the polygon(s) from the result simplical chain.
                 *
                 * @static
                 * @private
                 * @this FarseerPhysics.Common.PolygonManipulation.YuPengClipper
                 * @memberof FarseerPhysics.Common.PolygonManipulation.YuPengClipper
                 * @param   {System.Collections.Generic.List$1}                          simplicies    
                 * @param   {System.Collections.Generic.List}                            result
                 * @return  {FarseerPhysics.Common.PolygonManipulation.PolyClipError}
                 */
                BuildPolygonsFromChain: function (simplicies, result) {
                    result.v = new (System.Collections.Generic.List$1(FarseerPhysics.Common.Vertices)).ctor();
                    var errVal = FarseerPhysics.Common.PolygonManipulation.PolyClipError.None;

                    while (simplicies.Count > 0) {
                        var output = new FarseerPhysics.Common.Vertices.ctor();
                        output.add(simplicies.getItem(0).EdgeStart.$clone());
                        output.add(simplicies.getItem(0).EdgeEnd.$clone());
                        simplicies.removeAt(0);
                        var closed = false;
                        var index = 0;
                        var count = simplicies.Count;
                        while (!closed && simplicies.Count > 0) {
                            if (FarseerPhysics.Common.PolygonManipulation.YuPengClipper.VectorEqual(output.getItem(((output.Count - 1) | 0)).$clone(), simplicies.getItem(index).EdgeStart.$clone())) {
                                if (FarseerPhysics.Common.PolygonManipulation.YuPengClipper.VectorEqual(simplicies.getItem(index).EdgeEnd.$clone(), output.getItem(0).$clone())) {
                                    closed = true;
                                } else {
                                    output.add(simplicies.getItem(index).EdgeEnd.$clone());
                                }
                                simplicies.removeAt(index);
                                index = (index - 1) | 0;
                            } else if (FarseerPhysics.Common.PolygonManipulation.YuPengClipper.VectorEqual(output.getItem(((output.Count - 1) | 0)).$clone(), simplicies.getItem(index).EdgeEnd.$clone())) {
                                if (FarseerPhysics.Common.PolygonManipulation.YuPengClipper.VectorEqual(simplicies.getItem(index).EdgeStart.$clone(), output.getItem(0).$clone())) {
                                    closed = true;
                                } else {
                                    output.add(simplicies.getItem(index).EdgeStart.$clone());
                                }
                                simplicies.removeAt(index);
                                index = (index - 1) | 0;
                            }
                            if (!closed) {
                                if (((index = (index + 1) | 0)) === simplicies.Count) {
                                    if (count === simplicies.Count) {
                                        result.v = new (System.Collections.Generic.List$1(FarseerPhysics.Common.Vertices)).ctor();
                                        System.Diagnostics.Debug.WriteLine$2("Undefined error while building result polygon(s).");
                                        return FarseerPhysics.Common.PolygonManipulation.PolyClipError.BrokenResult;
                                    }
                                    index = 0;
                                    count = simplicies.Count;
                                }
                            }
                        }
                        if (output.Count < 3) {
                            errVal = FarseerPhysics.Common.PolygonManipulation.PolyClipError.DegeneratedOutput;
                            System.Diagnostics.Debug.WriteLine$2("Degenerated output polygon produced (vertices < 3).");
                        }
                        result.v.add(output);
                    }
                    return errVal;
                },
                /**
                 * Needed to calculate the characteristics function of a simplex.
                 *
                 * @static
                 * @private
                 * @this FarseerPhysics.Common.PolygonManipulation.YuPengClipper
                 * @memberof FarseerPhysics.Common.PolygonManipulation.YuPengClipper
                 * @param   {Microsoft.Xna.Framework.Vector2}                                 point          
                 * @param   {FarseerPhysics.Common.PolygonManipulation.YuPengClipper.Edge}    e              
                 * @param   {number}                                                          coefficient
                 * @return  {number}
                 */
                CalculateBeta: function (point, e, coefficient) {
                    var result = 0.0;
                    if (FarseerPhysics.Common.PolygonManipulation.YuPengClipper.PointInSimplex(point.$clone(), e)) {
                        result = coefficient;
                    }
                    if (FarseerPhysics.Common.PolygonManipulation.YuPengClipper.PointOnLineSegment(Microsoft.Xna.Framework.Vector2.Zero.$clone(), e.EdgeStart.$clone(), point.$clone()) || FarseerPhysics.Common.PolygonManipulation.YuPengClipper.PointOnLineSegment(Microsoft.Xna.Framework.Vector2.Zero.$clone(), e.EdgeEnd.$clone(), point.$clone())) {
                        result = 0.5 * coefficient;
                    }
                    return result;
                },
                /**
                 * Needed for sorting multiple intersections points on the same edge.
                 *
                 * @static
                 * @private
                 * @this FarseerPhysics.Common.PolygonManipulation.YuPengClipper
                 * @memberof FarseerPhysics.Common.PolygonManipulation.YuPengClipper
                 * @param   {Microsoft.Xna.Framework.Vector2}    start    
                 * @param   {Microsoft.Xna.Framework.Vector2}    end      
                 * @param   {Microsoft.Xna.Framework.Vector2}    point
                 * @return  {number}
                 */
                GetAlpha: function (start, end, point) {
                    return (Microsoft.Xna.Framework.Vector2.op_Subtraction(point.$clone(), start.$clone())).LengthSquared() / (Microsoft.Xna.Framework.Vector2.op_Subtraction(end.$clone(), start.$clone())).LengthSquared();
                },
                /**
                 * Returns the coefficient of a simplex.
                 *
                 * @static
                 * @private
                 * @this FarseerPhysics.Common.PolygonManipulation.YuPengClipper
                 * @memberof FarseerPhysics.Common.PolygonManipulation.YuPengClipper
                 * @param   {Microsoft.Xna.Framework.Vector2}    a    
                 * @param   {Microsoft.Xna.Framework.Vector2}    b    
                 * @param   {Microsoft.Xna.Framework.Vector2}    c
                 * @return  {number}
                 */
                CalculateSimplexCoefficient: function (a, b, c) {
                    a = {v:a};
                    b = {v:b};
                    c = {v:c};
                    var isLeft = FarseerPhysics.Common.MathUtils.Area$1(a, b, c);
                    if (isLeft < 0.0) {
                        return -1.0;
                    }

                    if (isLeft > 0.0) {
                        return 1.0;
                    }

                    return 0.0;
                },
                /**
                 * Winding number test for a point in a simplex.
                 *
                 * @static
                 * @private
                 * @this FarseerPhysics.Common.PolygonManipulation.YuPengClipper
                 * @memberof FarseerPhysics.Common.PolygonManipulation.YuPengClipper
                 * @param   {Microsoft.Xna.Framework.Vector2}                                 point    The point to be tested.
                 * @param   {FarseerPhysics.Common.PolygonManipulation.YuPengClipper.Edge}    edge     The edge that the point is tested against.
                 * @return  {boolean}                                                                  False if the winding number is even and the point is outside
                 the simplex and True otherwise.
                 */
                PointInSimplex: function (point, edge) {
                    point = {v:point};
                    var polygon = new FarseerPhysics.Common.Vertices.ctor();
                    polygon.add(Microsoft.Xna.Framework.Vector2.Zero.$clone());
                    polygon.add(edge.EdgeStart.$clone());
                    polygon.add(edge.EdgeEnd.$clone());
                    return (polygon.PointInPolygon(point) === 1);
                },
                /**
                 * Tests if a point lies on a line segment.
                 *
                 * @static
                 * @private
                 * @this FarseerPhysics.Common.PolygonManipulation.YuPengClipper
                 * @memberof FarseerPhysics.Common.PolygonManipulation.YuPengClipper
                 * @param   {Microsoft.Xna.Framework.Vector2}    start    
                 * @param   {Microsoft.Xna.Framework.Vector2}    end      
                 * @param   {Microsoft.Xna.Framework.Vector2}    point
                 * @return  {boolean}
                 */
                PointOnLineSegment: function (start, end, point) {
                    start = {v:start};
                    end = {v:end};
                    point = {v:point};
                    var segment = Microsoft.Xna.Framework.Vector2.op_Subtraction(end.v.$clone(), start.v.$clone());
                    return FarseerPhysics.Common.MathUtils.Area$1(start, end, point) === 0.0 && Microsoft.Xna.Framework.Vector2.Dot(Microsoft.Xna.Framework.Vector2.op_Subtraction(point.v.$clone(), start.v.$clone()), segment.$clone()) >= 0.0 && Microsoft.Xna.Framework.Vector2.Dot(Microsoft.Xna.Framework.Vector2.op_Subtraction(point.v.$clone(), end.v.$clone()), segment.$clone()) <= 0.0;
                },
                VectorEqual: function (vec1, vec2) {
                    return (Microsoft.Xna.Framework.Vector2.op_Subtraction(vec2.$clone(), vec1.$clone())).LengthSquared() <= FarseerPhysics.Common.PolygonManipulation.YuPengClipper.ClipperEpsilonSquared;
                }
            }
        }
    });

    /** @namespace FarseerPhysics.Common.PolygonManipulation */

    /**
     * Specifies an Edge. Edges are used to represent simplicies in simplical chains
     *
     * @private
     * @class FarseerPhysics.Common.PolygonManipulation.YuPengClipper.Edge
     */
    Bridge.define("FarseerPhysics.Common.PolygonManipulation.YuPengClipper.Edge", {
        $kind: "nested class",
        statics: {
            methods: {
                op_UnaryNegation: function (e) {
                    return new FarseerPhysics.Common.PolygonManipulation.YuPengClipper.Edge(e.EdgeEnd.$clone(), e.EdgeStart.$clone());
                }
            }
        },
        fields: {
            EdgeStart: null,
            EdgeEnd: null
        },
        ctors: {
            init: function () {
                this.EdgeStart = new Microsoft.Xna.Framework.Vector2();
                this.EdgeEnd = new Microsoft.Xna.Framework.Vector2();
            },
            ctor: function (edgeStart, edgeEnd) {
                this.$initialize();
                this.EdgeStart = edgeStart.$clone();
                this.EdgeEnd = edgeEnd.$clone();
            }
        },
        methods: {
            GetCenter: function () {
                return Microsoft.Xna.Framework.Vector2.op_Division$1((Microsoft.Xna.Framework.Vector2.op_Addition(this.EdgeStart.$clone(), this.EdgeEnd.$clone())), 2.0);
            },
            equals: function (obj) {
                if (obj == null) {
                    return false;
                }

                return this.Equals(Bridge.as(obj, FarseerPhysics.Common.PolygonManipulation.YuPengClipper.Edge));
            },
            Equals: function (e) {
                if (e == null) {
                    return false;
                }

                return FarseerPhysics.Common.PolygonManipulation.YuPengClipper.VectorEqual(this.EdgeStart.$clone(), e.EdgeStart.$clone()) && FarseerPhysics.Common.PolygonManipulation.YuPengClipper.VectorEqual(this.EdgeEnd.$clone(), e.EdgeEnd.$clone());
            },
            getHashCode: function () {
                return this.EdgeStart.getHashCode() ^ this.EdgeEnd.getHashCode();
            }
        }
    });

    Bridge.define("FarseerPhysics.Common.PolygonTools", {
        statics: {
            methods: {
                /**
                 * Build vertices to represent an axis-aligned box.
                 *
                 * @static
                 * @public
                 * @this FarseerPhysics.Common.PolygonTools
                 * @memberof FarseerPhysics.Common.PolygonTools
                 * @param   {number}                            hx    the half-width.
                 * @param   {number}                            hy    the half-height.
                 * @return  {FarseerPhysics.Common.Vertices}
                 */
                CreateRectangle: function (hx, hy) {
                    var vertices = new FarseerPhysics.Common.Vertices.$ctor3(4);
                    vertices.add(new Microsoft.Xna.Framework.Vector2.$ctor2(-hx, -hy));
                    vertices.add(new Microsoft.Xna.Framework.Vector2.$ctor2(hx, -hy));
                    vertices.add(new Microsoft.Xna.Framework.Vector2.$ctor2(hx, hy));
                    vertices.add(new Microsoft.Xna.Framework.Vector2.$ctor2(-hx, hy));

                    return vertices;
                },
                /**
                 * Build vertices to represent an oriented box.
                 *
                 * @static
                 * @public
                 * @this FarseerPhysics.Common.PolygonTools
                 * @memberof FarseerPhysics.Common.PolygonTools
                 * @param   {number}                             hx        the half-width.
                 * @param   {number}                             hy        the half-height.
                 * @param   {Microsoft.Xna.Framework.Vector2}    center    the center of the box in local coordinates.
                 * @param   {number}                             angle     the rotation of the box in local coordinates.
                 * @return  {FarseerPhysics.Common.Vertices}
                 */
                CreateRectangle$1: function (hx, hy, center, angle) {
                    var vertices = FarseerPhysics.Common.PolygonTools.CreateRectangle(hx, hy);

                    var xf = { v : new FarseerPhysics.Common.Transform.ctor() };
                    xf.v.Position = center.$clone();
                    xf.v.R.Set$1(angle);

                    for (var i = 0; i < 4; i = (i + 1) | 0) {
                        vertices.setItem(i, FarseerPhysics.Common.MathUtils.Multiply$2(xf, vertices.getItem(i).$clone()));
                    }

                    return vertices;
                },
                /**
                 * Creates a rounded rectangle with the specified width and height.
                 *
                 * @static
                 * @public
                 * @this FarseerPhysics.Common.PolygonTools
                 * @memberof FarseerPhysics.Common.PolygonTools
                 * @param   {number}                            width       The width.
                 * @param   {number}                            height      The height.
                 * @param   {number}                            xRadius     The rounding X radius.
                 * @param   {number}                            yRadius     The rounding Y radius.
                 * @param   {number}                            segments    The number of segments to subdivide the edges.
                 * @return  {FarseerPhysics.Common.Vertices}
                 */
                CreateRoundedRectangle: function (width, height, xRadius, yRadius, segments) {
                    if (yRadius > height / 2 || xRadius > width / 2) {
                        throw new System.Exception("Rounding amount can't be more than half the height and width respectively.");
                    }
                    if (segments < 0) {
                        throw new System.Exception("Segments must be zero or more.");
                    }

                    System.Diagnostics.Debug.Assert(FarseerPhysics.Settings.MaxPolygonVertices >= 8);

                    var vertices = new FarseerPhysics.Common.Vertices.ctor();
                    if (segments === 0) {
                        vertices.add(new Microsoft.Xna.Framework.Vector2.$ctor2(width * 0.5 - xRadius, -height * 0.5));
                        vertices.add(new Microsoft.Xna.Framework.Vector2.$ctor2(width * 0.5, -height * 0.5 + yRadius));

                        vertices.add(new Microsoft.Xna.Framework.Vector2.$ctor2(width * 0.5, height * 0.5 - yRadius));
                        vertices.add(new Microsoft.Xna.Framework.Vector2.$ctor2(width * 0.5 - xRadius, height * 0.5));

                        vertices.add(new Microsoft.Xna.Framework.Vector2.$ctor2(-width * 0.5 + xRadius, height * 0.5));
                        vertices.add(new Microsoft.Xna.Framework.Vector2.$ctor2(-width * 0.5, height * 0.5 - yRadius));

                        vertices.add(new Microsoft.Xna.Framework.Vector2.$ctor2(-width * 0.5, -height * 0.5 + yRadius));
                        vertices.add(new Microsoft.Xna.Framework.Vector2.$ctor2(-width * 0.5 + xRadius, -height * 0.5));
                    } else {
                        var numberOfEdges = (((Bridge.Int.mul(segments, 4) + 8) | 0));

                        var stepSize = Microsoft.Xna.Framework.MathHelper.TwoPi / (((numberOfEdges - 4) | 0));
                        var perPhase = (Bridge.Int.div(numberOfEdges, 4)) | 0;

                        var posOffset = new Microsoft.Xna.Framework.Vector2.$ctor2(width / 2 - xRadius, height / 2 - yRadius);
                        vertices.add(Microsoft.Xna.Framework.Vector2.op_Addition(posOffset.$clone(), new Microsoft.Xna.Framework.Vector2.$ctor2(xRadius, -yRadius + yRadius)));
                        var phase = 0;
                        for (var i = 1; i < numberOfEdges; i = (i + 1) | 0) {
                            if (((i - perPhase) | 0) === 0 || ((i - Bridge.Int.mul(perPhase, 3)) | 0) === 0) {
                                posOffset.X *= -1;
                                phase = Bridge.Int.sxs((phase - 1) & 65535);
                            } else if (((i - Bridge.Int.mul(perPhase, 2)) | 0) === 0) {
                                posOffset.Y *= -1;
                                phase = Bridge.Int.sxs((phase - 1) & 65535);
                            }

                            vertices.add(Microsoft.Xna.Framework.Vector2.op_Addition(posOffset.$clone(), new Microsoft.Xna.Framework.Vector2.$ctor2(xRadius * Math.cos(stepSize * ((-(((i + phase) | 0))) | 0)), -yRadius * Math.sin(stepSize * ((-(((i + phase) | 0))) | 0)))));
                        }
                    }

                    return vertices;
                },
                /**
                 * Set this as a single edge.
                 *
                 * @static
                 * @public
                 * @this FarseerPhysics.Common.PolygonTools
                 * @memberof FarseerPhysics.Common.PolygonTools
                 * @param   {Microsoft.Xna.Framework.Vector2}    start    The first point.
                 * @param   {Microsoft.Xna.Framework.Vector2}    end      The second point.
                 * @return  {FarseerPhysics.Common.Vertices}
                 */
                CreateLine: function (start, end) {
                    var vertices = new FarseerPhysics.Common.Vertices.$ctor3(2);
                    vertices.add(start.$clone());
                    vertices.add(end.$clone());

                    return vertices;
                },
                /**
                 * Creates a circle with the specified radius and number of edges.
                 *
                 * @static
                 * @public
                 * @this FarseerPhysics.Common.PolygonTools
                 * @memberof FarseerPhysics.Common.PolygonTools
                 * @param   {number}                            radius           The radius.
                 * @param   {number}                            numberOfEdges    The number of edges. The more edges, the more it resembles a circle
                 * @return  {FarseerPhysics.Common.Vertices}
                 */
                CreateCircle: function (radius, numberOfEdges) {
                    return FarseerPhysics.Common.PolygonTools.CreateEllipse(radius, radius, numberOfEdges);
                },
                /**
                 * Creates a ellipse with the specified width, height and number of edges.
                 *
                 * @static
                 * @public
                 * @this FarseerPhysics.Common.PolygonTools
                 * @memberof FarseerPhysics.Common.PolygonTools
                 * @param   {number}                            xRadius          Width of the ellipse.
                 * @param   {number}                            yRadius          Height of the ellipse.
                 * @param   {number}                            numberOfEdges    The number of edges. The more edges, the more it resembles an ellipse
                 * @return  {FarseerPhysics.Common.Vertices}
                 */
                CreateEllipse: function (xRadius, yRadius, numberOfEdges) {
                    var vertices = new FarseerPhysics.Common.Vertices.ctor();

                    var stepSize = Microsoft.Xna.Framework.MathHelper.TwoPi / numberOfEdges;

                    vertices.add(new Microsoft.Xna.Framework.Vector2.$ctor2(xRadius, 0));
                    for (var i = (numberOfEdges - 1) | 0; i > 0; i = (i - 1) | 0) {
                        vertices.add(new Microsoft.Xna.Framework.Vector2.$ctor2(xRadius * Math.cos(stepSize * i), -yRadius * Math.sin(stepSize * i)));
                    }

                    return vertices;
                },
                CreateArc: function (radians, sides, radius) {
                    System.Diagnostics.Debug.Assert$1(radians > 0, "The arc needs to be larger than 0");
                    System.Diagnostics.Debug.Assert$1(sides > 1, "The arc needs to have more than 1 sides");
                    System.Diagnostics.Debug.Assert$1(radius > 0, "The arc needs to have a radius larger than 0");

                    var vertices = new FarseerPhysics.Common.Vertices.ctor();

                    var stepSize = radians / sides;
                    for (var i = (sides - 1) | 0; i > 0; i = (i - 1) | 0) {
                        vertices.add(new Microsoft.Xna.Framework.Vector2.$ctor2(radius * Math.cos(stepSize * i), radius * Math.sin(stepSize * i)));
                    }

                    return vertices;
                },
                /**
                 * Creates an capsule with the specified height, radius and number of edges.
                 A capsule has the same form as a pill capsule.
                 *
                 * @static
                 * @public
                 * @this FarseerPhysics.Common.PolygonTools
                 * @memberof FarseerPhysics.Common.PolygonTools
                 * @param   {number}                            height       Height (inner height + 2 * radius) of the capsule.
                 * @param   {number}                            endRadius    Radius of the capsule ends.
                 * @param   {number}                            edges        The number of edges of the capsule ends. The more edges, the more it resembles an capsule
                 * @return  {FarseerPhysics.Common.Vertices}
                 */
                CreateCapsule: function (height, endRadius, edges) {
                    if (endRadius >= height / 2) {
                        throw new System.ArgumentException.$ctor3("The radius must be lower than height / 2. Higher values of radius would create a circle, and not a half circle.", "endRadius");
                    }

                    return FarseerPhysics.Common.PolygonTools.CreateCapsule$1(height, endRadius, edges, endRadius, edges);
                },
                /**
                 * Creates an capsule with the specified  height, radius and number of edges.
                 A capsule has the same form as a pill capsule.
                 *
                 * @static
                 * @public
                 * @this FarseerPhysics.Common.PolygonTools
                 * @memberof FarseerPhysics.Common.PolygonTools
                 * @param   {number}                            height          Height (inner height + radii) of the capsule.
                 * @param   {number}                            topRadius       Radius of the top.
                 * @param   {number}                            topEdges        The number of edges of the top. The more edges, the more it resembles an capsule
                 * @param   {number}                            bottomRadius    Radius of bottom.
                 * @param   {number}                            bottomEdges     The number of edges of the bottom. The more edges, the more it resembles an capsule
                 * @return  {FarseerPhysics.Common.Vertices}
                 */
                CreateCapsule$1: function (height, topRadius, topEdges, bottomRadius, bottomEdges) {
                    if (height <= 0) {
                        throw new System.ArgumentException.$ctor3("Height must be longer than 0", "height");
                    }

                    if (topRadius <= 0) {
                        throw new System.ArgumentException.$ctor3("The top radius must be more than 0", "topRadius");
                    }

                    if (topEdges <= 0) {
                        throw new System.ArgumentException.$ctor3("Top edges must be more than 0", "topEdges");
                    }

                    if (bottomRadius <= 0) {
                        throw new System.ArgumentException.$ctor3("The bottom radius must be more than 0", "bottomRadius");
                    }

                    if (bottomEdges <= 0) {
                        throw new System.ArgumentException.$ctor3("Bottom edges must be more than 0", "bottomEdges");
                    }

                    if (topRadius >= height / 2) {
                        throw new System.ArgumentException.$ctor3("The top radius must be lower than height / 2. Higher values of top radius would create a circle, and not a half circle.", "topRadius");
                    }

                    if (bottomRadius >= height / 2) {
                        throw new System.ArgumentException.$ctor3("The bottom radius must be lower than height / 2. Higher values of bottom radius would create a circle, and not a half circle.", "bottomRadius");
                    }

                    var vertices = new FarseerPhysics.Common.Vertices.ctor();

                    var newHeight = (height - topRadius - bottomRadius) * 0.5;

                    vertices.add(new Microsoft.Xna.Framework.Vector2.$ctor2(topRadius, newHeight));

                    var stepSize = Microsoft.Xna.Framework.MathHelper.Pi / topEdges;
                    for (var i = 1; i < topEdges; i = (i + 1) | 0) {
                        vertices.add(new Microsoft.Xna.Framework.Vector2.$ctor2(topRadius * Math.cos(stepSize * i), topRadius * Math.sin(stepSize * i) + newHeight));
                    }

                    vertices.add(new Microsoft.Xna.Framework.Vector2.$ctor2(-topRadius, newHeight));

                    vertices.add(new Microsoft.Xna.Framework.Vector2.$ctor2(-bottomRadius, -newHeight));

                    stepSize = Microsoft.Xna.Framework.MathHelper.Pi / bottomEdges;
                    for (var i1 = 1; i1 < bottomEdges; i1 = (i1 + 1) | 0) {
                        vertices.add(new Microsoft.Xna.Framework.Vector2.$ctor2(-bottomRadius * Math.cos(stepSize * i1), -bottomRadius * Math.sin(stepSize * i1) - newHeight));
                    }

                    vertices.add(new Microsoft.Xna.Framework.Vector2.$ctor2(bottomRadius, -newHeight));

                    return vertices;
                },
                /**
                 * Creates a gear shape with the specified radius and number of teeth.
                 *
                 * @static
                 * @public
                 * @this FarseerPhysics.Common.PolygonTools
                 * @memberof FarseerPhysics.Common.PolygonTools
                 * @param   {number}                            radius           The radius.
                 * @param   {number}                            numberOfTeeth    The number of teeth.
                 * @param   {number}                            tipPercentage    The tip percentage.
                 * @param   {number}                            toothHeight      Height of the tooth.
                 * @return  {FarseerPhysics.Common.Vertices}
                 */
                CreateGear: function (radius, numberOfTeeth, tipPercentage, toothHeight) {
                    var vertices = new FarseerPhysics.Common.Vertices.ctor();

                    var stepSize = Microsoft.Xna.Framework.MathHelper.TwoPi / numberOfTeeth;
                    tipPercentage /= 100.0;
                    Microsoft.Xna.Framework.MathHelper.Clamp$1(tipPercentage, 0.0, 1.0);
                    var toothTipStepSize = (stepSize / 2.0) * tipPercentage;

                    var toothAngleStepSize = (stepSize - (toothTipStepSize * 2.0)) / 2.0;

                    for (var i = (numberOfTeeth - 1) | 0; i >= 0; i = (i - 1) | 0) {
                        if (toothTipStepSize > 0.0) {
                            vertices.add(new Microsoft.Xna.Framework.Vector2.$ctor2(radius * Math.cos(stepSize * i + toothAngleStepSize * 2.0 + toothTipStepSize), -radius * Math.sin(stepSize * i + toothAngleStepSize * 2.0 + toothTipStepSize)));

                            vertices.add(new Microsoft.Xna.Framework.Vector2.$ctor2((radius + toothHeight) * Math.cos(stepSize * i + toothAngleStepSize + toothTipStepSize), -(radius + toothHeight) * Math.sin(stepSize * i + toothAngleStepSize + toothTipStepSize)));
                        }

                        vertices.add(new Microsoft.Xna.Framework.Vector2.$ctor2((radius + toothHeight) * Math.cos(stepSize * i + toothAngleStepSize), -(radius + toothHeight) * Math.sin(stepSize * i + toothAngleStepSize)));

                        vertices.add(new Microsoft.Xna.Framework.Vector2.$ctor2(radius * Math.cos(stepSize * i), -radius * Math.sin(stepSize * i)));
                    }

                    return vertices;
                },
                /**
                 * Detects the vertices by analyzing the texture data.
                 *
                 * @static
                 * @public
                 * @this FarseerPhysics.Common.PolygonTools
                 * @memberof FarseerPhysics.Common.PolygonTools
                 * @param   {Array.<number>}                    data     The texture data.
                 * @param   {number}                            width    The texture width.
                 * @return  {FarseerPhysics.Common.Vertices}
                 */
                CreatePolygon: function (data, width) {
                    return FarseerPhysics.Common.TextureConverter.DetectVertices(data, width);
                },
                /**
                 * Detects the vertices by analyzing the texture data.
                 *
                 * @static
                 * @public
                 * @this FarseerPhysics.Common.PolygonTools
                 * @memberof FarseerPhysics.Common.PolygonTools
                 * @param   {Array.<number>}                    data             The texture data.
                 * @param   {number}                            width            The texture width.
                 * @param   {boolean}                           holeDetection    if set to <pre><code>true</code></pre> it will perform hole detection.
                 * @return  {FarseerPhysics.Common.Vertices}
                 */
                CreatePolygon$1: function (data, width, holeDetection) {
                    return FarseerPhysics.Common.TextureConverter.DetectVertices$1(data, width, holeDetection);
                },
                /**
                 * Detects the vertices by analyzing the texture data.
                 *
                 * @static
                 * @public
                 * @this FarseerPhysics.Common.PolygonTools
                 * @memberof FarseerPhysics.Common.PolygonTools
                 * @param   {Array.<number>}                       data                  The texture data.
                 * @param   {number}                               width                 The texture width.
                 * @param   {number}                               hullTolerance         The hull tolerance.
                 * @param   {number}                               alphaTolerance        The alpha tolerance.
                 * @param   {boolean}                              multiPartDetection    if set to <pre><code>true</code></pre> it will perform multi part detection.
                 * @param   {boolean}                              holeDetection         if set to <pre><code>true</code></pre> it will perform hole detection.
                 * @return  {System.Collections.Generic.List$1}
                 */
                CreatePolygon$2: function (data, width, hullTolerance, alphaTolerance, multiPartDetection, holeDetection) {
                    return FarseerPhysics.Common.TextureConverter.DetectVertices$2(data, width, hullTolerance, alphaTolerance, multiPartDetection, holeDetection);
                }
            }
        }
    });

    /**
     * This describes the motion of a body/shape for TOI computation.
     Shapes are defined with respect to the body origin, which may
     no coincide with the center of mass. However, to support dynamics
     we must interpolate the center of mass position.
     *
     * @public
     * @class FarseerPhysics.Common.Sweep
     */
    Bridge.define("FarseerPhysics.Common.Sweep", {
        $kind: "struct",
        statics: {
            methods: {
                getDefaultValue: function () { return new FarseerPhysics.Common.Sweep(); }
            }
        },
        fields: {
            /**
             * World angles
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Common.Sweep
             * @type number
             */
            A: 0,
            A0: 0,
            /**
             * Fraction of the current time step in the range [0,1]
             c0 and a0 are the positions at alpha0.
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Common.Sweep
             * @type number
             */
            Alpha0: 0,
            /**
             * Center world positions
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Common.Sweep
             * @type Microsoft.Xna.Framework.Vector2
             */
            C: null,
            C0: null,
            /**
             * Local center of mass position
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Common.Sweep
             * @type Microsoft.Xna.Framework.Vector2
             */
            LocalCenter: null
        },
        ctors: {
            init: function () {
                this.C = new Microsoft.Xna.Framework.Vector2();
                this.C0 = new Microsoft.Xna.Framework.Vector2();
                this.LocalCenter = new Microsoft.Xna.Framework.Vector2();
            },
            ctor: function () {
                this.$initialize();
            }
        },
        methods: {
            /**
             * Get the interpolated transform at a specific time.
             *
             * @instance
             * @public
             * @this FarseerPhysics.Common.Sweep
             * @memberof FarseerPhysics.Common.Sweep
             * @param   {FarseerPhysics.Common.Transform}    xf      The transform.
             * @param   {number}                             beta    beta is a factor in [0,1], where 0 indicates alpha0.
             * @return  {void}
             */
            GetTransform: function (xf, beta) {
                xf.v = new FarseerPhysics.Common.Transform.ctor();
                xf.v.Position.X = (1.0 - beta) * this.C0.X + beta * this.C.X;
                xf.v.Position.Y = (1.0 - beta) * this.C0.Y + beta * this.C.Y;
                var angle = (1.0 - beta) * this.A0 + beta * this.A;
                xf.v.R.Set$1(angle);

                xf.v.Position = Microsoft.Xna.Framework.Vector2.op_Subtraction(xf.v.Position.$clone(), FarseerPhysics.Common.MathUtils.Multiply$1(Bridge.ref(xf.v, "R"), Bridge.ref(this, "LocalCenter")));
            },
            /**
             * Advance the sweep forward, yielding a new initial state.
             *
             * @instance
             * @public
             * @this FarseerPhysics.Common.Sweep
             * @memberof FarseerPhysics.Common.Sweep
             * @param   {number}    alpha    new initial time..
             * @return  {void}
             */
            Advance: function (alpha) {
                System.Diagnostics.Debug.Assert(this.Alpha0 < 1.0);
                var beta = (alpha - this.Alpha0) / (1.0 - this.Alpha0);
                this.C0.X = (1.0 - beta) * this.C0.X + beta * this.C.X;
                this.C0.Y = (1.0 - beta) * this.C0.Y + beta * this.C.Y;
                this.A0 = (1.0 - beta) * this.A0 + beta * this.A;
                this.Alpha0 = alpha;
            },
            /**
             * Normalize the angles.
             *
             * @instance
             * @public
             * @this FarseerPhysics.Common.Sweep
             * @memberof FarseerPhysics.Common.Sweep
             * @return  {void}
             */
            Normalize: function () {
                var d = Microsoft.Xna.Framework.MathHelper.TwoPi * Math.floor(this.A0 / Microsoft.Xna.Framework.MathHelper.TwoPi);
                this.A0 -= d;
                this.A -= d;
            },
            getHashCode: function () {
                var h = Bridge.addHash([1701148611, this.A, this.A0, this.Alpha0, this.C, this.C0, this.LocalCenter]);
                return h;
            },
            equals: function (o) {
                if (!Bridge.is(o, FarseerPhysics.Common.Sweep)) {
                    return false;
                }
                return Bridge.equals(this.A, o.A) && Bridge.equals(this.A0, o.A0) && Bridge.equals(this.Alpha0, o.Alpha0) && Bridge.equals(this.C, o.C) && Bridge.equals(this.C0, o.C0) && Bridge.equals(this.LocalCenter, o.LocalCenter);
            },
            $clone: function (to) {
                var s = to || new FarseerPhysics.Common.Sweep();
                s.A = this.A;
                s.A0 = this.A0;
                s.Alpha0 = this.Alpha0;
                s.C = this.C.$clone();
                s.C0 = this.C0.$clone();
                s.LocalCenter = this.LocalCenter.$clone();
                return s;
            }
        }
    });

    /**
     * @public
     * @class FarseerPhysics.Common.TextureConverter
     */
    Bridge.define("FarseerPhysics.Common.TextureConverter", {
        statics: {
            fields: {
                _CLOSEPIXELS_LENGTH: 0,
                /**
                 * This array is ment to be readonly.
                 It's not because it is accessed very frequently.
                 *
                 * @static
                 * @private
                 * @memberof FarseerPhysics.Common.TextureConverter
                 * @type Array.<number>
                 */
                ClosePixels: null
            },
            ctors: {
                init: function () {
                    this._CLOSEPIXELS_LENGTH = 8;
                    this.ClosePixels = System.Array.create(0, [[-1, -1], [0, -1], [1, -1], [1, 0], [1, 1], [0, 1], [-1, 1], [-1, 0]], System.Int32, 8, 2);
                }
            },
            methods: {
                /**
                 * Detects the vertices of the supplied texture data. (PolygonDetectionType.Integrated)
                 *
                 * @static
                 * @public
                 * @this FarseerPhysics.Common.TextureConverter
                 * @memberof FarseerPhysics.Common.TextureConverter
                 * @param   {Array.<number>}                    data     The texture data.
                 * @param   {number}                            width    The texture width.
                 * @return  {FarseerPhysics.Common.Vertices}
                 */
                DetectVertices: function (data, width) {
                    var tc = new FarseerPhysics.Common.TextureConverter.$ctor2(data, width);

                    var detectedVerticesList = tc.DetectVertices();

                    return detectedVerticesList.getItem(0);
                },
                /**
                 * Detects the vertices of the supplied texture data.
                 *
                 * @static
                 * @public
                 * @this FarseerPhysics.Common.TextureConverter
                 * @memberof FarseerPhysics.Common.TextureConverter
                 * @param   {Array.<number>}                    data             The texture data.
                 * @param   {number}                            width            The texture width.
                 * @param   {boolean}                           holeDetection    if set to <pre><code>true</code></pre> it will perform hole detection.
                 * @return  {FarseerPhysics.Common.Vertices}
                 */
                DetectVertices$1: function (data, width, holeDetection) {
                    var $t;
                    var tc = ($t = new FarseerPhysics.Common.TextureConverter.$ctor2(data, width), $t.HoleDetection = holeDetection, $t);

                    var detectedVerticesList = tc.DetectVertices();

                    return detectedVerticesList.getItem(0);
                },
                /**
                 * Detects the vertices of the supplied texture data.
                 *
                 * @static
                 * @public
                 * @this FarseerPhysics.Common.TextureConverter
                 * @memberof FarseerPhysics.Common.TextureConverter
                 * @param   {Array.<number>}                       data                  The texture data.
                 * @param   {number}                               width                 The texture width.
                 * @param   {number}                               hullTolerance         The hull tolerance.
                 * @param   {number}                               alphaTolerance        The alpha tolerance.
                 * @param   {boolean}                              multiPartDetection    if set to <pre><code>true</code></pre> it will perform multi part detection.
                 * @param   {boolean}                              holeDetection         if set to <pre><code>true</code></pre> it will perform hole detection.
                 * @return  {System.Collections.Generic.List$1}
                 */
                DetectVertices$2: function (data, width, hullTolerance, alphaTolerance, multiPartDetection, holeDetection) {
                    var $t;
                    var tc = ($t = new FarseerPhysics.Common.TextureConverter.$ctor2(data, width), $t.HullTolerance = hullTolerance, $t.AlphaTolerance = alphaTolerance, $t.MultipartDetection = multiPartDetection, $t.HoleDetection = holeDetection, $t);

                    var detectedVerticesList = tc.DetectVertices();
                    var result = new (System.Collections.Generic.List$1(FarseerPhysics.Common.Vertices)).ctor();

                    for (var i = 0; i < detectedVerticesList.Count; i = (i + 1) | 0) {
                        result.add(detectedVerticesList.getItem(i));
                    }

                    return result;
                }
            }
        },
        fields: {
            _data: null,
            _dataLength: 0,
            _width: 0,
            _height: 0,
            _polygonDetectionType: 0,
            _alphaTolerance: 0,
            _hullTolerance: 0,
            _holeDetection: false,
            _multipartDetection: false,
            _pixelOffsetOptimization: false,
            _transform: null,
            _tempIsSolidX: 0,
            _tempIsSolidY: 0
        },
        props: {
            /**
             * Get or set the polygon detection type.
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Common.TextureConverter
             * @function PolygonDetectionType
             * @type FarseerPhysics.Common.VerticesDetectionType
             */
            PolygonDetectionType: {
                get: function () {
                    return this._polygonDetectionType;
                },
                set: function (value) {
                    this._polygonDetectionType = value;
                }
            },
            /**
             * Will detect texture 'holes' if set to true. Slows down the detection. Default is false.
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Common.TextureConverter
             * @function HoleDetection
             * @type boolean
             */
            HoleDetection: {
                get: function () {
                    return this._holeDetection;
                },
                set: function (value) {
                    this._holeDetection = value;
                }
            },
            /**
             * Will detect texture multiple 'solid' isles if set to true. Slows down the detection. Default is false.
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Common.TextureConverter
             * @function MultipartDetection
             * @type boolean
             */
            MultipartDetection: {
                get: function () {
                    return this._multipartDetection;
                },
                set: function (value) {
                    this._multipartDetection = value;
                }
            },
            /**
             * Will optimize the vertex positions along the interpolated normal between two edges about a half pixel (post processing). Default is false.
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Common.TextureConverter
             * @function PixelOffsetOptimization
             * @type boolean
             */
            PixelOffsetOptimization: {
                get: function () {
                    return this._pixelOffsetOptimization;
                },
                set: function (value) {
                    this._pixelOffsetOptimization = value;
                }
            },
            /**
             * Can be used for scaling.
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Common.TextureConverter
             * @function Transform
             * @type Microsoft.Xna.Framework.Matrix
             */
            Transform: {
                get: function () {
                    return this._transform.$clone();
                },
                set: function (value) {
                    this._transform = value.$clone();
                }
            },
            /**
             * Alpha (coverage) tolerance. Default is 20: Every pixel with a coverage value equal or greater to 20 will be counts as solid.
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Common.TextureConverter
             * @function AlphaTolerance
             * @type number
             */
            AlphaTolerance: {
                get: function () {
                    return ((this._alphaTolerance >>> 24) & 255);
                },
                set: function (value) {
                    this._alphaTolerance = (value << 24) >>> 0;
                }
            },
            /**
             * Default is 1.5f.
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Common.TextureConverter
             * @function HullTolerance
             * @type number
             */
            HullTolerance: {
                get: function () {
                    return this._hullTolerance;
                },
                set: function (value) {
                    if (value > 4.0) {
                        this._hullTolerance = 4.0;
                    } else if (value < 0.9) {
                        this._hullTolerance = 0.9;
                    } else {
                        this._hullTolerance = value;
                    }
                }
            }
        },
        ctors: {
            init: function () {
                this._transform = new Microsoft.Xna.Framework.Matrix();
                this._transform = Microsoft.Xna.Framework.Matrix.Identity.$clone();
            },
            ctor: function () {
                this.$initialize();
                this.Initialize(null, null, null, null, null, null, null, null);
            },
            $ctor1: function (alphaTolerance, hullTolerance, holeDetection, multipartDetection, pixelOffsetOptimization, transform) {
                this.$initialize();
                this.Initialize(null, null, alphaTolerance, hullTolerance, holeDetection, multipartDetection, pixelOffsetOptimization, System.Nullable.lift1("$clone", transform));
            },
            $ctor2: function (data, width) {
                this.$initialize();
                this.Initialize(data, width, null, null, null, null, null, null);
            },
            $ctor3: function (data, width, alphaTolerance, hullTolerance, holeDetection, multipartDetection, pixelOffsetOptimization, transform) {
                this.$initialize();
                this.Initialize(data, width, alphaTolerance, hullTolerance, holeDetection, multipartDetection, pixelOffsetOptimization, System.Nullable.lift1("$clone", transform));
            }
        },
        methods: {
            Initialize: function (data, width, alphaTolerance, hullTolerance, holeDetection, multipartDetection, pixelOffsetOptimization, transform) {
                if (data != null && !System.Nullable.hasValue(width)) {
                    throw new System.ArgumentNullException.$ctor3("width", "'width' can't be null if 'data' is set.");
                }

                if (data == null && System.Nullable.hasValue(width)) {
                    throw new System.ArgumentNullException.$ctor3("data", "'data' can't be null if 'width' is set.");
                }

                if (data != null && System.Nullable.hasValue(width)) {
                    this.SetTextureData(data, System.Nullable.getValue(width));
                }

                if (System.Nullable.hasValue(alphaTolerance)) {
                    this.AlphaTolerance = System.Nullable.getValue(alphaTolerance);
                } else {
                    this.AlphaTolerance = 20;
                }

                if (System.Nullable.hasValue(hullTolerance)) {
                    this.HullTolerance = System.Nullable.getValue(hullTolerance);
                } else {
                    this.HullTolerance = 1.5;
                }

                if (System.Nullable.hasValue(holeDetection)) {
                    this.HoleDetection = System.Nullable.getValue(holeDetection);
                } else {
                    this.HoleDetection = false;
                }

                if (System.Nullable.hasValue(multipartDetection)) {
                    this.MultipartDetection = System.Nullable.getValue(multipartDetection);
                } else {
                    this.MultipartDetection = false;
                }

                if (System.Nullable.hasValue(pixelOffsetOptimization)) {
                    this.PixelOffsetOptimization = System.Nullable.getValue(pixelOffsetOptimization);
                } else {
                    this.PixelOffsetOptimization = false;
                }

                if (System.Nullable.hasValue(transform)) {
                    this.Transform = System.Nullable.getValue(transform).$clone();
                } else {
                    this.Transform = Microsoft.Xna.Framework.Matrix.Identity.$clone();
                }
            },
            /**
             * @instance
             * @private
             * @this FarseerPhysics.Common.TextureConverter
             * @memberof FarseerPhysics.Common.TextureConverter
             * @param   {Array.<number>}    data     
             * @param   {number}            width
             * @return  {void}
             */
            SetTextureData: function (data, width) {
                if (data == null) {
                    throw new System.ArgumentNullException.$ctor3("data", "'data' can't be null.");
                }

                if (data.length < 4) {
                    throw new System.ArgumentOutOfRangeException.$ctor4("data", "'data' length can't be less then 4. Your texture must be at least 2 x 2 pixels in size.");
                }

                if (width < 2) {
                    throw new System.ArgumentOutOfRangeException.$ctor4("width", "'width' can't be less then 2. Your texture must be at least 2 x 2 pixels in size.");
                }

                if (data.length % width !== 0) {
                    throw new System.ArgumentException.$ctor1("'width' has an invalid value.");
                }

                this._data = data;
                this._dataLength = this._data.length;
                this._width = width;
                this._height = (Bridge.Int.div(this._dataLength, width)) | 0;
            },
            DetectVertices: function () {

                if (this._data == null) {
                    throw new System.Exception("'_data' can't be null. You have to use SetTextureData(uint[] data, int width) before calling this method.");
                }

                if (this._data.length < 4) {
                    throw new System.Exception("'_data' length can't be less then 4. Your texture must be at least 2 x 2 pixels in size. You have to use SetTextureData(uint[] data, int width) before calling this method.");
                }

                if (this._width < 2) {
                    throw new System.Exception("'_width' can't be less then 2. Your texture must be at least 2 x 2 pixels in size. You have to use SetTextureData(uint[] data, int width) before calling this method.");
                }

                if (this._data.length % this._width !== 0) {
                    throw new System.Exception("'_width' has an invalid value. You have to use SetTextureData(uint[] data, int width) before calling this method.");
                }



                var detectedPolygons = { v : new (System.Collections.Generic.List$1(FarseerPhysics.Common.DetectedVertices)).ctor() };

                var polygon;
                var holePolygon;

                var holeEntrance = null;
                var polygonEntrance = { v : null };

                var blackList = new (System.Collections.Generic.List$1(Microsoft.Xna.Framework.Vector2)).ctor();

                var searchOn;
                do {
                    if (detectedPolygons.v.Count === 0) {
                        polygon = new FarseerPhysics.Common.DetectedVertices.$ctor1(this.CreateSimplePolygon(Microsoft.Xna.Framework.Vector2.Zero.$clone(), Microsoft.Xna.Framework.Vector2.Zero.$clone()));

                        if (polygon.Count > 2) {
                            polygonEntrance.v = this.GetTopMostVertex(polygon);
                        }
                    } else if (System.Nullable.hasValue(polygonEntrance.v)) {
                        polygon = new FarseerPhysics.Common.DetectedVertices.$ctor1(this.CreateSimplePolygon(System.Nullable.getValue(polygonEntrance.v).$clone(), new Microsoft.Xna.Framework.Vector2.$ctor2(System.Nullable.getValue(polygonEntrance.v).X - 1.0, System.Nullable.getValue(polygonEntrance.v).Y)));
                    } else {
                        break;
                    }

                    searchOn = false;


                    if (polygon.Count > 2) {
                        if (this._holeDetection) {
                            do {
                                holeEntrance = this.SearchHoleEntrance(polygon, System.Nullable.lift1("$clone", holeEntrance));

                                if (System.Nullable.hasValue(holeEntrance)) {
                                    if (!blackList.contains(System.Nullable.getValue(holeEntrance).$clone())) {
                                        blackList.add(System.Nullable.getValue(holeEntrance).$clone());
                                        holePolygon = this.CreateSimplePolygon(System.Nullable.getValue(holeEntrance).$clone(), new Microsoft.Xna.Framework.Vector2.$ctor2(System.Nullable.getValue(holeEntrance).X + 1, System.Nullable.getValue(holeEntrance).Y));

                                        if (holePolygon != null && holePolygon.Count > 2) {
                                            switch (this._polygonDetectionType) {
                                                case FarseerPhysics.Common.VerticesDetectionType.Integrated: 
                                                    holePolygon.add(holePolygon.getItem(0).$clone());
                                                    var vertex1Index = { }, vertex2Index = { };
                                                    if (this.SplitPolygonEdge(polygon, System.Nullable.getValue(holeEntrance).$clone(), vertex1Index, vertex2Index)) {
                                                        polygon.InsertRange(vertex2Index.v, holePolygon);
                                                    }
                                                    break;
                                                case FarseerPhysics.Common.VerticesDetectionType.Separated: 
                                                    if (polygon.Holes == null) {
                                                        polygon.Holes = new (System.Collections.Generic.List$1(FarseerPhysics.Common.Vertices)).ctor();
                                                    }
                                                    polygon.Holes.add(holePolygon);
                                                    break;
                                            }
                                        }
                                    } else {
                                        break;
                                    }
                                } else {
                                    break;
                                }
                            } while (true);
                        }

                        detectedPolygons.v.add(polygon);
                    }

                    if (this._multipartDetection || polygon.Count <= 2) {
                        if (this.SearchNextHullEntrance(detectedPolygons.v, System.Nullable.getValue(polygonEntrance.v).$clone(), polygonEntrance)) {
                            searchOn = true;
                        }
                    }
                } while (searchOn);

                if (detectedPolygons.v == null || (detectedPolygons.v != null && detectedPolygons.v.Count === 0)) {
                    throw new System.Exception("Couldn't detect any vertices.");
                }


                if (this.PolygonDetectionType === FarseerPhysics.Common.VerticesDetectionType.Separated) {
                    this.ApplyTriangulationCompatibleWinding(detectedPolygons);
                }

                if (this._pixelOffsetOptimization) {
                    this.ApplyPixelOffsetOptimization(detectedPolygons);
                }

                if (Microsoft.Xna.Framework.Matrix.op_Inequality(this._transform.$clone(), Microsoft.Xna.Framework.Matrix.Identity.$clone())) {
                    this.ApplyTransform(detectedPolygons);
                }


                return detectedPolygons.v;
            },
            ApplyTriangulationCompatibleWinding: function (detectedPolygons) {
                for (var i = 0; i < detectedPolygons.v.Count; i = (i + 1) | 0) {
                    detectedPolygons.v.getItem(i).Reverse();

                    if (detectedPolygons.v.getItem(i).Holes != null && detectedPolygons.v.getItem(i).Holes.Count > 0) {
                        for (var j = 0; j < detectedPolygons.v.getItem(i).Holes.Count; j = (j + 1) | 0) {
                            detectedPolygons.v.getItem(i).Holes.getItem(j).Reverse();
                        }
                    }
                }
            },
            ApplyPixelOffsetOptimization: function (detectedPolygons) {

            },
            ApplyTransform: function (detectedPolygons) {
                for (var i = 0; i < detectedPolygons.v.Count; i = (i + 1) | 0) {
                    detectedPolygons.v.getItem(i).Transform(this._transform.$clone());
                }
            },
            IsSolid: function (v) {
                this._tempIsSolidX = Bridge.Int.clip32(v.v.X);
                this._tempIsSolidY = Bridge.Int.clip32(v.v.Y);

                if (this._tempIsSolidX >= 0 && this._tempIsSolidX < this._width && this._tempIsSolidY >= 0 && this._tempIsSolidY < this._height) {
                    return (this._data[System.Array.index(((this._tempIsSolidX + Bridge.Int.mul(this._tempIsSolidY, this._width)) | 0), this._data)] >= this._alphaTolerance);
                }

                return false;
            },
            IsSolid$2: function (x, y) {
                if (x.v >= 0 && x.v < this._width && y.v >= 0 && y.v < this._height) {
                    return (this._data[System.Array.index(((x.v + Bridge.Int.mul(y.v, this._width)) | 0), this._data)] >= this._alphaTolerance);
                }

                return false;
            },
            IsSolid$1: function (index) {
                if (index.v >= 0 && index.v < this._dataLength) {
                    return (this._data[System.Array.index(index.v, this._data)] >= this._alphaTolerance);
                }

                return false;
            },
            InBounds: function (coord) {
                return (coord.v.X >= 0.0 && coord.v.X < this._width && coord.v.Y >= 0.0 && coord.v.Y < this._height);
            },
            /**
             * Function to search for an entrance point of a hole in a polygon. It searches the polygon from top to bottom between the polygon edges.
             *
             * @instance
             * @private
             * @this FarseerPhysics.Common.TextureConverter
             * @memberof FarseerPhysics.Common.TextureConverter
             * @param   {FarseerPhysics.Common.Vertices}      polygon             The polygon to search in.
             * @param   {?Microsoft.Xna.Framework.Vector2}    lastHoleEntrance    The last entrance point.
             * @return  {?Microsoft.Xna.Framework.Vector2}                        The next holes entrance point. Null if ther are no holes.
             */
            SearchHoleEntrance: function (polygon, lastHoleEntrance) {
                if (polygon == null) {
                    throw new System.ArgumentNullException.$ctor1("'polygon' can't be null.");
                }

                if (polygon.Count < 3) {
                    throw new System.ArgumentException.$ctor1("'polygon.MainPolygon.Count' can't be less then 3.");
                }


                var xCoords;
                var entrance;

                var startY;
                var endY;

                var lastSolid = 0;
                var foundSolid;
                var foundTransparent;

                if (System.Nullable.hasValue(lastHoleEntrance)) {
                    startY = Bridge.Int.clip32(System.Nullable.getValue(lastHoleEntrance).Y);
                } else {
                    startY = Bridge.Int.clip32(this.GetTopMostCoord(polygon));
                }

                endY = Bridge.Int.clip32(this.GetBottomMostCoord(polygon));

                if (startY > 0 && startY < this._height && endY > 0 && endY < this._height) {
                    for (var y = { v : startY }; y.v <= endY; y.v = (y.v + 1) | 0) {
                        xCoords = this.SearchCrossingEdges$1(polygon, y.v);

                        if (xCoords.Count > 1 && xCoords.Count % 2 === 0) {
                            for (var i = 0; i < xCoords.Count; i = (i + 2) | 0) {
                                foundSolid = false;
                                foundTransparent = false;

                                for (var x = { v : Bridge.Int.clip32(xCoords.getItem(i)) }; x.v <= Bridge.Int.clip32(xCoords.getItem(((i + 1) | 0))); x.v = (x.v + 1) | 0) {



                                    if (this.IsSolid$2(x, y)) {
                                        if (!foundTransparent) {
                                            foundSolid = true;
                                            lastSolid = x.v;
                                        }

                                        if (foundSolid && foundTransparent) {
                                            entrance = new Microsoft.Xna.Framework.Vector2.$ctor2(lastSolid, y.v);

                                            if (this.DistanceToHullAcceptable$1(polygon, System.Nullable.getValue(entrance).$clone(), true)) {
                                                return System.Nullable.lift1("$clone", entrance);
                                            }

                                            entrance = null;
                                            break;
                                        }
                                    } else {
                                        if (foundSolid) {
                                            foundTransparent = true;
                                        }
                                    }
                                }
                            }
                        } else {
                            if (xCoords.Count % 2 === 0) {
                                System.Diagnostics.Debug.WriteLine$2("SearchCrossingEdges() % 2 != 0");
                            }
                        }
                    }
                }

                return null;
            },
            DistanceToHullAcceptable: function (polygon, point, higherDetail) {
                if (polygon == null) {
                    throw new System.ArgumentNullException.$ctor3("polygon", "'polygon' can't be null.");
                }

                if (polygon.Count < 3) {
                    throw new System.ArgumentException.$ctor1("'polygon.MainPolygon.Count' can't be less then 3.");
                }

                if (this.DistanceToHullAcceptable$1(Bridge.cast(polygon, FarseerPhysics.Common.Vertices), point.$clone(), higherDetail)) {
                    if (polygon.Holes != null) {
                        for (var i = 0; i < polygon.Holes.Count; i = (i + 1) | 0) {
                            if (!this.DistanceToHullAcceptable$1(polygon.Holes.getItem(i), point.$clone(), higherDetail)) {
                                return false;
                            }
                        }
                    }

                    return true;
                }

                return false;
            },
            DistanceToHullAcceptable$1: function (polygon, point, higherDetail) {
                point = {v:point};
                if (polygon == null) {
                    throw new System.ArgumentNullException.$ctor3("polygon", "'polygon' can't be null.");
                }

                if (polygon.Count < 3) {
                    throw new System.ArgumentException.$ctor1("'polygon.Count' can't be less then 3.");
                }


                var edgeVertex2 = { v : polygon.getItem(((polygon.Count - 1) | 0)).$clone() };
                var edgeVertex1 = { v : new Microsoft.Xna.Framework.Vector2() };

                if (higherDetail) {
                    for (var i = 0; i < polygon.Count; i = (i + 1) | 0) {
                        edgeVertex1.v = polygon.getItem(i).$clone();

                        if (FarseerPhysics.Common.LineTools.DistanceBetweenPointAndLineSegment(point, edgeVertex1, edgeVertex2) <= this._hullTolerance || FarseerPhysics.Common.LineTools.DistanceBetweenPointAndPoint(point, edgeVertex1) <= this._hullTolerance) {
                            return false;
                        }

                        edgeVertex2.v = polygon.getItem(i).$clone();
                    }

                    return true;
                } else {
                    for (var i1 = 0; i1 < polygon.Count; i1 = (i1 + 1) | 0) {
                        edgeVertex1.v = polygon.getItem(i1).$clone();

                        if (FarseerPhysics.Common.LineTools.DistanceBetweenPointAndLineSegment(point, edgeVertex1, edgeVertex2) <= this._hullTolerance) {
                            return false;
                        }

                        edgeVertex2.v = polygon.getItem(i1).$clone();
                    }

                    return true;
                }
            },
            InPolygon: function (polygon, point) {
                var inPolygon = !this.DistanceToHullAcceptable(polygon, point.$clone(), true);

                if (!inPolygon) {
                    var xCoords = this.SearchCrossingEdges(polygon, Bridge.Int.clip32(point.Y));

                    if (xCoords.Count > 0 && xCoords.Count % 2 === 0) {
                        for (var i = 0; i < xCoords.Count; i = (i + 2) | 0) {
                            if (xCoords.getItem(i) <= point.X && xCoords.getItem(((i + 1) | 0)) >= point.X) {
                                return true;
                            }
                        }
                    }

                    return false;
                }

                return true;
            },
            GetTopMostVertex: function (vertices) {
                var topMostValue = 3.40282347E+38;
                var topMost = null;

                for (var i = 0; i < vertices.Count; i = (i + 1) | 0) {
                    if (topMostValue > vertices.getItem(i).$clone().Y) {
                        topMostValue = vertices.getItem(i).$clone().Y;
                        topMost = vertices.getItem(i).$clone();
                    }
                }

                return System.Nullable.lift1("$clone", topMost);
            },
            GetTopMostCoord: function (vertices) {
                var returnValue = 3.40282347E+38;

                for (var i = 0; i < vertices.Count; i = (i + 1) | 0) {
                    if (returnValue > vertices.getItem(i).$clone().Y) {
                        returnValue = vertices.getItem(i).$clone().Y;
                    }
                }

                return returnValue;
            },
            GetBottomMostCoord: function (vertices) {
                var returnValue = -3.40282347E+38;

                for (var i = 0; i < vertices.Count; i = (i + 1) | 0) {
                    if (returnValue < vertices.getItem(i).$clone().Y) {
                        returnValue = vertices.getItem(i).$clone().Y;
                    }
                }

                return returnValue;
            },
            SearchCrossingEdges: function (polygon, y) {
                if (polygon == null) {
                    throw new System.ArgumentNullException.$ctor3("polygon", "'polygon' can't be null.");
                }

                if (polygon.Count < 3) {
                    throw new System.ArgumentException.$ctor1("'polygon.MainPolygon.Count' can't be less then 3.");
                }

                var result = this.SearchCrossingEdges$1(Bridge.cast(polygon, FarseerPhysics.Common.Vertices), y);

                if (polygon.Holes != null) {
                    for (var i = 0; i < polygon.Holes.Count; i = (i + 1) | 0) {
                        result.AddRange(this.SearchCrossingEdges$1(polygon.Holes.getItem(i), y));
                    }
                }

                result.Sort();
                return result;
            },
            /**
             * Searches the polygon for the x coordinates of the edges that cross the specified y coordinate.
             *
             * @instance
             * @private
             * @this FarseerPhysics.Common.TextureConverter
             * @memberof FarseerPhysics.Common.TextureConverter
             * @param   {FarseerPhysics.Common.Vertices}       polygon    Polygon to search in.
             * @param   {number}                               y          Y coordinate to check for edges.
             * @return  {System.Collections.Generic.List$1}               Descending sorted list of x coordinates of edges that cross the specified y coordinate.
             */
            SearchCrossingEdges$1: function (polygon, y) {

                var edges = new (System.Collections.Generic.List$1(System.Single)).ctor();

                var slope = new Microsoft.Xna.Framework.Vector2();
                var vertex1 = new Microsoft.Xna.Framework.Vector2();
                var vertex2 = new Microsoft.Xna.Framework.Vector2();

                var nextSlope = new Microsoft.Xna.Framework.Vector2();
                var nextVertex = new Microsoft.Xna.Framework.Vector2();

                var addFind;

                if (polygon.Count > 2) {
                    vertex2 = polygon.getItem(((polygon.Count - 1) | 0)).$clone();

                    for (var i = 0; i < polygon.Count; i = (i + 1) | 0) {
                        vertex1 = polygon.getItem(i).$clone();

                        if ((vertex1.Y >= y && vertex2.Y <= y) || (vertex1.Y <= y && vertex2.Y >= y)) {
                            if (vertex1.Y !== vertex2.Y) {
                                addFind = true;
                                slope = Microsoft.Xna.Framework.Vector2.op_Subtraction(vertex2.$clone(), vertex1.$clone());

                                if (vertex1.Y === y) {
                                    nextVertex = polygon.getItem((((i + 1) | 0)) % polygon.Count).$clone();
                                    nextSlope = Microsoft.Xna.Framework.Vector2.op_Subtraction(vertex1.$clone(), nextVertex.$clone());

                                    if (slope.Y > 0) {
                                        addFind = (nextSlope.Y <= 0);
                                    } else {
                                        addFind = (nextSlope.Y >= 0);
                                    }
                                }

                                if (addFind) {
                                    edges.add((y - vertex1.Y) / slope.Y * slope.X + vertex1.X);
                                }
                            }
                        }

                        vertex2 = vertex1.$clone();
                    }
                }

                edges.Sort();
                return edges;
            },
            SplitPolygonEdge: function (polygon, coordInsideThePolygon, vertex1Index, vertex2Index) {
                var slope = new Microsoft.Xna.Framework.Vector2();
                var nearestEdgeVertex1Index = 0;
                var nearestEdgeVertex2Index = 0;
                var edgeFound = false;

                var shortestDistance = 3.40282347E+38;

                var edgeCoordFound = false;
                var foundEdgeCoord = { v : Microsoft.Xna.Framework.Vector2.Zero.$clone() };

                var xCoords = this.SearchCrossingEdges$1(polygon, Bridge.Int.clip32(coordInsideThePolygon.Y));

                vertex1Index.v = 0;
                vertex2Index.v = 0;

                foundEdgeCoord.v.Y = coordInsideThePolygon.Y;

                if (xCoords != null && xCoords.Count > 1 && xCoords.Count % 2 === 0) {
                    var distance;
                    for (var i = 0; i < xCoords.Count; i = (i + 1) | 0) {
                        if (xCoords.getItem(i) < coordInsideThePolygon.X) {
                            distance = coordInsideThePolygon.X - xCoords.getItem(i);

                            if (distance < shortestDistance) {
                                shortestDistance = distance;
                                foundEdgeCoord.v.X = xCoords.getItem(i);

                                edgeCoordFound = true;
                            }
                        }
                    }

                    if (edgeCoordFound) {
                        shortestDistance = 3.40282347E+38;

                        var edgeVertex2Index = (polygon.Count - 1) | 0;

                        var edgeVertex1Index;
                        for (edgeVertex1Index = 0; edgeVertex1Index < polygon.Count; edgeVertex1Index = (edgeVertex1Index + 1) | 0) {
                            var tempVector1 = { v : polygon.getItem(edgeVertex1Index).$clone() };
                            var tempVector2 = { v : polygon.getItem(edgeVertex2Index).$clone() };
                            distance = FarseerPhysics.Common.LineTools.DistanceBetweenPointAndLineSegment(foundEdgeCoord, tempVector1, tempVector2);
                            if (distance < shortestDistance) {
                                shortestDistance = distance;

                                nearestEdgeVertex1Index = edgeVertex1Index;
                                nearestEdgeVertex2Index = edgeVertex2Index;

                                edgeFound = true;
                            }

                            edgeVertex2Index = edgeVertex1Index;
                        }

                        if (edgeFound) {
                            slope = Microsoft.Xna.Framework.Vector2.op_Subtraction(polygon.getItem(nearestEdgeVertex2Index).$clone(), polygon.getItem(nearestEdgeVertex1Index).$clone());
                            slope.Normalize();

                            var tempVector = { v : polygon.getItem(nearestEdgeVertex1Index).$clone() };
                            distance = FarseerPhysics.Common.LineTools.DistanceBetweenPointAndPoint(tempVector, foundEdgeCoord);

                            vertex1Index.v = nearestEdgeVertex1Index;
                            vertex2Index.v = (nearestEdgeVertex1Index + 1) | 0;

                            polygon.insert(nearestEdgeVertex1Index, Microsoft.Xna.Framework.Vector2.op_Addition(Microsoft.Xna.Framework.Vector2.op_Multiply$2(distance, slope.$clone()), polygon.getItem(vertex1Index.v).$clone()));
                            polygon.insert(nearestEdgeVertex1Index, Microsoft.Xna.Framework.Vector2.op_Addition(Microsoft.Xna.Framework.Vector2.op_Multiply$2(distance, slope.$clone()), polygon.getItem(vertex2Index.v).$clone()));

                            return true;
                        }
                    }
                }

                return false;
            },
            /**
             * @instance
             * @private
             * @this FarseerPhysics.Common.TextureConverter
             * @memberof FarseerPhysics.Common.TextureConverter
             * @param   {Microsoft.Xna.Framework.Vector2}    entrance    
             * @param   {Microsoft.Xna.Framework.Vector2}    last
             * @return  {FarseerPhysics.Common.Vertices}
             */
            CreateSimplePolygon: function (entrance, last) {
                entrance = {v:entrance};
                last = {v:last};
                var entranceFound = false;
                var endOfHull = false;

                var polygon = new FarseerPhysics.Common.Vertices.$ctor3(32);
                var hullArea = new FarseerPhysics.Common.Vertices.$ctor3(32);
                var endOfHullArea = new FarseerPhysics.Common.Vertices.$ctor3(32);

                var current = { v : Microsoft.Xna.Framework.Vector2.Zero.$clone() };


                if (Microsoft.Xna.Framework.Vector2.op_Equality(entrance.v.$clone(), Microsoft.Xna.Framework.Vector2.Zero.$clone()) || !this.InBounds(entrance)) {
                    entranceFound = this.SearchHullEntrance(entrance);

                    if (entranceFound) {
                        current.v = new Microsoft.Xna.Framework.Vector2.$ctor2(entrance.v.X - 1.0, entrance.v.Y);
                    }
                } else {
                    if (this.IsSolid(entrance)) {
                        if (this.IsNearPixel(entrance, last)) {
                            current.v = last.v.$clone();
                            entranceFound = true;
                        } else {
                            var temp = { v : new Microsoft.Xna.Framework.Vector2() };
                            if (this.SearchNearPixels(false, entrance, temp)) {
                                current.v = temp.v.$clone();
                                entranceFound = true;
                            } else {
                                entranceFound = false;
                            }
                        }
                    }
                }


                if (entranceFound) {
                    polygon.add(entrance.v.$clone());
                    hullArea.add(entrance.v.$clone());

                    var next = { v : entrance.v.$clone() };

                    do {
                        var outstanding = { v : new Microsoft.Xna.Framework.Vector2() };
                        if (this.SearchForOutstandingVertex(hullArea, outstanding)) {
                            if (endOfHull) {
                                if (endOfHullArea.contains(outstanding.v.$clone())) {
                                    polygon.add(outstanding.v.$clone());
                                }

                                break;
                            }

                            polygon.add(outstanding.v.$clone());
                            hullArea.RemoveRange(0, hullArea.indexOf(outstanding.v.$clone()));
                        }

                        last.v = current.v.$clone();
                        current.v = next.v.$clone();

                        if (this.GetNextHullPoint(last, current, next)) {
                            hullArea.add(next.v.$clone());
                        } else {
                            break;
                        }

                        if (Microsoft.Xna.Framework.Vector2.op_Equality(next.v.$clone(), entrance.v.$clone()) && !endOfHull) {
                            endOfHull = true;
                            endOfHullArea.AddRange(hullArea);

                            if (endOfHullArea.contains(entrance.v.$clone())) {
                                endOfHullArea.remove(entrance.v.$clone());
                            }
                        }

                    } while (true);
                }

                return polygon;
            },
            SearchNearPixels: function (searchingForSolidPixel, current, foundPixel) {
                for (var i = 0; i < FarseerPhysics.Common.TextureConverter._CLOSEPIXELS_LENGTH; i = (i + 1) | 0) {
                    var x = { v : (Bridge.Int.clip32(current.v.X) + FarseerPhysics.Common.TextureConverter.ClosePixels.get([i, 0])) | 0 };
                    var y = { v : (Bridge.Int.clip32(current.v.Y) + FarseerPhysics.Common.TextureConverter.ClosePixels.get([i, 1])) | 0 };

                    if (!searchingForSolidPixel ^ this.IsSolid$2(x, y)) {
                        foundPixel.v = new Microsoft.Xna.Framework.Vector2.$ctor2(x.v, y.v);
                        return true;
                    }
                }

                foundPixel.v = Microsoft.Xna.Framework.Vector2.Zero.$clone();
                return false;
            },
            IsNearPixel: function (current, near) {
                for (var i = 0; i < FarseerPhysics.Common.TextureConverter._CLOSEPIXELS_LENGTH; i = (i + 1) | 0) {
                    var x = (Bridge.Int.clip32(current.v.X) + FarseerPhysics.Common.TextureConverter.ClosePixels.get([i, 0])) | 0;
                    var y = (Bridge.Int.clip32(current.v.Y) + FarseerPhysics.Common.TextureConverter.ClosePixels.get([i, 1])) | 0;

                    if (x >= 0 && x <= this._width && y >= 0 && y <= this._height) {
                        if (x === Bridge.Int.clip32(near.v.X) && y === Bridge.Int.clip32(near.v.Y)) {
                            return true;
                        }
                    }
                }

                return false;
            },
            SearchHullEntrance: function (entrance) {
                for (var y = { v : 0 }; y.v <= this._height; y.v = (y.v + 1) | 0) {
                    for (var x = { v : 0 }; x.v <= this._width; x.v = (x.v + 1) | 0) {
                        if (this.IsSolid$2(x, y)) {
                            entrance.v = new Microsoft.Xna.Framework.Vector2.$ctor2(x.v, y.v);
                            return true;
                        }
                    }
                }

                entrance.v = Microsoft.Xna.Framework.Vector2.Zero.$clone();
                return false;
            },
            /**
             * Searches for the next shape.
             *
             * @instance
             * @private
             * @this FarseerPhysics.Common.TextureConverter
             * @memberof FarseerPhysics.Common.TextureConverter
             * @param   {System.Collections.Generic.List$1}    detectedPolygons    Already detected polygons.
             * @param   {Microsoft.Xna.Framework.Vector2}      start               Search start coordinate.
             * @param   {System.Nullable}                      entrance            Returns the found entrance coordinate. Null if no other shapes found.
             * @return  {boolean}                                                  True if a new shape was found.
             */
            SearchNextHullEntrance: function (detectedPolygons, start, entrance) {
                var x;

                var foundTransparent = false;
                var inPolygon = false;

                for (var i = { v : (Bridge.Int.clip32(start.X) + Bridge.Int.mul(Bridge.Int.clip32(start.Y), this._width)) | 0 }; i.v <= this._dataLength; i.v = (i.v + 1) | 0) {
                    if (this.IsSolid$1(i)) {
                        if (foundTransparent) {
                            x = i.v % this._width;
                            entrance.v = new Microsoft.Xna.Framework.Vector2.$ctor2(x, (((i.v - x) | 0)) / this._width);

                            inPolygon = false;
                            for (var polygonIdx = 0; polygonIdx < detectedPolygons.Count; polygonIdx = (polygonIdx + 1) | 0) {
                                if (this.InPolygon(detectedPolygons.getItem(polygonIdx), System.Nullable.getValue(entrance.v).$clone())) {
                                    inPolygon = true;
                                    break;
                                }
                            }

                            if (inPolygon) {
                                foundTransparent = false;
                            } else {
                                return true;
                            }
                        }
                    } else {
                        foundTransparent = true;
                    }
                }

                entrance.v = null;
                return false;
            },
            GetNextHullPoint: function (last, current, next) {
                var x = { };
                var y = { };

                var indexOfFirstPixelToCheck = this.GetIndexOfFirstPixelToCheck(last, current);
                var indexOfPixelToCheck;

                for (var i = 0; i < FarseerPhysics.Common.TextureConverter._CLOSEPIXELS_LENGTH; i = (i + 1) | 0) {
                    indexOfPixelToCheck = (((indexOfFirstPixelToCheck + i) | 0)) % FarseerPhysics.Common.TextureConverter._CLOSEPIXELS_LENGTH;

                    x.v = (Bridge.Int.clip32(current.v.X) + FarseerPhysics.Common.TextureConverter.ClosePixels.get([indexOfPixelToCheck, 0])) | 0;
                    y.v = (Bridge.Int.clip32(current.v.Y) + FarseerPhysics.Common.TextureConverter.ClosePixels.get([indexOfPixelToCheck, 1])) | 0;

                    if (x.v >= 0 && x.v < this._width && y.v >= 0 && y.v <= this._height) {
                        if (this.IsSolid$2(x, y)) {
                            next.v = new Microsoft.Xna.Framework.Vector2.$ctor2(x.v, y.v);
                            return true;
                        }
                    }
                }

                next.v = Microsoft.Xna.Framework.Vector2.Zero.$clone();
                return false;
            },
            SearchForOutstandingVertex: function (hullArea, outstanding) {
                var outstandingResult = Microsoft.Xna.Framework.Vector2.Zero.$clone();
                var found = false;

                if (hullArea.Count > 2) {
                    var hullAreaLastPoint = (hullArea.Count - 1) | 0;

                    var tempVector1 = { v : new Microsoft.Xna.Framework.Vector2() };
                    var tempVector2 = { v : hullArea.getItem(0).$clone() };
                    var tempVector3 = { v : hullArea.getItem(hullAreaLastPoint).$clone() };

                    for (var i = 1; i < hullAreaLastPoint; i = (i + 1) | 0) {
                        tempVector1.v = hullArea.getItem(i).$clone();

                        if (FarseerPhysics.Common.LineTools.DistanceBetweenPointAndLineSegment(tempVector1, tempVector2, tempVector3) >= this._hullTolerance) {
                            outstandingResult = hullArea.getItem(i).$clone();
                            found = true;
                            break;
                        }
                    }
                }

                outstanding.v = outstandingResult.$clone();
                return found;
            },
            GetIndexOfFirstPixelToCheck: function (last, current) {


                switch (Bridge.Int.clip32(current.v.X - last.v.X)) {
                    case 1: 
                        switch (Bridge.Int.clip32(current.v.Y - last.v.Y)) {
                            case 1: 
                                return 1;
                            case 0: 
                                return 0;
                            case -1: 
                                return 7;
                        }
                        break;
                    case 0: 
                        switch (Bridge.Int.clip32(current.v.Y - last.v.Y)) {
                            case 1: 
                                return 2;
                            case -1: 
                                return 6;
                        }
                        break;
                    case -1: 
                        switch (Bridge.Int.clip32(current.v.Y - last.v.Y)) {
                            case 1: 
                                return 3;
                            case 0: 
                                return 4;
                            case -1: 
                                return 5;
                        }
                        break;
                }

                return 0;
            }
        }
    });

    /**
     * A transform contains translation and rotation. It is used to represent
     the position and orientation of rigid frames.
     *
     * @public
     * @class FarseerPhysics.Common.Transform
     */
    Bridge.define("FarseerPhysics.Common.Transform", {
        $kind: "struct",
        statics: {
            methods: {
                getDefaultValue: function () { return new FarseerPhysics.Common.Transform(); }
            }
        },
        fields: {
            Position: null,
            R: null
        },
        props: {
            /**
             * Calculate the angle that the rotation matrix represents.
             *
             * @instance
             * @public
             * @readonly
             * @memberof FarseerPhysics.Common.Transform
             * @function Angle
             * @type number
             */
            Angle: {
                get: function () {
                    return Math.atan2(this.R.Col1.Y, this.R.Col1.X);
                }
            }
        },
        ctors: {
            init: function () {
                this.Position = new Microsoft.Xna.Framework.Vector2();
                this.R = new FarseerPhysics.Common.Mat22();
            },
            /**
             * Initialize using a position vector and a rotation matrix.
             *
             * @instance
             * @public
             * @this FarseerPhysics.Common.Transform
             * @memberof FarseerPhysics.Common.Transform
             * @param   {Microsoft.Xna.Framework.Vector2}    position    The position.
             * @param   {FarseerPhysics.Common.Mat22}        r           The r.
             * @return  {void}
             */
            $ctor1: function (position, r) {
                this.$initialize();
                this.Position = position.v.$clone();
                this.R = r.v.$clone();
            },
            ctor: function () {
                this.$initialize();
            }
        },
        methods: {
            /**
             * Set this to the identity transform.
             *
             * @instance
             * @public
             * @this FarseerPhysics.Common.Transform
             * @memberof FarseerPhysics.Common.Transform
             * @return  {void}
             */
            SetIdentity: function () {
                this.Position = Microsoft.Xna.Framework.Vector2.Zero.$clone();
                this.R.SetIdentity();
            },
            /**
             * Set this based on the position and angle.
             *
             * @instance
             * @public
             * @this FarseerPhysics.Common.Transform
             * @memberof FarseerPhysics.Common.Transform
             * @param   {Microsoft.Xna.Framework.Vector2}    position    The position.
             * @param   {number}                             angle       The angle.
             * @return  {void}
             */
            Set: function (position, angle) {
                this.Position = position.$clone();
                this.R.Set$1(angle);
            },
            getHashCode: function () {
                var h = Bridge.addHash([3771783476, this.Position, this.R]);
                return h;
            },
            equals: function (o) {
                if (!Bridge.is(o, FarseerPhysics.Common.Transform)) {
                    return false;
                }
                return Bridge.equals(this.Position, o.Position) && Bridge.equals(this.R, o.R);
            },
            $clone: function (to) {
                var s = to || new FarseerPhysics.Common.Transform();
                s.Position = this.Position.$clone();
                s.R = this.R.$clone();
                return s;
            }
        }
    });

    Bridge.define("FarseerPhysics.Common.Vertices.PolyNode", {
        $kind: "nested class",
        statics: {
            fields: {
                MaxConnected: 0
            },
            ctors: {
                init: function () {
                    this.MaxConnected = 32;
                }
            }
        },
        fields: {
            Connected: null,
            NConnected: 0,
            Position: null
        },
        ctors: {
            init: function () {
                this.Position = new Microsoft.Xna.Framework.Vector2();
                this.Connected = System.Array.init(FarseerPhysics.Common.Vertices.PolyNode.MaxConnected, null, FarseerPhysics.Common.Vertices.PolyNode);
            },
            ctor: function (pos) {
                this.$initialize();
                this.Position = pos.$clone();
                this.NConnected = 0;
            }
        },
        methods: {
            IsRighter: function (sinA, cosA, sinB, cosB) {
                if (sinA < 0) {
                    if (sinB > 0 || cosA <= cosB) {
                        return true;
                    } else {
                        return false;
                    }
                } else {
                    if (sinB < 0 || cosA <= cosB) {
                        return false;
                    } else {
                        return true;
                    }
                }
            },
            AddConnection: function (toMe) {
                System.Diagnostics.Debug.Assert(this.NConnected < FarseerPhysics.Common.Vertices.PolyNode.MaxConnected);

                for (var i = 0; i < this.NConnected; i = (i + 1) | 0) {
                    if (Bridge.referenceEquals(this.Connected[System.Array.index(i, this.Connected)], toMe)) {
                        return;
                    }
                }
                this.Connected[System.Array.index(this.NConnected, this.Connected)] = toMe;
                this.NConnected = (this.NConnected + 1) | 0;
            },
            RemoveConnection: function (fromMe) {
                var isFound = false;
                var foundIndex = -1;
                for (var i = 0; i < this.NConnected; i = (i + 1) | 0) {
                    if (Bridge.referenceEquals(fromMe, this.Connected[System.Array.index(i, this.Connected)])) {
                        isFound = true;
                        foundIndex = i;
                        break;
                    }
                }
                System.Diagnostics.Debug.Assert(isFound);
                this.NConnected = (this.NConnected - 1) | 0;
                for (var i1 = foundIndex; i1 < this.NConnected; i1 = (i1 + 1) | 0) {
                    this.Connected[System.Array.index(i1, this.Connected)] = this.Connected[System.Array.index(((i1 + 1) | 0), this.Connected)];
                }
            },
            GetRightestConnection: function (incoming) {
                if (this.NConnected === 0) {
                    System.Diagnostics.Debug.Assert(false);
                }
                if (this.NConnected === 1) {
                    return incoming;
                }
                var inDir = Microsoft.Xna.Framework.Vector2.op_Subtraction(this.Position.$clone(), incoming.Position.$clone());

                var inLength = inDir.Length();
                inDir.Normalize();

                System.Diagnostics.Debug.Assert(inLength > FarseerPhysics.Settings.Epsilon);

                var result = null;
                for (var i = 0; i < this.NConnected; i = (i + 1) | 0) {
                    if (Bridge.referenceEquals(this.Connected[System.Array.index(i, this.Connected)], incoming)) {
                        continue;
                    }
                    var testDir = Microsoft.Xna.Framework.Vector2.op_Subtraction(this.Connected[System.Array.index(i, this.Connected)].Position.$clone(), this.Position.$clone());
                    var testLengthSqr = testDir.LengthSquared();
                    testDir.Normalize();
                    System.Diagnostics.Debug.Assert(testLengthSqr >= 1.42108547E-14);
                    var myCos = Microsoft.Xna.Framework.Vector2.Dot(inDir.$clone(), testDir.$clone());
                    var mySin = FarseerPhysics.Common.MathUtils.Cross$2(inDir.$clone(), testDir.$clone());
                    if (result != null) {
                        var resultDir = Microsoft.Xna.Framework.Vector2.op_Subtraction(result.Position.$clone(), this.Position.$clone());
                        resultDir.Normalize();
                        var resCos = Microsoft.Xna.Framework.Vector2.Dot(inDir.$clone(), resultDir.$clone());
                        var resSin = FarseerPhysics.Common.MathUtils.Cross$2(inDir.$clone(), resultDir.$clone());
                        if (this.IsRighter(mySin, myCos, resSin, resCos)) {
                            result = this.Connected[System.Array.index(i, this.Connected)];
                        }
                    } else {
                        result = this.Connected[System.Array.index(i, this.Connected)];
                    }
                }

                System.Diagnostics.Debug.Assert(result != null);

                return result;
            },
            GetRightestConnection$1: function (incomingDir) {
                var diff = Microsoft.Xna.Framework.Vector2.op_Subtraction(this.Position.$clone(), incomingDir.$clone());
                var temp = new FarseerPhysics.Common.Vertices.PolyNode(diff.$clone());
                var res = this.GetRightestConnection(temp);
                System.Diagnostics.Debug.Assert(res != null);
                return res;
            }
        }
    });

    /**
     * The detection type affects the resulting polygon data.
     *
     * @public
     * @class FarseerPhysics.Common.VerticesDetectionType
     */
    Bridge.define("FarseerPhysics.Common.VerticesDetectionType", {
        $kind: "enum",
        statics: {
            fields: {
                /**
                 * Holes are integrated into the main polygon.
                 *
                 * @static
                 * @public
                 * @memberof FarseerPhysics.Common.VerticesDetectionType
                 * @constant
                 * @default 0
                 * @type FarseerPhysics.Common.VerticesDetectionType
                 */
                Integrated: 0,
                /**
                 * The data of the main polygon and hole polygons is returned separately.
                 *
                 * @static
                 * @public
                 * @memberof FarseerPhysics.Common.VerticesDetectionType
                 * @constant
                 * @default 1
                 * @type FarseerPhysics.Common.VerticesDetectionType
                 */
                Separated: 1
            }
        }
    });

    /** @namespace FarseerPhysics.Controllers */

    /**
     * Modes for Decay. Actual Decay must be implemented in inheriting 
     classes
     *
     * @public
     * @class number
     */
    Bridge.define("FarseerPhysics.Controllers.AbstractForceController.DecayModes", {
        $kind: "nested enum",
        statics: {
            fields: {
                None: 0,
                Step: 1,
                Linear: 2,
                InverseSquare: 3,
                Curve: 4
            }
        }
    });

    /**
     * Forcetypes are used in the decay math to properly get the distance.
     They are also used to draw a representation in DebugView
     *
     * @public
     * @class number
     */
    Bridge.define("FarseerPhysics.Controllers.AbstractForceController.ForceTypes", {
        $kind: "nested enum",
        statics: {
            fields: {
                Point: 0,
                Line: 1,
                Area: 2
            }
        }
    });

    /**
     * Timing Modes
     Switched: Standard on/off mode using the baseclass enabled property
     Triggered: When the Trigger() method is called the force is active 
     for a specified Impulse Length
     Curve: Still to be defined. The basic idea is having a Trigger 
     combined with a curve for the strength
     *
     * @public
     * @class number
     */
    Bridge.define("FarseerPhysics.Controllers.AbstractForceController.TimingModes", {
        $kind: "nested enum",
        statics: {
            fields: {
                Switched: 0,
                Triggered: 1,
                Curve: 2
            }
        }
    });

    Bridge.define("FarseerPhysics.Controllers.ControllerFilter", {
        $kind: "struct",
        statics: {
            methods: {
                getDefaultValue: function () { return new FarseerPhysics.Controllers.ControllerFilter(); }
            }
        },
        fields: {
            ControllerFlags: 0
        },
        ctors: {
            ctor: function () {
                this.$initialize();
            }
        },
        methods: {
            /**
             * Ignores the controller. The controller has no effect on this body.
             *
             * @instance
             * @public
             * @this FarseerPhysics.Controllers.ControllerFilter
             * @memberof FarseerPhysics.Controllers.ControllerFilter
             * @param   {FarseerPhysics.Controllers.ControllerType}    controller    The controller type.
             * @return  {void}
             */
            IgnoreController: function (controller) {
                this.ControllerFlags |= controller;
            },
            /**
             * Restore the controller. The controller affects this body.
             *
             * @instance
             * @public
             * @this FarseerPhysics.Controllers.ControllerFilter
             * @memberof FarseerPhysics.Controllers.ControllerFilter
             * @param   {FarseerPhysics.Controllers.ControllerType}    controller    The controller type.
             * @return  {void}
             */
            RestoreController: function (controller) {
                this.ControllerFlags &= ~controller;
            },
            /**
             * Determines whether this body ignores the the specified controller.
             *
             * @instance
             * @public
             * @this FarseerPhysics.Controllers.ControllerFilter
             * @memberof FarseerPhysics.Controllers.ControllerFilter
             * @param   {FarseerPhysics.Controllers.ControllerType}    controller    The controller type.
             * @return  {boolean}                                                    <pre><code>true</code></pre> if the body has the specified flag; otherwise, <pre><code>false</code></pre>.
             */
            IsControllerIgnored: function (controller) {
                return (this.ControllerFlags & controller) === controller;
            },
            getHashCode: function () {
                var h = Bridge.addHash([7457916294, this.ControllerFlags]);
                return h;
            },
            equals: function (o) {
                if (!Bridge.is(o, FarseerPhysics.Controllers.ControllerFilter)) {
                    return false;
                }
                return Bridge.equals(this.ControllerFlags, o.ControllerFlags);
            },
            $clone: function (to) {
                var s = to || new FarseerPhysics.Controllers.ControllerFilter();
                s.ControllerFlags = this.ControllerFlags;
                return s;
            }
        }
    });

    Bridge.define("FarseerPhysics.Controllers.ControllerType", {
        $kind: "enum",
        statics: {
            fields: {
                GravityController: 1,
                VelocityLimitController: 2,
                AbstractForceController: 4,
                BuoyancyController: 8
            }
        },
        $flags: true
    });

    Bridge.define("FarseerPhysics.Controllers.GravityType", {
        $kind: "enum",
        statics: {
            fields: {
                Linear: 0,
                DistanceSquared: 1
            }
        }
    });

    /** @namespace FarseerPhysics */

    /**
     * @abstract
     * @public
     * @class FarseerPhysics.DebugView
     */
    Bridge.define("FarseerPhysics.DebugView", {
        fields: {
            World: null,
            /**
             * Gets or sets the debug view flags.
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.DebugView
             * @function Flags
             * @type FarseerPhysics.DebugViewFlags
             */
            Flags: 0
        },
        ctors: {
            ctor: function (world) {
                this.$initialize();
                this.World = world;
            }
        },
        methods: {
            /**
             * Append flags to the current flags.
             *
             * @instance
             * @public
             * @this FarseerPhysics.DebugView
             * @memberof FarseerPhysics.DebugView
             * @param   {FarseerPhysics.DebugViewFlags}    flags    The flags.
             * @return  {void}
             */
            AppendFlags: function (flags) {
                this.Flags |= flags;
            },
            /**
             * Remove flags from the current flags.
             *
             * @instance
             * @public
             * @this FarseerPhysics.DebugView
             * @memberof FarseerPhysics.DebugView
             * @param   {FarseerPhysics.DebugViewFlags}    flags    The flags.
             * @return  {void}
             */
            RemoveFlags: function (flags) {
                this.Flags &= ~flags;
            }
        }
    });

    Bridge.define("FarseerPhysics.DebugViewFlags", {
        $kind: "enum",
        statics: {
            fields: {
                /**
                 * Draw shapes.
                 *
                 * @static
                 * @public
                 * @memberof FarseerPhysics.DebugViewFlags
                 * @constant
                 * @default 1
                 * @type FarseerPhysics.DebugViewFlags
                 */
                Shape: 1,
                /**
                 * Draw joint connections.
                 *
                 * @static
                 * @public
                 * @memberof FarseerPhysics.DebugViewFlags
                 * @constant
                 * @default 2
                 * @type FarseerPhysics.DebugViewFlags
                 */
                Joint: 2,
                /**
                 * Draw axis aligned bounding boxes.
                 *
                 * @static
                 * @public
                 * @memberof FarseerPhysics.DebugViewFlags
                 * @constant
                 * @default 4
                 * @type FarseerPhysics.DebugViewFlags
                 */
                AABB: 4,
                /**
                 * Draw broad-phase pairs.
                 *
                 * @static
                 * @public
                 * @memberof FarseerPhysics.DebugViewFlags
                 * @constant
                 * @default 8
                 * @type FarseerPhysics.DebugViewFlags
                 */
                Pair: 8,
                /**
                 * Draw center of mass frame.
                 *
                 * @static
                 * @public
                 * @memberof FarseerPhysics.DebugViewFlags
                 * @constant
                 * @default 16
                 * @type FarseerPhysics.DebugViewFlags
                 */
                CenterOfMass: 16,
                /**
                 * Draw useful debug data such as timings and number of bodies, joints, contacts and more.
                 *
                 * @static
                 * @public
                 * @memberof FarseerPhysics.DebugViewFlags
                 * @constant
                 * @default 32
                 * @type FarseerPhysics.DebugViewFlags
                 */
                DebugPanel: 32,
                /**
                 * Draw contact points between colliding bodies.
                 *
                 * @static
                 * @public
                 * @memberof FarseerPhysics.DebugViewFlags
                 * @constant
                 * @default 64
                 * @type FarseerPhysics.DebugViewFlags
                 */
                ContactPoints: 64,
                /**
                 * Draw contact normals. Need ContactPoints to be enabled first.
                 *
                 * @static
                 * @public
                 * @memberof FarseerPhysics.DebugViewFlags
                 * @constant
                 * @default 128
                 * @type FarseerPhysics.DebugViewFlags
                 */
                ContactNormals: 128,
                /**
                 * Draws the vertices of polygons.
                 *
                 * @static
                 * @public
                 * @memberof FarseerPhysics.DebugViewFlags
                 * @constant
                 * @default 256
                 * @type FarseerPhysics.DebugViewFlags
                 */
                PolygonPoints: 256,
                /**
                 * Draws the performance graph.
                 *
                 * @static
                 * @public
                 * @memberof FarseerPhysics.DebugViewFlags
                 * @constant
                 * @default 512
                 * @type FarseerPhysics.DebugViewFlags
                 */
                PerformanceGraph: 512,
                /**
                 * Draws controllers.
                 *
                 * @static
                 * @public
                 * @memberof FarseerPhysics.DebugViewFlags
                 * @constant
                 * @default 1024
                 * @type FarseerPhysics.DebugViewFlags
                 */
                Controllers: 1024
            }
        },
        $flags: true
    });

    Bridge.define("FarseerPhysics.Dynamics.Body", {
        inherits: [System.IDisposable],
        statics: {
            fields: {
                _bodyIdCounter: 0
            }
        },
        fields: {
            AngularVelocityInternal: 0,
            BodyId: 0,
            ControllerFilter: null,
            Flags: 0,
            Force: null,
            InvI: 0,
            InvMass: 0,
            LinearVelocityInternal: null,
            PhysicsLogicFilter: null,
            SleepTime: 0,
            Sweep: null,
            Torque: 0,
            World: null,
            Xf: null,
            _angularDamping: 0,
            _bodyType: 0,
            _inertia: 0,
            _linearDamping: 0,
            _mass: 0,
            /**
             * Get or set this body is penetrable
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Dynamics.Body
             * @function Penetrable
             * @type boolean
             */
            Penetrable: false,
            /**
             * Gets all the fixtures attached to this body.
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Dynamics.Body
             * @function FixtureList
             * @type System.Collections.Generic.List$1
             */
            FixtureList: null,
            /**
             * Get the list of all joints attached to this body.
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Dynamics.Body
             * @function JointList
             * @type FarseerPhysics.Dynamics.Joints.JointEdge
             */
            JointList: null,
            /**
             * Get the list of all contacts attached to this body.
             Warning: this list changes during the time step and you may
             miss some collisions if you don't use ContactListener.
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Dynamics.Body
             * @function ContactList
             * @type FarseerPhysics.Dynamics.Contacts.ContactEdge
             */
            ContactList: null,
            /**
             * Set the user data. Use this to store your application specific data.
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Dynamics.Body
             * @function UserData
             * @type System.Object
             */
            UserData: null,
            IsDisposed: false
        },
        props: {
            /**
             * Gets the total number revolutions the body has made.
             *
             * @instance
             * @public
             * @readonly
             * @memberof FarseerPhysics.Dynamics.Body
             * @function Revolutions
             * @type number
             */
            Revolutions: {
                get: function () {
                    return this.Rotation / 3.14159274;
                }
            },
            /**
             * Gets or sets the body type.
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Dynamics.Body
             * @function BodyType
             * @type FarseerPhysics.Dynamics.BodyType
             */
            BodyType: {
                get: function () {
                    return this._bodyType;
                },
                set: function (value) {
                    if (this._bodyType === value) {
                        return;
                    }

                    this._bodyType = value;

                    this.ResetMassData();

                    if (this._bodyType === FarseerPhysics.Dynamics.BodyType.Static) {
                        this.LinearVelocityInternal = Microsoft.Xna.Framework.Vector2.Zero.$clone();
                        this.AngularVelocityInternal = 0.0;
                    }

                    this.Awake = true;

                    this.Force = Microsoft.Xna.Framework.Vector2.Zero.$clone();
                    this.Torque = 0.0;

                    for (var i = 0; i < this.FixtureList.Count; i = (i + 1) | 0) {
                        var f = this.FixtureList.getItem(i);
                        f.Refilter();
                    }
                }
            },
            /**
             * Get or sets the linear velocity of the center of mass.
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Dynamics.Body
             * @function LinearVelocity
             * @type Microsoft.Xna.Framework.Vector2
             */
            LinearVelocity: {
                get: function () {
                    return this.LinearVelocityInternal.$clone();
                },
                set: function (value) {
                    System.Diagnostics.Debug.Assert(!isNaN(value.X) && !isNaN(value.Y));

                    if (this._bodyType === FarseerPhysics.Dynamics.BodyType.Static) {
                        return;
                    }

                    if (Microsoft.Xna.Framework.Vector2.Dot(value.$clone(), value.$clone()) > 0.0) {
                        this.Awake = true;
                    }

                    this.LinearVelocityInternal = value.$clone();
                }
            },
            /**
             * Gets or sets the angular velocity. Radians/second.
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Dynamics.Body
             * @function AngularVelocity
             * @type number
             */
            AngularVelocity: {
                get: function () {
                    return this.AngularVelocityInternal;
                },
                set: function (value) {
                    System.Diagnostics.Debug.Assert(!isNaN(value));

                    if (this._bodyType === FarseerPhysics.Dynamics.BodyType.Static) {
                        return;
                    }

                    if (value * value > 0.0) {
                        this.Awake = true;
                    }

                    this.AngularVelocityInternal = value;
                }
            },
            /**
             * Gets or sets the linear damping.
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Dynamics.Body
             * @function LinearDamping
             * @type number
             */
            LinearDamping: {
                get: function () {
                    return this._linearDamping;
                },
                set: function (value) {
                    System.Diagnostics.Debug.Assert(!isNaN(value));

                    this._linearDamping = value;
                }
            },
            /**
             * Gets or sets the angular damping.
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Dynamics.Body
             * @function AngularDamping
             * @type number
             */
            AngularDamping: {
                get: function () {
                    return this._angularDamping;
                },
                set: function (value) {
                    System.Diagnostics.Debug.Assert(!isNaN(value));

                    this._angularDamping = value;
                }
            },
            /**
             * Gets or sets a value indicating whether this body should be included in the CCD solver.
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Dynamics.Body
             * @function IsBullet
             * @type boolean
             */
            IsBullet: {
                get: function () {
                    return (this.Flags & FarseerPhysics.Dynamics.BodyFlags.Bullet) === FarseerPhysics.Dynamics.BodyFlags.Bullet;
                },
                set: function (value) {
                    if (value) {
                        this.Flags |= FarseerPhysics.Dynamics.BodyFlags.Bullet;
                    } else {
                        this.Flags &= -9;
                    }
                }
            },
            /**
             * You can disable sleeping on this body. If you disable sleeping, the
             body will be woken.
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Dynamics.Body
             * @function SleepingAllowed
             * @type boolean
             */
            SleepingAllowed: {
                get: function () {
                    return (this.Flags & FarseerPhysics.Dynamics.BodyFlags.AutoSleep) === FarseerPhysics.Dynamics.BodyFlags.AutoSleep;
                },
                set: function (value) {
                    if (value) {
                        this.Flags |= FarseerPhysics.Dynamics.BodyFlags.AutoSleep;
                    } else {
                        this.Flags &= -5;
                        this.Awake = true;
                    }
                }
            },
            /**
             * Set the sleep state of the body. A sleeping body has very
             low CPU cost.
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Dynamics.Body
             * @function Awake
             * @type boolean
             */
            Awake: {
                get: function () {
                    return (this.Flags & FarseerPhysics.Dynamics.BodyFlags.Awake) === FarseerPhysics.Dynamics.BodyFlags.Awake;
                },
                set: function (value) {
                    if (value) {
                        if ((this.Flags & FarseerPhysics.Dynamics.BodyFlags.Awake) === 0) {
                            this.Flags |= FarseerPhysics.Dynamics.BodyFlags.Awake;
                            this.SleepTime = 0.0;
                        }
                    } else {
                        this.Flags &= -3;
                        this.SleepTime = 0.0;
                        this.LinearVelocityInternal = Microsoft.Xna.Framework.Vector2.Zero.$clone();
                        this.AngularVelocityInternal = 0.0;
                        this.Force = Microsoft.Xna.Framework.Vector2.Zero.$clone();
                        this.Torque = 0.0;
                    }
                }
            },
            /**
             * Set the active state of the body. An inactive body is not
             simulated and cannot be collided with or woken up.
             If you pass a flag of true, all fixtures will be added to the
             broad-phase.
             If you pass a flag of false, all fixtures will be removed from
             the broad-phase and all contacts will be destroyed.
             Fixtures and joints are otherwise unaffected. You may continue
             to create/destroy fixtures and joints on inactive bodies.
             Fixtures on an inactive body are implicitly inactive and will
             not participate in collisions, ray-casts, or queries.
             Joints connected to an inactive body are implicitly inactive.
             An inactive body is still owned by a b2World object and remains
             in the body list.
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Dynamics.Body
             * @function Enabled
             * @type boolean
             */
            Enabled: {
                get: function () {
                    return (this.Flags & FarseerPhysics.Dynamics.BodyFlags.Enabled) === FarseerPhysics.Dynamics.BodyFlags.Enabled;
                },
                set: function (value) {
                    if (value === this.Enabled) {
                        return;
                    }

                    if (value) {
                        this.Flags |= FarseerPhysics.Dynamics.BodyFlags.Enabled;

                        var broadPhase = this.World.ContactManager.BroadPhase;
                        for (var i = 0; i < this.FixtureList.Count; i = (i + 1) | 0) {
                            this.FixtureList.getItem(i).CreateProxies(broadPhase, Bridge.ref(this, "Xf"));
                        }

                    } else {
                        this.Flags &= -33;

                        var broadPhase1 = this.World.ContactManager.BroadPhase;

                        for (var i1 = 0; i1 < this.FixtureList.Count; i1 = (i1 + 1) | 0) {
                            this.FixtureList.getItem(i1).DestroyProxies(broadPhase1);
                        }

                        var ce = this.ContactList;
                        while (ce != null) {
                            var ce0 = ce;
                            ce = ce.Next;
                            this.World.ContactManager.Destroy(ce0.Contact);
                        }
                        this.ContactList = null;
                    }
                }
            },
            /**
             * Set this body to have fixed rotation. This causes the mass
             to be reset.
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Dynamics.Body
             * @function FixedRotation
             * @type boolean
             */
            FixedRotation: {
                get: function () {
                    return (this.Flags & FarseerPhysics.Dynamics.BodyFlags.FixedRotation) === FarseerPhysics.Dynamics.BodyFlags.FixedRotation;
                },
                set: function (value) {
                    if (value) {
                        this.Flags |= FarseerPhysics.Dynamics.BodyFlags.FixedRotation;
                    } else {
                        this.Flags &= -17;
                    }

                    this.ResetMassData();
                }
            },
            /**
             * Get the world body origin position.
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Dynamics.Body
             * @function Position
             * @type Microsoft.Xna.Framework.Vector2
             * @return  {[type]}        Return the world position of the body's origin.
             */
            Position: {
                get: function () {
                    return this.Xf.Position.$clone();
                },
                set: function (value) {
                    value = {v:value};
                    System.Diagnostics.Debug.Assert(!isNaN(value.v.X) && !isNaN(value.v.Y));

                    this.SetTransform$1(value, this.Rotation);
                }
            },
            /**
             * Get the angle in radians.
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Dynamics.Body
             * @function Rotation
             * @type number
             * @return  {[type]}        Return the current world rotation angle in radians.
             */
            Rotation: {
                get: function () {
                    return this.Sweep.A;
                },
                set: function (value) {
                    System.Diagnostics.Debug.Assert(!isNaN(value));

                    this.SetTransform$1(Bridge.ref(this.Xf, "Position"), value);
                }
            },
            /**
             * Gets or sets a value indicating whether this body is static.
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Dynamics.Body
             * @function IsStatic
             * @type boolean
             */
            IsStatic: {
                get: function () {
                    return this._bodyType === FarseerPhysics.Dynamics.BodyType.Static;
                },
                set: function (value) {
                    if (value) {
                        this.BodyType = FarseerPhysics.Dynamics.BodyType.Static;
                    } else {
                        this.BodyType = FarseerPhysics.Dynamics.BodyType.Dynamic;
                    }
                }
            },
            /**
             * Gets or sets a value indicating whether this body ignores gravity.
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Dynamics.Body
             * @function IgnoreGravity
             * @type boolean
             */
            IgnoreGravity: {
                get: function () {
                    return (this.Flags & FarseerPhysics.Dynamics.BodyFlags.IgnoreGravity) === FarseerPhysics.Dynamics.BodyFlags.IgnoreGravity;
                },
                set: function (value) {
                    if (value) {
                        this.Flags |= FarseerPhysics.Dynamics.BodyFlags.IgnoreGravity;
                    } else {
                        this.Flags &= -65;
                    }
                }
            },
            /**
             * Get the world position of the center of mass.
             *
             * @instance
             * @public
             * @readonly
             * @memberof FarseerPhysics.Dynamics.Body
             * @function WorldCenter
             * @type Microsoft.Xna.Framework.Vector2
             */
            WorldCenter: {
                get: function () {
                    return this.Sweep.C.$clone();
                }
            },
            /**
             * Get the local position of the center of mass.
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Dynamics.Body
             * @function LocalCenter
             * @type Microsoft.Xna.Framework.Vector2
             */
            LocalCenter: {
                get: function () {
                    return this.Sweep.LocalCenter.$clone();
                },
                set: function (value) {
                    var $t;
                    if (this._bodyType !== FarseerPhysics.Dynamics.BodyType.Dynamic) {
                        return;
                    }

                    var oldCenter = this.Sweep.C.$clone();
                    this.Sweep.LocalCenter = value.$clone();
                    this.Sweep.C0 = ($t = FarseerPhysics.Common.MathUtils.Multiply$3(Bridge.ref(this, "Xf"), Bridge.ref(this.Sweep, "LocalCenter")), this.Sweep.C = $t.$clone(), $t);

                    var a = Microsoft.Xna.Framework.Vector2.op_Subtraction(this.Sweep.C.$clone(), oldCenter.$clone());
                    this.LinearVelocityInternal = Microsoft.Xna.Framework.Vector2.op_Addition(this.LinearVelocityInternal.$clone(), new Microsoft.Xna.Framework.Vector2.$ctor2(-this.AngularVelocityInternal * a.Y, this.AngularVelocityInternal * a.X));
                }
            },
            /**
             * Gets or sets the mass. Usually in kilograms (kg).
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Dynamics.Body
             * @function Mass
             * @type number
             */
            Mass: {
                get: function () {
                    return this._mass;
                },
                set: function (value) {
                    System.Diagnostics.Debug.Assert(!isNaN(value));

                    if (this._bodyType !== FarseerPhysics.Dynamics.BodyType.Dynamic) {
                        return;
                    }

                    this._mass = value;

                    if (this._mass <= 0.0) {
                        this._mass = 1.0;
                    }

                    this.InvMass = 1.0 / this._mass;
                }
            },
            /**
             * Get or set the rotational inertia of the body about the local origin. usually in kg-m^2.
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Dynamics.Body
             * @function Inertia
             * @type number
             */
            Inertia: {
                get: function () {
                    return this._inertia + this.Mass * Microsoft.Xna.Framework.Vector2.Dot(this.Sweep.LocalCenter.$clone(), this.Sweep.LocalCenter.$clone());
                },
                set: function (value) {
                    System.Diagnostics.Debug.Assert(!isNaN(value));

                    if (this._bodyType !== FarseerPhysics.Dynamics.BodyType.Dynamic) {
                        return;
                    }

                    if (value > 0.0 && (this.Flags & FarseerPhysics.Dynamics.BodyFlags.FixedRotation) === 0) {
                        this._inertia = value - this.Mass * Microsoft.Xna.Framework.Vector2.Dot(this.LocalCenter.$clone(), this.LocalCenter.$clone());
                        System.Diagnostics.Debug.Assert(this._inertia > 0.0);
                        this.InvI = 1.0 / this._inertia;
                    }
                }
            },
            Restitution: {
                get: function () {
                    var res = 0;

                    for (var i = 0; i < this.FixtureList.Count; i = (i + 1) | 0) {
                        var f = this.FixtureList.getItem(i);
                        res += f.Restitution;
                    }

                    return res / this.FixtureList.Count;
                },
                set: function (value) {
                    for (var i = 0; i < this.FixtureList.Count; i = (i + 1) | 0) {
                        var f = this.FixtureList.getItem(i);
                        f.Restitution = value;
                    }
                }
            },
            Friction: {
                get: function () {
                    var res = 0;

                    for (var i = 0; i < this.FixtureList.Count; i = (i + 1) | 0) {
                        var f = this.FixtureList.getItem(i);
                        res += f.Friction;
                    }

                    return res / this.FixtureList.Count;
                },
                set: function (value) {
                    for (var i = 0; i < this.FixtureList.Count; i = (i + 1) | 0) {
                        var f = this.FixtureList.getItem(i);
                        f.Friction = value;
                    }
                }
            },
            CollisionCategories: {
                set: function (value) {
                    for (var i = 0; i < this.FixtureList.Count; i = (i + 1) | 0) {
                        var f = this.FixtureList.getItem(i);
                        f.CollisionCategories = value;
                    }
                }
            },
            CollidesWith: {
                set: function (value) {
                    for (var i = 0; i < this.FixtureList.Count; i = (i + 1) | 0) {
                        var f = this.FixtureList.getItem(i);
                        f.CollidesWith = value;
                    }
                }
            },
            CollisionGroup: {
                set: function (value) {
                    for (var i = 0; i < this.FixtureList.Count; i = (i + 1) | 0) {
                        var f = this.FixtureList.getItem(i);
                        f.CollisionGroup = value;
                    }
                }
            },
            IsSensor: {
                set: function (value) {
                    for (var i = 0; i < this.FixtureList.Count; i = (i + 1) | 0) {
                        var f = this.FixtureList.getItem(i);
                        f.IsSensor = value;
                    }
                }
            },
            IgnoreCCD: {
                get: function () {
                    return (this.Flags & FarseerPhysics.Dynamics.BodyFlags.IgnoreCCD) === FarseerPhysics.Dynamics.BodyFlags.IgnoreCCD;
                },
                set: function (value) {
                    if (value) {
                        this.Flags |= FarseerPhysics.Dynamics.BodyFlags.IgnoreCCD;
                    } else {
                        this.Flags &= -129;
                    }
                }
            }
        },
        alias: ["Dispose", "System$IDisposable$Dispose"],
        ctors: {
            init: function () {
                this.ControllerFilter = new FarseerPhysics.Controllers.ControllerFilter();
                this.Force = new Microsoft.Xna.Framework.Vector2();
                this.LinearVelocityInternal = new Microsoft.Xna.Framework.Vector2();
                this.PhysicsLogicFilter = new FarseerPhysics.Common.PhysicsLogic.PhysicsLogicFilter();
                this.Sweep = new FarseerPhysics.Common.Sweep();
                this.Xf = new FarseerPhysics.Common.Transform();
            },
            ctor: function () {
                this.$initialize();
                this.FixtureList = new (System.Collections.Generic.List$1(FarseerPhysics.Dynamics.Fixture)).$ctor2(32);
            },
            $ctor1: function (world) {
                FarseerPhysics.Dynamics.Body.$ctor2.call(this, world, null);
            },
            $ctor2: function (world, userData) {
                var $t;
                this.$initialize();
                this.FixtureList = new (System.Collections.Generic.List$1(FarseerPhysics.Dynamics.Fixture)).$ctor2(32);
                this.BodyId = Bridge.identity(FarseerPhysics.Dynamics.Body._bodyIdCounter, ($t = (FarseerPhysics.Dynamics.Body._bodyIdCounter + 1) | 0, FarseerPhysics.Dynamics.Body._bodyIdCounter = $t, $t));

                this.World = world;
                this.UserData = userData;

                this.FixedRotation = false;
                this.IsBullet = false;
                this.SleepingAllowed = true;
                this.Awake = true;
                this.BodyType = FarseerPhysics.Dynamics.BodyType.Static;
                this.Enabled = true;

                this.Xf.R.Set$1(0);

                world.AddBody(this);
            }
        },
        methods: {
            addOnCollision: function (value) {
                for (var i = 0; i < this.FixtureList.Count; i = (i + 1) | 0) {
                    this.FixtureList.getItem(i).OnCollision = Bridge.fn.combine(this.FixtureList.getItem(i).OnCollision, value);
                }
            },
            removeOnCollision: function (value) {
                for (var i = 0; i < this.FixtureList.Count; i = (i + 1) | 0) {
                    this.FixtureList.getItem(i).OnCollision = Bridge.fn.remove(this.FixtureList.getItem(i).OnCollision, value);
                }
            },
            addOnSeparation: function (value) {
                for (var i = 0; i < this.FixtureList.Count; i = (i + 1) | 0) {
                    this.FixtureList.getItem(i).OnSeparation = Bridge.fn.combine(this.FixtureList.getItem(i).OnSeparation, value);
                }
            },
            removeOnSeparation: function (value) {
                for (var i = 0; i < this.FixtureList.Count; i = (i + 1) | 0) {
                    this.FixtureList.getItem(i).OnSeparation = Bridge.fn.remove(this.FixtureList.getItem(i).OnSeparation, value);
                }
            },
            Dispose: function () {
                if (!this.IsDisposed) {

                    this.World.RemoveBody(this);
                    this.IsDisposed = true;
                }
            },
            /**
             * Resets the dynamics of this body.
             Sets torque, force and linear/angular velocity to 0
             *
             * @instance
             * @public
             * @this FarseerPhysics.Dynamics.Body
             * @memberof FarseerPhysics.Dynamics.Body
             * @return  {void}
             */
            ResetDynamics: function () {
                this.Torque = 0;
                this.AngularVelocityInternal = 0;
                this.Force = Microsoft.Xna.Framework.Vector2.Zero.$clone();
                this.LinearVelocityInternal = Microsoft.Xna.Framework.Vector2.Zero.$clone();
            },
            /**
             * Creates a fixture and attach it to this body.
             If the density is non-zero, this function automatically updates the mass of the body.
             Contacts are not created until the next time step.
             Warning: This function is locked during callbacks.
             *
             * @instance
             * @public
             * @this FarseerPhysics.Dynamics.Body
             * @memberof FarseerPhysics.Dynamics.Body
             * @param   {FarseerPhysics.Collision.Shapes.Shape}    shape    The shape.
             * @return  {FarseerPhysics.Dynamics.Fixture}
             */
            CreateFixture: function (shape) {
                return new FarseerPhysics.Dynamics.Fixture.$ctor1(this, shape);
            },
            /**
             * Creates a fixture and attach it to this body.
             If the density is non-zero, this function automatically updates the mass of the body.
             Contacts are not created until the next time step.
             Warning: This function is locked during callbacks.
             *
             * @instance
             * @public
             * @this FarseerPhysics.Dynamics.Body
             * @memberof FarseerPhysics.Dynamics.Body
             * @param   {FarseerPhysics.Collision.Shapes.Shape}    shape       The shape.
             * @param   {System.Object}                            userData    Application specific data
             * @return  {FarseerPhysics.Dynamics.Fixture}
             */
            CreateFixture$1: function (shape, userData) {
                return new FarseerPhysics.Dynamics.Fixture.$ctor2(this, shape, userData);
            },
            /**
             * Destroy a fixture. This removes the fixture from the broad-phase and
             destroys all contacts associated with this fixture. This will
             automatically adjust the mass of the body if the body is dynamic and the
             fixture has positive density.
             All fixtures attached to a body are implicitly destroyed when the body is destroyed.
             Warning: This function is locked during callbacks.
             *
             * @instance
             * @public
             * @this FarseerPhysics.Dynamics.Body
             * @memberof FarseerPhysics.Dynamics.Body
             * @param   {FarseerPhysics.Dynamics.Fixture}    fixture    The fixture to be removed.
             * @return  {void}
             */
            DestroyFixture: function (fixture) {
                System.Diagnostics.Debug.Assert(Bridge.referenceEquals(fixture.Body, this));

                System.Diagnostics.Debug.Assert(this.FixtureList.Count > 0);

                System.Diagnostics.Debug.Assert(this.FixtureList.contains(fixture));

                var edge = this.ContactList;
                while (edge != null) {
                    var c = edge.Contact;
                    edge = edge.Next;

                    var fixtureA = c.FixtureA;
                    var fixtureB = c.FixtureB;

                    if (Bridge.referenceEquals(fixture, fixtureA) || Bridge.referenceEquals(fixture, fixtureB)) {
                        this.World.ContactManager.Destroy(c);
                    }
                }

                if ((this.Flags & FarseerPhysics.Dynamics.BodyFlags.Enabled) === FarseerPhysics.Dynamics.BodyFlags.Enabled) {
                    var broadPhase = this.World.ContactManager.BroadPhase;
                    fixture.DestroyProxies(broadPhase);
                }

                this.FixtureList.remove(fixture);
                fixture.Destroy();
                fixture.Body = null;

                this.ResetMassData();
            },
            /**
             * Set the position of the body's origin and rotation.
             This breaks any contacts and wakes the other bodies.
             Manipulating a body's transform may cause non-physical behavior.
             *
             * @instance
             * @public
             * @this FarseerPhysics.Dynamics.Body
             * @memberof FarseerPhysics.Dynamics.Body
             * @param   {Microsoft.Xna.Framework.Vector2}    position    The world position of the body's local origin.
             * @param   {number}                             rotation    The world rotation in radians.
             * @return  {void}
             */
            SetTransform$1: function (position, rotation) {
                this.SetTransformIgnoreContacts(position, rotation);

                this.World.ContactManager.FindNewContacts();
            },
            /**
             * Set the position of the body's origin and rotation.
             This breaks any contacts and wakes the other bodies.
             Manipulating a body's transform may cause non-physical behavior.
             *
             * @instance
             * @public
             * @this FarseerPhysics.Dynamics.Body
             * @memberof FarseerPhysics.Dynamics.Body
             * @param   {Microsoft.Xna.Framework.Vector2}    position    The world position of the body's local origin.
             * @param   {number}                             rotation    The world rotation in radians.
             * @return  {void}
             */
            SetTransform: function (position, rotation) {
                position = {v:position};
                this.SetTransform$1(position, rotation);
            },
            /**
             * For teleporting a body without considering new contacts immediately.
             *
             * @instance
             * @public
             * @this FarseerPhysics.Dynamics.Body
             * @memberof FarseerPhysics.Dynamics.Body
             * @param   {Microsoft.Xna.Framework.Vector2}    position    The position.
             * @param   {number}                             angle       The angle.
             * @return  {void}
             */
            SetTransformIgnoreContacts: function (position, angle) {
                var $t;
                this.Xf.R.Set$1(angle);
                this.Xf.Position = position.v.$clone();

                this.Sweep.C0 = ($t = new Microsoft.Xna.Framework.Vector2.$ctor2(this.Xf.Position.X + this.Xf.R.Col1.X * this.Sweep.LocalCenter.X + this.Xf.R.Col2.X * this.Sweep.LocalCenter.Y, this.Xf.Position.Y + this.Xf.R.Col1.Y * this.Sweep.LocalCenter.X + this.Xf.R.Col2.Y * this.Sweep.LocalCenter.Y), this.Sweep.C = $t.$clone(), $t);
                this.Sweep.A0 = (this.Sweep.A = angle, angle);

                var broadPhase = this.World.ContactManager.BroadPhase;
                for (var i = 0; i < this.FixtureList.Count; i = (i + 1) | 0) {
                    this.FixtureList.getItem(i).Synchronize(broadPhase, Bridge.ref(this, "Xf"), Bridge.ref(this, "Xf"));
                }
            },
            /**
             * Get the body transform for the body's origin.
             *
             * @instance
             * @public
             * @this FarseerPhysics.Dynamics.Body
             * @memberof FarseerPhysics.Dynamics.Body
             * @param   {FarseerPhysics.Common.Transform}    transform    The transform of the body's origin.
             * @return  {void}
             */
            GetTransform: function (transform) {
                transform.v = this.Xf.$clone();
            },
            /**
             * Apply a force at a world point. If the force is not
             applied at the center of mass, it will generate a torque and
             affect the angular velocity. This wakes up the body.
             *
             * @instance
             * @public
             * @this FarseerPhysics.Dynamics.Body
             * @memberof FarseerPhysics.Dynamics.Body
             * @param   {Microsoft.Xna.Framework.Vector2}    force    The world force vector, usually in Newtons (N).
             * @param   {Microsoft.Xna.Framework.Vector2}    point    The world position of the point of application.
             * @return  {void}
             */
            ApplyForce$1: function (force, point) {
                force = {v:force};
                point = {v:point};
                this.ApplyForce$3(force, point);
            },
            /**
             * Applies a force at the center of mass.
             *
             * @instance
             * @public
             * @this FarseerPhysics.Dynamics.Body
             * @memberof FarseerPhysics.Dynamics.Body
             * @param   {Microsoft.Xna.Framework.Vector2}    force    The force.
             * @return  {void}
             */
            ApplyForce$2: function (force) {
                this.ApplyForce$3(force, Bridge.ref(this.Xf, "Position"));
            },
            /**
             * Applies a force at the center of mass.
             *
             * @instance
             * @public
             * @this FarseerPhysics.Dynamics.Body
             * @memberof FarseerPhysics.Dynamics.Body
             * @param   {Microsoft.Xna.Framework.Vector2}    force    The force.
             * @return  {void}
             */
            ApplyForce: function (force) {
                force = {v:force};
                this.ApplyForce$3(force, Bridge.ref(this.Xf, "Position"));
            },
            /**
             * Apply a force at a world point. If the force is not
             applied at the center of mass, it will generate a torque and
             affect the angular velocity. This wakes up the body.
             *
             * @instance
             * @public
             * @this FarseerPhysics.Dynamics.Body
             * @memberof FarseerPhysics.Dynamics.Body
             * @param   {Microsoft.Xna.Framework.Vector2}    force    The world force vector, usually in Newtons (N).
             * @param   {Microsoft.Xna.Framework.Vector2}    point    The world position of the point of application.
             * @return  {void}
             */
            ApplyForce$3: function (force, point) {
                System.Diagnostics.Debug.Assert(!isNaN(force.v.X));
                System.Diagnostics.Debug.Assert(!isNaN(force.v.Y));
                System.Diagnostics.Debug.Assert(!isNaN(point.v.X));
                System.Diagnostics.Debug.Assert(!isNaN(point.v.Y));

                if (this._bodyType === FarseerPhysics.Dynamics.BodyType.Dynamic) {
                    if (this.Awake === false) {
                        this.Awake = true;
                    }

                    this.Force = Microsoft.Xna.Framework.Vector2.op_Addition(this.Force.$clone(), force.v.$clone());
                    this.Torque += (point.v.X - this.Sweep.C.X) * force.v.Y - (point.v.Y - this.Sweep.C.Y) * force.v.X;
                }
            },
            /**
             * Apply a torque. This affects the angular velocity
             without affecting the linear velocity of the center of mass.
             This wakes up the body.
             *
             * @instance
             * @public
             * @this FarseerPhysics.Dynamics.Body
             * @memberof FarseerPhysics.Dynamics.Body
             * @param   {number}    torque    The torque about the z-axis (out of the screen), usually in N-m.
             * @return  {void}
             */
            ApplyTorque: function (torque) {
                System.Diagnostics.Debug.Assert(!isNaN(torque));

                if (this._bodyType === FarseerPhysics.Dynamics.BodyType.Dynamic) {
                    if (this.Awake === false) {
                        this.Awake = true;
                    }

                    this.Torque += torque;
                }
            },
            /**
             * Apply an impulse at a point. This immediately modifies the velocity.
             This wakes up the body.
             *
             * @instance
             * @public
             * @this FarseerPhysics.Dynamics.Body
             * @memberof FarseerPhysics.Dynamics.Body
             * @param   {Microsoft.Xna.Framework.Vector2}    impulse    The world impulse vector, usually in N-seconds or kg-m/s.
             * @return  {void}
             */
            ApplyLinearImpulse: function (impulse) {
                impulse = {v:impulse};
                this.ApplyLinearImpulse$2(impulse);
            },
            /**
             * Apply an impulse at a point. This immediately modifies the velocity.
             It also modifies the angular velocity if the point of application
             is not at the center of mass.
             This wakes up the body.
             *
             * @instance
             * @public
             * @this FarseerPhysics.Dynamics.Body
             * @memberof FarseerPhysics.Dynamics.Body
             * @param   {Microsoft.Xna.Framework.Vector2}    impulse    The world impulse vector, usually in N-seconds or kg-m/s.
             * @param   {Microsoft.Xna.Framework.Vector2}    point      The world position of the point of application.
             * @return  {void}
             */
            ApplyLinearImpulse$1: function (impulse, point) {
                impulse = {v:impulse};
                point = {v:point};
                this.ApplyLinearImpulse$3(impulse, point);
            },
            /**
             * Apply an impulse at a point. This immediately modifies the velocity.
             This wakes up the body.
             *
             * @instance
             * @public
             * @this FarseerPhysics.Dynamics.Body
             * @memberof FarseerPhysics.Dynamics.Body
             * @param   {Microsoft.Xna.Framework.Vector2}    impulse    The world impulse vector, usually in N-seconds or kg-m/s.
             * @return  {void}
             */
            ApplyLinearImpulse$2: function (impulse) {
                if (this._bodyType !== FarseerPhysics.Dynamics.BodyType.Dynamic) {
                    return;
                }
                if (this.Awake === false) {
                    this.Awake = true;
                }
                this.LinearVelocityInternal = Microsoft.Xna.Framework.Vector2.op_Addition(this.LinearVelocityInternal.$clone(), Microsoft.Xna.Framework.Vector2.op_Multiply$2(this.InvMass, impulse.v.$clone()));
            },
            /**
             * Apply an impulse at a point. This immediately modifies the velocity.
             It also modifies the angular velocity if the point of application
             is not at the center of mass.
             This wakes up the body.
             *
             * @instance
             * @public
             * @this FarseerPhysics.Dynamics.Body
             * @memberof FarseerPhysics.Dynamics.Body
             * @param   {Microsoft.Xna.Framework.Vector2}    impulse    The world impulse vector, usually in N-seconds or kg-m/s.
             * @param   {Microsoft.Xna.Framework.Vector2}    point      The world position of the point of application.
             * @return  {void}
             */
            ApplyLinearImpulse$3: function (impulse, point) {
                if (this._bodyType !== FarseerPhysics.Dynamics.BodyType.Dynamic) {
                    return;
                }

                if (this.Awake === false) {
                    this.Awake = true;
                }

                this.LinearVelocityInternal = Microsoft.Xna.Framework.Vector2.op_Addition(this.LinearVelocityInternal.$clone(), Microsoft.Xna.Framework.Vector2.op_Multiply$2(this.InvMass, impulse.v.$clone()));
                this.AngularVelocityInternal += this.InvI * ((point.v.X - this.Sweep.C.X) * impulse.v.Y - (point.v.Y - this.Sweep.C.Y) * impulse.v.X);
            },
            /**
             * Apply an angular impulse.
             *
             * @instance
             * @public
             * @this FarseerPhysics.Dynamics.Body
             * @memberof FarseerPhysics.Dynamics.Body
             * @param   {number}    impulse    The angular impulse in units of kg*m*m/s.
             * @return  {void}
             */
            ApplyAngularImpulse: function (impulse) {
                if (this._bodyType !== FarseerPhysics.Dynamics.BodyType.Dynamic) {
                    return;
                }

                if (this.Awake === false) {
                    this.Awake = true;
                }

                this.AngularVelocityInternal += this.InvI * impulse;
            },
            /**
             * This resets the mass properties to the sum of the mass properties of the fixtures.
             This normally does not need to be called unless you called SetMassData to override
             the mass and you later want to reset the mass.
             *
             * @instance
             * @public
             * @this FarseerPhysics.Dynamics.Body
             * @memberof FarseerPhysics.Dynamics.Body
             * @return  {void}
             */
            ResetMassData: function () {
                var $t, $t1, $t2, $t3;
                this._mass = 0.0;
                this.InvMass = 0.0;
                this._inertia = 0.0;
                this.InvI = 0.0;
                this.Sweep.LocalCenter = Microsoft.Xna.Framework.Vector2.Zero.$clone();

                if (this.BodyType === FarseerPhysics.Dynamics.BodyType.Kinematic) {
                    this.Sweep.C0 = ($t = this.Xf.Position.$clone(), this.Sweep.C = $t.$clone(), $t);
                    return;
                }

                System.Diagnostics.Debug.Assert(this.BodyType === FarseerPhysics.Dynamics.BodyType.Dynamic || this.BodyType === FarseerPhysics.Dynamics.BodyType.Static);

                var center = Microsoft.Xna.Framework.Vector2.Zero.$clone();
                $t1 = Bridge.getEnumerator(this.FixtureList);
                try {
                    while ($t1.moveNext()) {
                        var f = $t1.Current;
                        if (f.Shape._density === 0) {
                            continue;
                        }

                        var massData = f.Shape.MassData.$clone();
                        this._mass += massData.Mass;
                        center = Microsoft.Xna.Framework.Vector2.op_Addition(center.$clone(), Microsoft.Xna.Framework.Vector2.op_Multiply$2(massData.Mass, massData.Centroid.$clone()));
                        this._inertia += massData.Inertia;
                    }
                } finally {
                    if (Bridge.is($t1, System.IDisposable)) {
                        $t1.System$IDisposable$Dispose();
                    }
                }
                if (this.BodyType === FarseerPhysics.Dynamics.BodyType.Static) {
                    this.Sweep.C0 = ($t2 = this.Xf.Position.$clone(), this.Sweep.C = $t2.$clone(), $t2);
                    return;
                }

                if (this._mass > 0.0) {
                    this.InvMass = 1.0 / this._mass;
                    center = Microsoft.Xna.Framework.Vector2.op_Multiply$1(center.$clone(), this.InvMass);
                } else {
                    this._mass = 1.0;
                    this.InvMass = 1.0;
                }

                if (this._inertia > 0.0 && (this.Flags & FarseerPhysics.Dynamics.BodyFlags.FixedRotation) === 0) {
                    this._inertia -= this._mass * Microsoft.Xna.Framework.Vector2.Dot(center.$clone(), center.$clone());

                    System.Diagnostics.Debug.Assert(this._inertia > 0.0);
                    this.InvI = 1.0 / this._inertia;
                } else {
                    this._inertia = 0.0;
                    this.InvI = 0.0;
                }

                var oldCenter = this.Sweep.C.$clone();
                this.Sweep.LocalCenter = center.$clone();
                this.Sweep.C0 = ($t3 = FarseerPhysics.Common.MathUtils.Multiply$3(Bridge.ref(this, "Xf"), Bridge.ref(this.Sweep, "LocalCenter")), this.Sweep.C = $t3.$clone(), $t3);

                var a = Microsoft.Xna.Framework.Vector2.op_Subtraction(this.Sweep.C.$clone(), oldCenter.$clone());
                this.LinearVelocityInternal = Microsoft.Xna.Framework.Vector2.op_Addition(this.LinearVelocityInternal.$clone(), new Microsoft.Xna.Framework.Vector2.$ctor2(-this.AngularVelocityInternal * a.Y, this.AngularVelocityInternal * a.X));
            },
            /**
             * Get the world coordinates of a point given the local coordinates.
             *
             * @instance
             * @public
             * @this FarseerPhysics.Dynamics.Body
             * @memberof FarseerPhysics.Dynamics.Body
             * @param   {Microsoft.Xna.Framework.Vector2}    localPoint    A point on the body measured relative the the body's origin.
             * @return  {Microsoft.Xna.Framework.Vector2}                  The same point expressed in world coordinates.
             */
            GetWorldPoint$1: function (localPoint) {
                return new Microsoft.Xna.Framework.Vector2.$ctor2(this.Xf.Position.X + this.Xf.R.Col1.X * localPoint.v.X + this.Xf.R.Col2.X * localPoint.v.Y, this.Xf.Position.Y + this.Xf.R.Col1.Y * localPoint.v.X + this.Xf.R.Col2.Y * localPoint.v.Y);
            },
            /**
             * Get the world coordinates of a point given the local coordinates.
             *
             * @instance
             * @public
             * @this FarseerPhysics.Dynamics.Body
             * @memberof FarseerPhysics.Dynamics.Body
             * @param   {Microsoft.Xna.Framework.Vector2}    localPoint    A point on the body measured relative the the body's origin.
             * @return  {Microsoft.Xna.Framework.Vector2}                  The same point expressed in world coordinates.
             */
            GetWorldPoint: function (localPoint) {
                localPoint = {v:localPoint};
                return this.GetWorldPoint$1(localPoint);
            },
            /**
             * Get the world coordinates of a vector given the local coordinates.
             Note that the vector only takes the rotation into account, not the position.
             *
             * @instance
             * @public
             * @this FarseerPhysics.Dynamics.Body
             * @memberof FarseerPhysics.Dynamics.Body
             * @param   {Microsoft.Xna.Framework.Vector2}    localVector    A vector fixed in the body.
             * @return  {Microsoft.Xna.Framework.Vector2}                   The same vector expressed in world coordinates.
             */
            GetWorldVector$1: function (localVector) {
                return new Microsoft.Xna.Framework.Vector2.$ctor2(this.Xf.R.Col1.X * localVector.v.X + this.Xf.R.Col2.X * localVector.v.Y, this.Xf.R.Col1.Y * localVector.v.X + this.Xf.R.Col2.Y * localVector.v.Y);
            },
            /**
             * Get the world coordinates of a vector given the local coordinates.
             *
             * @instance
             * @public
             * @this FarseerPhysics.Dynamics.Body
             * @memberof FarseerPhysics.Dynamics.Body
             * @param   {Microsoft.Xna.Framework.Vector2}    localVector    A vector fixed in the body.
             * @return  {Microsoft.Xna.Framework.Vector2}                   The same vector expressed in world coordinates.
             */
            GetWorldVector: function (localVector) {
                localVector = {v:localVector};
                return this.GetWorldVector$1(localVector);
            },
            /**
             * Gets a local point relative to the body's origin given a world point.
             Note that the vector only takes the rotation into account, not the position.
             *
             * @instance
             * @public
             * @this FarseerPhysics.Dynamics.Body
             * @memberof FarseerPhysics.Dynamics.Body
             * @param   {Microsoft.Xna.Framework.Vector2}    worldPoint    A point in world coordinates.
             * @return  {Microsoft.Xna.Framework.Vector2}                  The corresponding local point relative to the body's origin.
             */
            GetLocalPoint$1: function (worldPoint) {
                return new Microsoft.Xna.Framework.Vector2.$ctor2((worldPoint.v.X - this.Xf.Position.X) * this.Xf.R.Col1.X + (worldPoint.v.Y - this.Xf.Position.Y) * this.Xf.R.Col1.Y, (worldPoint.v.X - this.Xf.Position.X) * this.Xf.R.Col2.X + (worldPoint.v.Y - this.Xf.Position.Y) * this.Xf.R.Col2.Y);
            },
            /**
             * Gets a local point relative to the body's origin given a world point.
             *
             * @instance
             * @public
             * @this FarseerPhysics.Dynamics.Body
             * @memberof FarseerPhysics.Dynamics.Body
             * @param   {Microsoft.Xna.Framework.Vector2}    worldPoint    A point in world coordinates.
             * @return  {Microsoft.Xna.Framework.Vector2}                  The corresponding local point relative to the body's origin.
             */
            GetLocalPoint: function (worldPoint) {
                worldPoint = {v:worldPoint};
                return this.GetLocalPoint$1(worldPoint);
            },
            /**
             * Gets a local vector given a world vector.
             Note that the vector only takes the rotation into account, not the position.
             *
             * @instance
             * @public
             * @this FarseerPhysics.Dynamics.Body
             * @memberof FarseerPhysics.Dynamics.Body
             * @param   {Microsoft.Xna.Framework.Vector2}    worldVector    A vector in world coordinates.
             * @return  {Microsoft.Xna.Framework.Vector2}                   The corresponding local vector.
             */
            GetLocalVector$1: function (worldVector) {
                return new Microsoft.Xna.Framework.Vector2.$ctor2(worldVector.v.X * this.Xf.R.Col1.X + worldVector.v.Y * this.Xf.R.Col1.Y, worldVector.v.X * this.Xf.R.Col2.X + worldVector.v.Y * this.Xf.R.Col2.Y);
            },
            /**
             * Gets a local vector given a world vector.
             Note that the vector only takes the rotation into account, not the position.
             *
             * @instance
             * @public
             * @this FarseerPhysics.Dynamics.Body
             * @memberof FarseerPhysics.Dynamics.Body
             * @param   {Microsoft.Xna.Framework.Vector2}    worldVector    A vector in world coordinates.
             * @return  {Microsoft.Xna.Framework.Vector2}                   The corresponding local vector.
             */
            GetLocalVector: function (worldVector) {
                worldVector = {v:worldVector};
                return this.GetLocalVector$1(worldVector);
            },
            /**
             * Get the world linear velocity of a world point attached to this body.
             *
             * @instance
             * @public
             * @this FarseerPhysics.Dynamics.Body
             * @memberof FarseerPhysics.Dynamics.Body
             * @param   {Microsoft.Xna.Framework.Vector2}    worldPoint    A point in world coordinates.
             * @return  {Microsoft.Xna.Framework.Vector2}                  The world velocity of a point.
             */
            GetLinearVelocityFromWorldPoint: function (worldPoint) {
                worldPoint = {v:worldPoint};
                return this.GetLinearVelocityFromWorldPoint$1(worldPoint);
            },
            /**
             * Get the world linear velocity of a world point attached to this body.
             *
             * @instance
             * @public
             * @this FarseerPhysics.Dynamics.Body
             * @memberof FarseerPhysics.Dynamics.Body
             * @param   {Microsoft.Xna.Framework.Vector2}    worldPoint    A point in world coordinates.
             * @return  {Microsoft.Xna.Framework.Vector2}                  The world velocity of a point.
             */
            GetLinearVelocityFromWorldPoint$1: function (worldPoint) {
                return Microsoft.Xna.Framework.Vector2.op_Addition(this.LinearVelocityInternal.$clone(), new Microsoft.Xna.Framework.Vector2.$ctor2(-this.AngularVelocityInternal * (worldPoint.v.Y - this.Sweep.C.Y), this.AngularVelocityInternal * (worldPoint.v.X - this.Sweep.C.X)));
            },
            /**
             * Get the world velocity of a local point.
             *
             * @instance
             * @public
             * @this FarseerPhysics.Dynamics.Body
             * @memberof FarseerPhysics.Dynamics.Body
             * @param   {Microsoft.Xna.Framework.Vector2}    localPoint    A point in local coordinates.
             * @return  {Microsoft.Xna.Framework.Vector2}                  The world velocity of a point.
             */
            GetLinearVelocityFromLocalPoint: function (localPoint) {
                localPoint = {v:localPoint};
                return this.GetLinearVelocityFromLocalPoint$1(localPoint);
            },
            /**
             * Get the world velocity of a local point.
             *
             * @instance
             * @public
             * @this FarseerPhysics.Dynamics.Body
             * @memberof FarseerPhysics.Dynamics.Body
             * @param   {Microsoft.Xna.Framework.Vector2}    localPoint    A point in local coordinates.
             * @return  {Microsoft.Xna.Framework.Vector2}                  The world velocity of a point.
             */
            GetLinearVelocityFromLocalPoint$1: function (localPoint) {
                return this.GetLinearVelocityFromWorldPoint(this.GetWorldPoint$1(localPoint));
            },
            DeepClone: function () {
                var body = this.Clone();

                for (var i = 0; i < this.FixtureList.Count; i = (i + 1) | 0) {
                    this.FixtureList.getItem(i).Clone(body);
                }

                return body;
            },
            Clone: function () {
                var body = new FarseerPhysics.Dynamics.Body.ctor();
                body.World = this.World;
                body.UserData = this.UserData;
                body.LinearDamping = this.LinearDamping;
                body.LinearVelocityInternal = this.LinearVelocityInternal.$clone();
                body.AngularDamping = this.AngularDamping;
                body.AngularVelocityInternal = this.AngularVelocityInternal;
                body.Position = this.Position.$clone();
                body.Rotation = this.Rotation;
                body._bodyType = this._bodyType;
                body.Flags = this.Flags;

                this.World.AddBody(body);

                return body;
            },
            SynchronizeFixtures: function () {
                var xf1 = { v : new FarseerPhysics.Common.Transform.ctor() };
                var c = Math.cos(this.Sweep.A0), s = Math.sin(this.Sweep.A0);
                xf1.v.R.Col1.X = c;
                xf1.v.R.Col2.X = -s;
                xf1.v.R.Col1.Y = s;
                xf1.v.R.Col2.Y = c;

                xf1.v.Position.X = this.Sweep.C0.X - (xf1.v.R.Col1.X * this.Sweep.LocalCenter.X + xf1.v.R.Col2.X * this.Sweep.LocalCenter.Y);
                xf1.v.Position.Y = this.Sweep.C0.Y - (xf1.v.R.Col1.Y * this.Sweep.LocalCenter.X + xf1.v.R.Col2.Y * this.Sweep.LocalCenter.Y);

                var broadPhase = this.World.ContactManager.BroadPhase;
                for (var i = 0; i < this.FixtureList.Count; i = (i + 1) | 0) {
                    this.FixtureList.getItem(i).Synchronize(broadPhase, xf1, Bridge.ref(this, "Xf"));
                }
            },
            SynchronizeTransform: function () {
                this.Xf.R.Set$1(this.Sweep.A);

                var vx = this.Xf.R.Col1.X * this.Sweep.LocalCenter.X + this.Xf.R.Col2.X * this.Sweep.LocalCenter.Y;
                var vy = this.Xf.R.Col1.Y * this.Sweep.LocalCenter.X + this.Xf.R.Col2.Y * this.Sweep.LocalCenter.Y;

                this.Xf.Position.X = this.Sweep.C.X - vx;
                this.Xf.Position.Y = this.Sweep.C.Y - vy;
            },
            /**
             * This is used to prevent connected bodies from colliding.
             It may lie, depending on the collideConnected flag.
             *
             * @instance
             * @this FarseerPhysics.Dynamics.Body
             * @memberof FarseerPhysics.Dynamics.Body
             * @param   {FarseerPhysics.Dynamics.Body}    other    The other body.
             * @return  {boolean}
             */
            ShouldCollide: function (other) {
                if (this._bodyType !== FarseerPhysics.Dynamics.BodyType.Dynamic && other._bodyType !== FarseerPhysics.Dynamics.BodyType.Dynamic) {
                    return false;
                }

                for (var jn = this.JointList; jn != null; jn = jn.Next) {
                    if (Bridge.referenceEquals(jn.Other, other)) {
                        if (jn.Joint.CollideConnected === false) {
                            return false;
                        }
                    }
                }

                return true;
            },
            Advance: function (alpha) {
                this.Sweep.Advance(alpha);
                this.Sweep.C = this.Sweep.C0.$clone();
                this.Sweep.A = this.Sweep.A0;
                this.SynchronizeTransform();
            },
            IgnoreCollisionWith: function (other) {
                for (var i = 0; i < this.FixtureList.Count; i = (i + 1) | 0) {
                    var f = this.FixtureList.getItem(i);
                    for (var j = 0; j < other.FixtureList.Count; j = (j + 1) | 0) {
                        var f2 = other.FixtureList.getItem(j);

                        f.IgnoreCollisionWith(f2);
                    }
                }
            },
            RestoreCollisionWith: function (other) {
                for (var i = 0; i < this.FixtureList.Count; i = (i + 1) | 0) {
                    var f = this.FixtureList.getItem(i);
                    for (var j = 0; j < other.FixtureList.Count; j = (j + 1) | 0) {
                        var f2 = other.FixtureList.getItem(j);

                        f.RestoreCollisionWith(f2);
                    }
                }
            }
        }
    });

    Bridge.define("FarseerPhysics.Dynamics.BodyFlags", {
        $kind: "enum",
        statics: {
            fields: {
                None: 0,
                Island: 1,
                Awake: 2,
                AutoSleep: 4,
                Bullet: 8,
                FixedRotation: 16,
                Enabled: 32,
                IgnoreGravity: 64,
                IgnoreCCD: 128
            }
        },
        $flags: true
    });

    /**
     * The body type.
     *
     * @public
     * @class FarseerPhysics.Dynamics.BodyType
     */
    Bridge.define("FarseerPhysics.Dynamics.BodyType", {
        $kind: "enum",
        statics: {
            fields: {
                /**
                 * Zero velocity, may be manually moved. Note: even static bodies have mass.
                 *
                 * @static
                 * @public
                 * @memberof FarseerPhysics.Dynamics.BodyType
                 * @constant
                 * @default 0
                 * @type FarseerPhysics.Dynamics.BodyType
                 */
                Static: 0,
                /**
                 * Zero mass, non-zero velocity set by user, moved by solver
                 *
                 * @static
                 * @public
                 * @memberof FarseerPhysics.Dynamics.BodyType
                 * @constant
                 * @default 1
                 * @type FarseerPhysics.Dynamics.BodyType
                 */
                Kinematic: 1,
                /**
                 * Positive mass, non-zero velocity determined by forces, moved by solver
                 *
                 * @static
                 * @public
                 * @memberof FarseerPhysics.Dynamics.BodyType
                 * @constant
                 * @default 2
                 * @type FarseerPhysics.Dynamics.BodyType
                 */
                Dynamic: 2
            }
        }
    });

    /**
     * A type of body that supports multiple fixtures that can break apart.
     *
     * @public
     * @class FarseerPhysics.Dynamics.BreakableBody
     */
    Bridge.define("FarseerPhysics.Dynamics.BreakableBody", {
        fields: {
            Broken: false,
            MainBody: null,
            Parts: null,
            /**
             * The force needed to break the body apart.
             Default: 500
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Dynamics.BreakableBody
             * @default 500.0
             * @type number
             */
            Strength: 0,
            _angularVelocitiesCache: null,
            _break: false,
            _velocitiesCache: null,
            _world: null
        },
        ctors: {
            init: function () {
                this.Parts = new (System.Collections.Generic.List$1(FarseerPhysics.Dynamics.Fixture)).$ctor2(8);
                this.Strength = 500.0;
                this._angularVelocitiesCache = System.Array.init(8, 0, System.Single);
                this._velocitiesCache = System.Array.init(8, function (){
                    return new Microsoft.Xna.Framework.Vector2();
                }, Microsoft.Xna.Framework.Vector2);
            },
            ctor: function (vertices, world, density) {
                FarseerPhysics.Dynamics.BreakableBody.$ctor1.call(this, vertices, world, density, null);
            },
            $ctor1: function (vertices, world, density, userData) {
                var $t;
                this.$initialize();
                this._world = world;
                this._world.ContactManager.PostSolve = Bridge.fn.combine(this._world.ContactManager.PostSolve, Bridge.fn.cacheBind(this, this.PostSolve));
                this.MainBody = new FarseerPhysics.Dynamics.Body.$ctor1(this._world);
                this.MainBody.BodyType = FarseerPhysics.Dynamics.BodyType.Dynamic;

                $t = Bridge.getEnumerator(vertices, FarseerPhysics.Common.Vertices);
                try {
                    while ($t.moveNext()) {
                        var part = $t.Current;
                        var polygonShape = new FarseerPhysics.Collision.Shapes.PolygonShape.$ctor1(part, density);
                        var fixture = this.MainBody.CreateFixture$1(polygonShape, userData);
                        this.Parts.add(fixture);
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }}
        },
        methods: {
            PostSolve: function (contact, impulse) {
                if (!this.Broken) {
                    if (this.Parts.contains(contact.FixtureA) || this.Parts.contains(contact.FixtureB)) {
                        var maxImpulse = 0.0;
                        var count = contact.Manifold.PointCount;

                        for (var i = 0; i < count; i = (i + 1) | 0) {
                            maxImpulse = Math.max(maxImpulse, impulse.Points[System.Array.index(i, impulse.Points)].NormalImpulse);
                        }

                        if (maxImpulse > this.Strength) {
                            this._break = true;
                        }
                    }
                }
            },
            Update: function () {
                if (this._break) {
                    this.Decompose();
                    this.Broken = true;
                    this._break = false;
                }

                if (this.Broken === false) {
                    if (this.Parts.Count > this._angularVelocitiesCache.length) {
                        this._velocitiesCache = System.Array.init(this.Parts.Count, function (){
                            return new Microsoft.Xna.Framework.Vector2();
                        }, Microsoft.Xna.Framework.Vector2);
                        this._angularVelocitiesCache = System.Array.init(this.Parts.Count, 0, System.Single);
                    }

                    for (var i = 0; i < this.Parts.Count; i = (i + 1) | 0) {
                        this._velocitiesCache[System.Array.index(i, this._velocitiesCache)] = this.Parts.getItem(i).Body.LinearVelocity.$clone();
                        this._angularVelocitiesCache[System.Array.index(i, this._angularVelocitiesCache)] = this.Parts.getItem(i).Body.AngularVelocity;
                    }
                }
            },
            Decompose: function () {
                this._world.ContactManager.PostSolve = Bridge.fn.remove(this._world.ContactManager.PostSolve, Bridge.fn.cacheBind(this, this.PostSolve));

                for (var i = 0; i < this.Parts.Count; i = (i + 1) | 0) {
                    var fixture = this.Parts.getItem(i);

                    var shape = fixture.Shape.Clone();

                    var userdata = fixture.UserData;
                    this.MainBody.DestroyFixture(fixture);

                    var body = FarseerPhysics.Factories.BodyFactory.CreateBody(this._world);
                    body.BodyType = FarseerPhysics.Dynamics.BodyType.Dynamic;
                    body.Position = this.MainBody.Position.$clone();
                    body.Rotation = this.MainBody.Rotation;
                    body.UserData = this.MainBody.UserData;

                    body.CreateFixture$1(shape, userdata);

                    body.AngularVelocity = this._angularVelocitiesCache[System.Array.index(i, this._angularVelocitiesCache)];
                    body.LinearVelocity = this._velocitiesCache[System.Array.index(i, this._velocitiesCache)].$clone();
                }

                this._world.RemoveBody(this.MainBody);
                this._world.RemoveBreakableBody(this);
            },
            Break: function () {
                this._break = true;
            }
        }
    });

    Bridge.define("FarseerPhysics.Dynamics.Category", {
        $kind: "enum",
        statics: {
            fields: {
                None: 0,
                All: 0,
                Cat1: 1,
                Cat2: 2,
                Cat3: 4,
                Cat4: 8,
                Cat5: 16,
                Cat6: 32,
                Cat7: 64,
                Cat8: 128,
                Cat9: 256,
                Cat10: 512,
                Cat11: 1024,
                Cat12: 2048,
                Cat13: 4096,
                Cat14: 8192,
                Cat15: 16384,
                Cat16: 32768,
                Cat17: 65536,
                Cat18: 131072,
                Cat19: 262144,
                Cat20: 524288,
                Cat21: 1048576,
                Cat22: 2097152,
                Cat23: 4194304,
                Cat24: 8388608,
                Cat25: 16777216,
                Cat26: 33554432,
                Cat27: 67108864,
                Cat28: 134217728,
                Cat29: 268435456,
                Cat30: 536870912,
                Cat31: 1073741824
            },
            ctors: {
                init: function () {
                    this.All = 2147483647;
                }
            }
        },
        $flags: true
    });

    /**
     * @memberof FarseerPhysics.Dynamics
     * @callback FarseerPhysics.Dynamics.PreSolveDelegate
     * @param   {FarseerPhysics.Dynamics.Contacts.Contact}    contact        
     * @param   {FarseerPhysics.Collision.Manifold}           oldManifold
     * @return  {void}
     */

    /**
     * @memberof FarseerPhysics.Dynamics
     * @callback FarseerPhysics.Dynamics.PostSolveDelegate
     * @param   {FarseerPhysics.Dynamics.Contacts.Contact}              contact    
     * @param   {FarseerPhysics.Dynamics.Contacts.ContactConstraint}    impulse
     * @return  {void}
     */

    /**
     * @memberof FarseerPhysics.Dynamics
     * @callback FarseerPhysics.Dynamics.BroadphaseDelegate
     * @param   {FarseerPhysics.Dynamics.FixtureProxy}    proxyA    
     * @param   {FarseerPhysics.Dynamics.FixtureProxy}    proxyB
     * @return  {void}
     */

    /**
     * @memberof FarseerPhysics.Dynamics
     * @callback FarseerPhysics.Dynamics.EndContactDelegate
     * @param   {FarseerPhysics.Dynamics.Contacts.Contact}    contact
     * @return  {void}
     */

    /**
     * @memberof FarseerPhysics.Dynamics
     * @callback FarseerPhysics.Dynamics.CollisionFilterDelegate
     * @param   {FarseerPhysics.Dynamics.Fixture}    fixtureA    
     * @param   {FarseerPhysics.Dynamics.Fixture}    fixtureB
     * @return  {boolean}
     */

    /**
     * @memberof FarseerPhysics.Dynamics
     * @callback FarseerPhysics.Dynamics.BeginContactDelegate
     * @param   {FarseerPhysics.Dynamics.Contacts.Contact}    contact
     * @return  {boolean}
     */

    Bridge.define("FarseerPhysics.Dynamics.ContactManager", {
        statics: {
            methods: {
                ShouldCollide: function (fixtureA, fixtureB) {
                    if (FarseerPhysics.Settings.UseFPECollisionCategories) {
                        if ((fixtureA.CollisionGroup === fixtureB.CollisionGroup) && fixtureA.CollisionGroup !== 0 && fixtureB.CollisionGroup !== 0) {
                            return false;
                        }

                        if (!!(((fixtureA.CollisionCategories & fixtureB.CollidesWith) === FarseerPhysics.Dynamics.Category.None) & ((fixtureB.CollisionCategories & fixtureA.CollidesWith) === FarseerPhysics.Dynamics.Category.None))) {
                            return false;
                        }

                        if (fixtureA.IsFixtureIgnored(fixtureB) || fixtureB.IsFixtureIgnored(fixtureA)) {
                            return false;
                        }

                        return true;
                    }

                    if (fixtureA.CollisionGroup === fixtureB.CollisionGroup && fixtureA.CollisionGroup !== 0) {
                        return fixtureA.CollisionGroup > 0;
                    }

                    var collide = (fixtureA.CollidesWith & fixtureB.CollisionCategories) !== 0 && (fixtureA.CollisionCategories & fixtureB.CollidesWith) !== 0;

                    if (collide) {
                        if (fixtureA.IsFixtureIgnored(fixtureB) || fixtureB.IsFixtureIgnored(fixtureA)) {
                            return false;
                        }
                    }

                    return collide;
                }
            }
        },
        fields: {
            /**
             * Fires when a contact is created
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Dynamics.ContactManager
             * @type FarseerPhysics.Dynamics.BeginContactDelegate
             */
            BeginContact: null,
            BroadPhase: null,
            /**
             * The filter used by the contact manager.
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Dynamics.ContactManager
             * @type FarseerPhysics.Dynamics.CollisionFilterDelegate
             */
            ContactFilter: null,
            ContactList: null,
            /**
             * Fires when a contact is deleted
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Dynamics.ContactManager
             * @type FarseerPhysics.Dynamics.EndContactDelegate
             */
            EndContact: null,
            /**
             * Fires when the broadphase detects that two Fixtures are close to each other.
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Dynamics.ContactManager
             * @type FarseerPhysics.Dynamics.BroadphaseDelegate
             */
            OnBroadphaseCollision: null,
            /**
             * Fires after the solver has run
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Dynamics.ContactManager
             * @type FarseerPhysics.Dynamics.PostSolveDelegate
             */
            PostSolve: null,
            /**
             * Fires before the solver runs
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Dynamics.ContactManager
             * @type FarseerPhysics.Dynamics.PreSolveDelegate
             */
            PreSolve: null
        },
        ctors: {
            init: function () {
                this.ContactList = new (System.Collections.Generic.List$1(FarseerPhysics.Dynamics.Contacts.Contact)).$ctor2(128);
            },
            ctor: function (broadPhase) {
                this.$initialize();
                this.BroadPhase = broadPhase;
                this.OnBroadphaseCollision = Bridge.fn.cacheBind(this, this.AddPair);
            }
        },
        methods: {
            AddPair: function (proxyA, proxyB) {
                var fixtureA = proxyA.v.Fixture;
                var fixtureB = proxyB.v.Fixture;

                var indexA = proxyA.v.ChildIndex;
                var indexB = proxyB.v.ChildIndex;

                var bodyA = fixtureA.Body;
                var bodyB = fixtureB.Body;

                if (Bridge.referenceEquals(bodyA, bodyB)) {
                    return;
                }

                var edge = bodyB.ContactList;
                while (edge != null) {
                    if (Bridge.referenceEquals(edge.Other, bodyA)) {
                        var fA = edge.Contact.FixtureA;
                        var fB = edge.Contact.FixtureB;
                        var iA = edge.Contact.ChildIndexA;
                        var iB = edge.Contact.ChildIndexB;

                        if (Bridge.referenceEquals(fA, fixtureA) && Bridge.referenceEquals(fB, fixtureB) && iA === indexA && iB === indexB) {
                            return;
                        }

                        if (Bridge.referenceEquals(fA, fixtureB) && Bridge.referenceEquals(fB, fixtureA) && iA === indexB && iB === indexA) {
                            return;
                        }
                    }

                    edge = edge.Next;
                }

                if (bodyB.ShouldCollide(bodyA) === false) {
                    return;
                }

                if (FarseerPhysics.Dynamics.ContactManager.ShouldCollide(fixtureA, fixtureB) === false) {
                    return;
                }

                if (!Bridge.staticEquals(this.ContactFilter, null) && this.ContactFilter(fixtureA, fixtureB) === false) {
                    return;
                }

                if (!Bridge.staticEquals(fixtureA.BeforeCollision, null) && fixtureA.BeforeCollision(fixtureA, fixtureB) === false) {
                    return;
                }

                if (!Bridge.staticEquals(fixtureB.BeforeCollision, null) && fixtureB.BeforeCollision(fixtureB, fixtureA) === false) {
                    return;
                }

                var c = FarseerPhysics.Dynamics.Contacts.Contact.Create(fixtureA, indexA, fixtureB, indexB);

                fixtureA = c.FixtureA;
                fixtureB = c.FixtureB;
                bodyA = fixtureA.Body;
                bodyB = fixtureB.Body;

                this.ContactList.add(c);


                c.NodeA.Contact = c;
                c.NodeA.Other = bodyB;

                c.NodeA.Prev = null;
                c.NodeA.Next = bodyA.ContactList;
                if (bodyA.ContactList != null) {
                    bodyA.ContactList.Prev = c.NodeA;
                }
                bodyA.ContactList = c.NodeA;

                c.NodeB.Contact = c;
                c.NodeB.Other = bodyA;

                c.NodeB.Prev = null;
                c.NodeB.Next = bodyB.ContactList;
                if (bodyB.ContactList != null) {
                    bodyB.ContactList.Prev = c.NodeB;
                }
                bodyB.ContactList = c.NodeB;
            },
            FindNewContacts: function () {
                this.BroadPhase.FarseerPhysics$Collision$IBroadPhase$UpdatePairs(this.OnBroadphaseCollision);
            },
            Destroy: function (contact) {
                var fixtureA = contact.FixtureA;
                var fixtureB = contact.FixtureB;
                var bodyA = fixtureA.Body;
                var bodyB = fixtureB.Body;

                if (!Bridge.staticEquals(this.EndContact, null) && contact.IsTouching()) {
                    this.EndContact(contact);
                }

                this.ContactList.remove(contact);

                if (contact.NodeA.Prev != null) {
                    contact.NodeA.Prev.Next = contact.NodeA.Next;
                }

                if (contact.NodeA.Next != null) {
                    contact.NodeA.Next.Prev = contact.NodeA.Prev;
                }

                if (Bridge.referenceEquals(contact.NodeA, bodyA.ContactList)) {
                    bodyA.ContactList = contact.NodeA.Next;
                }

                if (contact.NodeB.Prev != null) {
                    contact.NodeB.Prev.Next = contact.NodeB.Next;
                }

                if (contact.NodeB.Next != null) {
                    contact.NodeB.Next.Prev = contact.NodeB.Prev;
                }

                if (Bridge.referenceEquals(contact.NodeB, bodyB.ContactList)) {
                    bodyB.ContactList = contact.NodeB.Next;
                }

                contact.Destroy();
            },
            Collide: function () {
                for (var i = 0; i < this.ContactList.Count; i = (i + 1) | 0) {
                    var c = this.ContactList.getItem(i);
                    var fixtureA = c.FixtureA;
                    var fixtureB = c.FixtureB;
                    var indexA = c.ChildIndexA;
                    var indexB = c.ChildIndexB;
                    var bodyA = fixtureA.Body;
                    var bodyB = fixtureB.Body;

                    if (bodyA.Awake === false && bodyB.Awake === false) {
                        continue;
                    }

                    if ((c.Flags & FarseerPhysics.Dynamics.Contacts.ContactFlags.Filter) === FarseerPhysics.Dynamics.Contacts.ContactFlags.Filter) {
                        if (bodyB.ShouldCollide(bodyA) === false) {
                            var cNuke = c;
                            this.Destroy(cNuke);
                            continue;
                        }

                        if (FarseerPhysics.Dynamics.ContactManager.ShouldCollide(fixtureA, fixtureB) === false) {
                            var cNuke1 = c;
                            this.Destroy(cNuke1);
                            continue;
                        }

                        if (!Bridge.staticEquals(this.ContactFilter, null) && this.ContactFilter(fixtureA, fixtureB) === false) {
                            var cNuke2 = c;
                            this.Destroy(cNuke2);
                            continue;
                        }

                        c.Flags &= -9;
                    }

                    var proxyIdA = fixtureA.Proxies[System.Array.index(indexA, fixtureA.Proxies)].ProxyId;
                    var proxyIdB = fixtureB.Proxies[System.Array.index(indexB, fixtureB.Proxies)].ProxyId;

                    var overlap = this.BroadPhase.FarseerPhysics$Collision$IBroadPhase$TestOverlap(proxyIdA, proxyIdB);

                    if (overlap === false) {
                        var cNuke3 = c;
                        this.Destroy(cNuke3);
                        continue;
                    }

                    c.Update(this);
                }
            }
        }
    });

    /** @namespace FarseerPhysics.Dynamics.Contacts */

    /**
     * The class manages contact between two shapes. A contact exists for each overlapping
     AABB in the broad-phase (except if filtered). Therefore a contact object may exist
     that has no contact points.
     *
     * @public
     * @class FarseerPhysics.Dynamics.Contacts.Contact
     */
    Bridge.define("FarseerPhysics.Dynamics.Contacts.Contact", {
        statics: {
            fields: {
                _edge: null,
                _registers: null
            },
            ctors: {
                init: function () {
                    this._edge = new FarseerPhysics.Collision.Shapes.EdgeShape.ctor();
                    this._registers = System.Array.create(0, [[
                        FarseerPhysics.Dynamics.Contacts.Contact.ContactType.Circle, 
                        FarseerPhysics.Dynamics.Contacts.Contact.ContactType.EdgeAndCircle, 
                        FarseerPhysics.Dynamics.Contacts.Contact.ContactType.PolygonAndCircle, 
                        FarseerPhysics.Dynamics.Contacts.Contact.ContactType.LoopAndCircle
                    ], [
                        FarseerPhysics.Dynamics.Contacts.Contact.ContactType.EdgeAndCircle, 
                        FarseerPhysics.Dynamics.Contacts.Contact.ContactType.NotSupported, 
                        FarseerPhysics.Dynamics.Contacts.Contact.ContactType.EdgeAndPolygon, 
                        FarseerPhysics.Dynamics.Contacts.Contact.ContactType.NotSupported
                    ], [
                        FarseerPhysics.Dynamics.Contacts.Contact.ContactType.PolygonAndCircle, 
                        FarseerPhysics.Dynamics.Contacts.Contact.ContactType.EdgeAndPolygon, 
                        FarseerPhysics.Dynamics.Contacts.Contact.ContactType.Polygon, 
                        FarseerPhysics.Dynamics.Contacts.Contact.ContactType.LoopAndPolygon
                    ], [
                        FarseerPhysics.Dynamics.Contacts.Contact.ContactType.LoopAndCircle, 
                        FarseerPhysics.Dynamics.Contacts.Contact.ContactType.NotSupported, 
                        FarseerPhysics.Dynamics.Contacts.Contact.ContactType.LoopAndPolygon, 
                        FarseerPhysics.Dynamics.Contacts.Contact.ContactType.NotSupported
                    ]], FarseerPhysics.Dynamics.Contacts.Contact.ContactType, 4, 4);
                }
            },
            methods: {
                Create: function (fixtureA, indexA, fixtureB, indexB) {
                    var type1 = fixtureA.ShapeType;
                    var type2 = fixtureB.ShapeType;

                    System.Diagnostics.Debug.Assert(FarseerPhysics.Collision.Shapes.ShapeType.Unknown < type1 && type1 < FarseerPhysics.Collision.Shapes.ShapeType.TypeCount);
                    System.Diagnostics.Debug.Assert(FarseerPhysics.Collision.Shapes.ShapeType.Unknown < type2 && type2 < FarseerPhysics.Collision.Shapes.ShapeType.TypeCount);

                    var c;
                    var pool = fixtureA.Body.World.ContactPool;
                    if (pool.Count > 0) {
                        c = pool.Dequeue();
                        if ((type1 >= type2 || (type1 === FarseerPhysics.Collision.Shapes.ShapeType.Edge && type2 === FarseerPhysics.Collision.Shapes.ShapeType.Polygon)) && !(type2 === FarseerPhysics.Collision.Shapes.ShapeType.Edge && type1 === FarseerPhysics.Collision.Shapes.ShapeType.Polygon)) {
                            c.Reset(fixtureA, indexA, fixtureB, indexB);
                        } else {
                            c.Reset(fixtureB, indexB, fixtureA, indexA);
                        }
                    } else {
                        if ((type1 >= type2 || (type1 === FarseerPhysics.Collision.Shapes.ShapeType.Edge && type2 === FarseerPhysics.Collision.Shapes.ShapeType.Polygon)) && !(type2 === FarseerPhysics.Collision.Shapes.ShapeType.Edge && type1 === FarseerPhysics.Collision.Shapes.ShapeType.Polygon)) {
                            c = new FarseerPhysics.Dynamics.Contacts.Contact(fixtureA, indexA, fixtureB, indexB);
                        } else {
                            c = new FarseerPhysics.Dynamics.Contacts.Contact(fixtureB, indexB, fixtureA, indexA);
                        }
                    }

                    c._type = FarseerPhysics.Dynamics.Contacts.Contact._registers.get([type1, type2]);

                    return c;
                }
            }
        },
        fields: {
            FixtureA: null,
            FixtureB: null,
            Flags: 0,
            Manifold: null,
            NodeA: null,
            NodeB: null,
            TOI: 0,
            TOICount: 0,
            _type: 0,
            /**
             * Get the child primitive index for fixture A.
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Dynamics.Contacts.Contact
             * @function ChildIndexA
             * @type number
             */
            ChildIndexA: 0,
            /**
             * Get the child primitive index for fixture B.
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Dynamics.Contacts.Contact
             * @function ChildIndexB
             * @type number
             */
            ChildIndexB: 0
        },
        props: {
            /**
             * @instance
             * @public
             * @memberof FarseerPhysics.Dynamics.Contacts.Contact
             * @function Enabled
             * @type boolean
             */
            Enabled: {
                get: function () {
                    return (this.Flags & FarseerPhysics.Dynamics.Contacts.ContactFlags.Enabled) === FarseerPhysics.Dynamics.Contacts.ContactFlags.Enabled;
                },
                set: function (value) {
                    if (value) {
                        this.Flags |= FarseerPhysics.Dynamics.Contacts.ContactFlags.Enabled;
                    } else {
                        this.Flags &= -5;
                    }
                }
            }
        },
        ctors: {
            init: function () {
                this.Manifold = new FarseerPhysics.Collision.Manifold();
                this.NodeA = new FarseerPhysics.Dynamics.Contacts.ContactEdge();
                this.NodeB = new FarseerPhysics.Dynamics.Contacts.ContactEdge();
            },
            ctor: function (fA, indexA, fB, indexB) {
                this.$initialize();
                this.Reset(fA, indexA, fB, indexB);
            }
        },
        methods: {
            /**
             * Get the contact manifold. Do not modify the manifold unless you understand the
             internals of Box2D.
             *
             * @instance
             * @public
             * @this FarseerPhysics.Dynamics.Contacts.Contact
             * @memberof FarseerPhysics.Dynamics.Contacts.Contact
             * @param   {FarseerPhysics.Collision.Manifold}    manifold    The manifold.
             * @return  {void}
             */
            GetManifold: function (manifold) {
                manifold.v = this.Manifold.$clone();
            },
            /**
             * Gets the world manifold.
             *
             * @instance
             * @public
             * @this FarseerPhysics.Dynamics.Contacts.Contact
             * @memberof FarseerPhysics.Dynamics.Contacts.Contact
             * @param   {Microsoft.Xna.Framework.Vector2}      normal    
             * @param   {FarseerPhysics.Common.FixedArray2}    points
             * @return  {void}
             */
            GetWorldManifold: function (normal, points) {
                var bodyA = this.FixtureA.Body;
                var bodyB = this.FixtureB.Body;
                var shapeA = this.FixtureA.Shape;
                var shapeB = this.FixtureB.Shape;

                FarseerPhysics.Collision.Collision.GetWorldManifold(Bridge.ref(this, "Manifold"), Bridge.ref(bodyA, "Xf"), shapeA.Radius, Bridge.ref(bodyB, "Xf"), shapeB.Radius, normal, points);
            },
            /**
             * Determines whether this contact is touching.
             *
             * @instance
             * @public
             * @this FarseerPhysics.Dynamics.Contacts.Contact
             * @memberof FarseerPhysics.Dynamics.Contacts.Contact
             * @return  {boolean}        <pre><code>true</code></pre> if this instance is touching; otherwise, <pre><code>false</code></pre>.
             */
            IsTouching: function () {
                return (this.Flags & FarseerPhysics.Dynamics.Contacts.ContactFlags.Touching) === FarseerPhysics.Dynamics.Contacts.ContactFlags.Touching;
            },
            /**
             * Flag this contact for filtering. Filtering will occur the next time step.
             *
             * @instance
             * @public
             * @this FarseerPhysics.Dynamics.Contacts.Contact
             * @memberof FarseerPhysics.Dynamics.Contacts.Contact
             * @return  {void}
             */
            FlagForFiltering: function () {
                this.Flags |= FarseerPhysics.Dynamics.Contacts.ContactFlags.Filter;
            },
            Reset: function (fA, indexA, fB, indexB) {
                this.Flags = FarseerPhysics.Dynamics.Contacts.ContactFlags.Enabled;

                this.FixtureA = fA;
                this.FixtureB = fB;

                this.ChildIndexA = indexA;
                this.ChildIndexB = indexB;

                this.Manifold.PointCount = 0;

                this.NodeA.Contact = null;
                this.NodeA.Prev = null;
                this.NodeA.Next = null;
                this.NodeA.Other = null;

                this.NodeB.Contact = null;
                this.NodeB.Prev = null;
                this.NodeB.Next = null;
                this.NodeB.Other = null;

                this.TOICount = 0;
            },
            /**
             * Update the contact manifold and touching status.
             Note: do not assume the fixture AABBs are overlapping or are valid.
             *
             * @instance
             * @this FarseerPhysics.Dynamics.Contacts.Contact
             * @memberof FarseerPhysics.Dynamics.Contacts.Contact
             * @param   {FarseerPhysics.Dynamics.ContactManager}    contactManager    The contact manager.
             * @return  {void}
             */
            Update: function (contactManager) {
                var oldManifold = { v : this.Manifold.$clone() };

                this.Flags |= FarseerPhysics.Dynamics.Contacts.ContactFlags.Enabled;

                var touching;
                var wasTouching = (this.Flags & FarseerPhysics.Dynamics.Contacts.ContactFlags.Touching) === FarseerPhysics.Dynamics.Contacts.ContactFlags.Touching;

                var sensor = this.FixtureA.IsSensor || this.FixtureB.IsSensor;

                var bodyA = this.FixtureA.Body;
                var bodyB = this.FixtureB.Body;

                if (sensor) {
                    var shapeA = this.FixtureA.Shape;
                    var shapeB = this.FixtureB.Shape;
                    touching = FarseerPhysics.Collision.AABB.TestOverlap$2(shapeA, this.ChildIndexA, shapeB, this.ChildIndexB, Bridge.ref(bodyA, "Xf"), Bridge.ref(bodyB, "Xf"));

                    this.Manifold.PointCount = 0;
                } else {
                    this.Evaluate(Bridge.ref(this, "Manifold"), Bridge.ref(bodyA, "Xf"), Bridge.ref(bodyB, "Xf"));
                    touching = this.Manifold.PointCount > 0;

                    for (var i = 0; i < this.Manifold.PointCount; i = (i + 1) | 0) {
                        var mp2 = this.Manifold.Points.getItem(i).$clone();
                        mp2.NormalImpulse = 0.0;
                        mp2.TangentImpulse = 0.0;
                        var id2 = mp2.Id.$clone();
                        var found = false;

                        for (var j = 0; j < oldManifold.v.PointCount; j = (j + 1) | 0) {
                            var mp1 = oldManifold.v.Points.getItem(j).$clone();

                            if (mp1.Id.Key === id2.Key) {
                                mp2.NormalImpulse = mp1.NormalImpulse;
                                mp2.TangentImpulse = mp1.TangentImpulse;
                                found = true;
                                break;
                            }
                        }
                        if (found === false) {
                            mp2.NormalImpulse = 0.0;
                            mp2.TangentImpulse = 0.0;
                        }

                        this.Manifold.Points.setItem(i, mp2.$clone());
                    }

                    if (touching !== wasTouching) {
                        bodyA.Awake = true;
                        bodyB.Awake = true;
                    }
                }

                if (touching) {
                    this.Flags |= FarseerPhysics.Dynamics.Contacts.ContactFlags.Touching;
                } else {
                    this.Flags &= -3;
                }

                if (wasTouching === false && touching) {
                    if (!Bridge.staticEquals(this.FixtureA.OnCollision, null)) {
                        this.Enabled = this.FixtureA.OnCollision(this.FixtureA, this.FixtureB, this);
                    }

                    if (!Bridge.staticEquals(this.FixtureB.OnCollision, null)) {
                        this.Enabled = this.FixtureB.OnCollision(this.FixtureB, this.FixtureA, this);
                    }

                    if (!Bridge.staticEquals(contactManager.BeginContact, null)) {
                        this.Enabled = contactManager.BeginContact(this);
                    }

                    if (this.Enabled === false) {
                        this.Flags &= -3;
                    }
                }

                if (wasTouching && touching === false) {
                    if (this.FixtureA != null && !Bridge.staticEquals(this.FixtureA.OnSeparation, null)) {
                        this.FixtureA.OnSeparation(this.FixtureA, this.FixtureB);
                    }

                    if (this.FixtureB != null && !Bridge.staticEquals(this.FixtureB.OnSeparation, null)) {
                        this.FixtureB.OnSeparation(this.FixtureB, this.FixtureA);
                    }

                    if (!Bridge.staticEquals(contactManager.EndContact, null)) {
                        contactManager.EndContact(this);
                    }
                }

                if (sensor) {
                    return;
                }

                if (!Bridge.staticEquals(contactManager.PreSolve, null)) {
                    contactManager.PreSolve(this, oldManifold);
                }
            },
            /**
             * Evaluate this contact with your own manifold and transforms.
             *
             * @instance
             * @private
             * @this FarseerPhysics.Dynamics.Contacts.Contact
             * @memberof FarseerPhysics.Dynamics.Contacts.Contact
             * @param   {FarseerPhysics.Collision.Manifold}    manifold      The manifold.
             * @param   {FarseerPhysics.Common.Transform}      transformA    The first transform.
             * @param   {FarseerPhysics.Common.Transform}      transformB    The second transform.
             * @return  {void}
             */
            Evaluate: function (manifold, transformA, transformB) {
                switch (this._type) {
                    case FarseerPhysics.Dynamics.Contacts.Contact.ContactType.Polygon: 
                        FarseerPhysics.Collision.Collision.CollidePolygons(manifold, Bridge.cast(this.FixtureA.Shape, FarseerPhysics.Collision.Shapes.PolygonShape), transformA, Bridge.cast(this.FixtureB.Shape, FarseerPhysics.Collision.Shapes.PolygonShape), transformB);
                        break;
                    case FarseerPhysics.Dynamics.Contacts.Contact.ContactType.PolygonAndCircle: 
                        FarseerPhysics.Collision.Collision.CollidePolygonAndCircle(manifold, Bridge.cast(this.FixtureA.Shape, FarseerPhysics.Collision.Shapes.PolygonShape), transformA, Bridge.cast(this.FixtureB.Shape, FarseerPhysics.Collision.Shapes.CircleShape), transformB);
                        break;
                    case FarseerPhysics.Dynamics.Contacts.Contact.ContactType.EdgeAndCircle: 
                        FarseerPhysics.Collision.Collision.CollideEdgeAndCircle(manifold, Bridge.cast(this.FixtureA.Shape, FarseerPhysics.Collision.Shapes.EdgeShape), transformA, Bridge.cast(this.FixtureB.Shape, FarseerPhysics.Collision.Shapes.CircleShape), transformB);
                        break;
                    case FarseerPhysics.Dynamics.Contacts.Contact.ContactType.EdgeAndPolygon: 
                        FarseerPhysics.Collision.Collision.CollideEdgeAndPolygon(manifold, Bridge.cast(this.FixtureA.Shape, FarseerPhysics.Collision.Shapes.EdgeShape), transformA, Bridge.cast(this.FixtureB.Shape, FarseerPhysics.Collision.Shapes.PolygonShape), transformB);
                        break;
                    case FarseerPhysics.Dynamics.Contacts.Contact.ContactType.LoopAndCircle: 
                        var loop = Bridge.cast(this.FixtureA.Shape, FarseerPhysics.Collision.Shapes.LoopShape);
                        loop.GetChildEdge(Bridge.ref(FarseerPhysics.Dynamics.Contacts.Contact, "_edge"), this.ChildIndexA);
                        FarseerPhysics.Collision.Collision.CollideEdgeAndCircle(manifold, FarseerPhysics.Dynamics.Contacts.Contact._edge, transformA, Bridge.cast(this.FixtureB.Shape, FarseerPhysics.Collision.Shapes.CircleShape), transformB);
                        break;
                    case FarseerPhysics.Dynamics.Contacts.Contact.ContactType.LoopAndPolygon: 
                        var loop2 = Bridge.cast(this.FixtureA.Shape, FarseerPhysics.Collision.Shapes.LoopShape);
                        loop2.GetChildEdge(Bridge.ref(FarseerPhysics.Dynamics.Contacts.Contact, "_edge"), this.ChildIndexA);
                        FarseerPhysics.Collision.Collision.CollideEdgeAndPolygon(manifold, FarseerPhysics.Dynamics.Contacts.Contact._edge, transformA, Bridge.cast(this.FixtureB.Shape, FarseerPhysics.Collision.Shapes.PolygonShape), transformB);
                        break;
                    case FarseerPhysics.Dynamics.Contacts.Contact.ContactType.Circle: 
                        FarseerPhysics.Collision.Collision.CollideCircles(manifold, Bridge.cast(this.FixtureA.Shape, FarseerPhysics.Collision.Shapes.CircleShape), transformA, Bridge.cast(this.FixtureB.Shape, FarseerPhysics.Collision.Shapes.CircleShape), transformB);
                        break;
                }
            },
            Destroy: function () {
                this.FixtureA.Body.World.ContactPool.Enqueue(this);
                this.Reset(null, 0, null, 0);
            }
        }
    });

    Bridge.define("FarseerPhysics.Dynamics.Contacts.Contact.ContactType", {
        $kind: "nested enum",
        statics: {
            fields: {
                NotSupported: 0,
                Polygon: 1,
                PolygonAndCircle: 2,
                Circle: 3,
                EdgeAndPolygon: 4,
                EdgeAndCircle: 5,
                LoopAndPolygon: 6,
                LoopAndCircle: 7
            }
        }
    });

    Bridge.define("FarseerPhysics.Dynamics.Contacts.ContactConstraint", {
        fields: {
            BodyA: null,
            BodyB: null,
            Friction: 0,
            K: null,
            LocalNormal: null,
            LocalPoint: null,
            Manifold: null,
            Normal: null,
            NormalMass: null,
            PointCount: 0,
            Points: null,
            RadiusA: 0,
            RadiusB: 0,
            Restitution: 0,
            Type: 0
        },
        ctors: {
            init: function () {
                this.K = new FarseerPhysics.Common.Mat22();
                this.LocalNormal = new Microsoft.Xna.Framework.Vector2();
                this.LocalPoint = new Microsoft.Xna.Framework.Vector2();
                this.Manifold = new FarseerPhysics.Collision.Manifold();
                this.Normal = new Microsoft.Xna.Framework.Vector2();
                this.NormalMass = new FarseerPhysics.Common.Mat22();
                this.Points = System.Array.init(FarseerPhysics.Settings.MaxPolygonVertices, null, FarseerPhysics.Dynamics.Contacts.ContactConstraintPoint);
            },
            ctor: function () {
                this.$initialize();
                for (var i = 0; i < FarseerPhysics.Settings.MaxManifoldPoints; i = (i + 1) | 0) {
                    this.Points[System.Array.index(i, this.Points)] = new FarseerPhysics.Dynamics.Contacts.ContactConstraintPoint();
                }
            }
        }
    });

    Bridge.define("FarseerPhysics.Dynamics.Contacts.ContactConstraintPoint", {
        fields: {
            LocalPoint: null,
            NormalImpulse: 0,
            NormalMass: 0,
            TangentImpulse: 0,
            TangentMass: 0,
            VelocityBias: 0,
            rA: null,
            rB: null
        },
        ctors: {
            init: function () {
                this.LocalPoint = new Microsoft.Xna.Framework.Vector2();
                this.rA = new Microsoft.Xna.Framework.Vector2();
                this.rB = new Microsoft.Xna.Framework.Vector2();
            }
        }
    });

    /**
     * A contact edge is used to connect bodies and contacts together
     in a contact graph where each body is a node and each contact
     is an edge. A contact edge belongs to a doubly linked list
     maintained in each attached body. Each contact has two contact
     nodes, one for each attached body.
     *
     * @public
     * @class FarseerPhysics.Dynamics.Contacts.ContactEdge
     */
    Bridge.define("FarseerPhysics.Dynamics.Contacts.ContactEdge", {
        fields: {
            /**
             * The contact
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Dynamics.Contacts.ContactEdge
             * @type FarseerPhysics.Dynamics.Contacts.Contact
             */
            Contact: null,
            /**
             * The next contact edge in the body's contact list
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Dynamics.Contacts.ContactEdge
             * @type FarseerPhysics.Dynamics.Contacts.ContactEdge
             */
            Next: null,
            /**
             * Provides quick access to the other body attached.
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Dynamics.Contacts.ContactEdge
             * @type FarseerPhysics.Dynamics.Body
             */
            Other: null,
            /**
             * The previous contact edge in the body's contact list
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Dynamics.Contacts.ContactEdge
             * @type FarseerPhysics.Dynamics.Contacts.ContactEdge
             */
            Prev: null
        }
    });

    Bridge.define("FarseerPhysics.Dynamics.Contacts.ContactFlags", {
        $kind: "enum",
        statics: {
            fields: {
                None: 0,
                /**
                 * Used when crawling contact graph when forming islands.
                 *
                 * @static
                 * @public
                 * @memberof FarseerPhysics.Dynamics.Contacts.ContactFlags
                 * @constant
                 * @default 1
                 * @type FarseerPhysics.Dynamics.Contacts.ContactFlags
                 */
                Island: 1,
                /**
                 * Set when the shapes are touching.
                 *
                 * @static
                 * @public
                 * @memberof FarseerPhysics.Dynamics.Contacts.ContactFlags
                 * @constant
                 * @default 2
                 * @type FarseerPhysics.Dynamics.Contacts.ContactFlags
                 */
                Touching: 2,
                /**
                 * This contact can be disabled (by user)
                 *
                 * @static
                 * @public
                 * @memberof FarseerPhysics.Dynamics.Contacts.ContactFlags
                 * @constant
                 * @default 4
                 * @type FarseerPhysics.Dynamics.Contacts.ContactFlags
                 */
                Enabled: 4,
                /**
                 * This contact needs filtering because a fixture filter was changed.
                 *
                 * @static
                 * @public
                 * @memberof FarseerPhysics.Dynamics.Contacts.ContactFlags
                 * @constant
                 * @default 8
                 * @type FarseerPhysics.Dynamics.Contacts.ContactFlags
                 */
                Filter: 8,
                /**
                 * This bullet contact had a TOI event
                 *
                 * @static
                 * @public
                 * @memberof FarseerPhysics.Dynamics.Contacts.ContactFlags
                 * @constant
                 * @default 16
                 * @type FarseerPhysics.Dynamics.Contacts.ContactFlags
                 */
                BulletHit: 16,
                /**
                 * This contact has a valid TOI i the field TOI
                 *
                 * @static
                 * @public
                 * @memberof FarseerPhysics.Dynamics.Contacts.ContactFlags
                 * @constant
                 * @default 32
                 * @type FarseerPhysics.Dynamics.Contacts.ContactFlags
                 */
                TOI: 32
            }
        },
        $flags: true
    });

    Bridge.define("FarseerPhysics.Dynamics.Contacts.ContactSolver", {
        statics: {
            methods: {
                Solve: function (cc, index, normal, point, separation) {
                    System.Diagnostics.Debug.Assert(cc.PointCount > 0);

                    normal.v = Microsoft.Xna.Framework.Vector2.Zero.$clone();

                    switch (cc.Type) {
                        case FarseerPhysics.Collision.ManifoldType.Circles: 
                            {
                                var pointA = cc.BodyA.GetWorldPoint$1(Bridge.ref(cc, "LocalPoint"));
                                var pointB = cc.BodyB.GetWorldPoint$1(Bridge.ref(cc.Points[System.Array.index(0, cc.Points)], "LocalPoint"));
                                var a = (pointA.X - pointB.X) * (pointA.X - pointB.X) + (pointA.Y - pointB.Y) * (pointA.Y - pointB.Y);
                                if (a > 1.42108547E-14) {
                                    var normalTmp = Microsoft.Xna.Framework.Vector2.op_Subtraction(pointB.$clone(), pointA.$clone());
                                    var factor = 1.0 / Math.sqrt(normalTmp.X * normalTmp.X + normalTmp.Y * normalTmp.Y);
                                    normal.v.X = normalTmp.X * factor;
                                    normal.v.Y = normalTmp.Y * factor;
                                } else {
                                    normal.v.X = 1;
                                    normal.v.Y = 0;
                                }

                                point.v = Microsoft.Xna.Framework.Vector2.op_Multiply$2(0.5, (Microsoft.Xna.Framework.Vector2.op_Addition(pointA.$clone(), pointB.$clone())));
                                separation.v = (pointB.X - pointA.X) * normal.v.X + (pointB.Y - pointA.Y) * normal.v.Y - cc.RadiusA - cc.RadiusB;
                            }
                            break;
                        case FarseerPhysics.Collision.ManifoldType.FaceA: 
                            {
                                normal.v = cc.BodyA.GetWorldVector$1(Bridge.ref(cc, "LocalNormal"));
                                var planePoint = cc.BodyA.GetWorldPoint$1(Bridge.ref(cc, "LocalPoint"));
                                var clipPoint = cc.BodyB.GetWorldPoint$1(Bridge.ref(cc.Points[System.Array.index(index, cc.Points)], "LocalPoint"));
                                separation.v = (clipPoint.X - planePoint.X) * normal.v.X + (clipPoint.Y - planePoint.Y) * normal.v.Y - cc.RadiusA - cc.RadiusB;
                                point.v = clipPoint.$clone();
                            }
                            break;
                        case FarseerPhysics.Collision.ManifoldType.FaceB: 
                            {
                                normal.v = cc.BodyB.GetWorldVector$1(Bridge.ref(cc, "LocalNormal"));
                                var planePoint1 = cc.BodyB.GetWorldPoint$1(Bridge.ref(cc, "LocalPoint"));

                                var clipPoint1 = cc.BodyA.GetWorldPoint$1(Bridge.ref(cc.Points[System.Array.index(index, cc.Points)], "LocalPoint"));
                                separation.v = (clipPoint1.X - planePoint1.X) * normal.v.X + (clipPoint1.Y - planePoint1.Y) * normal.v.Y - cc.RadiusA - cc.RadiusB;
                                point.v = clipPoint1.$clone();

                                normal.v = Microsoft.Xna.Framework.Vector2.op_UnaryNegation(normal.v.$clone());
                            }
                            break;
                        default: 
                            point.v = Microsoft.Xna.Framework.Vector2.Zero.$clone();
                            separation.v = 0.0;
                            break;
                    }
                }
            }
        },
        fields: {
            Constraints: null,
            _constraintCount: 0,
            _contacts: null
        },
        methods: {
            Reset: function (contacts, contactCount, impulseRatio, warmstarting) {
                this._contacts = contacts;
                this._constraintCount = contactCount;

                if (this.Constraints == null || this.Constraints.length < this._constraintCount) {
                    this.Constraints = System.Array.init(Bridge.Int.mul(contactCount, 2), null, FarseerPhysics.Dynamics.Contacts.ContactConstraint);
                    for (var i = 0; i < this.Constraints.length; i = (i + 1) | 0) {
                        this.Constraints[System.Array.index(i, this.Constraints)] = new FarseerPhysics.Dynamics.Contacts.ContactConstraint();
                    }
                }

                for (var i1 = 0; i1 < this._constraintCount; i1 = (i1 + 1) | 0) {
                    var contact = this._contacts[System.Array.index(i1, this._contacts)];

                    var fixtureA = contact.FixtureA;
                    var fixtureB = contact.FixtureB;
                    var shapeA = fixtureA.Shape;
                    var shapeB = fixtureB.Shape;
                    var radiusA = shapeA.Radius;
                    var radiusB = shapeB.Radius;
                    var bodyA = fixtureA.Body;
                    var bodyB = fixtureB.Body;
                    var manifold = contact.Manifold.$clone();

                    System.Diagnostics.Debug.Assert(manifold.PointCount > 0);

                    var cc = this.Constraints[System.Array.index(i1, this.Constraints)];
                    cc.Friction = FarseerPhysics.Settings.MixFriction(fixtureA.Friction, fixtureB.Friction);
                    cc.Restitution = FarseerPhysics.Settings.MixRestitution(fixtureA.Restitution, fixtureB.Restitution);
                    cc.BodyA = bodyA;
                    cc.BodyB = bodyB;
                    cc.Manifold = manifold.$clone();
                    cc.Normal = Microsoft.Xna.Framework.Vector2.Zero.$clone();
                    cc.PointCount = manifold.PointCount;

                    cc.LocalNormal = manifold.LocalNormal.$clone();
                    cc.LocalPoint = manifold.LocalPoint.$clone();
                    cc.RadiusA = radiusA;
                    cc.RadiusB = radiusB;
                    cc.Type = manifold.Type;

                    for (var j = 0; j < cc.PointCount; j = (j + 1) | 0) {
                        var cp = manifold.Points.getItem(j).$clone();
                        var ccp = cc.Points[System.Array.index(j, cc.Points)];

                        if (warmstarting) {
                            ccp.NormalImpulse = impulseRatio * cp.NormalImpulse;
                            ccp.TangentImpulse = impulseRatio * cp.TangentImpulse;
                        } else {
                            ccp.NormalImpulse = 0.0;
                            ccp.TangentImpulse = 0.0;
                        }

                        ccp.LocalPoint = cp.LocalPoint.$clone();
                        ccp.rA = Microsoft.Xna.Framework.Vector2.Zero.$clone();
                        ccp.rB = Microsoft.Xna.Framework.Vector2.Zero.$clone();
                        ccp.NormalMass = 0.0;
                        ccp.TangentMass = 0.0;
                        ccp.VelocityBias = 0.0;
                    }

                    cc.K.SetZero();
                    cc.NormalMass.SetZero();
                }
            },
            InitializeVelocityConstraints: function () {
                for (var i = 0; i < this._constraintCount; i = (i + 1) | 0) {
                    var cc = this.Constraints[System.Array.index(i, this.Constraints)];

                    var radiusA = cc.RadiusA;
                    var radiusB = cc.RadiusB;
                    var bodyA = cc.BodyA;
                    var bodyB = cc.BodyB;
                    var manifold = { v : cc.Manifold.$clone() };

                    var vA = bodyA.LinearVelocity.$clone();
                    var vB = bodyB.LinearVelocity.$clone();
                    var wA = bodyA.AngularVelocity;
                    var wB = bodyB.AngularVelocity;

                    System.Diagnostics.Debug.Assert(manifold.v.PointCount > 0);
                    var points = { v : new (FarseerPhysics.Common.FixedArray2$1(Microsoft.Xna.Framework.Vector2))() };

                    FarseerPhysics.Collision.Collision.GetWorldManifold(manifold, Bridge.ref(bodyA, "Xf"), radiusA, Bridge.ref(bodyB, "Xf"), radiusB, Bridge.ref(cc, "Normal"), points);
                    var tangent = new Microsoft.Xna.Framework.Vector2.$ctor2(cc.Normal.Y, -cc.Normal.X);

                    for (var j = 0; j < cc.PointCount; j = (j + 1) | 0) {
                        var ccp = cc.Points[System.Array.index(j, cc.Points)];

                        ccp.rA = Microsoft.Xna.Framework.Vector2.op_Subtraction(points.v.getItem(j).$clone(), bodyA.Sweep.C.$clone());
                        ccp.rB = Microsoft.Xna.Framework.Vector2.op_Subtraction(points.v.getItem(j).$clone(), bodyB.Sweep.C.$clone());

                        var rnA = ccp.rA.X * cc.Normal.Y - ccp.rA.Y * cc.Normal.X;
                        var rnB = ccp.rB.X * cc.Normal.Y - ccp.rB.Y * cc.Normal.X;
                        rnA *= rnA;
                        rnB *= rnB;

                        var kNormal = bodyA.InvMass + bodyB.InvMass + bodyA.InvI * rnA + bodyB.InvI * rnB;

                        System.Diagnostics.Debug.Assert(kNormal > FarseerPhysics.Settings.Epsilon);
                        ccp.NormalMass = 1.0 / kNormal;

                        var rtA = ccp.rA.X * tangent.Y - ccp.rA.Y * tangent.X;
                        var rtB = ccp.rB.X * tangent.Y - ccp.rB.Y * tangent.X;

                        rtA *= rtA;
                        rtB *= rtB;
                        var kTangent = bodyA.InvMass + bodyB.InvMass + bodyA.InvI * rtA + bodyB.InvI * rtB;

                        System.Diagnostics.Debug.Assert(kTangent > FarseerPhysics.Settings.Epsilon);
                        ccp.TangentMass = 1.0 / kTangent;

                        ccp.VelocityBias = 0.0;
                        var vRel = cc.Normal.X * (vB.X + -wB * ccp.rB.Y - vA.X - -wA * ccp.rA.Y) + cc.Normal.Y * (vB.Y + wB * ccp.rB.X - vA.Y - wA * ccp.rA.X);
                        if (vRel < -1.0) {
                            ccp.VelocityBias = -cc.Restitution * vRel;
                        }
                    }

                    if (cc.PointCount === 2) {
                        var ccp1 = cc.Points[System.Array.index(0, cc.Points)];
                        var ccp2 = cc.Points[System.Array.index(1, cc.Points)];

                        var invMassA = bodyA.InvMass;
                        var invIA = bodyA.InvI;
                        var invMassB = bodyB.InvMass;
                        var invIB = bodyB.InvI;

                        var rn1A = ccp1.rA.X * cc.Normal.Y - ccp1.rA.Y * cc.Normal.X;
                        var rn1B = ccp1.rB.X * cc.Normal.Y - ccp1.rB.Y * cc.Normal.X;
                        var rn2A = ccp2.rA.X * cc.Normal.Y - ccp2.rA.Y * cc.Normal.X;
                        var rn2B = ccp2.rB.X * cc.Normal.Y - ccp2.rB.Y * cc.Normal.X;

                        var k11 = invMassA + invMassB + invIA * rn1A * rn1A + invIB * rn1B * rn1B;
                        var k22 = invMassA + invMassB + invIA * rn2A * rn2A + invIB * rn2B * rn2B;
                        var k12 = invMassA + invMassB + invIA * rn1A * rn2A + invIB * rn1B * rn2B;

                        var k_maxConditionNumber = 100.0;
                        if (k11 * k11 < k_maxConditionNumber * (k11 * k22 - k12 * k12)) {
                            cc.K.Col1.X = k11;
                            cc.K.Col1.Y = k12;
                            cc.K.Col2.X = k12;
                            cc.K.Col2.Y = k22;

                            var a = cc.K.Col1.X, b = cc.K.Col2.X, c = cc.K.Col1.Y, d = cc.K.Col2.Y;
                            var det = a * d - b * c;
                            if (det !== 0.0) {
                                det = 1.0 / det;
                            }

                            cc.NormalMass.Col1.X = det * d;
                            cc.NormalMass.Col1.Y = -det * c;
                            cc.NormalMass.Col2.X = -det * b;
                            cc.NormalMass.Col2.Y = det * a;
                        } else {
                            cc.PointCount = 1;
                        }
                    }
                }
            },
            WarmStart: function () {
                for (var i = 0; i < this._constraintCount; i = (i + 1) | 0) {
                    var c = this.Constraints[System.Array.index(i, this.Constraints)];

                    var tangentx = c.Normal.Y;
                    var tangenty = -c.Normal.X;

                    for (var j = 0; j < c.PointCount; j = (j + 1) | 0) {
                        var ccp = c.Points[System.Array.index(j, c.Points)];
                        var px = ccp.NormalImpulse * c.Normal.X + ccp.TangentImpulse * tangentx;
                        var py = ccp.NormalImpulse * c.Normal.Y + ccp.TangentImpulse * tangenty;
                        c.BodyA.AngularVelocityInternal -= c.BodyA.InvI * (ccp.rA.X * py - ccp.rA.Y * px);
                        c.BodyA.LinearVelocityInternal.X -= c.BodyA.InvMass * px;
                        c.BodyA.LinearVelocityInternal.Y -= c.BodyA.InvMass * py;
                        c.BodyB.AngularVelocityInternal += c.BodyB.InvI * (ccp.rB.X * py - ccp.rB.Y * px);
                        c.BodyB.LinearVelocityInternal.X += c.BodyB.InvMass * px;
                        c.BodyB.LinearVelocityInternal.Y += c.BodyB.InvMass * py;
                    }
                }
            },
            SolveVelocityConstraints: function () {
                for (var i = 0; i < this._constraintCount; i = (i + 1) | 0) {
                    var c = this.Constraints[System.Array.index(i, this.Constraints)];
                    if (c.BodyA.Penetrable || c.BodyB.Penetrable) {
                        continue;
                    }
                    var wA = c.BodyA.AngularVelocityInternal;
                    var wB = c.BodyB.AngularVelocityInternal;

                    var tangentx = c.Normal.Y;
                    var tangenty = -c.Normal.X;

                    var friction = c.Friction;

                    System.Diagnostics.Debug.Assert(c.PointCount === 1 || c.PointCount === 2);

                    for (var j = 0; j < c.PointCount; j = (j + 1) | 0) {
                        var ccp = c.Points[System.Array.index(j, c.Points)];
                        var lambda = ccp.TangentMass * -((c.BodyB.LinearVelocityInternal.X + (-wB * ccp.rB.Y) - c.BodyA.LinearVelocityInternal.X - (-wA * ccp.rA.Y)) * tangentx + (c.BodyB.LinearVelocityInternal.Y + (wB * ccp.rB.X) - c.BodyA.LinearVelocityInternal.Y - (wA * ccp.rA.X)) * tangenty);

                        var maxFriction = friction * ccp.NormalImpulse;
                        var newImpulse = Math.max(-maxFriction, Math.min(ccp.TangentImpulse + lambda, maxFriction));
                        lambda = newImpulse - ccp.TangentImpulse;

                        var px = lambda * tangentx;
                        var py = lambda * tangenty;

                        c.BodyA.LinearVelocityInternal.X -= c.BodyA.InvMass * px;
                        c.BodyA.LinearVelocityInternal.Y -= c.BodyA.InvMass * py;
                        wA -= c.BodyA.InvI * (ccp.rA.X * py - ccp.rA.Y * px);

                        c.BodyB.LinearVelocityInternal.X += c.BodyB.InvMass * px;
                        c.BodyB.LinearVelocityInternal.Y += c.BodyB.InvMass * py;
                        wB += c.BodyB.InvI * (ccp.rB.X * py - ccp.rB.Y * px);

                        ccp.TangentImpulse = newImpulse;
                    }

                    if (c.PointCount === 1) {
                        var ccp1 = c.Points[System.Array.index(0, c.Points)];

                        var lambda1 = -ccp1.NormalMass * ((c.BodyB.LinearVelocityInternal.X + (-wB * ccp1.rB.Y) - c.BodyA.LinearVelocityInternal.X - (-wA * ccp1.rA.Y)) * c.Normal.X + (c.BodyB.LinearVelocityInternal.Y + (wB * ccp1.rB.X) - c.BodyA.LinearVelocityInternal.Y - (wA * ccp1.rA.X)) * c.Normal.Y - ccp1.VelocityBias);

                        var newImpulse1 = Math.max(ccp1.NormalImpulse + lambda1, 0.0);
                        lambda1 = newImpulse1 - ccp1.NormalImpulse;

                        var px1 = lambda1 * c.Normal.X;
                        var py1 = lambda1 * c.Normal.Y;

                        c.BodyA.LinearVelocityInternal.X -= c.BodyA.InvMass * px1;
                        c.BodyA.LinearVelocityInternal.Y -= c.BodyA.InvMass * py1;
                        wA -= c.BodyA.InvI * (ccp1.rA.X * py1 - ccp1.rA.Y * px1);

                        c.BodyB.LinearVelocityInternal.X += c.BodyB.InvMass * px1;
                        c.BodyB.LinearVelocityInternal.Y += c.BodyB.InvMass * py1;
                        wB += c.BodyB.InvI * (ccp1.rB.X * py1 - ccp1.rB.Y * px1);

                        ccp1.NormalImpulse = newImpulse1;
                    } else {

                        var cp1 = c.Points[System.Array.index(0, c.Points)];
                        var cp2 = c.Points[System.Array.index(1, c.Points)];

                        var ax = cp1.NormalImpulse;
                        var ay = cp2.NormalImpulse;
                        System.Diagnostics.Debug.Assert(ax >= 0.0 && ay >= 0.0);

                        var vn1 = (c.BodyB.LinearVelocityInternal.X + (-wB * cp1.rB.Y) - c.BodyA.LinearVelocityInternal.X - (-wA * cp1.rA.Y)) * c.Normal.X + (c.BodyB.LinearVelocityInternal.Y + (wB * cp1.rB.X) - c.BodyA.LinearVelocityInternal.Y - (wA * cp1.rA.X)) * c.Normal.Y;
                        var vn2 = (c.BodyB.LinearVelocityInternal.X + (-wB * cp2.rB.Y) - c.BodyA.LinearVelocityInternal.X - (-wA * cp2.rA.Y)) * c.Normal.X + (c.BodyB.LinearVelocityInternal.Y + (wB * cp2.rB.X) - c.BodyA.LinearVelocityInternal.Y - (wA * cp2.rA.X)) * c.Normal.Y;

                        var bx = vn1 - cp1.VelocityBias - (c.K.Col1.X * ax + c.K.Col2.X * ay);
                        var by = vn2 - cp2.VelocityBias - (c.K.Col1.Y * ax + c.K.Col2.Y * ay);

                        var xx = -(c.NormalMass.Col1.X * bx + c.NormalMass.Col2.X * by);
                        var xy = -(c.NormalMass.Col1.Y * bx + c.NormalMass.Col2.Y * by);

                        while (true) {
                            if (xx >= 0.0 && xy >= 0.0) {
                                var dx = xx - ax;
                                var dy = xy - ay;

                                var p1x = dx * c.Normal.X;
                                var p1y = dx * c.Normal.Y;

                                var p2x = dy * c.Normal.X;
                                var p2y = dy * c.Normal.Y;

                                var p12x = p1x + p2x;
                                var p12y = p1y + p2y;

                                c.BodyA.LinearVelocityInternal.X -= c.BodyA.InvMass * p12x;
                                c.BodyA.LinearVelocityInternal.Y -= c.BodyA.InvMass * p12y;
                                wA -= c.BodyA.InvI * ((cp1.rA.X * p1y - cp1.rA.Y * p1x) + (cp2.rA.X * p2y - cp2.rA.Y * p2x));

                                c.BodyB.LinearVelocityInternal.X += c.BodyB.InvMass * p12x;
                                c.BodyB.LinearVelocityInternal.Y += c.BodyB.InvMass * p12y;
                                wB += c.BodyB.InvI * ((cp1.rB.X * p1y - cp1.rB.Y * p1x) + (cp2.rB.X * p2y - cp2.rB.Y * p2x));

                                cp1.NormalImpulse = xx;
                                cp2.NormalImpulse = xy;

                                break;
                            }

                            xx = -cp1.NormalMass * bx;
                            xy = 0.0;
                            vn1 = 0.0;
                            vn2 = c.K.Col1.Y * xx + by;

                            if (xx >= 0.0 && vn2 >= 0.0) {
                                var dx1 = xx - ax;
                                var dy1 = xy - ay;

                                var p1x1 = dx1 * c.Normal.X;
                                var p1y1 = dx1 * c.Normal.Y;

                                var p2x1 = dy1 * c.Normal.X;
                                var p2y1 = dy1 * c.Normal.Y;

                                var p12x1 = p1x1 + p2x1;
                                var p12y1 = p1y1 + p2y1;

                                c.BodyA.LinearVelocityInternal.X -= c.BodyA.InvMass * p12x1;
                                c.BodyA.LinearVelocityInternal.Y -= c.BodyA.InvMass * p12y1;
                                wA -= c.BodyA.InvI * ((cp1.rA.X * p1y1 - cp1.rA.Y * p1x1) + (cp2.rA.X * p2y1 - cp2.rA.Y * p2x1));

                                c.BodyB.LinearVelocityInternal.X += c.BodyB.InvMass * p12x1;
                                c.BodyB.LinearVelocityInternal.Y += c.BodyB.InvMass * p12y1;
                                wB += c.BodyB.InvI * ((cp1.rB.X * p1y1 - cp1.rB.Y * p1x1) + (cp2.rB.X * p2y1 - cp2.rB.Y * p2x1));

                                cp1.NormalImpulse = xx;
                                cp2.NormalImpulse = xy;

                                break;
                            }


                            xx = 0.0;
                            xy = -cp2.NormalMass * by;
                            vn1 = c.K.Col2.X * xy + bx;
                            vn2 = 0.0;

                            if (xy >= 0.0 && vn1 >= 0.0) {
                                var dx2 = xx - ax;
                                var dy2 = xy - ay;

                                var p1x2 = dx2 * c.Normal.X;
                                var p1y2 = dx2 * c.Normal.Y;

                                var p2x2 = dy2 * c.Normal.X;
                                var p2y2 = dy2 * c.Normal.Y;

                                var p12x2 = p1x2 + p2x2;
                                var p12y2 = p1y2 + p2y2;

                                c.BodyA.LinearVelocityInternal.X -= c.BodyA.InvMass * p12x2;
                                c.BodyA.LinearVelocityInternal.Y -= c.BodyA.InvMass * p12y2;
                                wA -= c.BodyA.InvI * ((cp1.rA.X * p1y2 - cp1.rA.Y * p1x2) + (cp2.rA.X * p2y2 - cp2.rA.Y * p2x2));

                                c.BodyB.LinearVelocityInternal.X += c.BodyB.InvMass * p12x2;
                                c.BodyB.LinearVelocityInternal.Y += c.BodyB.InvMass * p12y2;
                                wB += c.BodyB.InvI * ((cp1.rB.X * p1y2 - cp1.rB.Y * p1x2) + (cp2.rB.X * p2y2 - cp2.rB.Y * p2x2));

                                cp1.NormalImpulse = xx;
                                cp2.NormalImpulse = xy;

                                break;
                            }

                            xx = 0.0;
                            xy = 0.0;
                            vn1 = bx;
                            vn2 = by;

                            if (vn1 >= 0.0 && vn2 >= 0.0) {
                                var dx3 = xx - ax;
                                var dy3 = xy - ay;

                                var p1x3 = dx3 * c.Normal.X;
                                var p1y3 = dx3 * c.Normal.Y;

                                var p2x3 = dy3 * c.Normal.X;
                                var p2y3 = dy3 * c.Normal.Y;

                                var p12x3 = p1x3 + p2x3;
                                var p12y3 = p1y3 + p2y3;

                                c.BodyA.LinearVelocityInternal.X -= c.BodyA.InvMass * p12x3;
                                c.BodyA.LinearVelocityInternal.Y -= c.BodyA.InvMass * p12y3;
                                wA -= c.BodyA.InvI * ((cp1.rA.X * p1y3 - cp1.rA.Y * p1x3) + (cp2.rA.X * p2y3 - cp2.rA.Y * p2x3));

                                c.BodyB.LinearVelocityInternal.X += c.BodyB.InvMass * p12x3;
                                c.BodyB.LinearVelocityInternal.Y += c.BodyB.InvMass * p12y3;
                                wB += c.BodyB.InvI * ((cp1.rB.X * p1y3 - cp1.rB.Y * p1x3) + (cp2.rB.X * p2y3 - cp2.rB.Y * p2x3));

                                cp1.NormalImpulse = xx;
                                cp2.NormalImpulse = xy;

                                break;
                            }

                            break;
                        }
                    }

                    c.BodyA.AngularVelocityInternal = wA;
                    c.BodyB.AngularVelocityInternal = wB;
                }
            },
            StoreImpulses: function () {
                for (var i = 0; i < this._constraintCount; i = (i + 1) | 0) {
                    var c = this.Constraints[System.Array.index(i, this.Constraints)];
                    if (c.BodyA.Penetrable || c.BodyB.Penetrable) {
                        continue;
                    }

                    var m = c.Manifold.$clone();

                    for (var j = 0; j < c.PointCount; j = (j + 1) | 0) {
                        var pj = m.Points.getItem(j).$clone();
                        var cp = c.Points[System.Array.index(j, c.Points)];

                        pj.NormalImpulse = cp.NormalImpulse;
                        pj.TangentImpulse = cp.TangentImpulse;

                        m.Points.setItem(j, pj.$clone());
                    }

                    c.Manifold = m.$clone();
                    this._contacts[System.Array.index(i, this._contacts)].Manifold = m.$clone();
                }
            },
            SolvePositionConstraints: function (baumgarte) {
                var minSeparation = 0.0;

                for (var i = 0; i < this._constraintCount; i = (i + 1) | 0) {
                    var c = this.Constraints[System.Array.index(i, this.Constraints)];
                    if (c.BodyA.Penetrable || c.BodyB.Penetrable) {
                        continue;
                    }

                    var bodyA = c.BodyA;
                    var bodyB = c.BodyB;

                    var invMassA = bodyA.Mass * bodyA.InvMass;
                    var invIA = bodyA.Mass * bodyA.InvI;
                    var invMassB = bodyB.Mass * bodyB.InvMass;
                    var invIB = bodyB.Mass * bodyB.InvI;

                    for (var j = 0; j < c.PointCount; j = (j + 1) | 0) {
                        var normal = { v : new Microsoft.Xna.Framework.Vector2() };
                        var point = { v : new Microsoft.Xna.Framework.Vector2() };
                        var separation = { };

                        FarseerPhysics.Dynamics.Contacts.ContactSolver.Solve(c, j, normal, point, separation);

                        var rax = point.v.X - bodyA.Sweep.C.X;
                        var ray = point.v.Y - bodyA.Sweep.C.Y;

                        var rbx = point.v.X - bodyB.Sweep.C.X;
                        var rby = point.v.Y - bodyB.Sweep.C.Y;

                        minSeparation = Math.min(minSeparation, separation.v);

                        var C = Math.max(-0.2, Math.min(baumgarte * (separation.v + FarseerPhysics.Settings.LinearSlop), 0.0));

                        var rnA = rax * normal.v.Y - ray * normal.v.X;
                        var rnB = rbx * normal.v.Y - rby * normal.v.X;
                        var K = invMassA + invMassB + invIA * rnA * rnA + invIB * rnB * rnB;

                        var impulse = K > 0.0 ? -C / K : 0.0;

                        var px = impulse * normal.v.X;
                        var py = impulse * normal.v.Y;

                        bodyA.Sweep.C.X -= invMassA * px;
                        bodyA.Sweep.C.Y -= invMassA * py;
                        bodyA.Sweep.A -= invIA * (rax * py - ray * px);

                        bodyB.Sweep.C.X += invMassB * px;
                        bodyB.Sweep.C.Y += invMassB * py;
                        bodyB.Sweep.A += invIB * (rbx * py - rby * px);

                        bodyA.SynchronizeTransform();
                        bodyB.SynchronizeTransform();
                    }
                }

                return minSeparation >= -0.0075;
            }
        }
    });

    /**
     * @memberof FarseerPhysics.Dynamics
     * @callback FarseerPhysics.Dynamics.OnSeparationEventHandler
     * @param   {FarseerPhysics.Dynamics.Fixture}    fixtureA    
     * @param   {FarseerPhysics.Dynamics.Fixture}    fixtureB
     * @return  {void}
     */

    /**
     * @memberof FarseerPhysics.Dynamics
     * @callback FarseerPhysics.Dynamics.OnCollisionEventHandler
     * @param   {FarseerPhysics.Dynamics.Fixture}             fixtureA    
     * @param   {FarseerPhysics.Dynamics.Fixture}             fixtureB    
     * @param   {FarseerPhysics.Dynamics.Contacts.Contact}    contact
     * @return  {boolean}
     */

    /**
     * @memberof FarseerPhysics.Dynamics
     * @callback FarseerPhysics.Dynamics.BeforeCollisionEventHandler
     * @param   {FarseerPhysics.Dynamics.Fixture}    fixtureA    
     * @param   {FarseerPhysics.Dynamics.Fixture}    fixtureB
     * @return  {boolean}
     */

    /**
     * @memberof FarseerPhysics.Dynamics
     * @callback FarseerPhysics.Dynamics.AfterCollisionEventHandler
     * @param   {FarseerPhysics.Dynamics.Fixture}             fixtureA    
     * @param   {FarseerPhysics.Dynamics.Fixture}             fixtureB    
     * @param   {FarseerPhysics.Dynamics.Contacts.Contact}    contact
     * @return  {void}
     */

    /**
     * A fixture is used to attach a Shape to a body for collision detection. A fixture
     inherits its transform from its parent. Fixtures hold additional non-geometric data
     such as friction, collision filters, etc.
     Fixtures are created via Body.CreateFixture.
     Warning: You cannot reuse fixtures.
     *
     * @public
     * @class FarseerPhysics.Dynamics.Fixture
     * @implements  System.IDisposable
     */
    Bridge.define("FarseerPhysics.Dynamics.Fixture", {
        inherits: [System.IDisposable],
        statics: {
            fields: {
                _fixtureIdCounter: 0
            }
        },
        fields: {
            /**
             * Fires after two shapes has collided and are solved. This gives you a chance to get the impact force.
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Dynamics.Fixture
             * @type FarseerPhysics.Dynamics.AfterCollisionEventHandler
             */
            AfterCollision: null,
            /**
             * Fires when two fixtures are close to each other.
             Due to how the broadphase works, this can be quite inaccurate as shapes are approximated using AABBs.
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Dynamics.Fixture
             * @type FarseerPhysics.Dynamics.BeforeCollisionEventHandler
             */
            BeforeCollision: null,
            /**
             * Fires when two shapes collide and a contact is created between them.
             Note that the first fixture argument is always the fixture that the delegate is subscribed to.
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Dynamics.Fixture
             * @type FarseerPhysics.Dynamics.OnCollisionEventHandler
             */
            OnCollision: null,
            /**
             * Fires when two shapes separate and a contact is removed between them.
             Note that the first fixture argument is always the fixture that the delegate is subscribed to.
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Dynamics.Fixture
             * @type FarseerPhysics.Dynamics.OnSeparationEventHandler
             */
            OnSeparation: null,
            Proxies: null,
            ProxyCount: 0,
            _collidesWith: 0,
            _collisionCategories: 0,
            _collisionGroup: 0,
            _collisionIgnores: null,
            _friction: 0,
            _restitution: 0,
            /**
             * Get the child Shape. You can modify the child Shape, however you should not change the
             number of vertices because this will crash some collision caching mechanisms.
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Dynamics.Fixture
             * @function Shape
             * @type FarseerPhysics.Collision.Shapes.Shape
             */
            Shape: null,
            /**
             * Gets or sets a value indicating whether this fixture is a sensor.
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Dynamics.Fixture
             * @function IsSensor
             * @type boolean
             */
            IsSensor: false,
            /**
             * Get the parent body of this fixture. This is null if the fixture is not attached.
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Dynamics.Fixture
             * @function Body
             * @type FarseerPhysics.Dynamics.Body
             */
            Body: null,
            /**
             * Set the user data. Use this to store your application specific data.
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Dynamics.Fixture
             * @function UserData
             * @type System.Object
             */
            UserData: null,
            /**
             * Gets a unique ID for this fixture.
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Dynamics.Fixture
             * @function FixtureId
             * @type number
             */
            FixtureId: 0,
            IsDisposed: false
        },
        props: {
            /**
             * Defaults to 0
             If Settings.UseFPECollisionCategories is set to false:
             Collision groups allow a certain group of objects to never collide (negative)
             or always collide (positive). Zero means no collision group. Non-zero group
             filtering always wins against the mask bits.
             If Settings.UseFPECollisionCategories is set to true:
             If 2 fixtures are in the same collision group, they will not collide.
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Dynamics.Fixture
             * @function CollisionGroup
             * @type number
             */
            CollisionGroup: {
                get: function () {
                    return this._collisionGroup;
                },
                set: function (value) {
                    if (this._collisionGroup === value) {
                        return;
                    }

                    this._collisionGroup = value;
                    this.Refilter();
                }
            },
            /**
             * Defaults to Category.All
             The collision mask bits. This states the categories that this
             fixture would accept for collision.
             Use Settings.UseFPECollisionCategories to change the behavior.
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Dynamics.Fixture
             * @function CollidesWith
             * @type FarseerPhysics.Dynamics.Category
             */
            CollidesWith: {
                get: function () {
                    return this._collidesWith;
                },
                set: function (value) {
                    if (this._collidesWith === value) {
                        return;
                    }

                    this._collidesWith = value;
                    this.Refilter();
                }
            },
            /**
             * The collision categories this fixture is a part of.
             If Settings.UseFPECollisionCategories is set to false:
             Defaults to Category.Cat1
             If Settings.UseFPECollisionCategories is set to true:
             Defaults to Category.All
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Dynamics.Fixture
             * @function CollisionCategories
             * @type FarseerPhysics.Dynamics.Category
             */
            CollisionCategories: {
                get: function () {
                    return this._collisionCategories;
                },
                set: function (value) {
                    if (this._collisionCategories === value) {
                        return;
                    }

                    this._collisionCategories = value;
                    this.Refilter();
                }
            },
            /**
             * Get the type of the child Shape. You can use this to down cast to the concrete Shape.
             *
             * @instance
             * @public
             * @readonly
             * @memberof FarseerPhysics.Dynamics.Fixture
             * @function ShapeType
             * @type FarseerPhysics.Collision.Shapes.ShapeType
             */
            ShapeType: {
                get: function () {
                    return this.Shape.ShapeType;
                }
            },
            /**
             * Get or set the coefficient of friction.
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Dynamics.Fixture
             * @function Friction
             * @type number
             */
            Friction: {
                get: function () {
                    return this._friction;
                },
                set: function (value) {
                    System.Diagnostics.Debug.Assert(!isNaN(value));

                    this._friction = value;
                }
            },
            /**
             * Get or set the coefficient of restitution.
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Dynamics.Fixture
             * @function Restitution
             * @type number
             */
            Restitution: {
                get: function () {
                    return this._restitution;
                },
                set: function (value) {
                    System.Diagnostics.Debug.Assert(!isNaN(value));

                    this._restitution = value;
                }
            }
        },
        alias: ["Dispose", "System$IDisposable$Dispose"],
        ctors: {
            ctor: function () {
                this.$initialize();
            },
            $ctor1: function (body, shape) {
                FarseerPhysics.Dynamics.Fixture.$ctor2.call(this, body, shape, null);
            },
            $ctor2: function (body, shape, userData) {
                this.$initialize();
                if (FarseerPhysics.Settings.UseFPECollisionCategories) {
                    this._collisionCategories = FarseerPhysics.Dynamics.Category.All;
                } else {
                    this._collisionCategories = FarseerPhysics.Dynamics.Category.Cat1;
                }

                this._collidesWith = FarseerPhysics.Dynamics.Category.All;
                this._collisionGroup = 0;

                this.Friction = 0.2;
                this.Restitution = 0;

                this.IsSensor = false;

                this.Body = body;
                this.UserData = userData;

                if (FarseerPhysics.Settings.ConserveMemory) {
                    this.Shape = shape;
                } else {
                    this.Shape = shape.Clone();
                }

                this.RegisterFixture();
            }
        },
        methods: {
            Dispose: function () {
                if (!this.IsDisposed) {
                    this.Body.DestroyFixture(this);
                    this.IsDisposed = true;
                }
            },
            /**
             * Restores collisions between this fixture and the provided fixture.
             *
             * @instance
             * @public
             * @this FarseerPhysics.Dynamics.Fixture
             * @memberof FarseerPhysics.Dynamics.Fixture
             * @param   {FarseerPhysics.Dynamics.Fixture}    fixture    The fixture.
             * @return  {void}
             */
            RestoreCollisionWith: function (fixture) {
                if (this._collisionIgnores == null) {
                    return;
                }

                if (this._collisionIgnores.containsKey(fixture.FixtureId)) {
                    this._collisionIgnores.set(fixture.FixtureId, false);
                    this.Refilter();
                }
            },
            /**
             * Ignores collisions between this fixture and the provided fixture.
             *
             * @instance
             * @public
             * @this FarseerPhysics.Dynamics.Fixture
             * @memberof FarseerPhysics.Dynamics.Fixture
             * @param   {FarseerPhysics.Dynamics.Fixture}    fixture    The fixture.
             * @return  {void}
             */
            IgnoreCollisionWith: function (fixture) {
                if (this._collisionIgnores == null) {
                    this._collisionIgnores = new (System.Collections.Generic.Dictionary$2(System.Int32,System.Boolean))();
                }

                if (this._collisionIgnores.containsKey(fixture.FixtureId)) {
                    this._collisionIgnores.set(fixture.FixtureId, true);
                } else {
                    this._collisionIgnores.add(fixture.FixtureId, true);
                }

                this.Refilter();
            },
            /**
             * Determines whether collisions are ignored between this fixture and the provided fixture.
             *
             * @instance
             * @public
             * @this FarseerPhysics.Dynamics.Fixture
             * @memberof FarseerPhysics.Dynamics.Fixture
             * @param   {FarseerPhysics.Dynamics.Fixture}    fixture    The fixture.
             * @return  {boolean}                                       <pre><code>true</code></pre> if the fixture is ignored; otherwise, <pre><code>false</code></pre>.
             */
            IsFixtureIgnored: function (fixture) {
                if (this._collisionIgnores == null) {
                    return false;
                }

                if (this._collisionIgnores.containsKey(fixture.FixtureId)) {
                    return this._collisionIgnores.get(fixture.FixtureId);
                }

                return false;
            },
            /**
             * Contacts are persistant and will keep being persistant unless they are
             flagged for filtering.
             This methods flags all contacts associated with the body for filtering.
             *
             * @instance
             * @this FarseerPhysics.Dynamics.Fixture
             * @memberof FarseerPhysics.Dynamics.Fixture
             * @return  {void}
             */
            Refilter: function () {
                var edge = this.Body.ContactList;
                while (edge != null) {
                    var contact = edge.Contact;
                    var fixtureA = contact.FixtureA;
                    var fixtureB = contact.FixtureB;
                    if (Bridge.referenceEquals(fixtureA, this) || Bridge.referenceEquals(fixtureB, this)) {
                        contact.FlagForFiltering();
                    }

                    edge = edge.Next;
                }

                var world = this.Body.World;

                if (world == null) {
                    return;
                }

                var broadPhase = world.ContactManager.BroadPhase;
                for (var i = 0; i < this.ProxyCount; i = (i + 1) | 0) {
                    broadPhase.FarseerPhysics$Collision$IBroadPhase$TouchProxy(this.Proxies[System.Array.index(i, this.Proxies)].ProxyId);
                }
            },
            RegisterFixture: function () {
                var $t;
                this.Proxies = System.Array.init(this.Shape.ChildCount, function (){
                    return new FarseerPhysics.Dynamics.FixtureProxy();
                }, FarseerPhysics.Dynamics.FixtureProxy);
                this.ProxyCount = 0;

                this.FixtureId = Bridge.identity(FarseerPhysics.Dynamics.Fixture._fixtureIdCounter, ($t = (FarseerPhysics.Dynamics.Fixture._fixtureIdCounter + 1) | 0, FarseerPhysics.Dynamics.Fixture._fixtureIdCounter = $t, $t));

                if ((this.Body.Flags & FarseerPhysics.Dynamics.BodyFlags.Enabled) === FarseerPhysics.Dynamics.BodyFlags.Enabled) {
                    var broadPhase = this.Body.World.ContactManager.BroadPhase;
                    this.CreateProxies(broadPhase, Bridge.ref(this.Body, "Xf"));
                }

                this.Body.FixtureList.add(this);

                if (this.Shape._density > 0.0) {
                    this.Body.ResetMassData();
                }

                this.Body.World.Flags |= FarseerPhysics.Dynamics.WorldFlags.NewFixture;

                if (!Bridge.staticEquals(this.Body.World.FixtureAdded, null)) {
                    this.Body.World.FixtureAdded(this);
                }
            },
            /**
             * Test a point for containment in this fixture.
             *
             * @instance
             * @public
             * @this FarseerPhysics.Dynamics.Fixture
             * @memberof FarseerPhysics.Dynamics.Fixture
             * @param   {Microsoft.Xna.Framework.Vector2}    point    A point in world coordinates.
             * @return  {boolean}
             */
            TestPoint: function (point) {
                return this.Shape.TestPoint(Bridge.ref(this.Body, "Xf"), point);
            },
            /**
             * Cast a ray against this Shape.
             *
             * @instance
             * @public
             * @this FarseerPhysics.Dynamics.Fixture
             * @memberof FarseerPhysics.Dynamics.Fixture
             * @param   {FarseerPhysics.Collision.RayCastOutput}    output        The ray-cast results.
             * @param   {FarseerPhysics.Collision.RayCastInput}     input         The ray-cast input parameters.
             * @param   {number}                                    childIndex    Index of the child.
             * @return  {boolean}
             */
            RayCast: function (output, input, childIndex) {
                return this.Shape.RayCast(output, input, Bridge.ref(this.Body, "Xf"), childIndex);
            },
            /**
             * Get the fixture's AABB. This AABB may be enlarge and/or stale.
             If you need a more accurate AABB, compute it using the Shape and
             the body transform.
             *
             * @instance
             * @public
             * @this FarseerPhysics.Dynamics.Fixture
             * @memberof FarseerPhysics.Dynamics.Fixture
             * @param   {FarseerPhysics.Collision.AABB}    aabb          The aabb.
             * @param   {number}                           childIndex    Index of the child.
             * @return  {void}
             */
            GetAABB: function (aabb, childIndex) {
                System.Diagnostics.Debug.Assert(0 <= childIndex && childIndex < this.ProxyCount);
                aabb.v = this.Proxies[System.Array.index(childIndex, this.Proxies)].AABB.$clone();
            },
            Clone: function (body) {
                var $t;
                var fixture = new FarseerPhysics.Dynamics.Fixture.ctor();
                fixture.Body = body;

                if (FarseerPhysics.Settings.ConserveMemory) {
                    fixture.Shape = this.Shape;
                } else {
                    fixture.Shape = this.Shape.Clone();
                }

                fixture.UserData = this.UserData;
                fixture.Restitution = this.Restitution;
                fixture.Friction = this.Friction;
                fixture.IsSensor = this.IsSensor;
                fixture._collisionGroup = this.CollisionGroup;
                fixture._collisionCategories = this.CollisionCategories;
                fixture._collidesWith = this.CollidesWith;

                if (this._collisionIgnores != null) {
                    fixture._collisionIgnores = new (System.Collections.Generic.Dictionary$2(System.Int32,System.Boolean))();

                    $t = Bridge.getEnumerator(this._collisionIgnores);
                    try {
                        while ($t.moveNext()) {
                            var pair = $t.Current;
                            fixture._collisionIgnores.add(pair.key, pair.value);
                        }
                    } finally {
                        if (Bridge.is($t, System.IDisposable)) {
                            $t.System$IDisposable$Dispose();
                        }
                    }}

                fixture.RegisterFixture();
                return fixture;
            },
            DeepClone: function () {
                var fix = this.Clone(this.Body.Clone());
                return fix;
            },
            Destroy: function () {
                System.Diagnostics.Debug.Assert(this.ProxyCount === 0);

                this.Proxies = null;
                this.Shape = null;

                this.BeforeCollision = null;
                this.OnCollision = null;
                this.OnSeparation = null;
                this.AfterCollision = null;

                if (!Bridge.staticEquals(this.Body.World.FixtureRemoved, null)) {
                    this.Body.World.FixtureRemoved(this);
                }

                this.Body.World.FixtureAdded = null;
                this.Body.World.FixtureRemoved = null;
                this.OnSeparation = null;
                this.OnCollision = null;
            },
            CreateProxies: function (broadPhase, xf) {
                System.Diagnostics.Debug.Assert(this.ProxyCount === 0);

                this.ProxyCount = this.Shape.ChildCount;

                for (var i = 0; i < this.ProxyCount; i = (i + 1) | 0) {
                    var proxy = { v : new FarseerPhysics.Dynamics.FixtureProxy() };
                    this.Shape.ComputeAABB(Bridge.ref(proxy.v, "AABB"), xf, i);

                    proxy.v.Fixture = this;
                    proxy.v.ChildIndex = i;
                    proxy.v.ProxyId = broadPhase.FarseerPhysics$Collision$IBroadPhase$AddProxy(proxy);

                    this.Proxies[System.Array.index(i, this.Proxies)] = proxy.v.$clone();
                }
            },
            DestroyProxies: function (broadPhase) {
                for (var i = 0; i < this.ProxyCount; i = (i + 1) | 0) {
                    broadPhase.FarseerPhysics$Collision$IBroadPhase$RemoveProxy(this.Proxies[System.Array.index(i, this.Proxies)].ProxyId);
                    this.Proxies[System.Array.index(i, this.Proxies)].ProxyId = -1;
                }

                this.ProxyCount = 0;
            },
            Synchronize: function (broadPhase, transform1, transform2) {
                if (this.ProxyCount === 0) {
                    return;
                }

                for (var i = 0; i < this.ProxyCount; i = (i + 1) | 0) {
                    var proxy = this.Proxies[System.Array.index(i, this.Proxies)].$clone();

                    var aabb1 = { v : new FarseerPhysics.Collision.AABB() }, aabb2 = { v : new FarseerPhysics.Collision.AABB() };
                    this.Shape.ComputeAABB(aabb1, transform1, proxy.ChildIndex);
                    this.Shape.ComputeAABB(aabb2, transform2, proxy.ChildIndex);

                    proxy.AABB.Combine$1(aabb1, aabb2);

                    var displacement = Microsoft.Xna.Framework.Vector2.op_Subtraction(transform2.v.Position.$clone(), transform1.v.Position.$clone());

                    broadPhase.FarseerPhysics$Collision$IBroadPhase$MoveProxy(proxy.ProxyId, Bridge.ref(proxy, "AABB"), displacement.$clone());
                }
            },
            CompareTo: function (fixture) {
                return (this.CollidesWith === fixture.CollidesWith && this.CollisionCategories === fixture.CollisionCategories && this.CollisionGroup === fixture.CollisionGroup && this.Friction === fixture.Friction && this.IsSensor === fixture.IsSensor && this.Restitution === fixture.Restitution && this.Shape.CompareTo(fixture.Shape) && Bridge.referenceEquals(this.UserData, fixture.UserData));
            }
        }
    });

    /**
     * This proxy is used internally to connect fixtures to the broad-phase.
     *
     * @public
     * @class FarseerPhysics.Dynamics.FixtureProxy
     */
    Bridge.define("FarseerPhysics.Dynamics.FixtureProxy", {
        $kind: "struct",
        statics: {
            methods: {
                getDefaultValue: function () { return new FarseerPhysics.Dynamics.FixtureProxy(); }
            }
        },
        fields: {
            AABB: null,
            ChildIndex: 0,
            Fixture: null,
            ProxyId: 0
        },
        ctors: {
            init: function () {
                this.AABB = new FarseerPhysics.Collision.AABB();
            },
            ctor: function () {
                this.$initialize();
            }
        },
        methods: {
            getHashCode: function () {
                var h = Bridge.addHash([5340810029, this.AABB, this.ChildIndex, this.Fixture, this.ProxyId]);
                return h;
            },
            equals: function (o) {
                if (!Bridge.is(o, FarseerPhysics.Dynamics.FixtureProxy)) {
                    return false;
                }
                return Bridge.equals(this.AABB, o.AABB) && Bridge.equals(this.ChildIndex, o.ChildIndex) && Bridge.equals(this.Fixture, o.Fixture) && Bridge.equals(this.ProxyId, o.ProxyId);
            },
            $clone: function (to) {
                var s = to || new FarseerPhysics.Dynamics.FixtureProxy();
                s.AABB = this.AABB.$clone();
                s.ChildIndex = this.ChildIndex;
                s.Fixture = this.Fixture;
                s.ProxyId = this.ProxyId;
                return s;
            }
        }
    });

    /**
     * This is an internal class.
     *
     * @public
     * @class FarseerPhysics.Dynamics.Island
     */
    Bridge.define("FarseerPhysics.Dynamics.Island", {
        statics: {
            fields: {
                LinTolSqr: 0,
                AngTolSqr: 0
            },
            ctors: {
                init: function () {
                    this.LinTolSqr = 0.0001;
                    this.AngTolSqr = 0.00121846993;
                }
            }
        },
        fields: {
            Bodies: null,
            BodyCount: 0,
            ContactCount: 0,
            JointCount: 0,
            _bodyCapacity: 0,
            _contactCapacity: 0,
            _contactManager: null,
            _contactSolver: null,
            _contacts: null,
            _jointCapacity: 0,
            _joints: null,
            JointUpdateTime: 0,
            _tmpTime: 0
        },
        ctors: {
            init: function () {
                this._contactSolver = new FarseerPhysics.Dynamics.Contacts.ContactSolver();
            }
        },
        methods: {
            Reset: function (bodyCapacity, contactCapacity, jointCapacity, contactManager) {
                this._bodyCapacity = bodyCapacity;
                this._contactCapacity = contactCapacity;
                this._jointCapacity = jointCapacity;

                this.BodyCount = 0;
                this.ContactCount = 0;
                this.JointCount = 0;

                this._contactManager = contactManager;

                if (this.Bodies == null || this.Bodies.length < bodyCapacity) {
                    this.Bodies = System.Array.init(bodyCapacity, null, FarseerPhysics.Dynamics.Body);
                }

                if (this._contacts == null || this._contacts.length < contactCapacity) {
                    this._contacts = System.Array.init(Bridge.Int.mul(contactCapacity, 2), null, FarseerPhysics.Dynamics.Contacts.Contact);
                }

                if (this._joints == null || this._joints.length < jointCapacity) {
                    this._joints = System.Array.init(Bridge.Int.mul(jointCapacity, 2), null, FarseerPhysics.Dynamics.Joints.Joint);
                }
            },
            Clear: function () {
                this.BodyCount = 0;
                this.ContactCount = 0;
                this.JointCount = 0;
            },
            Solve: function (step, gravity) {
                for (var i = 0; i < this.BodyCount; i = (i + 1) | 0) {
                    var b = this.Bodies[System.Array.index(i, this.Bodies)];

                    if (b.BodyType !== FarseerPhysics.Dynamics.BodyType.Dynamic) {
                        continue;
                    }

                    if (b.IgnoreGravity) {
                        b.LinearVelocityInternal.X += step.v.dt * (b.InvMass * b.Force.X);
                        b.LinearVelocityInternal.Y += step.v.dt * (b.InvMass * b.Force.Y);
                        b.AngularVelocityInternal += step.v.dt * b.InvI * b.Torque;
                    } else {
                        b.LinearVelocityInternal.X += step.v.dt * (gravity.v.X + b.InvMass * b.Force.X);
                        b.LinearVelocityInternal.Y += step.v.dt * (gravity.v.Y + b.InvMass * b.Force.Y);
                        b.AngularVelocityInternal += step.v.dt * b.InvI * b.Torque;
                    }

                    b.LinearVelocityInternal = Microsoft.Xna.Framework.Vector2.op_Multiply$1(b.LinearVelocityInternal.$clone(), FarseerPhysics.Common.MathUtils.Clamp$2(1.0 - step.v.dt * b.LinearDamping, 0.0, 1.0));
                    b.AngularVelocityInternal *= FarseerPhysics.Common.MathUtils.Clamp$2(1.0 - step.v.dt * b.AngularDamping, 0.0, 1.0);
                }

                var i1 = -1;
                for (var i2 = 0; i2 < this.ContactCount; i2 = (i2 + 1) | 0) {
                    var fixtureA = this._contacts[System.Array.index(i2, this._contacts)].FixtureA;
                    var fixtureB = this._contacts[System.Array.index(i2, this._contacts)].FixtureB;
                    var bodyA = fixtureA.Body;
                    var bodyB = fixtureB.Body;
                    var nonStatic = bodyA.BodyType !== FarseerPhysics.Dynamics.BodyType.Static && bodyB.BodyType !== FarseerPhysics.Dynamics.BodyType.Static;
                    if (nonStatic) {
                        i1 = (i1 + 1) | 0;

                        var tmp = this._contacts[System.Array.index(i1, this._contacts)];
                        this._contacts[System.Array.index(i1, this._contacts)] = this._contacts[System.Array.index(i2, this._contacts)];
                        this._contacts[System.Array.index(i2, this._contacts)] = tmp;
                    }
                }

                this._contactSolver.Reset(this._contacts, this.ContactCount, step.v.dtRatio, FarseerPhysics.Settings.EnableWarmstarting);
                this._contactSolver.InitializeVelocityConstraints();

                if (FarseerPhysics.Settings.EnableWarmstarting) {
                    this._contactSolver.WarmStart();
                }


                for (var i3 = 0; i3 < this.JointCount; i3 = (i3 + 1) | 0) {
                    if (this._joints[System.Array.index(i3, this._joints)].Enabled) {
                        this._joints[System.Array.index(i3, this._joints)].InitVelocityConstraints(step);
                    }
                }


                for (var i4 = 0; i4 < FarseerPhysics.Settings.VelocityIterations; i4 = (i4 + 1) | 0) {
                    for (var j = 0; j < this.JointCount; j = (j + 1) | 0) {
                        var joint = this._joints[System.Array.index(j, this._joints)];

                        if (!joint.Enabled) {
                            continue;
                        }

                        joint.SolveVelocityConstraints(step);
                        joint.Validate(step.v.inv_dt);
                    }


                    this._contactSolver.SolveVelocityConstraints();
                }

                this._contactSolver.StoreImpulses();

                for (var i5 = 0; i5 < this.BodyCount; i5 = (i5 + 1) | 0) {
                    var b1 = this.Bodies[System.Array.index(i5, this.Bodies)];

                    if (b1.BodyType === FarseerPhysics.Dynamics.BodyType.Static) {
                        continue;
                    }

                    var translationX = step.v.dt * b1.LinearVelocityInternal.X;
                    var translationY = step.v.dt * b1.LinearVelocityInternal.Y;
                    var result = translationX * translationX + translationY * translationY;

                    if (result > FarseerPhysics.Settings.MaxTranslationSquared) {
                        var sq = Math.sqrt(result);

                        var ratio = FarseerPhysics.Settings.MaxTranslation / sq;
                        b1.LinearVelocityInternal.X *= ratio;
                        b1.LinearVelocityInternal.Y *= ratio;
                    }

                    var rotation = step.v.dt * b1.AngularVelocityInternal;
                    if (rotation * rotation > FarseerPhysics.Settings.MaxRotationSquared) {
                        var ratio1 = FarseerPhysics.Settings.MaxRotation / Math.abs(rotation);
                        b1.AngularVelocityInternal *= ratio1;
                    }

                    b1.Sweep.C0.X = b1.Sweep.C.X;
                    b1.Sweep.C0.Y = b1.Sweep.C.Y;
                    b1.Sweep.A0 = b1.Sweep.A;

                    b1.Sweep.C.X += step.v.dt * b1.LinearVelocityInternal.X;
                    b1.Sweep.C.Y += step.v.dt * b1.LinearVelocityInternal.Y;
                    b1.Sweep.A += step.v.dt * b1.AngularVelocityInternal;

                    b1.SynchronizeTransform();

                }

                for (var i6 = 0; i6 < FarseerPhysics.Settings.PositionIterations; i6 = (i6 + 1) | 0) {
                    var contactsOkay = this._contactSolver.SolvePositionConstraints(FarseerPhysics.Settings.ContactBaumgarte);
                    var jointsOkay = true;

                    for (var j1 = 0; j1 < this.JointCount; j1 = (j1 + 1) | 0) {
                        var joint1 = this._joints[System.Array.index(j1, this._joints)];
                        if (!joint1.Enabled) {
                            continue;
                        }

                        var jointOkay = joint1.SolvePositionConstraints();
                        jointsOkay = jointsOkay && jointOkay;
                    }

                    if (contactsOkay && jointsOkay) {
                        break;
                    }
                }


                this.Report(this._contactSolver.Constraints);

                if (FarseerPhysics.Settings.AllowSleep) {
                    var minSleepTime = FarseerPhysics.Settings.MaxFloat;

                    for (var i7 = 0; i7 < this.BodyCount; i7 = (i7 + 1) | 0) {
                        var b2 = this.Bodies[System.Array.index(i7, this.Bodies)];
                        if (b2.BodyType === FarseerPhysics.Dynamics.BodyType.Static) {
                            continue;
                        }

                        if ((b2.Flags & FarseerPhysics.Dynamics.BodyFlags.AutoSleep) === 0) {
                            b2.SleepTime = 0.0;
                            minSleepTime = 0.0;
                        }

                        if ((b2.Flags & FarseerPhysics.Dynamics.BodyFlags.AutoSleep) === 0 || b2.AngularVelocityInternal * b2.AngularVelocityInternal > FarseerPhysics.Dynamics.Island.AngTolSqr || Microsoft.Xna.Framework.Vector2.Dot(b2.LinearVelocityInternal.$clone(), b2.LinearVelocityInternal.$clone()) > FarseerPhysics.Dynamics.Island.LinTolSqr) {
                            b2.SleepTime = 0.0;
                            minSleepTime = 0.0;
                        } else {
                            b2.SleepTime += step.v.dt;
                            minSleepTime = Math.min(minSleepTime, b2.SleepTime);
                        }
                    }

                    if (minSleepTime >= FarseerPhysics.Settings.TimeToSleep) {
                        for (var i8 = 0; i8 < this.BodyCount; i8 = (i8 + 1) | 0) {
                            var b3 = this.Bodies[System.Array.index(i8, this.Bodies)];
                            b3.Awake = false;
                        }
                    }
                }
            },
            SolveTOI: function (subStep) {
                this._contactSolver.Reset(this._contacts, this.ContactCount, subStep.v.dtRatio, false);

                var kTOIBaumgarte = 0.75;
                for (var i = 0; i < FarseerPhysics.Settings.TOIPositionIterations; i = (i + 1) | 0) {
                    var contactsOkay = this._contactSolver.SolvePositionConstraints(kTOIBaumgarte);
                    if (contactsOkay) {
                        break;
                    }

                    if (i === ((FarseerPhysics.Settings.TOIPositionIterations - 1) | 0)) {
                        i = (i + 0) | 0;
                    }
                }

                for (var i1 = 0; i1 < this.BodyCount; i1 = (i1 + 1) | 0) {
                    var body = this.Bodies[System.Array.index(i1, this.Bodies)];
                    body.Sweep.A0 = body.Sweep.A;
                    body.Sweep.C0 = body.Sweep.C.$clone();
                }

                this._contactSolver.InitializeVelocityConstraints();

                for (var i2 = 0; i2 < FarseerPhysics.Settings.TOIVelocityIterations; i2 = (i2 + 1) | 0) {
                    this._contactSolver.SolveVelocityConstraints();
                }


                for (var i3 = 0; i3 < this.BodyCount; i3 = (i3 + 1) | 0) {
                    var b = this.Bodies[System.Array.index(i3, this.Bodies)];

                    if (b.BodyType === FarseerPhysics.Dynamics.BodyType.Static) {
                        continue;
                    }

                    var translationx = subStep.v.dt * b.LinearVelocityInternal.X;
                    var translationy = subStep.v.dt * b.LinearVelocityInternal.Y;
                    var dot = translationx * translationx + translationy * translationy;
                    if (dot > FarseerPhysics.Settings.MaxTranslationSquared) {
                        var norm = 1.0 / Math.sqrt(dot);
                        var value = FarseerPhysics.Settings.MaxTranslation * subStep.v.inv_dt;
                        b.LinearVelocityInternal.X = value * (translationx * norm);
                        b.LinearVelocityInternal.Y = value * (translationy * norm);
                    }

                    var rotation = subStep.v.dt * b.AngularVelocity;
                    if (rotation * rotation > FarseerPhysics.Settings.MaxRotationSquared) {
                        if (rotation < 0.0) {
                            b.AngularVelocityInternal = -subStep.v.inv_dt * FarseerPhysics.Settings.MaxRotation;
                        } else {
                            b.AngularVelocityInternal = subStep.v.inv_dt * FarseerPhysics.Settings.MaxRotation;
                        }
                    }

                    b.Sweep.C.X += subStep.v.dt * b.LinearVelocityInternal.X;
                    b.Sweep.C.Y += subStep.v.dt * b.LinearVelocityInternal.Y;
                    b.Sweep.A += subStep.v.dt * b.AngularVelocityInternal;

                    b.SynchronizeTransform();

                }

                this.Report(this._contactSolver.Constraints);
            },
            Add: function (body) {
                System.Diagnostics.Debug.Assert(this.BodyCount < this._bodyCapacity);
                this.Bodies[System.Array.index(Bridge.identity(this.BodyCount, (this.BodyCount = (this.BodyCount + 1) | 0)), this.Bodies)] = body;
            },
            Add$1: function (contact) {
                System.Diagnostics.Debug.Assert(this.ContactCount < this._contactCapacity);
                this._contacts[System.Array.index(Bridge.identity(this.ContactCount, (this.ContactCount = (this.ContactCount + 1) | 0)), this._contacts)] = contact;
            },
            Add$2: function (joint) {
                System.Diagnostics.Debug.Assert(this.JointCount < this._jointCapacity);
                this._joints[System.Array.index(Bridge.identity(this.JointCount, (this.JointCount = (this.JointCount + 1) | 0)), this._joints)] = joint;
            },
            Report: function (constraints) {
                if (this._contactManager == null) {
                    return;
                }

                for (var i = 0; i < this.ContactCount; i = (i + 1) | 0) {
                    var c = this._contacts[System.Array.index(i, this._contacts)];

                    if (!Bridge.staticEquals(c.FixtureA.AfterCollision, null)) {
                        c.FixtureA.AfterCollision(c.FixtureA, c.FixtureB, c);
                    }

                    if (!Bridge.staticEquals(c.FixtureB.AfterCollision, null)) {
                        c.FixtureB.AfterCollision(c.FixtureB, c.FixtureA, c);
                    }

                    if (!Bridge.staticEquals(this._contactManager.PostSolve, null)) {
                        var cc = constraints[System.Array.index(i, constraints)];

                        this._contactManager.PostSolve(c, cc);
                    }
                }
            }
        }
    });

    /**
     * @memberof System
     * @callback System.Action
     * @param   {FarseerPhysics.Dynamics.Joints.Joint}    arg1    
     * @param   {number}                                  arg2
     * @return  {void}
     */

    Bridge.define("FarseerPhysics.Dynamics.Joints.Joint", {
        fields: {
            /**
             * The Breakpoint simply indicates the maximum Value the JointError can be before it breaks.
             The default value is float.MaxValue
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Dynamics.Joints.Joint
             * @type number
             */
            Breakpoint: 0,
            EdgeA: null,
            EdgeB: null,
            Enabled: false,
            InvIA: 0,
            InvIB: 0,
            InvMassA: 0,
            InvMassB: 0,
            IslandFlag: false,
            LocalCenterA: null,
            LocalCenterB: null,
            /**
             * Gets or sets the type of the joint.
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Dynamics.Joints.Joint
             * @function JointType
             * @type FarseerPhysics.Dynamics.Joints.JointType
             */
            JointType: 0,
            /**
             * Get the first body attached to this joint.
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Dynamics.Joints.Joint
             * @function BodyA
             * @type FarseerPhysics.Dynamics.Body
             */
            BodyA: null,
            /**
             * Get the second body attached to this joint.
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Dynamics.Joints.Joint
             * @function BodyB
             * @type FarseerPhysics.Dynamics.Body
             */
            BodyB: null,
            /**
             * Set the user data pointer.
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Dynamics.Joints.Joint
             * @function UserData
             * @type System.Object
             */
            UserData: null,
            /**
             * Set this flag to true if the attached bodies should collide.
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Dynamics.Joints.Joint
             * @function CollideConnected
             * @type boolean
             */
            CollideConnected: false
        },
        events: {
            /**
             * Fires when the joint is broken.
             *
             * @instance
             * @public
             * @this FarseerPhysics.Dynamics.Joints.Joint
             * @memberof FarseerPhysics.Dynamics.Joints.Joint
             * @function addBroke
             * @param   {System.Action}    value
             * @return  {void}
             */
            /**
             * Fires when the joint is broken.
             *
             * @instance
             * @public
             * @this FarseerPhysics.Dynamics.Joints.Joint
             * @memberof FarseerPhysics.Dynamics.Joints.Joint
             * @function removeBroke
             * @param   {System.Action}    value
             * @return  {void}
             */
            Broke: null
        },
        props: {
            /**
             * Short-cut function to determine if either body is inactive.
             *
             * @instance
             * @public
             * @readonly
             * @memberof FarseerPhysics.Dynamics.Joints.Joint
             * @function Active
             * @type boolean
             */
            Active: {
                get: function () {
                    return this.BodyA.Enabled && this.BodyB.Enabled;
                }
            }
        },
        ctors: {
            init: function () {
                this.LocalCenterA = new Microsoft.Xna.Framework.Vector2();
                this.LocalCenterB = new Microsoft.Xna.Framework.Vector2();
                this.Breakpoint = 3.40282347E+38;
                this.EdgeA = new FarseerPhysics.Dynamics.Joints.JointEdge();
                this.EdgeB = new FarseerPhysics.Dynamics.Joints.JointEdge();
                this.Enabled = true;
            },
            ctor: function () {
                this.$initialize();
            },
            $ctor2: function (body, bodyB) {
                this.$initialize();
                System.Diagnostics.Debug.Assert(!Bridge.referenceEquals(body, bodyB));

                this.BodyA = body;
                this.BodyB = bodyB;

                this.CollideConnected = false;
            },
            /**
             * Constructor for fixed joint
             *
             * @instance
             * @protected
             * @this FarseerPhysics.Dynamics.Joints.Joint
             * @memberof FarseerPhysics.Dynamics.Joints.Joint
             * @param   {FarseerPhysics.Dynamics.Body}    body
             * @return  {void}
             */
            $ctor1: function (body) {
                this.$initialize();
                this.BodyA = body;

                this.CollideConnected = false;
            }
        },
        methods: {
            WakeBodies: function () {
                this.BodyA.Awake = true;
                if (this.BodyB != null) {
                    this.BodyB.Awake = true;
                }
            },
            /**
             * Return true if the joint is a fixed type.
             *
             * @instance
             * @public
             * @this FarseerPhysics.Dynamics.Joints.Joint
             * @memberof FarseerPhysics.Dynamics.Joints.Joint
             * @return  {boolean}
             */
            IsFixedType: function () {
                return this.JointType === FarseerPhysics.Dynamics.Joints.JointType.FixedRevolute || this.JointType === FarseerPhysics.Dynamics.Joints.JointType.FixedDistance || this.JointType === FarseerPhysics.Dynamics.Joints.JointType.FixedPrismatic || this.JointType === FarseerPhysics.Dynamics.Joints.JointType.FixedLine || this.JointType === FarseerPhysics.Dynamics.Joints.JointType.FixedMouse || this.JointType === FarseerPhysics.Dynamics.Joints.JointType.FixedAngle || this.JointType === FarseerPhysics.Dynamics.Joints.JointType.FixedFriction;
            },
            Validate: function (invDT) {
                if (!this.Enabled) {
                    return;
                }

                var jointError = this.GetReactionForce(invDT).Length();
                if (Math.abs(jointError) <= this.Breakpoint) {
                    return;
                }

                this.Enabled = false;

                if (!Bridge.staticEquals(this.Broke, null)) {
                    this.Broke(this, jointError);
                }
            }
        }
    });

    Bridge.define("FarseerPhysics.Dynamics.Joints.Jacobian", {
        $kind: "struct",
        statics: {
            methods: {
                getDefaultValue: function () { return new FarseerPhysics.Dynamics.Joints.Jacobian(); }
            }
        },
        fields: {
            AngularA: 0,
            AngularB: 0,
            LinearA: null,
            LinearB: null
        },
        ctors: {
            init: function () {
                this.LinearA = new Microsoft.Xna.Framework.Vector2();
                this.LinearB = new Microsoft.Xna.Framework.Vector2();
            },
            ctor: function () {
                this.$initialize();
            }
        },
        methods: {
            SetZero: function () {
                this.LinearA = Microsoft.Xna.Framework.Vector2.Zero.$clone();
                this.AngularA = 0.0;
                this.LinearB = Microsoft.Xna.Framework.Vector2.Zero.$clone();
                this.AngularB = 0.0;
            },
            Set: function (x1, a1, x2, a2) {
                this.LinearA = x1.$clone();
                this.AngularA = a1;
                this.LinearB = x2.$clone();
                this.AngularB = a2;
            },
            Compute: function (x1, a1, x2, a2) {
                return Microsoft.Xna.Framework.Vector2.Dot(this.LinearA.$clone(), x1.$clone()) + this.AngularA * a1 + Microsoft.Xna.Framework.Vector2.Dot(this.LinearB.$clone(), x2.$clone()) + this.AngularB * a2;
            },
            getHashCode: function () {
                var h = Bridge.addHash([3720661676, this.AngularA, this.AngularB, this.LinearA, this.LinearB]);
                return h;
            },
            equals: function (o) {
                if (!Bridge.is(o, FarseerPhysics.Dynamics.Joints.Jacobian)) {
                    return false;
                }
                return Bridge.equals(this.AngularA, o.AngularA) && Bridge.equals(this.AngularB, o.AngularB) && Bridge.equals(this.LinearA, o.LinearA) && Bridge.equals(this.LinearB, o.LinearB);
            },
            $clone: function (to) {
                var s = to || new FarseerPhysics.Dynamics.Joints.Jacobian();
                s.AngularA = this.AngularA;
                s.AngularB = this.AngularB;
                s.LinearA = this.LinearA.$clone();
                s.LinearB = this.LinearB.$clone();
                return s;
            }
        }
    });

    /** @namespace FarseerPhysics.Dynamics.Joints */

    /**
     * A joint edge is used to connect bodies and joints together
     in a joint graph where each body is a node and each joint
     is an edge. A joint edge belongs to a doubly linked list
     maintained in each attached body. Each joint has two joint
     nodes, one for each attached body.
     *
     * @public
     * @class FarseerPhysics.Dynamics.Joints.JointEdge
     */
    Bridge.define("FarseerPhysics.Dynamics.Joints.JointEdge", {
        fields: {
            /**
             * The joint.
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Dynamics.Joints.JointEdge
             * @type FarseerPhysics.Dynamics.Joints.Joint
             */
            Joint: null,
            /**
             * The next joint edge in the body's joint list.
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Dynamics.Joints.JointEdge
             * @type FarseerPhysics.Dynamics.Joints.JointEdge
             */
            Next: null,
            /**
             * Provides quick access to the other body attached.
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Dynamics.Joints.JointEdge
             * @type FarseerPhysics.Dynamics.Body
             */
            Other: null,
            /**
             * The previous joint edge in the body's joint list.
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Dynamics.Joints.JointEdge
             * @type FarseerPhysics.Dynamics.Joints.JointEdge
             */
            Prev: null
        }
    });

    Bridge.define("FarseerPhysics.Dynamics.Joints.JointType", {
        $kind: "enum",
        statics: {
            fields: {
                Revolute: 0,
                Prismatic: 1,
                Distance: 2,
                Pulley: 3,
                Gear: 4,
                Line: 5,
                Weld: 6,
                Friction: 7,
                Slider: 8,
                Angle: 9,
                Rope: 10,
                FixedMouse: 11,
                FixedRevolute: 12,
                FixedDistance: 13,
                FixedLine: 14,
                FixedPrismatic: 15,
                FixedAngle: 16,
                FixedFriction: 17
            }
        }
    });

    Bridge.define("FarseerPhysics.Dynamics.Joints.LimitState", {
        $kind: "enum",
        statics: {
            fields: {
                Inactive: 0,
                AtLower: 1,
                AtUpper: 2,
                Equal: 3
            }
        }
    });

    /**
     * This is an internal structure.
     *
     * @public
     * @class FarseerPhysics.Dynamics.TimeStep
     */
    Bridge.define("FarseerPhysics.Dynamics.TimeStep", {
        $kind: "struct",
        statics: {
            methods: {
                getDefaultValue: function () { return new FarseerPhysics.Dynamics.TimeStep(); }
            }
        },
        fields: {
            /**
             * Time step (Delta time)
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Dynamics.TimeStep
             * @type number
             */
            dt: 0,
            /**
             * dt * inv_dt0
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Dynamics.TimeStep
             * @type number
             */
            dtRatio: 0,
            /**
             * Inverse time step (0 if dt == 0).
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Dynamics.TimeStep
             * @type number
             */
            inv_dt: 0
        },
        ctors: {
            ctor: function () {
                this.$initialize();
            }
        },
        methods: {
            getHashCode: function () {
                var h = Bridge.addHash([3587366311, this.dt, this.dtRatio, this.inv_dt]);
                return h;
            },
            equals: function (o) {
                if (!Bridge.is(o, FarseerPhysics.Dynamics.TimeStep)) {
                    return false;
                }
                return Bridge.equals(this.dt, o.dt) && Bridge.equals(this.dtRatio, o.dtRatio) && Bridge.equals(this.inv_dt, o.inv_dt);
            },
            $clone: function (to) {
                var s = to || new FarseerPhysics.Dynamics.TimeStep();
                s.dt = this.dt;
                s.dtRatio = this.dtRatio;
                s.inv_dt = this.inv_dt;
                return s;
            }
        }
    });

    /**
     * @memberof FarseerPhysics.Dynamics
     * @callback FarseerPhysics.Dynamics.RayCastCallback
     * @param   {FarseerPhysics.Dynamics.Fixture}    fixture     
     * @param   {Microsoft.Xna.Framework.Vector2}    point       
     * @param   {Microsoft.Xna.Framework.Vector2}    normal      
     * @param   {number}                             fraction
     * @return  {number}
     */

    /**
     * @memberof FarseerPhysics.Dynamics
     * @callback FarseerPhysics.Dynamics.JointDelegate
     * @param   {FarseerPhysics.Dynamics.Joints.Joint}    joint
     * @return  {void}
     */

    /**
     * @memberof FarseerPhysics.Dynamics
     * @callback FarseerPhysics.Dynamics.FixtureDelegate
     * @param   {FarseerPhysics.Dynamics.Fixture}    fixture
     * @return  {void}
     */

    /**
     * @memberof FarseerPhysics.Dynamics
     * @callback FarseerPhysics.Dynamics.BodyDelegate
     * @param   {FarseerPhysics.Dynamics.Body}    body
     * @return  {void}
     */

    /**
     * The world class manages all physics entities, dynamic simulation,
     and asynchronous queries.
     *
     * @public
     * @class FarseerPhysics.Dynamics.World
     */
    Bridge.define("FarseerPhysics.Dynamics.World", {
        fields: {
            /**
             * Fires whenever a body has been added
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Dynamics.World
             * @type FarseerPhysics.Dynamics.BodyDelegate
             */
            BodyAdded: null,
            /**
             * Fires whenever a body has been removed
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Dynamics.World
             * @type FarseerPhysics.Dynamics.BodyDelegate
             */
            BodyRemoved: null,
            ContactPool: null,
            /**
             * Fires whenever a fixture has been added
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Dynamics.World
             * @type FarseerPhysics.Dynamics.FixtureDelegate
             */
            FixtureAdded: null,
            /**
             * Fires whenever a fixture has been removed
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Dynamics.World
             * @type FarseerPhysics.Dynamics.FixtureDelegate
             */
            FixtureRemoved: null,
            Flags: 0,
            /**
             * Fires whenever a joint has been added
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Dynamics.World
             * @type FarseerPhysics.Dynamics.JointDelegate
             */
            JointAdded: null,
            /**
             * Fires whenever a joint has been removed
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Dynamics.World
             * @type FarseerPhysics.Dynamics.JointDelegate
             */
            JointRemoved: null,
            ControllerAdded: null,
            ControllerRemoved: null,
            _invDt0: 0,
            Island: null,
            _stack: null,
            _stepComplete: false,
            _bodyAddList: null,
            _bodyRemoveList: null,
            _jointAddList: null,
            _jointRemoveList: null,
            _input: null,
            /**
             * If false, the whole simulation stops. It still processes added and removed geometries.
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Dynamics.World
             * @default true
             * @type boolean
             */
            Enabled: false,
            ControllerList: null,
            BreakableBodyList: null,
            UpdateTime: 0,
            ContinuousPhysicsTime: 0,
            ControllersUpdateTime: 0,
            AddRemoveTime: 0,
            ContactsUpdateTime: 0,
            SolveUpdateTime: 0,
            /**
             * Change the global gravity vector.
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Dynamics.World
             * @type Microsoft.Xna.Framework.Vector2
             */
            Gravity: null,
            /**
             * Get the contact manager for testing.
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Dynamics.World
             * @function ContactManager
             * @type FarseerPhysics.Dynamics.ContactManager
             */
            ContactManager: null,
            /**
             * Get the world body list.
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Dynamics.World
             * @function BodyList
             * @type System.Collections.Generic.List$1
             */
            BodyList: null,
            /**
             * Get the world joint list.
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Dynamics.World
             * @function JointList
             * @type System.Collections.Generic.List$1
             */
            JointList: null
        },
        props: {
            /**
             * Get the number of broad-phase proxies.
             *
             * @instance
             * @public
             * @readonly
             * @memberof FarseerPhysics.Dynamics.World
             * @function ProxyCount
             * @type number
             */
            ProxyCount: {
                get: function () {
                    return this.ContactManager.BroadPhase.FarseerPhysics$Collision$IBroadPhase$ProxyCount;
                }
            },
            /**
             * Set flag to control automatic clearing of forces after each time step.
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Dynamics.World
             * @function AutoClearForces
             * @type boolean
             */
            AutoClearForces: {
                get: function () {
                    return (this.Flags & FarseerPhysics.Dynamics.WorldFlags.ClearForces) === FarseerPhysics.Dynamics.WorldFlags.ClearForces;
                },
                set: function (value) {
                    if (value) {
                        this.Flags |= FarseerPhysics.Dynamics.WorldFlags.ClearForces;
                    } else {
                        this.Flags &= -5;
                    }
                }
            },
            /**
             * Get the world contact list. With the returned contact, use Contact.GetNext to get
             the next contact in the world list. A null contact indicates the end of the list.
             *
             * @instance
             * @public
             * @readonly
             * @memberof FarseerPhysics.Dynamics.World
             * @function ContactList
             * @type System.Collections.Generic.List$1
             */
            ContactList: {
                get: function () {
                    return this.ContactManager.ContactList;
                }
            },
            /**
             * Enable/disable single stepped continuous physics. For testing.
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Dynamics.World
             * @function EnableSubStepping
             * @type boolean
             */
            EnableSubStepping: {
                get: function () {
                    return (this.Flags & FarseerPhysics.Dynamics.WorldFlags.SubStepping) === FarseerPhysics.Dynamics.WorldFlags.SubStepping;
                },
                set: function (value) {
                    if (value) {
                        this.Flags |= FarseerPhysics.Dynamics.WorldFlags.SubStepping;
                    } else {
                        this.Flags &= -17;
                    }
                }
            }
        },
        ctors: {
            init: function () {
                this.Gravity = new Microsoft.Xna.Framework.Vector2();
                this.ContactPool = new (System.Collections.Generic.Queue$1(FarseerPhysics.Dynamics.Contacts.Contact)).$ctor2(256);
                this.Island = new FarseerPhysics.Dynamics.Island();
                this._stack = System.Array.init(64, null, FarseerPhysics.Dynamics.Body);
                this._bodyAddList = new (System.Collections.Generic.HashSet$1(FarseerPhysics.Dynamics.Body)).ctor();
                this._bodyRemoveList = new (System.Collections.Generic.HashSet$1(FarseerPhysics.Dynamics.Body)).ctor();
                this._jointAddList = new (System.Collections.Generic.HashSet$1(FarseerPhysics.Dynamics.Joints.Joint)).ctor();
                this._jointRemoveList = new (System.Collections.Generic.HashSet$1(FarseerPhysics.Dynamics.Joints.Joint)).ctor();
                this._input = new FarseerPhysics.Collision.TOIInput();
                this.Enabled = true;
            },
            /**
             * Initializes a new instance of the {@link } class.
             *
             * @instance
             * @private
             * @this FarseerPhysics.Dynamics.World
             * @memberof FarseerPhysics.Dynamics.World
             * @return  {void}
             */
            ctor: function () {
                this.$initialize();
                this.Flags = FarseerPhysics.Dynamics.WorldFlags.ClearForces;

                this.ControllerList = new (System.Collections.Generic.List$1(FarseerPhysics.Controllers.Controller)).ctor();
                this.BreakableBodyList = new (System.Collections.Generic.List$1(FarseerPhysics.Dynamics.BreakableBody)).ctor();
                this.BodyList = new (System.Collections.Generic.List$1(FarseerPhysics.Dynamics.Body)).$ctor2(32);
                this.JointList = new (System.Collections.Generic.List$1(FarseerPhysics.Dynamics.Joints.Joint)).$ctor2(32);
            },
            $ctor2: function (gravity, span) {
                FarseerPhysics.Dynamics.World.ctor.call(this);
                this.Gravity = gravity.$clone();
                this.ContactManager = new FarseerPhysics.Dynamics.ContactManager(new QuadTreeBroadPhase(span.$clone()));
            },
            /**
             * Initializes a new instance of the {@link } class.
             *
             * @instance
             * @public
             * @this FarseerPhysics.Dynamics.World
             * @memberof FarseerPhysics.Dynamics.World
             * @param   {Microsoft.Xna.Framework.Vector2}    gravity    The gravity.
             * @return  {void}
             */
            $ctor1: function (gravity) {
                FarseerPhysics.Dynamics.World.ctor.call(this);
                this.ContactManager = new FarseerPhysics.Dynamics.ContactManager(new FarseerPhysics.Collision.DynamicTreeBroadPhase());
                this.Gravity = gravity.$clone();
            }
        },
        methods: {
            /**
             * Add a rigid body.
             *
             * @instance
             * @this FarseerPhysics.Dynamics.World
             * @memberof FarseerPhysics.Dynamics.World
             * @param   {FarseerPhysics.Dynamics.Body}    body
             * @return  {void}
             */
            AddBody: function (body) {
                System.Diagnostics.Debug.Assert$1(!this._bodyAddList.contains(body), "You are adding the same body more than once.");

                if (!this._bodyAddList.contains(body)) {
                    this._bodyAddList.add(body);
                }
            },
            /**
             * Destroy a rigid body.
             Warning: This automatically deletes all associated shapes and joints.
             *
             * @instance
             * @public
             * @this FarseerPhysics.Dynamics.World
             * @memberof FarseerPhysics.Dynamics.World
             * @param   {FarseerPhysics.Dynamics.Body}    body    The body.
             * @return  {void}
             */
            RemoveBody: function (body) {
                System.Diagnostics.Debug.Assert$1(!this._bodyRemoveList.contains(body), "The body is already marked for removal. You are removing the body more than once.");

                if (!this._bodyRemoveList.contains(body)) {
                    this._bodyRemoveList.add(body);
                }
            },
            /**
             * Create a joint to constrain bodies together. This may cause the connected bodies to cease colliding.
             *
             * @instance
             * @public
             * @this FarseerPhysics.Dynamics.World
             * @memberof FarseerPhysics.Dynamics.World
             * @param   {FarseerPhysics.Dynamics.Joints.Joint}    joint    The joint.
             * @return  {void}
             */
            AddJoint: function (joint) {
                System.Diagnostics.Debug.Assert$1(!this._jointAddList.contains(joint), "You are adding the same joint more than once.");

                if (!this._jointAddList.contains(joint)) {
                    this._jointAddList.add(joint);
                }
            },
            RemoveJoint$1: function (joint, doCheck) {
                if (doCheck) {
                    System.Diagnostics.Debug.Assert$1(!this._jointRemoveList.contains(joint), "The joint is already marked for removal. You are removing the joint more than once.");
                }

                if (!this._jointRemoveList.contains(joint)) {
                    this._jointRemoveList.add(joint);
                }
            },
            /**
             * Destroy a joint. This may cause the connected bodies to begin colliding.
             *
             * @instance
             * @public
             * @this FarseerPhysics.Dynamics.World
             * @memberof FarseerPhysics.Dynamics.World
             * @param   {FarseerPhysics.Dynamics.Joints.Joint}    joint    The joint.
             * @return  {void}
             */
            RemoveJoint: function (joint) {
                this.RemoveJoint$1(joint, true);
            },
            /**
             * All adds and removes are cached by the World duing a World step.
             To process the changes before the world updates again, call this method.
             *
             * @instance
             * @public
             * @this FarseerPhysics.Dynamics.World
             * @memberof FarseerPhysics.Dynamics.World
             * @return  {void}
             */
            ProcessChanges: function () {
                this.ProcessAddedBodies();
                this.ProcessAddedJoints();

                this.ProcessRemovedBodies();
                this.ProcessRemovedJoints();
            },
            ProcessRemovedJoints: function () {
                var $t;
                if (this._jointRemoveList.Count > 0) {
                    $t = Bridge.getEnumerator(this._jointRemoveList);
                    try {
                        while ($t.moveNext()) {
                            var joint = $t.Current;
                            var collideConnected = joint.CollideConnected;

                            this.JointList.remove(joint);

                            var bodyA = joint.BodyA;
                            var bodyB = joint.BodyB;

                            bodyA.Awake = true;

                            if (!joint.IsFixedType()) {
                                bodyB.Awake = true;
                            }

                            if (joint.EdgeA.Prev != null) {
                                joint.EdgeA.Prev.Next = joint.EdgeA.Next;
                            }

                            if (joint.EdgeA.Next != null) {
                                joint.EdgeA.Next.Prev = joint.EdgeA.Prev;
                            }

                            if (Bridge.referenceEquals(joint.EdgeA, bodyA.JointList)) {
                                bodyA.JointList = joint.EdgeA.Next;
                            }

                            joint.EdgeA.Prev = null;
                            joint.EdgeA.Next = null;

                            if (!joint.IsFixedType()) {
                                if (joint.EdgeB.Prev != null) {
                                    joint.EdgeB.Prev.Next = joint.EdgeB.Next;
                                }

                                if (joint.EdgeB.Next != null) {
                                    joint.EdgeB.Next.Prev = joint.EdgeB.Prev;
                                }

                                if (Bridge.referenceEquals(joint.EdgeB, bodyB.JointList)) {
                                    bodyB.JointList = joint.EdgeB.Next;
                                }

                                joint.EdgeB.Prev = null;
                                joint.EdgeB.Next = null;
                            }

                            if (!joint.IsFixedType()) {
                                if (collideConnected === false) {
                                    var edge = bodyB.ContactList;
                                    while (edge != null) {
                                        if (Bridge.referenceEquals(edge.Other, bodyA)) {
                                            edge.Contact.FlagForFiltering();
                                        }

                                        edge = edge.Next;
                                    }
                                }
                            }

                            if (!Bridge.staticEquals(this.JointRemoved, null)) {
                                this.JointRemoved(joint);
                            }
                        }
                    } finally {
                        if (Bridge.is($t, System.IDisposable)) {
                            $t.System$IDisposable$Dispose();
                        }
                    }
                    this._jointRemoveList.clear();
                }
            },
            ProcessAddedJoints: function () {
                var $t;
                if (this._jointAddList.Count > 0) {
                    $t = Bridge.getEnumerator(this._jointAddList);
                    try {
                        while ($t.moveNext()) {
                            var joint = $t.Current;
                            this.JointList.add(joint);

                            joint.EdgeA.Joint = joint;
                            joint.EdgeA.Other = joint.BodyB;
                            joint.EdgeA.Prev = null;
                            joint.EdgeA.Next = joint.BodyA.JointList;

                            if (joint.BodyA.JointList != null) {
                                joint.BodyA.JointList.Prev = joint.EdgeA;
                            }

                            joint.BodyA.JointList = joint.EdgeA;

                            if (!joint.IsFixedType()) {
                                joint.EdgeB.Joint = joint;
                                joint.EdgeB.Other = joint.BodyA;
                                joint.EdgeB.Prev = null;
                                joint.EdgeB.Next = joint.BodyB.JointList;

                                if (joint.BodyB.JointList != null) {
                                    joint.BodyB.JointList.Prev = joint.EdgeB;
                                }

                                joint.BodyB.JointList = joint.EdgeB;

                                var bodyA = joint.BodyA;
                                var bodyB = joint.BodyB;

                                if (joint.CollideConnected === false) {
                                    var edge = bodyB.ContactList;
                                    while (edge != null) {
                                        if (Bridge.referenceEquals(edge.Other, bodyA)) {
                                            edge.Contact.FlagForFiltering();
                                        }

                                        edge = edge.Next;
                                    }
                                }
                            }

                            if (!Bridge.staticEquals(this.JointAdded, null)) {
                                this.JointAdded(joint);
                            }

                        }
                    } finally {
                        if (Bridge.is($t, System.IDisposable)) {
                            $t.System$IDisposable$Dispose();
                        }
                    }
                    this._jointAddList.clear();
                }
            },
            ProcessAddedBodies: function () {
                var $t;
                if (this._bodyAddList.Count > 0) {
                    $t = Bridge.getEnumerator(this._bodyAddList);
                    try {
                        while ($t.moveNext()) {
                            var body = $t.Current;
                            this.BodyList.add(body);

                            if (!Bridge.staticEquals(this.BodyAdded, null)) {
                                this.BodyAdded(body);
                            }
                        }
                    } finally {
                        if (Bridge.is($t, System.IDisposable)) {
                            $t.System$IDisposable$Dispose();
                        }
                    }
                    this._bodyAddList.clear();
                }
            },
            ProcessRemovedBodies: function () {
                var $t;
                if (this._bodyRemoveList.Count > 0) {
                    $t = Bridge.getEnumerator(this._bodyRemoveList);
                    try {
                        while ($t.moveNext()) {
                            var body = $t.Current;
                            System.Diagnostics.Debug.Assert(this.BodyList.Count > 0);

                            System.Diagnostics.Debug.Assert(this.BodyList.contains(body));

                            var je = body.JointList;
                            while (je != null) {
                                var je0 = je;
                                je = je.Next;

                                this.RemoveJoint$1(je0.Joint, false);
                            }
                            body.JointList = null;

                            var ce = body.ContactList;
                            while (ce != null) {
                                var ce0 = ce;
                                ce = ce.Next;
                                this.ContactManager.Destroy(ce0.Contact);
                            }
                            body.ContactList = null;

                            for (var i = 0; i < body.FixtureList.Count; i = (i + 1) | 0) {
                                body.FixtureList.getItem(i).DestroyProxies(this.ContactManager.BroadPhase);
                                body.FixtureList.getItem(i).Destroy();
                            }

                            body.FixtureList = null;

                            this.BodyList.remove(body);

                            if (!Bridge.staticEquals(this.BodyRemoved, null)) {
                                this.BodyRemoved(body);
                            }
                        }
                    } finally {
                        if (Bridge.is($t, System.IDisposable)) {
                            $t.System$IDisposable$Dispose();
                        }
                    }
                    this._bodyRemoveList.clear();
                }
            },
            /**
             * Take a time step. This performs collision detection, integration,
             and consraint solution.
             *
             * @instance
             * @public
             * @this FarseerPhysics.Dynamics.World
             * @memberof FarseerPhysics.Dynamics.World
             * @param   {number}    dt    The amount of time to simulate, this should not vary.
             * @return  {void}
             */
            Step: function (dt) {

                this.ProcessChanges();

                if (dt === 0 || !this.Enabled) {
                    return;
                }

                if ((this.Flags & FarseerPhysics.Dynamics.WorldFlags.NewFixture) === FarseerPhysics.Dynamics.WorldFlags.NewFixture) {
                    this.ContactManager.FindNewContacts();
                    this.Flags &= -2;
                }

                var step = { v : new FarseerPhysics.Dynamics.TimeStep() };
                step.v.inv_dt = 1.0 / dt;
                step.v.dt = dt;
                step.v.dtRatio = this._invDt0 * dt;

                for (var i = 0; i < this.ControllerList.Count; i = (i + 1) | 0) {
                    this.ControllerList.getItem(i).Update(dt);
                }


                this.ContactManager.Collide();

                this.Solve(step);


                if (FarseerPhysics.Settings.ContinuousPhysics) {
                    this.SolveTOI(step);
                }

                this._invDt0 = step.v.inv_dt;

                if ((this.Flags & FarseerPhysics.Dynamics.WorldFlags.ClearForces) !== 0) {
                    this.ClearForces();
                }

                for (var i1 = 0; i1 < this.BreakableBodyList.Count; i1 = (i1 + 1) | 0) {
                    this.BreakableBodyList.getItem(i1).Update();
                }
            },
            /**
             * Call this after you are done with time steps to clear the forces. You normally
             call this after each call to Step, unless you are performing sub-steps. By default,
             forces will be automatically cleared, so you don't need to call this function.
             *
             * @instance
             * @public
             * @this FarseerPhysics.Dynamics.World
             * @memberof FarseerPhysics.Dynamics.World
             * @return  {void}
             */
            ClearForces: function () {
                for (var i = 0; i < this.BodyList.Count; i = (i + 1) | 0) {
                    var body = this.BodyList.getItem(i);
                    body.Force = Microsoft.Xna.Framework.Vector2.Zero.$clone();
                    body.Torque = 0.0;
                }
            },
            /**
             * Query the world for all fixtures that potentially overlap the
             provided AABB.
             Inside the callback:
             Return true: Continues the query
             Return false: Terminate the query
             *
             * @instance
             * @public
             * @this FarseerPhysics.Dynamics.World
             * @memberof FarseerPhysics.Dynamics.World
             * @param   {System.Func}                      callback    A user implemented callback class.
             * @param   {FarseerPhysics.Collision.AABB}    aabb        The aabb query box.
             * @return  {void}
             */
            QueryAABB: function (callback, aabb) {
                this.ContactManager.BroadPhase.FarseerPhysics$Collision$IBroadPhase$Query(Bridge.fn.bind(this, function (proxyId) {
                    var proxy = this.ContactManager.BroadPhase.FarseerPhysics$Collision$IBroadPhase$GetProxy(proxyId);
                    return callback(proxy.Fixture);
                }), aabb);
            },
            /**
             * Ray-cast the world for all fixtures in the path of the ray. Your callback
             controls whether you get the closest point, any point, or n-points.
             The ray-cast ignores shapes that contain the starting point.
             Inside the callback:
             return -1: ignore this fixture and continue
             return 0: terminate the ray cast
             return fraction: clip the ray to this point
             return 1: don't clip the ray and continue
             *
             * @instance
             * @public
             * @this FarseerPhysics.Dynamics.World
             * @memberof FarseerPhysics.Dynamics.World
             * @param   {FarseerPhysics.Dynamics.RayCastCallback}    callback    A user implemented callback class.
             * @param   {Microsoft.Xna.Framework.Vector2}            point1      The ray starting point.
             * @param   {Microsoft.Xna.Framework.Vector2}            point2      The ray ending point.
             * @return  {void}
             */
            RayCast: function (callback, point1, point2) {
                var input = { v : new FarseerPhysics.Collision.RayCastInput() };
                input.v.MaxFraction = 1.0;
                input.v.Point1 = point1.$clone();
                input.v.Point2 = point2.$clone();

                this.ContactManager.BroadPhase.FarseerPhysics$Collision$IBroadPhase$RayCast(Bridge.fn.bind(this, function (rayCastInput, proxyId) {
                    rayCastInput = {v:rayCastInput};
                    var proxy = this.ContactManager.BroadPhase.FarseerPhysics$Collision$IBroadPhase$GetProxy(proxyId);
                    var fixture = proxy.Fixture;
                    var index = proxy.ChildIndex;
                    var output = { v : new FarseerPhysics.Collision.RayCastOutput() };
                    var hit = fixture.RayCast(output, rayCastInput, index);

                    if (hit) {
                        var fraction = output.v.Fraction;
                        var point = Microsoft.Xna.Framework.Vector2.op_Addition(Microsoft.Xna.Framework.Vector2.op_Multiply$2((1.0 - fraction), input.v.Point1.$clone()), Microsoft.Xna.Framework.Vector2.op_Multiply$2(fraction, input.v.Point2.$clone()));
                        return callback(fixture, point.$clone(), output.v.Normal.$clone(), fraction);
                    }

                    return input.v.MaxFraction;
                }), input);
            },
            Solve: function (step) {
                var $t, $t1, $t2, $t3;
                this.Island.Reset(this.BodyList.Count, this.ContactManager.ContactList.Count, this.JointList.Count, this.ContactManager);

                $t = Bridge.getEnumerator(this.BodyList);
                try {
                    while ($t.moveNext()) {
                        var b = $t.Current;
                        b.Flags &= -2;
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }
                for (var i = 0; i < this.ContactManager.ContactList.Count; i = (i + 1) | 0) {
                    var c = this.ContactManager.ContactList.getItem(i);
                    c.Flags &= -2;
                }
                $t1 = Bridge.getEnumerator(this.JointList);
                try {
                    while ($t1.moveNext()) {
                        var j = $t1.Current;
                        j.IslandFlag = false;
                    }
                } finally {
                    if (Bridge.is($t1, System.IDisposable)) {
                        $t1.System$IDisposable$Dispose();
                    }
                }
                var stackSize = this.BodyList.Count;
                if (stackSize > this._stack.length) {
                    this._stack = System.Array.init(Math.max(Bridge.Int.mul(this._stack.length, 2), stackSize), null, FarseerPhysics.Dynamics.Body);
                }

                for (var index = (this.BodyList.Count - 1) | 0; index >= 0; index = (index - 1) | 0) {
                    var seed = this.BodyList.getItem(index);
                    if ((seed.Flags & (FarseerPhysics.Dynamics.BodyFlags.Island)) !== FarseerPhysics.Dynamics.BodyFlags.None) {
                        continue;
                    }

                    if (seed.Awake === false || seed.Enabled === false) {
                        continue;
                    }

                    if (seed.BodyType === FarseerPhysics.Dynamics.BodyType.Static) {
                        continue;
                    }

                    this.Island.Clear();
                    var stackCount = 0;
                    this._stack[System.Array.index(Bridge.identity(stackCount, (stackCount = (stackCount + 1) | 0)), this._stack)] = seed;
                    seed.Flags |= FarseerPhysics.Dynamics.BodyFlags.Island;

                    while (stackCount > 0) {
                        var b1 = this._stack[System.Array.index(((stackCount = (stackCount - 1) | 0)), this._stack)];
                        System.Diagnostics.Debug.Assert(b1.Enabled);
                        this.Island.Add(b1);

                        b1.Awake = true;

                        if (b1.BodyType === FarseerPhysics.Dynamics.BodyType.Static) {
                            continue;
                        }

                        for (var ce = b1.ContactList; ce != null; ce = ce.Next) {
                            var contact = ce.Contact;

                            if ((contact.Flags & FarseerPhysics.Dynamics.Contacts.ContactFlags.Island) !== FarseerPhysics.Dynamics.Contacts.ContactFlags.None) {
                                continue;
                            }

                            if (!ce.Contact.Enabled || !ce.Contact.IsTouching()) {
                                continue;
                            }

                            var sensorA = contact.FixtureA.IsSensor;
                            var sensorB = contact.FixtureB.IsSensor;
                            if (sensorA || sensorB) {
                                continue;
                            }

                            this.Island.Add$1(contact);
                            contact.Flags |= FarseerPhysics.Dynamics.Contacts.ContactFlags.Island;

                            var other = ce.Other;

                            if ((other.Flags & FarseerPhysics.Dynamics.BodyFlags.Island) !== FarseerPhysics.Dynamics.BodyFlags.None) {
                                continue;
                            }

                            System.Diagnostics.Debug.Assert(stackCount < stackSize);
                            this._stack[System.Array.index(Bridge.identity(stackCount, (stackCount = (stackCount + 1) | 0)), this._stack)] = other;
                            other.Flags |= FarseerPhysics.Dynamics.BodyFlags.Island;
                        }

                        for (var je = b1.JointList; je != null; je = je.Next) {
                            if (je.Joint.IslandFlag) {
                                continue;
                            }

                            var other1 = je.Other;

                            if (other1 != null) {
                                if (other1.Enabled === false) {
                                    continue;
                                }

                                this.Island.Add$2(je.Joint);
                                je.Joint.IslandFlag = true;

                                if ((other1.Flags & FarseerPhysics.Dynamics.BodyFlags.Island) !== FarseerPhysics.Dynamics.BodyFlags.None) {
                                    continue;
                                }

                                System.Diagnostics.Debug.Assert(stackCount < stackSize);
                                this._stack[System.Array.index(Bridge.identity(stackCount, (stackCount = (stackCount + 1) | 0)), this._stack)] = other1;
                                other1.Flags |= FarseerPhysics.Dynamics.BodyFlags.Island;
                            } else {
                                this.Island.Add$2(je.Joint);
                                je.Joint.IslandFlag = true;
                            }
                        }
                    }

                    this.Island.Solve(step, Bridge.ref(this, "Gravity"));

                    for (var i1 = 0; i1 < this.Island.BodyCount; i1 = (i1 + 1) | 0) {
                        var b2 = ($t2 = this.Island.Bodies)[System.Array.index(i1, $t2)];
                        if (b2.BodyType === FarseerPhysics.Dynamics.BodyType.Static) {
                            b2.Flags &= -2;
                        }
                    }
                }

                $t3 = Bridge.getEnumerator(this.BodyList);
                try {
                    while ($t3.moveNext()) {
                        var b3 = $t3.Current;
                        if ((b3.Flags & FarseerPhysics.Dynamics.BodyFlags.Island) !== FarseerPhysics.Dynamics.BodyFlags.Island) {
                            continue;
                        }

                        if (b3.BodyType === FarseerPhysics.Dynamics.BodyType.Static) {
                            continue;
                        }

                        b3.SynchronizeFixtures();
                    }
                } finally {
                    if (Bridge.is($t3, System.IDisposable)) {
                        $t3.System$IDisposable$Dispose();
                    }
                }
                this.ContactManager.FindNewContacts();
            },
            /**
             * Find TOI contacts and solve them.
             *
             * @instance
             * @private
             * @this FarseerPhysics.Dynamics.World
             * @memberof FarseerPhysics.Dynamics.World
             * @param   {FarseerPhysics.Dynamics.TimeStep}    step    The step.
             * @return  {void}
             */
            SolveTOI: function (step) {
                var $t;
                this.Island.Reset(100, FarseerPhysics.Settings.MaxTOIContacts, 0, this.ContactManager);

                if (this._stepComplete) {
                    for (var i = 0; i < this.BodyList.Count; i = (i + 1) | 0) {
                        this.BodyList.getItem(i).Flags &= -2;
                        this.BodyList.getItem(i).Sweep.Alpha0 = 0.0;
                    }

                    for (var i1 = 0; i1 < this.ContactManager.ContactList.Count; i1 = (i1 + 1) | 0) {
                        var c = this.ContactManager.ContactList.getItem(i1);

                        c.Flags &= -34;
                        c.TOICount = 0;
                        c.TOI = 1.0;
                    }
                }

                for (; ; ) {
                    var minContact = null;
                    var minAlpha = 1.0;

                    for (var i2 = 0; i2 < this.ContactManager.ContactList.Count; i2 = (i2 + 1) | 0) {
                        var c1 = this.ContactManager.ContactList.getItem(i2);

                        if (c1.Enabled === false) {
                            continue;
                        }

                        if (c1.TOICount > FarseerPhysics.Settings.MaxSubSteps) {
                            continue;
                        }

                        var alpha;
                        if ((c1.Flags & FarseerPhysics.Dynamics.Contacts.ContactFlags.TOI) === FarseerPhysics.Dynamics.Contacts.ContactFlags.TOI) {
                            alpha = c1.TOI;
                        } else {
                            var fA = c1.FixtureA;
                            var fB = c1.FixtureB;

                            if (fA.IsSensor || fB.IsSensor) {
                                continue;
                            }

                            var bA = fA.Body;
                            var bB = fB.Body;

                            var typeA = bA.BodyType;
                            var typeB = bB.BodyType;
                            System.Diagnostics.Debug.Assert(typeA === FarseerPhysics.Dynamics.BodyType.Dynamic || typeB === FarseerPhysics.Dynamics.BodyType.Dynamic);

                            var awakeA = bA.Awake && typeA !== FarseerPhysics.Dynamics.BodyType.Static;
                            var awakeB = bB.Awake && typeB !== FarseerPhysics.Dynamics.BodyType.Static;

                            if (awakeA === false && awakeB === false) {
                                continue;
                            }

                            var collideA = (bA.IsBullet || typeA !== FarseerPhysics.Dynamics.BodyType.Dynamic) && !bA.IgnoreCCD;
                            var collideB = (bB.IsBullet || typeB !== FarseerPhysics.Dynamics.BodyType.Dynamic) && !bB.IgnoreCCD;

                            if (collideA === false && collideB === false) {
                                continue;
                            }

                            var alpha0 = bA.Sweep.Alpha0;

                            if (bA.Sweep.Alpha0 < bB.Sweep.Alpha0) {
                                alpha0 = bB.Sweep.Alpha0;
                                bA.Sweep.Advance(alpha0);
                            } else if (bB.Sweep.Alpha0 < bA.Sweep.Alpha0) {
                                alpha0 = bA.Sweep.Alpha0;
                                bB.Sweep.Advance(alpha0);
                            }

                            System.Diagnostics.Debug.Assert(alpha0 < 1.0);

                            this._input.ProxyA.Set(fA.Shape, c1.ChildIndexA);
                            this._input.ProxyB.Set(fB.Shape, c1.ChildIndexB);
                            this._input.SweepA = bA.Sweep.$clone();
                            this._input.SweepB = bB.Sweep.$clone();
                            this._input.TMax = 1.0;

                            var output = { v : new FarseerPhysics.Collision.TOIOutput() };
                            FarseerPhysics.Collision.TimeOfImpact.CalculateTimeOfImpact(output, this._input);

                            var beta = output.v.T;
                            if (output.v.State === FarseerPhysics.Collision.TOIOutputState.Touching) {
                                alpha = Math.min(alpha0 + (1.0 - alpha0) * beta, 1.0);
                            } else {
                                alpha = 1.0;
                            }

                            c1.TOI = alpha;
                            c1.Flags |= FarseerPhysics.Dynamics.Contacts.ContactFlags.TOI;
                        }

                        if (alpha < minAlpha) {
                            minContact = c1;
                            minAlpha = alpha;
                        }
                    }

                    if (minContact == null || 0.9999988 < minAlpha) {
                        this._stepComplete = true;
                        break;
                    }

                    var fA1 = minContact.FixtureA;
                    var fB1 = minContact.FixtureB;
                    var bA1 = fA1.Body;
                    var bB1 = fB1.Body;

                    var backup1 = bA1.Sweep.$clone();
                    var backup2 = bB1.Sweep.$clone();

                    bA1.Advance(minAlpha);
                    bB1.Advance(minAlpha);

                    minContact.Update(this.ContactManager);
                    minContact.Flags &= -33;
                    minContact.TOICount = (minContact.TOICount + 1) | 0;

                    if (minContact.Enabled === false || minContact.IsTouching() === false) {
                        minContact.Enabled = false;
                        bA1.Sweep = backup1.$clone();
                        bB1.Sweep = backup2.$clone();
                        bA1.SynchronizeTransform();
                        bB1.SynchronizeTransform();
                        continue;
                    }

                    bA1.Awake = true;
                    bB1.Awake = true;

                    this.Island.Clear();
                    this.Island.Add(bA1);
                    this.Island.Add(bB1);
                    this.Island.Add$1(minContact);

                    bA1.Flags |= FarseerPhysics.Dynamics.BodyFlags.Island;
                    bB1.Flags |= FarseerPhysics.Dynamics.BodyFlags.Island;
                    minContact.Flags |= FarseerPhysics.Dynamics.Contacts.ContactFlags.Island;

                    var bodies = System.Array.init([bA1, bB1], FarseerPhysics.Dynamics.Body);
                    for (var i3 = 0; i3 < 2; i3 = (i3 + 1) | 0) {
                        var body = bodies[System.Array.index(i3, bodies)];
                        if (body.BodyType === FarseerPhysics.Dynamics.BodyType.Dynamic) {
                            for (var ce = body.ContactList; ce != null; ce = ce.Next) {
                                var contact = ce.Contact;

                                if ((contact.Flags & FarseerPhysics.Dynamics.Contacts.ContactFlags.Island) === FarseerPhysics.Dynamics.Contacts.ContactFlags.Island) {
                                    continue;
                                }

                                var other = ce.Other;
                                if (other.BodyType === FarseerPhysics.Dynamics.BodyType.Dynamic && body.IsBullet === false && other.IsBullet === false) {
                                    continue;
                                }

                                if (contact.FixtureA.IsSensor || contact.FixtureB.IsSensor) {
                                    continue;
                                }

                                var backup = other.Sweep.$clone();
                                if ((other.Flags & FarseerPhysics.Dynamics.BodyFlags.Island) === 0) {
                                    other.Advance(minAlpha);
                                }

                                contact.Update(this.ContactManager);

                                if (contact.Enabled === false) {
                                    other.Sweep = backup.$clone();
                                    other.SynchronizeTransform();
                                    continue;
                                }

                                if (contact.IsTouching() === false) {
                                    other.Sweep = backup.$clone();
                                    other.SynchronizeTransform();
                                    continue;
                                }

                                contact.Flags |= FarseerPhysics.Dynamics.Contacts.ContactFlags.Island;
                                this.Island.Add$1(contact);

                                if ((other.Flags & FarseerPhysics.Dynamics.BodyFlags.Island) === FarseerPhysics.Dynamics.BodyFlags.Island) {
                                    continue;
                                }

                                other.Flags |= FarseerPhysics.Dynamics.BodyFlags.Island;

                                if (other.BodyType !== FarseerPhysics.Dynamics.BodyType.Static) {
                                    other.Awake = true;
                                }

                                this.Island.Add(other);
                            }
                        }
                    }

                    var subStep = { v : new FarseerPhysics.Dynamics.TimeStep() };
                    subStep.v.dt = (1.0 - minAlpha) * step.v.dt;
                    subStep.v.inv_dt = 1.0 / subStep.v.dt;
                    subStep.v.dtRatio = 1.0;
                    this.Island.SolveTOI(subStep);

                    for (var i4 = 0; i4 < this.Island.BodyCount; i4 = (i4 + 1) | 0) {
                        var body1 = ($t = this.Island.Bodies)[System.Array.index(i4, $t)];
                        body1.Flags &= -2;

                        if (body1.BodyType !== FarseerPhysics.Dynamics.BodyType.Dynamic) {
                            continue;
                        }

                        body1.SynchronizeFixtures();

                        for (var ce1 = body1.ContactList; ce1 != null; ce1 = ce1.Next) {
                            ce1.Contact.Flags &= -34;
                        }
                    }

                    this.ContactManager.FindNewContacts();

                    if (this.EnableSubStepping) {
                        this._stepComplete = false;
                        break;
                    }
                }
            },
            AddController: function (controller) {
                System.Diagnostics.Debug.Assert$1(!this.ControllerList.contains(controller), "You are adding the same controller more than once.");

                controller.World = this;
                this.ControllerList.add(controller);

                if (!Bridge.staticEquals(this.ControllerAdded, null)) {
                    this.ControllerAdded(controller);
                }
            },
            RemoveController: function (controller) {
                System.Diagnostics.Debug.Assert$1(this.ControllerList.contains(controller), "You are removing a controller that is not in the simulation.");

                if (this.ControllerList.contains(controller)) {
                    this.ControllerList.remove(controller);

                    if (!Bridge.staticEquals(this.ControllerRemoved, null)) {
                        this.ControllerRemoved(controller);
                    }
                }
            },
            AddBreakableBody: function (breakableBody) {
                this.BreakableBodyList.add(breakableBody);
            },
            RemoveBreakableBody: function (breakableBody) {
                System.Diagnostics.Debug.Assert(this.BreakableBodyList.contains(breakableBody));

                this.BreakableBodyList.remove(breakableBody);
            },
            TestPoint: function (point) {
                point = {v:point};
                var aabb = { v : new FarseerPhysics.Collision.AABB() };
                var d = new Microsoft.Xna.Framework.Vector2.$ctor2(FarseerPhysics.Settings.Epsilon, FarseerPhysics.Settings.Epsilon);
                aabb.v.LowerBound = Microsoft.Xna.Framework.Vector2.op_Subtraction(point.v.$clone(), d.$clone());
                aabb.v.UpperBound = Microsoft.Xna.Framework.Vector2.op_Addition(point.v.$clone(), d.$clone());

                var myFixture = null;

                this.QueryAABB(function (fixture) {
                    var inside = fixture.TestPoint(point);
                    if (inside) {
                        myFixture = fixture;
                        return false;
                    }

                    return true;
                }, aabb);

                return myFixture;
            },
            /**
             * Returns a list of fixtures that are at the specified point.
             *
             * @instance
             * @public
             * @this FarseerPhysics.Dynamics.World
             * @memberof FarseerPhysics.Dynamics.World
             * @param   {Microsoft.Xna.Framework.Vector2}      point    The point.
             * @return  {System.Collections.Generic.List$1}
             */
            TestPointAll: function (point) {
                point = {v:point};
                var aabb = { v : new FarseerPhysics.Collision.AABB() };
                var d = new Microsoft.Xna.Framework.Vector2.$ctor2(FarseerPhysics.Settings.Epsilon, FarseerPhysics.Settings.Epsilon);
                aabb.v.LowerBound = Microsoft.Xna.Framework.Vector2.op_Subtraction(point.v.$clone(), d.$clone());
                aabb.v.UpperBound = Microsoft.Xna.Framework.Vector2.op_Addition(point.v.$clone(), d.$clone());

                var fixtures = new (System.Collections.Generic.List$1(FarseerPhysics.Dynamics.Fixture)).ctor();

                this.QueryAABB(function (fixture) {
                    var inside = fixture.TestPoint(point);
                    if (inside) {
                        fixtures.add(fixture);
                    }

                    return true;
                }, aabb);

                return fixtures;
            },
            Clear: function () {
                this.ProcessChanges();

                for (var i = (this.BodyList.Count - 1) | 0; i >= 0; i = (i - 1) | 0) {
                    this.RemoveBody(this.BodyList.getItem(i));
                }

                for (var i1 = (this.ControllerList.Count - 1) | 0; i1 >= 0; i1 = (i1 - 1) | 0) {
                    this.RemoveController(this.ControllerList.getItem(i1));
                }

                for (var i2 = (this.BreakableBodyList.Count - 1) | 0; i2 >= 0; i2 = (i2 - 1) | 0) {
                    this.RemoveBreakableBody(this.BreakableBodyList.getItem(i2));
                }

                this.ProcessChanges();
            }
        }
    });

    Bridge.define("FarseerPhysics.Dynamics.WorldFlags", {
        $kind: "enum",
        statics: {
            fields: {
                /**
                 * Flag that indicates a new fixture has been added to the world.
                 *
                 * @static
                 * @public
                 * @memberof FarseerPhysics.Dynamics.WorldFlags
                 * @constant
                 * @default 1
                 * @type FarseerPhysics.Dynamics.WorldFlags
                 */
                NewFixture: 1,
                /**
                 * Flag that clear the forces after each time step.
                 *
                 * @static
                 * @public
                 * @memberof FarseerPhysics.Dynamics.WorldFlags
                 * @constant
                 * @default 4
                 * @type FarseerPhysics.Dynamics.WorldFlags
                 */
                ClearForces: 4,
                SubStepping: 16
            }
        },
        $flags: true
    });

    Bridge.define("FarseerPhysics.Factories.BodyFactory", {
        statics: {
            methods: {
                CreateBody: function (world) {
                    return FarseerPhysics.Factories.BodyFactory.CreateBody$3(world, null);
                },
                CreateBody$3: function (world, userData) {
                    var body = new FarseerPhysics.Dynamics.Body.$ctor2(world, userData);
                    return body;
                },
                CreateBody$1: function (world, position) {
                    return FarseerPhysics.Factories.BodyFactory.CreateBody$2(world, position.$clone(), null);
                },
                CreateBody$2: function (world, position, userData) {
                    var body = FarseerPhysics.Factories.BodyFactory.CreateBody$3(world, userData);
                    body.Position = position.$clone();
                    return body;
                },
                CreateEdge: function (world, start, end) {
                    return FarseerPhysics.Factories.BodyFactory.CreateEdge$1(world, start.$clone(), end.$clone(), null);
                },
                CreateEdge$1: function (world, start, end, userData) {
                    var body = FarseerPhysics.Factories.BodyFactory.CreateBody(world);
                    FarseerPhysics.Factories.FixtureFactory.AttachEdge$1(start.$clone(), end.$clone(), body, userData);
                    return body;
                },
                CreateLoopShape: function (world, vertices) {
                    return FarseerPhysics.Factories.BodyFactory.CreateLoopShape$3(world, vertices, null);
                },
                CreateLoopShape$3: function (world, vertices, userData) {
                    return FarseerPhysics.Factories.BodyFactory.CreateLoopShape$2(world, vertices, Microsoft.Xna.Framework.Vector2.Zero.$clone(), userData);
                },
                CreateLoopShape$1: function (world, vertices, position) {
                    return FarseerPhysics.Factories.BodyFactory.CreateLoopShape$2(world, vertices, position.$clone(), null);
                },
                CreateLoopShape$2: function (world, vertices, position, userData) {
                    var body = FarseerPhysics.Factories.BodyFactory.CreateBody$1(world, position.$clone());
                    FarseerPhysics.Factories.FixtureFactory.AttachLoopShape$1(vertices, body, userData);
                    return body;
                },
                CreateRectangle: function (world, width, height, density) {
                    return FarseerPhysics.Factories.BodyFactory.CreateRectangle$3(world, width, height, density, null);
                },
                CreateRectangle$3: function (world, width, height, density, userData) {
                    return FarseerPhysics.Factories.BodyFactory.CreateRectangle$2(world, width, height, density, Microsoft.Xna.Framework.Vector2.Zero.$clone(), userData);
                },
                CreateRectangle$1: function (world, width, height, density, position) {
                    return FarseerPhysics.Factories.BodyFactory.CreateRectangle$2(world, width, height, density, position.$clone(), null);
                },
                CreateRectangle$2: function (world, width, height, density, position, userData) {
                    if (width <= 0) {
                        throw new System.ArgumentOutOfRangeException.$ctor4("width", "Width must be more than 0 meters");
                    }

                    if (height <= 0) {
                        throw new System.ArgumentOutOfRangeException.$ctor4("height", "Height must be more than 0 meters");
                    }

                    var newBody = FarseerPhysics.Factories.BodyFactory.CreateBody$1(world, position.$clone());
                    var rectangleVertices = FarseerPhysics.Common.PolygonTools.CreateRectangle(width / 2, height / 2);
                    var rectangleShape = new FarseerPhysics.Collision.Shapes.PolygonShape.$ctor1(rectangleVertices, density);
                    newBody.CreateFixture$1(rectangleShape, userData);

                    return newBody;
                },
                CreateCircle: function (world, radius, density) {
                    return FarseerPhysics.Factories.BodyFactory.CreateCircle$3(world, radius, density, null);
                },
                CreateCircle$3: function (world, radius, density, userData) {
                    return FarseerPhysics.Factories.BodyFactory.CreateCircle$2(world, radius, density, Microsoft.Xna.Framework.Vector2.Zero.$clone(), userData);
                },
                CreateCircle$1: function (world, radius, density, position) {
                    return FarseerPhysics.Factories.BodyFactory.CreateCircle$2(world, radius, density, position.$clone(), null);
                },
                CreateCircle$2: function (world, radius, density, position, userData) {
                    var body = FarseerPhysics.Factories.BodyFactory.CreateBody$1(world, position.$clone());
                    FarseerPhysics.Factories.FixtureFactory.AttachCircle$3(radius, density, body, userData);
                    return body;
                },
                CreateEllipse: function (world, xRadius, yRadius, edges, density) {
                    return FarseerPhysics.Factories.BodyFactory.CreateEllipse$3(world, xRadius, yRadius, edges, density, null);
                },
                CreateEllipse$3: function (world, xRadius, yRadius, edges, density, userData) {
                    return FarseerPhysics.Factories.BodyFactory.CreateEllipse$2(world, xRadius, yRadius, edges, density, Microsoft.Xna.Framework.Vector2.Zero.$clone(), userData);
                },
                CreateEllipse$1: function (world, xRadius, yRadius, edges, density, position) {
                    return FarseerPhysics.Factories.BodyFactory.CreateEllipse$2(world, xRadius, yRadius, edges, density, position.$clone(), null);
                },
                CreateEllipse$2: function (world, xRadius, yRadius, edges, density, position, userData) {
                    var body = FarseerPhysics.Factories.BodyFactory.CreateBody$1(world, position.$clone());
                    FarseerPhysics.Factories.FixtureFactory.AttachEllipse$1(xRadius, yRadius, edges, density, body, userData);
                    return body;
                },
                CreatePolygon: function (world, vertices, density) {
                    return FarseerPhysics.Factories.BodyFactory.CreatePolygon$3(world, vertices, density, null);
                },
                CreatePolygon$3: function (world, vertices, density, userData) {
                    return FarseerPhysics.Factories.BodyFactory.CreatePolygon$2(world, vertices, density, Microsoft.Xna.Framework.Vector2.Zero.$clone(), userData);
                },
                CreatePolygon$1: function (world, vertices, density, position) {
                    return FarseerPhysics.Factories.BodyFactory.CreatePolygon$2(world, vertices, density, position.$clone(), null);
                },
                CreatePolygon$2: function (world, vertices, density, position, userData) {
                    var body = FarseerPhysics.Factories.BodyFactory.CreateBody$1(world, position.$clone());
                    FarseerPhysics.Factories.FixtureFactory.AttachPolygon$1(vertices, density, body, userData);
                    return body;
                },
                CreateCompoundPolygon: function (world, list, density) {
                    return FarseerPhysics.Factories.BodyFactory.CreateCompoundPolygon$3(world, list, density, Bridge.box(FarseerPhysics.Dynamics.BodyType.Static, FarseerPhysics.Dynamics.BodyType, System.Enum.toStringFn(FarseerPhysics.Dynamics.BodyType)));
                },
                CreateCompoundPolygon$3: function (world, list, density, userData) {
                    return FarseerPhysics.Factories.BodyFactory.CreateCompoundPolygon$2(world, list, density, Microsoft.Xna.Framework.Vector2.Zero.$clone(), userData);
                },
                CreateCompoundPolygon$1: function (world, list, density, position) {
                    return FarseerPhysics.Factories.BodyFactory.CreateCompoundPolygon$2(world, list, density, position.$clone(), null);
                },
                CreateCompoundPolygon$2: function (world, list, density, position, userData) {
                    var polygonBody = FarseerPhysics.Factories.BodyFactory.CreateBody$1(world, position.$clone());
                    FarseerPhysics.Factories.FixtureFactory.AttachCompoundPolygon$1(list, density, polygonBody, userData);
                    return polygonBody;
                },
                CreateGear: function (world, radius, numberOfTeeth, tipPercentage, toothHeight, density) {
                    return FarseerPhysics.Factories.BodyFactory.CreateGear$1(world, radius, numberOfTeeth, tipPercentage, toothHeight, density, null);
                },
                CreateGear$1: function (world, radius, numberOfTeeth, tipPercentage, toothHeight, density, userData) {
                    var gearPolygon = FarseerPhysics.Common.PolygonTools.CreateGear(radius, numberOfTeeth, tipPercentage, toothHeight);

                    if (!gearPolygon.IsConvex()) {
                        var list = FarseerPhysics.Common.Decomposition.EarclipDecomposer.ConvexPartition(gearPolygon);

                        return FarseerPhysics.Factories.BodyFactory.CreateCompoundPolygon$3(world, list, density, userData);
                    }

                    return FarseerPhysics.Factories.BodyFactory.CreatePolygon$3(world, gearPolygon, density, userData);
                },
                /**
                 * Creates a capsule.
                 Note: Automatically decomposes the capsule if it contains too many vertices (controlled by Settings.MaxPolygonVertices)
                 *
                 * @static
                 * @public
                 * @this FarseerPhysics.Factories.BodyFactory
                 * @memberof FarseerPhysics.Factories.BodyFactory
                 * @param   {FarseerPhysics.Dynamics.World}      world           The world.
                 * @param   {number}                             height          The height.
                 * @param   {number}                             topRadius       The top radius.
                 * @param   {number}                             topEdges        The top edges.
                 * @param   {number}                             bottomRadius    The bottom radius.
                 * @param   {number}                             bottomEdges     The bottom edges.
                 * @param   {number}                             density         The density.
                 * @param   {Microsoft.Xna.Framework.Vector2}    position        The position.
                 * @param   {System.Object}                      userData
                 * @return  {FarseerPhysics.Dynamics.Body}
                 */
                CreateCapsule$1: function (world, height, topRadius, topEdges, bottomRadius, bottomEdges, density, position, userData) {
                    var verts = FarseerPhysics.Common.PolygonTools.CreateCapsule$1(height, topRadius, topEdges, bottomRadius, bottomEdges);

                    var body;

                    if (verts.Count >= FarseerPhysics.Settings.MaxPolygonVertices) {
                        var vertList = FarseerPhysics.Common.Decomposition.EarclipDecomposer.ConvexPartition(verts);
                        body = FarseerPhysics.Factories.BodyFactory.CreateCompoundPolygon$3(world, vertList, density, userData);
                        body.Position = position.$clone();

                        return body;
                    }

                    body = FarseerPhysics.Factories.BodyFactory.CreatePolygon$3(world, verts, density, userData);
                    body.Position = position.$clone();

                    return body;
                },
                CreateCapsule: function (world, height, topRadius, topEdges, bottomRadius, bottomEdges, density, position) {
                    return FarseerPhysics.Factories.BodyFactory.CreateCapsule$1(world, height, topRadius, topEdges, bottomRadius, bottomEdges, density, position.$clone(), null);
                },
                CreateCapsule$2: function (world, height, endRadius, density) {
                    return FarseerPhysics.Factories.BodyFactory.CreateCapsule$3(world, height, endRadius, density, null);
                },
                CreateCapsule$3: function (world, height, endRadius, density, userData) {
                    var rectangle = FarseerPhysics.Common.PolygonTools.CreateRectangle(endRadius, height / 2);

                    var list = new (System.Collections.Generic.List$1(FarseerPhysics.Common.Vertices)).ctor();
                    list.add(rectangle);

                    var body = FarseerPhysics.Factories.BodyFactory.CreateCompoundPolygon$3(world, list, density, userData);

                    var topCircle = new FarseerPhysics.Collision.Shapes.CircleShape.$ctor1(endRadius, density);
                    topCircle.Position = new Microsoft.Xna.Framework.Vector2.$ctor2(0, height / 2);
                    body.CreateFixture$1(topCircle, userData);

                    var bottomCircle = new FarseerPhysics.Collision.Shapes.CircleShape.$ctor1(endRadius, density);
                    bottomCircle.Position = new Microsoft.Xna.Framework.Vector2.$ctor2(0, -(height / 2));
                    body.CreateFixture$1(bottomCircle, userData);
                    return body;
                },
                /**
                 * Creates a rounded rectangle.
                 Note: Automatically decomposes the capsule if it contains too many vertices (controlled by Settings.MaxPolygonVertices)
                 *
                 * @static
                 * @public
                 * @this FarseerPhysics.Factories.BodyFactory
                 * @memberof FarseerPhysics.Factories.BodyFactory
                 * @param   {FarseerPhysics.Dynamics.World}      world       The world.
                 * @param   {number}                             width       The width.
                 * @param   {number}                             height      The height.
                 * @param   {number}                             xRadius     The x radius.
                 * @param   {number}                             yRadius     The y radius.
                 * @param   {number}                             segments    The segments.
                 * @param   {number}                             density     The density.
                 * @param   {Microsoft.Xna.Framework.Vector2}    position    The position.
                 * @param   {System.Object}                      userData
                 * @return  {FarseerPhysics.Dynamics.Body}
                 */
                CreateRoundedRectangle$2: function (world, width, height, xRadius, yRadius, segments, density, position, userData) {
                    var verts = FarseerPhysics.Common.PolygonTools.CreateRoundedRectangle(width, height, xRadius, yRadius, segments);

                    if (verts.Count >= FarseerPhysics.Settings.MaxPolygonVertices) {
                        var vertList = FarseerPhysics.Common.Decomposition.EarclipDecomposer.ConvexPartition(verts);
                        var body = FarseerPhysics.Factories.BodyFactory.CreateCompoundPolygon$3(world, vertList, density, userData);
                        body.Position = position.$clone();
                        return body;
                    }

                    return FarseerPhysics.Factories.BodyFactory.CreatePolygon(world, verts, density);
                },
                CreateRoundedRectangle$1: function (world, width, height, xRadius, yRadius, segments, density, position) {
                    return FarseerPhysics.Factories.BodyFactory.CreateRoundedRectangle$2(world, width, height, xRadius, yRadius, segments, density, position.$clone(), null);
                },
                CreateRoundedRectangle: function (world, width, height, xRadius, yRadius, segments, density) {
                    return FarseerPhysics.Factories.BodyFactory.CreateRoundedRectangle$3(world, width, height, xRadius, yRadius, segments, density, null);
                },
                CreateRoundedRectangle$3: function (world, width, height, xRadius, yRadius, segments, density, userData) {
                    return FarseerPhysics.Factories.BodyFactory.CreateRoundedRectangle$2(world, width, height, xRadius, yRadius, segments, density, Microsoft.Xna.Framework.Vector2.Zero.$clone(), userData);
                },
                CreateBreakableBody: function (world, vertices, density) {
                    return FarseerPhysics.Factories.BodyFactory.CreateBreakableBody$3(world, vertices, density, null);
                },
                CreateBreakableBody$3: function (world, vertices, density, userData) {
                    return FarseerPhysics.Factories.BodyFactory.CreateBreakableBody$2(world, vertices, density, Microsoft.Xna.Framework.Vector2.Zero.$clone(), userData);
                },
                /**
                 * Creates a breakable body. You would want to remove collinear points before using this.
                 *
                 * @static
                 * @public
                 * @this FarseerPhysics.Factories.BodyFactory
                 * @memberof FarseerPhysics.Factories.BodyFactory
                 * @param   {FarseerPhysics.Dynamics.World}            world       The world.
                 * @param   {FarseerPhysics.Common.Vertices}           vertices    The vertices.
                 * @param   {number}                                   density     The density.
                 * @param   {Microsoft.Xna.Framework.Vector2}          position    The position.
                 * @param   {System.Object}                            userData
                 * @return  {FarseerPhysics.Dynamics.BreakableBody}
                 */
                CreateBreakableBody$2: function (world, vertices, density, position, userData) {
                    var triangles = FarseerPhysics.Common.Decomposition.EarclipDecomposer.ConvexPartition(vertices);

                    var breakableBody = new FarseerPhysics.Dynamics.BreakableBody.$ctor1(triangles, world, density, userData);
                    breakableBody.MainBody.Position = position.$clone();
                    world.AddBreakableBody(breakableBody);

                    return breakableBody;
                },
                CreateBreakableBody$1: function (world, vertices, density, position) {
                    return FarseerPhysics.Factories.BodyFactory.CreateBreakableBody$2(world, vertices, density, position.$clone(), null);
                },
                CreateLineArc: function (world, radians, sides, radius, position, angle, closed) {
                    var body = FarseerPhysics.Factories.BodyFactory.CreateBody(world);
                    FarseerPhysics.Factories.FixtureFactory.AttachLineArc(radians, sides, radius, position.$clone(), angle, closed, body);
                    return body;
                },
                CreateSolidArc: function (world, density, radians, sides, radius, position, angle) {
                    var body = FarseerPhysics.Factories.BodyFactory.CreateBody(world);
                    FarseerPhysics.Factories.FixtureFactory.AttachSolidArc(density, radians, sides, radius, position.$clone(), angle, body);
                    return body;
                }
            }
        }
    });

    /** @namespace FarseerPhysics.Factories */

    /**
     * An easy to use factory for creating bodies
     *
     * @static
     * @abstract
     * @public
     * @class FarseerPhysics.Factories.FixtureFactory
     */
    Bridge.define("FarseerPhysics.Factories.FixtureFactory", {
        statics: {
            methods: {
                AttachEdge: function (start, end, body) {
                    return FarseerPhysics.Factories.FixtureFactory.AttachEdge$1(start.$clone(), end.$clone(), body, null);
                },
                AttachEdge$1: function (start, end, body, userData) {
                    var edgeShape = new FarseerPhysics.Collision.Shapes.EdgeShape.$ctor1(start.$clone(), end.$clone());
                    return body.CreateFixture$1(edgeShape, userData);
                },
                AttachLoopShape: function (vertices, body) {
                    return FarseerPhysics.Factories.FixtureFactory.AttachLoopShape$1(vertices, body, null);
                },
                AttachLoopShape$1: function (vertices, body, userData) {
                    var shape = new FarseerPhysics.Collision.Shapes.LoopShape.$ctor1(vertices);
                    return body.CreateFixture$1(shape, userData);
                },
                AttachRectangle$1: function (width, height, density, offset, body, userData) {
                    offset = {v:offset};
                    var rectangleVertices = FarseerPhysics.Common.PolygonTools.CreateRectangle(width / 2, height / 2);
                    rectangleVertices.Translate$1(offset);
                    var rectangleShape = new FarseerPhysics.Collision.Shapes.PolygonShape.$ctor1(rectangleVertices, density);
                    return body.CreateFixture$1(rectangleShape, userData);
                },
                AttachRectangle: function (width, height, density, offset, body) {
                    return FarseerPhysics.Factories.FixtureFactory.AttachRectangle$1(width, height, density, offset.$clone(), body, null);
                },
                AttachCircle: function (radius, density, body) {
                    return FarseerPhysics.Factories.FixtureFactory.AttachCircle$3(radius, density, body, null);
                },
                AttachCircle$3: function (radius, density, body, userData) {
                    if (radius <= 0) {
                        throw new System.ArgumentOutOfRangeException.$ctor4("radius", "Radius must be more than 0 meters");
                    }

                    var circleShape = new FarseerPhysics.Collision.Shapes.CircleShape.$ctor1(radius, density);
                    return body.CreateFixture$1(circleShape, userData);
                },
                AttachCircle$1: function (radius, density, body, offset) {
                    return FarseerPhysics.Factories.FixtureFactory.AttachCircle$2(radius, density, body, offset.$clone(), null);
                },
                AttachCircle$2: function (radius, density, body, offset, userData) {
                    if (radius <= 0) {
                        throw new System.ArgumentOutOfRangeException.$ctor4("radius", "Radius must be more than 0 meters");
                    }

                    var circleShape = new FarseerPhysics.Collision.Shapes.CircleShape.$ctor1(radius, density);
                    circleShape.Position = offset.$clone();
                    return body.CreateFixture$1(circleShape, userData);
                },
                AttachPolygon: function (vertices, density, body) {
                    return FarseerPhysics.Factories.FixtureFactory.AttachPolygon$1(vertices, density, body, null);
                },
                AttachPolygon$1: function (vertices, density, body, userData) {
                    if (vertices.Count <= 1) {
                        throw new System.ArgumentOutOfRangeException.$ctor4("vertices", "Too few points to be a polygon");
                    }

                    var polygon = new FarseerPhysics.Collision.Shapes.PolygonShape.$ctor1(vertices, density);
                    return body.CreateFixture$1(polygon, userData);
                },
                AttachEllipse: function (xRadius, yRadius, edges, density, body) {
                    return FarseerPhysics.Factories.FixtureFactory.AttachEllipse$1(xRadius, yRadius, edges, density, body, null);
                },
                AttachEllipse$1: function (xRadius, yRadius, edges, density, body, userData) {
                    if (xRadius <= 0) {
                        throw new System.ArgumentOutOfRangeException.$ctor4("xRadius", "X-radius must be more than 0");
                    }

                    if (yRadius <= 0) {
                        throw new System.ArgumentOutOfRangeException.$ctor4("yRadius", "Y-radius must be more than 0");
                    }

                    var ellipseVertices = FarseerPhysics.Common.PolygonTools.CreateEllipse(xRadius, yRadius, edges);
                    var polygonShape = new FarseerPhysics.Collision.Shapes.PolygonShape.$ctor1(ellipseVertices, density);
                    return body.CreateFixture$1(polygonShape, userData);
                },
                AttachCompoundPolygon: function (list, density, body) {
                    return FarseerPhysics.Factories.FixtureFactory.AttachCompoundPolygon$1(list, density, body, null);
                },
                AttachCompoundPolygon$1: function (list, density, body, userData) {
                    var $t;
                    var res = new (System.Collections.Generic.List$1(FarseerPhysics.Dynamics.Fixture)).$ctor2(list.Count);

                    $t = Bridge.getEnumerator(list);
                    try {
                        while ($t.moveNext()) {
                            var vertices = $t.Current;
                            if (vertices.Count === 2) {
                                var shape = new FarseerPhysics.Collision.Shapes.EdgeShape.$ctor1(vertices.getItem(0).$clone(), vertices.getItem(1).$clone());
                                res.add(body.CreateFixture$1(shape, userData));
                            } else {
                                var shape1 = new FarseerPhysics.Collision.Shapes.PolygonShape.$ctor1(vertices, density);
                                res.add(body.CreateFixture$1(shape1, userData));
                            }
                        }
                    } finally {
                        if (Bridge.is($t, System.IDisposable)) {
                            $t.System$IDisposable$Dispose();
                        }
                    }
                    return res;
                },
                AttachLineArc: function (radians, sides, radius, position, angle, closed, body) {
                    position = {v:position};
                    var arc = FarseerPhysics.Common.PolygonTools.CreateArc(radians, sides, radius);
                    arc.Rotate((Microsoft.Xna.Framework.MathHelper.Pi - radians) / 2 + angle);
                    arc.Translate$1(position);

                    var fixtures = new (System.Collections.Generic.List$1(FarseerPhysics.Dynamics.Fixture)).$ctor2(arc.Count);

                    if (closed) {
                        fixtures.add(FarseerPhysics.Factories.FixtureFactory.AttachLoopShape(arc, body));
                    }

                    for (var i = 1; i < arc.Count; i = (i + 1) | 0) {
                        fixtures.add(FarseerPhysics.Factories.FixtureFactory.AttachEdge(arc.getItem(i).$clone(), arc.getItem(((i - 1) | 0)).$clone(), body));
                    }

                    return fixtures;
                },
                AttachSolidArc: function (density, radians, sides, radius, position, angle, body) {
                    position = {v:position};
                    var arc = FarseerPhysics.Common.PolygonTools.CreateArc(radians, sides, radius);
                    arc.Rotate((Microsoft.Xna.Framework.MathHelper.Pi - radians) / 2 + angle);

                    arc.Translate$1(position);

                    arc.add(arc.getItem(0).$clone());

                    var triangles = FarseerPhysics.Common.Decomposition.EarclipDecomposer.ConvexPartition(arc);

                    return FarseerPhysics.Factories.FixtureFactory.AttachCompoundPolygon(triangles, density, body);
                }
            }
        }
    });

    /**
     * An easy to use factory for using joints.
     *
     * @static
     * @abstract
     * @public
     * @class FarseerPhysics.Factories.JointFactory
     */
    Bridge.define("FarseerPhysics.Factories.JointFactory", {
        statics: {
            methods: {
                /**
                 * Creates a revolute joint.
                 *
                 * @static
                 * @public
                 * @this FarseerPhysics.Factories.JointFactory
                 * @memberof FarseerPhysics.Factories.JointFactory
                 * @param   {FarseerPhysics.Dynamics.Body}                    bodyA           
                 * @param   {FarseerPhysics.Dynamics.Body}                    bodyB           
                 * @param   {Microsoft.Xna.Framework.Vector2}                 localAnchorB    The anchor of bodyB in local coordinates
                 * @return  {FarseerPhysics.Dynamics.Joints.RevoluteJoint}
                 */
                CreateRevoluteJoint: function (bodyA, bodyB, localAnchorB) {
                    var localanchorA = bodyA.GetLocalPoint(bodyB.GetWorldPoint(localAnchorB.$clone()));
                    var joint = new FarseerPhysics.Dynamics.Joints.RevoluteJoint.$ctor1(bodyA, bodyB, localanchorA.$clone(), localAnchorB.$clone());
                    return joint;
                },
                /**
                 * Creates a revolute joint and adds it to the world
                 *
                 * @static
                 * @public
                 * @this FarseerPhysics.Factories.JointFactory
                 * @memberof FarseerPhysics.Factories.JointFactory
                 * @param   {FarseerPhysics.Dynamics.World}                   world     
                 * @param   {FarseerPhysics.Dynamics.Body}                    bodyA     
                 * @param   {FarseerPhysics.Dynamics.Body}                    bodyB     
                 * @param   {Microsoft.Xna.Framework.Vector2}                 anchor
                 * @return  {FarseerPhysics.Dynamics.Joints.RevoluteJoint}
                 */
                CreateRevoluteJoint$1: function (world, bodyA, bodyB, anchor) {
                    var joint = FarseerPhysics.Factories.JointFactory.CreateRevoluteJoint(bodyA, bodyB, anchor.$clone());
                    world.AddJoint(joint);
                    return joint;
                },
                /**
                 * Creates the fixed revolute joint.
                 *
                 * @static
                 * @public
                 * @this FarseerPhysics.Factories.JointFactory
                 * @memberof FarseerPhysics.Factories.JointFactory
                 * @param   {FarseerPhysics.Dynamics.World}                        world          The world.
                 * @param   {FarseerPhysics.Dynamics.Body}                         body           The body.
                 * @param   {Microsoft.Xna.Framework.Vector2}                      bodyAnchor     The body anchor.
                 * @param   {Microsoft.Xna.Framework.Vector2}                      worldAnchor    The world anchor.
                 * @return  {FarseerPhysics.Dynamics.Joints.FixedRevoluteJoint}
                 */
                CreateFixedRevoluteJoint: function (world, body, bodyAnchor, worldAnchor) {
                    var fixedRevoluteJoint = new FarseerPhysics.Dynamics.Joints.FixedRevoluteJoint(body, bodyAnchor.$clone(), worldAnchor.$clone());
                    world.AddJoint(fixedRevoluteJoint);
                    return fixedRevoluteJoint;
                },
                /**
                 * Creates a weld joint
                 *
                 * @static
                 * @public
                 * @this FarseerPhysics.Factories.JointFactory
                 * @memberof FarseerPhysics.Factories.JointFactory
                 * @param   {FarseerPhysics.Dynamics.Body}                bodyA          
                 * @param   {FarseerPhysics.Dynamics.Body}                bodyB          
                 * @param   {Microsoft.Xna.Framework.Vector2}             localAnchor
                 * @return  {FarseerPhysics.Dynamics.Joints.WeldJoint}
                 */
                CreateWeldJoint: function (bodyA, bodyB, localAnchor) {
                    var joint = new FarseerPhysics.Dynamics.Joints.WeldJoint.$ctor1(bodyA, bodyB, bodyA.GetLocalPoint(localAnchor.$clone()), bodyB.GetLocalPoint(localAnchor.$clone()));
                    return joint;
                },
                /**
                 * Creates a weld joint and adds it to the world
                 *
                 * @static
                 * @public
                 * @this FarseerPhysics.Factories.JointFactory
                 * @memberof FarseerPhysics.Factories.JointFactory
                 * @param   {FarseerPhysics.Dynamics.World}               world           
                 * @param   {FarseerPhysics.Dynamics.Body}                bodyA           
                 * @param   {FarseerPhysics.Dynamics.Body}                bodyB           
                 * @param   {Microsoft.Xna.Framework.Vector2}             localanchorB
                 * @return  {FarseerPhysics.Dynamics.Joints.WeldJoint}
                 */
                CreateWeldJoint$1: function (world, bodyA, bodyB, localanchorB) {
                    var joint = FarseerPhysics.Factories.JointFactory.CreateWeldJoint(bodyA, bodyB, localanchorB.$clone());
                    world.AddJoint(joint);
                    return joint;
                },
                CreateWeldJoint$2: function (world, bodyA, bodyB, localAnchorA, localAnchorB) {
                    var weldJoint = new FarseerPhysics.Dynamics.Joints.WeldJoint.$ctor1(bodyA, bodyB, localAnchorA.$clone(), localAnchorB.$clone());
                    world.AddJoint(weldJoint);
                    return weldJoint;
                },
                /**
                 * Creates a prsimatic joint
                 *
                 * @static
                 * @public
                 * @this FarseerPhysics.Factories.JointFactory
                 * @memberof FarseerPhysics.Factories.JointFactory
                 * @param   {FarseerPhysics.Dynamics.Body}                     bodyA           
                 * @param   {FarseerPhysics.Dynamics.Body}                     bodyB           
                 * @param   {Microsoft.Xna.Framework.Vector2}                  localanchorB    
                 * @param   {Microsoft.Xna.Framework.Vector2}                  axis
                 * @return  {FarseerPhysics.Dynamics.Joints.PrismaticJoint}
                 */
                CreatePrismaticJoint: function (bodyA, bodyB, localanchorB, axis) {
                    var localanchorA = bodyA.GetLocalPoint(bodyB.GetWorldPoint(localanchorB.$clone()));
                    var joint = new FarseerPhysics.Dynamics.Joints.PrismaticJoint.$ctor1(bodyA, bodyB, localanchorA.$clone(), localanchorB.$clone(), axis.$clone());
                    return joint;
                },
                /**
                 * Creates a prismatic joint and adds it to the world
                 *
                 * @static
                 * @public
                 * @this FarseerPhysics.Factories.JointFactory
                 * @memberof FarseerPhysics.Factories.JointFactory
                 * @param   {FarseerPhysics.Dynamics.World}                    world           
                 * @param   {FarseerPhysics.Dynamics.Body}                     bodyA           
                 * @param   {FarseerPhysics.Dynamics.Body}                     bodyB           
                 * @param   {Microsoft.Xna.Framework.Vector2}                  localanchorB    
                 * @param   {Microsoft.Xna.Framework.Vector2}                  axis
                 * @return  {FarseerPhysics.Dynamics.Joints.PrismaticJoint}
                 */
                CreatePrismaticJoint$1: function (world, bodyA, bodyB, localanchorB, axis) {
                    var joint = FarseerPhysics.Factories.JointFactory.CreatePrismaticJoint(bodyA, bodyB, localanchorB.$clone(), axis.$clone());
                    world.AddJoint(joint);
                    return joint;
                },
                CreateFixedPrismaticJoint: function (world, body, worldAnchor, axis) {
                    var joint = new FarseerPhysics.Dynamics.Joints.FixedPrismaticJoint(body, worldAnchor.$clone(), axis.$clone());
                    world.AddJoint(joint);
                    return joint;
                },
                /**
                 * Creates a line joint
                 *
                 * @static
                 * @public
                 * @this FarseerPhysics.Factories.JointFactory
                 * @memberof FarseerPhysics.Factories.JointFactory
                 * @param   {FarseerPhysics.Dynamics.Body}                bodyA     
                 * @param   {FarseerPhysics.Dynamics.Body}                bodyB     
                 * @param   {Microsoft.Xna.Framework.Vector2}             anchor    
                 * @param   {Microsoft.Xna.Framework.Vector2}             axis
                 * @return  {FarseerPhysics.Dynamics.Joints.LineJoint}
                 */
                CreateLineJoint: function (bodyA, bodyB, anchor, axis) {
                    var joint = new FarseerPhysics.Dynamics.Joints.LineJoint.$ctor1(bodyA, bodyB, anchor.$clone(), axis.$clone());
                    return joint;
                },
                /**
                 * Creates a line joint and adds it to the world
                 *
                 * @static
                 * @public
                 * @this FarseerPhysics.Factories.JointFactory
                 * @memberof FarseerPhysics.Factories.JointFactory
                 * @param   {FarseerPhysics.Dynamics.World}               world           
                 * @param   {FarseerPhysics.Dynamics.Body}                bodyA           
                 * @param   {FarseerPhysics.Dynamics.Body}                bodyB           
                 * @param   {Microsoft.Xna.Framework.Vector2}             localanchorB    
                 * @param   {Microsoft.Xna.Framework.Vector2}             axis
                 * @return  {FarseerPhysics.Dynamics.Joints.LineJoint}
                 */
                CreateLineJoint$1: function (world, bodyA, bodyB, localanchorB, axis) {
                    var joint = FarseerPhysics.Factories.JointFactory.CreateLineJoint(bodyA, bodyB, localanchorB.$clone(), axis.$clone());
                    world.AddJoint(joint);
                    return joint;
                },
                /**
                 * Creates an angle joint.
                 *
                 * @static
                 * @public
                 * @this FarseerPhysics.Factories.JointFactory
                 * @memberof FarseerPhysics.Factories.JointFactory
                 * @param   {FarseerPhysics.Dynamics.World}                world    The world.
                 * @param   {FarseerPhysics.Dynamics.Body}                 bodyA    The first body.
                 * @param   {FarseerPhysics.Dynamics.Body}                 bodyB    The second body.
                 * @return  {FarseerPhysics.Dynamics.Joints.AngleJoint}
                 */
                CreateAngleJoint: function (world, bodyA, bodyB) {
                    var angleJoint = new FarseerPhysics.Dynamics.Joints.AngleJoint.$ctor1(bodyA, bodyB);
                    world.AddJoint(angleJoint);

                    return angleJoint;
                },
                /**
                 * Creates a fixed angle joint.
                 *
                 * @static
                 * @public
                 * @this FarseerPhysics.Factories.JointFactory
                 * @memberof FarseerPhysics.Factories.JointFactory
                 * @param   {FarseerPhysics.Dynamics.World}                     world    The world.
                 * @param   {FarseerPhysics.Dynamics.Body}                      body     The body.
                 * @return  {FarseerPhysics.Dynamics.Joints.FixedAngleJoint}
                 */
                CreateFixedAngleJoint: function (world, body) {
                    var angleJoint = new FarseerPhysics.Dynamics.Joints.FixedAngleJoint(body);
                    world.AddJoint(angleJoint);

                    return angleJoint;
                },
                CreateDistanceJoint: function (world, bodyA, bodyB, anchorA, anchorB) {
                    var distanceJoint = new FarseerPhysics.Dynamics.Joints.DistanceJoint.$ctor1(bodyA, bodyB, anchorA.$clone(), anchorB.$clone());
                    world.AddJoint(distanceJoint);
                    return distanceJoint;
                },
                CreateFixedDistanceJoint: function (world, body, localAnchor, worldAnchor) {
                    var distanceJoint = new FarseerPhysics.Dynamics.Joints.FixedDistanceJoint(body, localAnchor.$clone(), worldAnchor.$clone());
                    world.AddJoint(distanceJoint);
                    return distanceJoint;
                },
                CreateFrictionJoint: function (world, bodyA, bodyB, anchorA, anchorB) {
                    var frictionJoint = new FarseerPhysics.Dynamics.Joints.FrictionJoint.$ctor1(bodyA, bodyB, anchorA.$clone(), anchorB.$clone());
                    world.AddJoint(frictionJoint);
                    return frictionJoint;
                },
                CreateFixedFrictionJoint: function (world, body, bodyAnchor) {
                    var frictionJoint = new FarseerPhysics.Dynamics.Joints.FixedFrictionJoint(body, bodyAnchor.$clone());
                    world.AddJoint(frictionJoint);
                    return frictionJoint;
                },
                CreateGearJoint: function (world, jointA, jointB, ratio) {
                    var gearJoint = new FarseerPhysics.Dynamics.Joints.GearJoint(jointA, jointB, ratio);
                    world.AddJoint(gearJoint);
                    return gearJoint;
                },
                CreatePulleyJoint: function (world, bodyA, bodyB, groundAnchorA, groundAnchorB, anchorA, anchorB, ratio) {
                    var pulleyJoint = new FarseerPhysics.Dynamics.Joints.PulleyJoint.$ctor1(bodyA, bodyB, groundAnchorA.$clone(), groundAnchorB.$clone(), anchorA.$clone(), anchorB.$clone(), ratio);
                    world.AddJoint(pulleyJoint);
                    return pulleyJoint;
                },
                CreateSliderJoint: function (world, bodyA, bodyB, anchorA, anchorB, minLength, maxLength) {
                    var sliderJoint = new FarseerPhysics.Dynamics.Joints.SliderJoint.$ctor1(bodyA, bodyB, anchorA.$clone(), anchorB.$clone(), minLength, maxLength);
                    world.AddJoint(sliderJoint);
                    return sliderJoint;
                }
            }
        }
    });

    Bridge.define("FarseerPhysics.Settings", {
        statics: {
            fields: {
                MaxFloat: 0,
                Epsilon: 0,
                Pi: 0,
                /**
                 * Enabling diagnistics causes the engine to gather timing information.
                 You can see how much time it took to solve the contacts, solve CCD
                 and update the controllers.
                 NOTE: If you are using a debug view that shows performance counters,
                 you might want to enable this.
                 *
                 * @static
                 * @public
                 * @memberof FarseerPhysics.Settings
                 * @default true
                 * @type boolean
                 */
                EnableDiagnostics: false,
                /**
                 * The number of velocity iterations used in the solver.
                 *
                 * @static
                 * @public
                 * @memberof FarseerPhysics.Settings
                 * @default 8
                 * @type number
                 */
                VelocityIterations: 0,
                /**
                 * The number of position iterations used in the solver.
                 *
                 * @static
                 * @public
                 * @memberof FarseerPhysics.Settings
                 * @default 3
                 * @type number
                 */
                PositionIterations: 0,
                /**
                 * Enable/Disable Continuous Collision Detection (CCD)
                 *
                 * @static
                 * @public
                 * @memberof FarseerPhysics.Settings
                 * @default true
                 * @type boolean
                 */
                ContinuousPhysics: false,
                /**
                 * The number of velocity iterations in the TOI solver
                 *
                 * @static
                 * @public
                 * @memberof FarseerPhysics.Settings
                 * @default 8
                 * @type number
                 */
                TOIVelocityIterations: 0,
                /**
                 * The number of position iterations in the TOI solver
                 *
                 * @static
                 * @public
                 * @memberof FarseerPhysics.Settings
                 * @default 20
                 * @type number
                 */
                TOIPositionIterations: 0,
                /**
                 * Maximum number of sub-steps per contact in continuous physics simulation.
                 *
                 * @static
                 * @public
                 * @memberof FarseerPhysics.Settings
                 * @constant
                 * @default 8
                 * @type number
                 */
                MaxSubSteps: 0,
                /**
                 * Enable/Disable warmstarting
                 *
                 * @static
                 * @public
                 * @memberof FarseerPhysics.Settings
                 * @default true
                 * @type boolean
                 */
                EnableWarmstarting: false,
                /**
                 * Enable/Disable sleeping
                 *
                 * @static
                 * @public
                 * @memberof FarseerPhysics.Settings
                 * @default true
                 * @type boolean
                 */
                AllowSleep: false,
                /**
                 * The maximum number of vertices on a convex polygon.
                 *
                 * @static
                 * @public
                 * @memberof FarseerPhysics.Settings
                 * @default 30
                 * @type number
                 */
                MaxPolygonVertices: 0,
                /**
                 * Farseer Physics Engine has a different way of filtering fixtures than Box2d.
                 We have both FPE and Box2D filtering in the engine. If you are upgrading
                 from earlier versions of FPE, set this to true.
                 *
                 * @static
                 * @public
                 * @memberof FarseerPhysics.Settings
                 * @type boolean
                 */
                UseFPECollisionCategories: false,
                /**
                 * Conserve memory makes sure that objects are used by reference instead of cloned.
                 When you give a vertices collection to a PolygonShape, it will by default copy the vertices
                 instead of using the original reference. This is to ensure that objects modified outside the engine
                 does not affect the engine itself, however, this uses extra memory. This behavior
                 can be turned off by setting ConserveMemory to true.
                 *
                 * @static
                 * @public
                 * @memberof FarseerPhysics.Settings
                 * @constant
                 * @default false
                 * @type boolean
                 */
                ConserveMemory: false,
                /**
                 * The maximum number of contact points between two convex shapes.
                 *
                 * @static
                 * @public
                 * @memberof FarseerPhysics.Settings
                 * @constant
                 * @default 2
                 * @type number
                 */
                MaxManifoldPoints: 0,
                /**
                 * This is used to fatten AABBs in the dynamic tree. This allows proxies
                 to move by a small amount without triggering a tree adjustment.
                 This is in meters.
                 *
                 * @static
                 * @public
                 * @memberof FarseerPhysics.Settings
                 * @constant
                 * @default 0.1
                 * @type number
                 */
                AABBExtension: 0,
                /**
                 * This is used to fatten AABBs in the dynamic tree. This is used to predict
                 the future position based on the current displacement.
                 This is a dimensionless multiplier.
                 *
                 * @static
                 * @public
                 * @memberof FarseerPhysics.Settings
                 * @constant
                 * @default 2.0
                 * @type number
                 */
                AABBMultiplier: 0,
                /**
                 * A small length used as a collision and constraint tolerance. Usually it is
                 chosen to be numerically significant, but visually insignificant.
                 *
                 * @static
                 * @public
                 * @memberof FarseerPhysics.Settings
                 * @constant
                 * @default 0.005
                 * @type number
                 */
                LinearSlop: 0,
                /**
                 * A small angle used as a collision and constraint tolerance. Usually it is
                 chosen to be numerically significant, but visually insignificant.
                 *
                 * @static
                 * @public
                 * @memberof FarseerPhysics.Settings
                 * @constant
                 * @default 0.03490659
                 * @type number
                 */
                AngularSlop: 0,
                /**
                 * The radius of the polygon/edge shape skin. This should not be modified. Making
                 this smaller means polygons will have an insufficient buffer for continuous collision.
                 Making it larger may create artifacts for vertex collision.
                 *
                 * @static
                 * @public
                 * @memberof FarseerPhysics.Settings
                 * @constant
                 * @default 0.01
                 * @type number
                 */
                PolygonRadius: 0,
                /**
                 * Maximum number of contacts to be handled to solve a TOI impact.
                 *
                 * @static
                 * @public
                 * @memberof FarseerPhysics.Settings
                 * @constant
                 * @default 50
                 * @type number
                 */
                MaxTOIContacts: 0,
                /**
                 * A velocity threshold for elastic collisions. Any collision with a relative linear
                 velocity below this threshold will be treated as inelastic.
                 *
                 * @static
                 * @public
                 * @memberof FarseerPhysics.Settings
                 * @constant
                 * @default 1.0
                 * @type number
                 */
                VelocityThreshold: 0,
                /**
                 * The maximum linear position correction used when solving constraints. This helps to
                 prevent overshoot.
                 *
                 * @static
                 * @public
                 * @memberof FarseerPhysics.Settings
                 * @constant
                 * @default 0.2
                 * @type number
                 */
                MaxLinearCorrection: 0,
                /**
                 * The maximum angular position correction used when solving constraints. This helps to
                 prevent overshoot.
                 *
                 * @static
                 * @public
                 * @memberof FarseerPhysics.Settings
                 * @constant
                 * @default 0.139626354
                 * @type number
                 */
                MaxAngularCorrection: 0,
                /**
                 * This scale factor controls how fast overlap is resolved. Ideally this would be 1 so
                 that overlap is removed in one time step. However using values close to 1 often lead
                 to overshoot.
                 *
                 * @static
                 * @public
                 * @memberof FarseerPhysics.Settings
                 * @constant
                 * @default 0.2
                 * @type number
                 */
                ContactBaumgarte: 0,
                /**
                 * The time that a body must be still before it will go to sleep.
                 *
                 * @static
                 * @public
                 * @memberof FarseerPhysics.Settings
                 * @constant
                 * @default 0.5
                 * @type number
                 */
                TimeToSleep: 0,
                /**
                 * A body cannot sleep if its linear velocity is above this tolerance.
                 *
                 * @static
                 * @public
                 * @memberof FarseerPhysics.Settings
                 * @constant
                 * @default 0.01
                 * @type number
                 */
                LinearSleepTolerance: 0,
                /**
                 * A body cannot sleep if its angular velocity is above this tolerance.
                 *
                 * @static
                 * @public
                 * @memberof FarseerPhysics.Settings
                 * @constant
                 * @default 0.03490659
                 * @type number
                 */
                AngularSleepTolerance: 0,
                /**
                 * The maximum linear velocity of a body. This limit is very large and is used
                 to prevent numerical problems. You shouldn't need to adjust this.
                 *
                 * @static
                 * @public
                 * @memberof FarseerPhysics.Settings
                 * @constant
                 * @default 2.0
                 * @type number
                 */
                MaxTranslation: 0,
                MaxTranslationSquared: 0,
                /**
                 * The maximum angular velocity of a body. This limit is very large and is used
                 to prevent numerical problems. You shouldn't need to adjust this.
                 *
                 * @static
                 * @public
                 * @memberof FarseerPhysics.Settings
                 * @constant
                 * @default 1.57079637
                 * @type number
                 */
                MaxRotation: 0,
                MaxRotationSquared: 0
            },
            ctors: {
                init: function () {
                    this.MaxFloat = 3.40282347E+38;
                    this.Epsilon = 1.1920929E-07;
                    this.Pi = 3.14159274;
                    this.EnableDiagnostics = true;
                    this.VelocityIterations = 8;
                    this.PositionIterations = 3;
                    this.ContinuousPhysics = true;
                    this.TOIVelocityIterations = 8;
                    this.TOIPositionIterations = 20;
                    this.MaxSubSteps = 8;
                    this.EnableWarmstarting = true;
                    this.AllowSleep = true;
                    this.MaxPolygonVertices = 30;
                    this.ConserveMemory = false;
                    this.MaxManifoldPoints = 2;
                    this.AABBExtension = 0.1;
                    this.AABBMultiplier = 2.0;
                    this.LinearSlop = 0.005;
                    this.AngularSlop = (0.03490659);
                    this.PolygonRadius = (0.01);
                    this.MaxTOIContacts = 50;
                    this.VelocityThreshold = 1.0;
                    this.MaxLinearCorrection = 0.2;
                    this.MaxAngularCorrection = (0.139626354);
                    this.ContactBaumgarte = 0.2;
                    this.TimeToSleep = 0.5;
                    this.LinearSleepTolerance = 0.01;
                    this.AngularSleepTolerance = (0.03490659);
                    this.MaxTranslation = 2.0;
                    this.MaxTranslationSquared = (4.0);
                    this.MaxRotation = (1.57079637);
                    this.MaxRotationSquared = (2.46740127);
                }
            },
            methods: {
                /**
                 * Friction mixing law. Feel free to customize this.
                 *
                 * @static
                 * @public
                 * @this FarseerPhysics.Settings
                 * @memberof FarseerPhysics.Settings
                 * @param   {number}    friction1    The friction1.
                 * @param   {number}    friction2    The friction2.
                 * @return  {number}
                 */
                MixFriction: function (friction1, friction2) {
                    return Math.sqrt(friction1 * friction2);
                },
                /**
                 * Restitution mixing law. Feel free to customize this.
                 *
                 * @static
                 * @public
                 * @this FarseerPhysics.Settings
                 * @memberof FarseerPhysics.Settings
                 * @param   {number}    restitution1    The restitution1.
                 * @param   {number}    restitution2    The restitution2.
                 * @return  {number}
                 */
                MixRestitution: function (restitution1, restitution2) {
                    return restitution1 > restitution2 ? restitution1 : restitution2;
                }
            }
        }
    });

    Bridge.define("FarseerPhysics.Utility.Camera2D", {
        statics: {
            fields: {
                _minZoom: 0,
                _maxZoom: 0,
                _graphics: null
            },
            ctors: {
                init: function () {
                    this._minZoom = 0.02;
                    this._maxZoom = 20.0;
                }
            }
        },
        fields: {
            _batchView: null,
            _currentPosition: null,
            _currentRotation: 0,
            _currentZoom: 0,
            _maxPosition: null,
            _maxRotation: 0,
            _minPosition: null,
            _minRotation: 0,
            _positionTracking: false,
            _projection: null,
            _rotationTracking: false,
            _targetPosition: null,
            _targetRotation: 0,
            _trackingBody: null,
            _translateCenter: null,
            _view: null
        },
        props: {
            View: {
                get: function () {
                    return this._batchView.$clone();
                }
            },
            SimView: {
                get: function () {
                    return this._view.$clone();
                }
            },
            SimProjection: {
                get: function () {
                    return this._projection.$clone();
                }
            },
            /**
             * The current position of the camera.
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Utility.Camera2D
             * @function Position
             * @type Microsoft.Xna.Framework.Vector2
             */
            Position: {
                get: function () {
                    return FarseerPhysics.Utility.ConvertUnits.ToDisplayUnits(this._currentPosition.$clone());
                },
                set: function (value) {
                    this._targetPosition = FarseerPhysics.Utility.ConvertUnits.ToSimUnits(value.$clone());
                    if (Microsoft.Xna.Framework.Vector2.op_Inequality(this._minPosition.$clone(), this._maxPosition.$clone())) {
                        Microsoft.Xna.Framework.Vector2.Clamp$1(Bridge.ref(this, "_targetPosition"), Bridge.ref(this, "_minPosition"), Bridge.ref(this, "_maxPosition"), Bridge.ref(this, "_targetPosition"));
                    }
                }
            },
            /**
             * The furthest up, and the furthest left the camera can go.
             if this value equals maxPosition, then no clamping will be 
             applied (unless you override that function).
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Utility.Camera2D
             * @function MinPosition
             * @type Microsoft.Xna.Framework.Vector2
             */
            MinPosition: {
                get: function () {
                    return FarseerPhysics.Utility.ConvertUnits.ToDisplayUnits(this._minPosition.$clone());
                },
                set: function (value) {
                    this._minPosition = FarseerPhysics.Utility.ConvertUnits.ToSimUnits(value.$clone());
                }
            },
            /**
             * the furthest down, and the furthest right the camera will go.
             if this value equals minPosition, then no clamping will be 
             applied (unless you override that function).
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Utility.Camera2D
             * @function MaxPosition
             * @type Microsoft.Xna.Framework.Vector2
             */
            MaxPosition: {
                get: function () {
                    return FarseerPhysics.Utility.ConvertUnits.ToDisplayUnits(this._maxPosition.$clone());
                },
                set: function (value) {
                    this._maxPosition = FarseerPhysics.Utility.ConvertUnits.ToSimUnits(value.$clone());
                }
            },
            /**
             * The current rotation of the camera in radians.
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Utility.Camera2D
             * @function Rotation
             * @type number
             */
            Rotation: {
                get: function () {
                    return this._currentRotation;
                },
                set: function (value) {
                    this._targetRotation = value % Microsoft.Xna.Framework.MathHelper.TwoPi;
                    if (this._minRotation !== this._maxRotation) {
                        this._targetRotation = Microsoft.Xna.Framework.MathHelper.Clamp$1(this._targetRotation, this._minRotation, this._maxRotation);
                    }
                }
            },
            /**
             * Gets or sets the minimum rotation in radians.
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Utility.Camera2D
             * @function MinRotation
             * @type number
             */
            MinRotation: {
                get: function () {
                    return this._minRotation;
                },
                set: function (value) {
                    this._minRotation = Microsoft.Xna.Framework.MathHelper.Clamp$1(value, -3.14159274, 0.0);
                }
            },
            /**
             * Gets or sets the maximum rotation in radians.
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Utility.Camera2D
             * @function MaxRotation
             * @type number
             */
            MaxRotation: {
                get: function () {
                    return this._maxRotation;
                },
                set: function (value) {
                    this._maxRotation = Microsoft.Xna.Framework.MathHelper.Clamp$1(value, 0.0, Microsoft.Xna.Framework.MathHelper.Pi);
                }
            },
            /**
             * The current rotation of the camera in radians.
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Utility.Camera2D
             * @function Zoom
             * @type number
             */
            Zoom: {
                get: function () {
                    return this._currentZoom;
                },
                set: function (value) {
                    this._currentZoom = value;
                    this._currentZoom = Microsoft.Xna.Framework.MathHelper.Clamp$1(this._currentZoom, FarseerPhysics.Utility.Camera2D._minZoom, FarseerPhysics.Utility.Camera2D._maxZoom);
                }
            },
            /**
             * the body that this camera is currently tracking. 
             Null if not tracking any.
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Utility.Camera2D
             * @function TrackingBody
             * @type FarseerPhysics.Dynamics.Body
             */
            TrackingBody: {
                get: function () {
                    return this._trackingBody;
                },
                set: function (value) {
                    this._trackingBody = value;
                    if (this._trackingBody != null) {
                        this._positionTracking = true;
                    }
                }
            },
            EnablePositionTracking: {
                get: function () {
                    return this._positionTracking;
                },
                set: function (value) {
                    if (value && this._trackingBody != null) {
                        this._positionTracking = true;
                    } else {
                        this._positionTracking = false;
                    }
                }
            },
            EnableRotationTracking: {
                get: function () {
                    return this._rotationTracking;
                },
                set: function (value) {
                    if (value && this._trackingBody != null) {
                        this._rotationTracking = true;
                    } else {
                        this._rotationTracking = false;
                    }
                }
            },
            EnableTracking: {
                set: function (value) {
                    this.EnablePositionTracking = value;
                    this.EnableRotationTracking = value;
                }
            }
        },
        ctors: {
            init: function () {
                this._batchView = new Microsoft.Xna.Framework.Matrix();
                this._currentPosition = new Microsoft.Xna.Framework.Vector2();
                this._maxPosition = new Microsoft.Xna.Framework.Vector2();
                this._minPosition = new Microsoft.Xna.Framework.Vector2();
                this._projection = new Microsoft.Xna.Framework.Matrix();
                this._targetPosition = new Microsoft.Xna.Framework.Vector2();
                this._translateCenter = new Microsoft.Xna.Framework.Vector2();
                this._view = new Microsoft.Xna.Framework.Matrix();
            },
            /**
             * The constructor for the Camera2D class.
             *
             * @instance
             * @public
             * @this FarseerPhysics.Utility.Camera2D
             * @memberof FarseerPhysics.Utility.Camera2D
             * @param   {Microsoft.Xna.Framework.Graphics.GraphicsDevice}    graphics
             * @return  {void}
             */
            ctor: function (graphics) {
                this.$initialize();
                FarseerPhysics.Utility.Camera2D._graphics = graphics;
                this._projection = Microsoft.Xna.Framework.Matrix.CreateOrthographicOffCenter$1(0.0, FarseerPhysics.Utility.ConvertUnits.ToSimUnits$5(FarseerPhysics.Utility.Camera2D._graphics.Viewport.Width), FarseerPhysics.Utility.ConvertUnits.ToSimUnits$5(FarseerPhysics.Utility.Camera2D._graphics.Viewport.Height), 0.0, 0.0, 1.0);
                this._view = Microsoft.Xna.Framework.Matrix.Identity.$clone();
                this._batchView = Microsoft.Xna.Framework.Matrix.Identity.$clone();

                this._translateCenter = new Microsoft.Xna.Framework.Vector2.$ctor2(FarseerPhysics.Utility.ConvertUnits.ToSimUnits$6(FarseerPhysics.Utility.Camera2D._graphics.Viewport.Width / 2.0), FarseerPhysics.Utility.ConvertUnits.ToSimUnits$6(FarseerPhysics.Utility.Camera2D._graphics.Viewport.Height / 2.0));

                this.ResetCamera();
            }
        },
        methods: {
            MoveCamera: function (amount) {
                this._currentPosition = Microsoft.Xna.Framework.Vector2.op_Addition(this._currentPosition.$clone(), amount.$clone());
                if (Microsoft.Xna.Framework.Vector2.op_Inequality(this._minPosition.$clone(), this._maxPosition.$clone())) {
                    Microsoft.Xna.Framework.Vector2.Clamp$1(Bridge.ref(this, "_currentPosition"), Bridge.ref(this, "_minPosition"), Bridge.ref(this, "_maxPosition"), Bridge.ref(this, "_currentPosition"));
                }
                this._targetPosition = this._currentPosition.$clone();
                this._positionTracking = false;
                this._rotationTracking = false;
            },
            RotateCamera: function (amount) {
                this._currentRotation += amount;
                if (this._minRotation !== this._maxRotation) {
                    this._currentRotation = Microsoft.Xna.Framework.MathHelper.Clamp$1(this._currentRotation, this._minRotation, this._maxRotation);
                }
                this._targetRotation = this._currentRotation;
                this._positionTracking = false;
                this._rotationTracking = false;
            },
            /**
             * Resets the camera to default values.
             *
             * @instance
             * @public
             * @this FarseerPhysics.Utility.Camera2D
             * @memberof FarseerPhysics.Utility.Camera2D
             * @return  {void}
             */
            ResetCamera: function () {
                this._currentPosition = Microsoft.Xna.Framework.Vector2.Zero.$clone();
                this._targetPosition = Microsoft.Xna.Framework.Vector2.Zero.$clone();
                this._minPosition = Microsoft.Xna.Framework.Vector2.Zero.$clone();
                this._maxPosition = Microsoft.Xna.Framework.Vector2.Zero.$clone();

                this._currentRotation = 0.0;
                this._targetRotation = 0.0;
                this._minRotation = -3.14159274;
                this._maxRotation = Microsoft.Xna.Framework.MathHelper.Pi;

                this._positionTracking = false;
                this._rotationTracking = false;

                this._currentZoom = 1.0;

                this.SetView();
            },
            Jump2Target: function () {
                this._currentPosition = this._targetPosition.$clone();
                this._currentRotation = this._targetRotation;

                this.SetView();
            },
            SetView: function () {
                var matRotation = Microsoft.Xna.Framework.Matrix.CreateRotationZ(this._currentRotation);
                var matZoom = Microsoft.Xna.Framework.Matrix.CreateScale$1(this._currentZoom);
                var translateCenter = new Microsoft.Xna.Framework.Vector3.$ctor1(this._translateCenter.$clone(), 0.0);
                var translateBody = new Microsoft.Xna.Framework.Vector3.$ctor1(Microsoft.Xna.Framework.Vector2.op_UnaryNegation(this._currentPosition.$clone()), 0.0);

                this._view = Microsoft.Xna.Framework.Matrix.op_Multiply(Microsoft.Xna.Framework.Matrix.op_Multiply(Microsoft.Xna.Framework.Matrix.op_Multiply(Microsoft.Xna.Framework.Matrix.CreateTranslation(translateBody.$clone()), matRotation.$clone()), matZoom.$clone()), Microsoft.Xna.Framework.Matrix.CreateTranslation(translateCenter.$clone()));

                translateCenter = FarseerPhysics.Utility.ConvertUnits.ToDisplayUnits$2(translateCenter.$clone());
                translateBody = FarseerPhysics.Utility.ConvertUnits.ToDisplayUnits$2(translateBody.$clone());

                this._batchView = Microsoft.Xna.Framework.Matrix.op_Multiply(Microsoft.Xna.Framework.Matrix.op_Multiply(Microsoft.Xna.Framework.Matrix.op_Multiply(Microsoft.Xna.Framework.Matrix.CreateTranslation(translateBody.$clone()), matRotation.$clone()), matZoom.$clone()), Microsoft.Xna.Framework.Matrix.CreateTranslation(translateCenter.$clone()));
            },
            /**
             * Moves the camera forward one timestep.
             *
             * @instance
             * @public
             * @this FarseerPhysics.Utility.Camera2D
             * @memberof FarseerPhysics.Utility.Camera2D
             * @param   {Microsoft.Xna.Framework.GameTime}    gameTime
             * @return  {void}
             */
            Update: function (gameTime) {
                if (this._trackingBody != null) {
                    if (this._positionTracking) {
                        this._targetPosition = this._trackingBody.Position.$clone();
                        if (Microsoft.Xna.Framework.Vector2.op_Inequality(this._minPosition.$clone(), this._maxPosition.$clone())) {
                            Microsoft.Xna.Framework.Vector2.Clamp$1(Bridge.ref(this, "_targetPosition"), Bridge.ref(this, "_minPosition"), Bridge.ref(this, "_maxPosition"), Bridge.ref(this, "_targetPosition"));
                        }
                    }
                    if (this._rotationTracking) {
                        this._targetRotation = -this._trackingBody.Rotation % Microsoft.Xna.Framework.MathHelper.TwoPi;
                        if (this._minRotation !== this._maxRotation) {
                            this._targetRotation = Microsoft.Xna.Framework.MathHelper.Clamp$1(this._targetRotation, this._minRotation, this._maxRotation);
                        }
                    }
                }
                var delta = Microsoft.Xna.Framework.Vector2.op_Subtraction(this._targetPosition.$clone(), this._currentPosition.$clone());
                var distance = delta.Length();
                if (distance > 0.0) {
                    delta = Microsoft.Xna.Framework.Vector2.op_Division$1(delta.$clone(), distance);
                }
                var inertia;
                if (distance < 10.0) {
                    inertia = Math.pow(distance / 10.0, 2.0);
                } else {
                    inertia = 1.0;
                }

                var rotDelta = this._targetRotation - this._currentRotation;

                var rotInertia;
                if (Math.abs(rotDelta) < 5.0) {
                    rotInertia = Math.pow(rotDelta / 5.0, 2.0);
                } else {
                    rotInertia = 1.0;
                }
                if (Math.abs(rotDelta) > 0.0) {
                    rotDelta /= Math.abs(rotDelta);
                }

                this._currentPosition = Microsoft.Xna.Framework.Vector2.op_Addition(this._currentPosition.$clone(), Microsoft.Xna.Framework.Vector2.op_Multiply$1(Microsoft.Xna.Framework.Vector2.op_Multiply$1(Microsoft.Xna.Framework.Vector2.op_Multiply$2(100.0, delta.$clone()), inertia), gameTime.ElapsedGameTime.getTotalSeconds()));
                this._currentRotation += 80.0 * rotDelta * rotInertia * gameTime.ElapsedGameTime.getTotalSeconds();

                this.SetView();
            },
            ConvertScreenToWorld: function (location) {
                var t = new Microsoft.Xna.Framework.Vector3.$ctor1(location.$clone(), 0);

                t = FarseerPhysics.Utility.Camera2D._graphics.Viewport.Unproject(t.$clone(), this._projection.$clone(), this._view.$clone(), Microsoft.Xna.Framework.Matrix.Identity.$clone());

                return new Microsoft.Xna.Framework.Vector2.$ctor2(t.X, t.Y);
            },
            ConvertWorldToScreen: function (location) {
                var t = new Microsoft.Xna.Framework.Vector3.$ctor1(location.$clone(), 0);

                t = FarseerPhysics.Utility.Camera2D._graphics.Viewport.Project(t.$clone(), this._projection.$clone(), this._view.$clone(), Microsoft.Xna.Framework.Matrix.Identity.$clone());

                return new Microsoft.Xna.Framework.Vector2.$ctor2(t.X, t.Y);
            }
        }
    });

    Bridge.define("FarseerPhysics.Utility.Common", {
        statics: {
            methods: {
                GetCompoundPolygonVertices: function (_polygonTexture, _scale, origin) {
                    var $t;
                    var data = System.Array.init(Bridge.Int.mul(_polygonTexture.Width, _polygonTexture.Height), 0, System.UInt32);
                    _polygonTexture.GetData(System.UInt32, data);

                    var textureVertices = FarseerPhysics.Common.PolygonTools.CreatePolygon$1(data, _polygonTexture.Width, false);

                    var centroid = { v : Microsoft.Xna.Framework.Vector2.op_UnaryNegation(textureVertices.GetCentroid()) };
                    textureVertices.Translate$1(centroid);

                    origin.v = Microsoft.Xna.Framework.Vector2.op_UnaryNegation(centroid.v.$clone());

                    textureVertices = FarseerPhysics.Common.PolygonManipulation.SimplifyTools.ReduceByDistance(textureVertices, 4.0);

                    var list = FarseerPhysics.Common.Decomposition.BayazitDecomposer.ConvexPartition(textureVertices);

                    var vertScale = { v : Microsoft.Xna.Framework.Vector2.op_Multiply$1(new Microsoft.Xna.Framework.Vector2.$ctor1(FarseerPhysics.Utility.ConvertUnits.ToSimUnits$5(1)), _scale) };
                    $t = Bridge.getEnumerator(list);
                    try {
                        while ($t.moveNext()) {
                            var vertices = $t.Current;
                            vertices.Scale(vertScale);
                        }
                    } finally {
                        if (Bridge.is($t, System.IDisposable)) {
                            $t.System$IDisposable$Dispose();
                        }
                    }
                    return list;
                },
                GetPolygonVertices: function (_polygonTexture, _scale, origin) {
                    var data = System.Array.init(Bridge.Int.mul(_polygonTexture.Width, _polygonTexture.Height), 0, System.UInt32);
                    _polygonTexture.GetData(System.UInt32, data);

                    var textureVertices = FarseerPhysics.Common.PolygonTools.CreatePolygon$1(data, _polygonTexture.Width, false);

                    var centroid = { v : Microsoft.Xna.Framework.Vector2.op_UnaryNegation(textureVertices.GetCentroid()) };
                    textureVertices.Translate$1(centroid);

                    origin.v = Microsoft.Xna.Framework.Vector2.op_UnaryNegation(centroid.v.$clone());

                    textureVertices = FarseerPhysics.Common.PolygonManipulation.SimplifyTools.CollinearSimplify$1(textureVertices, 10.0);
                    var vertScale = { v : Microsoft.Xna.Framework.Vector2.op_Multiply$1(new Microsoft.Xna.Framework.Vector2.$ctor1(FarseerPhysics.Utility.ConvertUnits.ToSimUnits$5(1)), _scale) };
                    textureVertices.Scale(vertScale);

                    return textureVertices;
                },
                GetAlpha: function (opacity) {
                    return new Microsoft.Xna.Framework.Color.$ctor9(opacity, opacity, opacity, opacity);
                },
                IsRectangleTouch: function (position, origin, rectWidth, rectHeight) {
                    return (position.X >= origin.X - rectWidth / 2 && position.X <= origin.X + rectWidth / 2 && position.Y >= origin.Y - rectHeight / 2 && position.Y <= origin.Y + rectHeight / 2);
                }
            }
        }
    });

    /** @namespace FarseerPhysics.Utility */

    /**
     * Convert units between display and simulation units.
     *
     * @static
     * @abstract
     * @public
     * @class FarseerPhysics.Utility.ConvertUnits
     */
    Bridge.define("FarseerPhysics.Utility.ConvertUnits", {
        statics: {
            fields: {
                _displayUnitsToSimUnitsRatio: 0,
                _simUnitsToDisplayUnitsRatio: 0
            },
            ctors: {
                init: function () {
                    this._displayUnitsToSimUnitsRatio = 100.0;
                    this._simUnitsToDisplayUnitsRatio = 1 / FarseerPhysics.Utility.ConvertUnits._displayUnitsToSimUnitsRatio;
                }
            },
            methods: {
                SetDisplayUnitToSimUnitRatio: function (displayUnitsPerSimUnit) {
                    FarseerPhysics.Utility.ConvertUnits._displayUnitsToSimUnitsRatio = displayUnitsPerSimUnit;
                    FarseerPhysics.Utility.ConvertUnits._simUnitsToDisplayUnitsRatio = 1 / displayUnitsPerSimUnit;
                },
                ToDisplayUnits$4: function (simUnits) {
                    return simUnits * FarseerPhysics.Utility.ConvertUnits._displayUnitsToSimUnitsRatio;
                },
                ToDisplayUnits$3: function (simUnits) {
                    return simUnits * FarseerPhysics.Utility.ConvertUnits._displayUnitsToSimUnitsRatio;
                },
                ToDisplayUnits: function (simUnits) {
                    return Microsoft.Xna.Framework.Vector2.op_Multiply$1(simUnits.$clone(), FarseerPhysics.Utility.ConvertUnits._displayUnitsToSimUnitsRatio);
                },
                ToDisplayUnits$5: function (simUnits, displayUnits) {
                    Microsoft.Xna.Framework.Vector2.Multiply$3(simUnits, FarseerPhysics.Utility.ConvertUnits._displayUnitsToSimUnitsRatio, displayUnits);
                },
                ToDisplayUnits$2: function (simUnits) {
                    return Microsoft.Xna.Framework.Vector3.op_Multiply$1(simUnits.$clone(), FarseerPhysics.Utility.ConvertUnits._displayUnitsToSimUnitsRatio);
                },
                ToDisplayUnits$1: function (x, y) {
                    return Microsoft.Xna.Framework.Vector2.op_Multiply$1(new Microsoft.Xna.Framework.Vector2.$ctor2(x, y), FarseerPhysics.Utility.ConvertUnits._displayUnitsToSimUnitsRatio);
                },
                ToDisplayUnits$6: function (x, y, displayUnits) {
                    displayUnits.v = Microsoft.Xna.Framework.Vector2.Zero.$clone();
                    displayUnits.v.X = x * FarseerPhysics.Utility.ConvertUnits._displayUnitsToSimUnitsRatio;
                    displayUnits.v.Y = y * FarseerPhysics.Utility.ConvertUnits._displayUnitsToSimUnitsRatio;
                },
                ToSimUnits$6: function (displayUnits) {
                    return displayUnits * FarseerPhysics.Utility.ConvertUnits._simUnitsToDisplayUnitsRatio;
                },
                ToSimUnits$4: function (displayUnits) {
                    return displayUnits * FarseerPhysics.Utility.ConvertUnits._simUnitsToDisplayUnitsRatio;
                },
                ToSimUnits$5: function (displayUnits) {
                    return displayUnits * FarseerPhysics.Utility.ConvertUnits._simUnitsToDisplayUnitsRatio;
                },
                ToSimUnits: function (displayUnits) {
                    return Microsoft.Xna.Framework.Vector2.op_Multiply$1(displayUnits.$clone(), FarseerPhysics.Utility.ConvertUnits._simUnitsToDisplayUnitsRatio);
                },
                ToSimUnits$3: function (displayUnits) {
                    return Microsoft.Xna.Framework.Vector3.op_Multiply$1(displayUnits.$clone(), FarseerPhysics.Utility.ConvertUnits._simUnitsToDisplayUnitsRatio);
                },
                ToSimUnits$7: function (displayUnits, simUnits) {
                    Microsoft.Xna.Framework.Vector2.Multiply$3(displayUnits, FarseerPhysics.Utility.ConvertUnits._simUnitsToDisplayUnitsRatio, simUnits);
                },
                ToSimUnits$2: function (x, y) {
                    return Microsoft.Xna.Framework.Vector2.op_Multiply$1(new Microsoft.Xna.Framework.Vector2.$ctor2(x, y), FarseerPhysics.Utility.ConvertUnits._simUnitsToDisplayUnitsRatio);
                },
                ToSimUnits$1: function (x, y) {
                    return Microsoft.Xna.Framework.Vector2.op_Multiply$1(new Microsoft.Xna.Framework.Vector2.$ctor2(x, y), FarseerPhysics.Utility.ConvertUnits._simUnitsToDisplayUnitsRatio);
                },
                ToSimUnits$8: function (x, y, simUnits) {
                    simUnits.v = Microsoft.Xna.Framework.Vector2.Zero.$clone();
                    simUnits.v.X = x * FarseerPhysics.Utility.ConvertUnits._simUnitsToDisplayUnitsRatio;
                    simUnits.v.Y = y * FarseerPhysics.Utility.ConvertUnits._simUnitsToDisplayUnitsRatio;
                }
            }
        }
    });

    /**
     * A screen is a single layer that has update and draw logic, and which
     can be combined with other layers to build up a complex menu system.
     For instance the main menu, the options menu, the "are you sure you
     want to quit" message box, and the main game itself are all implemented
     as screens.
     *
     * @abstract
     * @public
     * @class FarseerPhysics.Utility.GameScreen
     */
    Bridge.define("FarseerPhysics.Utility.GameScreen", {
        fields: {
            _enabledGestures: 0,
            _otherScreenHasFocus: false,
            HasCursor: false,
            HasVirtualStick: false,
            /**
             * Normally when one screen is brought up over the top of another,
             the first screen will transition off to make room for the new
             one. This property indicates whether the screen is only a small
             popup, in which case screens underneath it do not need to bother
             transitioning off.
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Utility.GameScreen
             * @function IsPopup
             * @type boolean
             */
            IsPopup: false,
            /**
             * Indicates how long the screen takes to
             transition on when it is activated.
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Utility.GameScreen
             * @function TransitionOnTime
             * @type System.TimeSpan
             */
            TransitionOnTime: null,
            /**
             * Indicates how long the screen takes to
             transition off when it is deactivated.
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Utility.GameScreen
             * @function TransitionOffTime
             * @type System.TimeSpan
             */
            TransitionOffTime: null,
            /**
             * Gets the current position of the screen transition, ranging
             from zero (fully active, no transition) to one (transitioned
             fully off to nothing).
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Utility.GameScreen
             * @function TransitionPosition
             * @type number
             */
            TransitionPosition: 0,
            /**
             * Gets the current screen transition state.
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Utility.GameScreen
             * @function ScreenState
             * @type FarseerPhysics.Utility.ScreenState
             */
            ScreenState: 0,
            /**
             * There are two possible reasons why a screen might be transitioning
             off. It could be temporarily going away to make room for another
             screen that is on top of it, or it could be going away for good.
             This property indicates whether the screen is exiting for real:
             if set, the screen will automatically remove itself as soon as the
             transition finishes.
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Utility.GameScreen
             * @function IsExiting
             * @type boolean
             */
            IsExiting: false,
            /**
             * Gets the manager that this screen belongs to.
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Utility.GameScreen
             * @function ScreenManager
             * @type FarseerPhysics.Utility.ScreenManager
             */
            ScreenManager: null
        },
        props: {
            /**
             * Gets the current alpha of the screen transition, ranging
             from 1 (fully active, no transition) to 0 (transitioned
             fully off to nothing).
             *
             * @instance
             * @public
             * @readonly
             * @memberof FarseerPhysics.Utility.GameScreen
             * @function TransitionAlpha
             * @type number
             */
            TransitionAlpha: {
                get: function () {
                    return 1.0 - this.TransitionPosition;
                }
            },
            /**
             * Checks whether this screen is active and can respond to user input.
             *
             * @instance
             * @public
             * @readonly
             * @memberof FarseerPhysics.Utility.GameScreen
             * @function IsActive
             * @type boolean
             */
            IsActive: {
                get: function () {
                    return !this._otherScreenHasFocus && (this.ScreenState === FarseerPhysics.Utility.ScreenState.TransitionOn || this.ScreenState === FarseerPhysics.Utility.ScreenState.Active);
                }
            },
            /**
             * Gets the gestures the screen is interested in. Screens should be as specific
             as possible with gestures to increase the accuracy of the gesture engine.
             For example, most menus only need Tap or perhaps Tap and VerticalDrag to operate.
             These gestures are handled by the ScreenManager when screens change and
             all gestures are placed in the InputState passed to the HandleInput method.
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Utility.GameScreen
             * @function EnabledGestures
             * @type Microsoft.Xna.Framework.Input.Touch.GestureType
             */
            EnabledGestures: {
                get: function () {
                    return this._enabledGestures;
                },
                set: function (value) {
                    this._enabledGestures = value;

                    if (this.ScreenState === FarseerPhysics.Utility.ScreenState.Active) {
                        Microsoft.Xna.Framework.Input.Touch.TouchPanel.EnabledGestures = value;
                    }
                }
            }
        },
        ctors: {
            init: function () {
                this.TransitionOnTime = new System.TimeSpan();
                this.TransitionOffTime = new System.TimeSpan();
                this._enabledGestures = Microsoft.Xna.Framework.Input.Touch.GestureType.None;
            },
            ctor: function () {
                this.$initialize();
                this.ScreenState = FarseerPhysics.Utility.ScreenState.TransitionOn;
                this.TransitionPosition = 1;
                this.TransitionOffTime = System.TimeSpan.zero;
                this.TransitionOnTime = System.TimeSpan.zero;
                this.HasCursor = false;
                this.HasVirtualStick = false;
            }
        },
        methods: {
            /**
             * Load graphics content for the screen.
             *
             * @instance
             * @public
             * @this FarseerPhysics.Utility.GameScreen
             * @memberof FarseerPhysics.Utility.GameScreen
             * @return  {void}
             */
            LoadContent: function () { },
            /**
             * Unload content for the screen.
             *
             * @instance
             * @public
             * @this FarseerPhysics.Utility.GameScreen
             * @memberof FarseerPhysics.Utility.GameScreen
             * @return  {void}
             */
            UnloadContent: function () { },
            /**
             * Allows the screen to run logic, such as updating the transition position.
             Unlike HandleInput, this method is called regardless of whether the screen
             is active, hidden, or in the middle of a transition.
             *
             * @instance
             * @public
             * @this FarseerPhysics.Utility.GameScreen
             * @memberof FarseerPhysics.Utility.GameScreen
             * @param   {Microsoft.Xna.Framework.GameTime}    gameTime                
             * @param   {boolean}                             otherScreenHasFocus     
             * @param   {boolean}                             coveredByOtherScreen
             * @return  {void}
             */
            Update: function (gameTime, otherScreenHasFocus, coveredByOtherScreen) {
                this._otherScreenHasFocus = otherScreenHasFocus;
                if (this.IsExiting) {
                    this.ScreenState = FarseerPhysics.Utility.ScreenState.TransitionOff;

                    if (!this.UpdateTransition(gameTime, this.TransitionOffTime, 1)) {
                        this.ScreenManager.RemoveScreen(this);
                    }
                } else if (coveredByOtherScreen) {
                    if (this.UpdateTransition(gameTime, this.TransitionOffTime, 1)) {
                        this.ScreenState = FarseerPhysics.Utility.ScreenState.TransitionOff;
                    } else {
                        this.ScreenState = FarseerPhysics.Utility.ScreenState.Hidden;
                    }
                } else {
                    if (this.UpdateTransition(gameTime, this.TransitionOnTime, -1)) {
                        this.ScreenState = FarseerPhysics.Utility.ScreenState.TransitionOn;
                    } else {
                        this.ScreenState = FarseerPhysics.Utility.ScreenState.Active;
                    }
                }
            },
            /**
             * Helper for updating the screen transition position.
             *
             * @instance
             * @private
             * @this FarseerPhysics.Utility.GameScreen
             * @memberof FarseerPhysics.Utility.GameScreen
             * @param   {Microsoft.Xna.Framework.GameTime}    gameTime     
             * @param   {System.TimeSpan}                     time         
             * @param   {number}                              direction
             * @return  {boolean}
             */
            UpdateTransition: function (gameTime, time, direction) {
                var transitionDelta;

                if (System.TimeSpan.eq(time, System.TimeSpan.zero)) {
                    transitionDelta = 1.0;
                } else {
                    transitionDelta = gameTime.ElapsedGameTime.getTotalMilliseconds() / time.getTotalMilliseconds();
                }

                this.TransitionPosition += transitionDelta * direction;

                if (((direction < 0) && (this.TransitionPosition <= 0)) || ((direction > 0) && (this.TransitionPosition >= 1))) {
                    this.TransitionPosition = Microsoft.Xna.Framework.MathHelper.Clamp$1(this.TransitionPosition, 0, 1);
                    return false;
                }

                return true;
            },
            /**
             * This is called when the screen should draw itself.
             *
             * @instance
             * @public
             * @this FarseerPhysics.Utility.GameScreen
             * @memberof FarseerPhysics.Utility.GameScreen
             * @param   {Microsoft.Xna.Framework.GameTime}    gameTime
             * @return  {void}
             */
            Draw: function (gameTime) { },
            /**
             * Tells the screen to go away. Unlike ScreenManager.RemoveScreen, which
             instantly kills the screen, this method respects the transition timings
             and will give the screen a chance to gradually transition off.
             *
             * @instance
             * @public
             * @this FarseerPhysics.Utility.GameScreen
             * @memberof FarseerPhysics.Utility.GameScreen
             * @return  {void}
             */
            ExitScreen: function () {
                if (System.TimeSpan.eq(this.TransitionOffTime, System.TimeSpan.zero)) {
                    this.ScreenManager.RemoveScreen(this);
                } else {
                    this.IsExiting = true;
                }
            }
        }
    });

    /**
     * The screen manager is a component which manages one or more GameScreen
     instances. It maintains a stack of screens, calls their Update and Draw
     methods at the appropriate times, and automatically routes input to the
     topmost active screen.
     *
     * @public
     * @class FarseerPhysics.Utility.ScreenManager
     * @augments Microsoft.Xna.Framework.DrawableGameComponent
     */
    Bridge.define("FarseerPhysics.Utility.ScreenManager", {
        inherits: [Microsoft.Xna.Framework.DrawableGameComponent],
        fields: {
            _contentManager: null,
            _isInitialized: false,
            _screens: null,
            _screensToUpdate: null,
            _spriteBatch: null,
            _transitions: null
        },
        props: {
            /**
             * A default SpriteBatch shared by all the screens. This saves
             each screen having to bother creating their own local instance.
             *
             * @instance
             * @public
             * @readonly
             * @memberof FarseerPhysics.Utility.ScreenManager
             * @function SpriteBatch
             * @type Microsoft.Xna.Framework.Graphics.SpriteBatch
             */
            SpriteBatch: {
                get: function () {
                    return this._spriteBatch;
                }
            },
            Content: {
                get: function () {
                    return this._contentManager;
                }
            }
        },
        alias: [
            "Initialize", "Microsoft$Xna$Framework$IGameComponent$Initialize",
            "Draw", "Microsoft$Xna$Framework$IDrawable$Draw"
        ],
        ctors: {
            /**
             * Constructs a new screen manager component.
             *
             * @instance
             * @public
             * @this FarseerPhysics.Utility.ScreenManager
             * @memberof FarseerPhysics.Utility.ScreenManager
             * @param   {Microsoft.Xna.Framework.Game}    game
             * @return  {void}
             */
            ctor: function (game) {
                this.$initialize();
                Microsoft.Xna.Framework.DrawableGameComponent.ctor.call(this, game);
                Microsoft.Xna.Framework.Input.Touch.TouchPanel.EnabledGestures = Microsoft.Xna.Framework.Input.Touch.GestureType.None;
                this._contentManager = game.Content;
                this._contentManager.RootDirectory = "Content";

                this._screens = new (System.Collections.Generic.List$1(FarseerPhysics.Utility.GameScreen)).ctor();
                this._screensToUpdate = new (System.Collections.Generic.List$1(FarseerPhysics.Utility.GameScreen)).ctor();
                this._transitions = new (System.Collections.Generic.List$1(Microsoft.Xna.Framework.Graphics.RenderTarget2D)).ctor();
            }
        },
        methods: {
            /**
             * Initializes the screen manager component.
             *
             * @instance
             * @public
             * @override
             * @this FarseerPhysics.Utility.ScreenManager
             * @memberof FarseerPhysics.Utility.ScreenManager
             * @return  {void}
             */
            Initialize: function () {
                Microsoft.Xna.Framework.DrawableGameComponent.prototype.Initialize.call(this);

                this._isInitialized = true;
            },
            /**
             * Load your graphics content.
             *
             * @instance
             * @protected
             * @override
             * @this FarseerPhysics.Utility.ScreenManager
             * @memberof FarseerPhysics.Utility.ScreenManager
             * @return  {void}
             */
            LoadContent: function () {
                var $t;
                this._spriteBatch = new Microsoft.Xna.Framework.Graphics.SpriteBatch(this.GraphicsDevice);

                $t = Bridge.getEnumerator(this._screens);
                try {
                    while ($t.moveNext()) {
                        var screen = $t.Current;
                        screen.LoadContent();
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }},
            /**
             * Unload your graphics content.
             *
             * @instance
             * @protected
             * @override
             * @this FarseerPhysics.Utility.ScreenManager
             * @memberof FarseerPhysics.Utility.ScreenManager
             * @return  {void}
             */
            UnloadContent: function () {
                var $t;
                $t = Bridge.getEnumerator(this._screens);
                try {
                    while ($t.moveNext()) {
                        var screen = $t.Current;
                        screen.UnloadContent();
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }},
            /**
             * Allows each screen to run logic.
             *
             * @instance
             * @public
             * @override
             * @this FarseerPhysics.Utility.ScreenManager
             * @memberof FarseerPhysics.Utility.ScreenManager
             * @param   {Microsoft.Xna.Framework.GameTime}    gameTime
             * @return  {void}
             */
            Update: function (gameTime) {
                var $t;

                this._screensToUpdate.clear();
                $t = Bridge.getEnumerator(this._screens);
                try {
                    while ($t.moveNext()) {
                        var screen = $t.Current;
                        this._screensToUpdate.add(screen);
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }
                var otherScreenHasFocus = !this.Game.IsActive;
                var coveredByOtherScreen = false;

                while (this._screensToUpdate.Count > 0) {
                    var screen1 = this._screensToUpdate.getItem(((this._screensToUpdate.Count - 1) | 0));

                    this._screensToUpdate.removeAt(((this._screensToUpdate.Count - 1) | 0));

                    screen1.Update(gameTime, otherScreenHasFocus, coveredByOtherScreen);

                    if (screen1.ScreenState === FarseerPhysics.Utility.ScreenState.TransitionOn || screen1.ScreenState === FarseerPhysics.Utility.ScreenState.Active) {
                        if (!otherScreenHasFocus) {
                            otherScreenHasFocus = true;
                        }

                        if (!screen1.IsPopup) {
                            coveredByOtherScreen = true;
                        }
                    }
                }
            },
            /**
             * Tells each screen to draw itself.
             *
             * @instance
             * @public
             * @override
             * @this FarseerPhysics.Utility.ScreenManager
             * @memberof FarseerPhysics.Utility.ScreenManager
             * @param   {Microsoft.Xna.Framework.GameTime}    gameTime
             * @return  {void}
             */
            Draw: function (gameTime) {
                var $t;
                this.GraphicsDevice.Clear(Microsoft.Xna.Framework.Color.Black.$clone());
                $t = Bridge.getEnumerator(this._screens);
                try {
                    while ($t.moveNext()) {
                        var screen = $t.Current;
                        screen.Draw(gameTime);
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }},
            /**
             * Adds a new screen to the screen manager.
             *
             * @instance
             * @public
             * @this FarseerPhysics.Utility.ScreenManager
             * @memberof FarseerPhysics.Utility.ScreenManager
             * @param   {FarseerPhysics.Utility.GameScreen}    screen
             * @return  {void}
             */
            AddScreen: function (screen) {
                screen.ScreenManager = this;
                screen.IsExiting = false;

                if (this._isInitialized) {
                    screen.LoadContent();
                }

                this._screens.add(screen);

                Microsoft.Xna.Framework.Input.Touch.TouchPanel.EnabledGestures = screen.EnabledGestures;
            },
            /**
             * Removes a screen from the screen manager. You should normally
             use GameScreen.ExitScreen instead of calling this directly, so
             the screen can gradually transition off rather than just being
             instantly removed.
             *
             * @instance
             * @public
             * @this FarseerPhysics.Utility.ScreenManager
             * @memberof FarseerPhysics.Utility.ScreenManager
             * @param   {FarseerPhysics.Utility.GameScreen}    screen
             * @return  {void}
             */
            RemoveScreen: function (screen) {
                if (this._isInitialized) {
                    screen.UnloadContent();
                }

                this._screens.remove(screen);
                this._screensToUpdate.remove(screen);

                if (this._screens.Count > 0) {
                    Microsoft.Xna.Framework.Input.Touch.TouchPanel.EnabledGestures = this._screens.getItem(((this._screens.Count - 1) | 0)).EnabledGestures;
                }
            },
            /**
             * Expose an array holding all the screens. We return a copy rather
             than the real master list, because screens should only ever be added
             or removed using the AddScreen and RemoveScreen methods.
             *
             * @instance
             * @public
             * @this FarseerPhysics.Utility.ScreenManager
             * @memberof FarseerPhysics.Utility.ScreenManager
             * @return  {Array.<FarseerPhysics.Utility.GameScreen>}
             */
            GetScreens: function () {
                return this._screens.ToArray();
            }
        }
    });

    /**
     * Enum describes the screen transition state.
     *
     * @public
     * @class FarseerPhysics.Utility.ScreenState
     */
    Bridge.define("FarseerPhysics.Utility.ScreenState", {
        $kind: "enum",
        statics: {
            fields: {
                TransitionOn: 0,
                Active: 1,
                TransitionOff: 2,
                Hidden: 3
            }
        }
    });

    Bridge.define("FarseerPhysics.Utility.Sprite", {
        $kind: "struct",
        statics: {
            methods: {
                getDefaultValue: function () { return new FarseerPhysics.Utility.Sprite(); }
            }
        },
        fields: {
            Origin: null,
            Texture: null
        },
        ctors: {
            init: function () {
                this.Origin = new Microsoft.Xna.Framework.Vector2();
            },
            $ctor2: function (texture, origin) {
                this.$initialize();
                this.Texture = texture;
                this.Origin = origin.$clone();
            },
            $ctor1: function (sprite) {
                this.$initialize();
                this.Texture = sprite;
                this.Origin = new Microsoft.Xna.Framework.Vector2.$ctor2(sprite.Width / 2.0, sprite.Height / 2.0);
            },
            ctor: function () {
                this.$initialize();
            }
        },
        methods: {
            getHashCode: function () {
                var h = Bridge.addHash([1769133511, this.Origin, this.Texture]);
                return h;
            },
            equals: function (o) {
                if (!Bridge.is(o, FarseerPhysics.Utility.Sprite)) {
                    return false;
                }
                return Bridge.equals(this.Origin, o.Origin) && Bridge.equals(this.Texture, o.Texture);
            },
            $clone: function (to) {
                var s = to || new FarseerPhysics.Utility.Sprite();
                s.Origin = this.Origin.$clone();
                s.Texture = this.Texture;
                return s;
            }
        }
    });

    Bridge.define("Poly2Tri.Triangulation.Delaunay.DelaunayTriangle", {
        fields: {
            EdgeIsConstrained: null,
            EdgeIsDelaunay: null,
            Neighbors: null,
            Points: null,
            IsInterior: false
        },
        ctors: {
            init: function () {
                this.EdgeIsConstrained = new Poly2Tri.Triangulation.Util.FixedBitArray3();
                this.EdgeIsDelaunay = new Poly2Tri.Triangulation.Util.FixedBitArray3();
                this.Neighbors = new (Poly2Tri.Triangulation.Util.FixedArray3$1(Poly2Tri.Triangulation.Delaunay.DelaunayTriangle))();
                this.Points = new (Poly2Tri.Triangulation.Util.FixedArray3$1(Poly2Tri.Triangulation.TriangulationPoint))();
            },
            ctor: function (p1, p2, p3) {
                this.$initialize();
                this.Points.setItem(0, p1);
                this.Points.setItem(1, p2);
                this.Points.setItem(2, p3);
            }
        },
        methods: {
            IndexOf: function (p) {
                var i = this.Points.IndexOf(p);
                if (i === -1) {
                    throw new System.Exception("Calling index with a point that doesn't exist in triangle");
                }
                return i;
            },
            IndexCW: function (p) {
                var index = this.IndexOf(p);
                switch (index) {
                    case 0: 
                        return 2;
                    case 1: 
                        return 0;
                    default: 
                        return 1;
                }
            },
            IndexCCW: function (p) {
                var index = this.IndexOf(p);
                switch (index) {
                    case 0: 
                        return 1;
                    case 1: 
                        return 2;
                    default: 
                        return 0;
                }
            },
            Contains$1: function (p) {
                return (Bridge.referenceEquals(p, this.Points.getItem(0)) || Bridge.referenceEquals(p, this.Points.getItem(1)) || Bridge.referenceEquals(p, this.Points.getItem(2)));
            },
            Contains: function (e) {
                return (this.Contains$1(e.P) && this.Contains$1(e.Q));
            },
            Contains$2: function (p, q) {
                return (this.Contains$1(p) && this.Contains$1(q));
            },
            /**
             * Update neighbor pointers
             *
             * @instance
             * @private
             * @this Poly2Tri.Triangulation.Delaunay.DelaunayTriangle
             * @memberof Poly2Tri.Triangulation.Delaunay.DelaunayTriangle
             * @param   {Poly2Tri.Triangulation.TriangulationPoint}           p1    Point 1 of the shared edge
             * @param   {Poly2Tri.Triangulation.TriangulationPoint}           p2    Point 2 of the shared edge
             * @param   {Poly2Tri.Triangulation.Delaunay.DelaunayTriangle}    t     This triangle's new neighbor
             * @return  {void}
             */
            MarkNeighbor$1: function (p1, p2, t) {
                if ((Bridge.referenceEquals(p1, this.Points.getItem(2)) && Bridge.referenceEquals(p2, this.Points.getItem(1))) || (Bridge.referenceEquals(p1, this.Points.getItem(1)) && Bridge.referenceEquals(p2, this.Points.getItem(2)))) {
                    this.Neighbors.setItem(0, t);
                } else if ((Bridge.referenceEquals(p1, this.Points.getItem(0)) && Bridge.referenceEquals(p2, this.Points.getItem(2))) || (Bridge.referenceEquals(p1, this.Points.getItem(2)) && Bridge.referenceEquals(p2, this.Points.getItem(0)))) {
                    this.Neighbors.setItem(1, t);
                } else if ((Bridge.referenceEquals(p1, this.Points.getItem(0)) && Bridge.referenceEquals(p2, this.Points.getItem(1))) || (Bridge.referenceEquals(p1, this.Points.getItem(1)) && Bridge.referenceEquals(p2, this.Points.getItem(0)))) {
                    this.Neighbors.setItem(2, t);
                } else {
                    System.Diagnostics.Debug.WriteLine$2("Neighbor error, please report!");
                }
            },
            /**
             * Exhaustive search to update neighbor pointers
             *
             * @instance
             * @public
             * @this Poly2Tri.Triangulation.Delaunay.DelaunayTriangle
             * @memberof Poly2Tri.Triangulation.Delaunay.DelaunayTriangle
             * @param   {Poly2Tri.Triangulation.Delaunay.DelaunayTriangle}    t
             * @return  {void}
             */
            MarkNeighbor: function (t) {
                if (t.Contains$2(this.Points.getItem(1), this.Points.getItem(2))) {
                    this.Neighbors.setItem(0, t);
                    t.MarkNeighbor$1(this.Points.getItem(1), this.Points.getItem(2), this);
                } else if (t.Contains$2(this.Points.getItem(0), this.Points.getItem(2))) {
                    this.Neighbors.setItem(1, t);
                    t.MarkNeighbor$1(this.Points.getItem(0), this.Points.getItem(2), this);
                } else if (t.Contains$2(this.Points.getItem(0), this.Points.getItem(1))) {
                    this.Neighbors.setItem(2, t);
                    t.MarkNeighbor$1(this.Points.getItem(0), this.Points.getItem(1), this);
                } else {
                    System.Diagnostics.Debug.WriteLine$2("markNeighbor failed");
                }
            },
            ClearNeighbors: function () {
                var $t, $t1;
                this.Neighbors.setItem(0, ($t = ($t1 = null, this.Neighbors.setItem(2, $t1), $t1), this.Neighbors.setItem(1, $t), $t));
            },
            ClearNeighbor: function (triangle) {
                if (Bridge.referenceEquals(this.Neighbors.getItem(0), triangle)) {
                    this.Neighbors.setItem(0, null);
                } else if (Bridge.referenceEquals(this.Neighbors.getItem(1), triangle)) {
                    this.Neighbors.setItem(1, null);
                } else {
                    this.Neighbors.setItem(2, null);
                }
            },
            Clear: function () {
                var $t, $t1;
                var t;
                for (var i = 0; i < 3; i = (i + 1) | 0) {
                    t = this.Neighbors.getItem(i);
                    if (t != null) {
                        t.ClearNeighbor(this);
                    }
                }
                this.ClearNeighbors();
                this.Points.setItem(0, ($t = ($t1 = null, this.Points.setItem(2, $t1), $t1), this.Points.setItem(1, $t), $t));
            },
            /**
             * @instance
             * @public
             * @this Poly2Tri.Triangulation.Delaunay.DelaunayTriangle
             * @memberof Poly2Tri.Triangulation.Delaunay.DelaunayTriangle
             * @param   {Poly2Tri.Triangulation.Delaunay.DelaunayTriangle}    t    Opposite triangle
             * @param   {Poly2Tri.Triangulation.TriangulationPoint}           p    The point in t that isn't shared between the triangles
             * @return  {Poly2Tri.Triangulation.TriangulationPoint}
             */
            OppositePoint: function (t, p) {
                System.Diagnostics.Debug.Assert$1(!Bridge.referenceEquals(t, this), "self-pointer error");
                return this.PointCW(t.PointCW(p));
            },
            NeighborCW: function (point) {
                return this.Neighbors.getItem((((this.Points.IndexOf(point) + 1) | 0)) % 3);
            },
            NeighborCCW: function (point) {
                return this.Neighbors.getItem((((this.Points.IndexOf(point) + 2) | 0)) % 3);
            },
            NeighborAcross: function (point) {
                return this.Neighbors.getItem(this.Points.IndexOf(point));
            },
            PointCCW: function (point) {
                return this.Points.getItem((((this.IndexOf(point) + 1) | 0)) % 3);
            },
            PointCW: function (point) {
                return this.Points.getItem((((this.IndexOf(point) + 2) | 0)) % 3);
            },
            RotateCW: function () {
                var t = this.Points.getItem(2);
                this.Points.setItem(2, this.Points.getItem(1));
                this.Points.setItem(1, this.Points.getItem(0));
                this.Points.setItem(0, t);
            },
            /**
             * Legalize triangle by rotating clockwise around oPoint
             *
             * @instance
             * @public
             * @this Poly2Tri.Triangulation.Delaunay.DelaunayTriangle
             * @memberof Poly2Tri.Triangulation.Delaunay.DelaunayTriangle
             * @param   {Poly2Tri.Triangulation.TriangulationPoint}    oPoint    The origin point to rotate around
             * @param   {Poly2Tri.Triangulation.TriangulationPoint}    nPoint    ???
             * @return  {void}
             */
            Legalize: function (oPoint, nPoint) {
                this.RotateCW();
                this.Points.setItem(this.IndexCCW(oPoint), nPoint);
            },
            toString: function () {
                return System.String.concat(System.String.concat(this.Points.getItem(0), ",", this.Points.getItem(1)) + ",", this.Points.getItem(2));
            },
            /**
             * Finalize edge marking
             *
             * @instance
             * @public
             * @this Poly2Tri.Triangulation.Delaunay.DelaunayTriangle
             * @memberof Poly2Tri.Triangulation.Delaunay.DelaunayTriangle
             * @return  {void}
             */
            MarkNeighborEdges: function () {
                for (var i = 0; i < 3; i = (i + 1) | 0) {
                    if (this.EdgeIsConstrained.getItem(i) && this.Neighbors.getItem(i) != null) {
                        this.Neighbors.getItem(i).MarkConstrainedEdge$1(this.Points.getItem((((i + 1) | 0)) % 3), this.Points.getItem((((i + 2) | 0)) % 3));
                    }
                }
            },
            MarkEdge: function (triangle) {
                for (var i = 0; i < 3; i = (i + 1) | 0) {
                    if (this.EdgeIsConstrained.getItem(i)) {
                        triangle.MarkConstrainedEdge$1(this.Points.getItem((((i + 1) | 0)) % 3), this.Points.getItem((((i + 2) | 0)) % 3));
                    }
                }
            },
            MarkEdge$1: function (tList) {
                var $t;
                $t = Bridge.getEnumerator(tList);
                try {
                    while ($t.moveNext()) {
                        var t = $t.Current;
                        for (var i = 0; i < 3; i = (i + 1) | 0) {
                            if (t.EdgeIsConstrained.getItem(i)) {
                                this.MarkConstrainedEdge$1(t.Points.getItem((((i + 1) | 0)) % 3), t.Points.getItem((((i + 2) | 0)) % 3));
                            }
                        }
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }},
            MarkConstrainedEdge$2: function (index) {
                this.EdgeIsConstrained.setItem(index, true);
            },
            MarkConstrainedEdge: function (edge) {
                this.MarkConstrainedEdge$1(edge.P, edge.Q);
            },
            /**
             * Mark edge as constrained
             *
             * @instance
             * @public
             * @this Poly2Tri.Triangulation.Delaunay.DelaunayTriangle
             * @memberof Poly2Tri.Triangulation.Delaunay.DelaunayTriangle
             * @param   {Poly2Tri.Triangulation.TriangulationPoint}    p    
             * @param   {Poly2Tri.Triangulation.TriangulationPoint}    q
             * @return  {void}
             */
            MarkConstrainedEdge$1: function (p, q) {
                var i = this.EdgeIndex(p, q);
                if (i !== -1) {
                    this.EdgeIsConstrained.setItem(i, true);
                }
            },
            Area: function () {
                var b = this.Points.getItem(0).X - this.Points.getItem(1).X;
                var h = this.Points.getItem(2).Y - this.Points.getItem(1).Y;

                return Math.abs((b * h * 0.5));
            },
            Centroid: function () {
                var cx = (this.Points.getItem(0).X + this.Points.getItem(1).X + this.Points.getItem(2).X) / 3.0;
                var cy = (this.Points.getItem(0).Y + this.Points.getItem(1).Y + this.Points.getItem(2).Y) / 3.0;
                return new Poly2Tri.Triangulation.TriangulationPoint(cx, cy);
            },
            /**
             * Get the index of the neighbor that shares this edge (or -1 if it isn't shared)
             *
             * @instance
             * @public
             * @this Poly2Tri.Triangulation.Delaunay.DelaunayTriangle
             * @memberof Poly2Tri.Triangulation.Delaunay.DelaunayTriangle
             * @param   {Poly2Tri.Triangulation.TriangulationPoint}    p1    
             * @param   {Poly2Tri.Triangulation.TriangulationPoint}    p2
             * @return  {number}                                             index of the shared edge or -1 if edge isn't shared
             */
            EdgeIndex: function (p1, p2) {
                var i1 = this.Points.IndexOf(p1);
                var i2 = this.Points.IndexOf(p2);

                var a = (i1 === 0 || i2 === 0);
                var b = (i1 === 1 || i2 === 1);
                var c = (i1 === 2 || i2 === 2);

                if (b && c) {
                    return 0;
                }
                if (a && c) {
                    return 1;
                }
                if (a && b) {
                    return 2;
                }
                return -1;
            },
            GetConstrainedEdgeCCW: function (p) {
                return this.EdgeIsConstrained.getItem((((this.IndexOf(p) + 2) | 0)) % 3);
            },
            GetConstrainedEdgeCW: function (p) {
                return this.EdgeIsConstrained.getItem((((this.IndexOf(p) + 1) | 0)) % 3);
            },
            GetConstrainedEdgeAcross: function (p) {
                return this.EdgeIsConstrained.getItem(this.IndexOf(p));
            },
            SetConstrainedEdgeCCW: function (p, ce) {
                this.EdgeIsConstrained.setItem((((this.IndexOf(p) + 2) | 0)) % 3, ce);
            },
            SetConstrainedEdgeCW: function (p, ce) {
                this.EdgeIsConstrained.setItem((((this.IndexOf(p) + 1) | 0)) % 3, ce);
            },
            SetConstrainedEdgeAcross: function (p, ce) {
                this.EdgeIsConstrained.setItem(this.IndexOf(p), ce);
            },
            GetDelaunayEdgeCCW: function (p) {
                return this.EdgeIsDelaunay.getItem((((this.IndexOf(p) + 2) | 0)) % 3);
            },
            GetDelaunayEdgeCW: function (p) {
                return this.EdgeIsDelaunay.getItem((((this.IndexOf(p) + 1) | 0)) % 3);
            },
            GetDelaunayEdgeAcross: function (p) {
                return this.EdgeIsDelaunay.getItem(this.IndexOf(p));
            },
            SetDelaunayEdgeCCW: function (p, ce) {
                this.EdgeIsDelaunay.setItem((((this.IndexOf(p) + 2) | 0)) % 3, ce);
            },
            SetDelaunayEdgeCW: function (p, ce) {
                this.EdgeIsDelaunay.setItem((((this.IndexOf(p) + 1) | 0)) % 3, ce);
            },
            SetDelaunayEdgeAcross: function (p, ce) {
                this.EdgeIsDelaunay.setItem(this.IndexOf(p), ce);
            }
        }
    });

    Bridge.define("Poly2Tri.Triangulation.Delaunay.Sweep.AdvancingFront", {
        fields: {
            Head: null,
            Search: null,
            Tail: null
        },
        ctors: {
            ctor: function (head, tail) {
                this.$initialize();
                this.Head = head;
                this.Tail = tail;
                this.Search = head;
                this.AddNode(head);
                this.AddNode(tail);
            }
        },
        methods: {
            AddNode: function (node) { },
            RemoveNode: function (node) { },
            toString: function () {
                var sb = new System.Text.StringBuilder();
                var node = this.Head;
                while (!Bridge.referenceEquals(node, this.Tail)) {
                    sb.append(node.Point.X).append("->");
                    node = node.Next;
                }
                sb.append(this.Tail.Point.X);
                return sb.toString();
            },
            /**
             * MM:  This seems to be used by LocateNode to guess a position in the implicit linked list of AdvancingFrontNodes near x
                  Removed an overload that depended on this being exact
             *
             * @instance
             * @private
             * @this Poly2Tri.Triangulation.Delaunay.Sweep.AdvancingFront
             * @memberof Poly2Tri.Triangulation.Delaunay.Sweep.AdvancingFront
             * @param   {number}                                                      x
             * @return  {Poly2Tri.Triangulation.Delaunay.Sweep.AdvancingFrontNode}
             */
            FindSearchNode: function (x) {
                return this.Search;
            },
            /**
             * We use a balancing tree to locate a node smaller or equal to given key value
             *
             * @instance
             * @public
             * @this Poly2Tri.Triangulation.Delaunay.Sweep.AdvancingFront
             * @memberof Poly2Tri.Triangulation.Delaunay.Sweep.AdvancingFront
             * @param   {Poly2Tri.Triangulation.TriangulationPoint}                   point
             * @return  {Poly2Tri.Triangulation.Delaunay.Sweep.AdvancingFrontNode}
             */
            LocateNode: function (point) {
                return this.LocateNode$1(point.X);
            },
            LocateNode$1: function (x) {
                var node = this.FindSearchNode(x);
                if (x < node.Value) {
                    while (((node = node.Prev)) != null) {
                        if (x >= node.Value) {
                            this.Search = node;
                            return node;
                        }
                    }
                } else {
                    while (((node = node.Next)) != null) {
                        if (x < node.Value) {
                            this.Search = node.Prev;
                            return node.Prev;
                        }
                    }
                }
                return null;
            },
            /**
             * This implementation will use simple node traversal algorithm to find a point on the front
             *
             * @instance
             * @public
             * @this Poly2Tri.Triangulation.Delaunay.Sweep.AdvancingFront
             * @memberof Poly2Tri.Triangulation.Delaunay.Sweep.AdvancingFront
             * @param   {Poly2Tri.Triangulation.TriangulationPoint}                   point
             * @return  {Poly2Tri.Triangulation.Delaunay.Sweep.AdvancingFrontNode}
             */
            LocatePoint: function (point) {
                var px = point.X;
                var node = this.FindSearchNode(px);
                var nx = node.Point.X;

                if (px === nx) {
                    if (!Bridge.referenceEquals(point, node.Point)) {
                        if (Bridge.referenceEquals(point, node.Prev.Point)) {
                            node = node.Prev;
                        } else if (Bridge.referenceEquals(point, node.Next.Point)) {
                            node = node.Next;
                        } else {
                            throw new System.Exception("Failed to find Node for given afront point");
                        }
                    }
                } else if (px < nx) {
                    while (((node = node.Prev)) != null) {
                        if (Bridge.referenceEquals(point, node.Point)) {
                            break;
                        }
                    }
                } else {
                    while (((node = node.Next)) != null) {
                        if (Bridge.referenceEquals(point, node.Point)) {
                            break;
                        }
                    }
                }
                this.Search = node;
                return node;
            }
        }
    });

    Bridge.define("Poly2Tri.Triangulation.Delaunay.Sweep.AdvancingFrontNode", {
        fields: {
            Next: null,
            Point: null,
            Prev: null,
            Triangle: null,
            Value: 0
        },
        props: {
            HasNext: {
                get: function () {
                    return this.Next != null;
                }
            },
            HasPrev: {
                get: function () {
                    return this.Prev != null;
                }
            }
        },
        ctors: {
            ctor: function (point) {
                this.$initialize();
                this.Point = point;
                this.Value = point.X;
            }
        }
    });

    Bridge.define("Poly2Tri.Triangulation.Delaunay.Sweep.DTSweep", {
        statics: {
            fields: {
                PI_div2: 0,
                PI_3div4: 0
            },
            ctors: {
                init: function () {
                    this.PI_div2 = 1.5707963267948966;
                    this.PI_3div4 = 2.3561944901923448;
                }
            },
            methods: {
                /**
                 * Triangulate simple polygon with holes
                 *
                 * @static
                 * @public
                 * @this Poly2Tri.Triangulation.Delaunay.Sweep.DTSweep
                 * @memberof Poly2Tri.Triangulation.Delaunay.Sweep.DTSweep
                 * @param   {Poly2Tri.Triangulation.Delaunay.Sweep.DTSweepContext}    tcx
                 * @return  {void}
                 */
                Triangulate: function (tcx) {
                    tcx.CreateAdvancingFront();

                    Poly2Tri.Triangulation.Delaunay.Sweep.DTSweep.Sweep(tcx);

                    if (tcx.TriangulationMode === Poly2Tri.Triangulation.TriangulationMode.Polygon) {
                        Poly2Tri.Triangulation.Delaunay.Sweep.DTSweep.FinalizationPolygon(tcx);
                    } else {
                        Poly2Tri.Triangulation.Delaunay.Sweep.DTSweep.FinalizationConvexHull(tcx);
                    }

                    tcx.Done();
                },
                /**
                 * Start sweeping the Y-sorted point set from bottom to top
                 *
                 * @static
                 * @private
                 * @this Poly2Tri.Triangulation.Delaunay.Sweep.DTSweep
                 * @memberof Poly2Tri.Triangulation.Delaunay.Sweep.DTSweep
                 * @param   {Poly2Tri.Triangulation.Delaunay.Sweep.DTSweepContext}    tcx
                 * @return  {void}
                 */
                Sweep: function (tcx) {
                    var $t;
                    var points = tcx.Points;
                    var point;
                    var node;

                    for (var i = 1; i < points.Count; i = (i + 1) | 0) {
                        point = points.getItem(i);

                        node = Poly2Tri.Triangulation.Delaunay.Sweep.DTSweep.PointEvent(tcx, point);

                        if (point.HasEdges) {
                            $t = Bridge.getEnumerator(point.Edges);
                            try {
                                while ($t.moveNext()) {
                                    var e = $t.Current;
                                    Poly2Tri.Triangulation.Delaunay.Sweep.DTSweep.EdgeEvent(tcx, e, node);
                                }
                            } finally {
                                if (Bridge.is($t, System.IDisposable)) {
                                    $t.System$IDisposable$Dispose();
                                }
                            }}
                        tcx.Update(null);
                    }
                },
                /**
                 * If this is a Delaunay Triangulation of a pointset we need to fill so the triangle mesh gets a ConvexHull
                 *
                 * @static
                 * @private
                 * @this Poly2Tri.Triangulation.Delaunay.Sweep.DTSweep
                 * @memberof Poly2Tri.Triangulation.Delaunay.Sweep.DTSweep
                 * @param   {Poly2Tri.Triangulation.Delaunay.Sweep.DTSweepContext}    tcx
                 * @return  {void}
                 */
                FinalizationConvexHull: function (tcx) {
                    var n1, n2;
                    var t1, t2;
                    var first, p1;

                    n1 = tcx.aFront.Head.Next;
                    n2 = n1.Next;
                    first = n1.Point;

                    Poly2Tri.Triangulation.Delaunay.Sweep.DTSweep.TurnAdvancingFrontConvex(tcx, n1, n2);



                    n1 = tcx.aFront.Tail.Prev;
                    if (n1.Triangle.Contains$1(n1.Next.Point) && n1.Triangle.Contains$1(n1.Prev.Point)) {
                        t1 = n1.Triangle.NeighborAcross(n1.Point);
                        Poly2Tri.Triangulation.Delaunay.Sweep.DTSweep.RotateTrianglePair(n1.Triangle, n1.Point, t1, t1.OppositePoint(n1.Triangle, n1.Point));
                        tcx.MapTriangleToNodes(n1.Triangle);
                        tcx.MapTriangleToNodes(t1);
                    }
                    n1 = tcx.aFront.Head.Next;
                    if (n1.Triangle.Contains$1(n1.Prev.Point) && n1.Triangle.Contains$1(n1.Next.Point)) {
                        t1 = n1.Triangle.NeighborAcross(n1.Point);
                        Poly2Tri.Triangulation.Delaunay.Sweep.DTSweep.RotateTrianglePair(n1.Triangle, n1.Point, t1, t1.OppositePoint(n1.Triangle, n1.Point));
                        tcx.MapTriangleToNodes(n1.Triangle);
                        tcx.MapTriangleToNodes(t1);
                    }

                    first = tcx.aFront.Head.Point;
                    n2 = tcx.aFront.Tail.Prev;
                    t1 = n2.Triangle;
                    p1 = n2.Point;
                    n2.Triangle = null;
                    do {
                        tcx.RemoveFromList(t1);
                        p1 = t1.PointCCW(p1);
                        if (Bridge.referenceEquals(p1, first)) {
                            break;
                        }
                        t2 = t1.NeighborCCW(p1);
                        t1.Clear();
                        t1 = t2;
                    } while (true);

                    first = tcx.aFront.Head.Next.Point;
                    p1 = t1.PointCW(tcx.aFront.Head.Point);
                    t2 = t1.NeighborCW(tcx.aFront.Head.Point);
                    t1.Clear();
                    t1 = t2;
                    while (!Bridge.referenceEquals(p1, first)) {
                        tcx.RemoveFromList(t1);
                        p1 = t1.PointCCW(p1);
                        t2 = t1.NeighborCCW(p1);
                        t1.Clear();
                        t1 = t2;
                    }

                    tcx.aFront.Head = tcx.aFront.Head.Next;
                    tcx.aFront.Head.Prev = null;
                    tcx.aFront.Tail = tcx.aFront.Tail.Prev;
                    tcx.aFront.Tail.Next = null;

                    tcx.FinalizeTriangulation();
                },
                /**
                 * We will traverse the entire advancing front and fill it to form a convex hull.
                 *
                 * @static
                 * @private
                 * @this Poly2Tri.Triangulation.Delaunay.Sweep.DTSweep
                 * @memberof Poly2Tri.Triangulation.Delaunay.Sweep.DTSweep
                 * @param   {Poly2Tri.Triangulation.Delaunay.Sweep.DTSweepContext}        tcx    
                 * @param   {Poly2Tri.Triangulation.Delaunay.Sweep.AdvancingFrontNode}    b      
                 * @param   {Poly2Tri.Triangulation.Delaunay.Sweep.AdvancingFrontNode}    c
                 * @return  {void}
                 */
                TurnAdvancingFrontConvex: function (tcx, b, c) {
                    var first = b;
                    while (!Bridge.referenceEquals(c, tcx.aFront.Tail)) {
                        if (Poly2Tri.Triangulation.TriangulationUtil.Orient2d(b.Point, c.Point, c.Next.Point) === FarseerPhysics.Common.Decomposition.CDT.Orientation.CCW) {
                            Poly2Tri.Triangulation.Delaunay.Sweep.DTSweep.Fill(tcx, c);
                            c = c.Next;
                        } else {
                            if (!Bridge.referenceEquals(b, first) && Poly2Tri.Triangulation.TriangulationUtil.Orient2d(b.Prev.Point, b.Point, c.Point) === FarseerPhysics.Common.Decomposition.CDT.Orientation.CCW) {
                                Poly2Tri.Triangulation.Delaunay.Sweep.DTSweep.Fill(tcx, b);
                                b = b.Prev;
                            } else {
                                b = c;
                                c = c.Next;
                            }
                        }
                    }
                },
                FinalizationPolygon: function (tcx) {
                    var t = tcx.aFront.Head.Next.Triangle;
                    var p = tcx.aFront.Head.Next.Point;
                    while (!t.GetConstrainedEdgeCW(p)) {
                        t = t.NeighborCCW(p);
                    }

                    tcx.MeshClean(t);
                },
                /**
                 * Find closes node to the left of the new point and
                 create a new triangle. If needed new holes and basins
                 will be filled to.
                 *
                 * @static
                 * @private
                 * @this Poly2Tri.Triangulation.Delaunay.Sweep.DTSweep
                 * @memberof Poly2Tri.Triangulation.Delaunay.Sweep.DTSweep
                 * @param   {Poly2Tri.Triangulation.Delaunay.Sweep.DTSweepContext}        tcx      
                 * @param   {Poly2Tri.Triangulation.TriangulationPoint}                   point
                 * @return  {Poly2Tri.Triangulation.Delaunay.Sweep.AdvancingFrontNode}
                 */
                PointEvent: function (tcx, point) {
                    var node, newNode;

                    node = tcx.LocateNode(point);
                    newNode = Poly2Tri.Triangulation.Delaunay.Sweep.DTSweep.NewFrontTriangle(tcx, point, node);

                    if (point.X <= node.Point.X + Poly2Tri.Triangulation.TriangulationUtil.EPSILON) {
                        Poly2Tri.Triangulation.Delaunay.Sweep.DTSweep.Fill(tcx, node);
                    }

                    tcx.AddNode(newNode);

                    Poly2Tri.Triangulation.Delaunay.Sweep.DTSweep.FillAdvancingFront(tcx, newNode);
                    return newNode;
                },
                /**
                 * Creates a new front triangle and legalize it
                 *
                 * @static
                 * @private
                 * @this Poly2Tri.Triangulation.Delaunay.Sweep.DTSweep
                 * @memberof Poly2Tri.Triangulation.Delaunay.Sweep.DTSweep
                 * @param   {Poly2Tri.Triangulation.Delaunay.Sweep.DTSweepContext}        tcx      
                 * @param   {Poly2Tri.Triangulation.TriangulationPoint}                   point    
                 * @param   {Poly2Tri.Triangulation.Delaunay.Sweep.AdvancingFrontNode}    node
                 * @return  {Poly2Tri.Triangulation.Delaunay.Sweep.AdvancingFrontNode}
                 */
                NewFrontTriangle: function (tcx, point, node) {
                    var newNode;
                    var triangle;

                    triangle = new Poly2Tri.Triangulation.Delaunay.DelaunayTriangle(point, node.Point, node.Next.Point);
                    triangle.MarkNeighbor(node.Triangle);
                    tcx.Triangles.add(triangle);

                    newNode = new Poly2Tri.Triangulation.Delaunay.Sweep.AdvancingFrontNode(point);
                    newNode.Next = node.Next;
                    newNode.Prev = node;
                    node.Next.Prev = newNode;
                    node.Next = newNode;

                    tcx.AddNode(newNode);

                    if (!Poly2Tri.Triangulation.Delaunay.Sweep.DTSweep.Legalize(tcx, triangle)) {
                        tcx.MapTriangleToNodes(triangle);
                    }

                    return newNode;
                },
                EdgeEvent: function (tcx, edge, node) {
                    try {
                        tcx.EdgeEvent.ConstrainedEdge = edge;
                        tcx.EdgeEvent.Right = edge.P.X > edge.Q.X;

                        if (Poly2Tri.Triangulation.Delaunay.Sweep.DTSweep.IsEdgeSideOfTriangle(node.Triangle, edge.P, edge.Q)) {
                            return;
                        }

                        Poly2Tri.Triangulation.Delaunay.Sweep.DTSweep.FillEdgeEvent(tcx, edge, node);

                        Poly2Tri.Triangulation.Delaunay.Sweep.DTSweep.EdgeEvent$1(tcx, edge.P, edge.Q, node.Triangle, edge.Q);
                    }
                    catch ($e1) {
                        $e1 = System.Exception.create($e1);
                        var e;
                        if (Bridge.is($e1, Poly2Tri.Triangulation.Delaunay.Sweep.PointOnEdgeException)) {
                            e = $e1;
                            System.Diagnostics.Debug.WriteLine$2(System.String.format("Skipping Edge: {0}", [e.Message]));
                        } else {
                            throw $e1;
                        }
                    }
                },
                EdgeEvent$1: function (tcx, ep, eq, triangle, point) {
                    var p1, p2;

                    if (Poly2Tri.Triangulation.Delaunay.Sweep.DTSweep.IsEdgeSideOfTriangle(triangle, ep, eq)) {
                        return;
                    }

                    p1 = triangle.PointCCW(point);
                    var o1 = Poly2Tri.Triangulation.TriangulationUtil.Orient2d(eq, p1, ep);
                    if (o1 === FarseerPhysics.Common.Decomposition.CDT.Orientation.Collinear) {
                        if (triangle.Contains$2(eq, p1)) {
                            triangle.MarkConstrainedEdge$1(eq, p1);
                            tcx.EdgeEvent.ConstrainedEdge.Q = p1;
                            triangle = triangle.NeighborAcross(point);
                            Poly2Tri.Triangulation.Delaunay.Sweep.DTSweep.EdgeEvent$1(tcx, ep, p1, triangle, p1);
                        } else {
                            throw new Poly2Tri.Triangulation.Delaunay.Sweep.PointOnEdgeException("EdgeEvent - Point on constrained edge not supported yet");
                        }
                        if (tcx.IsDebugEnabled) {
                            System.Diagnostics.Debug.WriteLine$2("EdgeEvent - Point on constrained edge");
                        }
                        return;
                    }

                    p2 = triangle.PointCW(point);
                    var o2 = Poly2Tri.Triangulation.TriangulationUtil.Orient2d(eq, p2, ep);
                    if (o2 === FarseerPhysics.Common.Decomposition.CDT.Orientation.Collinear) {
                        if (triangle.Contains$2(eq, p2)) {
                            triangle.MarkConstrainedEdge$1(eq, p2);
                            tcx.EdgeEvent.ConstrainedEdge.Q = p2;
                            triangle = triangle.NeighborAcross(point);
                            Poly2Tri.Triangulation.Delaunay.Sweep.DTSweep.EdgeEvent$1(tcx, ep, p2, triangle, p2);
                        } else {
                            throw new Poly2Tri.Triangulation.Delaunay.Sweep.PointOnEdgeException("EdgeEvent - Point on constrained edge not supported yet");
                        }
                        if (tcx.IsDebugEnabled) {
                            System.Diagnostics.Debug.WriteLine$2("EdgeEvent - Point on constrained edge");
                        }
                        return;
                    }

                    if (o1 === o2) {
                        if (o1 === FarseerPhysics.Common.Decomposition.CDT.Orientation.CW) {
                            triangle = triangle.NeighborCCW(point);
                        } else {
                            triangle = triangle.NeighborCW(point);
                        }
                        Poly2Tri.Triangulation.Delaunay.Sweep.DTSweep.EdgeEvent$1(tcx, ep, eq, triangle, point);
                    } else {
                        Poly2Tri.Triangulation.Delaunay.Sweep.DTSweep.FlipEdgeEvent(tcx, ep, eq, triangle, point);
                    }
                },
                FillEdgeEvent: function (tcx, edge, node) {
                    if (tcx.EdgeEvent.Right) {
                        Poly2Tri.Triangulation.Delaunay.Sweep.DTSweep.FillRightAboveEdgeEvent(tcx, edge, node);
                    } else {
                        Poly2Tri.Triangulation.Delaunay.Sweep.DTSweep.FillLeftAboveEdgeEvent(tcx, edge, node);
                    }
                },
                FillRightConcaveEdgeEvent: function (tcx, edge, node) {
                    Poly2Tri.Triangulation.Delaunay.Sweep.DTSweep.Fill(tcx, node.Next);
                    if (!Bridge.referenceEquals(node.Next.Point, edge.P)) {
                        if (Poly2Tri.Triangulation.TriangulationUtil.Orient2d(edge.Q, node.Next.Point, edge.P) === FarseerPhysics.Common.Decomposition.CDT.Orientation.CCW) {
                            if (Poly2Tri.Triangulation.TriangulationUtil.Orient2d(node.Point, node.Next.Point, node.Next.Next.Point) === FarseerPhysics.Common.Decomposition.CDT.Orientation.CCW) {
                                Poly2Tri.Triangulation.Delaunay.Sweep.DTSweep.FillRightConcaveEdgeEvent(tcx, edge, node);
                            } else {
                            }
                        }
                    }
                },
                FillRightConvexEdgeEvent: function (tcx, edge, node) {
                    if (Poly2Tri.Triangulation.TriangulationUtil.Orient2d(node.Next.Point, node.Next.Next.Point, node.Next.Next.Next.Point) === FarseerPhysics.Common.Decomposition.CDT.Orientation.CCW) {
                        Poly2Tri.Triangulation.Delaunay.Sweep.DTSweep.FillRightConcaveEdgeEvent(tcx, edge, node.Next);
                    } else {
                        if (Poly2Tri.Triangulation.TriangulationUtil.Orient2d(edge.Q, node.Next.Next.Point, edge.P) === FarseerPhysics.Common.Decomposition.CDT.Orientation.CCW) {
                            Poly2Tri.Triangulation.Delaunay.Sweep.DTSweep.FillRightConvexEdgeEvent(tcx, edge, node.Next);
                        } else {
                        }
                    }
                },
                FillRightBelowEdgeEvent: function (tcx, edge, node) {
                    if (node.Point.X < edge.P.X) {
                        if (Poly2Tri.Triangulation.TriangulationUtil.Orient2d(node.Point, node.Next.Point, node.Next.Next.Point) === FarseerPhysics.Common.Decomposition.CDT.Orientation.CCW) {
                            Poly2Tri.Triangulation.Delaunay.Sweep.DTSweep.FillRightConcaveEdgeEvent(tcx, edge, node);
                        } else {
                            Poly2Tri.Triangulation.Delaunay.Sweep.DTSweep.FillRightConvexEdgeEvent(tcx, edge, node);
                            Poly2Tri.Triangulation.Delaunay.Sweep.DTSweep.FillRightBelowEdgeEvent(tcx, edge, node);
                        }
                    }
                },
                FillRightAboveEdgeEvent: function (tcx, edge, node) {
                    while (node.Next.Point.X < edge.P.X) {
                        var o1 = Poly2Tri.Triangulation.TriangulationUtil.Orient2d(edge.Q, node.Next.Point, edge.P);
                        if (o1 === FarseerPhysics.Common.Decomposition.CDT.Orientation.CCW) {
                            Poly2Tri.Triangulation.Delaunay.Sweep.DTSweep.FillRightBelowEdgeEvent(tcx, edge, node);
                        } else {
                            node = node.Next;
                        }
                    }
                },
                FillLeftConvexEdgeEvent: function (tcx, edge, node) {
                    if (Poly2Tri.Triangulation.TriangulationUtil.Orient2d(node.Prev.Point, node.Prev.Prev.Point, node.Prev.Prev.Prev.Point) === FarseerPhysics.Common.Decomposition.CDT.Orientation.CW) {
                        Poly2Tri.Triangulation.Delaunay.Sweep.DTSweep.FillLeftConcaveEdgeEvent(tcx, edge, node.Prev);
                    } else {
                        if (Poly2Tri.Triangulation.TriangulationUtil.Orient2d(edge.Q, node.Prev.Prev.Point, edge.P) === FarseerPhysics.Common.Decomposition.CDT.Orientation.CW) {
                            Poly2Tri.Triangulation.Delaunay.Sweep.DTSweep.FillLeftConvexEdgeEvent(tcx, edge, node.Prev);
                        } else {
                        }
                    }
                },
                FillLeftConcaveEdgeEvent: function (tcx, edge, node) {
                    Poly2Tri.Triangulation.Delaunay.Sweep.DTSweep.Fill(tcx, node.Prev);
                    if (!Bridge.referenceEquals(node.Prev.Point, edge.P)) {
                        if (Poly2Tri.Triangulation.TriangulationUtil.Orient2d(edge.Q, node.Prev.Point, edge.P) === FarseerPhysics.Common.Decomposition.CDT.Orientation.CW) {
                            if (Poly2Tri.Triangulation.TriangulationUtil.Orient2d(node.Point, node.Prev.Point, node.Prev.Prev.Point) === FarseerPhysics.Common.Decomposition.CDT.Orientation.CW) {
                                Poly2Tri.Triangulation.Delaunay.Sweep.DTSweep.FillLeftConcaveEdgeEvent(tcx, edge, node);
                            } else {
                            }
                        }
                    }
                },
                FillLeftBelowEdgeEvent: function (tcx, edge, node) {
                    if (node.Point.X > edge.P.X) {
                        if (Poly2Tri.Triangulation.TriangulationUtil.Orient2d(node.Point, node.Prev.Point, node.Prev.Prev.Point) === FarseerPhysics.Common.Decomposition.CDT.Orientation.CW) {
                            Poly2Tri.Triangulation.Delaunay.Sweep.DTSweep.FillLeftConcaveEdgeEvent(tcx, edge, node);
                        } else {
                            Poly2Tri.Triangulation.Delaunay.Sweep.DTSweep.FillLeftConvexEdgeEvent(tcx, edge, node);
                            Poly2Tri.Triangulation.Delaunay.Sweep.DTSweep.FillLeftBelowEdgeEvent(tcx, edge, node);
                        }
                    }
                },
                FillLeftAboveEdgeEvent: function (tcx, edge, node) {
                    while (node.Prev.Point.X > edge.P.X) {
                        var o1 = Poly2Tri.Triangulation.TriangulationUtil.Orient2d(edge.Q, node.Prev.Point, edge.P);
                        if (o1 === FarseerPhysics.Common.Decomposition.CDT.Orientation.CW) {
                            Poly2Tri.Triangulation.Delaunay.Sweep.DTSweep.FillLeftBelowEdgeEvent(tcx, edge, node);
                        } else {
                            node = node.Prev;
                        }
                    }
                },
                IsEdgeSideOfTriangle: function (triangle, ep, eq) {
                    var index;
                    index = triangle.EdgeIndex(ep, eq);
                    if (index !== -1) {
                        triangle.MarkConstrainedEdge$2(index);
                        triangle = triangle.Neighbors.getItem(index);
                        if (triangle != null) {
                            triangle.MarkConstrainedEdge$1(ep, eq);
                        }
                        return true;
                    }
                    return false;
                },
                FlipEdgeEvent: function (tcx, ep, eq, t, p) {
                    var op, newP;
                    var ot;
                    var inScanArea;

                    ot = t.NeighborAcross(p);
                    op = ot.OppositePoint(t, p);

                    if (ot == null) {
                        throw new System.InvalidOperationException.$ctor1("[BUG:FIXME] FLIP failed due to missing triangle");
                    }

                    inScanArea = Poly2Tri.Triangulation.TriangulationUtil.InScanArea(p, t.PointCCW(p), t.PointCW(p), op);
                    if (inScanArea) {
                        Poly2Tri.Triangulation.Delaunay.Sweep.DTSweep.RotateTrianglePair(t, p, ot, op);
                        tcx.MapTriangleToNodes(t);
                        tcx.MapTriangleToNodes(ot);

                        if (Bridge.referenceEquals(p, eq) && Bridge.referenceEquals(op, ep)) {
                            if (Bridge.referenceEquals(eq, tcx.EdgeEvent.ConstrainedEdge.Q) && Bridge.referenceEquals(ep, tcx.EdgeEvent.ConstrainedEdge.P)) {
                                if (tcx.IsDebugEnabled) {
                                    System.Console.WriteLine("[FLIP] - constrained edge done");
                                }
                                t.MarkConstrainedEdge$1(ep, eq);
                                ot.MarkConstrainedEdge$1(ep, eq);
                                Poly2Tri.Triangulation.Delaunay.Sweep.DTSweep.Legalize(tcx, t);
                                Poly2Tri.Triangulation.Delaunay.Sweep.DTSweep.Legalize(tcx, ot);
                            } else {
                                if (tcx.IsDebugEnabled) {
                                    System.Console.WriteLine("[FLIP] - subedge done");
                                }
                            }
                        } else {
                            if (tcx.IsDebugEnabled) {
                                System.Console.WriteLine("[FLIP] - flipping and continuing with triangle still crossing edge");
                            }
                            var o = Poly2Tri.Triangulation.TriangulationUtil.Orient2d(eq, op, ep);
                            t = Poly2Tri.Triangulation.Delaunay.Sweep.DTSweep.NextFlipTriangle(tcx, o, t, ot, p, op);
                            Poly2Tri.Triangulation.Delaunay.Sweep.DTSweep.FlipEdgeEvent(tcx, ep, eq, t, p);
                        }
                    } else {
                        newP = Poly2Tri.Triangulation.Delaunay.Sweep.DTSweep.NextFlipPoint(ep, eq, ot, op);
                        Poly2Tri.Triangulation.Delaunay.Sweep.DTSweep.FlipScanEdgeEvent(tcx, ep, eq, t, ot, newP);
                        Poly2Tri.Triangulation.Delaunay.Sweep.DTSweep.EdgeEvent$1(tcx, ep, eq, t, p);
                    }
                },
                /**
                 * When we need to traverse from one triangle to the next we need 
                 the point in current triangle that is the opposite point to the next
                 triangle.
                 *
                 * @static
                 * @private
                 * @this Poly2Tri.Triangulation.Delaunay.Sweep.DTSweep
                 * @memberof Poly2Tri.Triangulation.Delaunay.Sweep.DTSweep
                 * @param   {Poly2Tri.Triangulation.TriangulationPoint}           ep    
                 * @param   {Poly2Tri.Triangulation.TriangulationPoint}           eq    
                 * @param   {Poly2Tri.Triangulation.Delaunay.DelaunayTriangle}    ot    
                 * @param   {Poly2Tri.Triangulation.TriangulationPoint}           op
                 * @return  {Poly2Tri.Triangulation.TriangulationPoint}
                 */
                NextFlipPoint: function (ep, eq, ot, op) {
                    var o2d = Poly2Tri.Triangulation.TriangulationUtil.Orient2d(eq, op, ep);
                    if (o2d === FarseerPhysics.Common.Decomposition.CDT.Orientation.CW) {
                        return ot.PointCCW(op);
                    } else if (o2d === FarseerPhysics.Common.Decomposition.CDT.Orientation.CCW) {
                        return ot.PointCW(op);
                    } else {
                        throw new Poly2Tri.Triangulation.Delaunay.Sweep.PointOnEdgeException("Point on constrained edge not supported yet");
                    }
                },
                /**
                 * After a flip we have two triangles and know that only one will still be
                 intersecting the edge. So decide which to contiune with and legalize the other
                 *
                 * @static
                 * @private
                 * @this Poly2Tri.Triangulation.Delaunay.Sweep.DTSweep
                 * @memberof Poly2Tri.Triangulation.Delaunay.Sweep.DTSweep
                 * @param   {Poly2Tri.Triangulation.Delaunay.Sweep.DTSweepContext}    tcx    
                 * @param   {FarseerPhysics.Common.Decomposition.CDT.Orientation}     o      should be the result of an TriangulationUtil.orient2d( eq, op, ep )
                 * @param   {Poly2Tri.Triangulation.Delaunay.DelaunayTriangle}        t      triangle 1
                 * @param   {Poly2Tri.Triangulation.Delaunay.DelaunayTriangle}        ot     triangle 2
                 * @param   {Poly2Tri.Triangulation.TriangulationPoint}               p      a point shared by both triangles
                 * @param   {Poly2Tri.Triangulation.TriangulationPoint}               op     another point shared by both triangles
                 * @return  {Poly2Tri.Triangulation.Delaunay.DelaunayTriangle}               returns the triangle still intersecting the edge
                 */
                NextFlipTriangle: function (tcx, o, t, ot, p, op) {
                    var edgeIndex;
                    if (o === FarseerPhysics.Common.Decomposition.CDT.Orientation.CCW) {
                        edgeIndex = ot.EdgeIndex(p, op);
                        ot.EdgeIsDelaunay.setItem(edgeIndex, true);
                        Poly2Tri.Triangulation.Delaunay.Sweep.DTSweep.Legalize(tcx, ot);
                        ot.EdgeIsDelaunay.Clear();
                        return t;
                    }
                    edgeIndex = t.EdgeIndex(p, op);
                    t.EdgeIsDelaunay.setItem(edgeIndex, true);
                    Poly2Tri.Triangulation.Delaunay.Sweep.DTSweep.Legalize(tcx, t);
                    t.EdgeIsDelaunay.Clear();
                    return ot;
                },
                
                FlipScanEdgeEvent: function (tcx, ep, eq, flipTriangle, t, p) {
                    var ot;
                    var op, newP;
                    var inScanArea;

                    ot = t.NeighborAcross(p);
                    op = ot.OppositePoint(t, p);

                    if (ot == null) {
                        throw new System.Exception("[BUG:FIXME] FLIP failed due to missing triangle");
                    }

                    inScanArea = Poly2Tri.Triangulation.TriangulationUtil.InScanArea(eq, flipTriangle.PointCCW(eq), flipTriangle.PointCW(eq), op);
                    if (inScanArea) {
                        Poly2Tri.Triangulation.Delaunay.Sweep.DTSweep.FlipEdgeEvent(tcx, eq, op, ot, op);
                    } else {
                        newP = Poly2Tri.Triangulation.Delaunay.Sweep.DTSweep.NextFlipPoint(ep, eq, ot, op);
                        Poly2Tri.Triangulation.Delaunay.Sweep.DTSweep.FlipScanEdgeEvent(tcx, ep, eq, flipTriangle, ot, newP);
                    }
                },
                /**
                 * Fills holes in the Advancing Front
                 *
                 * @static
                 * @private
                 * @this Poly2Tri.Triangulation.Delaunay.Sweep.DTSweep
                 * @memberof Poly2Tri.Triangulation.Delaunay.Sweep.DTSweep
                 * @param   {Poly2Tri.Triangulation.Delaunay.Sweep.DTSweepContext}        tcx    
                 * @param   {Poly2Tri.Triangulation.Delaunay.Sweep.AdvancingFrontNode}    n
                 * @return  {void}
                 */
                FillAdvancingFront: function (tcx, n) {
                    var node;
                    var angle;

                    node = n.Next;
                    while (node.HasNext) {
                        angle = Poly2Tri.Triangulation.Delaunay.Sweep.DTSweep.HoleAngle(node);
                        if (angle > Poly2Tri.Triangulation.Delaunay.Sweep.DTSweep.PI_div2 || angle < -1.5707963267948966) {
                            break;
                        }
                        Poly2Tri.Triangulation.Delaunay.Sweep.DTSweep.Fill(tcx, node);
                        node = node.Next;
                    }

                    node = n.Prev;
                    while (node.HasPrev) {
                        angle = Poly2Tri.Triangulation.Delaunay.Sweep.DTSweep.HoleAngle(node);
                        if (angle > Poly2Tri.Triangulation.Delaunay.Sweep.DTSweep.PI_div2 || angle < -1.5707963267948966) {
                            break;
                        }
                        Poly2Tri.Triangulation.Delaunay.Sweep.DTSweep.Fill(tcx, node);
                        node = node.Prev;
                    }

                    if (n.HasNext && n.Next.HasNext) {
                        angle = Poly2Tri.Triangulation.Delaunay.Sweep.DTSweep.BasinAngle(n);
                        if (angle < Poly2Tri.Triangulation.Delaunay.Sweep.DTSweep.PI_3div4) {
                            Poly2Tri.Triangulation.Delaunay.Sweep.DTSweep.FillBasin(tcx, n);
                        }
                    }
                },
                
                FillBasin: function (tcx, node) {
                    if (Poly2Tri.Triangulation.TriangulationUtil.Orient2d(node.Point, node.Next.Point, node.Next.Next.Point) === FarseerPhysics.Common.Decomposition.CDT.Orientation.CCW) {
                        tcx.Basin.leftNode = node;
                    } else {
                        tcx.Basin.leftNode = node.Next;
                    }

                    tcx.Basin.bottomNode = tcx.Basin.leftNode;
                    while (tcx.Basin.bottomNode.HasNext && tcx.Basin.bottomNode.Point.Y >= tcx.Basin.bottomNode.Next.Point.Y) {
                        tcx.Basin.bottomNode = tcx.Basin.bottomNode.Next;
                    }

                    if (Bridge.referenceEquals(tcx.Basin.bottomNode, tcx.Basin.leftNode)) {
                        return;
                    }

                    tcx.Basin.rightNode = tcx.Basin.bottomNode;
                    while (tcx.Basin.rightNode.HasNext && tcx.Basin.rightNode.Point.Y < tcx.Basin.rightNode.Next.Point.Y) {
                        tcx.Basin.rightNode = tcx.Basin.rightNode.Next;
                    }

                    if (Bridge.referenceEquals(tcx.Basin.rightNode, tcx.Basin.bottomNode)) {
                        return;
                    }

                    tcx.Basin.width = tcx.Basin.rightNode.Point.X - tcx.Basin.leftNode.Point.X;
                    tcx.Basin.leftHighest = tcx.Basin.leftNode.Point.Y > tcx.Basin.rightNode.Point.Y;

                    Poly2Tri.Triangulation.Delaunay.Sweep.DTSweep.FillBasinReq(tcx, tcx.Basin.bottomNode);
                },
                /**
                 * Recursive algorithm to fill a Basin with triangles
                 *
                 * @static
                 * @private
                 * @this Poly2Tri.Triangulation.Delaunay.Sweep.DTSweep
                 * @memberof Poly2Tri.Triangulation.Delaunay.Sweep.DTSweep
                 * @param   {Poly2Tri.Triangulation.Delaunay.Sweep.DTSweepContext}        tcx     
                 * @param   {Poly2Tri.Triangulation.Delaunay.Sweep.AdvancingFrontNode}    node
                 * @return  {void}
                 */
                FillBasinReq: function (tcx, node) {
                    if (Poly2Tri.Triangulation.Delaunay.Sweep.DTSweep.IsShallow(tcx, node)) {
                        return;
                    }

                    Poly2Tri.Triangulation.Delaunay.Sweep.DTSweep.Fill(tcx, node);
                    if (Bridge.referenceEquals(node.Prev, tcx.Basin.leftNode) && Bridge.referenceEquals(node.Next, tcx.Basin.rightNode)) {
                        return;
                    } else if (Bridge.referenceEquals(node.Prev, tcx.Basin.leftNode)) {
                        var o = Poly2Tri.Triangulation.TriangulationUtil.Orient2d(node.Point, node.Next.Point, node.Next.Next.Point);
                        if (o === FarseerPhysics.Common.Decomposition.CDT.Orientation.CW) {
                            return;
                        }
                        node = node.Next;
                    } else if (Bridge.referenceEquals(node.Next, tcx.Basin.rightNode)) {
                        var o1 = Poly2Tri.Triangulation.TriangulationUtil.Orient2d(node.Point, node.Prev.Point, node.Prev.Prev.Point);
                        if (o1 === FarseerPhysics.Common.Decomposition.CDT.Orientation.CCW) {
                            return;
                        }
                        node = node.Prev;
                    } else {
                        if (node.Prev.Point.Y < node.Next.Point.Y) {
                            node = node.Prev;
                        } else {
                            node = node.Next;
                        }
                    }
                    Poly2Tri.Triangulation.Delaunay.Sweep.DTSweep.FillBasinReq(tcx, node);
                },
                IsShallow: function (tcx, node) {
                    var height;

                    if (tcx.Basin.leftHighest) {
                        height = tcx.Basin.leftNode.Point.Y - node.Point.Y;
                    } else {
                        height = tcx.Basin.rightNode.Point.Y - node.Point.Y;
                    }
                    if (tcx.Basin.width > height) {
                        return true;
                    }
                    return false;
                },
                /**
                 * ???
                 *
                 * @static
                 * @private
                 * @this Poly2Tri.Triangulation.Delaunay.Sweep.DTSweep
                 * @memberof Poly2Tri.Triangulation.Delaunay.Sweep.DTSweep
                 * @param   {Poly2Tri.Triangulation.Delaunay.Sweep.AdvancingFrontNode}    node    middle node
                 * @return  {number}                                                              the angle between 3 front nodes
                 */
                HoleAngle: function (node) {
                    /* Complex plane
                      ab = cosA +i*sinA
                      ab = (ax + ay*i)(bx + by*i) = (ax*bx + ay*by) + i(ax*by-ay*bx)
                      atan2(y,x) computes the principal value of the argument function
                      applied to the complex number x+iy
                      Where x = ax*bx + ay*by
                            y = ax*by - ay*bx
                    */
                    var px = node.Point.X;
                    var py = node.Point.Y;
                    var ax = node.Next.Point.X - px;
                    var ay = node.Next.Point.Y - py;
                    var bx = node.Prev.Point.X - px;
                    var by = node.Prev.Point.Y - py;
                    return Math.atan2(ax * by - ay * bx, ax * bx + ay * by);
                },
                /**
                 * The basin angle is decided against the horizontal line [1,0]
                 *
                 * @static
                 * @private
                 * @this Poly2Tri.Triangulation.Delaunay.Sweep.DTSweep
                 * @memberof Poly2Tri.Triangulation.Delaunay.Sweep.DTSweep
                 * @param   {Poly2Tri.Triangulation.Delaunay.Sweep.AdvancingFrontNode}    node
                 * @return  {number}
                 */
                BasinAngle: function (node) {
                    var ax = node.Point.X - node.Next.Next.Point.X;
                    var ay = node.Point.Y - node.Next.Next.Point.Y;
                    return Math.atan2(ay, ax);
                },
                /**
                 * Adds a triangle to the advancing front to fill a hole.
                 *
                 * @static
                 * @private
                 * @this Poly2Tri.Triangulation.Delaunay.Sweep.DTSweep
                 * @memberof Poly2Tri.Triangulation.Delaunay.Sweep.DTSweep
                 * @param   {Poly2Tri.Triangulation.Delaunay.Sweep.DTSweepContext}        tcx     
                 * @param   {Poly2Tri.Triangulation.Delaunay.Sweep.AdvancingFrontNode}    node    middle node, that is the bottom of the hole
                 * @return  {void}
                 */
                Fill: function (tcx, node) {
                    var triangle = new Poly2Tri.Triangulation.Delaunay.DelaunayTriangle(node.Prev.Point, node.Point, node.Next.Point);
                    triangle.MarkNeighbor(node.Prev.Triangle);
                    triangle.MarkNeighbor(node.Triangle);
                    tcx.Triangles.add(triangle);

                    node.Prev.Next = node.Next;
                    node.Next.Prev = node.Prev;
                    tcx.RemoveNode(node);

                    if (!Poly2Tri.Triangulation.Delaunay.Sweep.DTSweep.Legalize(tcx, triangle)) {
                        tcx.MapTriangleToNodes(triangle);
                    }
                },
                /**
                 * Returns true if triangle was legalized
                 *
                 * @static
                 * @private
                 * @this Poly2Tri.Triangulation.Delaunay.Sweep.DTSweep
                 * @memberof Poly2Tri.Triangulation.Delaunay.Sweep.DTSweep
                 * @param   {Poly2Tri.Triangulation.Delaunay.Sweep.DTSweepContext}    tcx    
                 * @param   {Poly2Tri.Triangulation.Delaunay.DelaunayTriangle}        t
                 * @return  {boolean}
                 */
                Legalize: function (tcx, t) {
                    var oi;
                    var inside;
                    var p, op;
                    var ot;

                    for (var i = 0; i < 3; i = (i + 1) | 0) {
                        if (t.EdgeIsDelaunay.getItem(i)) {
                            continue;
                        }

                        ot = t.Neighbors.getItem(i);
                        if (ot != null) {
                            p = t.Points.getItem(i);
                            op = ot.OppositePoint(t, p);
                            oi = ot.IndexOf(op);
                            if (ot.EdgeIsConstrained.getItem(oi) || ot.EdgeIsDelaunay.getItem(oi)) {
                                t.EdgeIsConstrained.setItem(i, ot.EdgeIsConstrained.getItem(oi));
                                continue;
                            }

                            inside = Poly2Tri.Triangulation.TriangulationUtil.SmartIncircle(p, t.PointCCW(p), t.PointCW(p), op);

                            if (inside) {
                                var notLegalized;

                                t.EdgeIsDelaunay.setItem(i, true);
                                ot.EdgeIsDelaunay.setItem(oi, true);

                                Poly2Tri.Triangulation.Delaunay.Sweep.DTSweep.RotateTrianglePair(t, p, ot, op);


                                notLegalized = !Poly2Tri.Triangulation.Delaunay.Sweep.DTSweep.Legalize(tcx, t);

                                if (notLegalized) {
                                    tcx.MapTriangleToNodes(t);
                                }
                                notLegalized = !Poly2Tri.Triangulation.Delaunay.Sweep.DTSweep.Legalize(tcx, ot);
                                if (notLegalized) {
                                    tcx.MapTriangleToNodes(ot);
                                }

                                t.EdgeIsDelaunay.setItem(i, false);
                                ot.EdgeIsDelaunay.setItem(oi, false);

                                return true;
                            }
                        }
                    }
                    return false;
                },
                /**
                 * Rotates a triangle pair one vertex CW
                       n2                    n2
                  P +-----+             P +-----+
                    | t  /|               |\  t |  
                    |   / |               | \   |
                  n1|  /  |n3           n1|  \  |n3
                    | /   |    after CW   |   \ |
                    |/ oT |               | oT \|
                    +-----+ oP            +-----+
                       n4                    n4
                 *
                 * @static
                 * @private
                 * @this Poly2Tri.Triangulation.Delaunay.Sweep.DTSweep
                 * @memberof Poly2Tri.Triangulation.Delaunay.Sweep.DTSweep
                 * @param   {Poly2Tri.Triangulation.Delaunay.DelaunayTriangle}    t     
                 * @param   {Poly2Tri.Triangulation.TriangulationPoint}           p     
                 * @param   {Poly2Tri.Triangulation.Delaunay.DelaunayTriangle}    ot    
                 * @param   {Poly2Tri.Triangulation.TriangulationPoint}           op
                 * @return  {void}
                 */
                RotateTrianglePair: function (t, p, ot, op) {
                    var n1, n2, n3, n4;
                    n1 = t.NeighborCCW(p);
                    n2 = t.NeighborCW(p);
                    n3 = ot.NeighborCCW(op);
                    n4 = ot.NeighborCW(op);

                    var ce1, ce2, ce3, ce4;
                    ce1 = t.GetConstrainedEdgeCCW(p);
                    ce2 = t.GetConstrainedEdgeCW(p);
                    ce3 = ot.GetConstrainedEdgeCCW(op);
                    ce4 = ot.GetConstrainedEdgeCW(op);

                    var de1, de2, de3, de4;
                    de1 = t.GetDelaunayEdgeCCW(p);
                    de2 = t.GetDelaunayEdgeCW(p);
                    de3 = ot.GetDelaunayEdgeCCW(op);
                    de4 = ot.GetDelaunayEdgeCW(op);

                    t.Legalize(p, op);
                    ot.Legalize(op, p);

                    ot.SetDelaunayEdgeCCW(p, de1);
                    t.SetDelaunayEdgeCW(p, de2);
                    t.SetDelaunayEdgeCCW(op, de3);
                    ot.SetDelaunayEdgeCW(op, de4);

                    ot.SetConstrainedEdgeCCW(p, ce1);
                    t.SetConstrainedEdgeCW(p, ce2);
                    t.SetConstrainedEdgeCCW(op, ce3);
                    ot.SetConstrainedEdgeCW(op, ce4);

                    t.Neighbors.Clear();
                    ot.Neighbors.Clear();
                    if (n1 != null) {
                        ot.MarkNeighbor(n1);
                    }
                    if (n2 != null) {
                        t.MarkNeighbor(n2);
                    }
                    if (n3 != null) {
                        t.MarkNeighbor(n3);
                    }
                    if (n4 != null) {
                        ot.MarkNeighbor(n4);
                    }
                    t.MarkNeighbor(ot);
                }
            }
        }
    });

    Bridge.define("Poly2Tri.Triangulation.TriangulationConstraint", {
        fields: {
            P: null,
            Q: null
        }
    });

    Bridge.define("Poly2Tri.Triangulation.TriangulationContext", {
        fields: {
            Points: null,
            Triangles: null,
            _stepTime: 0,
            TriangulationMode: 0,
            Triangulatable: null,
            WaitUntilNotified: false,
            Terminated: false,
            StepCount: 0,
            IsDebugEnabled: false
        },
        ctors: {
            init: function () {
                this.Points = new (System.Collections.Generic.List$1(Poly2Tri.Triangulation.TriangulationPoint)).$ctor2(200);
                this.Triangles = new (System.Collections.Generic.List$1(Poly2Tri.Triangulation.Delaunay.DelaunayTriangle)).ctor();
                this._stepTime = -1;
            },
            ctor: function () {
                this.$initialize();
                this.Terminated = false;
            }
        },
        methods: {
            Done: function () {
                this.StepCount = (this.StepCount + 1) | 0;
            },
            PrepareTriangulation: function (t) {
                this.Triangulatable = t;
                this.TriangulationMode = t.Poly2Tri$Triangulation$Triangulatable$TriangulationMode;
                t.Poly2Tri$Triangulation$Triangulatable$PrepareTriangulation(this);
            },
            Update: function (message) { },
            Clear: function () {
                this.Points.clear();
                this.Terminated = false;
                this.StepCount = 0;
            }
        }
    });

    Bridge.define("Poly2Tri.Triangulation.Delaunay.Sweep.DTSweepContext.DTSweepBasin", {
        $kind: "nested class",
        fields: {
            bottomNode: null,
            leftHighest: false,
            leftNode: null,
            rightNode: null,
            width: 0
        }
    });

    Bridge.define("Poly2Tri.Triangulation.Delaunay.Sweep.DTSweepContext.DTSweepEdgeEvent", {
        $kind: "nested class",
        fields: {
            ConstrainedEdge: null,
            Right: false
        }
    });

    Bridge.define("Poly2Tri.Triangulation.TriangulationPoint", {
        fields: {
            X: 0,
            Y: 0,
            Edges: null
        },
        props: {
            Xf: {
                get: function () {
                    return this.X;
                },
                set: function (value) {
                    this.X = value;
                }
            },
            Yf: {
                get: function () {
                    return this.Y;
                },
                set: function (value) {
                    this.Y = value;
                }
            },
            HasEdges: {
                get: function () {
                    return this.Edges != null;
                }
            }
        },
        ctors: {
            ctor: function (x, y) {
                this.$initialize();
                this.X = x;
                this.Y = y;
            }
        },
        methods: {
            toString: function () {
                return "[" + System.Double.format(this.X) + "," + System.Double.format(this.Y) + "]";
            },
            AddEdge: function (e) {
                if (this.Edges == null) {
                    this.Edges = new (System.Collections.Generic.List$1(Poly2Tri.Triangulation.Delaunay.Sweep.DTSweepConstraint)).ctor();
                }
                this.Edges.add(e);
            }
        }
    });

    Bridge.define("Poly2Tri.Triangulation.Delaunay.Sweep.PointOnEdgeException", {
        inherits: [System.NotImplementedException],
        ctors: {
            ctor: function (message) {
                this.$initialize();
                System.NotImplementedException.$ctor1.call(this, message);
            }
        }
    });

    Bridge.define("Poly2Tri.Triangulation.Triangulatable", {
        $kind: "interface"
    });

    Bridge.define("Poly2Tri.Triangulation.Polygon.PolygonSet", {
        fields: {
            _polygons: null
        },
        props: {
            Polygons: {
                get: function () {
                    return this._polygons;
                }
            }
        },
        ctors: {
            init: function () {
                this._polygons = new (System.Collections.Generic.List$1(Poly2Tri.Triangulation.Polygon.Polygon)).ctor();
            },
            ctor: function () {
                this.$initialize();
            },
            $ctor1: function (poly) {
                this.$initialize();
                this._polygons.add(poly);
            }
        },
        methods: {
            Add: function (p) {
                this._polygons.add(p);
            }
        }
    });

    Bridge.define("Poly2Tri.Triangulation.TriangulationMode", {
        $kind: "enum",
        statics: {
            fields: {
                Unconstrained: 0,
                Constrained: 1,
                Polygon: 2
            }
        }
    });

    Bridge.define("Poly2Tri.Triangulation.TriangulationUtil", {
        statics: {
            fields: {
                EPSILON: 0
            },
            ctors: {
                init: function () {
                    this.EPSILON = 1E-12;
                }
            },
            methods: {
                /**
                 * Requirements:
                 1. a,b and c form a triangle.
                 2. a and d is know to be on opposite side of bc
                 <pre><code>a
                                +
                               / \
                              /   \
                            b/     \c
                            +-------+ 
                           /    B    \  
                          /           \</code></pre>
                    Facts:
                  d has to be in area B to have a chance to be inside the circle formed by a,b and c
                  d is outside B if orient2d(a,b,d) or orient2d(c,a,d) is CW
                  This preknowledge gives us a way to optimize the incircle test
                 *
                 * @static
                 * @public
                 * @this Poly2Tri.Triangulation.TriangulationUtil
                 * @memberof Poly2Tri.Triangulation.TriangulationUtil
                 * @param   {Poly2Tri.Triangulation.TriangulationPoint}    pa    triangle point, opposite d
                 * @param   {Poly2Tri.Triangulation.TriangulationPoint}    pb    triangle point
                 * @param   {Poly2Tri.Triangulation.TriangulationPoint}    pc    triangle point
                 * @param   {Poly2Tri.Triangulation.TriangulationPoint}    pd    point opposite a
                 * @return  {boolean}                                            true if d is inside circle, false if on circle edge
                 */
                SmartIncircle: function (pa, pb, pc, pd) {
                    var pdx = pd.X;
                    var pdy = pd.Y;
                    var adx = pa.X - pdx;
                    var ady = pa.Y - pdy;
                    var bdx = pb.X - pdx;
                    var bdy = pb.Y - pdy;

                    var adxbdy = adx * bdy;
                    var bdxady = bdx * ady;
                    var oabd = adxbdy - bdxady;
                    if (oabd <= 0) {
                        return false;
                    }

                    var cdx = pc.X - pdx;
                    var cdy = pc.Y - pdy;

                    var cdxady = cdx * ady;
                    var adxcdy = adx * cdy;
                    var ocad = cdxady - adxcdy;
                    if (ocad <= 0) {
                        return false;
                    }

                    var bdxcdy = bdx * cdy;
                    var cdxbdy = cdx * bdy;

                    var alift = adx * adx + ady * ady;
                    var blift = bdx * bdx + bdy * bdy;
                    var clift = cdx * cdx + cdy * cdy;

                    var det = alift * (bdxcdy - cdxbdy) + blift * ocad + clift * oabd;

                    return det > 0;
                },
                InScanArea: function (pa, pb, pc, pd) {
                    var pdx = pd.X;
                    var pdy = pd.Y;
                    var adx = pa.X - pdx;
                    var ady = pa.Y - pdy;
                    var bdx = pb.X - pdx;
                    var bdy = pb.Y - pdy;

                    var adxbdy = adx * bdy;
                    var bdxady = bdx * ady;
                    var oabd = adxbdy - bdxady;
                    if (oabd <= 0) {
                        return false;
                    }

                    var cdx = pc.X - pdx;
                    var cdy = pc.Y - pdy;

                    var cdxady = cdx * ady;
                    var adxcdy = adx * cdy;
                    var ocad = cdxady - adxcdy;
                    if (ocad <= 0) {
                        return false;
                    }
                    return true;
                },
                /**
                 * @static
                 * @public
                 * @this Poly2Tri.Triangulation.TriangulationUtil
                 * @memberof Poly2Tri.Triangulation.TriangulationUtil
                 * @param   {Poly2Tri.Triangulation.TriangulationPoint}              pa    
                 * @param   {Poly2Tri.Triangulation.TriangulationPoint}              pb    
                 * @param   {Poly2Tri.Triangulation.TriangulationPoint}              pc
                 * @return  {FarseerPhysics.Common.Decomposition.CDT.Orientation}
                 */
                Orient2d: function (pa, pb, pc) {
                    var detleft = (pa.X - pc.X) * (pb.Y - pc.Y);
                    var detright = (pa.Y - pc.Y) * (pb.X - pc.X);
                    var val = detleft - detright;
                    if (val > -Poly2Tri.Triangulation.TriangulationUtil.EPSILON && val < Poly2Tri.Triangulation.TriangulationUtil.EPSILON) {
                        return FarseerPhysics.Common.Decomposition.CDT.Orientation.Collinear;
                    } else if (val > 0) {
                        return FarseerPhysics.Common.Decomposition.CDT.Orientation.CCW;
                    }
                    return FarseerPhysics.Common.Decomposition.CDT.Orientation.CW;
                }
            }
        }
    });

    Bridge.define("Poly2Tri.Triangulation.Util.FixedArray3$1", function (T) { return {
        inherits: [System.Collections.Generic.IEnumerable$1(T)],
        $kind: "struct",
        statics: {
            methods: {
                getDefaultValue: function () { return new (Poly2Tri.Triangulation.Util.FixedArray3$1(T))(); }
            }
        },
        fields: {
            _0: Bridge.getDefaultValue(T),
            _1: Bridge.getDefaultValue(T),
            _2: Bridge.getDefaultValue(T)
        },
        alias: ["GetEnumerator", ["System$Collections$Generic$IEnumerable$1$" + Bridge.getTypeAlias(T) + "$GetEnumerator", "System$Collections$Generic$IEnumerable$1$GetEnumerator"]],
        ctors: {
            ctor: function () {
                this.$initialize();
            }
        },
        methods: {
            getItem: function (index) {
                switch (index) {
                    case 0: 
                        return this._0;
                    case 1: 
                        return this._1;
                    case 2: 
                        return this._2;
                    default: 
                        throw new System.IndexOutOfRangeException.ctor();
                }
            },
            setItem: function (index, value) {
                switch (index) {
                    case 0: 
                        this._0 = value;
                        break;
                    case 1: 
                        this._1 = value;
                        break;
                    case 2: 
                        this._2 = value;
                        break;
                    default: 
                        throw new System.IndexOutOfRangeException.ctor();
                }
            },
            GetEnumerator: function () {
                return Bridge.getEnumerator(this.Enumerate(), T);
            },
            System$Collections$IEnumerable$GetEnumerator: function () {
                return this.GetEnumerator();
            },
            Contains: function (value) {
                for (var i = 0; i < 3; i = (i + 1) | 0) {
                    if (Bridge.referenceEquals(this.getItem(i), value)) {
                        return true;
                    }
                }
                return false;
            },
            IndexOf: function (value) {
                for (var i = 0; i < 3; i = (i + 1) | 0) {
                    if (Bridge.referenceEquals(this.getItem(i), value)) {
                        return i;
                    }
                }
                return -1;
            },
            Clear: function () {
                this._0 = (this._1 = (this._2 = null));
            },
            Clear$1: function (value) {
                for (var i = 0; i < 3; i = (i + 1) | 0) {
                    if (Bridge.referenceEquals(this.getItem(i), value)) {
                        this.setItem(i, null);
                    }
                }
            },
            Enumerate: function () {
                return new (Bridge.GeneratorEnumerable$1(T))(Bridge.fn.bind(this, function ()  {
                    var $step = 0,
                        $jumpFromFinally,
                        $returnValue,
                        i,
                        $async_e;

                    var $enumerator = new (Bridge.GeneratorEnumerator$1(T))(Bridge.fn.bind(this, function () {
                        try {
                            for (;;) {
                                switch ($step) {
                                    case 0: {
                                        i = 0;
                                            $step = 1;
                                            continue;
                                    }
                                    case 1: {
                                        if ( i < 3 ) {
                                                $step = 2;
                                                continue;
                                            }
                                        $step = 5;
                                        continue;
                                    }
                                    case 2: {
                                        $enumerator.current = this.getItem(i);
                                            $step = 3;
                                            return true;
                                    }
                                    case 3: {
                                        $step = 4;
                                        continue;
                                    }
                                    case 4: {
                                        i = (i + 1) | 0;
                                        $step = 1;
                                        continue;
                                    }
                                    case 5: {

                                    }
                                    default: {
                                        return false;
                                    }
                                }
                            }
                        } catch($async_e1) {
                            $async_e = System.Exception.create($async_e1);
                            throw $async_e;
                        }
                    }));
                    return $enumerator;
                }));
            },
            getHashCode: function () {
                var h = Bridge.addHash([3625853963, this._0, this._1, this._2]);
                return h;
            },
            equals: function (o) {
                if (!Bridge.is(o, Poly2Tri.Triangulation.Util.FixedArray3$1(T))) {
                    return false;
                }
                return Bridge.equals(this._0, o._0) && Bridge.equals(this._1, o._1) && Bridge.equals(this._2, o._2);
            },
            $clone: function (to) {
                var s = to || new (Poly2Tri.Triangulation.Util.FixedArray3$1(T))();
                s._0 = this._0;
                s._1 = this._1;
                s._2 = this._2;
                return s;
            }
        }
    }; });

    Bridge.define("Poly2Tri.Triangulation.Util.FixedBitArray3", {
        inherits: [System.Collections.Generic.IEnumerable$1(System.Boolean)],
        $kind: "struct",
        statics: {
            methods: {
                getDefaultValue: function () { return new Poly2Tri.Triangulation.Util.FixedBitArray3(); }
            }
        },
        fields: {
            _0: false,
            _1: false,
            _2: false
        },
        alias: ["GetEnumerator", ["System$Collections$Generic$IEnumerable$1$System$Boolean$GetEnumerator", "System$Collections$Generic$IEnumerable$1$GetEnumerator"]],
        ctors: {
            ctor: function () {
                this.$initialize();
            }
        },
        methods: {
            getItem: function (index) {
                switch (index) {
                    case 0: 
                        return this._0;
                    case 1: 
                        return this._1;
                    case 2: 
                        return this._2;
                    default: 
                        throw new System.IndexOutOfRangeException.ctor();
                }
            },
            setItem: function (index, value) {
                switch (index) {
                    case 0: 
                        this._0 = value;
                        break;
                    case 1: 
                        this._1 = value;
                        break;
                    case 2: 
                        this._2 = value;
                        break;
                    default: 
                        throw new System.IndexOutOfRangeException.ctor();
                }
            },
            GetEnumerator: function () {
                return Bridge.getEnumerator(this.Enumerate(), System.Boolean);
            },
            System$Collections$IEnumerable$GetEnumerator: function () {
                return this.GetEnumerator();
            },
            Contains: function (value) {
                for (var i = 0; i < 3; i = (i + 1) | 0) {
                    if (this.getItem(i) === value) {
                        return true;
                    }
                }
                return false;
            },
            IndexOf: function (value) {
                for (var i = 0; i < 3; i = (i + 1) | 0) {
                    if (this.getItem(i) === value) {
                        return i;
                    }
                }
                return -1;
            },
            Clear: function () {
                this._0 = (this._1 = (this._2 = false));
            },
            Clear$1: function (value) {
                for (var i = 0; i < 3; i = (i + 1) | 0) {
                    if (this.getItem(i) === value) {
                        this.setItem(i, false);
                    }
                }
            },
            Enumerate: function () {
                return new (Bridge.GeneratorEnumerable$1(System.Boolean))(Bridge.fn.bind(this, function ()  {
                    var $step = 0,
                        $jumpFromFinally,
                        $returnValue,
                        i,
                        $async_e;

                    var $enumerator = new (Bridge.GeneratorEnumerator$1(System.Boolean))(Bridge.fn.bind(this, function () {
                        try {
                            for (;;) {
                                switch ($step) {
                                    case 0: {
                                        i = 0;
                                            $step = 1;
                                            continue;
                                    }
                                    case 1: {
                                        if ( i < 3 ) {
                                                $step = 2;
                                                continue;
                                            }
                                        $step = 5;
                                        continue;
                                    }
                                    case 2: {
                                        $enumerator.current = this.getItem(i);
                                            $step = 3;
                                            return true;
                                    }
                                    case 3: {
                                        $step = 4;
                                        continue;
                                    }
                                    case 4: {
                                        i = (i + 1) | 0;
                                        $step = 1;
                                        continue;
                                    }
                                    case 5: {

                                    }
                                    default: {
                                        return false;
                                    }
                                }
                            }
                        } catch($async_e1) {
                            $async_e = System.Exception.create($async_e1);
                            throw $async_e;
                        }
                    }));
                    return $enumerator;
                }));
            },
            getHashCode: function () {
                var h = Bridge.addHash([5290348900, this._0, this._1, this._2]);
                return h;
            },
            equals: function (o) {
                if (!Bridge.is(o, Poly2Tri.Triangulation.Util.FixedBitArray3)) {
                    return false;
                }
                return Bridge.equals(this._0, o._0) && Bridge.equals(this._1, o._1) && Bridge.equals(this._2, o._2);
            },
            $clone: function (to) {
                var s = to || new Poly2Tri.Triangulation.Util.FixedBitArray3();
                s._0 = this._0;
                s._1 = this._1;
                s._2 = this._2;
                return s;
            }
        }
    });

    Bridge.define("Poly2Tri.Triangulation.Util.PointGenerator", {
        statics: {
            fields: {
                RNG: null
            },
            ctors: {
                init: function () {
                    this.RNG = new System.Random.ctor();
                }
            },
            methods: {
                UniformDistribution: function (n, scale) {
                    var points = new (System.Collections.Generic.List$1(Poly2Tri.Triangulation.TriangulationPoint)).ctor();
                    for (var i = 0; i < n; i = (i + 1) | 0) {
                        points.add(new Poly2Tri.Triangulation.TriangulationPoint(scale * (0.5 - Poly2Tri.Triangulation.Util.PointGenerator.RNG.NextDouble()), scale * (0.5 - Poly2Tri.Triangulation.Util.PointGenerator.RNG.NextDouble())));
                    }
                    return points;
                },
                UniformGrid: function (n, scale) {
                    var x = 0;
                    var size = scale / n;
                    var halfScale = 0.5 * scale;

                    var points = new (System.Collections.Generic.List$1(Poly2Tri.Triangulation.TriangulationPoint)).ctor();
                    for (var i = 0; i < ((n + 1) | 0); i = (i + 1) | 0) {
                        x = halfScale - i * size;
                        for (var j = 0; j < ((n + 1) | 0); j = (j + 1) | 0) {
                            points.add(new Poly2Tri.Triangulation.TriangulationPoint(x, halfScale - j * size));
                        }
                    }
                    return points;
                }
            }
        }
    });

    Bridge.define("Poly2Tri.Triangulation.Util.PolygonGenerator", {
        statics: {
            fields: {
                RNG: null,
                PI_2: 0
            },
            ctors: {
                init: function () {
                    this.RNG = new System.Random.ctor();
                    this.PI_2 = 6.2831853071795862;
                }
            },
            methods: {
                RandomCircleSweep: function (scale, vertexCount) {
                    var point;
                    var points;
                    var radius = scale / 4;

                    points = System.Array.init(vertexCount, null, Poly2Tri.Triangulation.Polygon.PolygonPoint);
                    for (var i = 0; i < vertexCount; i = (i + 1) | 0) {
                        do {
                            if (i % 250 === 0) {
                                radius += scale / 2 * (0.5 - Poly2Tri.Triangulation.Util.PolygonGenerator.RNG.NextDouble());
                            } else if (i % 50 === 0) {
                                radius += scale / 5 * (0.5 - Poly2Tri.Triangulation.Util.PolygonGenerator.RNG.NextDouble());
                            } else {
                                radius += 25 * scale / vertexCount * (0.5 - Poly2Tri.Triangulation.Util.PolygonGenerator.RNG.NextDouble());
                            }
                            radius = radius > scale / 2 ? scale / 2 : radius;
                            radius = radius < scale / 10 ? scale / 10 : radius;
                        } while (radius < scale / 10 || radius > scale / 2);
                        point = new Poly2Tri.Triangulation.Polygon.PolygonPoint(radius * Math.cos((Poly2Tri.Triangulation.Util.PolygonGenerator.PI_2 * i) / vertexCount), radius * Math.sin((Poly2Tri.Triangulation.Util.PolygonGenerator.PI_2 * i) / vertexCount));
                        points[System.Array.index(i, points)] = point;
                    }
                    return new Poly2Tri.Triangulation.Polygon.Polygon.$ctor2(points);
                },
                RandomCircleSweep2: function (scale, vertexCount) {
                    var point;
                    var points;
                    var radius = scale / 4;

                    points = System.Array.init(vertexCount, null, Poly2Tri.Triangulation.Polygon.PolygonPoint);
                    for (var i = 0; i < vertexCount; i = (i + 1) | 0) {
                        do {
                            radius += scale / 5 * (0.5 - Poly2Tri.Triangulation.Util.PolygonGenerator.RNG.NextDouble());
                            radius = radius > scale / 2 ? scale / 2 : radius;
                            radius = radius < scale / 10 ? scale / 10 : radius;
                        } while (radius < scale / 10 || radius > scale / 2);
                        point = new Poly2Tri.Triangulation.Polygon.PolygonPoint(radius * Math.cos((Poly2Tri.Triangulation.Util.PolygonGenerator.PI_2 * i) / vertexCount), radius * Math.sin((Poly2Tri.Triangulation.Util.PolygonGenerator.PI_2 * i) / vertexCount));
                        points[System.Array.index(i, points)] = point;
                    }
                    return new Poly2Tri.Triangulation.Polygon.Polygon.$ctor2(points);
                }
            }
        }
    });

    Bridge.define("QuadTree$1", function (T) { return {
        statics: {
            methods: {
                /**
                 * tests if ray intersects AABB
                 *
                 * @static
                 * @public
                 * @this QuadTree$1
                 * @memberof QuadTree$1
                 * @param   {FarseerPhysics.Collision.AABB}      aabb    
                 * @param   {Microsoft.Xna.Framework.Vector2}    p1      
                 * @param   {Microsoft.Xna.Framework.Vector2}    p2
                 * @return  {boolean}
                 */
                RayCastAABB: function (aabb, p1, p2) {
                    p1 = {v:p1};
                    p2 = {v:p2};
                    var segmentAABB = new FarseerPhysics.Collision.AABB.ctor();
                    {
                        Microsoft.Xna.Framework.Vector2.Min$1(p1, p2, Bridge.ref(segmentAABB, "LowerBound"));
                        Microsoft.Xna.Framework.Vector2.Max$1(p1, p2, Bridge.ref(segmentAABB, "UpperBound"));
                    }
                    if (!FarseerPhysics.Collision.AABB.TestOverlap(aabb.$clone(), segmentAABB.$clone())) {
                        return false;
                    }

                    var rayDir = Microsoft.Xna.Framework.Vector2.op_Subtraction(p2.v.$clone(), p1.v.$clone());
                    var rayPos = p1.v.$clone();

                    var norm = new Microsoft.Xna.Framework.Vector2.$ctor2(-rayDir.Y, rayDir.X);
                    if (norm.Length() === 0.0) {
                        return true;
                    }
                    norm.Normalize();

                    var dPos = Microsoft.Xna.Framework.Vector2.Dot(rayPos.$clone(), norm.$clone());

                    var verts = aabb.GetVertices();
                    var d0 = Microsoft.Xna.Framework.Vector2.Dot(verts[System.Array.index(0, verts)].$clone(), norm.$clone()) - dPos;
                    for (var i = 1; i < 4; i = (i + 1) | 0) {
                        var d = Microsoft.Xna.Framework.Vector2.Dot(verts[System.Array.index(i, verts)].$clone(), norm.$clone()) - dPos;
                        if (Bridge.Int.sign(d) !== Bridge.Int.sign(d0)) {
                            return true;
                        }
                    }

                    return false;
                }
            }
        },
        fields: {
            MaxBucket: 0,
            MaxDepth: 0,
            Nodes: null,
            Span: null,
            SubTrees: null
        },
        props: {
            IsPartitioned: {
                get: function () {
                    return this.SubTrees != null;
                }
            }
        },
        ctors: {
            init: function () {
                this.Span = new FarseerPhysics.Collision.AABB();
            },
            ctor: function (span, maxbucket, maxdepth) {
                this.$initialize();
                this.Span = span.$clone();
                this.Nodes = new (System.Collections.Generic.List$1(Element$1(T))).ctor();

                this.MaxBucket = maxbucket;
                this.MaxDepth = maxdepth;
            }
        },
        methods: {
            /**
             * returns the quadrant of span that entirely contains test. if none, return 0.
             *
             * @instance
             * @private
             * @this QuadTree$1
             * @memberof QuadTree$1
             * @param   {FarseerPhysics.Collision.AABB}    span    
             * @param   {FarseerPhysics.Collision.AABB}    test
             * @return  {number}
             */
            Partition: function (span, test) {
                test = {v:test};
                if (span.Q1.Contains(test)) {
                    return 1;
                }
                if (span.Q2.Contains(test)) {
                    return 2;
                }
                if (span.Q3.Contains(test)) {
                    return 3;
                }
                if (span.Q4.Contains(test)) {
                    return 4;
                }

                return 0;
            },
            AddNode: function (node) {
                var $t;
                if (!this.IsPartitioned) {
                    if (this.Nodes.Count >= this.MaxBucket && this.MaxDepth > 0) {
                        this.Nodes.add(node);

                        this.SubTrees = System.Array.init(4, null, QuadTree$1(T));
                        this.SubTrees[System.Array.index(0, this.SubTrees)] = new (QuadTree$1(T))(this.Span.Q1.$clone(), this.MaxBucket, ((this.MaxDepth - 1) | 0));
                        this.SubTrees[System.Array.index(1, this.SubTrees)] = new (QuadTree$1(T))(this.Span.Q2.$clone(), this.MaxBucket, ((this.MaxDepth - 1) | 0));
                        this.SubTrees[System.Array.index(2, this.SubTrees)] = new (QuadTree$1(T))(this.Span.Q3.$clone(), this.MaxBucket, ((this.MaxDepth - 1) | 0));
                        this.SubTrees[System.Array.index(3, this.SubTrees)] = new (QuadTree$1(T))(this.Span.Q4.$clone(), this.MaxBucket, ((this.MaxDepth - 1) | 0));

                        var remNodes = new (System.Collections.Generic.List$1(Element$1(T))).ctor();

                        $t = Bridge.getEnumerator(this.Nodes);
                        try {
                            while ($t.moveNext()) {
                                var n = $t.Current;
                                switch (this.Partition(this.Span.$clone(), n.Span.$clone())) {
                                    case 1: 
                                        this.SubTrees[System.Array.index(0, this.SubTrees)].AddNode(n);
                                        break;
                                    case 2: 
                                        this.SubTrees[System.Array.index(1, this.SubTrees)].AddNode(n);
                                        break;
                                    case 3: 
                                        this.SubTrees[System.Array.index(2, this.SubTrees)].AddNode(n);
                                        break;
                                    case 4: 
                                        this.SubTrees[System.Array.index(3, this.SubTrees)].AddNode(n);
                                        break;
                                    default: 
                                        n.Parent = this;
                                        remNodes.add(n);
                                        break;
                                }
                            }
                        } finally {
                            if (Bridge.is($t, System.IDisposable)) {
                                $t.System$IDisposable$Dispose();
                            }
                        }
                        this.Nodes = remNodes;
                    } else {
                        node.Parent = this;
                        this.Nodes.add(node);
                    }
                } else {
                    switch (this.Partition(this.Span.$clone(), node.Span.$clone())) {
                        case 1: 
                            this.SubTrees[System.Array.index(0, this.SubTrees)].AddNode(node);
                            break;
                        case 2: 
                            this.SubTrees[System.Array.index(1, this.SubTrees)].AddNode(node);
                            break;
                        case 3: 
                            this.SubTrees[System.Array.index(2, this.SubTrees)].AddNode(node);
                            break;
                        case 4: 
                            this.SubTrees[System.Array.index(3, this.SubTrees)].AddNode(node);
                            break;
                        default: 
                            node.Parent = this;
                            this.Nodes.add(node);
                            break;
                    }
                }
            },
            QueryAABB: function (callback, searchR) {
                var $t, $t1;
                var stack = new (System.Collections.Generic.Stack$1(QuadTree$1(T))).ctor();
                stack.Push(this);

                while (stack.Count > 0) {
                    var qt = stack.Pop();
                    if (!FarseerPhysics.Collision.AABB.TestOverlap$1(searchR, Bridge.ref(qt, "Span"))) {
                        continue;
                    }

                    $t = Bridge.getEnumerator(qt.Nodes);
                    try {
                        while ($t.moveNext()) {
                            var n = $t.Current;
                            if (FarseerPhysics.Collision.AABB.TestOverlap$1(searchR, Bridge.ref(n, "Span"))) {
                                if (!callback(n)) {
                                    return;
                                }
                            }
                        }
                    } finally {
                        if (Bridge.is($t, System.IDisposable)) {
                            $t.System$IDisposable$Dispose();
                        }
                    }
                    if (qt.IsPartitioned) {
                        $t1 = Bridge.getEnumerator(qt.SubTrees);
                        try {
                            while ($t1.moveNext()) {
                                var st = $t1.Current;
                                stack.Push(st);
                            }
                        } finally {
                            if (Bridge.is($t1, System.IDisposable)) {
                                $t1.System$IDisposable$Dispose();
                            }
                        }}
                }
            },
            RayCast: function (callback, input) {
                var $t, $t1;
                var stack = new (System.Collections.Generic.Stack$1(QuadTree$1(T))).ctor();
                stack.Push(this);

                var maxFraction = input.v.MaxFraction;
                var p1 = input.v.Point1.$clone();
                var p2 = Microsoft.Xna.Framework.Vector2.op_Addition(p1.$clone(), Microsoft.Xna.Framework.Vector2.op_Multiply$1((Microsoft.Xna.Framework.Vector2.op_Subtraction(input.v.Point2.$clone(), input.v.Point1.$clone())), maxFraction));

                while (stack.Count > 0) {
                    var qt = stack.Pop();

                    if (!QuadTree$1(T).RayCastAABB(qt.Span.$clone(), p1.$clone(), p2.$clone())) {
                        continue;
                    }

                    $t = Bridge.getEnumerator(qt.Nodes);
                    try {
                        while ($t.moveNext()) {
                            var n = $t.Current;
                            if (!QuadTree$1(T).RayCastAABB(n.Span.$clone(), p1.$clone(), p2.$clone())) {
                                continue;
                            }

                            var subInput = new FarseerPhysics.Collision.RayCastInput();
                            subInput.Point1 = input.v.Point1.$clone();
                            subInput.Point2 = input.v.Point2.$clone();
                            subInput.MaxFraction = maxFraction;

                            var value = callback(subInput.$clone(), n);
                            if (value === 0.0) {
                                return;
                            }

                            if (value <= 0.0) {
                                continue;
                            }

                            maxFraction = value;
                            p2 = Microsoft.Xna.Framework.Vector2.op_Addition(p1.$clone(), Microsoft.Xna.Framework.Vector2.op_Multiply$1((Microsoft.Xna.Framework.Vector2.op_Subtraction(input.v.Point2.$clone(), input.v.Point1.$clone())), maxFraction));
                        }
                    } finally {
                        if (Bridge.is($t, System.IDisposable)) {
                            $t.System$IDisposable$Dispose();
                        }
                    }if (this.IsPartitioned) {
                        $t1 = Bridge.getEnumerator(qt.SubTrees);
                        try {
                            while ($t1.moveNext()) {
                                var st = $t1.Current;
                                stack.Push(st);
                            }
                        } finally {
                            if (Bridge.is($t1, System.IDisposable)) {
                                $t1.System$IDisposable$Dispose();
                            }
                        }}
                }
            },
            GetAllNodesR: function (nodes) {
                var $t;
                nodes.v.AddRange(this.Nodes);

                if (this.IsPartitioned) {
                    $t = Bridge.getEnumerator(this.SubTrees);
                    try {
                        while ($t.moveNext()) {
                            var st = $t.Current;
                            st.GetAllNodesR(nodes);
                        }
                    } finally {
                        if (Bridge.is($t, System.IDisposable)) {
                            $t.System$IDisposable$Dispose();
                        }
                    }}
            },
            RemoveNode: function (node) {
                node.Parent.Nodes.remove(node);
            },
            Reconstruct: function () {
                var allNodes = { v : new (System.Collections.Generic.List$1(Element$1(T))).ctor() };
                this.GetAllNodesR(allNodes);

                this.Clear();

                allNodes.v.ForEach(Bridge.fn.cacheBind(this, this.AddNode));
            },
            Clear: function () {
                this.Nodes.clear();
                this.SubTrees = null;
            }
        }
    }; });

    /**
     * The broad-phase is used for computing pairs and performing volume queries and ray casts.
     This broad-phase does not persist pairs. Instead, this reports potentially new pairs.
     It is up to the client to consume the new pairs and to track subsequent overlap.
     *
     * @public
     * @class FarseerPhysics.Collision.DynamicTreeBroadPhase
     * @implements  FarseerPhysics.Collision.IBroadPhase
     */
    Bridge.define("FarseerPhysics.Collision.DynamicTreeBroadPhase", {
        inherits: [FarseerPhysics.Collision.IBroadPhase],
        fields: {
            _moveBuffer: null,
            _moveCapacity: 0,
            _moveCount: 0,
            _pairBuffer: null,
            _pairCapacity: 0,
            _pairCount: 0,
            _proxyCount: 0,
            _queryCallback: null,
            _queryProxyId: 0,
            _tree: null
        },
        props: {
            /**
             * Get the number of proxies.
             *
             * @instance
             * @public
             * @readonly
             * @memberof FarseerPhysics.Collision.DynamicTreeBroadPhase
             * @function ProxyCount
             * @type number
             */
            ProxyCount: {
                get: function () {
                    return this._proxyCount;
                }
            }
        },
        alias: [
            "ProxyCount", "FarseerPhysics$Collision$IBroadPhase$ProxyCount",
            "AddProxy", "FarseerPhysics$Collision$IBroadPhase$AddProxy",
            "RemoveProxy", "FarseerPhysics$Collision$IBroadPhase$RemoveProxy",
            "MoveProxy", "FarseerPhysics$Collision$IBroadPhase$MoveProxy",
            "GetFatAABB", "FarseerPhysics$Collision$IBroadPhase$GetFatAABB",
            "GetProxy", "FarseerPhysics$Collision$IBroadPhase$GetProxy",
            "TestOverlap", "FarseerPhysics$Collision$IBroadPhase$TestOverlap",
            "UpdatePairs", "FarseerPhysics$Collision$IBroadPhase$UpdatePairs",
            "Query", "FarseerPhysics$Collision$IBroadPhase$Query",
            "RayCast", "FarseerPhysics$Collision$IBroadPhase$RayCast",
            "TouchProxy", "FarseerPhysics$Collision$IBroadPhase$TouchProxy"
        ],
        ctors: {
            init: function () {
                this._tree = new (FarseerPhysics.Collision.DynamicTree$1(FarseerPhysics.Dynamics.FixtureProxy))();
            },
            ctor: function () {
                this.$initialize();
                this._queryCallback = Bridge.fn.cacheBind(this, this.QueryCallback);

                this._pairCapacity = 16;
                this._pairBuffer = System.Array.init(this._pairCapacity, function (){
                    return new FarseerPhysics.Collision.Pair();
                }, FarseerPhysics.Collision.Pair);

                this._moveCapacity = 16;
                this._moveBuffer = System.Array.init(this._moveCapacity, 0, System.Int32);
            }
        },
        methods: {
            /**
             * Create a proxy with an initial AABB. Pairs are not reported until
             UpdatePairs is called.
             *
             * @instance
             * @public
             * @this FarseerPhysics.Collision.DynamicTreeBroadPhase
             * @memberof FarseerPhysics.Collision.DynamicTreeBroadPhase
             * @param   {FarseerPhysics.Dynamics.FixtureProxy}    proxy    The user data.
             * @return  {number}
             */
            AddProxy: function (proxy) {
                var proxyId = this._tree.AddProxy(Bridge.ref(proxy.v, "AABB"), proxy.v.$clone());
                this._proxyCount = (this._proxyCount + 1) | 0;
                this.BufferMove(proxyId);
                return proxyId;
            },
            /**
             * Destroy a proxy. It is up to the client to remove any pairs.
             *
             * @instance
             * @public
             * @this FarseerPhysics.Collision.DynamicTreeBroadPhase
             * @memberof FarseerPhysics.Collision.DynamicTreeBroadPhase
             * @param   {number}    proxyId    The proxy id.
             * @return  {void}
             */
            RemoveProxy: function (proxyId) {
                this.UnBufferMove(proxyId);
                this._proxyCount = (this._proxyCount - 1) | 0;
                this._tree.RemoveProxy(proxyId);
            },
            MoveProxy: function (proxyId, aabb, displacement) {
                var buffer = this._tree.MoveProxy(proxyId, aabb, displacement.$clone());
                if (buffer) {
                    this.BufferMove(proxyId);
                }
            },
            /**
             * Get the AABB for a proxy.
             *
             * @instance
             * @public
             * @this FarseerPhysics.Collision.DynamicTreeBroadPhase
             * @memberof FarseerPhysics.Collision.DynamicTreeBroadPhase
             * @param   {number}                           proxyId    The proxy id.
             * @param   {FarseerPhysics.Collision.AABB}    aabb       The aabb.
             * @return  {void}
             */
            GetFatAABB: function (proxyId, aabb) {
                this._tree.GetFatAABB(proxyId, aabb);
            },
            /**
             * Get user data from a proxy. Returns null if the id is invalid.
             *
             * @instance
             * @public
             * @this FarseerPhysics.Collision.DynamicTreeBroadPhase
             * @memberof FarseerPhysics.Collision.DynamicTreeBroadPhase
             * @param   {number}                                  proxyId    The proxy id.
             * @return  {FarseerPhysics.Dynamics.FixtureProxy}
             */
            GetProxy: function (proxyId) {
                return this._tree.GetUserData(proxyId);
            },
            /**
             * Test overlap of fat AABBs.
             *
             * @instance
             * @public
             * @this FarseerPhysics.Collision.DynamicTreeBroadPhase
             * @memberof FarseerPhysics.Collision.DynamicTreeBroadPhase
             * @param   {number}     proxyIdA    The proxy id A.
             * @param   {number}     proxyIdB    The proxy id B.
             * @return  {boolean}
             */
            TestOverlap: function (proxyIdA, proxyIdB) {
                var aabbA = { v : new FarseerPhysics.Collision.AABB() }, aabbB = { v : new FarseerPhysics.Collision.AABB() };
                this._tree.GetFatAABB(proxyIdA, aabbA);
                this._tree.GetFatAABB(proxyIdB, aabbB);
                return FarseerPhysics.Collision.AABB.TestOverlap$1(aabbA, aabbB);
            },
            /**
             * Update the pairs. This results in pair callbacks. This can only add pairs.
             *
             * @instance
             * @public
             * @this FarseerPhysics.Collision.DynamicTreeBroadPhase
             * @memberof FarseerPhysics.Collision.DynamicTreeBroadPhase
             * @param   {FarseerPhysics.Dynamics.BroadphaseDelegate}    callback    The callback.
             * @return  {void}
             */
            UpdatePairs: function (callback) {
                this._pairCount = 0;

                for (var j = 0; j < this._moveCount; j = (j + 1) | 0) {
                    this._queryProxyId = this._moveBuffer[System.Array.index(j, this._moveBuffer)];
                    if (this._queryProxyId === -1) {
                        continue;
                    }

                    var fatAABB = { v : new FarseerPhysics.Collision.AABB() };
                    this._tree.GetFatAABB(this._queryProxyId, fatAABB);

                    this._tree.Query(this._queryCallback, fatAABB);
                }

                this._moveCount = 0;

                System.Array.sort(this._pairBuffer, 0, this._pairCount);

                var i = 0;
                while (i < this._pairCount) {
                    var primaryPair = this._pairBuffer[System.Array.index(i, this._pairBuffer)].$clone();
                    var userDataA = { v : this._tree.GetUserData(primaryPair.ProxyIdA).$clone() };
                    var userDataB = { v : this._tree.GetUserData(primaryPair.ProxyIdB).$clone() };

                    callback(userDataA, userDataB);
                    i = (i + 1) | 0;

                    while (i < this._pairCount) {
                        var pair = this._pairBuffer[System.Array.index(i, this._pairBuffer)].$clone();
                        if (pair.ProxyIdA !== primaryPair.ProxyIdA || pair.ProxyIdB !== primaryPair.ProxyIdB) {
                            break;
                        }
                        i = (i + 1) | 0;
                    }
                }

                this._tree.Rebalance(4);
            },
            /**
             * Query an AABB for overlapping proxies. The callback class
             is called for each proxy that overlaps the supplied AABB.
             *
             * @instance
             * @public
             * @this FarseerPhysics.Collision.DynamicTreeBroadPhase
             * @memberof FarseerPhysics.Collision.DynamicTreeBroadPhase
             * @param   {System.Func}                      callback    The callback.
             * @param   {FarseerPhysics.Collision.AABB}    aabb        The aabb.
             * @return  {void}
             */
            Query: function (callback, aabb) {
                this._tree.Query(callback, aabb);
            },
            /**
             * Ray-cast against the proxies in the tree. This relies on the callback
             to perform a exact ray-cast in the case were the proxy contains a shape.
             The callback also performs the any collision filtering. This has performance
             roughly equal to k * log(n), where k is the number of collisions and n is the
             number of proxies in the tree.
             *
             * @instance
             * @public
             * @this FarseerPhysics.Collision.DynamicTreeBroadPhase
             * @memberof FarseerPhysics.Collision.DynamicTreeBroadPhase
             * @param   {System.Func}                              callback    A callback class that is called for each proxy that is hit by the ray.
             * @param   {FarseerPhysics.Collision.RayCastInput}    input       The ray-cast input data. The ray extends from p1 to p1 + maxFraction * (p2 - p1).
             * @return  {void}
             */
            RayCast: function (callback, input) {
                this._tree.RayCast(callback, input);
            },
            TouchProxy: function (proxyId) {
                this.BufferMove(proxyId);
            },
            /**
             * Compute the height of the embedded tree.
             *
             * @instance
             * @public
             * @this FarseerPhysics.Collision.DynamicTreeBroadPhase
             * @memberof FarseerPhysics.Collision.DynamicTreeBroadPhase
             * @return  {number}
             */
            ComputeHeight: function () {
                return this._tree.ComputeHeight();
            },
            BufferMove: function (proxyId) {
                if (this._moveCount === this._moveCapacity) {
                    var oldBuffer = this._moveBuffer;
                    this._moveCapacity = Bridge.Int.mul(this._moveCapacity, 2);
                    this._moveBuffer = System.Array.init(this._moveCapacity, 0, System.Int32);
                    System.Array.copy(oldBuffer, 0, this._moveBuffer, 0, this._moveCount);
                }

                this._moveBuffer[System.Array.index(this._moveCount, this._moveBuffer)] = proxyId;
                this._moveCount = (this._moveCount + 1) | 0;
            },
            UnBufferMove: function (proxyId) {
                for (var i = 0; i < this._moveCount; i = (i + 1) | 0) {
                    if (this._moveBuffer[System.Array.index(i, this._moveBuffer)] === proxyId) {
                        this._moveBuffer[System.Array.index(i, this._moveBuffer)] = -1;
                        return;
                    }
                }
            },
            QueryCallback: function (proxyId) {
                if (proxyId === this._queryProxyId) {
                    return true;
                }

                if (this._pairCount === this._pairCapacity) {
                    var oldBuffer = this._pairBuffer;
                    this._pairCapacity = Bridge.Int.mul(this._pairCapacity, 2);
                    this._pairBuffer = System.Array.init(this._pairCapacity, function (){
                        return new FarseerPhysics.Collision.Pair();
                    }, FarseerPhysics.Collision.Pair);
                    System.Array.copy(oldBuffer, 0, this._pairBuffer, 0, this._pairCount);
                }

                this._pairBuffer[System.Array.index(this._pairCount, this._pairBuffer)].ProxyIdA = Math.min(proxyId, this._queryProxyId);
                this._pairBuffer[System.Array.index(this._pairCount, this._pairBuffer)].ProxyIdB = Math.max(proxyId, this._queryProxyId);
                this._pairCount = (this._pairCount + 1) | 0;

                return true;
            }
        }
    });

    Bridge.define("FarseerPhysics.Collision.Shapes.CircleShape", {
        inherits: [FarseerPhysics.Collision.Shapes.Shape],
        fields: {
            _position: null
        },
        props: {
            ChildCount: {
                get: function () {
                    return 1;
                }
            },
            Position: {
                get: function () {
                    return this._position.$clone();
                },
                set: function (value) {
                    this._position = value.$clone();
                    this.ComputeProperties();
                }
            }
        },
        ctors: {
            init: function () {
                this._position = new Microsoft.Xna.Framework.Vector2();
            },
            $ctor1: function (radius, density) {
                this.$initialize();
                FarseerPhysics.Collision.Shapes.Shape.ctor.call(this, density);
                this.ShapeType = FarseerPhysics.Collision.Shapes.ShapeType.Circle;
                this._radius = radius;
                this._position = Microsoft.Xna.Framework.Vector2.Zero.$clone();
                this.ComputeProperties();
            },
            ctor: function () {
                this.$initialize();
                FarseerPhysics.Collision.Shapes.Shape.ctor.call(this, 0);
                this.ShapeType = FarseerPhysics.Collision.Shapes.ShapeType.Circle;
                this._radius = 0.0;
                this._position = Microsoft.Xna.Framework.Vector2.Zero.$clone();
            }
        },
        methods: {
            Clone: function () {
                var shape = new FarseerPhysics.Collision.Shapes.CircleShape.ctor();
                shape._radius = this.Radius;
                shape._density = this._density;
                shape._position = this._position.$clone();
                shape.ShapeType = this.ShapeType;
                shape.MassData = this.MassData.$clone();
                return shape;
            },
            /**
             * Test a point for containment in this shape. This only works for convex shapes.
             *
             * @instance
             * @public
             * @override
             * @this FarseerPhysics.Collision.Shapes.CircleShape
             * @memberof FarseerPhysics.Collision.Shapes.CircleShape
             * @param   {FarseerPhysics.Common.Transform}    transform    The shape world transform.
             * @param   {Microsoft.Xna.Framework.Vector2}    point        a point in world coordinates.
             * @return  {boolean}                                         True if the point is inside the shape
             */
            TestPoint: function (transform, point) {
                var center = Microsoft.Xna.Framework.Vector2.op_Addition(transform.v.Position.$clone(), FarseerPhysics.Common.MathUtils.Multiply(Bridge.ref(transform.v, "R"), this.Position.$clone()));
                var d = Microsoft.Xna.Framework.Vector2.op_Subtraction(point.v.$clone(), center.$clone());
                return Microsoft.Xna.Framework.Vector2.Dot(d.$clone(), d.$clone()) <= this.Radius * this.Radius;
            },
            /**
             * Cast a ray against a child shape.
             *
             * @instance
             * @public
             * @override
             * @this FarseerPhysics.Collision.Shapes.CircleShape
             * @memberof FarseerPhysics.Collision.Shapes.CircleShape
             * @param   {FarseerPhysics.Collision.RayCastOutput}    output        The ray-cast results.
             * @param   {FarseerPhysics.Collision.RayCastInput}     input         The ray-cast input parameters.
             * @param   {FarseerPhysics.Common.Transform}           transform     The transform to be applied to the shape.
             * @param   {number}                                    childIndex    The child shape index.
             * @return  {boolean}                                                 True if the ray-cast hits the shape
             */
            RayCast: function (output, input, transform, childIndex) {

                output.v = new FarseerPhysics.Collision.RayCastOutput();

                var position = Microsoft.Xna.Framework.Vector2.op_Addition(transform.v.Position.$clone(), FarseerPhysics.Common.MathUtils.Multiply(Bridge.ref(transform.v, "R"), this.Position.$clone()));
                var s = Microsoft.Xna.Framework.Vector2.op_Subtraction(input.v.Point1.$clone(), position.$clone());
                var b = Microsoft.Xna.Framework.Vector2.Dot(s.$clone(), s.$clone()) - this.Radius * this.Radius;

                var r = Microsoft.Xna.Framework.Vector2.op_Subtraction(input.v.Point2.$clone(), input.v.Point1.$clone());
                var c = Microsoft.Xna.Framework.Vector2.Dot(s.$clone(), r.$clone());
                var rr = Microsoft.Xna.Framework.Vector2.Dot(r.$clone(), r.$clone());
                var sigma = c * c - rr * b;

                if (sigma < 0.0 || rr < FarseerPhysics.Settings.Epsilon) {
                    return false;
                }

                var a = -(c + Math.sqrt(sigma));

                if (0.0 <= a && a <= input.v.MaxFraction * rr) {
                    a /= rr;
                    output.v.Fraction = a;
                    var norm = (Microsoft.Xna.Framework.Vector2.op_Addition(s.$clone(), Microsoft.Xna.Framework.Vector2.op_Multiply$2(a, r.$clone())));
                    norm.Normalize();
                    output.v.Normal = norm.$clone();
                    return true;
                }

                return false;
            },
            /**
             * Given a transform, compute the associated axis aligned bounding box for a child shape.
             *
             * @instance
             * @public
             * @override
             * @this FarseerPhysics.Collision.Shapes.CircleShape
             * @memberof FarseerPhysics.Collision.Shapes.CircleShape
             * @param   {FarseerPhysics.Collision.AABB}      aabb          The aabb results.
             * @param   {FarseerPhysics.Common.Transform}    transform     The world transform of the shape.
             * @param   {number}                             childIndex    The child shape index.
             * @return  {void}
             */
            ComputeAABB: function (aabb, transform, childIndex) {
                var p = Microsoft.Xna.Framework.Vector2.op_Addition(transform.v.Position.$clone(), FarseerPhysics.Common.MathUtils.Multiply(Bridge.ref(transform.v, "R"), this.Position.$clone()));
                aabb.v.LowerBound = new Microsoft.Xna.Framework.Vector2.$ctor2(p.X - this.Radius, p.Y - this.Radius);
                aabb.v.UpperBound = new Microsoft.Xna.Framework.Vector2.$ctor2(p.X + this.Radius, p.Y + this.Radius);
            },
            /**
             * Compute the mass properties of this shape using its dimensions and density.
             The inertia tensor is computed about the local origin, not the centroid.
             *
             * @instance
             * @public
             * @override
             * @this FarseerPhysics.Collision.Shapes.CircleShape
             * @memberof FarseerPhysics.Collision.Shapes.CircleShape
             * @return  {void}
             */
            ComputeProperties: function () {
                var area = FarseerPhysics.Settings.Pi * this.Radius * this.Radius;
                this.MassData.Area = area;
                this.MassData.Mass = this.Density * area;
                this.MassData.Centroid = this.Position.$clone();

                this.MassData.Inertia = this.MassData.Mass * (0.5 * this.Radius * this.Radius + Microsoft.Xna.Framework.Vector2.Dot(this.Position.$clone(), this.Position.$clone()));
            },
            CompareTo$1: function (shape) {
                return (this.Radius === shape.Radius && Microsoft.Xna.Framework.Vector2.op_Equality(this.Position.$clone(), shape.Position.$clone()));
            },
            ComputeSubmergedArea: function (normal, offset, xf, sc) {
                xf = {v:xf};
                sc.v = Microsoft.Xna.Framework.Vector2.Zero.$clone();

                var p = FarseerPhysics.Common.MathUtils.Multiply$2(xf, this.Position.$clone());
                var l = -(Microsoft.Xna.Framework.Vector2.Dot(normal.$clone(), p.$clone()) - offset);
                if (l < -this.Radius + FarseerPhysics.Settings.Epsilon) {
                    return 0;
                }
                if (l > this.Radius) {
                    sc.v = p.$clone();
                    return FarseerPhysics.Settings.Pi * this.Radius * this.Radius;
                }

                var r2 = this.Radius * this.Radius;
                var l2 = l * l;
                var area = r2 * ((Math.asin(l / this.Radius) + 1.57079637) + l * Math.sqrt(r2 - l2));
                var com = -0.6666667 * Math.pow(r2 - l2, 1.5) / area;

                sc.v.X = p.X + normal.X * com;
                sc.v.Y = p.Y + normal.Y * com;

                return area;
            }
        }
    });

    /**
     * A line segment (edge) Shape. These can be connected in chains or loops
     to other edge Shapes. The connectivity information is used to ensure
     correct contact normals.
     *
     * @public
     * @class FarseerPhysics.Collision.Shapes.EdgeShape
     * @augments FarseerPhysics.Collision.Shapes.Shape
     */
    Bridge.define("FarseerPhysics.Collision.Shapes.EdgeShape", {
        inherits: [FarseerPhysics.Collision.Shapes.Shape],
        fields: {
            HasVertex0: false,
            HasVertex3: false,
            /**
             * Optional adjacent vertices. These are used for smooth collision.
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Collision.Shapes.EdgeShape
             * @type Microsoft.Xna.Framework.Vector2
             */
            Vertex0: null,
            /**
             * Optional adjacent vertices. These are used for smooth collision.
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Collision.Shapes.EdgeShape
             * @type Microsoft.Xna.Framework.Vector2
             */
            Vertex3: null,
            /**
             * Edge start vertex
             *
             * @instance
             * @private
             * @memberof FarseerPhysics.Collision.Shapes.EdgeShape
             * @type Microsoft.Xna.Framework.Vector2
             */
            _vertex1: null,
            /**
             * Edge end vertex
             *
             * @instance
             * @private
             * @memberof FarseerPhysics.Collision.Shapes.EdgeShape
             * @type Microsoft.Xna.Framework.Vector2
             */
            _vertex2: null
        },
        props: {
            ChildCount: {
                get: function () {
                    return 1;
                }
            },
            /**
             * These are the edge vertices
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Collision.Shapes.EdgeShape
             * @function Vertex1
             * @type Microsoft.Xna.Framework.Vector2
             */
            Vertex1: {
                get: function () {
                    return this._vertex1.$clone();
                },
                set: function (value) {
                    this._vertex1 = value.$clone();
                    this.ComputeProperties();
                }
            },
            /**
             * These are the edge vertices
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Collision.Shapes.EdgeShape
             * @function Vertex2
             * @type Microsoft.Xna.Framework.Vector2
             */
            Vertex2: {
                get: function () {
                    return this._vertex2.$clone();
                },
                set: function (value) {
                    this._vertex2 = value.$clone();
                    this.ComputeProperties();
                }
            }
        },
        ctors: {
            init: function () {
                this.Vertex0 = new Microsoft.Xna.Framework.Vector2();
                this.Vertex3 = new Microsoft.Xna.Framework.Vector2();
                this._vertex1 = new Microsoft.Xna.Framework.Vector2();
                this._vertex2 = new Microsoft.Xna.Framework.Vector2();
            },
            ctor: function () {
                this.$initialize();
                FarseerPhysics.Collision.Shapes.Shape.ctor.call(this, 0);
                this.ShapeType = FarseerPhysics.Collision.Shapes.ShapeType.Edge;
                this._radius = FarseerPhysics.Settings.PolygonRadius;
            },
            $ctor1: function (start, end) {
                this.$initialize();
                FarseerPhysics.Collision.Shapes.Shape.ctor.call(this, 0);
                this.ShapeType = FarseerPhysics.Collision.Shapes.ShapeType.Edge;
                this._radius = FarseerPhysics.Settings.PolygonRadius;
                this.Set(start.$clone(), end.$clone());
            }
        },
        methods: {
            /**
             * Set this as an isolated edge.
             *
             * @instance
             * @public
             * @this FarseerPhysics.Collision.Shapes.EdgeShape
             * @memberof FarseerPhysics.Collision.Shapes.EdgeShape
             * @param   {Microsoft.Xna.Framework.Vector2}    start    The start.
             * @param   {Microsoft.Xna.Framework.Vector2}    end      The end.
             * @return  {void}
             */
            Set: function (start, end) {
                this._vertex1 = start.$clone();
                this._vertex2 = end.$clone();
                this.HasVertex0 = false;
                this.HasVertex3 = false;

                this.ComputeProperties();
            },
            Clone: function () {
                var edge = new FarseerPhysics.Collision.Shapes.EdgeShape.ctor();
                edge._radius = this._radius;
                edge._density = this._density;
                edge.HasVertex0 = this.HasVertex0;
                edge.HasVertex3 = this.HasVertex3;
                edge.Vertex0 = this.Vertex0.$clone();
                edge._vertex1 = this._vertex1.$clone();
                edge._vertex2 = this._vertex2.$clone();
                edge.Vertex3 = this.Vertex3.$clone();
                edge.MassData = this.MassData.$clone();
                return edge;
            },
            /**
             * Test a point for containment in this shape. This only works for convex shapes.
             *
             * @instance
             * @public
             * @override
             * @this FarseerPhysics.Collision.Shapes.EdgeShape
             * @memberof FarseerPhysics.Collision.Shapes.EdgeShape
             * @param   {FarseerPhysics.Common.Transform}    transform    The shape world transform.
             * @param   {Microsoft.Xna.Framework.Vector2}    point        a point in world coordinates.
             * @return  {boolean}                                         True if the point is inside the shape
             */
            TestPoint: function (transform, point) {
                return false;
            },
            /**
             * Cast a ray against a child shape.
             *
             * @instance
             * @public
             * @override
             * @this FarseerPhysics.Collision.Shapes.EdgeShape
             * @memberof FarseerPhysics.Collision.Shapes.EdgeShape
             * @param   {FarseerPhysics.Collision.RayCastOutput}    output        The ray-cast results.
             * @param   {FarseerPhysics.Collision.RayCastInput}     input         The ray-cast input parameters.
             * @param   {FarseerPhysics.Common.Transform}           transform     The transform to be applied to the shape.
             * @param   {number}                                    childIndex    The child shape index.
             * @return  {boolean}                                                 True if the ray-cast hits the shape
             */
            RayCast: function (output, input, transform, childIndex) {

                output.v = new FarseerPhysics.Collision.RayCastOutput();

                var p1 = FarseerPhysics.Common.MathUtils.MultiplyT(Bridge.ref(transform.v, "R"), Microsoft.Xna.Framework.Vector2.op_Subtraction(input.v.Point1.$clone(), transform.v.Position.$clone()));
                var p2 = FarseerPhysics.Common.MathUtils.MultiplyT(Bridge.ref(transform.v, "R"), Microsoft.Xna.Framework.Vector2.op_Subtraction(input.v.Point2.$clone(), transform.v.Position.$clone()));
                var d = Microsoft.Xna.Framework.Vector2.op_Subtraction(p2.$clone(), p1.$clone());

                var v1 = this._vertex1.$clone();
                var v2 = this._vertex2.$clone();
                var e = Microsoft.Xna.Framework.Vector2.op_Subtraction(v2.$clone(), v1.$clone());
                var normal = new Microsoft.Xna.Framework.Vector2.$ctor2(e.Y, -e.X);
                normal.Normalize();

                var numerator = Microsoft.Xna.Framework.Vector2.Dot(normal.$clone(), Microsoft.Xna.Framework.Vector2.op_Subtraction(v1.$clone(), p1.$clone()));
                var denominator = Microsoft.Xna.Framework.Vector2.Dot(normal.$clone(), d.$clone());

                if (denominator === 0.0) {
                    return false;
                }

                var t = numerator / denominator;
                if (t < 0.0 || 1.0 < t) {
                    return false;
                }

                var q = Microsoft.Xna.Framework.Vector2.op_Addition(p1.$clone(), Microsoft.Xna.Framework.Vector2.op_Multiply$2(t, d.$clone()));

                var r = Microsoft.Xna.Framework.Vector2.op_Subtraction(v2.$clone(), v1.$clone());
                var rr = Microsoft.Xna.Framework.Vector2.Dot(r.$clone(), r.$clone());
                if (rr === 0.0) {
                    return false;
                }

                var s = Microsoft.Xna.Framework.Vector2.Dot(Microsoft.Xna.Framework.Vector2.op_Subtraction(q.$clone(), v1.$clone()), r.$clone()) / rr;
                if (s < 0.0 || 1.0 < s) {
                    return false;
                }

                output.v.Fraction = t;
                if (numerator > 0.0) {
                    output.v.Normal = Microsoft.Xna.Framework.Vector2.op_UnaryNegation(normal.$clone());
                } else {
                    output.v.Normal = normal.$clone();
                }
                return true;
            },
            /**
             * Given a transform, compute the associated axis aligned bounding box for a child shape.
             *
             * @instance
             * @public
             * @override
             * @this FarseerPhysics.Collision.Shapes.EdgeShape
             * @memberof FarseerPhysics.Collision.Shapes.EdgeShape
             * @param   {FarseerPhysics.Collision.AABB}      aabb          The aabb results.
             * @param   {FarseerPhysics.Common.Transform}    transform     The world transform of the shape.
             * @param   {number}                             childIndex    The child shape index.
             * @return  {void}
             */
            ComputeAABB: function (aabb, transform, childIndex) {
                var v1 = FarseerPhysics.Common.MathUtils.Multiply$2(transform, this._vertex1.$clone());
                var v2 = FarseerPhysics.Common.MathUtils.Multiply$2(transform, this._vertex2.$clone());

                var lower = Microsoft.Xna.Framework.Vector2.Min(v1.$clone(), v2.$clone());
                var upper = Microsoft.Xna.Framework.Vector2.Max(v1.$clone(), v2.$clone());

                var r = new Microsoft.Xna.Framework.Vector2.$ctor2(this.Radius, this.Radius);
                aabb.v.LowerBound = Microsoft.Xna.Framework.Vector2.op_Subtraction(lower.$clone(), r.$clone());
                aabb.v.UpperBound = Microsoft.Xna.Framework.Vector2.op_Addition(upper.$clone(), r.$clone());
            },
            /**
             * Compute the mass properties of this shape using its dimensions and density.
             The inertia tensor is computed about the local origin, not the centroid.
             *
             * @instance
             * @public
             * @override
             * @this FarseerPhysics.Collision.Shapes.EdgeShape
             * @memberof FarseerPhysics.Collision.Shapes.EdgeShape
             * @return  {void}
             */
            ComputeProperties: function () {
                this.MassData.Centroid = Microsoft.Xna.Framework.Vector2.op_Multiply$2(0.5, (Microsoft.Xna.Framework.Vector2.op_Addition(this._vertex1.$clone(), this._vertex2.$clone())));
            },
            ComputeSubmergedArea: function (normal, offset, xf, sc) {
                sc.v = Microsoft.Xna.Framework.Vector2.Zero.$clone();
                return 0;
            },
            CompareTo$1: function (shape) {
                return (this.HasVertex0 === shape.HasVertex0 && this.HasVertex3 === shape.HasVertex3 && Microsoft.Xna.Framework.Vector2.op_Equality(this.Vertex0.$clone(), shape.Vertex0.$clone()) && Microsoft.Xna.Framework.Vector2.op_Equality(this.Vertex1.$clone(), shape.Vertex1.$clone()) && Microsoft.Xna.Framework.Vector2.op_Equality(this.Vertex2.$clone(), shape.Vertex2.$clone()) && Microsoft.Xna.Framework.Vector2.op_Equality(this.Vertex3.$clone(), shape.Vertex3.$clone()));
            }
        }
    });

    /**
     * A loop Shape is a free form sequence of line segments that form a circular list.
     The loop may cross upon itself, but this is not recommended for smooth collision.
     The loop has double sided collision, so you can use inside and outside collision.
     Therefore, you may use any winding order.
     *
     * @public
     * @class FarseerPhysics.Collision.Shapes.LoopShape
     * @augments FarseerPhysics.Collision.Shapes.Shape
     */
    Bridge.define("FarseerPhysics.Collision.Shapes.LoopShape", {
        inherits: [FarseerPhysics.Collision.Shapes.Shape],
        statics: {
            fields: {
                _edgeShape: null
            },
            ctors: {
                init: function () {
                    this._edgeShape = new FarseerPhysics.Collision.Shapes.EdgeShape.ctor();
                }
            }
        },
        fields: {
            /**
             * The vertices. These are not owned/freed by the loop Shape.
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Collision.Shapes.LoopShape
             * @type FarseerPhysics.Common.Vertices
             */
            Vertices: null
        },
        props: {
            ChildCount: {
                get: function () {
                    return this.Vertices.Count;
                }
            }
        },
        ctors: {
            ctor: function () {
                this.$initialize();
                FarseerPhysics.Collision.Shapes.Shape.ctor.call(this, 0);
                this.ShapeType = FarseerPhysics.Collision.Shapes.ShapeType.Loop;
                this._radius = FarseerPhysics.Settings.PolygonRadius;
            },
            $ctor1: function (vertices) {
                this.$initialize();
                FarseerPhysics.Collision.Shapes.Shape.ctor.call(this, 0);
                this.ShapeType = FarseerPhysics.Collision.Shapes.ShapeType.Loop;
                this._radius = FarseerPhysics.Settings.PolygonRadius;

                if (FarseerPhysics.Settings.ConserveMemory) {
                    this.Vertices = vertices;
                } else {
                    this.Vertices = new FarseerPhysics.Common.Vertices.$ctor2(vertices);
                }
            }
        },
        methods: {
            Clone: function () {
                var loop = new FarseerPhysics.Collision.Shapes.LoopShape.ctor();
                loop._density = this._density;
                loop._radius = this._radius;
                loop.Vertices = this.Vertices;
                loop.MassData = this.MassData.$clone();
                return loop;
            },
            /**
             * Get a child edge.
             *
             * @instance
             * @public
             * @this FarseerPhysics.Collision.Shapes.LoopShape
             * @memberof FarseerPhysics.Collision.Shapes.LoopShape
             * @param   {FarseerPhysics.Collision.Shapes.EdgeShape}    edge     The edge.
             * @param   {number}                                       index    The index.
             * @return  {void}
             */
            GetChildEdge: function (edge, index) {
                System.Diagnostics.Debug.Assert(2 <= this.Vertices.Count);
                System.Diagnostics.Debug.Assert(0 <= index && index < this.Vertices.Count);
                edge.v.ShapeType = FarseerPhysics.Collision.Shapes.ShapeType.Edge;
                edge.v._radius = this._radius;
                edge.v.HasVertex0 = true;
                edge.v.HasVertex3 = true;

                var i0 = ((index - 1) | 0) >= 0 ? ((index - 1) | 0) : ((this.Vertices.Count - 1) | 0);
                var i1 = index;
                var i2 = ((index + 1) | 0) < this.Vertices.Count ? ((index + 1) | 0) : 0;
                var i3 = (index + 2) | 0;
                while (i3 >= this.Vertices.Count) {
                    i3 = (i3 - this.Vertices.Count) | 0;
                }

                edge.v.Vertex0 = this.Vertices.getItem(i0).$clone();
                edge.v.Vertex1 = this.Vertices.getItem(i1).$clone();
                edge.v.Vertex2 = this.Vertices.getItem(i2).$clone();
                edge.v.Vertex3 = this.Vertices.getItem(i3).$clone();
            },
            /**
             * Test a point for containment in this shape. This only works for convex shapes.
             *
             * @instance
             * @public
             * @override
             * @this FarseerPhysics.Collision.Shapes.LoopShape
             * @memberof FarseerPhysics.Collision.Shapes.LoopShape
             * @param   {FarseerPhysics.Common.Transform}    transform    The shape world transform.
             * @param   {Microsoft.Xna.Framework.Vector2}    point        a point in world coordinates.
             * @return  {boolean}                                         True if the point is inside the shape
             */
            TestPoint: function (transform, point) {
                return false;
            },
            /**
             * Cast a ray against a child shape.
             *
             * @instance
             * @public
             * @override
             * @this FarseerPhysics.Collision.Shapes.LoopShape
             * @memberof FarseerPhysics.Collision.Shapes.LoopShape
             * @param   {FarseerPhysics.Collision.RayCastOutput}    output        The ray-cast results.
             * @param   {FarseerPhysics.Collision.RayCastInput}     input         The ray-cast input parameters.
             * @param   {FarseerPhysics.Common.Transform}           transform     The transform to be applied to the shape.
             * @param   {number}                                    childIndex    The child shape index.
             * @return  {boolean}                                                 True if the ray-cast hits the shape
             */
            RayCast: function (output, input, transform, childIndex) {
                System.Diagnostics.Debug.Assert(childIndex < this.Vertices.Count);

                var i1 = childIndex;
                var i2 = (childIndex + 1) | 0;
                if (i2 === this.Vertices.Count) {
                    i2 = 0;
                }

                FarseerPhysics.Collision.Shapes.LoopShape._edgeShape.Vertex1 = this.Vertices.getItem(i1).$clone();
                FarseerPhysics.Collision.Shapes.LoopShape._edgeShape.Vertex2 = this.Vertices.getItem(i2).$clone();

                return FarseerPhysics.Collision.Shapes.LoopShape._edgeShape.RayCast(output, input, transform, 0);
            },
            /**
             * Given a transform, compute the associated axis aligned bounding box for a child shape.
             *
             * @instance
             * @public
             * @override
             * @this FarseerPhysics.Collision.Shapes.LoopShape
             * @memberof FarseerPhysics.Collision.Shapes.LoopShape
             * @param   {FarseerPhysics.Collision.AABB}      aabb          The aabb results.
             * @param   {FarseerPhysics.Common.Transform}    transform     The world transform of the shape.
             * @param   {number}                             childIndex    The child shape index.
             * @return  {void}
             */
            ComputeAABB: function (aabb, transform, childIndex) {
                System.Diagnostics.Debug.Assert(childIndex < this.Vertices.Count);

                var i1 = childIndex;
                var i2 = (childIndex + 1) | 0;
                if (i2 === this.Vertices.Count) {
                    i2 = 0;
                }

                var v1 = FarseerPhysics.Common.MathUtils.Multiply$2(transform, this.Vertices.getItem(i1).$clone());
                var v2 = FarseerPhysics.Common.MathUtils.Multiply$2(transform, this.Vertices.getItem(i2).$clone());

                aabb.v.LowerBound = Microsoft.Xna.Framework.Vector2.Min(v1.$clone(), v2.$clone());
                aabb.v.UpperBound = Microsoft.Xna.Framework.Vector2.Max(v1.$clone(), v2.$clone());
            },
            /**
             * Chains have zero mass.
             *
             * @instance
             * @public
             * @override
             * @this FarseerPhysics.Collision.Shapes.LoopShape
             * @memberof FarseerPhysics.Collision.Shapes.LoopShape
             * @return  {void}
             */
            ComputeProperties: function () { },
            ComputeSubmergedArea: function (normal, offset, xf, sc) {
                sc.v = Microsoft.Xna.Framework.Vector2.Zero.$clone();
                return 0;
            }
        }
    });

    /**
     * Represents a simple non-selfintersecting convex polygon.
     If you want to have concave polygons, you will have to use the {@link } or the {@link }
     to decompose the concave polygon into 2 or more convex polygons.
     *
     * @public
     * @class FarseerPhysics.Collision.Shapes.PolygonShape
     * @augments FarseerPhysics.Collision.Shapes.Shape
     */
    Bridge.define("FarseerPhysics.Collision.Shapes.PolygonShape", {
        inherits: [FarseerPhysics.Collision.Shapes.Shape],
        fields: {
            Normals: null,
            Vertices: null
        },
        props: {
            ChildCount: {
                get: function () {
                    return 1;
                }
            }
        },
        ctors: {
            /**
             * Initializes a new instance of the {@link } class.
             *
             * @instance
             * @public
             * @this FarseerPhysics.Collision.Shapes.PolygonShape
             * @memberof FarseerPhysics.Collision.Shapes.PolygonShape
             * @param   {FarseerPhysics.Common.Vertices}    vertices    The vertices.
             * @param   {number}                            density     The density.
             * @return  {void}
             */
            $ctor1: function (vertices, density) {
                this.$initialize();
                FarseerPhysics.Collision.Shapes.Shape.ctor.call(this, density);
                this.ShapeType = FarseerPhysics.Collision.Shapes.ShapeType.Polygon;
                this._radius = FarseerPhysics.Settings.PolygonRadius;

                this.Set(vertices);
            },
            $ctor2: function (density) {
                this.$initialize();
                FarseerPhysics.Collision.Shapes.Shape.ctor.call(this, density);
                this.ShapeType = FarseerPhysics.Collision.Shapes.ShapeType.Polygon;
                this._radius = FarseerPhysics.Settings.PolygonRadius;
                this.Normals = new FarseerPhysics.Common.Vertices.ctor();
                this.Vertices = new FarseerPhysics.Common.Vertices.ctor();
            },
            ctor: function () {
                this.$initialize();
                FarseerPhysics.Collision.Shapes.Shape.ctor.call(this, 0);
                this.ShapeType = FarseerPhysics.Collision.Shapes.ShapeType.Polygon;
                this._radius = FarseerPhysics.Settings.PolygonRadius;
                this.Normals = new FarseerPhysics.Common.Vertices.ctor();
                this.Vertices = new FarseerPhysics.Common.Vertices.ctor();
            }
        },
        methods: {
            Clone: function () {
                var clone = new FarseerPhysics.Collision.Shapes.PolygonShape.ctor();
                clone.ShapeType = this.ShapeType;
                clone._radius = this._radius;
                clone._density = this._density;

                if (FarseerPhysics.Settings.ConserveMemory) {
                    clone.Vertices = this.Vertices;
                    clone.Normals = this.Normals;
                } else {
                    clone.Vertices = new FarseerPhysics.Common.Vertices.$ctor2(this.Vertices);
                    clone.Normals = new FarseerPhysics.Common.Vertices.$ctor2(this.Normals);
                }

                clone.MassData = this.MassData.$clone();
                return clone;
            },
            /**
             * Copy vertices. This assumes the vertices define a convex polygon.
             It is assumed that the exterior is the the right of each edge.
             *
             * @instance
             * @public
             * @this FarseerPhysics.Collision.Shapes.PolygonShape
             * @memberof FarseerPhysics.Collision.Shapes.PolygonShape
             * @param   {FarseerPhysics.Common.Vertices}    vertices    The vertices.
             * @return  {void}
             */
            Set: function (vertices) {
                System.Diagnostics.Debug.Assert(vertices.Count >= 3 && vertices.Count <= FarseerPhysics.Settings.MaxPolygonVertices);

                if (FarseerPhysics.Settings.ConserveMemory) {
                    this.Vertices = vertices;
                } else {
                    this.Vertices = new FarseerPhysics.Common.Vertices.$ctor2(vertices);
                }

                this.Normals = new FarseerPhysics.Common.Vertices.$ctor3(vertices.Count);

                for (var i = 0; i < vertices.Count; i = (i + 1) | 0) {
                    var i1 = i;
                    var i2 = ((i + 1) | 0) < vertices.Count ? ((i + 1) | 0) : 0;
                    var edge = Microsoft.Xna.Framework.Vector2.op_Subtraction(this.Vertices.getItem(i2).$clone(), this.Vertices.getItem(i1).$clone());
                    System.Diagnostics.Debug.Assert(edge.LengthSquared() > 1.42108547E-14);

                    var temp = new Microsoft.Xna.Framework.Vector2.$ctor2(edge.Y, -edge.X);
                    temp.Normalize();
                    this.Normals.add(temp.$clone());
                }

                for (var i3 = 0; i3 < this.Vertices.Count; i3 = (i3 + 1) | 0) {
                    var i11 = i3;
                    var i21 = ((i3 + 1) | 0) < this.Vertices.Count ? ((i3 + 1) | 0) : 0;
                    var edge1 = Microsoft.Xna.Framework.Vector2.op_Subtraction(this.Vertices.getItem(i21).$clone(), this.Vertices.getItem(i11).$clone());

                    for (var j = 0; j < vertices.Count; j = (j + 1) | 0) {
                        if (j === i11 || j === i21) {
                            continue;
                        }

                        var r = Microsoft.Xna.Framework.Vector2.op_Subtraction(this.Vertices.getItem(j).$clone(), this.Vertices.getItem(i11).$clone());

                        var s = edge1.X * r.Y - edge1.Y * r.X;

                        System.Diagnostics.Debug.Assert(s > 0.0);
                    }
                }

                this.ComputeProperties();
            },
            /**
             * Compute the mass properties of this shape using its dimensions and density.
             The inertia tensor is computed about the local origin, not the centroid.
             *
             * @instance
             * @public
             * @override
             * @this FarseerPhysics.Collision.Shapes.PolygonShape
             * @memberof FarseerPhysics.Collision.Shapes.PolygonShape
             * @return  {void}
             */
            ComputeProperties: function () {

                System.Diagnostics.Debug.Assert(this.Vertices.Count >= 3);

                if (this._density <= 0) {
                    return;
                }

                var center = Microsoft.Xna.Framework.Vector2.Zero.$clone();
                var area = 0.0;
                var I = 0.0;

                var pRef = Microsoft.Xna.Framework.Vector2.Zero.$clone();


                var inv3 = 0.333333343;

                for (var i = 0; i < this.Vertices.Count; i = (i + 1) | 0) {
                    var p1 = pRef.$clone();
                    var p2 = this.Vertices.getItem(i).$clone();
                    var p3 = ((i + 1) | 0) < this.Vertices.Count ? this.Vertices.getItem(((i + 1) | 0)).$clone() : this.Vertices.getItem(0).$clone();

                    var e1 = { v : Microsoft.Xna.Framework.Vector2.op_Subtraction(p2.$clone(), p1.$clone()) };
                    var e2 = { v : Microsoft.Xna.Framework.Vector2.op_Subtraction(p3.$clone(), p1.$clone()) };

                    var d = { };
                    FarseerPhysics.Common.MathUtils.Cross$3(e1, e2, d);

                    var triangleArea = 0.5 * d.v;
                    area += triangleArea;

                    center = Microsoft.Xna.Framework.Vector2.op_Addition(center.$clone(), Microsoft.Xna.Framework.Vector2.op_Multiply$2(triangleArea * inv3, (Microsoft.Xna.Framework.Vector2.op_Addition(Microsoft.Xna.Framework.Vector2.op_Addition(p1.$clone(), p2.$clone()), p3.$clone()))));

                    var px = p1.X, py = p1.Y;
                    var ex1 = e1.v.X, ey1 = e1.v.Y;
                    var ex2 = e2.v.X, ey2 = e2.v.Y;

                    var intx2 = inv3 * (0.25 * (ex1 * ex1 + ex2 * ex1 + ex2 * ex2) + (px * ex1 + px * ex2)) + 0.5 * px * px;
                    var inty2 = inv3 * (0.25 * (ey1 * ey1 + ey2 * ey1 + ey2 * ey2) + (py * ey1 + py * ey2)) + 0.5 * py * py;

                    I += d.v * (intx2 + inty2);
                }

                System.Diagnostics.Debug.Assert(area > FarseerPhysics.Settings.Epsilon);

                this.MassData.Area = area;

                this.MassData.Mass = this._density * area;

                center = Microsoft.Xna.Framework.Vector2.op_Multiply$1(center.$clone(), 1.0 / area);
                this.MassData.Centroid = center.$clone();

                this.MassData.Inertia = this._density * I;
            },
            /**
             * Build vertices to represent an axis-aligned box.
             *
             * @instance
             * @public
             * @this FarseerPhysics.Collision.Shapes.PolygonShape
             * @memberof FarseerPhysics.Collision.Shapes.PolygonShape
             * @param   {number}    halfWidth     The half-width.
             * @param   {number}    halfHeight    The half-height.
             * @return  {void}
             */
            SetAsBox: function (halfWidth, halfHeight) {
                this.Set(FarseerPhysics.Common.PolygonTools.CreateRectangle(halfWidth, halfHeight));
            },
            /**
             * Build vertices to represent an oriented box.
             *
             * @instance
             * @public
             * @this FarseerPhysics.Collision.Shapes.PolygonShape
             * @memberof FarseerPhysics.Collision.Shapes.PolygonShape
             * @param   {number}                             halfWidth     The half-width..
             * @param   {number}                             halfHeight    The half-height.
             * @param   {Microsoft.Xna.Framework.Vector2}    center        The center of the box in local coordinates.
             * @param   {number}                             angle         The rotation of the box in local coordinates.
             * @return  {void}
             */
            SetAsBox$1: function (halfWidth, halfHeight, center, angle) {
                this.Set(FarseerPhysics.Common.PolygonTools.CreateRectangle$1(halfWidth, halfHeight, center.$clone(), angle));
            },
            /**
             * Test a point for containment in this shape. This only works for convex shapes.
             *
             * @instance
             * @public
             * @override
             * @this FarseerPhysics.Collision.Shapes.PolygonShape
             * @memberof FarseerPhysics.Collision.Shapes.PolygonShape
             * @param   {FarseerPhysics.Common.Transform}    transform    The shape world transform.
             * @param   {Microsoft.Xna.Framework.Vector2}    point        a point in world coordinates.
             * @return  {boolean}                                         True if the point is inside the shape
             */
            TestPoint: function (transform, point) {
                var pLocal = FarseerPhysics.Common.MathUtils.MultiplyT(Bridge.ref(transform.v, "R"), Microsoft.Xna.Framework.Vector2.op_Subtraction(point.v.$clone(), transform.v.Position.$clone()));

                for (var i = 0; i < this.Vertices.Count; i = (i + 1) | 0) {
                    var dot = Microsoft.Xna.Framework.Vector2.Dot(this.Normals.getItem(i).$clone(), Microsoft.Xna.Framework.Vector2.op_Subtraction(pLocal.$clone(), this.Vertices.getItem(i).$clone()));
                    if (dot > 0.0) {
                        return false;
                    }
                }

                return true;
            },
            /**
             * Cast a ray against a child shape.
             *
             * @instance
             * @public
             * @override
             * @this FarseerPhysics.Collision.Shapes.PolygonShape
             * @memberof FarseerPhysics.Collision.Shapes.PolygonShape
             * @param   {FarseerPhysics.Collision.RayCastOutput}    output        The ray-cast results.
             * @param   {FarseerPhysics.Collision.RayCastInput}     input         The ray-cast input parameters.
             * @param   {FarseerPhysics.Common.Transform}           transform     The transform to be applied to the shape.
             * @param   {number}                                    childIndex    The child shape index.
             * @return  {boolean}                                                 True if the ray-cast hits the shape
             */
            RayCast: function (output, input, transform, childIndex) {
                output.v = new FarseerPhysics.Collision.RayCastOutput();

                var p1 = FarseerPhysics.Common.MathUtils.MultiplyT(Bridge.ref(transform.v, "R"), Microsoft.Xna.Framework.Vector2.op_Subtraction(input.v.Point1.$clone(), transform.v.Position.$clone()));
                var p2 = FarseerPhysics.Common.MathUtils.MultiplyT(Bridge.ref(transform.v, "R"), Microsoft.Xna.Framework.Vector2.op_Subtraction(input.v.Point2.$clone(), transform.v.Position.$clone()));
                var d = Microsoft.Xna.Framework.Vector2.op_Subtraction(p2.$clone(), p1.$clone());

                var lower = 0.0, upper = input.v.MaxFraction;

                var index = -1;

                for (var i = 0; i < this.Vertices.Count; i = (i + 1) | 0) {
                    var numerator = Microsoft.Xna.Framework.Vector2.Dot(this.Normals.getItem(i).$clone(), Microsoft.Xna.Framework.Vector2.op_Subtraction(this.Vertices.getItem(i).$clone(), p1.$clone()));
                    var denominator = Microsoft.Xna.Framework.Vector2.Dot(this.Normals.getItem(i).$clone(), d.$clone());

                    if (denominator === 0.0) {
                        if (numerator < 0.0) {
                            return false;
                        }
                    } else {
                        if (denominator < 0.0 && numerator < lower * denominator) {
                            lower = numerator / denominator;
                            index = i;
                        } else if (denominator > 0.0 && numerator < upper * denominator) {
                            upper = numerator / denominator;
                        }
                    }

                    if (upper < lower) {
                        return false;
                    }
                }

                System.Diagnostics.Debug.Assert(0.0 <= lower && lower <= input.v.MaxFraction);

                if (index >= 0) {
                    output.v.Fraction = lower;
                    output.v.Normal = FarseerPhysics.Common.MathUtils.Multiply(Bridge.ref(transform.v, "R"), this.Normals.getItem(index).$clone());
                    return true;
                }

                return false;
            },
            /**
             * Given a transform, compute the associated axis aligned bounding box for a child shape.
             *
             * @instance
             * @public
             * @override
             * @this FarseerPhysics.Collision.Shapes.PolygonShape
             * @memberof FarseerPhysics.Collision.Shapes.PolygonShape
             * @param   {FarseerPhysics.Collision.AABB}      aabb          The aabb results.
             * @param   {FarseerPhysics.Common.Transform}    transform     The world transform of the shape.
             * @param   {number}                             childIndex    The child shape index.
             * @return  {void}
             */
            ComputeAABB: function (aabb, transform, childIndex) {
                var lower = FarseerPhysics.Common.MathUtils.Multiply$2(transform, this.Vertices.getItem(0).$clone());
                var upper = lower.$clone();

                for (var i = 1; i < this.Vertices.Count; i = (i + 1) | 0) {
                    var v = FarseerPhysics.Common.MathUtils.Multiply$2(transform, this.Vertices.getItem(i).$clone());
                    lower = Microsoft.Xna.Framework.Vector2.Min(lower.$clone(), v.$clone());
                    upper = Microsoft.Xna.Framework.Vector2.Max(upper.$clone(), v.$clone());
                }

                var r = new Microsoft.Xna.Framework.Vector2.$ctor2(this.Radius, this.Radius);
                aabb.v.LowerBound = Microsoft.Xna.Framework.Vector2.op_Subtraction(lower.$clone(), r.$clone());
                aabb.v.UpperBound = Microsoft.Xna.Framework.Vector2.op_Addition(upper.$clone(), r.$clone());
            },
            CompareTo$1: function (shape) {
                if (this.Vertices.Count !== shape.Vertices.Count) {
                    return false;
                }

                for (var i = 0; i < this.Vertices.Count; i = (i + 1) | 0) {
                    if (Microsoft.Xna.Framework.Vector2.op_Inequality(this.Vertices.getItem(i).$clone(), shape.Vertices.getItem(i).$clone())) {
                        return false;
                    }
                }

                return (this.Radius === shape.Radius && FarseerPhysics.Collision.Shapes.MassData.op_Equality(this.MassData.$clone(), shape.MassData.$clone()));
            },
            ComputeSubmergedArea: function (normal, offset, xf, sc) {
                xf = {v:xf};
                sc.v = Microsoft.Xna.Framework.Vector2.Zero.$clone();

                var normalL = FarseerPhysics.Common.MathUtils.MultiplyT(Bridge.ref(xf.v, "R"), normal.$clone());
                var offsetL = offset - Microsoft.Xna.Framework.Vector2.Dot(normal.$clone(), xf.v.Position.$clone());

                var depths = System.Array.init(FarseerPhysics.Settings.MaxPolygonVertices, 0, System.Single);
                var diveCount = 0;
                var intoIndex = -1;
                var outoIndex = -1;

                var lastSubmerged = false;
                var i;
                for (i = 0; i < this.Vertices.Count; i = (i + 1) | 0) {
                    depths[System.Array.index(i, depths)] = Microsoft.Xna.Framework.Vector2.Dot(normalL.$clone(), this.Vertices.getItem(i).$clone()) - offsetL;
                    var isSubmerged = depths[System.Array.index(i, depths)] < -1.1920929E-07;
                    if (i > 0) {
                        if (isSubmerged) {
                            if (!lastSubmerged) {
                                intoIndex = (i - 1) | 0;
                                diveCount = (diveCount + 1) | 0;
                            }
                        } else {
                            if (lastSubmerged) {
                                outoIndex = (i - 1) | 0;
                                diveCount = (diveCount + 1) | 0;
                            }
                        }
                    }
                    lastSubmerged = isSubmerged;
                }
                switch (diveCount) {
                    case 0: 
                        if (lastSubmerged) {
                            sc.v = FarseerPhysics.Common.MathUtils.Multiply$2(xf, this.MassData.Centroid.$clone());
                            return this.MassData.Mass / this.Density;
                        } else {
                            return 0;
                        }
                        break;
                    case 1: 
                        if (intoIndex === -1) {
                            intoIndex = (this.Vertices.Count - 1) | 0;
                        } else {
                            outoIndex = (this.Vertices.Count - 1) | 0;
                        }
                        break;
                }
                var intoIndex2 = (((intoIndex + 1) | 0)) % this.Vertices.Count;
                var outoIndex2 = (((outoIndex + 1) | 0)) % this.Vertices.Count;

                var intoLambda = (0 - depths[System.Array.index(intoIndex, depths)]) / (depths[System.Array.index(intoIndex2, depths)] - depths[System.Array.index(intoIndex, depths)]);
                var outoLambda = (0 - depths[System.Array.index(outoIndex, depths)]) / (depths[System.Array.index(outoIndex2, depths)] - depths[System.Array.index(outoIndex, depths)]);

                var intoVec = new Microsoft.Xna.Framework.Vector2.$ctor2(this.Vertices.getItem(intoIndex).$clone().X * (1 - intoLambda) + this.Vertices.getItem(intoIndex2).$clone().X * intoLambda, this.Vertices.getItem(intoIndex).$clone().Y * (1 - intoLambda) + this.Vertices.getItem(intoIndex2).$clone().Y * intoLambda);
                var outoVec = new Microsoft.Xna.Framework.Vector2.$ctor2(this.Vertices.getItem(outoIndex).$clone().X * (1 - outoLambda) + this.Vertices.getItem(outoIndex2).$clone().X * outoLambda, this.Vertices.getItem(outoIndex).$clone().Y * (1 - outoLambda) + this.Vertices.getItem(outoIndex2).$clone().Y * outoLambda);

                var area = 0;
                var center = new Microsoft.Xna.Framework.Vector2.$ctor2(0, 0);
                var p2 = this.Vertices.getItem(intoIndex2).$clone();
                var p3 = new Microsoft.Xna.Framework.Vector2();

                var k_inv3 = 0.333333343;

                i = intoIndex2;
                while (i !== outoIndex2) {
                    i = (((i + 1) | 0)) % this.Vertices.Count;
                    if (i === outoIndex2) {
                        p3 = outoVec.$clone();
                    } else {
                        p3 = this.Vertices.getItem(i).$clone();
                    }
                    {
                        var e1 = Microsoft.Xna.Framework.Vector2.op_Subtraction(p2.$clone(), intoVec.$clone());
                        var e2 = Microsoft.Xna.Framework.Vector2.op_Subtraction(p3.$clone(), intoVec.$clone());

                        var D = FarseerPhysics.Common.MathUtils.Cross$2(e1.$clone(), e2.$clone());

                        var triangleArea = 0.5 * D;

                        area += triangleArea;

                        center = Microsoft.Xna.Framework.Vector2.op_Addition(center.$clone(), Microsoft.Xna.Framework.Vector2.op_Multiply$2(triangleArea * k_inv3, (Microsoft.Xna.Framework.Vector2.op_Addition(Microsoft.Xna.Framework.Vector2.op_Addition(intoVec.$clone(), p2.$clone()), p3.$clone()))));
                    }
                    p2 = p3.$clone();
                }

                center = Microsoft.Xna.Framework.Vector2.op_Multiply$1(center.$clone(), 1.0 / area);

                sc.v = FarseerPhysics.Common.MathUtils.Multiply$2(xf, center.$clone());

                return area;
            }
        }
    });

    Bridge.define("FarseerPhysics.Common.Decomposition.Sink", {
        inherits: [FarseerPhysics.Common.Decomposition.Node],
        statics: {
            methods: {
                Isink: function (trapezoid) {
                    if (trapezoid.Sink == null) {
                        return new FarseerPhysics.Common.Decomposition.Sink(trapezoid);
                    }
                    return trapezoid.Sink;
                }
            }
        },
        fields: {
            Trapezoid: null
        },
        ctors: {
            ctor: function (trapezoid) {
                this.$initialize();
                FarseerPhysics.Common.Decomposition.Node.ctor.call(this, null, null);
                this.Trapezoid = trapezoid;
                trapezoid.Sink = this;
            }
        },
        methods: {
            Locate: function (edge) {
                return this;
            }
        }
    });

    Bridge.define("FarseerPhysics.Common.Decomposition.XNode", {
        inherits: [FarseerPhysics.Common.Decomposition.Node],
        fields: {
            _point: null
        },
        ctors: {
            ctor: function (point, lChild, rChild) {
                this.$initialize();
                FarseerPhysics.Common.Decomposition.Node.ctor.call(this, lChild, rChild);
                this._point = point;
            }
        },
        methods: {
            Locate: function (edge) {
                if (edge.P.X >= this._point.X) {
                    return this.RightChild.Locate(edge);
                }
                return this.LeftChild.Locate(edge);
            }
        }
    });

    Bridge.define("FarseerPhysics.Common.Decomposition.YNode", {
        inherits: [FarseerPhysics.Common.Decomposition.Node],
        fields: {
            _edge: null
        },
        ctors: {
            ctor: function (edge, lChild, rChild) {
                this.$initialize();
                FarseerPhysics.Common.Decomposition.Node.ctor.call(this, lChild, rChild);
                this._edge = edge;
            }
        },
        methods: {
            Locate: function (edge) {
                if (this._edge.IsAbove(edge.P)) {
                    return this.RightChild.Locate(edge);
                }

                if (this._edge.IsBelow(edge.P)) {
                    return this.LeftChild.Locate(edge);
                }

                if (edge.Slope < this._edge.Slope) {
                    return this.RightChild.Locate(edge);
                }

                return this.LeftChild.Locate(edge);
            }
        }
    });

    /**
     * Detected vertices of a single polygon.
     *
     * @public
     * @class FarseerPhysics.Common.DetectedVertices
     * @augments FarseerPhysics.Common.Vertices
     */
    Bridge.define("FarseerPhysics.Common.DetectedVertices", {
        inherits: [FarseerPhysics.Common.Vertices],
        fields: {
            _holes: null
        },
        props: {
            Holes: {
                get: function () {
                    return this._holes;
                },
                set: function (value) {
                    this._holes = value;
                }
            }
        },
        ctors: {
            ctor: function () {
                this.$initialize();
                FarseerPhysics.Common.Vertices.ctor.call(this);
            },
            $ctor1: function (vertices) {
                this.$initialize();
                FarseerPhysics.Common.Vertices.$ctor2.call(this, vertices);
            }
        },
        methods: {
            Transform: function (transform) {
                transform = {v:transform};
                for (var i = 0; i < this.Count; i = (i + 1) | 0) {
                    this.setItem(i, Microsoft.Xna.Framework.Vector2.Transform(this.getItem(i).$clone(), transform.v.$clone()));
                }

                var temp = null;
                if (this._holes != null && this._holes.Count > 0) {
                    for (var i1 = 0; i1 < this._holes.Count; i1 = (i1 + 1) | 0) {
                        temp = this._holes.getItem(i1).ToArray();
                        Microsoft.Xna.Framework.Vector2.Transform$4(temp, transform, temp);

                        this._holes.setItem(i1, new FarseerPhysics.Common.Vertices.$ctor1(temp));
                    }
                }
            }
        }
    });

    Bridge.define("FarseerPhysics.Common.PhysicsLogic.PhysicsLogic", {
        inherits: [FarseerPhysics.Dynamics.FilterData],
        fields: {
            _type: 0,
            World: null
        },
        ctors: {
            ctor: function (world, type) {
                this.$initialize();
                FarseerPhysics.Dynamics.FilterData.ctor.call(this);
                this._type = type;
                this.World = world;
            }
        },
        methods: {
            IsActiveOn: function (body) {
                if (body.PhysicsLogicFilter.IsPhysicsLogicIgnored(this._type)) {
                    return false;
                }

                return FarseerPhysics.Dynamics.FilterData.prototype.IsActiveOn.call(this, body);
            }
        }
    });

    Bridge.define("FarseerPhysics.Controllers.Controller", {
        inherits: [FarseerPhysics.Dynamics.FilterData],
        fields: {
            Enabled: false,
            World: null,
            _type: 0
        },
        ctors: {
            ctor: function (controllerType) {
                this.$initialize();
                FarseerPhysics.Dynamics.FilterData.ctor.call(this);
                this._type = controllerType;
            }
        },
        methods: {
            IsActiveOn: function (body) {
                if (body.ControllerFilter.IsControllerIgnored(this._type)) {
                    return false;
                }

                return FarseerPhysics.Dynamics.FilterData.prototype.IsActiveOn.call(this, body);
            }
        }
    });

    /**
     * Maintains a fixed angle between two bodies
     *
     * @public
     * @class FarseerPhysics.Dynamics.Joints.AngleJoint
     * @augments FarseerPhysics.Dynamics.Joints.Joint
     */
    Bridge.define("FarseerPhysics.Dynamics.Joints.AngleJoint", {
        inherits: [FarseerPhysics.Dynamics.Joints.Joint],
        fields: {
            BiasFactor: 0,
            MaxImpulse: 0,
            Softness: 0,
            _bias: 0,
            _jointError: 0,
            _massFactor: 0,
            _targetAngle: 0
        },
        props: {
            TargetAngle: {
                get: function () {
                    return this._targetAngle;
                },
                set: function (value) {
                    if (value !== this._targetAngle) {
                        this._targetAngle = value;
                        this.WakeBodies();
                    }
                }
            },
            WorldAnchorA: {
                get: function () {
                    return this.BodyA.Position.$clone();
                }
            },
            WorldAnchorB: {
                get: function () {
                    return this.BodyB.Position.$clone();
                },
                set: function (value) {
                    System.Diagnostics.Debug.Assert$1(false, "You can't set the world anchor on this joint type.");
                }
            }
        },
        ctors: {
            ctor: function () {
                this.$initialize();
                FarseerPhysics.Dynamics.Joints.Joint.ctor.call(this);
                this.JointType = FarseerPhysics.Dynamics.Joints.JointType.Angle;
            },
            $ctor1: function (bodyA, bodyB) {
                this.$initialize();
                FarseerPhysics.Dynamics.Joints.Joint.$ctor2.call(this, bodyA, bodyB);
                this.JointType = FarseerPhysics.Dynamics.Joints.JointType.Angle;
                this.TargetAngle = 0;
                this.BiasFactor = 0.2;
                this.Softness = 0.0;
                this.MaxImpulse = 3.40282347E+38;
            }
        },
        methods: {
            GetReactionForce: function (inv_dt) {
                return Microsoft.Xna.Framework.Vector2.Zero.$clone();
            },
            GetReactionTorque: function (inv_dt) {
                return 0;
            },
            InitVelocityConstraints: function (step) {
                this._jointError = (this.BodyB.Sweep.A - this.BodyA.Sweep.A - this.TargetAngle);

                this._bias = -this.BiasFactor * step.v.inv_dt * this._jointError;

                this._massFactor = (1 - this.Softness) / (this.BodyA.InvI + this.BodyB.InvI);
            },
            SolveVelocityConstraints: function (step) {
                var $t, $t1;
                var p = (this._bias - this.BodyB.AngularVelocity + this.BodyA.AngularVelocity) * this._massFactor;
                $t = this.BodyA;
                $t.AngularVelocity -= this.BodyA.InvI * Bridge.Int.sign(p) * Math.min(Math.abs(p), this.MaxImpulse);
                $t1 = this.BodyB;
                $t1.AngularVelocity += this.BodyB.InvI * Bridge.Int.sign(p) * Math.min(Math.abs(p), this.MaxImpulse);
            },
            SolvePositionConstraints: function () {
                return true;
            }
        }
    });

    /**
     * A distance joint rains two points on two bodies
     to remain at a fixed distance from each other. You can view
     this as a massless, rigid rod.
     *
     * @public
     * @class FarseerPhysics.Dynamics.Joints.DistanceJoint
     * @augments FarseerPhysics.Dynamics.Joints.Joint
     */
    Bridge.define("FarseerPhysics.Dynamics.Joints.DistanceJoint", {
        inherits: [FarseerPhysics.Dynamics.Joints.Joint],
        fields: {
            /**
             * The local anchor point relative to bodyA's origin.
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Dynamics.Joints.DistanceJoint
             * @type Microsoft.Xna.Framework.Vector2
             */
            LocalAnchorA: null,
            /**
             * The local anchor point relative to bodyB's origin.
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Dynamics.Joints.DistanceJoint
             * @type Microsoft.Xna.Framework.Vector2
             */
            LocalAnchorB: null,
            _bias: 0,
            _gamma: 0,
            _impulse: 0,
            _mass: 0,
            _tmpFloat1: 0,
            _tmpVector1: null,
            _u: null,
            /**
             * The natural length between the anchor points.
             Manipulating the length can lead to non-physical behavior when the frequency is zero.
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Dynamics.Joints.DistanceJoint
             * @function Length
             * @type number
             */
            Length: 0,
            /**
             * The mass-spring-damper frequency in Hertz.
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Dynamics.Joints.DistanceJoint
             * @function Frequency
             * @type number
             */
            Frequency: 0,
            /**
             * The damping ratio. 0 = no damping, 1 = critical damping.
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Dynamics.Joints.DistanceJoint
             * @function DampingRatio
             * @type number
             */
            DampingRatio: 0
        },
        props: {
            WorldAnchorA: {
                get: function () {
                    return this.BodyA.GetWorldPoint(this.LocalAnchorA.$clone());
                }
            },
            WorldAnchorB: {
                get: function () {
                    return this.BodyB.GetWorldPoint(this.LocalAnchorB.$clone());
                },
                set: function (value) {
                    System.Diagnostics.Debug.Assert$1(false, "You can't set the world anchor on this joint type.");
                }
            }
        },
        ctors: {
            init: function () {
                this.LocalAnchorA = new Microsoft.Xna.Framework.Vector2();
                this.LocalAnchorB = new Microsoft.Xna.Framework.Vector2();
                this._tmpVector1 = new Microsoft.Xna.Framework.Vector2();
                this._u = new Microsoft.Xna.Framework.Vector2();
            },
            ctor: function () {
                this.$initialize();
                FarseerPhysics.Dynamics.Joints.Joint.ctor.call(this);
                this.JointType = FarseerPhysics.Dynamics.Joints.JointType.Distance;
            },
            /**
             * This requires defining an
             anchor point on both bodies and the non-zero length of the
             distance joint. If you don't supply a length, the local anchor points
             is used so that the initial configuration can violate the constraint
             slightly. This helps when saving and loading a game.
             @warning Do not use a zero or short length.
             *
             * @instance
             * @public
             * @this FarseerPhysics.Dynamics.Joints.DistanceJoint
             * @memberof FarseerPhysics.Dynamics.Joints.DistanceJoint
             * @param   {FarseerPhysics.Dynamics.Body}       bodyA           The first body
             * @param   {FarseerPhysics.Dynamics.Body}       bodyB           The second body
             * @param   {Microsoft.Xna.Framework.Vector2}    localAnchorA    The first body anchor
             * @param   {Microsoft.Xna.Framework.Vector2}    localAnchorB    The second body anchor
             * @return  {void}
             */
            $ctor1: function (bodyA, bodyB, localAnchorA, localAnchorB) {
                this.$initialize();
                FarseerPhysics.Dynamics.Joints.Joint.$ctor2.call(this, bodyA, bodyB);
                this.JointType = FarseerPhysics.Dynamics.Joints.JointType.Distance;

                this.LocalAnchorA = localAnchorA.$clone();
                this.LocalAnchorB = localAnchorB.$clone();

                var d = Microsoft.Xna.Framework.Vector2.op_Subtraction(this.WorldAnchorB.$clone(), this.WorldAnchorA.$clone());
                this.Length = d.Length();
            }
        },
        methods: {
            GetReactionForce: function (inv_dt) {
                var F = Microsoft.Xna.Framework.Vector2.op_Multiply$2((inv_dt * this._impulse), this._u.$clone());
                return F.$clone();
            },
            GetReactionTorque: function (inv_dt) {
                return 0.0;
            },
            InitVelocityConstraints: function (step) {
                var b1 = this.BodyA;
                var b2 = this.BodyB;

                var r1 = { v : FarseerPhysics.Common.MathUtils.Multiply(Bridge.ref(b1.Xf, "R"), Microsoft.Xna.Framework.Vector2.op_Subtraction(this.LocalAnchorA.$clone(), b1.LocalCenter.$clone())) };
                var r2 = { v : FarseerPhysics.Common.MathUtils.Multiply(Bridge.ref(b2.Xf, "R"), Microsoft.Xna.Framework.Vector2.op_Subtraction(this.LocalAnchorB.$clone(), b2.LocalCenter.$clone())) };
                this._u = Microsoft.Xna.Framework.Vector2.op_Subtraction(Microsoft.Xna.Framework.Vector2.op_Subtraction(Microsoft.Xna.Framework.Vector2.op_Addition(b2.Sweep.C.$clone(), r2.v.$clone()), b1.Sweep.C.$clone()), r1.v.$clone());

                var length = this._u.Length();
                if (length > FarseerPhysics.Settings.LinearSlop) {
                    this._u = Microsoft.Xna.Framework.Vector2.op_Multiply$1(this._u.$clone(), 1.0 / length);
                } else {
                    this._u = Microsoft.Xna.Framework.Vector2.Zero.$clone();
                }

                var cr1u = { }, cr2u = { };
                FarseerPhysics.Common.MathUtils.Cross$3(r1, Bridge.ref(this, "_u"), cr1u);
                FarseerPhysics.Common.MathUtils.Cross$3(r2, Bridge.ref(this, "_u"), cr2u);
                var invMass = b1.InvMass + b1.InvI * cr1u.v * cr1u.v + b2.InvMass + b2.InvI * cr2u.v * cr2u.v;
                System.Diagnostics.Debug.Assert(invMass > FarseerPhysics.Settings.Epsilon);
                this._mass = invMass !== 0.0 ? 1.0 / invMass : 0.0;

                if (this.Frequency > 0.0) {
                    var C = length - this.Length;

                    var omega = 6.28318548 * this.Frequency;

                    var d = 2.0 * this._mass * this.DampingRatio * omega;

                    var k = this._mass * omega * omega;

                    this._gamma = step.v.dt * (d + step.v.dt * k);
                    this._gamma = this._gamma !== 0.0 ? 1.0 / this._gamma : 0.0;
                    this._bias = C * step.v.dt * k * this._gamma;

                    this._mass = invMass + this._gamma;
                    this._mass = this._mass !== 0.0 ? 1.0 / this._mass : 0.0;
                }

                if (FarseerPhysics.Settings.EnableWarmstarting) {
                    this._impulse *= step.v.dtRatio;

                    var P = { v : Microsoft.Xna.Framework.Vector2.op_Multiply$2(this._impulse, this._u.$clone()) };
                    b1.LinearVelocityInternal = Microsoft.Xna.Framework.Vector2.op_Subtraction(b1.LinearVelocityInternal.$clone(), Microsoft.Xna.Framework.Vector2.op_Multiply$2(b1.InvMass, P.v.$clone()));
                    FarseerPhysics.Common.MathUtils.Cross$3(r1, P, Bridge.ref(this, "_tmpFloat1"));
                    b1.AngularVelocityInternal -= b1.InvI * this._tmpFloat1;
                    b2.LinearVelocityInternal = Microsoft.Xna.Framework.Vector2.op_Addition(b2.LinearVelocityInternal.$clone(), Microsoft.Xna.Framework.Vector2.op_Multiply$2(b2.InvMass, P.v.$clone()));
                    FarseerPhysics.Common.MathUtils.Cross$3(r2, P, Bridge.ref(this, "_tmpFloat1"));
                    b2.AngularVelocityInternal += b2.InvI * this._tmpFloat1;
                } else {
                    this._impulse = 0.0;
                }
            },
            SolveVelocityConstraints: function (step) {
                var b1 = this.BodyA;
                var b2 = this.BodyB;

                var xf1 = { v : new FarseerPhysics.Common.Transform() }, xf2 = { v : new FarseerPhysics.Common.Transform() };
                b1.GetTransform(xf1);
                b2.GetTransform(xf2);

                var r1 = { v : FarseerPhysics.Common.MathUtils.Multiply(Bridge.ref(xf1.v, "R"), Microsoft.Xna.Framework.Vector2.op_Subtraction(this.LocalAnchorA.$clone(), b1.LocalCenter.$clone())) };
                var r2 = { v : FarseerPhysics.Common.MathUtils.Multiply(Bridge.ref(xf2.v, "R"), Microsoft.Xna.Framework.Vector2.op_Subtraction(this.LocalAnchorB.$clone(), b2.LocalCenter.$clone())) };

                FarseerPhysics.Common.MathUtils.Cross$4(b1.AngularVelocityInternal, r1, Bridge.ref(this, "_tmpVector1"));
                var v1 = Microsoft.Xna.Framework.Vector2.op_Addition(b1.LinearVelocityInternal.$clone(), this._tmpVector1.$clone());
                FarseerPhysics.Common.MathUtils.Cross$4(b2.AngularVelocityInternal, r2, Bridge.ref(this, "_tmpVector1"));
                var v2 = Microsoft.Xna.Framework.Vector2.op_Addition(b2.LinearVelocityInternal.$clone(), this._tmpVector1.$clone());
                var Cdot = Microsoft.Xna.Framework.Vector2.Dot(this._u.$clone(), Microsoft.Xna.Framework.Vector2.op_Subtraction(v2.$clone(), v1.$clone()));

                var impulse = -this._mass * (Cdot + this._bias + this._gamma * this._impulse);
                this._impulse += impulse;

                var P = { v : Microsoft.Xna.Framework.Vector2.op_Multiply$2(impulse, this._u.$clone()) };
                b1.LinearVelocityInternal = Microsoft.Xna.Framework.Vector2.op_Subtraction(b1.LinearVelocityInternal.$clone(), Microsoft.Xna.Framework.Vector2.op_Multiply$2(b1.InvMass, P.v.$clone()));
                FarseerPhysics.Common.MathUtils.Cross$3(r1, P, Bridge.ref(this, "_tmpFloat1"));
                b1.AngularVelocityInternal -= b1.InvI * this._tmpFloat1;
                b2.LinearVelocityInternal = Microsoft.Xna.Framework.Vector2.op_Addition(b2.LinearVelocityInternal.$clone(), Microsoft.Xna.Framework.Vector2.op_Multiply$2(b2.InvMass, P.v.$clone()));
                FarseerPhysics.Common.MathUtils.Cross$3(r2, P, Bridge.ref(this, "_tmpFloat1"));
                b2.AngularVelocityInternal += b2.InvI * this._tmpFloat1;
            },
            SolvePositionConstraints: function () {
                if (this.Frequency > 0.0) {
                    return true;
                }

                var b1 = this.BodyA;
                var b2 = this.BodyB;

                var xf1 = { v : new FarseerPhysics.Common.Transform() }, xf2 = { v : new FarseerPhysics.Common.Transform() };
                b1.GetTransform(xf1);
                b2.GetTransform(xf2);

                var r1 = { v : FarseerPhysics.Common.MathUtils.Multiply(Bridge.ref(xf1.v, "R"), Microsoft.Xna.Framework.Vector2.op_Subtraction(this.LocalAnchorA.$clone(), b1.LocalCenter.$clone())) };
                var r2 = { v : FarseerPhysics.Common.MathUtils.Multiply(Bridge.ref(xf2.v, "R"), Microsoft.Xna.Framework.Vector2.op_Subtraction(this.LocalAnchorB.$clone(), b2.LocalCenter.$clone())) };

                var d = Microsoft.Xna.Framework.Vector2.op_Subtraction(Microsoft.Xna.Framework.Vector2.op_Subtraction(Microsoft.Xna.Framework.Vector2.op_Addition(b2.Sweep.C.$clone(), r2.v.$clone()), b1.Sweep.C.$clone()), r1.v.$clone());

                var length = d.Length();

                if (length === 0.0) {
                    return true;
                }

                d = Microsoft.Xna.Framework.Vector2.op_Division$1(d.$clone(), length);
                var C = length - this.Length;
                C = FarseerPhysics.Common.MathUtils.Clamp$2(C, -0.2, FarseerPhysics.Settings.MaxLinearCorrection);

                var impulse = -this._mass * C;
                this._u = d.$clone();
                var P = { v : Microsoft.Xna.Framework.Vector2.op_Multiply$2(impulse, this._u.$clone()) };

                b1.Sweep.C = Microsoft.Xna.Framework.Vector2.op_Subtraction(b1.Sweep.C.$clone(), Microsoft.Xna.Framework.Vector2.op_Multiply$2(b1.InvMass, P.v.$clone()));
                FarseerPhysics.Common.MathUtils.Cross$3(r1, P, Bridge.ref(this, "_tmpFloat1"));
                b1.Sweep.A -= b1.InvI * this._tmpFloat1;
                b2.Sweep.C = Microsoft.Xna.Framework.Vector2.op_Addition(b2.Sweep.C.$clone(), Microsoft.Xna.Framework.Vector2.op_Multiply$2(b2.InvMass, P.v.$clone()));
                FarseerPhysics.Common.MathUtils.Cross$3(r2, P, Bridge.ref(this, "_tmpFloat1"));
                b2.Sweep.A += b2.InvI * this._tmpFloat1;

                b1.SynchronizeTransform();
                b2.SynchronizeTransform();

                return Math.abs(C) < FarseerPhysics.Settings.LinearSlop;
            }
        }
    });

    Bridge.define("FarseerPhysics.Dynamics.Joints.FixedAngleJoint", {
        inherits: [FarseerPhysics.Dynamics.Joints.Joint],
        fields: {
            BiasFactor: 0,
            MaxImpulse: 0,
            Softness: 0,
            _bias: 0,
            _jointError: 0,
            _massFactor: 0,
            _targetAngle: 0
        },
        props: {
            TargetAngle: {
                get: function () {
                    return this._targetAngle;
                },
                set: function (value) {
                    if (value !== this._targetAngle) {
                        this._targetAngle = value;
                        this.WakeBodies();
                    }
                }
            },
            WorldAnchorA: {
                get: function () {
                    return this.BodyA.Position.$clone();
                }
            },
            WorldAnchorB: {
                get: function () {
                    return this.BodyA.Position.$clone();
                },
                set: function (value) {
                    System.Diagnostics.Debug.Assert$1(false, "You can't set the world anchor on this joint type.");
                }
            }
        },
        ctors: {
            ctor: function (bodyA) {
                this.$initialize();
                FarseerPhysics.Dynamics.Joints.Joint.$ctor1.call(this, bodyA);
                this.JointType = FarseerPhysics.Dynamics.Joints.JointType.FixedAngle;
                this.TargetAngle = 0;
                this.BiasFactor = 0.2;
                this.Softness = 0.0;
                this.MaxImpulse = 3.40282347E+38;
            }
        },
        methods: {
            GetReactionForce: function (inv_dt) {
                return Microsoft.Xna.Framework.Vector2.Zero.$clone();
            },
            GetReactionTorque: function (inv_dt) {
                return 0;
            },
            InitVelocityConstraints: function (step) {
                this._jointError = this.BodyA.Sweep.A - this.TargetAngle;

                this._bias = -this.BiasFactor * step.v.inv_dt * this._jointError;

                this._massFactor = (1 - this.Softness) / (this.BodyA.InvI);
            },
            SolveVelocityConstraints: function (step) {
                var $t;
                var p = (this._bias - this.BodyA.AngularVelocity) * this._massFactor;
                $t = this.BodyA;
                $t.AngularVelocity += this.BodyA.InvI * Bridge.Int.sign(p) * Math.min(Math.abs(p), this.MaxImpulse);
            },
            SolvePositionConstraints: function () {
                return true;
            }
        }
    });

    /**
     * A distance joint rains two points on two bodies
     to remain at a fixed distance from each other. You can view
     this as a massless, rigid rod.
     *
     * @public
     * @class FarseerPhysics.Dynamics.Joints.FixedDistanceJoint
     * @augments FarseerPhysics.Dynamics.Joints.Joint
     */
    Bridge.define("FarseerPhysics.Dynamics.Joints.FixedDistanceJoint", {
        inherits: [FarseerPhysics.Dynamics.Joints.Joint],
        fields: {
            /**
             * The local anchor point relative to bodyA's origin.
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Dynamics.Joints.FixedDistanceJoint
             * @type Microsoft.Xna.Framework.Vector2
             */
            LocalAnchorA: null,
            _bias: 0,
            _gamma: 0,
            _impulse: 0,
            _mass: 0,
            _u: null,
            _worldAnchorB: null,
            /**
             * The natural length between the anchor points.
             Manipulating the length can lead to non-physical behavior when the frequency is zero.
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Dynamics.Joints.FixedDistanceJoint
             * @function Length
             * @type number
             */
            Length: 0,
            /**
             * The mass-spring-damper frequency in Hertz.
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Dynamics.Joints.FixedDistanceJoint
             * @function Frequency
             * @type number
             */
            Frequency: 0,
            /**
             * The damping ratio. 0 = no damping, 1 = critical damping.
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Dynamics.Joints.FixedDistanceJoint
             * @function DampingRatio
             * @type number
             */
            DampingRatio: 0
        },
        props: {
            WorldAnchorA: {
                get: function () {
                    return this.BodyA.GetWorldPoint(this.LocalAnchorA.$clone());
                }
            },
            WorldAnchorB: {
                get: function () {
                    return this._worldAnchorB.$clone();
                },
                set: function (value) {
                    this._worldAnchorB = value.$clone();
                }
            }
        },
        ctors: {
            init: function () {
                this.LocalAnchorA = new Microsoft.Xna.Framework.Vector2();
                this._u = new Microsoft.Xna.Framework.Vector2();
                this._worldAnchorB = new Microsoft.Xna.Framework.Vector2();
            },
            /**
             * This requires defining an
             anchor point on both bodies and the non-zero length of the
             distance joint. If you don't supply a length, the local anchor points
             is used so that the initial configuration can violate the constraint
             slightly. This helps when saving and loading a game.
             @warning Do not use a zero or short length.
             *
             * @instance
             * @public
             * @this FarseerPhysics.Dynamics.Joints.FixedDistanceJoint
             * @memberof FarseerPhysics.Dynamics.Joints.FixedDistanceJoint
             * @param   {FarseerPhysics.Dynamics.Body}       body           The body.
             * @param   {Microsoft.Xna.Framework.Vector2}    bodyAnchor     The body anchor.
             * @param   {Microsoft.Xna.Framework.Vector2}    worldAnchor    The world anchor.
             * @return  {void}
             */
            ctor: function (body, bodyAnchor, worldAnchor) {
                this.$initialize();
                FarseerPhysics.Dynamics.Joints.Joint.$ctor1.call(this, body);
                this.JointType = FarseerPhysics.Dynamics.Joints.JointType.FixedDistance;

                this.LocalAnchorA = bodyAnchor.$clone();
                this._worldAnchorB = worldAnchor.$clone();

                var d = Microsoft.Xna.Framework.Vector2.op_Subtraction(this.WorldAnchorB.$clone(), this.WorldAnchorA.$clone());
                this.Length = d.Length();
            }
        },
        methods: {
            GetReactionForce: function (invDt) {
                return Microsoft.Xna.Framework.Vector2.op_Multiply$2((invDt * this._impulse), this._u.$clone());
            },
            GetReactionTorque: function (invDt) {
                return 0.0;
            },
            InitVelocityConstraints: function (step) {
                var b1 = this.BodyA;

                var xf1 = { v : new FarseerPhysics.Common.Transform() };
                b1.GetTransform(xf1);

                var r1 = FarseerPhysics.Common.MathUtils.Multiply(Bridge.ref(xf1.v, "R"), Microsoft.Xna.Framework.Vector2.op_Subtraction(this.LocalAnchorA.$clone(), b1.LocalCenter.$clone()));
                var r2 = this._worldAnchorB.$clone();
                this._u = Microsoft.Xna.Framework.Vector2.op_Subtraction(Microsoft.Xna.Framework.Vector2.op_Subtraction(r2.$clone(), b1.Sweep.C.$clone()), r1.$clone());

                var length = this._u.Length();
                if (length > FarseerPhysics.Settings.LinearSlop) {
                    this._u = Microsoft.Xna.Framework.Vector2.op_Multiply$1(this._u.$clone(), 1.0 / length);
                } else {
                    this._u = Microsoft.Xna.Framework.Vector2.Zero.$clone();
                }

                var cr1u = FarseerPhysics.Common.MathUtils.Cross$2(r1.$clone(), this._u.$clone());
                var cr2u = FarseerPhysics.Common.MathUtils.Cross$2(r2.$clone(), this._u.$clone());
                var invMass = b1.InvMass + b1.InvI * cr1u * cr1u + 0 * cr2u * cr2u;
                System.Diagnostics.Debug.Assert(invMass > FarseerPhysics.Settings.Epsilon);
                this._mass = invMass !== 0.0 ? 1.0 / invMass : 0.0;

                if (this.Frequency > 0.0) {
                    var C = length - this.Length;

                    var omega = 6.28318548 * this.Frequency;

                    var d = 2.0 * this._mass * this.DampingRatio * omega;

                    var k = this._mass * omega * omega;

                    this._gamma = step.v.dt * (d + step.v.dt * k);
                    this._gamma = this._gamma !== 0.0 ? 1.0 / this._gamma : 0.0;
                    this._bias = C * step.v.dt * k * this._gamma;

                    this._mass = invMass + this._gamma;
                    this._mass = this._mass !== 0.0 ? 1.0 / this._mass : 0.0;
                }

                if (FarseerPhysics.Settings.EnableWarmstarting) {
                    this._impulse *= step.v.dtRatio;

                    var P = Microsoft.Xna.Framework.Vector2.op_Multiply$2(this._impulse, this._u.$clone());
                    b1.LinearVelocityInternal = Microsoft.Xna.Framework.Vector2.op_Subtraction(b1.LinearVelocityInternal.$clone(), Microsoft.Xna.Framework.Vector2.op_Multiply$2(b1.InvMass, P.$clone()));
                    b1.AngularVelocityInternal -= b1.InvI * FarseerPhysics.Common.MathUtils.Cross$2(r1.$clone(), P.$clone());
                } else {
                    this._impulse = 0.0;
                }
            },
            SolveVelocityConstraints: function (step) {
                var b1 = this.BodyA;

                var xf1 = { v : new FarseerPhysics.Common.Transform() };
                b1.GetTransform(xf1);

                var r1 = FarseerPhysics.Common.MathUtils.Multiply(Bridge.ref(xf1.v, "R"), Microsoft.Xna.Framework.Vector2.op_Subtraction(this.LocalAnchorA.$clone(), b1.LocalCenter.$clone()));

                var v1 = Microsoft.Xna.Framework.Vector2.op_Addition(b1.LinearVelocityInternal.$clone(), FarseerPhysics.Common.MathUtils.Cross$1(b1.AngularVelocityInternal, r1.$clone()));
                var v2 = Microsoft.Xna.Framework.Vector2.Zero.$clone();
                var Cdot = Microsoft.Xna.Framework.Vector2.Dot(this._u.$clone(), Microsoft.Xna.Framework.Vector2.op_Subtraction(v2.$clone(), v1.$clone()));

                var impulse = -this._mass * (Cdot + this._bias + this._gamma * this._impulse);
                this._impulse += impulse;

                var P = Microsoft.Xna.Framework.Vector2.op_Multiply$2(impulse, this._u.$clone());
                b1.LinearVelocityInternal = Microsoft.Xna.Framework.Vector2.op_Subtraction(b1.LinearVelocityInternal.$clone(), Microsoft.Xna.Framework.Vector2.op_Multiply$2(b1.InvMass, P.$clone()));
                b1.AngularVelocityInternal -= b1.InvI * FarseerPhysics.Common.MathUtils.Cross$2(r1.$clone(), P.$clone());
            },
            SolvePositionConstraints: function () {
                if (this.Frequency > 0.0) {
                    return true;
                }

                var b1 = this.BodyA;

                var xf1 = { v : new FarseerPhysics.Common.Transform() };
                b1.GetTransform(xf1);

                var r1 = FarseerPhysics.Common.MathUtils.Multiply(Bridge.ref(xf1.v, "R"), Microsoft.Xna.Framework.Vector2.op_Subtraction(this.LocalAnchorA.$clone(), b1.LocalCenter.$clone()));
                var r2 = this._worldAnchorB.$clone();

                var d = Microsoft.Xna.Framework.Vector2.op_Subtraction(Microsoft.Xna.Framework.Vector2.op_Subtraction(r2.$clone(), b1.Sweep.C.$clone()), r1.$clone());

                var length = d.Length();

                if (length === 0.0) {
                    return true;
                }

                d = Microsoft.Xna.Framework.Vector2.op_Division$1(d.$clone(), length);
                var C = length - this.Length;
                C = FarseerPhysics.Common.MathUtils.Clamp$2(C, -0.2, FarseerPhysics.Settings.MaxLinearCorrection);

                var impulse = -this._mass * C;
                this._u = d.$clone();
                var P = Microsoft.Xna.Framework.Vector2.op_Multiply$2(impulse, this._u.$clone());

                b1.Sweep.C = Microsoft.Xna.Framework.Vector2.op_Subtraction(b1.Sweep.C.$clone(), Microsoft.Xna.Framework.Vector2.op_Multiply$2(b1.InvMass, P.$clone()));
                b1.Sweep.A -= b1.InvI * FarseerPhysics.Common.MathUtils.Cross$2(r1.$clone(), P.$clone());

                b1.SynchronizeTransform();

                return Math.abs(C) < FarseerPhysics.Settings.LinearSlop;
            }
        }
    });

    /**
     * Friction joint. This is used for top-down friction.
     It provides 2D translational friction and angular friction.
     *
     * @public
     * @class FarseerPhysics.Dynamics.Joints.FixedFrictionJoint
     * @augments FarseerPhysics.Dynamics.Joints.Joint
     */
    Bridge.define("FarseerPhysics.Dynamics.Joints.FixedFrictionJoint", {
        inherits: [FarseerPhysics.Dynamics.Joints.Joint],
        fields: {
            LocalAnchorA: null,
            /**
             * The maximum friction force in N.
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Dynamics.Joints.FixedFrictionJoint
             * @type number
             */
            MaxForce: 0,
            /**
             * The maximum friction torque in N-m.
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Dynamics.Joints.FixedFrictionJoint
             * @type number
             */
            MaxTorque: 0,
            _angularImpulse: 0,
            _angularMass: 0,
            _linearImpulse: null,
            _linearMass: null
        },
        props: {
            WorldAnchorA: {
                get: function () {
                    return this.BodyA.GetWorldPoint(this.LocalAnchorA.$clone());
                }
            },
            WorldAnchorB: {
                get: function () {
                    return Microsoft.Xna.Framework.Vector2.Zero.$clone();
                },
                set: function (value) {
                    System.Diagnostics.Debug.Assert$1(false, "You can't set the world anchor on this joint type.");
                }
            }
        },
        ctors: {
            init: function () {
                this.LocalAnchorA = new Microsoft.Xna.Framework.Vector2();
                this._linearImpulse = new Microsoft.Xna.Framework.Vector2();
                this._linearMass = new FarseerPhysics.Common.Mat22();
            },
            ctor: function (body, localAnchorA) {
                this.$initialize();
                FarseerPhysics.Dynamics.Joints.Joint.$ctor1.call(this, body);
                this.JointType = FarseerPhysics.Dynamics.Joints.JointType.FixedFriction;
                this.LocalAnchorA = localAnchorA.$clone();

                var gravity = 10.0;

                var radius = Math.sqrt(2.0 * (body.Inertia / body.Mass));

                this.MaxForce = body.Mass * gravity;
                this.MaxTorque = body.Mass * radius * gravity;
            }
        },
        methods: {
            GetReactionForce: function (invDT) {
                return Microsoft.Xna.Framework.Vector2.op_Multiply$2(invDT, this._linearImpulse.$clone());
            },
            GetReactionTorque: function (invDT) {
                return invDT * this._angularImpulse;
            },
            InitVelocityConstraints: function (step) {
                var bA = this.BodyA;

                var xfA = { v : new FarseerPhysics.Common.Transform() };
                bA.GetTransform(xfA);

                var rA = FarseerPhysics.Common.MathUtils.Multiply(Bridge.ref(xfA.v, "R"), Microsoft.Xna.Framework.Vector2.op_Subtraction(this.LocalAnchorA.$clone(), bA.LocalCenter.$clone()));



                var mA = bA.InvMass;
                var iA = bA.InvI;

                var K1 = { v : new FarseerPhysics.Common.Mat22.ctor() };
                K1.v.Col1.X = mA;
                K1.v.Col2.X = 0.0;
                K1.v.Col1.Y = 0.0;
                K1.v.Col2.Y = mA;

                var K2 = { v : new FarseerPhysics.Common.Mat22.ctor() };
                K2.v.Col1.X = iA * rA.Y * rA.Y;
                K2.v.Col2.X = -iA * rA.X * rA.Y;
                K2.v.Col1.Y = -iA * rA.X * rA.Y;
                K2.v.Col2.Y = iA * rA.X * rA.X;

                var K12 = { v : new FarseerPhysics.Common.Mat22() };
                FarseerPhysics.Common.Mat22.Add(K1, K2, K12);

                this._linearMass = K12.v.Inverse.$clone();

                this._angularMass = iA;
                if (this._angularMass > 0.0) {
                    this._angularMass = 1.0 / this._angularMass;
                }

                if (FarseerPhysics.Settings.EnableWarmstarting) {
                    this._linearImpulse = Microsoft.Xna.Framework.Vector2.op_Multiply$1(this._linearImpulse.$clone(), step.v.dtRatio);
                    this._angularImpulse *= step.v.dtRatio;

                    var P = new Microsoft.Xna.Framework.Vector2.$ctor2(this._linearImpulse.X, this._linearImpulse.Y);

                    bA.LinearVelocityInternal = Microsoft.Xna.Framework.Vector2.op_Subtraction(bA.LinearVelocityInternal.$clone(), Microsoft.Xna.Framework.Vector2.op_Multiply$2(mA, P.$clone()));
                    bA.AngularVelocityInternal -= iA * (FarseerPhysics.Common.MathUtils.Cross$2(rA.$clone(), P.$clone()) + this._angularImpulse);
                } else {
                    this._linearImpulse = Microsoft.Xna.Framework.Vector2.Zero.$clone();
                    this._angularImpulse = 0.0;
                }
            },
            SolveVelocityConstraints: function (step) {
                var bA = this.BodyA;

                var vA = bA.LinearVelocityInternal.$clone();
                var wA = bA.AngularVelocityInternal;

                var mA = bA.InvMass;
                var iA = bA.InvI;

                var xfA = { v : new FarseerPhysics.Common.Transform() };
                bA.GetTransform(xfA);

                var rA = FarseerPhysics.Common.MathUtils.Multiply(Bridge.ref(xfA.v, "R"), Microsoft.Xna.Framework.Vector2.op_Subtraction(this.LocalAnchorA.$clone(), bA.LocalCenter.$clone()));

                {
                    var Cdot = -wA;
                    var impulse = -this._angularMass * Cdot;

                    var oldImpulse = this._angularImpulse;
                    var maxImpulse = step.v.dt * this.MaxTorque;
                    this._angularImpulse = FarseerPhysics.Common.MathUtils.Clamp$2(this._angularImpulse + impulse, -maxImpulse, maxImpulse);
                    impulse = this._angularImpulse - oldImpulse;

                    wA -= iA * impulse;
                }

                {
                    var Cdot1 = Microsoft.Xna.Framework.Vector2.op_Subtraction(Microsoft.Xna.Framework.Vector2.op_UnaryNegation(vA.$clone()), FarseerPhysics.Common.MathUtils.Cross$1(wA, rA.$clone()));

                    var impulse1 = Microsoft.Xna.Framework.Vector2.op_UnaryNegation(FarseerPhysics.Common.MathUtils.Multiply(Bridge.ref(this, "_linearMass"), Cdot1.$clone()));
                    var oldImpulse1 = this._linearImpulse.$clone();
                    this._linearImpulse = Microsoft.Xna.Framework.Vector2.op_Addition(this._linearImpulse.$clone(), impulse1.$clone());

                    var maxImpulse1 = step.v.dt * this.MaxForce;

                    if (this._linearImpulse.LengthSquared() > maxImpulse1 * maxImpulse1) {
                        this._linearImpulse.Normalize();
                        this._linearImpulse = Microsoft.Xna.Framework.Vector2.op_Multiply$1(this._linearImpulse.$clone(), maxImpulse1);
                    }

                    impulse1 = Microsoft.Xna.Framework.Vector2.op_Subtraction(this._linearImpulse.$clone(), oldImpulse1.$clone());

                    vA = Microsoft.Xna.Framework.Vector2.op_Subtraction(vA.$clone(), Microsoft.Xna.Framework.Vector2.op_Multiply$2(mA, impulse1.$clone()));
                    wA -= iA * FarseerPhysics.Common.MathUtils.Cross$2(rA.$clone(), impulse1.$clone());
                }

                bA.LinearVelocityInternal = vA.$clone();
                bA.AngularVelocityInternal = wA;
            },
            SolvePositionConstraints: function () {
                return true;
            }
        }
    });

    Bridge.define("FarseerPhysics.Dynamics.Joints.FixedLineJoint", {
        inherits: [FarseerPhysics.Dynamics.Joints.Joint],
        fields: {
            _ax: null,
            _ay: null,
            _bias: 0,
            _enableMotor: false,
            _gamma: 0,
            _impulse: 0,
            _localXAxis: null,
            _localYAxisA: null,
            _mass: 0,
            _maxMotorTorque: 0,
            _motorImpulse: 0,
            _motorMass: 0,
            _motorSpeed: 0,
            _sAx: 0,
            _sAy: 0,
            _sBx: 0,
            _sBy: 0,
            _springImpulse: 0,
            _springMass: 0,
            LocalAnchorA: null,
            LocalAnchorB: null,
            Frequency: 0,
            DampingRatio: 0
        },
        props: {
            WorldAnchorA: {
                get: function () {
                    return this.LocalAnchorA.$clone();
                }
            },
            WorldAnchorB: {
                get: function () {
                    return this.BodyA.GetWorldPoint(this.LocalAnchorB.$clone());
                },
                set: function (value) {
                    System.Diagnostics.Debug.Assert$1(false, "You can't set the world anchor on this joint type.");
                }
            },
            JointTranslation: {
                get: function () {
                    var bA = this.BodyA;
                    var bB = this.BodyB;

                    var pA = bA.GetWorldPoint(this.LocalAnchorA.$clone());
                    var pB = bB.GetWorldPoint(this.LocalAnchorB.$clone());
                    var d = Microsoft.Xna.Framework.Vector2.op_Subtraction(pB.$clone(), pA.$clone());
                    var axis = bA.GetWorldVector(this.LocalXAxis.$clone());

                    var translation = Microsoft.Xna.Framework.Vector2.Dot(d.$clone(), axis.$clone());
                    return translation;
                }
            },
            JointSpeed: {
                get: function () {
                    var wA = this.BodyA.AngularVelocityInternal;
                    var wB = this.BodyB.AngularVelocityInternal;
                    return wB - wA;
                }
            },
            MotorEnabled: {
                get: function () {
                    return this._enableMotor;
                },
                set: function (value) {
                    this.BodyA.Awake = true;
                    this.BodyB.Awake = true;
                    this._enableMotor = value;
                }
            },
            MotorSpeed: {
                get: function () {
                    return this._motorSpeed;
                },
                set: function (value) {
                    this.BodyA.Awake = true;
                    this.BodyB.Awake = true;
                    this._motorSpeed = value;
                }
            },
            MaxMotorTorque: {
                get: function () {
                    return this._maxMotorTorque;
                },
                set: function (value) {
                    this.BodyA.Awake = true;
                    this.BodyB.Awake = true;
                    this._maxMotorTorque = value;
                }
            },
            LocalXAxis: {
                get: function () {
                    return this._localXAxis.$clone();
                },
                set: function (value) {
                    this._localXAxis = value.$clone();
                    this._localYAxisA = FarseerPhysics.Common.MathUtils.Cross$1(1.0, this._localXAxis.$clone());
                }
            }
        },
        ctors: {
            init: function () {
                this._ax = new Microsoft.Xna.Framework.Vector2();
                this._ay = new Microsoft.Xna.Framework.Vector2();
                this._localXAxis = new Microsoft.Xna.Framework.Vector2();
                this._localYAxisA = new Microsoft.Xna.Framework.Vector2();
                this.LocalAnchorA = new Microsoft.Xna.Framework.Vector2();
                this.LocalAnchorB = new Microsoft.Xna.Framework.Vector2();
            },
            ctor: function () {
                this.$initialize();
                FarseerPhysics.Dynamics.Joints.Joint.ctor.call(this);
                this.JointType = FarseerPhysics.Dynamics.Joints.JointType.FixedLine;
            },
            $ctor1: function (body, worldAnchor, axis) {
                this.$initialize();
                FarseerPhysics.Dynamics.Joints.Joint.$ctor1.call(this, body);
                this.JointType = FarseerPhysics.Dynamics.Joints.JointType.FixedLine;

                this.BodyB = this.BodyA;

                this.LocalAnchorA = worldAnchor.$clone();
                this.LocalAnchorB = this.BodyB.GetLocalPoint(worldAnchor.$clone());
                this.LocalXAxis = axis.$clone();
            }
        },
        methods: {
            GetReactionForce: function (invDt) {
                return Microsoft.Xna.Framework.Vector2.op_Multiply$2(invDt, (Microsoft.Xna.Framework.Vector2.op_Addition(Microsoft.Xna.Framework.Vector2.op_Multiply$2(this._impulse, this._ay.$clone()), Microsoft.Xna.Framework.Vector2.op_Multiply$2(this._springImpulse, this._ax.$clone()))));
            },
            GetReactionTorque: function (invDt) {
                return invDt * this._motorImpulse;
            },
            InitVelocityConstraints: function (step) {
                var bB = this.BodyB;

                this.LocalCenterA = Microsoft.Xna.Framework.Vector2.Zero.$clone();
                this.LocalCenterB = bB.LocalCenter.$clone();

                var xfB = { v : new FarseerPhysics.Common.Transform() };
                bB.GetTransform(xfB);

                var rA = this.LocalAnchorA.$clone();
                var rB = FarseerPhysics.Common.MathUtils.Multiply(Bridge.ref(xfB.v, "R"), Microsoft.Xna.Framework.Vector2.op_Subtraction(this.LocalAnchorB.$clone(), this.LocalCenterB.$clone()));
                var d = Microsoft.Xna.Framework.Vector2.op_Subtraction(Microsoft.Xna.Framework.Vector2.op_Addition(bB.Sweep.C.$clone(), rB.$clone()), rA.$clone());

                this.InvMassA = 0.0;
                this.InvIA = 0.0;
                this.InvMassB = bB.InvMass;
                this.InvIB = bB.InvI;

                {
                    this._ay = this._localYAxisA.$clone();
                    this._sAy = FarseerPhysics.Common.MathUtils.Cross$2(Microsoft.Xna.Framework.Vector2.op_Addition(d.$clone(), rA.$clone()), this._ay.$clone());
                    this._sBy = FarseerPhysics.Common.MathUtils.Cross$2(rB.$clone(), this._ay.$clone());

                    this._mass = this.InvMassA + this.InvMassB + this.InvIA * this._sAy * this._sAy + this.InvIB * this._sBy * this._sBy;

                    if (this._mass > 0.0) {
                        this._mass = 1.0 / this._mass;
                    }
                }

                this._springMass = 0.0;
                if (this.Frequency > 0.0) {
                    this._ax = this.LocalXAxis.$clone();
                    this._sAx = FarseerPhysics.Common.MathUtils.Cross$2(Microsoft.Xna.Framework.Vector2.op_Addition(d.$clone(), rA.$clone()), this._ax.$clone());
                    this._sBx = FarseerPhysics.Common.MathUtils.Cross$2(rB.$clone(), this._ax.$clone());

                    var invMass = this.InvMassA + this.InvMassB + this.InvIA * this._sAx * this._sAx + this.InvIB * this._sBx * this._sBx;

                    if (invMass > 0.0) {
                        this._springMass = 1.0 / invMass;

                        var C = Microsoft.Xna.Framework.Vector2.Dot(d.$clone(), this._ax.$clone());

                        var omega = 6.28318548 * this.Frequency;

                        var da = 2.0 * this._springMass * this.DampingRatio * omega;

                        var k = this._springMass * omega * omega;

                        this._gamma = step.v.dt * (da + step.v.dt * k);
                        if (this._gamma > 0.0) {
                            this._gamma = 1.0 / this._gamma;
                        }

                        this._bias = C * step.v.dt * k * this._gamma;

                        this._springMass = invMass + this._gamma;
                        if (this._springMass > 0.0) {
                            this._springMass = 1.0 / this._springMass;
                        }
                    }
                } else {
                    this._springImpulse = 0.0;
                    this._springMass = 0.0;
                }

                if (this._enableMotor) {
                    this._motorMass = this.InvIA + this.InvIB;
                    if (this._motorMass > 0.0) {
                        this._motorMass = 1.0 / this._motorMass;
                    }
                } else {
                    this._motorMass = 0.0;
                    this._motorImpulse = 0.0;
                }

                if (FarseerPhysics.Settings.EnableWarmstarting) {
                    this._impulse *= step.v.dtRatio;
                    this._springImpulse *= step.v.dtRatio;
                    this._motorImpulse *= step.v.dtRatio;

                    var P = Microsoft.Xna.Framework.Vector2.op_Addition(Microsoft.Xna.Framework.Vector2.op_Multiply$2(this._impulse, this._ay.$clone()), Microsoft.Xna.Framework.Vector2.op_Multiply$2(this._springImpulse, this._ax.$clone()));
                    var LB = this._impulse * this._sBy + this._springImpulse * this._sBx + this._motorImpulse;

                    bB.LinearVelocityInternal = Microsoft.Xna.Framework.Vector2.op_Addition(bB.LinearVelocityInternal.$clone(), Microsoft.Xna.Framework.Vector2.op_Multiply$2(this.InvMassB, P.$clone()));
                    bB.AngularVelocityInternal += this.InvIB * LB;
                } else {
                    this._impulse = 0.0;
                    this._springImpulse = 0.0;
                    this._motorImpulse = 0.0;
                }
            },
            SolveVelocityConstraints: function (step) {
                var bB = this.BodyB;

                var vA = Microsoft.Xna.Framework.Vector2.Zero.$clone();
                var wA = 0.0;
                var vB = bB.LinearVelocityInternal.$clone();
                var wB = bB.AngularVelocityInternal;

                {
                    var Cdot = Microsoft.Xna.Framework.Vector2.Dot(this._ax.$clone(), Microsoft.Xna.Framework.Vector2.op_Subtraction(vB.$clone(), vA.$clone())) + this._sBx * wB - this._sAx * wA;
                    var impulse = -this._springMass * (Cdot + this._bias + this._gamma * this._springImpulse);
                    this._springImpulse += impulse;

                    var P = Microsoft.Xna.Framework.Vector2.op_Multiply$2(impulse, this._ax.$clone());
                    var LA = impulse * this._sAx;
                    var LB = impulse * this._sBx;

                    vA = Microsoft.Xna.Framework.Vector2.op_Subtraction(vA.$clone(), Microsoft.Xna.Framework.Vector2.op_Multiply$2(this.InvMassA, P.$clone()));
                    wA -= this.InvIA * LA;

                    vB = Microsoft.Xna.Framework.Vector2.op_Addition(vB.$clone(), Microsoft.Xna.Framework.Vector2.op_Multiply$2(this.InvMassB, P.$clone()));
                    wB += this.InvIB * LB;
                }

                {
                    var Cdot1 = wB - wA - this._motorSpeed;
                    var impulse1 = -this._motorMass * Cdot1;

                    var oldImpulse = this._motorImpulse;
                    var maxImpulse = step.v.dt * this._maxMotorTorque;
                    this._motorImpulse = FarseerPhysics.Common.MathUtils.Clamp$2(this._motorImpulse + impulse1, -maxImpulse, maxImpulse);
                    impulse1 = this._motorImpulse - oldImpulse;

                    wA -= this.InvIA * impulse1;
                    wB += this.InvIB * impulse1;
                }

                {
                    var Cdot2 = Microsoft.Xna.Framework.Vector2.Dot(this._ay.$clone(), Microsoft.Xna.Framework.Vector2.op_Subtraction(vB.$clone(), vA.$clone())) + this._sBy * wB - this._sAy * wA;
                    var impulse2 = this._mass * (-Cdot2);
                    this._impulse += impulse2;

                    var P1 = Microsoft.Xna.Framework.Vector2.op_Multiply$2(impulse2, this._ay.$clone());
                    var LB1 = impulse2 * this._sBy;

                    vB = Microsoft.Xna.Framework.Vector2.op_Addition(vB.$clone(), Microsoft.Xna.Framework.Vector2.op_Multiply$2(this.InvMassB, P1.$clone()));
                    wB += this.InvIB * LB1;
                }

                bB.LinearVelocityInternal = vB.$clone();
                bB.AngularVelocityInternal = wB;
            },
            SolvePositionConstraints: function () {
                var bB = this.BodyB;

                var xA = Microsoft.Xna.Framework.Vector2.Zero.$clone();
                var angleA = 0.0;

                var xB = bB.Sweep.C.$clone();
                var angleB = bB.Sweep.A;

                var RA = { v : new FarseerPhysics.Common.Mat22.$ctor2(angleA) };
                var RB = { v : new FarseerPhysics.Common.Mat22.$ctor2(angleB) };

                var rA = FarseerPhysics.Common.MathUtils.Multiply(RA, Microsoft.Xna.Framework.Vector2.op_Subtraction(this.LocalAnchorA.$clone(), this.LocalCenterA.$clone()));
                var rB = FarseerPhysics.Common.MathUtils.Multiply(RB, Microsoft.Xna.Framework.Vector2.op_Subtraction(this.LocalAnchorB.$clone(), this.LocalCenterB.$clone()));
                var d = Microsoft.Xna.Framework.Vector2.op_Subtraction(Microsoft.Xna.Framework.Vector2.op_Subtraction(Microsoft.Xna.Framework.Vector2.op_Addition(xB.$clone(), rB.$clone()), xA.$clone()), rA.$clone());

                var ay = FarseerPhysics.Common.MathUtils.Multiply(RA, this._localYAxisA.$clone());

                var sBy = FarseerPhysics.Common.MathUtils.Cross$2(rB.$clone(), ay.$clone());

                var C = Microsoft.Xna.Framework.Vector2.Dot(d.$clone(), ay.$clone());

                var k = this.InvMassA + this.InvMassB + this.InvIA * this._sAy * this._sAy + this.InvIB * this._sBy * this._sBy;

                var impulse;
                if (k !== 0.0) {
                    impulse = -C / k;
                } else {
                    impulse = 0.0;
                }

                var P = Microsoft.Xna.Framework.Vector2.op_Multiply$2(impulse, ay.$clone());
                var LB = impulse * sBy;

                xB = Microsoft.Xna.Framework.Vector2.op_Addition(xB.$clone(), Microsoft.Xna.Framework.Vector2.op_Multiply$2(this.InvMassB, P.$clone()));
                angleB += this.InvIB * LB;

                bB.Sweep.C = xB.$clone();
                bB.Sweep.A = angleB;
                bB.SynchronizeTransform();

                return Math.abs(C) <= FarseerPhysics.Settings.LinearSlop;
            },
            GetMotorTorque: function (invDt) {
                return invDt * this._motorImpulse;
            }
        }
    });

    /**
     * A mouse joint is used to make a point on a body track a
     specified world point. This a soft constraint with a maximum
     force. This allows the constraint to stretch and without
     applying huge forces.
     NOTE: this joint is not documented in the manual because it was
     developed to be used in the testbed. If you want to learn how to
     use the mouse joint, look at the testbed.
     *
     * @public
     * @class FarseerPhysics.Dynamics.Joints.FixedMouseJoint
     * @augments FarseerPhysics.Dynamics.Joints.Joint
     */
    Bridge.define("FarseerPhysics.Dynamics.Joints.FixedMouseJoint", {
        inherits: [FarseerPhysics.Dynamics.Joints.Joint],
        fields: {
            LocalAnchorA: null,
            _C: null,
            _beta: 0,
            _gamma: 0,
            _impulse: null,
            _mass: null,
            _worldAnchor: null,
            /**
             * The maximum constraint force that can be exerted
             to move the candidate body. Usually you will express
             as some multiple of the weight (multiplier * mass * gravity).
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Dynamics.Joints.FixedMouseJoint
             * @function MaxForce
             * @type number
             */
            MaxForce: 0,
            /**
             * The response speed.
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Dynamics.Joints.FixedMouseJoint
             * @function Frequency
             * @type number
             */
            Frequency: 0,
            /**
             * The damping ratio. 0 = no damping, 1 = critical damping.
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Dynamics.Joints.FixedMouseJoint
             * @function DampingRatio
             * @type number
             */
            DampingRatio: 0
        },
        props: {
            WorldAnchorA: {
                get: function () {
                    return this.BodyA.GetWorldPoint(this.LocalAnchorA.$clone());
                }
            },
            WorldAnchorB: {
                get: function () {
                    return this._worldAnchor.$clone();
                },
                set: function (value) {
                    this.BodyA.Awake = true;
                    this._worldAnchor = value.$clone();
                }
            }
        },
        ctors: {
            init: function () {
                this.LocalAnchorA = new Microsoft.Xna.Framework.Vector2();
                this._C = new Microsoft.Xna.Framework.Vector2();
                this._impulse = new Microsoft.Xna.Framework.Vector2();
                this._mass = new FarseerPhysics.Common.Mat22();
                this._worldAnchor = new Microsoft.Xna.Framework.Vector2();
            },
            /**
             * This requires a world target point,
             tuning parameters, and the time step.
             *
             * @instance
             * @public
             * @this FarseerPhysics.Dynamics.Joints.FixedMouseJoint
             * @memberof FarseerPhysics.Dynamics.Joints.FixedMouseJoint
             * @param   {FarseerPhysics.Dynamics.Body}       body           The body.
             * @param   {Microsoft.Xna.Framework.Vector2}    worldAnchor    The target.
             * @return  {void}
             */
            ctor: function (body, worldAnchor) {
                this.$initialize();
                FarseerPhysics.Dynamics.Joints.Joint.$ctor1.call(this, body);
                this.JointType = FarseerPhysics.Dynamics.Joints.JointType.FixedMouse;
                this.Frequency = 5.0;
                this.DampingRatio = 0.7;

                System.Diagnostics.Debug.Assert(FarseerPhysics.Common.MathUtils.IsValid(worldAnchor));

                var xf1 = { v : new FarseerPhysics.Common.Transform() };
                this.BodyA.GetTransform(xf1);

                this._worldAnchor = worldAnchor.$clone();
                this.LocalAnchorA = this.BodyA.GetLocalPoint(worldAnchor.$clone());
            }
        },
        methods: {
            GetReactionForce: function (inv_dt) {
                return Microsoft.Xna.Framework.Vector2.op_Multiply$2(inv_dt, this._impulse.$clone());
            },
            GetReactionTorque: function (inv_dt) {
                return inv_dt * 0.0;
            },
            InitVelocityConstraints: function (step) {
                var b = this.BodyA;

                var mass = b.Mass;

                var omega = 6.28318548 * this.Frequency;

                var d = 2.0 * mass * this.DampingRatio * omega;

                var k = mass * (omega * omega);

                System.Diagnostics.Debug.Assert(d + step.v.dt * k > FarseerPhysics.Settings.Epsilon);

                this._gamma = step.v.dt * (d + step.v.dt * k);
                if (this._gamma !== 0.0) {
                    this._gamma = 1.0 / this._gamma;
                }

                this._beta = step.v.dt * k * this._gamma;

                var xf1 = { v : new FarseerPhysics.Common.Transform() };
                b.GetTransform(xf1);
                var r = FarseerPhysics.Common.MathUtils.Multiply(Bridge.ref(xf1.v, "R"), Microsoft.Xna.Framework.Vector2.op_Subtraction(this.LocalAnchorA.$clone(), b.LocalCenter.$clone()));

                var invMass = b.InvMass;
                var invI = b.InvI;

                var K1 = { v : new FarseerPhysics.Common.Mat22.$ctor1(new Microsoft.Xna.Framework.Vector2.$ctor2(invMass, 0.0), new Microsoft.Xna.Framework.Vector2.$ctor2(0.0, invMass)) };
                var K2 = { v : new FarseerPhysics.Common.Mat22.$ctor1(new Microsoft.Xna.Framework.Vector2.$ctor2(invI * r.Y * r.Y, -invI * r.X * r.Y), new Microsoft.Xna.Framework.Vector2.$ctor2(-invI * r.X * r.Y, invI * r.X * r.X)) };

                var K = { v : new FarseerPhysics.Common.Mat22() };
                FarseerPhysics.Common.Mat22.Add(K1, K2, K);

                K.v.Col1.X += this._gamma;
                K.v.Col2.Y += this._gamma;

                this._mass = K.v.Inverse.$clone();

                this._C = Microsoft.Xna.Framework.Vector2.op_Subtraction(Microsoft.Xna.Framework.Vector2.op_Addition(b.Sweep.C.$clone(), r.$clone()), this._worldAnchor.$clone());

                b.AngularVelocityInternal *= 0.98;

                this._impulse = Microsoft.Xna.Framework.Vector2.op_Multiply$1(this._impulse.$clone(), step.v.dtRatio);
                b.LinearVelocityInternal = Microsoft.Xna.Framework.Vector2.op_Addition(b.LinearVelocityInternal.$clone(), Microsoft.Xna.Framework.Vector2.op_Multiply$2(invMass, this._impulse.$clone()));
                b.AngularVelocityInternal += invI * FarseerPhysics.Common.MathUtils.Cross$2(r.$clone(), this._impulse.$clone());
            },
            SolveVelocityConstraints: function (step) {
                var b = this.BodyA;

                var xf1 = { v : new FarseerPhysics.Common.Transform() };
                b.GetTransform(xf1);

                var r = FarseerPhysics.Common.MathUtils.Multiply(Bridge.ref(xf1.v, "R"), Microsoft.Xna.Framework.Vector2.op_Subtraction(this.LocalAnchorA.$clone(), b.LocalCenter.$clone()));

                var Cdot = Microsoft.Xna.Framework.Vector2.op_Addition(b.LinearVelocityInternal.$clone(), FarseerPhysics.Common.MathUtils.Cross$1(b.AngularVelocityInternal, r.$clone()));
                var impulse = FarseerPhysics.Common.MathUtils.Multiply(Bridge.ref(this, "_mass"), Microsoft.Xna.Framework.Vector2.op_UnaryNegation((Microsoft.Xna.Framework.Vector2.op_Addition(Microsoft.Xna.Framework.Vector2.op_Addition(Cdot.$clone(), Microsoft.Xna.Framework.Vector2.op_Multiply$2(this._beta, this._C.$clone())), Microsoft.Xna.Framework.Vector2.op_Multiply$2(this._gamma, this._impulse.$clone())))));

                var oldImpulse = this._impulse.$clone();
                this._impulse = Microsoft.Xna.Framework.Vector2.op_Addition(this._impulse.$clone(), impulse.$clone());
                var maxImpulse = step.v.dt * this.MaxForce;
                if (this._impulse.LengthSquared() > maxImpulse * maxImpulse) {
                    this._impulse = Microsoft.Xna.Framework.Vector2.op_Multiply$1(this._impulse.$clone(), maxImpulse / this._impulse.Length());
                }
                impulse = Microsoft.Xna.Framework.Vector2.op_Subtraction(this._impulse.$clone(), oldImpulse.$clone());

                b.LinearVelocityInternal = Microsoft.Xna.Framework.Vector2.op_Addition(b.LinearVelocityInternal.$clone(), Microsoft.Xna.Framework.Vector2.op_Multiply$2(b.InvMass, impulse.$clone()));
                b.AngularVelocityInternal += b.InvI * FarseerPhysics.Common.MathUtils.Cross$2(r.$clone(), impulse.$clone());
            },
            SolvePositionConstraints: function () {
                return true;
            }
        }
    });

    /**
     * A prismatic joint. This joint provides one degree of freedom: translation
     along an axis fixed in body1. Relative rotation is prevented. You can
     use a joint limit to restrict the range of motion and a joint motor to
     drive the motion or to model joint friction.
     *
     * @public
     * @class FarseerPhysics.Dynamics.Joints.FixedPrismaticJoint
     * @augments FarseerPhysics.Dynamics.Joints.Joint
     */
    Bridge.define("FarseerPhysics.Dynamics.Joints.FixedPrismaticJoint", {
        inherits: [FarseerPhysics.Dynamics.Joints.Joint],
        fields: {
            _K: null,
            _a1: 0,
            _a2: 0,
            _axis: null,
            _enableLimit: false,
            _enableMotor: false,
            _impulse: null,
            _limitState: 0,
            _localXAxis1: null,
            _localYAxis1: null,
            _lowerTranslation: 0,
            _maxMotorForce: 0,
            _motorMass: 0,
            _motorSpeed: 0,
            _perp: null,
            _refAngle: 0,
            _s1: 0,
            _s2: 0,
            _upperTranslation: 0,
            LocalAnchorA: null,
            LocalAnchorB: null,
            /**
             * Get the current motor force, usually in N.
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Dynamics.Joints.FixedPrismaticJoint
             * @function MotorForce
             * @type number
             */
            MotorForce: 0
        },
        props: {
            WorldAnchorA: {
                get: function () {
                    return this.LocalAnchorA.$clone();
                }
            },
            WorldAnchorB: {
                get: function () {
                    return this.BodyA.GetWorldPoint(this.LocalAnchorB.$clone());
                },
                set: function (value) {
                    System.Diagnostics.Debug.Assert$1(false, "You can't set the world anchor on this joint type.");
                }
            },
            /**
             * Get the current joint translation, usually in meters.
             *
             * @instance
             * @public
             * @readonly
             * @memberof FarseerPhysics.Dynamics.Joints.FixedPrismaticJoint
             * @function JointTranslation
             * @type number
             */
            JointTranslation: {
                get: function () {
                    var d = Microsoft.Xna.Framework.Vector2.op_Subtraction(this.BodyB.GetWorldPoint(this.LocalAnchorB.$clone()), this.LocalAnchorA.$clone());
                    var axis = this._localXAxis1.$clone();

                    return Microsoft.Xna.Framework.Vector2.Dot(d.$clone(), axis.$clone());
                }
            },
            /**
             * Get the current joint translation speed, usually in meters per second.
             *
             * @instance
             * @public
             * @readonly
             * @memberof FarseerPhysics.Dynamics.Joints.FixedPrismaticJoint
             * @function JointSpeed
             * @type number
             */
            JointSpeed: {
                get: function () {
                    var xf2 = { v : new FarseerPhysics.Common.Transform() };
                    this.BodyB.GetTransform(xf2);

                    var r1 = this.LocalAnchorA.$clone();
                    var r2 = FarseerPhysics.Common.MathUtils.Multiply(Bridge.ref(xf2.v, "R"), Microsoft.Xna.Framework.Vector2.op_Subtraction(this.LocalAnchorB.$clone(), this.BodyB.LocalCenter.$clone()));
                    var p1 = r1.$clone();
                    var p2 = Microsoft.Xna.Framework.Vector2.op_Addition(this.BodyB.Sweep.C.$clone(), r2.$clone());
                    var d = Microsoft.Xna.Framework.Vector2.op_Subtraction(p2.$clone(), p1.$clone());
                    var axis = this._localXAxis1.$clone();

                    var v1 = Microsoft.Xna.Framework.Vector2.Zero.$clone();
                    var v2 = this.BodyB.LinearVelocityInternal.$clone();
                    var w1 = 0.0;
                    var w2 = this.BodyB.AngularVelocityInternal;

                    var speed = Microsoft.Xna.Framework.Vector2.Dot(d.$clone(), FarseerPhysics.Common.MathUtils.Cross$1(w1, axis.$clone())) + Microsoft.Xna.Framework.Vector2.Dot(axis.$clone(), Microsoft.Xna.Framework.Vector2.op_Subtraction(Microsoft.Xna.Framework.Vector2.op_Subtraction(Microsoft.Xna.Framework.Vector2.op_Addition(v2.$clone(), FarseerPhysics.Common.MathUtils.Cross$1(w2, r2.$clone())), v1.$clone()), FarseerPhysics.Common.MathUtils.Cross$1(w1, r1.$clone())));
                    return speed;
                }
            },
            /**
             * Is the joint limit enabled?
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Dynamics.Joints.FixedPrismaticJoint
             * @function LimitEnabled
             * @type boolean
             */
            LimitEnabled: {
                get: function () {
                    return this._enableLimit;
                },
                set: function (value) {
                    System.Diagnostics.Debug.Assert$1(this.BodyA.FixedRotation === false, "Warning: limits does currently not work with fixed rotation");

                    this.WakeBodies();
                    this._enableLimit = value;
                }
            },
            /**
             * Get the lower joint limit, usually in meters.
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Dynamics.Joints.FixedPrismaticJoint
             * @function LowerLimit
             * @type number
             */
            LowerLimit: {
                get: function () {
                    return this._lowerTranslation;
                },
                set: function (value) {
                    this.WakeBodies();
                    this._lowerTranslation = value;
                }
            },
            /**
             * Get the upper joint limit, usually in meters.
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Dynamics.Joints.FixedPrismaticJoint
             * @function UpperLimit
             * @type number
             */
            UpperLimit: {
                get: function () {
                    return this._upperTranslation;
                },
                set: function (value) {
                    this.WakeBodies();
                    this._upperTranslation = value;
                }
            },
            /**
             * Is the joint motor enabled?
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Dynamics.Joints.FixedPrismaticJoint
             * @function MotorEnabled
             * @type boolean
             */
            MotorEnabled: {
                get: function () {
                    return this._enableMotor;
                },
                set: function (value) {
                    this.WakeBodies();
                    this._enableMotor = value;
                }
            },
            /**
             * Set the motor speed, usually in meters per second.
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Dynamics.Joints.FixedPrismaticJoint
             * @function MotorSpeed
             * @type number
             */
            MotorSpeed: {
                get: function () {
                    return this._motorSpeed;
                },
                set: function (value) {
                    this.WakeBodies();
                    this._motorSpeed = value;
                }
            },
            /**
             * Set the maximum motor force, usually in N.
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Dynamics.Joints.FixedPrismaticJoint
             * @function MaxMotorForce
             * @type number
             */
            MaxMotorForce: {
                set: function (value) {
                    this.WakeBodies();
                    this._maxMotorForce = value;
                }
            },
            LocalXAxis1: {
                get: function () {
                    return this._localXAxis1.$clone();
                },
                set: function (value) {
                    this._localXAxis1 = value.$clone();
                    this._localYAxis1 = FarseerPhysics.Common.MathUtils.Cross$1(1.0, this._localXAxis1.$clone());
                }
            }
        },
        ctors: {
            init: function () {
                this._K = new FarseerPhysics.Common.Mat33();
                this._axis = new Microsoft.Xna.Framework.Vector2();
                this._impulse = new Microsoft.Xna.Framework.Vector3();
                this._localXAxis1 = new Microsoft.Xna.Framework.Vector2();
                this._localYAxis1 = new Microsoft.Xna.Framework.Vector2();
                this._perp = new Microsoft.Xna.Framework.Vector2();
                this.LocalAnchorA = new Microsoft.Xna.Framework.Vector2();
                this.LocalAnchorB = new Microsoft.Xna.Framework.Vector2();
            },
            /**
             * This requires defining a line of
             motion using an axis and an anchor point. The definition uses local
             anchor points and a local axis so that the initial configuration
             can violate the constraint slightly. The joint translation is zero
             when the local anchor points coincide in world space. Using local
             anchors and a local axis helps when saving and loading a game.
             *
             * @instance
             * @public
             * @this FarseerPhysics.Dynamics.Joints.FixedPrismaticJoint
             * @memberof FarseerPhysics.Dynamics.Joints.FixedPrismaticJoint
             * @param   {FarseerPhysics.Dynamics.Body}       body           The body.
             * @param   {Microsoft.Xna.Framework.Vector2}    worldAnchor    The anchor.
             * @param   {Microsoft.Xna.Framework.Vector2}    axis           The axis.
             * @return  {void}
             */
            ctor: function (body, worldAnchor, axis) {
                this.$initialize();
                FarseerPhysics.Dynamics.Joints.Joint.$ctor1.call(this, body);
                this.JointType = FarseerPhysics.Dynamics.Joints.JointType.FixedPrismatic;

                this.BodyB = this.BodyA;

                this.LocalAnchorA = worldAnchor.$clone();
                this.LocalAnchorB = this.BodyB.GetLocalPoint(worldAnchor.$clone());

                this._localXAxis1 = axis.$clone();
                this._localYAxis1 = FarseerPhysics.Common.MathUtils.Cross$1(1.0, this._localXAxis1.$clone());
                this._refAngle = this.BodyB.Rotation;

                this._limitState = FarseerPhysics.Dynamics.Joints.LimitState.Inactive;
            }
        },
        methods: {
            GetReactionForce: function (inv_dt) {
                return Microsoft.Xna.Framework.Vector2.op_Multiply$2(inv_dt, (Microsoft.Xna.Framework.Vector2.op_Addition(Microsoft.Xna.Framework.Vector2.op_Multiply$2(this._impulse.X, this._perp.$clone()), Microsoft.Xna.Framework.Vector2.op_Multiply$2((this.MotorForce + this._impulse.Z), this._axis.$clone()))));
            },
            GetReactionTorque: function (inv_dt) {
                return inv_dt * this._impulse.Y;
            },
            InitVelocityConstraints: function (step) {
                var bB = this.BodyB;

                this.LocalCenterA = Microsoft.Xna.Framework.Vector2.Zero.$clone();
                this.LocalCenterB = bB.LocalCenter.$clone();

                var xf2 = { v : new FarseerPhysics.Common.Transform() };
                bB.GetTransform(xf2);

                var r1 = this.LocalAnchorA.$clone();
                var r2 = FarseerPhysics.Common.MathUtils.Multiply(Bridge.ref(xf2.v, "R"), Microsoft.Xna.Framework.Vector2.op_Subtraction(this.LocalAnchorB.$clone(), this.LocalCenterB.$clone()));
                var d = Microsoft.Xna.Framework.Vector2.op_Subtraction(Microsoft.Xna.Framework.Vector2.op_Addition(bB.Sweep.C.$clone(), r2.$clone()), r1.$clone());

                this.InvMassA = 0.0;
                this.InvIA = 0.0;
                this.InvMassB = bB.InvMass;
                this.InvIB = bB.InvI;

                {
                    this._axis = this._localXAxis1.$clone();
                    this._a1 = FarseerPhysics.Common.MathUtils.Cross$2(Microsoft.Xna.Framework.Vector2.op_Addition(d.$clone(), r1.$clone()), this._axis.$clone());
                    this._a2 = FarseerPhysics.Common.MathUtils.Cross$2(r2.$clone(), this._axis.$clone());

                    this._motorMass = this.InvMassA + this.InvMassB + this.InvIA * this._a1 * this._a1 + this.InvIB * this._a2 * this._a2;

                    if (this._motorMass > FarseerPhysics.Settings.Epsilon) {
                        this._motorMass = 1.0 / this._motorMass;
                    }
                }

                {
                    this._perp = this._localYAxis1.$clone();

                    this._s1 = FarseerPhysics.Common.MathUtils.Cross$2(Microsoft.Xna.Framework.Vector2.op_Addition(d.$clone(), r1.$clone()), this._perp.$clone());
                    this._s2 = FarseerPhysics.Common.MathUtils.Cross$2(r2.$clone(), this._perp.$clone());

                    var m1 = this.InvMassA, m2 = this.InvMassB;
                    var i1 = this.InvIA, i2 = this.InvIB;

                    var k11 = m1 + m2 + i1 * this._s1 * this._s1 + i2 * this._s2 * this._s2;
                    var k12 = i1 * this._s1 + i2 * this._s2;
                    var k13 = i1 * this._s1 * this._a1 + i2 * this._s2 * this._a2;
                    var k22 = i1 + i2;
                    var k23 = i1 * this._a1 + i2 * this._a2;
                    var k33 = m1 + m2 + i1 * this._a1 * this._a1 + i2 * this._a2 * this._a2;

                    this._K.Col1 = new Microsoft.Xna.Framework.Vector3.$ctor3(k11, k12, k13);
                    this._K.Col2 = new Microsoft.Xna.Framework.Vector3.$ctor3(k12, k22, k23);
                    this._K.Col3 = new Microsoft.Xna.Framework.Vector3.$ctor3(k13, k23, k33);
                }

                if (this._enableLimit) {
                    var jointTranslation = Microsoft.Xna.Framework.Vector2.Dot(this._axis.$clone(), d.$clone());
                    if (Math.abs(this._upperTranslation - this._lowerTranslation) < 0.01) {
                        this._limitState = FarseerPhysics.Dynamics.Joints.LimitState.Equal;
                    } else if (jointTranslation <= this._lowerTranslation) {
                        if (this._limitState !== FarseerPhysics.Dynamics.Joints.LimitState.AtLower) {
                            this._limitState = FarseerPhysics.Dynamics.Joints.LimitState.AtLower;
                            this._impulse.Z = 0.0;
                        }
                    } else if (jointTranslation >= this._upperTranslation) {
                        if (this._limitState !== FarseerPhysics.Dynamics.Joints.LimitState.AtUpper) {
                            this._limitState = FarseerPhysics.Dynamics.Joints.LimitState.AtUpper;
                            this._impulse.Z = 0.0;
                        }
                    } else {
                        this._limitState = FarseerPhysics.Dynamics.Joints.LimitState.Inactive;
                        this._impulse.Z = 0.0;
                    }
                } else {
                    this._limitState = FarseerPhysics.Dynamics.Joints.LimitState.Inactive;
                }

                if (this._enableMotor === false) {
                    this.MotorForce = 0.0;
                }

                if (FarseerPhysics.Settings.EnableWarmstarting) {
                    this._impulse = Microsoft.Xna.Framework.Vector3.op_Multiply$1(this._impulse.$clone(), step.v.dtRatio);
                    this.MotorForce *= step.v.dtRatio;

                    var P = Microsoft.Xna.Framework.Vector2.op_Addition(Microsoft.Xna.Framework.Vector2.op_Multiply$2(this._impulse.X, this._perp.$clone()), Microsoft.Xna.Framework.Vector2.op_Multiply$2((this.MotorForce + this._impulse.Z), this._axis.$clone()));
                    var L2 = this._impulse.X * this._s2 + this._impulse.Y + (this.MotorForce + this._impulse.Z) * this._a2;

                    bB.LinearVelocityInternal = Microsoft.Xna.Framework.Vector2.op_Addition(bB.LinearVelocityInternal.$clone(), Microsoft.Xna.Framework.Vector2.op_Multiply$2(this.InvMassB, P.$clone()));
                    bB.AngularVelocityInternal += this.InvIB * L2;
                } else {
                    this._impulse = Microsoft.Xna.Framework.Vector3.Zero.$clone();
                    this.MotorForce = 0.0;
                }
            },
            SolveVelocityConstraints: function (step) {
                var bB = this.BodyB;

                var v1 = Microsoft.Xna.Framework.Vector2.Zero.$clone();
                var w1 = 0.0;
                var v2 = bB.LinearVelocityInternal.$clone();
                var w2 = bB.AngularVelocityInternal;

                if (this._enableMotor && this._limitState !== FarseerPhysics.Dynamics.Joints.LimitState.Equal) {
                    var Cdot = Microsoft.Xna.Framework.Vector2.Dot(this._axis.$clone(), Microsoft.Xna.Framework.Vector2.op_Subtraction(v2.$clone(), v1.$clone())) + this._a2 * w2 - this._a1 * w1;
                    var impulse = this._motorMass * (this._motorSpeed - Cdot);
                    var oldImpulse = this.MotorForce;
                    var maxImpulse = step.v.dt * this._maxMotorForce;
                    this.MotorForce = FarseerPhysics.Common.MathUtils.Clamp$2(this.MotorForce + impulse, -maxImpulse, maxImpulse);
                    impulse = this.MotorForce - oldImpulse;

                    var P = Microsoft.Xna.Framework.Vector2.op_Multiply$2(impulse, this._axis.$clone());
                    var L1 = impulse * this._a1;
                    var L2 = impulse * this._a2;

                    v1 = Microsoft.Xna.Framework.Vector2.op_Subtraction(v1.$clone(), Microsoft.Xna.Framework.Vector2.op_Multiply$2(this.InvMassA, P.$clone()));
                    w1 -= this.InvIA * L1;

                    v2 = Microsoft.Xna.Framework.Vector2.op_Addition(v2.$clone(), Microsoft.Xna.Framework.Vector2.op_Multiply$2(this.InvMassB, P.$clone()));
                    w2 += this.InvIB * L2;
                }

                var Cdot1 = new Microsoft.Xna.Framework.Vector2.$ctor2(Microsoft.Xna.Framework.Vector2.Dot(this._perp.$clone(), Microsoft.Xna.Framework.Vector2.op_Subtraction(v2.$clone(), v1.$clone())) + this._s2 * w2 - this._s1 * w1, w2 - w1);

                if (this._enableLimit && this._limitState !== FarseerPhysics.Dynamics.Joints.LimitState.Inactive) {
                    var Cdot2 = Microsoft.Xna.Framework.Vector2.Dot(this._axis.$clone(), Microsoft.Xna.Framework.Vector2.op_Subtraction(v2.$clone(), v1.$clone())) + this._a2 * w2 - this._a1 * w1;
                    var Cdot3 = new Microsoft.Xna.Framework.Vector3.$ctor3(Cdot1.X, Cdot1.Y, Cdot2);

                    var f1 = this._impulse.$clone();
                    var df = this._K.Solve33(Microsoft.Xna.Framework.Vector3.op_UnaryNegation(Cdot3.$clone()));
                    this._impulse = Microsoft.Xna.Framework.Vector3.op_Addition(this._impulse.$clone(), df.$clone());

                    if (this._limitState === FarseerPhysics.Dynamics.Joints.LimitState.AtLower) {
                        this._impulse.Z = Math.max(this._impulse.Z, 0.0);
                    } else if (this._limitState === FarseerPhysics.Dynamics.Joints.LimitState.AtUpper) {
                        this._impulse.Z = Math.min(this._impulse.Z, 0.0);
                    }

                    var b = Microsoft.Xna.Framework.Vector2.op_Subtraction(Microsoft.Xna.Framework.Vector2.op_UnaryNegation(Cdot1.$clone()), Microsoft.Xna.Framework.Vector2.op_Multiply$2((this._impulse.Z - f1.Z), new Microsoft.Xna.Framework.Vector2.$ctor2(this._K.Col3.X, this._K.Col3.Y)));
                    var f2r = Microsoft.Xna.Framework.Vector2.op_Addition(this._K.Solve22(b.$clone()), new Microsoft.Xna.Framework.Vector2.$ctor2(f1.X, f1.Y));
                    this._impulse.X = f2r.X;
                    this._impulse.Y = f2r.Y;

                    df = Microsoft.Xna.Framework.Vector3.op_Subtraction(this._impulse.$clone(), f1.$clone());

                    var P1 = Microsoft.Xna.Framework.Vector2.op_Addition(Microsoft.Xna.Framework.Vector2.op_Multiply$2(df.X, this._perp.$clone()), Microsoft.Xna.Framework.Vector2.op_Multiply$2(df.Z, this._axis.$clone()));
                    var L21 = df.X * this._s2 + df.Y + df.Z * this._a2;

                    v2 = Microsoft.Xna.Framework.Vector2.op_Addition(v2.$clone(), Microsoft.Xna.Framework.Vector2.op_Multiply$2(this.InvMassB, P1.$clone()));
                    w2 += this.InvIB * L21;
                } else {
                    var df1 = this._K.Solve22(Microsoft.Xna.Framework.Vector2.op_UnaryNegation(Cdot1.$clone()));
                    this._impulse.X += df1.X;
                    this._impulse.Y += df1.Y;

                    var P2 = Microsoft.Xna.Framework.Vector2.op_Multiply$2(df1.X, this._perp.$clone());
                    var L22 = df1.X * this._s2 + df1.Y;

                    v2 = Microsoft.Xna.Framework.Vector2.op_Addition(v2.$clone(), Microsoft.Xna.Framework.Vector2.op_Multiply$2(this.InvMassB, P2.$clone()));
                    w2 += this.InvIB * L22;
                }

                bB.LinearVelocityInternal = v2.$clone();
                bB.AngularVelocityInternal = w2;
            },
            SolvePositionConstraints: function () {
                var b2 = this.BodyB;

                var c1 = Microsoft.Xna.Framework.Vector2.Zero.$clone();
                var a1 = 0.0;

                var c2 = b2.Sweep.C.$clone();
                var a2 = b2.Sweep.A;

                var linearError = 0.0;
                var active = false;
                var C2 = 0.0;

                var R1 = { v : new FarseerPhysics.Common.Mat22.$ctor2(a1) };
                var R2 = { v : new FarseerPhysics.Common.Mat22.$ctor2(a2) };

                var r1 = FarseerPhysics.Common.MathUtils.Multiply(R1, Microsoft.Xna.Framework.Vector2.op_Subtraction(this.LocalAnchorA.$clone(), this.LocalCenterA.$clone()));
                var r2 = FarseerPhysics.Common.MathUtils.Multiply(R2, Microsoft.Xna.Framework.Vector2.op_Subtraction(this.LocalAnchorB.$clone(), this.LocalCenterB.$clone()));
                var d = Microsoft.Xna.Framework.Vector2.op_Subtraction(Microsoft.Xna.Framework.Vector2.op_Subtraction(Microsoft.Xna.Framework.Vector2.op_Addition(c2.$clone(), r2.$clone()), c1.$clone()), r1.$clone());

                if (this._enableLimit) {
                    this._axis = FarseerPhysics.Common.MathUtils.Multiply(R1, this._localXAxis1.$clone());

                    this._a1 = FarseerPhysics.Common.MathUtils.Cross$2(Microsoft.Xna.Framework.Vector2.op_Addition(d.$clone(), r1.$clone()), this._axis.$clone());
                    this._a2 = FarseerPhysics.Common.MathUtils.Cross$2(r2.$clone(), this._axis.$clone());

                    var translation = Microsoft.Xna.Framework.Vector2.Dot(this._axis.$clone(), d.$clone());
                    if (Math.abs(this._upperTranslation - this._lowerTranslation) < 0.01) {
                        C2 = FarseerPhysics.Common.MathUtils.Clamp$2(translation, -0.2, FarseerPhysics.Settings.MaxLinearCorrection);
                        linearError = Math.abs(translation);
                        active = true;
                    } else if (translation <= this._lowerTranslation) {
                        C2 = FarseerPhysics.Common.MathUtils.Clamp$2(translation - this._lowerTranslation + FarseerPhysics.Settings.LinearSlop, -0.2, 0.0);
                        linearError = this._lowerTranslation - translation;
                        active = true;
                    } else if (translation >= this._upperTranslation) {
                        C2 = FarseerPhysics.Common.MathUtils.Clamp$2(translation - this._upperTranslation - FarseerPhysics.Settings.LinearSlop, 0.0, FarseerPhysics.Settings.MaxLinearCorrection);
                        linearError = translation - this._upperTranslation;
                        active = true;
                    }
                }

                this._perp = FarseerPhysics.Common.MathUtils.Multiply(R1, this._localYAxis1.$clone());

                this._s1 = FarseerPhysics.Common.MathUtils.Cross$2(Microsoft.Xna.Framework.Vector2.op_Addition(d.$clone(), r1.$clone()), this._perp.$clone());
                this._s2 = FarseerPhysics.Common.MathUtils.Cross$2(r2.$clone(), this._perp.$clone());

                var impulse = new Microsoft.Xna.Framework.Vector3();
                var C1 = new Microsoft.Xna.Framework.Vector2.$ctor2(Microsoft.Xna.Framework.Vector2.Dot(this._perp.$clone(), d.$clone()), a2 - a1 - this._refAngle);

                linearError = Math.max(linearError, Math.abs(C1.X));
                var angularError = Math.abs(C1.Y);

                if (active) {
                    var m1 = this.InvMassA, m2 = this.InvMassB;
                    var i1 = this.InvIA, i2 = this.InvIB;

                    var k11 = m1 + m2 + i1 * this._s1 * this._s1 + i2 * this._s2 * this._s2;
                    var k12 = i1 * this._s1 + i2 * this._s2;
                    var k13 = i1 * this._s1 * this._a1 + i2 * this._s2 * this._a2;
                    var k22 = i1 + i2;
                    var k23 = i1 * this._a1 + i2 * this._a2;
                    var k33 = m1 + m2 + i1 * this._a1 * this._a1 + i2 * this._a2 * this._a2;

                    this._K.Col1 = new Microsoft.Xna.Framework.Vector3.$ctor3(k11, k12, k13);
                    this._K.Col2 = new Microsoft.Xna.Framework.Vector3.$ctor3(k12, k22, k23);
                    this._K.Col3 = new Microsoft.Xna.Framework.Vector3.$ctor3(k13, k23, k33);

                    var C = new Microsoft.Xna.Framework.Vector3.$ctor3(-C1.X, -C1.Y, -C2);
                    impulse = this._K.Solve33(C.$clone());
                } else {
                    var m11 = this.InvMassA, m21 = this.InvMassB;
                    var i11 = this.InvIA, i21 = this.InvIB;

                    var k111 = m11 + m21 + i11 * this._s1 * this._s1 + i21 * this._s2 * this._s2;
                    var k121 = i11 * this._s1 + i21 * this._s2;
                    var k221 = i11 + i21;

                    this._K.Col1 = new Microsoft.Xna.Framework.Vector3.$ctor3(k111, k121, 0.0);
                    this._K.Col2 = new Microsoft.Xna.Framework.Vector3.$ctor3(k121, k221, 0.0);

                    var impulse1 = this._K.Solve22(Microsoft.Xna.Framework.Vector2.op_UnaryNegation(C1.$clone()));
                    impulse.X = impulse1.X;
                    impulse.Y = impulse1.Y;
                    impulse.Z = 0.0;
                }

                var P = Microsoft.Xna.Framework.Vector2.op_Addition(Microsoft.Xna.Framework.Vector2.op_Multiply$2(impulse.X, this._perp.$clone()), Microsoft.Xna.Framework.Vector2.op_Multiply$2(impulse.Z, this._axis.$clone()));
                var L2 = impulse.X * this._s2 + impulse.Y + impulse.Z * this._a2;

                c2 = Microsoft.Xna.Framework.Vector2.op_Addition(c2.$clone(), Microsoft.Xna.Framework.Vector2.op_Multiply$2(this.InvMassB, P.$clone()));
                a2 += this.InvIB * L2;

                b2.Sweep.C = c2.$clone();
                b2.Sweep.A = a2;
                b2.SynchronizeTransform();

                return linearError <= FarseerPhysics.Settings.LinearSlop && angularError <= FarseerPhysics.Settings.AngularSlop;
            }
        }
    });

    /**
     * A revolute joint rains to bodies to share a common point while they
     are free to rotate about the point. The relative rotation about the shared
     point is the joint angle. You can limit the relative rotation with
     a joint limit that specifies a lower and upper angle. You can use a motor
     to drive the relative rotation about the shared point. A maximum motor torque
     is provided so that infinite forces are not generated.
     *
     * @public
     * @class FarseerPhysics.Dynamics.Joints.FixedRevoluteJoint
     * @augments FarseerPhysics.Dynamics.Joints.Joint
     */
    Bridge.define("FarseerPhysics.Dynamics.Joints.FixedRevoluteJoint", {
        inherits: [FarseerPhysics.Dynamics.Joints.Joint],
        fields: {
            _enableLimit: false,
            _enableMotor: false,
            _impulse: null,
            _limitState: 0,
            _lowerAngle: 0,
            _mass: null,
            _maxMotorTorque: 0,
            _motorImpulse: 0,
            _motorMass: 0,
            _motorSpeed: 0,
            _upperAngle: 0,
            _worldAnchor: null,
            LocalAnchorA: null,
            ReferenceAngle: 0
        },
        props: {
            WorldAnchorA: {
                get: function () {
                    return this.BodyA.GetWorldPoint(this.LocalAnchorA.$clone());
                }
            },
            WorldAnchorB: {
                get: function () {
                    return this._worldAnchor.$clone();
                },
                set: function (value) {
                    this._worldAnchor = value.$clone();
                }
            },
            /**
             * Get the current joint angle in radians.
             *
             * @instance
             * @public
             * @readonly
             * @memberof FarseerPhysics.Dynamics.Joints.FixedRevoluteJoint
             * @function JointAngle
             * @type number
             */
            JointAngle: {
                get: function () {
                    return this.BodyA.Sweep.A - this.ReferenceAngle;
                }
            },
            /**
             * Get the current joint angle speed in radians per second.
             *
             * @instance
             * @public
             * @readonly
             * @memberof FarseerPhysics.Dynamics.Joints.FixedRevoluteJoint
             * @function JointSpeed
             * @type number
             */
            JointSpeed: {
                get: function () {
                    return this.BodyA.AngularVelocityInternal;
                }
            },
            /**
             * Is the joint limit enabled?
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Dynamics.Joints.FixedRevoluteJoint
             * @function LimitEnabled
             * @type boolean
             */
            LimitEnabled: {
                get: function () {
                    return this._enableLimit;
                },
                set: function (value) {
                    this.WakeBodies();
                    this._enableLimit = value;
                }
            },
            /**
             * Get the lower joint limit in radians.
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Dynamics.Joints.FixedRevoluteJoint
             * @function LowerLimit
             * @type number
             */
            LowerLimit: {
                get: function () {
                    return this._lowerAngle;
                },
                set: function (value) {
                    this.WakeBodies();
                    this._lowerAngle = value;
                }
            },
            /**
             * Get the upper joint limit in radians.
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Dynamics.Joints.FixedRevoluteJoint
             * @function UpperLimit
             * @type number
             */
            UpperLimit: {
                get: function () {
                    return this._upperAngle;
                },
                set: function (value) {
                    this.WakeBodies();
                    this._upperAngle = value;
                }
            },
            /**
             * Is the joint motor enabled?
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Dynamics.Joints.FixedRevoluteJoint
             * @function MotorEnabled
             * @type boolean
             */
            MotorEnabled: {
                get: function () {
                    return this._enableMotor;
                },
                set: function (value) {
                    this.WakeBodies();
                    this._enableMotor = value;
                }
            },
            /**
             * Set the motor speed in radians per second.
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Dynamics.Joints.FixedRevoluteJoint
             * @function MotorSpeed
             * @type number
             */
            MotorSpeed: {
                get: function () {
                    return this._motorSpeed;
                },
                set: function (value) {
                    this.WakeBodies();
                    this._motorSpeed = value;
                }
            },
            /**
             * Set the maximum motor torque, usually in N-m.
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Dynamics.Joints.FixedRevoluteJoint
             * @function MaxMotorTorque
             * @type number
             */
            MaxMotorTorque: {
                get: function () {
                    return this._maxMotorTorque;
                },
                set: function (value) {
                    this.WakeBodies();
                    this._maxMotorTorque = value;
                }
            },
            /**
             * Get the current motor torque, usually in N-m.
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Dynamics.Joints.FixedRevoluteJoint
             * @function MotorTorque
             * @type number
             */
            MotorTorque: {
                get: function () {
                    return this._motorImpulse;
                },
                set: function (value) {
                    this.WakeBodies();
                    this._motorImpulse = value;
                }
            }
        },
        ctors: {
            init: function () {
                this._impulse = new Microsoft.Xna.Framework.Vector3();
                this._mass = new FarseerPhysics.Common.Mat33();
                this._worldAnchor = new Microsoft.Xna.Framework.Vector2();
                this.LocalAnchorA = new Microsoft.Xna.Framework.Vector2();
            },
            /**
             * Initialize the bodies, anchors, and reference angle using the world
             anchor.
             This requires defining an
             anchor point where the bodies are joined. The definition
             uses local anchor points so that the initial configuration
             can violate the constraint slightly. You also need to
             specify the initial relative angle for joint limits. This
             helps when saving and loading a game.
             The local anchor points are measured from the body's origin
             rather than the center of mass because:
             1. you might not know where the center of mass will be.
             2. if you add/remove shapes from a body and recompute the mass,
             the joints will be broken.
             *
             * @instance
             * @public
             * @this FarseerPhysics.Dynamics.Joints.FixedRevoluteJoint
             * @memberof FarseerPhysics.Dynamics.Joints.FixedRevoluteJoint
             * @param   {FarseerPhysics.Dynamics.Body}       body           The body.
             * @param   {Microsoft.Xna.Framework.Vector2}    bodyAnchor     The body anchor.
             * @param   {Microsoft.Xna.Framework.Vector2}    worldAnchor    The world anchor.
             * @return  {void}
             */
            ctor: function (body, bodyAnchor, worldAnchor) {
                this.$initialize();
                FarseerPhysics.Dynamics.Joints.Joint.$ctor1.call(this, body);
                this.JointType = FarseerPhysics.Dynamics.Joints.JointType.FixedRevolute;

                this.LocalAnchorA = bodyAnchor.$clone();
                this._worldAnchor = worldAnchor.$clone();

                this.ReferenceAngle = -this.BodyA.Rotation;

                this._impulse = Microsoft.Xna.Framework.Vector3.Zero.$clone();

                this._limitState = FarseerPhysics.Dynamics.Joints.LimitState.Inactive;
            }
        },
        methods: {
            GetReactionForce: function (inv_dt) {
                return Microsoft.Xna.Framework.Vector2.op_Multiply$2(inv_dt, new Microsoft.Xna.Framework.Vector2.$ctor2(this._impulse.X, this._impulse.Y));
            },
            GetReactionTorque: function (inv_dt) {
                return inv_dt * this._impulse.Z;
            },
            InitVelocityConstraints: function (step) {
                var b1 = this.BodyA;

                if (this._enableMotor || this._enableLimit) {
                    System.Diagnostics.Debug.Assert(b1.InvI > 0.0);
                }

                var xf1 = { v : new FarseerPhysics.Common.Transform() };
                b1.GetTransform(xf1);

                var r1 = FarseerPhysics.Common.MathUtils.Multiply(Bridge.ref(xf1.v, "R"), Microsoft.Xna.Framework.Vector2.op_Subtraction(this.LocalAnchorA.$clone(), b1.LocalCenter.$clone()));
                var r2 = this._worldAnchor.$clone();



                var m1 = b1.InvMass;
                var m2 = 0;
                var i1 = b1.InvI;
                var i2 = 0;

                this._mass.Col1.X = m1 + m2 + r1.Y * r1.Y * i1 + r2.Y * r2.Y * i2;
                this._mass.Col2.X = -r1.Y * r1.X * i1 - r2.Y * r2.X * i2;
                this._mass.Col3.X = -r1.Y * i1 - r2.Y * i2;
                this._mass.Col1.Y = this._mass.Col2.X;
                this._mass.Col2.Y = m1 + m2 + r1.X * r1.X * i1 + r2.X * r2.X * i2;
                this._mass.Col3.Y = r1.X * i1 + r2.X * i2;
                this._mass.Col1.Z = this._mass.Col3.X;
                this._mass.Col2.Z = this._mass.Col3.Y;
                this._mass.Col3.Z = i1 + i2;

                this._motorMass = i1 + i2;
                if (this._motorMass > 0.0) {
                    this._motorMass = 1.0 / this._motorMass;
                }

                if (this._enableMotor === false) {
                    this._motorImpulse = 0.0;
                }

                if (this._enableLimit) {
                    var jointAngle = 0 - b1.Sweep.A - this.ReferenceAngle;
                    if (Math.abs(this._upperAngle - this._lowerAngle) < 0.06981318) {
                        this._limitState = FarseerPhysics.Dynamics.Joints.LimitState.Equal;
                    } else if (jointAngle <= this._lowerAngle) {
                        if (this._limitState !== FarseerPhysics.Dynamics.Joints.LimitState.AtLower) {
                            this._impulse.Z = 0.0;
                        }
                        this._limitState = FarseerPhysics.Dynamics.Joints.LimitState.AtLower;
                    } else if (jointAngle >= this._upperAngle) {
                        if (this._limitState !== FarseerPhysics.Dynamics.Joints.LimitState.AtUpper) {
                            this._impulse.Z = 0.0;
                        }
                        this._limitState = FarseerPhysics.Dynamics.Joints.LimitState.AtUpper;
                    } else {
                        this._limitState = FarseerPhysics.Dynamics.Joints.LimitState.Inactive;
                        this._impulse.Z = 0.0;
                    }
                } else {
                    this._limitState = FarseerPhysics.Dynamics.Joints.LimitState.Inactive;
                }

                if (FarseerPhysics.Settings.EnableWarmstarting) {
                    this._impulse = Microsoft.Xna.Framework.Vector3.op_Multiply$1(this._impulse.$clone(), step.v.dtRatio);
                    this._motorImpulse *= step.v.dtRatio;

                    var P = new Microsoft.Xna.Framework.Vector2.$ctor2(this._impulse.X, this._impulse.Y);

                    b1.LinearVelocityInternal = Microsoft.Xna.Framework.Vector2.op_Subtraction(b1.LinearVelocityInternal.$clone(), Microsoft.Xna.Framework.Vector2.op_Multiply$2(m1, P.$clone()));
                    b1.AngularVelocityInternal -= i1 * (FarseerPhysics.Common.MathUtils.Cross$2(r1.$clone(), P.$clone()) + this._motorImpulse + this._impulse.Z);
                } else {
                    this._impulse = Microsoft.Xna.Framework.Vector3.Zero.$clone();
                    this._motorImpulse = 0.0;
                }
            },
            SolveVelocityConstraints: function (step) {
                var b1 = this.BodyA;

                var v1 = b1.LinearVelocityInternal.$clone();
                var w1 = b1.AngularVelocityInternal;
                var v2 = Microsoft.Xna.Framework.Vector2.Zero.$clone();
                var w2 = 0;

                var m1 = b1.InvMass;
                var i1 = b1.InvI;

                if (this._enableMotor && this._limitState !== FarseerPhysics.Dynamics.Joints.LimitState.Equal) {
                    var Cdot = w2 - w1 - this._motorSpeed;
                    var impulse = this._motorMass * (-Cdot);
                    var oldImpulse = this._motorImpulse;
                    var maxImpulse = step.v.dt * this._maxMotorTorque;
                    this._motorImpulse = FarseerPhysics.Common.MathUtils.Clamp$2(this._motorImpulse + impulse, -maxImpulse, maxImpulse);
                    impulse = this._motorImpulse - oldImpulse;

                    w1 -= i1 * impulse;
                }

                if (this._enableLimit && this._limitState !== FarseerPhysics.Dynamics.Joints.LimitState.Inactive) {
                    var xf1 = { v : new FarseerPhysics.Common.Transform() };
                    b1.GetTransform(xf1);

                    var r1 = FarseerPhysics.Common.MathUtils.Multiply(Bridge.ref(xf1.v, "R"), Microsoft.Xna.Framework.Vector2.op_Subtraction(this.LocalAnchorA.$clone(), b1.LocalCenter.$clone()));
                    var r2 = this._worldAnchor.$clone();

                    var Cdot1 = Microsoft.Xna.Framework.Vector2.op_Subtraction(Microsoft.Xna.Framework.Vector2.op_Subtraction(Microsoft.Xna.Framework.Vector2.op_Addition(v2.$clone(), FarseerPhysics.Common.MathUtils.Cross$1(w2, r2.$clone())), v1.$clone()), FarseerPhysics.Common.MathUtils.Cross$1(w1, r1.$clone()));
                    var Cdot2 = w2 - w1;
                    var Cdot3 = new Microsoft.Xna.Framework.Vector3.$ctor3(Cdot1.X, Cdot1.Y, Cdot2);

                    var impulse1 = this._mass.Solve33(Microsoft.Xna.Framework.Vector3.op_UnaryNegation(Cdot3.$clone()));

                    if (this._limitState === FarseerPhysics.Dynamics.Joints.LimitState.Equal) {
                        this._impulse = Microsoft.Xna.Framework.Vector3.op_Addition(this._impulse.$clone(), impulse1.$clone());
                    } else if (this._limitState === FarseerPhysics.Dynamics.Joints.LimitState.AtLower) {
                        var newImpulse = this._impulse.Z + impulse1.Z;
                        if (newImpulse < 0.0) {
                            var reduced = this._mass.Solve22(Microsoft.Xna.Framework.Vector2.op_UnaryNegation(Cdot1.$clone()));
                            impulse1.X = reduced.X;
                            impulse1.Y = reduced.Y;
                            impulse1.Z = -this._impulse.Z;
                            this._impulse.X += reduced.X;
                            this._impulse.Y += reduced.Y;
                            this._impulse.Z = 0.0;
                        }
                    } else if (this._limitState === FarseerPhysics.Dynamics.Joints.LimitState.AtUpper) {
                        var newImpulse1 = this._impulse.Z + impulse1.Z;
                        if (newImpulse1 > 0.0) {
                            var reduced1 = this._mass.Solve22(Microsoft.Xna.Framework.Vector2.op_UnaryNegation(Cdot1.$clone()));
                            impulse1.X = reduced1.X;
                            impulse1.Y = reduced1.Y;
                            impulse1.Z = -this._impulse.Z;
                            this._impulse.X += reduced1.X;
                            this._impulse.Y += reduced1.Y;
                            this._impulse.Z = 0.0;
                        }
                    }

                    var P = new Microsoft.Xna.Framework.Vector2.$ctor2(impulse1.X, impulse1.Y);

                    v1 = Microsoft.Xna.Framework.Vector2.op_Subtraction(v1.$clone(), Microsoft.Xna.Framework.Vector2.op_Multiply$2(m1, P.$clone()));
                    w1 -= i1 * (FarseerPhysics.Common.MathUtils.Cross$2(r1.$clone(), P.$clone()) + impulse1.Z);
                } else {
                    var xf11 = { v : new FarseerPhysics.Common.Transform() };
                    b1.GetTransform(xf11);

                    var r11 = FarseerPhysics.Common.MathUtils.Multiply(Bridge.ref(xf11.v, "R"), Microsoft.Xna.Framework.Vector2.op_Subtraction(this.LocalAnchorA.$clone(), b1.LocalCenter.$clone()));
                    var r21 = this._worldAnchor.$clone();

                    var Cdot4 = Microsoft.Xna.Framework.Vector2.op_Subtraction(Microsoft.Xna.Framework.Vector2.op_Subtraction(Microsoft.Xna.Framework.Vector2.op_Addition(v2.$clone(), FarseerPhysics.Common.MathUtils.Cross$1(w2, r21.$clone())), v1.$clone()), FarseerPhysics.Common.MathUtils.Cross$1(w1, r11.$clone()));
                    var impulse2 = this._mass.Solve22(Microsoft.Xna.Framework.Vector2.op_UnaryNegation(Cdot4.$clone()));

                    this._impulse.X += impulse2.X;
                    this._impulse.Y += impulse2.Y;

                    v1 = Microsoft.Xna.Framework.Vector2.op_Subtraction(v1.$clone(), Microsoft.Xna.Framework.Vector2.op_Multiply$2(m1, impulse2.$clone()));
                    w1 -= i1 * FarseerPhysics.Common.MathUtils.Cross$2(r11.$clone(), impulse2.$clone());
                }

                b1.LinearVelocityInternal = v1.$clone();
                b1.AngularVelocityInternal = w1;
            },
            SolvePositionConstraints: function () {

                var b1 = this.BodyA;

                var angularError = 0.0;
                var positionError;

                if (this._enableLimit && this._limitState !== FarseerPhysics.Dynamics.Joints.LimitState.Inactive) {
                    var angle = 0 - b1.Sweep.A - this.ReferenceAngle;
                    var limitImpulse = 0.0;

                    if (this._limitState === FarseerPhysics.Dynamics.Joints.LimitState.Equal) {
                        var C = FarseerPhysics.Common.MathUtils.Clamp$2(angle - this._lowerAngle, -0.139626354, FarseerPhysics.Settings.MaxAngularCorrection);
                        limitImpulse = -this._motorMass * C;
                        angularError = Math.abs(C);
                    } else if (this._limitState === FarseerPhysics.Dynamics.Joints.LimitState.AtLower) {
                        var C1 = angle - this._lowerAngle;
                        angularError = -C1;

                        C1 = FarseerPhysics.Common.MathUtils.Clamp$2(C1 + FarseerPhysics.Settings.AngularSlop, -0.139626354, 0.0);
                        limitImpulse = -this._motorMass * C1;
                    } else if (this._limitState === FarseerPhysics.Dynamics.Joints.LimitState.AtUpper) {
                        var C2 = angle - this._upperAngle;
                        angularError = C2;

                        C2 = FarseerPhysics.Common.MathUtils.Clamp$2(C2 - FarseerPhysics.Settings.AngularSlop, 0.0, FarseerPhysics.Settings.MaxAngularCorrection);
                        limitImpulse = -this._motorMass * C2;
                    }

                    b1.Sweep.A -= b1.InvI * limitImpulse;

                    b1.SynchronizeTransform();
                }

                {
                    var xf1 = { v : new FarseerPhysics.Common.Transform() };
                    b1.GetTransform(xf1);

                    var r1 = FarseerPhysics.Common.MathUtils.Multiply(Bridge.ref(xf1.v, "R"), Microsoft.Xna.Framework.Vector2.op_Subtraction(this.LocalAnchorA.$clone(), b1.LocalCenter.$clone()));
                    var r2 = this._worldAnchor.$clone();

                    var C3 = Microsoft.Xna.Framework.Vector2.op_Subtraction(Microsoft.Xna.Framework.Vector2.op_Subtraction(Microsoft.Xna.Framework.Vector2.op_Addition(Microsoft.Xna.Framework.Vector2.Zero.$clone(), r2.$clone()), b1.Sweep.C.$clone()), r1.$clone());
                    positionError = C3.Length();

                    var invMass1 = b1.InvMass;
                    var invMass2 = 0;
                    var invI1 = b1.InvI;
                    var invI2 = 0;

                    var k_allowedStretch = 0.049999997;
                    if (C3.LengthSquared() > 0.00249999971) {
                        var u = C3.$clone();
                        u.Normalize();
                        var k = invMass1 + invMass2;
                        System.Diagnostics.Debug.Assert(k > FarseerPhysics.Settings.Epsilon);
                        var m = 1.0 / k;
                        var impulse2 = Microsoft.Xna.Framework.Vector2.op_Multiply$2(m, (Microsoft.Xna.Framework.Vector2.op_UnaryNegation(C3.$clone())));
                        var k_beta = 0.5;
                        b1.Sweep.C = Microsoft.Xna.Framework.Vector2.op_Subtraction(b1.Sweep.C.$clone(), Microsoft.Xna.Framework.Vector2.op_Multiply$2(k_beta * invMass1, impulse2.$clone()));

                        C3 = Microsoft.Xna.Framework.Vector2.op_Subtraction(Microsoft.Xna.Framework.Vector2.op_Subtraction(Microsoft.Xna.Framework.Vector2.op_Addition(Microsoft.Xna.Framework.Vector2.Zero.$clone(), r2.$clone()), b1.Sweep.C.$clone()), r1.$clone());
                    }

                    var K1 = { v : new FarseerPhysics.Common.Mat22.$ctor1(new Microsoft.Xna.Framework.Vector2.$ctor2(invMass1 + invMass2, 0.0), new Microsoft.Xna.Framework.Vector2.$ctor2(0.0, invMass1 + invMass2)) };
                    var K2 = { v : new FarseerPhysics.Common.Mat22.$ctor1(new Microsoft.Xna.Framework.Vector2.$ctor2(invI1 * r1.Y * r1.Y, -invI1 * r1.X * r1.Y), new Microsoft.Xna.Framework.Vector2.$ctor2(-invI1 * r1.X * r1.Y, invI1 * r1.X * r1.X)) };
                    var K3 = { v : new FarseerPhysics.Common.Mat22.$ctor1(new Microsoft.Xna.Framework.Vector2.$ctor2(invI2 * r2.Y * r2.Y, 0.0 * r2.X * r2.Y), new Microsoft.Xna.Framework.Vector2.$ctor2(0.0 * r2.X * r2.Y, invI2 * r2.X * r2.X)) };

                    var Ka = { v : new FarseerPhysics.Common.Mat22() };
                    FarseerPhysics.Common.Mat22.Add(K1, K2, Ka);

                    var K = { v : new FarseerPhysics.Common.Mat22() };
                    FarseerPhysics.Common.Mat22.Add(Ka, K3, K);

                    var impulse = K.v.Solve(Microsoft.Xna.Framework.Vector2.op_UnaryNegation(C3.$clone()));

                    b1.Sweep.C = Microsoft.Xna.Framework.Vector2.op_Subtraction(b1.Sweep.C.$clone(), Microsoft.Xna.Framework.Vector2.op_Multiply$2(b1.InvMass, impulse.$clone()));
                    b1.Sweep.A -= b1.InvI * FarseerPhysics.Common.MathUtils.Cross$2(r1.$clone(), impulse.$clone());

                    b1.SynchronizeTransform();
                }

                return positionError <= FarseerPhysics.Settings.LinearSlop && angularError <= FarseerPhysics.Settings.AngularSlop;
            }
        }
    });

    /**
     * Friction joint. This is used for top-down friction.
     It provides 2D translational friction and angular friction.
     *
     * @public
     * @class FarseerPhysics.Dynamics.Joints.FrictionJoint
     * @augments FarseerPhysics.Dynamics.Joints.Joint
     */
    Bridge.define("FarseerPhysics.Dynamics.Joints.FrictionJoint", {
        inherits: [FarseerPhysics.Dynamics.Joints.Joint],
        fields: {
            LocalAnchorA: null,
            LocalAnchorB: null,
            _angularImpulse: 0,
            _angularMass: 0,
            _linearImpulse: null,
            _linearMass: null,
            /**
             * The maximum friction force in N.
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Dynamics.Joints.FrictionJoint
             * @function MaxForce
             * @type number
             */
            MaxForce: 0,
            /**
             * The maximum friction torque in N-m.
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Dynamics.Joints.FrictionJoint
             * @function MaxTorque
             * @type number
             */
            MaxTorque: 0
        },
        props: {
            WorldAnchorA: {
                get: function () {
                    return this.BodyA.GetWorldPoint(this.LocalAnchorA.$clone());
                }
            },
            WorldAnchorB: {
                get: function () {
                    return this.BodyB.GetWorldPoint(this.LocalAnchorB.$clone());
                },
                set: function (value) {
                    System.Diagnostics.Debug.Assert$1(false, "You can't set the world anchor on this joint type.");
                }
            }
        },
        ctors: {
            init: function () {
                this.LocalAnchorA = new Microsoft.Xna.Framework.Vector2();
                this.LocalAnchorB = new Microsoft.Xna.Framework.Vector2();
                this._linearImpulse = new Microsoft.Xna.Framework.Vector2();
                this._linearMass = new FarseerPhysics.Common.Mat22();
            },
            ctor: function () {
                this.$initialize();
                FarseerPhysics.Dynamics.Joints.Joint.ctor.call(this);
                this.JointType = FarseerPhysics.Dynamics.Joints.JointType.Friction;
            },
            $ctor1: function (bodyA, bodyB, localAnchorA, localAnchorB) {
                this.$initialize();
                FarseerPhysics.Dynamics.Joints.Joint.$ctor2.call(this, bodyA, bodyB);
                this.JointType = FarseerPhysics.Dynamics.Joints.JointType.Friction;
                this.LocalAnchorA = localAnchorA.$clone();
                this.LocalAnchorB = localAnchorB.$clone();
            }
        },
        methods: {
            GetReactionForce: function (inv_dt) {
                return Microsoft.Xna.Framework.Vector2.op_Multiply$2(inv_dt, this._linearImpulse.$clone());
            },
            GetReactionTorque: function (inv_dt) {
                return inv_dt * this._angularImpulse;
            },
            InitVelocityConstraints: function (step) {
                var bA = this.BodyA;
                var bB = this.BodyB;

                var xfA = { v : new FarseerPhysics.Common.Transform() }, xfB = { v : new FarseerPhysics.Common.Transform() };
                bA.GetTransform(xfA);
                bB.GetTransform(xfB);

                var rA = FarseerPhysics.Common.MathUtils.Multiply(Bridge.ref(xfA.v, "R"), Microsoft.Xna.Framework.Vector2.op_Subtraction(this.LocalAnchorA.$clone(), bA.LocalCenter.$clone()));
                var rB = FarseerPhysics.Common.MathUtils.Multiply(Bridge.ref(xfB.v, "R"), Microsoft.Xna.Framework.Vector2.op_Subtraction(this.LocalAnchorB.$clone(), bB.LocalCenter.$clone()));



                var mA = bA.InvMass, mB = bB.InvMass;
                var iA = bA.InvI, iB = bB.InvI;

                var K1 = { v : new FarseerPhysics.Common.Mat22.ctor() };
                K1.v.Col1.X = mA + mB;
                K1.v.Col2.X = 0.0;
                K1.v.Col1.Y = 0.0;
                K1.v.Col2.Y = mA + mB;

                var K2 = { v : new FarseerPhysics.Common.Mat22.ctor() };
                K2.v.Col1.X = iA * rA.Y * rA.Y;
                K2.v.Col2.X = -iA * rA.X * rA.Y;
                K2.v.Col1.Y = -iA * rA.X * rA.Y;
                K2.v.Col2.Y = iA * rA.X * rA.X;

                var K3 = { v : new FarseerPhysics.Common.Mat22.ctor() };
                K3.v.Col1.X = iB * rB.Y * rB.Y;
                K3.v.Col2.X = -iB * rB.X * rB.Y;
                K3.v.Col1.Y = -iB * rB.X * rB.Y;
                K3.v.Col2.Y = iB * rB.X * rB.X;

                var K12 = { v : new FarseerPhysics.Common.Mat22() };
                FarseerPhysics.Common.Mat22.Add(K1, K2, K12);

                var K = { v : new FarseerPhysics.Common.Mat22() };
                FarseerPhysics.Common.Mat22.Add(K12, K3, K);

                this._linearMass = K.v.Inverse.$clone();

                this._angularMass = iA + iB;
                if (this._angularMass > 0.0) {
                    this._angularMass = 1.0 / this._angularMass;
                }

                if (FarseerPhysics.Settings.EnableWarmstarting) {
                    this._linearImpulse = Microsoft.Xna.Framework.Vector2.op_Multiply$1(this._linearImpulse.$clone(), step.v.dtRatio);
                    this._angularImpulse *= step.v.dtRatio;

                    var P = new Microsoft.Xna.Framework.Vector2.$ctor2(this._linearImpulse.X, this._linearImpulse.Y);

                    bA.LinearVelocityInternal = Microsoft.Xna.Framework.Vector2.op_Subtraction(bA.LinearVelocityInternal.$clone(), Microsoft.Xna.Framework.Vector2.op_Multiply$2(mA, P.$clone()));
                    bA.AngularVelocityInternal -= iA * (FarseerPhysics.Common.MathUtils.Cross$2(rA.$clone(), P.$clone()) + this._angularImpulse);

                    bB.LinearVelocityInternal = Microsoft.Xna.Framework.Vector2.op_Addition(bB.LinearVelocityInternal.$clone(), Microsoft.Xna.Framework.Vector2.op_Multiply$2(mB, P.$clone()));
                    bB.AngularVelocityInternal += iB * (FarseerPhysics.Common.MathUtils.Cross$2(rB.$clone(), P.$clone()) + this._angularImpulse);
                } else {
                    this._linearImpulse = Microsoft.Xna.Framework.Vector2.Zero.$clone();
                    this._angularImpulse = 0.0;
                }
            },
            SolveVelocityConstraints: function (step) {
                var bA = this.BodyA;
                var bB = this.BodyB;

                var vA = bA.LinearVelocityInternal.$clone();
                var wA = bA.AngularVelocityInternal;
                var vB = bB.LinearVelocityInternal.$clone();
                var wB = bB.AngularVelocityInternal;

                var mA = bA.InvMass, mB = bB.InvMass;
                var iA = bA.InvI, iB = bB.InvI;

                var xfA = { v : new FarseerPhysics.Common.Transform() }, xfB = { v : new FarseerPhysics.Common.Transform() };
                bA.GetTransform(xfA);
                bB.GetTransform(xfB);

                var rA = FarseerPhysics.Common.MathUtils.Multiply(Bridge.ref(xfA.v, "R"), Microsoft.Xna.Framework.Vector2.op_Subtraction(this.LocalAnchorA.$clone(), bA.LocalCenter.$clone()));
                var rB = FarseerPhysics.Common.MathUtils.Multiply(Bridge.ref(xfB.v, "R"), Microsoft.Xna.Framework.Vector2.op_Subtraction(this.LocalAnchorB.$clone(), bB.LocalCenter.$clone()));

                {
                    var Cdot = wB - wA;
                    var impulse = -this._angularMass * Cdot;

                    var oldImpulse = this._angularImpulse;
                    var maxImpulse = step.v.dt * this.MaxTorque;
                    this._angularImpulse = FarseerPhysics.Common.MathUtils.Clamp$2(this._angularImpulse + impulse, -maxImpulse, maxImpulse);
                    impulse = this._angularImpulse - oldImpulse;

                    wA -= iA * impulse;
                    wB += iB * impulse;
                }

                {
                    var Cdot1 = Microsoft.Xna.Framework.Vector2.op_Subtraction(Microsoft.Xna.Framework.Vector2.op_Subtraction(Microsoft.Xna.Framework.Vector2.op_Addition(vB.$clone(), FarseerPhysics.Common.MathUtils.Cross$1(wB, rB.$clone())), vA.$clone()), FarseerPhysics.Common.MathUtils.Cross$1(wA, rA.$clone()));

                    var impulse1 = Microsoft.Xna.Framework.Vector2.op_UnaryNegation(FarseerPhysics.Common.MathUtils.Multiply(Bridge.ref(this, "_linearMass"), Cdot1.$clone()));
                    var oldImpulse1 = this._linearImpulse.$clone();
                    this._linearImpulse = Microsoft.Xna.Framework.Vector2.op_Addition(this._linearImpulse.$clone(), impulse1.$clone());

                    var maxImpulse1 = step.v.dt * this.MaxForce;

                    if (this._linearImpulse.LengthSquared() > maxImpulse1 * maxImpulse1) {
                        this._linearImpulse.Normalize();
                        this._linearImpulse = Microsoft.Xna.Framework.Vector2.op_Multiply$1(this._linearImpulse.$clone(), maxImpulse1);
                    }

                    impulse1 = Microsoft.Xna.Framework.Vector2.op_Subtraction(this._linearImpulse.$clone(), oldImpulse1.$clone());

                    vA = Microsoft.Xna.Framework.Vector2.op_Subtraction(vA.$clone(), Microsoft.Xna.Framework.Vector2.op_Multiply$2(mA, impulse1.$clone()));
                    wA -= iA * FarseerPhysics.Common.MathUtils.Cross$2(rA.$clone(), impulse1.$clone());

                    vB = Microsoft.Xna.Framework.Vector2.op_Addition(vB.$clone(), Microsoft.Xna.Framework.Vector2.op_Multiply$2(mB, impulse1.$clone()));
                    wB += iB * FarseerPhysics.Common.MathUtils.Cross$2(rB.$clone(), impulse1.$clone());
                }

                bA.LinearVelocityInternal = vA.$clone();
                bA.AngularVelocityInternal = wA;
                bB.LinearVelocityInternal = vB.$clone();
                bB.AngularVelocityInternal = wB;
            },
            SolvePositionConstraints: function () {
                return true;
            }
        }
    });

    /**
     * A gear joint is used to connect two joints together. Either joint
     can be a revolute or prismatic joint. You specify a gear ratio
     to bind the motions together:
     coordinate1 + ratio * coordinate2 = ant
     The ratio can be negative or positive. If one joint is a revolute joint
     and the other joint is a prismatic joint, then the ratio will have units
     of length or units of 1/length.
     @warning The revolute and prismatic joints must be attached to
     fixed bodies (which must be body1 on those joints).
     *
     * @public
     * @class FarseerPhysics.Dynamics.Joints.GearJoint
     * @augments FarseerPhysics.Dynamics.Joints.Joint
     */
    Bridge.define("FarseerPhysics.Dynamics.Joints.GearJoint", {
        inherits: [FarseerPhysics.Dynamics.Joints.Joint],
        fields: {
            _J: null,
            _ant: 0,
            _fixedPrismatic1: null,
            _fixedPrismatic2: null,
            _fixedRevolute1: null,
            _fixedRevolute2: null,
            _impulse: 0,
            _mass: 0,
            _prismatic1: null,
            _prismatic2: null,
            _revolute1: null,
            _revolute2: null,
            /**
             * The gear ratio.
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Dynamics.Joints.GearJoint
             * @function Ratio
             * @type number
             */
            Ratio: 0,
            /**
             * The first revolute/prismatic joint attached to the gear joint.
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Dynamics.Joints.GearJoint
             * @function JointA
             * @type FarseerPhysics.Dynamics.Joints.Joint
             */
            JointA: null,
            /**
             * The second revolute/prismatic joint attached to the gear joint.
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Dynamics.Joints.GearJoint
             * @function JointB
             * @type FarseerPhysics.Dynamics.Joints.Joint
             */
            JointB: null,
            LocalAnchor1: null,
            LocalAnchor2: null
        },
        props: {
            WorldAnchorA: {
                get: function () {
                    return this.BodyA.GetWorldPoint(this.LocalAnchor1.$clone());
                }
            },
            WorldAnchorB: {
                get: function () {
                    return this.BodyB.GetWorldPoint(this.LocalAnchor2.$clone());
                },
                set: function (value) {
                    System.Diagnostics.Debug.Assert$1(false, "You can't set the world anchor on this joint type.");
                }
            }
        },
        ctors: {
            init: function () {
                this._J = new FarseerPhysics.Dynamics.Joints.Jacobian();
                this.LocalAnchor1 = new Microsoft.Xna.Framework.Vector2();
                this.LocalAnchor2 = new Microsoft.Xna.Framework.Vector2();
            },
            /**
             * Requires two existing revolute or prismatic joints (any combination will work).
             The provided joints must attach a dynamic body to a static body.
             *
             * @instance
             * @public
             * @this FarseerPhysics.Dynamics.Joints.GearJoint
             * @memberof FarseerPhysics.Dynamics.Joints.GearJoint
             * @param   {FarseerPhysics.Dynamics.Joints.Joint}    jointA    The first joint.
             * @param   {FarseerPhysics.Dynamics.Joints.Joint}    jointB    The second joint.
             * @param   {number}                                  ratio     The ratio.
             * @return  {void}
             */
            ctor: function (jointA, jointB, ratio) {
                this.$initialize();
                FarseerPhysics.Dynamics.Joints.Joint.$ctor2.call(this, jointA.BodyA, jointA.BodyB);
                this.JointType = FarseerPhysics.Dynamics.Joints.JointType.Gear;
                this.JointA = jointA;
                this.JointB = jointB;
                this.Ratio = ratio;

                var type1 = jointA.JointType;
                var type2 = jointB.JointType;

                System.Diagnostics.Debug.Assert(type1 === FarseerPhysics.Dynamics.Joints.JointType.Revolute || type1 === FarseerPhysics.Dynamics.Joints.JointType.Prismatic || type1 === FarseerPhysics.Dynamics.Joints.JointType.FixedRevolute || type1 === FarseerPhysics.Dynamics.Joints.JointType.FixedPrismatic);
                System.Diagnostics.Debug.Assert(type2 === FarseerPhysics.Dynamics.Joints.JointType.Revolute || type2 === FarseerPhysics.Dynamics.Joints.JointType.Prismatic || type2 === FarseerPhysics.Dynamics.Joints.JointType.FixedRevolute || type2 === FarseerPhysics.Dynamics.Joints.JointType.FixedPrismatic);

                if (type1 === FarseerPhysics.Dynamics.Joints.JointType.Revolute || type1 === FarseerPhysics.Dynamics.Joints.JointType.Prismatic) {
                    System.Diagnostics.Debug.Assert(jointA.BodyA.BodyType === FarseerPhysics.Dynamics.BodyType.Static);
                }
                if (type2 === FarseerPhysics.Dynamics.Joints.JointType.Revolute || type2 === FarseerPhysics.Dynamics.Joints.JointType.Prismatic) {
                    System.Diagnostics.Debug.Assert(jointB.BodyA.BodyType === FarseerPhysics.Dynamics.BodyType.Static);
                }

                var coordinate1 = 0.0, coordinate2 = 0.0;

                switch (type1) {
                    case FarseerPhysics.Dynamics.Joints.JointType.Revolute: 
                        this.BodyA = jointA.BodyB;
                        this._revolute1 = Bridge.cast(jointA, FarseerPhysics.Dynamics.Joints.RevoluteJoint);
                        this.LocalAnchor1 = this._revolute1.LocalAnchorB.$clone();
                        coordinate1 = this._revolute1.JointAngle;
                        break;
                    case FarseerPhysics.Dynamics.Joints.JointType.Prismatic: 
                        this.BodyA = jointA.BodyB;
                        this._prismatic1 = Bridge.cast(jointA, FarseerPhysics.Dynamics.Joints.PrismaticJoint);
                        this.LocalAnchor1 = this._prismatic1.LocalAnchorB.$clone();
                        coordinate1 = this._prismatic1.JointTranslation;
                        break;
                    case FarseerPhysics.Dynamics.Joints.JointType.FixedRevolute: 
                        this.BodyA = jointA.BodyA;
                        this._fixedRevolute1 = Bridge.cast(jointA, FarseerPhysics.Dynamics.Joints.FixedRevoluteJoint);
                        this.LocalAnchor1 = this._fixedRevolute1.LocalAnchorA.$clone();
                        coordinate1 = this._fixedRevolute1.JointAngle;
                        break;
                    case FarseerPhysics.Dynamics.Joints.JointType.FixedPrismatic: 
                        this.BodyA = jointA.BodyA;
                        this._fixedPrismatic1 = Bridge.cast(jointA, FarseerPhysics.Dynamics.Joints.FixedPrismaticJoint);
                        this.LocalAnchor1 = this._fixedPrismatic1.LocalAnchorA.$clone();
                        coordinate1 = this._fixedPrismatic1.JointTranslation;
                        break;
                }

                switch (type2) {
                    case FarseerPhysics.Dynamics.Joints.JointType.Revolute: 
                        this.BodyB = jointB.BodyB;
                        this._revolute2 = Bridge.cast(jointB, FarseerPhysics.Dynamics.Joints.RevoluteJoint);
                        this.LocalAnchor2 = this._revolute2.LocalAnchorB.$clone();
                        coordinate2 = this._revolute2.JointAngle;
                        break;
                    case FarseerPhysics.Dynamics.Joints.JointType.Prismatic: 
                        this.BodyB = jointB.BodyB;
                        this._prismatic2 = Bridge.cast(jointB, FarseerPhysics.Dynamics.Joints.PrismaticJoint);
                        this.LocalAnchor2 = this._prismatic2.LocalAnchorB.$clone();
                        coordinate2 = this._prismatic2.JointTranslation;
                        break;
                    case FarseerPhysics.Dynamics.Joints.JointType.FixedRevolute: 
                        this.BodyB = jointB.BodyA;
                        this._fixedRevolute2 = Bridge.cast(jointB, FarseerPhysics.Dynamics.Joints.FixedRevoluteJoint);
                        this.LocalAnchor2 = this._fixedRevolute2.LocalAnchorA.$clone();
                        coordinate2 = this._fixedRevolute2.JointAngle;
                        break;
                    case FarseerPhysics.Dynamics.Joints.JointType.FixedPrismatic: 
                        this.BodyB = jointB.BodyA;
                        this._fixedPrismatic2 = Bridge.cast(jointB, FarseerPhysics.Dynamics.Joints.FixedPrismaticJoint);
                        this.LocalAnchor2 = this._fixedPrismatic2.LocalAnchorA.$clone();
                        coordinate2 = this._fixedPrismatic2.JointTranslation;
                        break;
                }

                this._ant = coordinate1 + this.Ratio * coordinate2;
            }
        },
        methods: {
            GetReactionForce: function (inv_dt) {
                var P = Microsoft.Xna.Framework.Vector2.op_Multiply$2(this._impulse, this._J.LinearB.$clone());
                return Microsoft.Xna.Framework.Vector2.op_Multiply$2(inv_dt, P.$clone());
            },
            GetReactionTorque: function (inv_dt) {
                var xf1 = { v : new FarseerPhysics.Common.Transform() };
                this.BodyB.GetTransform(xf1);

                var r = FarseerPhysics.Common.MathUtils.Multiply(Bridge.ref(xf1.v, "R"), Microsoft.Xna.Framework.Vector2.op_Subtraction(this.LocalAnchor2.$clone(), this.BodyB.LocalCenter.$clone()));
                var P = Microsoft.Xna.Framework.Vector2.op_Multiply$2(this._impulse, this._J.LinearB.$clone());
                var L = this._impulse * this._J.AngularB - FarseerPhysics.Common.MathUtils.Cross$2(r.$clone(), P.$clone());
                return inv_dt * L;
            },
            InitVelocityConstraints: function (step) {
                var b1 = this.BodyA;
                var b2 = this.BodyB;

                var K = 0.0;
                this._J.SetZero();

                if (this._revolute1 != null || this._fixedRevolute1 != null) {
                    this._J.AngularA = -1.0;
                    K += b1.InvI;
                } else {
                    var ug = new Microsoft.Xna.Framework.Vector2();
                    if (this._prismatic1 != null) {
                        ug = this._prismatic1.LocalXAxis1.$clone();
                    } else {
                        ug = this._fixedPrismatic1.LocalXAxis1.$clone();
                    }

                    var xf1 = { v : new FarseerPhysics.Common.Transform() };
                    b1.GetTransform(xf1);


                    var r = FarseerPhysics.Common.MathUtils.Multiply(Bridge.ref(xf1.v, "R"), Microsoft.Xna.Framework.Vector2.op_Subtraction(this.LocalAnchor1.$clone(), b1.LocalCenter.$clone()));
                    var crug = FarseerPhysics.Common.MathUtils.Cross$2(r.$clone(), ug.$clone());
                    this._J.LinearA = Microsoft.Xna.Framework.Vector2.op_UnaryNegation(ug.$clone());
                    this._J.AngularA = -crug;
                    K += b1.InvMass + b1.InvI * crug * crug;
                }

                if (this._revolute2 != null || this._fixedRevolute2 != null) {
                    this._J.AngularB = -this.Ratio;
                    K += this.Ratio * this.Ratio * b2.InvI;
                } else {
                    var ug1 = new Microsoft.Xna.Framework.Vector2();
                    if (this._prismatic2 != null) {
                        ug1 = this._prismatic2.LocalXAxis1.$clone();
                    } else {
                        ug1 = this._fixedPrismatic2.LocalXAxis1.$clone();
                    }

                    var xf2 = { v : new FarseerPhysics.Common.Transform() };
                    b2.GetTransform(xf2);

                    var r1 = FarseerPhysics.Common.MathUtils.Multiply(Bridge.ref(xf2.v, "R"), Microsoft.Xna.Framework.Vector2.op_Subtraction(this.LocalAnchor2.$clone(), b2.LocalCenter.$clone()));
                    var crug1 = FarseerPhysics.Common.MathUtils.Cross$2(r1.$clone(), ug1.$clone());
                    this._J.LinearB = Microsoft.Xna.Framework.Vector2.op_Multiply$2(-this.Ratio, ug1.$clone());
                    this._J.AngularB = -this.Ratio * crug1;
                    K += this.Ratio * this.Ratio * (b2.InvMass + b2.InvI * crug1 * crug1);
                }

                System.Diagnostics.Debug.Assert(K > 0.0);
                this._mass = K > 0.0 ? 1.0 / K : 0.0;

                if (FarseerPhysics.Settings.EnableWarmstarting) {
                    b1.LinearVelocityInternal = Microsoft.Xna.Framework.Vector2.op_Addition(b1.LinearVelocityInternal.$clone(), Microsoft.Xna.Framework.Vector2.op_Multiply$2(b1.InvMass * this._impulse, this._J.LinearA.$clone()));
                    b1.AngularVelocityInternal += b1.InvI * this._impulse * this._J.AngularA;
                    b2.LinearVelocityInternal = Microsoft.Xna.Framework.Vector2.op_Addition(b2.LinearVelocityInternal.$clone(), Microsoft.Xna.Framework.Vector2.op_Multiply$2(b2.InvMass * this._impulse, this._J.LinearB.$clone()));
                    b2.AngularVelocityInternal += b2.InvI * this._impulse * this._J.AngularB;
                } else {
                    this._impulse = 0.0;
                }
            },
            SolveVelocityConstraints: function (step) {
                var b1 = this.BodyA;
                var b2 = this.BodyB;

                var Cdot = this._J.Compute(b1.LinearVelocityInternal.$clone(), b1.AngularVelocityInternal, b2.LinearVelocityInternal.$clone(), b2.AngularVelocityInternal);

                var impulse = this._mass * (-Cdot);
                this._impulse += impulse;

                b1.LinearVelocityInternal = Microsoft.Xna.Framework.Vector2.op_Addition(b1.LinearVelocityInternal.$clone(), Microsoft.Xna.Framework.Vector2.op_Multiply$2(b1.InvMass * impulse, this._J.LinearA.$clone()));
                b1.AngularVelocityInternal += b1.InvI * impulse * this._J.AngularA;
                b2.LinearVelocityInternal = Microsoft.Xna.Framework.Vector2.op_Addition(b2.LinearVelocityInternal.$clone(), Microsoft.Xna.Framework.Vector2.op_Multiply$2(b2.InvMass * impulse, this._J.LinearB.$clone()));
                b2.AngularVelocityInternal += b2.InvI * impulse * this._J.AngularB;
            },
            SolvePositionConstraints: function () {
                var linearError = 0.0;

                var b1 = this.BodyA;
                var b2 = this.BodyB;

                var coordinate1 = 0.0, coordinate2 = 0.0;
                if (this._revolute1 != null) {
                    coordinate1 = this._revolute1.JointAngle;
                } else if (this._fixedRevolute1 != null) {
                    coordinate1 = this._fixedRevolute1.JointAngle;
                } else if (this._prismatic1 != null) {
                    coordinate1 = this._prismatic1.JointTranslation;
                } else if (this._fixedPrismatic1 != null) {
                    coordinate1 = this._fixedPrismatic1.JointTranslation;
                }

                if (this._revolute2 != null) {
                    coordinate2 = this._revolute2.JointAngle;
                } else if (this._fixedRevolute2 != null) {
                    coordinate2 = this._fixedRevolute2.JointAngle;
                } else if (this._prismatic2 != null) {
                    coordinate2 = this._prismatic2.JointTranslation;
                } else if (this._fixedPrismatic2 != null) {
                    coordinate2 = this._fixedPrismatic2.JointTranslation;
                }

                var C = this._ant - (coordinate1 + this.Ratio * coordinate2);

                var impulse = this._mass * (-C);

                b1.Sweep.C = Microsoft.Xna.Framework.Vector2.op_Addition(b1.Sweep.C.$clone(), Microsoft.Xna.Framework.Vector2.op_Multiply$2(b1.InvMass * impulse, this._J.LinearA.$clone()));
                b1.Sweep.A += b1.InvI * impulse * this._J.AngularA;
                b2.Sweep.C = Microsoft.Xna.Framework.Vector2.op_Addition(b2.Sweep.C.$clone(), Microsoft.Xna.Framework.Vector2.op_Multiply$2(b2.InvMass * impulse, this._J.LinearB.$clone()));
                b2.Sweep.A += b2.InvI * impulse * this._J.AngularB;

                b1.SynchronizeTransform();
                b2.SynchronizeTransform();

                return true;
            }
        }
    });

    Bridge.define("FarseerPhysics.Dynamics.Joints.LineJoint", {
        inherits: [FarseerPhysics.Dynamics.Joints.Joint],
        fields: {
            _ax: null,
            _ay: null,
            _bias: 0,
            _enableMotor: false,
            _gamma: 0,
            _impulse: 0,
            _localXAxis: null,
            _localYAxisA: null,
            _mass: 0,
            _maxMotorTorque: 0,
            _motorImpulse: 0,
            _motorMass: 0,
            _motorSpeed: 0,
            _sAx: 0,
            _sAy: 0,
            _sBx: 0,
            _sBy: 0,
            _springImpulse: 0,
            _springMass: 0,
            LocalAnchorA: null,
            LocalAnchorB: null,
            Frequency: 0,
            DampingRatio: 0
        },
        props: {
            WorldAnchorA: {
                get: function () {
                    return this.BodyA.GetWorldPoint(this.LocalAnchorA.$clone());
                }
            },
            WorldAnchorB: {
                get: function () {
                    return this.BodyB.GetWorldPoint(this.LocalAnchorB.$clone());
                },
                set: function (value) {
                    System.Diagnostics.Debug.Assert$1(false, "You can't set the world anchor on this joint type.");
                }
            },
            JointTranslation: {
                get: function () {
                    var bA = this.BodyA;
                    var bB = this.BodyB;

                    var pA = bA.GetWorldPoint(this.LocalAnchorA.$clone());
                    var pB = bB.GetWorldPoint(this.LocalAnchorB.$clone());
                    var d = Microsoft.Xna.Framework.Vector2.op_Subtraction(pB.$clone(), pA.$clone());
                    var axis = bA.GetWorldVector(this.LocalXAxis.$clone());

                    var translation = Microsoft.Xna.Framework.Vector2.Dot(d.$clone(), axis.$clone());
                    return translation;
                }
            },
            JointSpeed: {
                get: function () {
                    var wA = this.BodyA.AngularVelocityInternal;
                    var wB = this.BodyB.AngularVelocityInternal;
                    return wB - wA;
                }
            },
            MotorEnabled: {
                get: function () {
                    return this._enableMotor;
                },
                set: function (value) {
                    this.BodyA.Awake = true;
                    this.BodyB.Awake = true;
                    this._enableMotor = value;
                }
            },
            MotorSpeed: {
                get: function () {
                    return this._motorSpeed;
                },
                set: function (value) {
                    this.BodyA.Awake = true;
                    this.BodyB.Awake = true;
                    this._motorSpeed = value;
                }
            },
            MaxMotorTorque: {
                get: function () {
                    return this._maxMotorTorque;
                },
                set: function (value) {
                    this.BodyA.Awake = true;
                    this.BodyB.Awake = true;
                    this._maxMotorTorque = value;
                }
            },
            LocalXAxis: {
                get: function () {
                    return this._localXAxis.$clone();
                },
                set: function (value) {
                    this._localXAxis = value.$clone();
                    this._localYAxisA = FarseerPhysics.Common.MathUtils.Cross$1(1.0, this._localXAxis.$clone());
                }
            }
        },
        ctors: {
            init: function () {
                this._ax = new Microsoft.Xna.Framework.Vector2();
                this._ay = new Microsoft.Xna.Framework.Vector2();
                this._localXAxis = new Microsoft.Xna.Framework.Vector2();
                this._localYAxisA = new Microsoft.Xna.Framework.Vector2();
                this.LocalAnchorA = new Microsoft.Xna.Framework.Vector2();
                this.LocalAnchorB = new Microsoft.Xna.Framework.Vector2();
            },
            ctor: function () {
                this.$initialize();
                FarseerPhysics.Dynamics.Joints.Joint.ctor.call(this);
                this.JointType = FarseerPhysics.Dynamics.Joints.JointType.Line;
            },
            $ctor1: function (bA, bB, anchor, axis) {
                this.$initialize();
                FarseerPhysics.Dynamics.Joints.Joint.$ctor2.call(this, bA, bB);
                this.JointType = FarseerPhysics.Dynamics.Joints.JointType.Line;

                this.LocalAnchorA = bA.GetLocalPoint(anchor.$clone());
                this.LocalAnchorB = bB.GetLocalPoint(anchor.$clone());
                this.LocalXAxis = bA.GetLocalVector(axis.$clone());
            }
        },
        methods: {
            GetReactionForce: function (invDt) {
                return Microsoft.Xna.Framework.Vector2.op_Multiply$2(invDt, (Microsoft.Xna.Framework.Vector2.op_Addition(Microsoft.Xna.Framework.Vector2.op_Multiply$2(this._impulse, this._ay.$clone()), Microsoft.Xna.Framework.Vector2.op_Multiply$2(this._springImpulse, this._ax.$clone()))));
            },
            GetReactionTorque: function (invDt) {
                return invDt * this._motorImpulse;
            },
            InitVelocityConstraints: function (step) {
                var bA = this.BodyA;
                var bB = this.BodyB;

                this.LocalCenterA = bA.LocalCenter.$clone();
                this.LocalCenterB = bB.LocalCenter.$clone();

                var xfA = { v : new FarseerPhysics.Common.Transform() };
                bA.GetTransform(xfA);
                var xfB = { v : new FarseerPhysics.Common.Transform() };
                bB.GetTransform(xfB);

                var rA = FarseerPhysics.Common.MathUtils.Multiply(Bridge.ref(xfA.v, "R"), Microsoft.Xna.Framework.Vector2.op_Subtraction(this.LocalAnchorA.$clone(), this.LocalCenterA.$clone()));
                var rB = FarseerPhysics.Common.MathUtils.Multiply(Bridge.ref(xfB.v, "R"), Microsoft.Xna.Framework.Vector2.op_Subtraction(this.LocalAnchorB.$clone(), this.LocalCenterB.$clone()));
                var d = Microsoft.Xna.Framework.Vector2.op_Subtraction(Microsoft.Xna.Framework.Vector2.op_Subtraction(Microsoft.Xna.Framework.Vector2.op_Addition(bB.Sweep.C.$clone(), rB.$clone()), bA.Sweep.C.$clone()), rA.$clone());

                this.InvMassA = bA.InvMass;
                this.InvIA = bA.InvI;
                this.InvMassB = bB.InvMass;
                this.InvIB = bB.InvI;

                {
                    this._ay = FarseerPhysics.Common.MathUtils.Multiply(Bridge.ref(xfA.v, "R"), this._localYAxisA.$clone());
                    this._sAy = FarseerPhysics.Common.MathUtils.Cross$2(Microsoft.Xna.Framework.Vector2.op_Addition(d.$clone(), rA.$clone()), this._ay.$clone());
                    this._sBy = FarseerPhysics.Common.MathUtils.Cross$2(rB.$clone(), this._ay.$clone());

                    this._mass = this.InvMassA + this.InvMassB + this.InvIA * this._sAy * this._sAy + this.InvIB * this._sBy * this._sBy;

                    if (this._mass > 0.0) {
                        this._mass = 1.0 / this._mass;
                    }
                }

                this._springMass = 0.0;
                if (this.Frequency > 0.0) {
                    this._ax = FarseerPhysics.Common.MathUtils.Multiply(Bridge.ref(xfA.v, "R"), this.LocalXAxis.$clone());
                    this._sAx = FarseerPhysics.Common.MathUtils.Cross$2(Microsoft.Xna.Framework.Vector2.op_Addition(d.$clone(), rA.$clone()), this._ax.$clone());
                    this._sBx = FarseerPhysics.Common.MathUtils.Cross$2(rB.$clone(), this._ax.$clone());

                    var invMass = this.InvMassA + this.InvMassB + this.InvIA * this._sAx * this._sAx + this.InvIB * this._sBx * this._sBx;

                    if (invMass > 0.0) {
                        this._springMass = 1.0 / invMass;

                        var C = Microsoft.Xna.Framework.Vector2.Dot(d.$clone(), this._ax.$clone());

                        var omega = 6.28318548 * this.Frequency;

                        var da = 2.0 * this._springMass * this.DampingRatio * omega;

                        var k = this._springMass * omega * omega;

                        this._gamma = step.v.dt * (da + step.v.dt * k);
                        if (this._gamma > 0.0) {
                            this._gamma = 1.0 / this._gamma;
                        }

                        this._bias = C * step.v.dt * k * this._gamma;

                        this._springMass = invMass + this._gamma;
                        if (this._springMass > 0.0) {
                            this._springMass = 1.0 / this._springMass;
                        }
                    }
                } else {
                    this._springImpulse = 0.0;
                    this._springMass = 0.0;
                }

                if (this._enableMotor) {
                    this._motorMass = this.InvIA + this.InvIB;
                    if (this._motorMass > 0.0) {
                        this._motorMass = 1.0 / this._motorMass;
                    }
                } else {
                    this._motorMass = 0.0;
                    this._motorImpulse = 0.0;
                }

                if (FarseerPhysics.Settings.EnableWarmstarting) {
                    this._impulse *= step.v.dtRatio;
                    this._springImpulse *= step.v.dtRatio;
                    this._motorImpulse *= step.v.dtRatio;

                    var P = Microsoft.Xna.Framework.Vector2.op_Addition(Microsoft.Xna.Framework.Vector2.op_Multiply$2(this._impulse, this._ay.$clone()), Microsoft.Xna.Framework.Vector2.op_Multiply$2(this._springImpulse, this._ax.$clone()));
                    var LA = this._impulse * this._sAy + this._springImpulse * this._sAx + this._motorImpulse;
                    var LB = this._impulse * this._sBy + this._springImpulse * this._sBx + this._motorImpulse;

                    bA.LinearVelocityInternal = Microsoft.Xna.Framework.Vector2.op_Subtraction(bA.LinearVelocityInternal.$clone(), Microsoft.Xna.Framework.Vector2.op_Multiply$2(this.InvMassA, P.$clone()));
                    bA.AngularVelocityInternal -= this.InvIA * LA;

                    bB.LinearVelocityInternal = Microsoft.Xna.Framework.Vector2.op_Addition(bB.LinearVelocityInternal.$clone(), Microsoft.Xna.Framework.Vector2.op_Multiply$2(this.InvMassB, P.$clone()));
                    bB.AngularVelocityInternal += this.InvIB * LB;
                } else {
                    this._impulse = 0.0;
                    this._springImpulse = 0.0;
                    this._motorImpulse = 0.0;
                }
            },
            SolveVelocityConstraints: function (step) {
                var bA = this.BodyA;
                var bB = this.BodyB;

                var vA = bA.LinearVelocity.$clone();
                var wA = bA.AngularVelocityInternal;
                var vB = bB.LinearVelocityInternal.$clone();
                var wB = bB.AngularVelocityInternal;

                {
                    var Cdot = Microsoft.Xna.Framework.Vector2.Dot(this._ax.$clone(), Microsoft.Xna.Framework.Vector2.op_Subtraction(vB.$clone(), vA.$clone())) + this._sBx * wB - this._sAx * wA;
                    var impulse = -this._springMass * (Cdot + this._bias + this._gamma * this._springImpulse);
                    this._springImpulse += impulse;

                    var P = Microsoft.Xna.Framework.Vector2.op_Multiply$2(impulse, this._ax.$clone());
                    var LA = impulse * this._sAx;
                    var LB = impulse * this._sBx;

                    vA = Microsoft.Xna.Framework.Vector2.op_Subtraction(vA.$clone(), Microsoft.Xna.Framework.Vector2.op_Multiply$2(this.InvMassA, P.$clone()));
                    wA -= this.InvIA * LA;

                    vB = Microsoft.Xna.Framework.Vector2.op_Addition(vB.$clone(), Microsoft.Xna.Framework.Vector2.op_Multiply$2(this.InvMassB, P.$clone()));
                    wB += this.InvIB * LB;
                }

                {
                    var Cdot1 = wB - wA - this._motorSpeed;
                    var impulse1 = -this._motorMass * Cdot1;

                    var oldImpulse = this._motorImpulse;
                    var maxImpulse = step.v.dt * this._maxMotorTorque;
                    this._motorImpulse = FarseerPhysics.Common.MathUtils.Clamp$2(this._motorImpulse + impulse1, -maxImpulse, maxImpulse);
                    impulse1 = this._motorImpulse - oldImpulse;

                    wA -= this.InvIA * impulse1;
                    wB += this.InvIB * impulse1;
                }

                {
                    var Cdot2 = Microsoft.Xna.Framework.Vector2.Dot(this._ay.$clone(), Microsoft.Xna.Framework.Vector2.op_Subtraction(vB.$clone(), vA.$clone())) + this._sBy * wB - this._sAy * wA;
                    var impulse2 = this._mass * (-Cdot2);
                    this._impulse += impulse2;

                    var P1 = Microsoft.Xna.Framework.Vector2.op_Multiply$2(impulse2, this._ay.$clone());
                    var LA1 = impulse2 * this._sAy;
                    var LB1 = impulse2 * this._sBy;

                    vA = Microsoft.Xna.Framework.Vector2.op_Subtraction(vA.$clone(), Microsoft.Xna.Framework.Vector2.op_Multiply$2(this.InvMassA, P1.$clone()));
                    wA -= this.InvIA * LA1;

                    vB = Microsoft.Xna.Framework.Vector2.op_Addition(vB.$clone(), Microsoft.Xna.Framework.Vector2.op_Multiply$2(this.InvMassB, P1.$clone()));
                    wB += this.InvIB * LB1;
                }

                bA.LinearVelocityInternal = vA.$clone();
                bA.AngularVelocityInternal = wA;
                bB.LinearVelocityInternal = vB.$clone();
                bB.AngularVelocityInternal = wB;
            },
            SolvePositionConstraints: function () {
                var bA = this.BodyA;
                var bB = this.BodyB;

                var xA = bA.Sweep.C.$clone();
                var angleA = bA.Sweep.A;

                var xB = bB.Sweep.C.$clone();
                var angleB = bB.Sweep.A;

                var RA = { v : new FarseerPhysics.Common.Mat22.$ctor2(angleA) };
                var RB = { v : new FarseerPhysics.Common.Mat22.$ctor2(angleB) };

                var rA = FarseerPhysics.Common.MathUtils.Multiply(RA, Microsoft.Xna.Framework.Vector2.op_Subtraction(this.LocalAnchorA.$clone(), this.LocalCenterA.$clone()));
                var rB = FarseerPhysics.Common.MathUtils.Multiply(RB, Microsoft.Xna.Framework.Vector2.op_Subtraction(this.LocalAnchorB.$clone(), this.LocalCenterB.$clone()));
                var d = Microsoft.Xna.Framework.Vector2.op_Subtraction(Microsoft.Xna.Framework.Vector2.op_Subtraction(Microsoft.Xna.Framework.Vector2.op_Addition(xB.$clone(), rB.$clone()), xA.$clone()), rA.$clone());

                var ay = FarseerPhysics.Common.MathUtils.Multiply(RA, this._localYAxisA.$clone());

                var sAy = FarseerPhysics.Common.MathUtils.Cross$2(Microsoft.Xna.Framework.Vector2.op_Addition(d.$clone(), rA.$clone()), ay.$clone());
                var sBy = FarseerPhysics.Common.MathUtils.Cross$2(rB.$clone(), ay.$clone());

                var C = Microsoft.Xna.Framework.Vector2.Dot(d.$clone(), ay.$clone());

                var k = this.InvMassA + this.InvMassB + this.InvIA * this._sAy * this._sAy + this.InvIB * this._sBy * this._sBy;

                var impulse;
                if (k !== 0.0) {
                    impulse = -C / k;
                } else {
                    impulse = 0.0;
                }

                var P = Microsoft.Xna.Framework.Vector2.op_Multiply$2(impulse, ay.$clone());
                var LA = impulse * sAy;
                var LB = impulse * sBy;

                xA = Microsoft.Xna.Framework.Vector2.op_Subtraction(xA.$clone(), Microsoft.Xna.Framework.Vector2.op_Multiply$2(this.InvMassA, P.$clone()));
                angleA -= this.InvIA * LA;
                xB = Microsoft.Xna.Framework.Vector2.op_Addition(xB.$clone(), Microsoft.Xna.Framework.Vector2.op_Multiply$2(this.InvMassB, P.$clone()));
                angleB += this.InvIB * LB;

                bA.Sweep.C = xA.$clone();
                bA.Sweep.A = angleA;
                bB.Sweep.C = xB.$clone();
                bB.Sweep.A = angleB;
                bA.SynchronizeTransform();
                bB.SynchronizeTransform();

                return Math.abs(C) <= FarseerPhysics.Settings.LinearSlop;
            },
            GetMotorTorque: function (invDt) {
                return invDt * this._motorImpulse;
            }
        }
    });

    /**
     * A prismatic joint. This joint provides one degree of freedom: translation
     along an axis fixed in body1. Relative rotation is prevented. You can
     use a joint limit to restrict the range of motion and a joint motor to
     drive the motion or to model joint friction.
     *
     * @public
     * @class FarseerPhysics.Dynamics.Joints.PrismaticJoint
     * @augments FarseerPhysics.Dynamics.Joints.Joint
     */
    Bridge.define("FarseerPhysics.Dynamics.Joints.PrismaticJoint", {
        inherits: [FarseerPhysics.Dynamics.Joints.Joint],
        fields: {
            LocalAnchorA: null,
            LocalAnchorB: null,
            _K: null,
            _a1: 0,
            _a2: 0,
            _axis: null,
            _enableLimit: false,
            _enableMotor: false,
            _impulse: null,
            _limitState: 0,
            _localXAxis1: null,
            _localYAxis1: null,
            _lowerTranslation: 0,
            _maxMotorForce: 0,
            _motorImpulse: 0,
            _motorMass: 0,
            _motorSpeed: 0,
            _perp: null,
            _refAngle: 0,
            _s1: 0,
            _s2: 0,
            _upperTranslation: 0
        },
        props: {
            WorldAnchorA: {
                get: function () {
                    return this.BodyA.GetWorldPoint(this.LocalAnchorA.$clone());
                }
            },
            WorldAnchorB: {
                get: function () {
                    return this.BodyB.GetWorldPoint(this.LocalAnchorB.$clone());
                },
                set: function (value) {
                    System.Diagnostics.Debug.Assert$1(false, "You can't set the world anchor on this joint type.");
                }
            },
            /**
             * Get the current joint translation, usually in meters.
             *
             * @instance
             * @public
             * @readonly
             * @memberof FarseerPhysics.Dynamics.Joints.PrismaticJoint
             * @function JointTranslation
             * @type number
             */
            JointTranslation: {
                get: function () {
                    var d = Microsoft.Xna.Framework.Vector2.op_Subtraction(this.BodyB.GetWorldPoint(this.LocalAnchorB.$clone()), this.BodyA.GetWorldPoint(this.LocalAnchorA.$clone()));
                    var axis = this.BodyA.GetWorldVector$1(Bridge.ref(this, "_localXAxis1"));

                    return Microsoft.Xna.Framework.Vector2.Dot(d.$clone(), axis.$clone());
                }
            },
            /**
             * Get the current joint translation speed, usually in meters per second.
             *
             * @instance
             * @public
             * @readonly
             * @memberof FarseerPhysics.Dynamics.Joints.PrismaticJoint
             * @function JointSpeed
             * @type number
             */
            JointSpeed: {
                get: function () {
                    var xf1 = { v : new FarseerPhysics.Common.Transform() }, xf2 = { v : new FarseerPhysics.Common.Transform() };
                    this.BodyA.GetTransform(xf1);
                    this.BodyB.GetTransform(xf2);

                    var r1 = FarseerPhysics.Common.MathUtils.Multiply(Bridge.ref(xf1.v, "R"), Microsoft.Xna.Framework.Vector2.op_Subtraction(this.LocalAnchorA.$clone(), this.BodyA.LocalCenter.$clone()));
                    var r2 = FarseerPhysics.Common.MathUtils.Multiply(Bridge.ref(xf2.v, "R"), Microsoft.Xna.Framework.Vector2.op_Subtraction(this.LocalAnchorB.$clone(), this.BodyB.LocalCenter.$clone()));
                    var p1 = Microsoft.Xna.Framework.Vector2.op_Addition(this.BodyA.Sweep.C.$clone(), r1.$clone());
                    var p2 = Microsoft.Xna.Framework.Vector2.op_Addition(this.BodyB.Sweep.C.$clone(), r2.$clone());
                    var d = Microsoft.Xna.Framework.Vector2.op_Subtraction(p2.$clone(), p1.$clone());
                    var axis = this.BodyA.GetWorldVector$1(Bridge.ref(this, "_localXAxis1"));

                    var v1 = this.BodyA.LinearVelocityInternal.$clone();
                    var v2 = this.BodyB.LinearVelocityInternal.$clone();
                    var w1 = this.BodyA.AngularVelocityInternal;
                    var w2 = this.BodyB.AngularVelocityInternal;

                    var speed = Microsoft.Xna.Framework.Vector2.Dot(d.$clone(), FarseerPhysics.Common.MathUtils.Cross$1(w1, axis.$clone())) + Microsoft.Xna.Framework.Vector2.Dot(axis.$clone(), Microsoft.Xna.Framework.Vector2.op_Subtraction(Microsoft.Xna.Framework.Vector2.op_Subtraction(Microsoft.Xna.Framework.Vector2.op_Addition(v2.$clone(), FarseerPhysics.Common.MathUtils.Cross$1(w2, r2.$clone())), v1.$clone()), FarseerPhysics.Common.MathUtils.Cross$1(w1, r1.$clone())));
                    return speed;
                }
            },
            /**
             * Is the joint limit enabled?
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Dynamics.Joints.PrismaticJoint
             * @function LimitEnabled
             * @type boolean
             */
            LimitEnabled: {
                get: function () {
                    return this._enableLimit;
                },
                set: function (value) {
                    System.Diagnostics.Debug.Assert$1(this.BodyA.FixedRotation === false || this.BodyB.FixedRotation === false, "Warning: limits does currently not work with fixed rotation");

                    this.WakeBodies();
                    this._enableLimit = value;
                }
            },
            /**
             * Get the lower joint limit, usually in meters.
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Dynamics.Joints.PrismaticJoint
             * @function LowerLimit
             * @type number
             */
            LowerLimit: {
                get: function () {
                    return this._lowerTranslation;
                },
                set: function (value) {
                    this.WakeBodies();
                    this._lowerTranslation = value;
                }
            },
            /**
             * Get the upper joint limit, usually in meters.
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Dynamics.Joints.PrismaticJoint
             * @function UpperLimit
             * @type number
             */
            UpperLimit: {
                get: function () {
                    return this._upperTranslation;
                },
                set: function (value) {
                    this.WakeBodies();
                    this._upperTranslation = value;
                }
            },
            /**
             * Is the joint motor enabled?
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Dynamics.Joints.PrismaticJoint
             * @function MotorEnabled
             * @type boolean
             */
            MotorEnabled: {
                get: function () {
                    return this._enableMotor;
                },
                set: function (value) {
                    this.WakeBodies();
                    this._enableMotor = value;
                }
            },
            /**
             * Set the motor speed, usually in meters per second.
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Dynamics.Joints.PrismaticJoint
             * @function MotorSpeed
             * @type number
             */
            MotorSpeed: {
                get: function () {
                    return this._motorSpeed;
                },
                set: function (value) {
                    this.WakeBodies();
                    this._motorSpeed = value;
                }
            },
            /**
             * Set the maximum motor force, usually in N.
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Dynamics.Joints.PrismaticJoint
             * @function MaxMotorForce
             * @type number
             */
            MaxMotorForce: {
                get: function () {
                    return this._maxMotorForce;
                },
                set: function (value) {
                    this.WakeBodies();
                    this._maxMotorForce = value;
                }
            },
            /**
             * Get the current motor force, usually in N.
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Dynamics.Joints.PrismaticJoint
             * @function MotorForce
             * @type number
             */
            MotorForce: {
                get: function () {
                    return this._motorImpulse;
                },
                set: function (value) {
                    this._motorImpulse = value;
                }
            },
            LocalXAxis1: {
                get: function () {
                    return this._localXAxis1.$clone();
                },
                set: function (value) {
                    this._localXAxis1 = this.BodyA.GetLocalVector(value.$clone());
                    this._localYAxis1 = FarseerPhysics.Common.MathUtils.Cross$1(1.0, this._localXAxis1.$clone());
                }
            },
            ReferenceAngle: {
                get: function () {
                    return this._refAngle;
                },
                set: function (value) {
                    this._refAngle = value;
                }
            }
        },
        ctors: {
            init: function () {
                this.LocalAnchorA = new Microsoft.Xna.Framework.Vector2();
                this.LocalAnchorB = new Microsoft.Xna.Framework.Vector2();
                this._K = new FarseerPhysics.Common.Mat33();
                this._axis = new Microsoft.Xna.Framework.Vector2();
                this._impulse = new Microsoft.Xna.Framework.Vector3();
                this._localXAxis1 = new Microsoft.Xna.Framework.Vector2();
                this._localYAxis1 = new Microsoft.Xna.Framework.Vector2();
                this._perp = new Microsoft.Xna.Framework.Vector2();
            },
            ctor: function () {
                this.$initialize();
                FarseerPhysics.Dynamics.Joints.Joint.ctor.call(this);
                this.JointType = FarseerPhysics.Dynamics.Joints.JointType.Prismatic;
            },
            /**
             * This requires defining a line of
             motion using an axis and an anchor point. The definition uses local
             anchor points and a local axis so that the initial configuration
             can violate the constraint slightly. The joint translation is zero
             when the local anchor points coincide in world space. Using local
             anchors and a local axis helps when saving and loading a game.
             *
             * @instance
             * @public
             * @this FarseerPhysics.Dynamics.Joints.PrismaticJoint
             * @memberof FarseerPhysics.Dynamics.Joints.PrismaticJoint
             * @param   {FarseerPhysics.Dynamics.Body}       bodyA           The first body.
             * @param   {FarseerPhysics.Dynamics.Body}       bodyB           The second body.
             * @param   {Microsoft.Xna.Framework.Vector2}    localAnchorA    The first body anchor.
             * @param   {Microsoft.Xna.Framework.Vector2}    localAnchorB    The second body anchor.
             * @param   {Microsoft.Xna.Framework.Vector2}    axis            The axis.
             * @return  {void}
             */
            $ctor1: function (bodyA, bodyB, localAnchorA, localAnchorB, axis) {
                this.$initialize();
                FarseerPhysics.Dynamics.Joints.Joint.$ctor2.call(this, bodyA, bodyB);
                this.JointType = FarseerPhysics.Dynamics.Joints.JointType.Prismatic;

                this.LocalAnchorA = localAnchorA.$clone();
                this.LocalAnchorB = localAnchorB.$clone();

                this._localXAxis1 = this.BodyA.GetLocalVector(axis.$clone());
                this._localYAxis1 = FarseerPhysics.Common.MathUtils.Cross$1(1.0, this._localXAxis1.$clone());
                this._refAngle = this.BodyB.Rotation - this.BodyA.Rotation;

                this._limitState = FarseerPhysics.Dynamics.Joints.LimitState.Inactive;
            }
        },
        methods: {
            GetReactionForce: function (inv_dt) {
                return Microsoft.Xna.Framework.Vector2.op_Multiply$2(inv_dt, (Microsoft.Xna.Framework.Vector2.op_Addition(Microsoft.Xna.Framework.Vector2.op_Multiply$2(this._impulse.X, this._perp.$clone()), Microsoft.Xna.Framework.Vector2.op_Multiply$2((this._motorImpulse + this._impulse.Z), this._axis.$clone()))));
            },
            GetReactionTorque: function (inv_dt) {
                return inv_dt * this._impulse.Y;
            },
            InitVelocityConstraints: function (step) {
                var b1 = this.BodyA;
                var b2 = this.BodyB;

                this.LocalCenterA = b1.LocalCenter.$clone();
                this.LocalCenterB = b2.LocalCenter.$clone();

                var xf1 = { v : new FarseerPhysics.Common.Transform() }, xf2 = { v : new FarseerPhysics.Common.Transform() };
                b1.GetTransform(xf1);
                b2.GetTransform(xf2);

                var r1 = FarseerPhysics.Common.MathUtils.Multiply(Bridge.ref(xf1.v, "R"), Microsoft.Xna.Framework.Vector2.op_Subtraction(this.LocalAnchorA.$clone(), this.LocalCenterA.$clone()));
                var r2 = FarseerPhysics.Common.MathUtils.Multiply(Bridge.ref(xf2.v, "R"), Microsoft.Xna.Framework.Vector2.op_Subtraction(this.LocalAnchorB.$clone(), this.LocalCenterB.$clone()));
                var d = Microsoft.Xna.Framework.Vector2.op_Subtraction(Microsoft.Xna.Framework.Vector2.op_Subtraction(Microsoft.Xna.Framework.Vector2.op_Addition(b2.Sweep.C.$clone(), r2.$clone()), b1.Sweep.C.$clone()), r1.$clone());

                this.InvMassA = b1.InvMass;
                this.InvIA = b1.InvI;
                this.InvMassB = b2.InvMass;
                this.InvIB = b2.InvI;

                {
                    this._axis = FarseerPhysics.Common.MathUtils.Multiply(Bridge.ref(xf1.v, "R"), this._localXAxis1.$clone());
                    this._a1 = FarseerPhysics.Common.MathUtils.Cross$2(Microsoft.Xna.Framework.Vector2.op_Addition(d.$clone(), r1.$clone()), this._axis.$clone());
                    this._a2 = FarseerPhysics.Common.MathUtils.Cross$2(r2.$clone(), this._axis.$clone());

                    this._motorMass = this.InvMassA + this.InvMassB + this.InvIA * this._a1 * this._a1 + this.InvIB * this._a2 * this._a2;

                    if (this._motorMass > FarseerPhysics.Settings.Epsilon) {
                        this._motorMass = 1.0 / this._motorMass;
                    }
                }

                {
                    this._perp = FarseerPhysics.Common.MathUtils.Multiply(Bridge.ref(xf1.v, "R"), this._localYAxis1.$clone());

                    this._s1 = FarseerPhysics.Common.MathUtils.Cross$2(Microsoft.Xna.Framework.Vector2.op_Addition(d.$clone(), r1.$clone()), this._perp.$clone());
                    this._s2 = FarseerPhysics.Common.MathUtils.Cross$2(r2.$clone(), this._perp.$clone());

                    var m1 = this.InvMassA, m2 = this.InvMassB;
                    var i1 = this.InvIA, i2 = this.InvIB;

                    var k11 = m1 + m2 + i1 * this._s1 * this._s1 + i2 * this._s2 * this._s2;
                    var k12 = i1 * this._s1 + i2 * this._s2;
                    var k13 = i1 * this._s1 * this._a1 + i2 * this._s2 * this._a2;
                    var k22 = i1 + i2;
                    var k23 = i1 * this._a1 + i2 * this._a2;
                    var k33 = m1 + m2 + i1 * this._a1 * this._a1 + i2 * this._a2 * this._a2;

                    this._K.Col1 = new Microsoft.Xna.Framework.Vector3.$ctor3(k11, k12, k13);
                    this._K.Col2 = new Microsoft.Xna.Framework.Vector3.$ctor3(k12, k22, k23);
                    this._K.Col3 = new Microsoft.Xna.Framework.Vector3.$ctor3(k13, k23, k33);
                }

                if (this._enableLimit) {
                    var jointTranslation = Microsoft.Xna.Framework.Vector2.Dot(this._axis.$clone(), d.$clone());
                    if (Math.abs(this._upperTranslation - this._lowerTranslation) < 0.01) {
                        this._limitState = FarseerPhysics.Dynamics.Joints.LimitState.Equal;
                    } else if (jointTranslation <= this._lowerTranslation) {
                        if (this._limitState !== FarseerPhysics.Dynamics.Joints.LimitState.AtLower) {
                            this._limitState = FarseerPhysics.Dynamics.Joints.LimitState.AtLower;
                            this._impulse.Z = 0.0;
                        }
                    } else if (jointTranslation >= this._upperTranslation) {
                        if (this._limitState !== FarseerPhysics.Dynamics.Joints.LimitState.AtUpper) {
                            this._limitState = FarseerPhysics.Dynamics.Joints.LimitState.AtUpper;
                            this._impulse.Z = 0.0;
                        }
                    } else {
                        this._limitState = FarseerPhysics.Dynamics.Joints.LimitState.Inactive;
                        this._impulse.Z = 0.0;
                    }
                } else {
                    this._limitState = FarseerPhysics.Dynamics.Joints.LimitState.Inactive;
                }

                if (this._enableMotor === false) {
                    this._motorImpulse = 0.0;
                }

                if (FarseerPhysics.Settings.EnableWarmstarting) {
                    this._impulse = Microsoft.Xna.Framework.Vector3.op_Multiply$1(this._impulse.$clone(), step.v.dtRatio);
                    this._motorImpulse *= step.v.dtRatio;

                    var P = Microsoft.Xna.Framework.Vector2.op_Addition(Microsoft.Xna.Framework.Vector2.op_Multiply$2(this._impulse.X, this._perp.$clone()), Microsoft.Xna.Framework.Vector2.op_Multiply$2((this._motorImpulse + this._impulse.Z), this._axis.$clone()));
                    var L1 = this._impulse.X * this._s1 + this._impulse.Y + (this._motorImpulse + this._impulse.Z) * this._a1;
                    var L2 = this._impulse.X * this._s2 + this._impulse.Y + (this._motorImpulse + this._impulse.Z) * this._a2;

                    b1.LinearVelocityInternal = Microsoft.Xna.Framework.Vector2.op_Subtraction(b1.LinearVelocityInternal.$clone(), Microsoft.Xna.Framework.Vector2.op_Multiply$2(this.InvMassA, P.$clone()));
                    b1.AngularVelocityInternal -= this.InvIA * L1;

                    b2.LinearVelocityInternal = Microsoft.Xna.Framework.Vector2.op_Addition(b2.LinearVelocityInternal.$clone(), Microsoft.Xna.Framework.Vector2.op_Multiply$2(this.InvMassB, P.$clone()));
                    b2.AngularVelocityInternal += this.InvIB * L2;
                } else {
                    this._impulse = Microsoft.Xna.Framework.Vector3.Zero.$clone();
                    this._motorImpulse = 0.0;
                }
            },
            SolveVelocityConstraints: function (step) {
                var b1 = this.BodyA;
                var b2 = this.BodyB;

                var v1 = b1.LinearVelocityInternal.$clone();
                var w1 = b1.AngularVelocityInternal;
                var v2 = b2.LinearVelocityInternal.$clone();
                var w2 = b2.AngularVelocityInternal;

                if (this._enableMotor && this._limitState !== FarseerPhysics.Dynamics.Joints.LimitState.Equal) {
                    var Cdot = Microsoft.Xna.Framework.Vector2.Dot(this._axis.$clone(), Microsoft.Xna.Framework.Vector2.op_Subtraction(v2.$clone(), v1.$clone())) + this._a2 * w2 - this._a1 * w1;
                    var impulse = this._motorMass * (this._motorSpeed - Cdot);
                    var oldImpulse = this._motorImpulse;
                    var maxImpulse = step.v.dt * this._maxMotorForce;
                    this._motorImpulse = FarseerPhysics.Common.MathUtils.Clamp$2(this._motorImpulse + impulse, -maxImpulse, maxImpulse);
                    impulse = this._motorImpulse - oldImpulse;

                    var P = Microsoft.Xna.Framework.Vector2.op_Multiply$2(impulse, this._axis.$clone());
                    var L1 = impulse * this._a1;
                    var L2 = impulse * this._a2;

                    v1 = Microsoft.Xna.Framework.Vector2.op_Subtraction(v1.$clone(), Microsoft.Xna.Framework.Vector2.op_Multiply$2(this.InvMassA, P.$clone()));
                    w1 -= this.InvIA * L1;

                    v2 = Microsoft.Xna.Framework.Vector2.op_Addition(v2.$clone(), Microsoft.Xna.Framework.Vector2.op_Multiply$2(this.InvMassB, P.$clone()));
                    w2 += this.InvIB * L2;
                }

                var Cdot1 = new Microsoft.Xna.Framework.Vector2.$ctor2(Microsoft.Xna.Framework.Vector2.Dot(this._perp.$clone(), Microsoft.Xna.Framework.Vector2.op_Subtraction(v2.$clone(), v1.$clone())) + this._s2 * w2 - this._s1 * w1, w2 - w1);

                if (this._enableLimit && this._limitState !== FarseerPhysics.Dynamics.Joints.LimitState.Inactive) {
                    var Cdot2 = Microsoft.Xna.Framework.Vector2.Dot(this._axis.$clone(), Microsoft.Xna.Framework.Vector2.op_Subtraction(v2.$clone(), v1.$clone())) + this._a2 * w2 - this._a1 * w1;
                    var Cdot3 = new Microsoft.Xna.Framework.Vector3.$ctor3(Cdot1.X, Cdot1.Y, Cdot2);

                    var f1 = this._impulse.$clone();
                    var df = this._K.Solve33(Microsoft.Xna.Framework.Vector3.op_UnaryNegation(Cdot3.$clone()));
                    this._impulse = Microsoft.Xna.Framework.Vector3.op_Addition(this._impulse.$clone(), df.$clone());

                    if (this._limitState === FarseerPhysics.Dynamics.Joints.LimitState.AtLower) {
                        this._impulse.Z = Math.max(this._impulse.Z, 0.0);
                    } else if (this._limitState === FarseerPhysics.Dynamics.Joints.LimitState.AtUpper) {
                        this._impulse.Z = Math.min(this._impulse.Z, 0.0);
                    }

                    var b = Microsoft.Xna.Framework.Vector2.op_Subtraction(Microsoft.Xna.Framework.Vector2.op_UnaryNegation(Cdot1.$clone()), Microsoft.Xna.Framework.Vector2.op_Multiply$2((this._impulse.Z - f1.Z), new Microsoft.Xna.Framework.Vector2.$ctor2(this._K.Col3.X, this._K.Col3.Y)));
                    var f2r = Microsoft.Xna.Framework.Vector2.op_Addition(this._K.Solve22(b.$clone()), new Microsoft.Xna.Framework.Vector2.$ctor2(f1.X, f1.Y));
                    this._impulse.X = f2r.X;
                    this._impulse.Y = f2r.Y;

                    df = Microsoft.Xna.Framework.Vector3.op_Subtraction(this._impulse.$clone(), f1.$clone());

                    var P1 = Microsoft.Xna.Framework.Vector2.op_Addition(Microsoft.Xna.Framework.Vector2.op_Multiply$2(df.X, this._perp.$clone()), Microsoft.Xna.Framework.Vector2.op_Multiply$2(df.Z, this._axis.$clone()));
                    var L11 = df.X * this._s1 + df.Y + df.Z * this._a1;
                    var L21 = df.X * this._s2 + df.Y + df.Z * this._a2;

                    v1 = Microsoft.Xna.Framework.Vector2.op_Subtraction(v1.$clone(), Microsoft.Xna.Framework.Vector2.op_Multiply$2(this.InvMassA, P1.$clone()));
                    w1 -= this.InvIA * L11;

                    v2 = Microsoft.Xna.Framework.Vector2.op_Addition(v2.$clone(), Microsoft.Xna.Framework.Vector2.op_Multiply$2(this.InvMassB, P1.$clone()));
                    w2 += this.InvIB * L21;
                } else {
                    var df1 = this._K.Solve22(Microsoft.Xna.Framework.Vector2.op_UnaryNegation(Cdot1.$clone()));
                    this._impulse.X += df1.X;
                    this._impulse.Y += df1.Y;

                    var P2 = Microsoft.Xna.Framework.Vector2.op_Multiply$2(df1.X, this._perp.$clone());
                    var L12 = df1.X * this._s1 + df1.Y;
                    var L22 = df1.X * this._s2 + df1.Y;

                    v1 = Microsoft.Xna.Framework.Vector2.op_Subtraction(v1.$clone(), Microsoft.Xna.Framework.Vector2.op_Multiply$2(this.InvMassA, P2.$clone()));
                    w1 -= this.InvIA * L12;

                    v2 = Microsoft.Xna.Framework.Vector2.op_Addition(v2.$clone(), Microsoft.Xna.Framework.Vector2.op_Multiply$2(this.InvMassB, P2.$clone()));
                    w2 += this.InvIB * L22;
                }

                b1.LinearVelocityInternal = v1.$clone();
                b1.AngularVelocityInternal = w1;
                b2.LinearVelocityInternal = v2.$clone();
                b2.AngularVelocityInternal = w2;
            },
            SolvePositionConstraints: function () {
                var b1 = this.BodyA;
                var b2 = this.BodyB;

                var c1 = b1.Sweep.C.$clone();
                var a1 = b1.Sweep.A;

                var c2 = b2.Sweep.C.$clone();
                var a2 = b2.Sweep.A;

                var linearError = 0.0;
                var active = false;
                var C2 = 0.0;

                var R1 = { v : new FarseerPhysics.Common.Mat22.$ctor2(a1) };
                var R2 = { v : new FarseerPhysics.Common.Mat22.$ctor2(a2) };

                var r1 = FarseerPhysics.Common.MathUtils.Multiply(R1, Microsoft.Xna.Framework.Vector2.op_Subtraction(this.LocalAnchorA.$clone(), this.LocalCenterA.$clone()));
                var r2 = FarseerPhysics.Common.MathUtils.Multiply(R2, Microsoft.Xna.Framework.Vector2.op_Subtraction(this.LocalAnchorB.$clone(), this.LocalCenterB.$clone()));
                var d = Microsoft.Xna.Framework.Vector2.op_Subtraction(Microsoft.Xna.Framework.Vector2.op_Subtraction(Microsoft.Xna.Framework.Vector2.op_Addition(c2.$clone(), r2.$clone()), c1.$clone()), r1.$clone());

                if (this._enableLimit) {
                    this._axis = FarseerPhysics.Common.MathUtils.Multiply(R1, this._localXAxis1.$clone());

                    this._a1 = FarseerPhysics.Common.MathUtils.Cross$2(Microsoft.Xna.Framework.Vector2.op_Addition(d.$clone(), r1.$clone()), this._axis.$clone());
                    this._a2 = FarseerPhysics.Common.MathUtils.Cross$2(r2.$clone(), this._axis.$clone());

                    var translation = Microsoft.Xna.Framework.Vector2.Dot(this._axis.$clone(), d.$clone());
                    if (Math.abs(this._upperTranslation - this._lowerTranslation) < 0.01) {
                        C2 = FarseerPhysics.Common.MathUtils.Clamp$2(translation, -0.2, FarseerPhysics.Settings.MaxLinearCorrection);
                        linearError = Math.abs(translation);
                        active = true;
                    } else if (translation <= this._lowerTranslation) {
                        C2 = FarseerPhysics.Common.MathUtils.Clamp$2(translation - this._lowerTranslation + FarseerPhysics.Settings.LinearSlop, -0.2, 0.0);
                        linearError = this._lowerTranslation - translation;
                        active = true;
                    } else if (translation >= this._upperTranslation) {
                        C2 = FarseerPhysics.Common.MathUtils.Clamp$2(translation - this._upperTranslation - FarseerPhysics.Settings.LinearSlop, 0.0, FarseerPhysics.Settings.MaxLinearCorrection);
                        linearError = translation - this._upperTranslation;
                        active = true;
                    }
                }

                this._perp = FarseerPhysics.Common.MathUtils.Multiply(R1, this._localYAxis1.$clone());

                this._s1 = FarseerPhysics.Common.MathUtils.Cross$2(Microsoft.Xna.Framework.Vector2.op_Addition(d.$clone(), r1.$clone()), this._perp.$clone());
                this._s2 = FarseerPhysics.Common.MathUtils.Cross$2(r2.$clone(), this._perp.$clone());

                var impulse = new Microsoft.Xna.Framework.Vector3();
                var C1 = new Microsoft.Xna.Framework.Vector2.$ctor2(Microsoft.Xna.Framework.Vector2.Dot(this._perp.$clone(), d.$clone()), a2 - a1 - this.ReferenceAngle);

                linearError = Math.max(linearError, Math.abs(C1.X));
                var angularError = Math.abs(C1.Y);

                if (active) {
                    var m1 = this.InvMassA, m2 = this.InvMassB;
                    var i1 = this.InvIA, i2 = this.InvIB;

                    var k11 = m1 + m2 + i1 * this._s1 * this._s1 + i2 * this._s2 * this._s2;
                    var k12 = i1 * this._s1 + i2 * this._s2;
                    var k13 = i1 * this._s1 * this._a1 + i2 * this._s2 * this._a2;
                    var k22 = i1 + i2;
                    var k23 = i1 * this._a1 + i2 * this._a2;
                    var k33 = m1 + m2 + i1 * this._a1 * this._a1 + i2 * this._a2 * this._a2;

                    this._K.Col1 = new Microsoft.Xna.Framework.Vector3.$ctor3(k11, k12, k13);
                    this._K.Col2 = new Microsoft.Xna.Framework.Vector3.$ctor3(k12, k22, k23);
                    this._K.Col3 = new Microsoft.Xna.Framework.Vector3.$ctor3(k13, k23, k33);

                    var C = new Microsoft.Xna.Framework.Vector3.$ctor3(-C1.X, -C1.Y, -C2);
                    impulse = this._K.Solve33(C.$clone());
                } else {
                    var m11 = this.InvMassA, m21 = this.InvMassB;
                    var i11 = this.InvIA, i21 = this.InvIB;

                    var k111 = m11 + m21 + i11 * this._s1 * this._s1 + i21 * this._s2 * this._s2;
                    var k121 = i11 * this._s1 + i21 * this._s2;
                    var k221 = i11 + i21;

                    this._K.Col1 = new Microsoft.Xna.Framework.Vector3.$ctor3(k111, k121, 0.0);
                    this._K.Col2 = new Microsoft.Xna.Framework.Vector3.$ctor3(k121, k221, 0.0);

                    var impulse1 = this._K.Solve22(Microsoft.Xna.Framework.Vector2.op_UnaryNegation(C1.$clone()));
                    impulse.X = impulse1.X;
                    impulse.Y = impulse1.Y;
                    impulse.Z = 0.0;
                }

                var P = Microsoft.Xna.Framework.Vector2.op_Addition(Microsoft.Xna.Framework.Vector2.op_Multiply$2(impulse.X, this._perp.$clone()), Microsoft.Xna.Framework.Vector2.op_Multiply$2(impulse.Z, this._axis.$clone()));
                var L1 = impulse.X * this._s1 + impulse.Y + impulse.Z * this._a1;
                var L2 = impulse.X * this._s2 + impulse.Y + impulse.Z * this._a2;

                c1 = Microsoft.Xna.Framework.Vector2.op_Subtraction(c1.$clone(), Microsoft.Xna.Framework.Vector2.op_Multiply$2(this.InvMassA, P.$clone()));
                a1 -= this.InvIA * L1;
                c2 = Microsoft.Xna.Framework.Vector2.op_Addition(c2.$clone(), Microsoft.Xna.Framework.Vector2.op_Multiply$2(this.InvMassB, P.$clone()));
                a2 += this.InvIB * L2;

                b1.Sweep.C = c1.$clone();
                b1.Sweep.A = a1;
                b2.Sweep.C = c2.$clone();
                b2.Sweep.A = a2;
                b1.SynchronizeTransform();
                b2.SynchronizeTransform();

                return linearError <= FarseerPhysics.Settings.LinearSlop && angularError <= FarseerPhysics.Settings.AngularSlop;
            }
        }
    });

    /**
     * The pulley joint is connected to two bodies and two fixed ground points.
     The pulley supports a ratio such that:
     length1 + ratio * length2 <!--<-->= ant
     Yes, the force transmitted is scaled by the ratio.
     The pulley also enforces a maximum length limit on both sides. This is
     useful to prevent one side of the pulley hitting the top.
     *
     * @public
     * @class FarseerPhysics.Dynamics.Joints.PulleyJoint
     * @augments FarseerPhysics.Dynamics.Joints.Joint
     */
    Bridge.define("FarseerPhysics.Dynamics.Joints.PulleyJoint", {
        inherits: [FarseerPhysics.Dynamics.Joints.Joint],
        fields: {
            /**
             * Get the first ground anchor.
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Dynamics.Joints.PulleyJoint
             * @type Microsoft.Xna.Framework.Vector2
             */
            GroundAnchorA: null,
            /**
             * Get the second ground anchor.
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Dynamics.Joints.PulleyJoint
             * @type Microsoft.Xna.Framework.Vector2
             */
            GroundAnchorB: null,
            LocalAnchorA: null,
            LocalAnchorB: null,
            MinPulleyLength: 0,
            _ant: 0,
            _impulse: 0,
            _lengthA: 0,
            _lengthB: 0,
            _limitImpulse1: 0,
            _limitImpulse2: 0,
            _limitMass1: 0,
            _limitMass2: 0,
            _limitState1: 0,
            _limitState2: 0,
            _maxLengthA: 0,
            _maxLengthB: 0,
            _pulleyMass: 0,
            _state: 0,
            _u1: null,
            _u2: null,
            /**
             * Get the pulley ratio.
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Dynamics.Joints.PulleyJoint
             * @function Ratio
             * @type number
             */
            Ratio: 0
        },
        props: {
            WorldAnchorA: {
                get: function () {
                    return this.BodyA.GetWorldPoint(this.LocalAnchorA.$clone());
                }
            },
            WorldAnchorB: {
                get: function () {
                    return this.BodyB.GetWorldPoint(this.LocalAnchorB.$clone());
                },
                set: function (value) {
                    System.Diagnostics.Debug.Assert$1(false, "You can't set the world anchor on this joint type.");
                }
            },
            /**
             * Get the current length of the segment attached to body1.
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Dynamics.Joints.PulleyJoint
             * @function LengthA
             * @type number
             */
            LengthA: {
                get: function () {
                    var d = Microsoft.Xna.Framework.Vector2.op_Subtraction(this.BodyA.GetWorldPoint(this.LocalAnchorA.$clone()), this.GroundAnchorA.$clone());
                    return d.Length();
                },
                set: function (value) {
                    this._lengthA = value;
                }
            },
            /**
             * Get the current length of the segment attached to body2.
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Dynamics.Joints.PulleyJoint
             * @function LengthB
             * @type number
             */
            LengthB: {
                get: function () {
                    var d = Microsoft.Xna.Framework.Vector2.op_Subtraction(this.BodyB.GetWorldPoint(this.LocalAnchorB.$clone()), this.GroundAnchorB.$clone());
                    return d.Length();
                },
                set: function (value) {
                    this._lengthB = value;
                }
            },
            MaxLengthA: {
                get: function () {
                    return this._maxLengthA;
                },
                set: function (value) {
                    this._maxLengthA = value;
                }
            },
            MaxLengthB: {
                get: function () {
                    return this._maxLengthB;
                },
                set: function (value) {
                    this._maxLengthB = value;
                }
            }
        },
        ctors: {
            init: function () {
                this.GroundAnchorA = new Microsoft.Xna.Framework.Vector2();
                this.GroundAnchorB = new Microsoft.Xna.Framework.Vector2();
                this.LocalAnchorA = new Microsoft.Xna.Framework.Vector2();
                this.LocalAnchorB = new Microsoft.Xna.Framework.Vector2();
                this._u1 = new Microsoft.Xna.Framework.Vector2();
                this._u2 = new Microsoft.Xna.Framework.Vector2();
                this.MinPulleyLength = 2.0;
            },
            ctor: function () {
                this.$initialize();
                FarseerPhysics.Dynamics.Joints.Joint.ctor.call(this);
                this.JointType = FarseerPhysics.Dynamics.Joints.JointType.Pulley;
            },
            /**
             * Initialize the bodies, anchors, lengths, max lengths, and ratio using the world anchors.
             This requires two ground anchors,
             two dynamic body anchor points, max lengths for each side,
             and a pulley ratio.
             *
             * @instance
             * @public
             * @this FarseerPhysics.Dynamics.Joints.PulleyJoint
             * @memberof FarseerPhysics.Dynamics.Joints.PulleyJoint
             * @param   {FarseerPhysics.Dynamics.Body}       bodyA            The first body.
             * @param   {FarseerPhysics.Dynamics.Body}       bodyB            The second body.
             * @param   {Microsoft.Xna.Framework.Vector2}    groundAnchorA    The ground anchor for the first body.
             * @param   {Microsoft.Xna.Framework.Vector2}    groundAnchorB    The ground anchor for the second body.
             * @param   {Microsoft.Xna.Framework.Vector2}    localAnchorA     The first body anchor.
             * @param   {Microsoft.Xna.Framework.Vector2}    localAnchorB     The second body anchor.
             * @param   {number}                             ratio            The ratio.
             * @return  {void}
             */
            $ctor1: function (bodyA, bodyB, groundAnchorA, groundAnchorB, localAnchorA, localAnchorB, ratio) {
                this.$initialize();
                FarseerPhysics.Dynamics.Joints.Joint.$ctor2.call(this, bodyA, bodyB);
                this.JointType = FarseerPhysics.Dynamics.Joints.JointType.Pulley;

                this.GroundAnchorA = groundAnchorA.$clone();
                this.GroundAnchorB = groundAnchorB.$clone();
                this.LocalAnchorA = localAnchorA.$clone();
                this.LocalAnchorB = localAnchorB.$clone();

                var d1 = Microsoft.Xna.Framework.Vector2.op_Subtraction(this.BodyA.GetWorldPoint(localAnchorA.$clone()), groundAnchorA.$clone());
                this._lengthA = d1.Length();

                var d2 = Microsoft.Xna.Framework.Vector2.op_Subtraction(this.BodyB.GetWorldPoint(localAnchorB.$clone()), groundAnchorB.$clone());
                this._lengthB = d2.Length();

                System.Diagnostics.Debug.Assert(ratio !== 0.0);
                System.Diagnostics.Debug.Assert(ratio > FarseerPhysics.Settings.Epsilon);
                this.Ratio = ratio;

                var C = this._lengthA + this.Ratio * this._lengthB;

                this.MaxLengthA = C - this.Ratio * this.MinPulleyLength;
                this.MaxLengthB = (C - this.MinPulleyLength) / this.Ratio;

                this._ant = this._lengthA + this.Ratio * this._lengthB;

                this.MaxLengthA = Math.min(this.MaxLengthA, this._ant - this.Ratio * this.MinPulleyLength);
                this.MaxLengthB = Math.min(this.MaxLengthB, (this._ant - this.MinPulleyLength) / this.Ratio);

                this._impulse = 0.0;
                this._limitImpulse1 = 0.0;
                this._limitImpulse2 = 0.0;
            }
        },
        methods: {
            GetReactionForce: function (inv_dt) {
                var P = Microsoft.Xna.Framework.Vector2.op_Multiply$2(this._impulse, this._u2.$clone());
                return Microsoft.Xna.Framework.Vector2.op_Multiply$2(inv_dt, P.$clone());
            },
            GetReactionTorque: function (inv_dt) {
                return 0.0;
            },
            InitVelocityConstraints: function (step) {
                var b1 = this.BodyA;
                var b2 = this.BodyB;

                var xf1 = { v : new FarseerPhysics.Common.Transform() }, xf2 = { v : new FarseerPhysics.Common.Transform() };
                b1.GetTransform(xf1);
                b2.GetTransform(xf2);

                var r1 = FarseerPhysics.Common.MathUtils.Multiply(Bridge.ref(xf1.v, "R"), Microsoft.Xna.Framework.Vector2.op_Subtraction(this.LocalAnchorA.$clone(), b1.LocalCenter.$clone()));
                var r2 = FarseerPhysics.Common.MathUtils.Multiply(Bridge.ref(xf2.v, "R"), Microsoft.Xna.Framework.Vector2.op_Subtraction(this.LocalAnchorB.$clone(), b2.LocalCenter.$clone()));

                var p1 = Microsoft.Xna.Framework.Vector2.op_Addition(b1.Sweep.C.$clone(), r1.$clone());
                var p2 = Microsoft.Xna.Framework.Vector2.op_Addition(b2.Sweep.C.$clone(), r2.$clone());

                var s1 = this.GroundAnchorA.$clone();
                var s2 = this.GroundAnchorB.$clone();

                this._u1 = Microsoft.Xna.Framework.Vector2.op_Subtraction(p1.$clone(), s1.$clone());
                this._u2 = Microsoft.Xna.Framework.Vector2.op_Subtraction(p2.$clone(), s2.$clone());

                var length1 = this._u1.Length();
                var length2 = this._u2.Length();

                if (length1 > FarseerPhysics.Settings.LinearSlop) {
                    this._u1 = Microsoft.Xna.Framework.Vector2.op_Multiply$1(this._u1.$clone(), 1.0 / length1);
                } else {
                    this._u1 = Microsoft.Xna.Framework.Vector2.Zero.$clone();
                }

                if (length2 > FarseerPhysics.Settings.LinearSlop) {
                    this._u2 = Microsoft.Xna.Framework.Vector2.op_Multiply$1(this._u2.$clone(), 1.0 / length2);
                } else {
                    this._u2 = Microsoft.Xna.Framework.Vector2.Zero.$clone();
                }

                var C = this._ant - length1 - this.Ratio * length2;
                if (C > 0.0) {
                    this._state = FarseerPhysics.Dynamics.Joints.LimitState.Inactive;
                    this._impulse = 0.0;
                } else {
                    this._state = FarseerPhysics.Dynamics.Joints.LimitState.AtUpper;
                }

                if (length1 < this.MaxLengthA) {
                    this._limitState1 = FarseerPhysics.Dynamics.Joints.LimitState.Inactive;
                    this._limitImpulse1 = 0.0;
                } else {
                    this._limitState1 = FarseerPhysics.Dynamics.Joints.LimitState.AtUpper;
                }

                if (length2 < this.MaxLengthB) {
                    this._limitState2 = FarseerPhysics.Dynamics.Joints.LimitState.Inactive;
                    this._limitImpulse2 = 0.0;
                } else {
                    this._limitState2 = FarseerPhysics.Dynamics.Joints.LimitState.AtUpper;
                }

                var cr1u1 = FarseerPhysics.Common.MathUtils.Cross$2(r1.$clone(), this._u1.$clone());
                var cr2u2 = FarseerPhysics.Common.MathUtils.Cross$2(r2.$clone(), this._u2.$clone());

                this._limitMass1 = b1.InvMass + b1.InvI * cr1u1 * cr1u1;
                this._limitMass2 = b2.InvMass + b2.InvI * cr2u2 * cr2u2;
                this._pulleyMass = this._limitMass1 + this.Ratio * this.Ratio * this._limitMass2;
                System.Diagnostics.Debug.Assert(this._limitMass1 > FarseerPhysics.Settings.Epsilon);
                System.Diagnostics.Debug.Assert(this._limitMass2 > FarseerPhysics.Settings.Epsilon);
                System.Diagnostics.Debug.Assert(this._pulleyMass > FarseerPhysics.Settings.Epsilon);
                this._limitMass1 = 1.0 / this._limitMass1;
                this._limitMass2 = 1.0 / this._limitMass2;
                this._pulleyMass = 1.0 / this._pulleyMass;

                if (FarseerPhysics.Settings.EnableWarmstarting) {
                    this._impulse *= step.v.dtRatio;
                    this._limitImpulse1 *= step.v.dtRatio;
                    this._limitImpulse2 *= step.v.dtRatio;

                    var P1 = Microsoft.Xna.Framework.Vector2.op_Multiply$2(-(this._impulse + this._limitImpulse1), this._u1.$clone());
                    var P2 = Microsoft.Xna.Framework.Vector2.op_Multiply$2((-this.Ratio * this._impulse - this._limitImpulse2), this._u2.$clone());
                    b1.LinearVelocityInternal = Microsoft.Xna.Framework.Vector2.op_Addition(b1.LinearVelocityInternal.$clone(), Microsoft.Xna.Framework.Vector2.op_Multiply$2(b1.InvMass, P1.$clone()));
                    b1.AngularVelocityInternal += b1.InvI * FarseerPhysics.Common.MathUtils.Cross$2(r1.$clone(), P1.$clone());
                    b2.LinearVelocityInternal = Microsoft.Xna.Framework.Vector2.op_Addition(b2.LinearVelocityInternal.$clone(), Microsoft.Xna.Framework.Vector2.op_Multiply$2(b2.InvMass, P2.$clone()));
                    b2.AngularVelocityInternal += b2.InvI * FarseerPhysics.Common.MathUtils.Cross$2(r2.$clone(), P2.$clone());
                } else {
                    this._impulse = 0.0;
                    this._limitImpulse1 = 0.0;
                    this._limitImpulse2 = 0.0;
                }
            },
            SolveVelocityConstraints: function (step) {
                var b1 = this.BodyA;
                var b2 = this.BodyB;

                var xf1 = { v : new FarseerPhysics.Common.Transform() }, xf2 = { v : new FarseerPhysics.Common.Transform() };
                b1.GetTransform(xf1);
                b2.GetTransform(xf2);

                var r1 = FarseerPhysics.Common.MathUtils.Multiply(Bridge.ref(xf1.v, "R"), Microsoft.Xna.Framework.Vector2.op_Subtraction(this.LocalAnchorA.$clone(), b1.LocalCenter.$clone()));
                var r2 = FarseerPhysics.Common.MathUtils.Multiply(Bridge.ref(xf2.v, "R"), Microsoft.Xna.Framework.Vector2.op_Subtraction(this.LocalAnchorB.$clone(), b2.LocalCenter.$clone()));

                if (this._state === FarseerPhysics.Dynamics.Joints.LimitState.AtUpper) {
                    var v1 = Microsoft.Xna.Framework.Vector2.op_Addition(b1.LinearVelocityInternal.$clone(), FarseerPhysics.Common.MathUtils.Cross$1(b1.AngularVelocityInternal, r1.$clone()));
                    var v2 = Microsoft.Xna.Framework.Vector2.op_Addition(b2.LinearVelocityInternal.$clone(), FarseerPhysics.Common.MathUtils.Cross$1(b2.AngularVelocityInternal, r2.$clone()));

                    var Cdot = -Microsoft.Xna.Framework.Vector2.Dot(this._u1.$clone(), v1.$clone()) - this.Ratio * Microsoft.Xna.Framework.Vector2.Dot(this._u2.$clone(), v2.$clone());
                    var impulse = this._pulleyMass * (-Cdot);
                    var oldImpulse = this._impulse;
                    this._impulse = Math.max(0.0, this._impulse + impulse);
                    impulse = this._impulse - oldImpulse;

                    var P1 = Microsoft.Xna.Framework.Vector2.op_Multiply$2(-impulse, this._u1.$clone());
                    var P2 = Microsoft.Xna.Framework.Vector2.op_Multiply$2(-this.Ratio * impulse, this._u2.$clone());
                    b1.LinearVelocityInternal = Microsoft.Xna.Framework.Vector2.op_Addition(b1.LinearVelocityInternal.$clone(), Microsoft.Xna.Framework.Vector2.op_Multiply$2(b1.InvMass, P1.$clone()));
                    b1.AngularVelocityInternal += b1.InvI * FarseerPhysics.Common.MathUtils.Cross$2(r1.$clone(), P1.$clone());
                    b2.LinearVelocityInternal = Microsoft.Xna.Framework.Vector2.op_Addition(b2.LinearVelocityInternal.$clone(), Microsoft.Xna.Framework.Vector2.op_Multiply$2(b2.InvMass, P2.$clone()));
                    b2.AngularVelocityInternal += b2.InvI * FarseerPhysics.Common.MathUtils.Cross$2(r2.$clone(), P2.$clone());
                }

                if (this._limitState1 === FarseerPhysics.Dynamics.Joints.LimitState.AtUpper) {
                    var v11 = Microsoft.Xna.Framework.Vector2.op_Addition(b1.LinearVelocityInternal.$clone(), FarseerPhysics.Common.MathUtils.Cross$1(b1.AngularVelocityInternal, r1.$clone()));

                    var Cdot1 = -Microsoft.Xna.Framework.Vector2.Dot(this._u1.$clone(), v11.$clone());
                    var impulse1 = -this._limitMass1 * Cdot1;
                    var oldImpulse1 = this._limitImpulse1;
                    this._limitImpulse1 = Math.max(0.0, this._limitImpulse1 + impulse1);
                    impulse1 = this._limitImpulse1 - oldImpulse1;

                    var P11 = Microsoft.Xna.Framework.Vector2.op_Multiply$2(-impulse1, this._u1.$clone());
                    b1.LinearVelocityInternal = Microsoft.Xna.Framework.Vector2.op_Addition(b1.LinearVelocityInternal.$clone(), Microsoft.Xna.Framework.Vector2.op_Multiply$2(b1.InvMass, P11.$clone()));
                    b1.AngularVelocityInternal += b1.InvI * FarseerPhysics.Common.MathUtils.Cross$2(r1.$clone(), P11.$clone());
                }

                if (this._limitState2 === FarseerPhysics.Dynamics.Joints.LimitState.AtUpper) {
                    var v21 = Microsoft.Xna.Framework.Vector2.op_Addition(b2.LinearVelocityInternal.$clone(), FarseerPhysics.Common.MathUtils.Cross$1(b2.AngularVelocityInternal, r2.$clone()));

                    var Cdot2 = -Microsoft.Xna.Framework.Vector2.Dot(this._u2.$clone(), v21.$clone());
                    var impulse2 = -this._limitMass2 * Cdot2;
                    var oldImpulse2 = this._limitImpulse2;
                    this._limitImpulse2 = Math.max(0.0, this._limitImpulse2 + impulse2);
                    impulse2 = this._limitImpulse2 - oldImpulse2;

                    var P21 = Microsoft.Xna.Framework.Vector2.op_Multiply$2(-impulse2, this._u2.$clone());
                    b2.LinearVelocityInternal = Microsoft.Xna.Framework.Vector2.op_Addition(b2.LinearVelocityInternal.$clone(), Microsoft.Xna.Framework.Vector2.op_Multiply$2(b2.InvMass, P21.$clone()));
                    b2.AngularVelocityInternal += b2.InvI * FarseerPhysics.Common.MathUtils.Cross$2(r2.$clone(), P21.$clone());
                }
            },
            SolvePositionConstraints: function () {
                var b1 = this.BodyA;
                var b2 = this.BodyB;

                var s1 = this.GroundAnchorA.$clone();
                var s2 = this.GroundAnchorB.$clone();

                var linearError = 0.0;

                if (this._state === FarseerPhysics.Dynamics.Joints.LimitState.AtUpper) {
                    var xf1 = { v : new FarseerPhysics.Common.Transform() }, xf2 = { v : new FarseerPhysics.Common.Transform() };
                    b1.GetTransform(xf1);
                    b2.GetTransform(xf2);

                    var r1 = FarseerPhysics.Common.MathUtils.Multiply(Bridge.ref(xf1.v, "R"), Microsoft.Xna.Framework.Vector2.op_Subtraction(this.LocalAnchorA.$clone(), b1.LocalCenter.$clone()));
                    var r2 = FarseerPhysics.Common.MathUtils.Multiply(Bridge.ref(xf2.v, "R"), Microsoft.Xna.Framework.Vector2.op_Subtraction(this.LocalAnchorB.$clone(), b2.LocalCenter.$clone()));

                    var p1 = Microsoft.Xna.Framework.Vector2.op_Addition(b1.Sweep.C.$clone(), r1.$clone());
                    var p2 = Microsoft.Xna.Framework.Vector2.op_Addition(b2.Sweep.C.$clone(), r2.$clone());

                    this._u1 = Microsoft.Xna.Framework.Vector2.op_Subtraction(p1.$clone(), s1.$clone());
                    this._u2 = Microsoft.Xna.Framework.Vector2.op_Subtraction(p2.$clone(), s2.$clone());

                    var length1 = this._u1.Length();
                    var length2 = this._u2.Length();

                    if (length1 > FarseerPhysics.Settings.LinearSlop) {
                        this._u1 = Microsoft.Xna.Framework.Vector2.op_Multiply$1(this._u1.$clone(), 1.0 / length1);
                    } else {
                        this._u1 = Microsoft.Xna.Framework.Vector2.Zero.$clone();
                    }

                    if (length2 > FarseerPhysics.Settings.LinearSlop) {
                        this._u2 = Microsoft.Xna.Framework.Vector2.op_Multiply$1(this._u2.$clone(), 1.0 / length2);
                    } else {
                        this._u2 = Microsoft.Xna.Framework.Vector2.Zero.$clone();
                    }

                    var C = this._ant - length1 - this.Ratio * length2;
                    linearError = Math.max(linearError, -C);

                    C = FarseerPhysics.Common.MathUtils.Clamp$2(C + FarseerPhysics.Settings.LinearSlop, -0.2, 0.0);
                    var impulse = -this._pulleyMass * C;

                    var P1 = Microsoft.Xna.Framework.Vector2.op_Multiply$2(-impulse, this._u1.$clone());
                    var P2 = Microsoft.Xna.Framework.Vector2.op_Multiply$2(-this.Ratio * impulse, this._u2.$clone());

                    b1.Sweep.C = Microsoft.Xna.Framework.Vector2.op_Addition(b1.Sweep.C.$clone(), Microsoft.Xna.Framework.Vector2.op_Multiply$2(b1.InvMass, P1.$clone()));
                    b1.Sweep.A += b1.InvI * FarseerPhysics.Common.MathUtils.Cross$2(r1.$clone(), P1.$clone());
                    b2.Sweep.C = Microsoft.Xna.Framework.Vector2.op_Addition(b2.Sweep.C.$clone(), Microsoft.Xna.Framework.Vector2.op_Multiply$2(b2.InvMass, P2.$clone()));
                    b2.Sweep.A += b2.InvI * FarseerPhysics.Common.MathUtils.Cross$2(r2.$clone(), P2.$clone());

                    b1.SynchronizeTransform();
                    b2.SynchronizeTransform();
                }

                if (this._limitState1 === FarseerPhysics.Dynamics.Joints.LimitState.AtUpper) {
                    var xf11 = { v : new FarseerPhysics.Common.Transform() };
                    b1.GetTransform(xf11);

                    var r11 = FarseerPhysics.Common.MathUtils.Multiply(Bridge.ref(xf11.v, "R"), Microsoft.Xna.Framework.Vector2.op_Subtraction(this.LocalAnchorA.$clone(), b1.LocalCenter.$clone()));
                    var p11 = Microsoft.Xna.Framework.Vector2.op_Addition(b1.Sweep.C.$clone(), r11.$clone());

                    this._u1 = Microsoft.Xna.Framework.Vector2.op_Subtraction(p11.$clone(), s1.$clone());
                    var length11 = this._u1.Length();

                    if (length11 > FarseerPhysics.Settings.LinearSlop) {
                        this._u1 = Microsoft.Xna.Framework.Vector2.op_Multiply$1(this._u1.$clone(), 1.0 / length11);
                    } else {
                        this._u1 = Microsoft.Xna.Framework.Vector2.Zero.$clone();
                    }

                    var C1 = this.MaxLengthA - length11;
                    linearError = Math.max(linearError, -C1);
                    C1 = FarseerPhysics.Common.MathUtils.Clamp$2(C1 + FarseerPhysics.Settings.LinearSlop, -0.2, 0.0);
                    var impulse1 = -this._limitMass1 * C1;

                    var P11 = Microsoft.Xna.Framework.Vector2.op_Multiply$2(-impulse1, this._u1.$clone());
                    b1.Sweep.C = Microsoft.Xna.Framework.Vector2.op_Addition(b1.Sweep.C.$clone(), Microsoft.Xna.Framework.Vector2.op_Multiply$2(b1.InvMass, P11.$clone()));
                    b1.Sweep.A += b1.InvI * FarseerPhysics.Common.MathUtils.Cross$2(r11.$clone(), P11.$clone());

                    b1.SynchronizeTransform();
                }

                if (this._limitState2 === FarseerPhysics.Dynamics.Joints.LimitState.AtUpper) {
                    var xf21 = { v : new FarseerPhysics.Common.Transform() };
                    b2.GetTransform(xf21);

                    var r21 = FarseerPhysics.Common.MathUtils.Multiply(Bridge.ref(xf21.v, "R"), Microsoft.Xna.Framework.Vector2.op_Subtraction(this.LocalAnchorB.$clone(), b2.LocalCenter.$clone()));
                    var p21 = Microsoft.Xna.Framework.Vector2.op_Addition(b2.Sweep.C.$clone(), r21.$clone());

                    this._u2 = Microsoft.Xna.Framework.Vector2.op_Subtraction(p21.$clone(), s2.$clone());
                    var length21 = this._u2.Length();

                    if (length21 > FarseerPhysics.Settings.LinearSlop) {
                        this._u2 = Microsoft.Xna.Framework.Vector2.op_Multiply$1(this._u2.$clone(), 1.0 / length21);
                    } else {
                        this._u2 = Microsoft.Xna.Framework.Vector2.Zero.$clone();
                    }

                    var C2 = this.MaxLengthB - length21;
                    linearError = Math.max(linearError, -C2);
                    C2 = FarseerPhysics.Common.MathUtils.Clamp$2(C2 + FarseerPhysics.Settings.LinearSlop, -0.2, 0.0);
                    var impulse2 = -this._limitMass2 * C2;

                    var P21 = Microsoft.Xna.Framework.Vector2.op_Multiply$2(-impulse2, this._u2.$clone());
                    b2.Sweep.C = Microsoft.Xna.Framework.Vector2.op_Addition(b2.Sweep.C.$clone(), Microsoft.Xna.Framework.Vector2.op_Multiply$2(b2.InvMass, P21.$clone()));
                    b2.Sweep.A += b2.InvI * FarseerPhysics.Common.MathUtils.Cross$2(r21.$clone(), P21.$clone());

                    b2.SynchronizeTransform();
                }

                return linearError < FarseerPhysics.Settings.LinearSlop;
            }
        }
    });

    /**
     * A revolute joint rains to bodies to share a common point while they
     are free to rotate about the point. The relative rotation about the shared
     point is the joint angle. You can limit the relative rotation with
     a joint limit that specifies a lower and upper angle. You can use a motor
     to drive the relative rotation about the shared point. A maximum motor torque
     is provided so that infinite forces are not generated.
     *
     * @public
     * @class FarseerPhysics.Dynamics.Joints.RevoluteJoint
     * @augments FarseerPhysics.Dynamics.Joints.Joint
     */
    Bridge.define("FarseerPhysics.Dynamics.Joints.RevoluteJoint", {
        inherits: [FarseerPhysics.Dynamics.Joints.Joint],
        fields: {
            LocalAnchorA: null,
            LocalAnchorB: null,
            _enableLimit: false,
            _enableMotor: false,
            _impulse: null,
            _limitState: 0,
            _lowerAngle: 0,
            _mass: null,
            _maxMotorTorque: 0,
            _motorImpulse: 0,
            _motorMass: 0,
            _motorSpeed: 0,
            _referenceAngle: 0,
            _tmpFloat1: 0,
            _tmpVector1: null,
            _tmpVector2: null,
            _upperAngle: 0
        },
        props: {
            WorldAnchorA: {
                get: function () {
                    return this.BodyA.GetWorldPoint(this.LocalAnchorA.$clone());
                }
            },
            WorldAnchorB: {
                get: function () {
                    return this.BodyB.GetWorldPoint(this.LocalAnchorB.$clone());
                },
                set: function (value) {
                    System.Diagnostics.Debug.Assert$1(false, "You can't set the world anchor on this joint type.");
                }
            },
            ReferenceAngle: {
                get: function () {
                    return this._referenceAngle;
                },
                set: function (value) {
                    this.WakeBodies();
                    this._referenceAngle = value;
                }
            },
            /**
             * Get the current joint angle in radians.
             *
             * @instance
             * @public
             * @readonly
             * @memberof FarseerPhysics.Dynamics.Joints.RevoluteJoint
             * @function JointAngle
             * @type number
             */
            JointAngle: {
                get: function () {
                    return this.BodyB.Sweep.A - this.BodyA.Sweep.A - this.ReferenceAngle;
                }
            },
            /**
             * Get the current joint angle speed in radians per second.
             *
             * @instance
             * @public
             * @readonly
             * @memberof FarseerPhysics.Dynamics.Joints.RevoluteJoint
             * @function JointSpeed
             * @type number
             */
            JointSpeed: {
                get: function () {
                    return this.BodyB.AngularVelocityInternal - this.BodyA.AngularVelocityInternal;
                }
            },
            /**
             * Is the joint limit enabled?
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Dynamics.Joints.RevoluteJoint
             * @function LimitEnabled
             * @type boolean
             */
            LimitEnabled: {
                get: function () {
                    return this._enableLimit;
                },
                set: function (value) {
                    this.WakeBodies();
                    this._enableLimit = value;
                }
            },
            /**
             * Get the lower joint limit in radians.
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Dynamics.Joints.RevoluteJoint
             * @function LowerLimit
             * @type number
             */
            LowerLimit: {
                get: function () {
                    return this._lowerAngle;
                },
                set: function (value) {
                    this.WakeBodies();
                    this._lowerAngle = value;
                }
            },
            /**
             * Get the upper joint limit in radians.
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Dynamics.Joints.RevoluteJoint
             * @function UpperLimit
             * @type number
             */
            UpperLimit: {
                get: function () {
                    return this._upperAngle;
                },
                set: function (value) {
                    this.WakeBodies();
                    this._upperAngle = value;
                }
            },
            /**
             * Is the joint motor enabled?
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Dynamics.Joints.RevoluteJoint
             * @function MotorEnabled
             * @type boolean
             */
            MotorEnabled: {
                get: function () {
                    return this._enableMotor;
                },
                set: function (value) {
                    this.WakeBodies();
                    this._enableMotor = value;
                }
            },
            /**
             * Set the motor speed in radians per second.
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Dynamics.Joints.RevoluteJoint
             * @function MotorSpeed
             * @type number
             */
            MotorSpeed: {
                get: function () {
                    return this._motorSpeed;
                },
                set: function (value) {
                    this.WakeBodies();
                    this._motorSpeed = value;
                }
            },
            /**
             * Set the maximum motor torque, usually in N-m.
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Dynamics.Joints.RevoluteJoint
             * @function MaxMotorTorque
             * @type number
             */
            MaxMotorTorque: {
                get: function () {
                    return this._maxMotorTorque;
                },
                set: function (value) {
                    this.WakeBodies();
                    this._maxMotorTorque = value;
                }
            },
            /**
             * Get the current motor torque, usually in N-m.
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Dynamics.Joints.RevoluteJoint
             * @function MotorTorque
             * @type number
             */
            MotorTorque: {
                get: function () {
                    return this._motorImpulse;
                },
                set: function (value) {
                    this.WakeBodies();
                    this._motorImpulse = value;
                }
            }
        },
        ctors: {
            init: function () {
                this.LocalAnchorA = new Microsoft.Xna.Framework.Vector2();
                this.LocalAnchorB = new Microsoft.Xna.Framework.Vector2();
                this._impulse = new Microsoft.Xna.Framework.Vector3();
                this._mass = new FarseerPhysics.Common.Mat33();
                this._tmpVector1 = new Microsoft.Xna.Framework.Vector2();
                this._tmpVector2 = new Microsoft.Xna.Framework.Vector2();
            },
            ctor: function () {
                this.$initialize();
                FarseerPhysics.Dynamics.Joints.Joint.ctor.call(this);
                this.JointType = FarseerPhysics.Dynamics.Joints.JointType.Revolute;
            },
            /**
             * Initialize the bodies and local anchor.
             This requires defining an
             anchor point where the bodies are joined. The definition
             uses local anchor points so that the initial configuration
             can violate the constraint slightly. You also need to
             specify the initial relative angle for joint limits. This
             helps when saving and loading a game.
             The local anchor points are measured from the body's origin
             rather than the center of mass because:
             1. you might not know where the center of mass will be.
             2. if you add/remove shapes from a body and recompute the mass,
             the joints will be broken.
             *
             * @instance
             * @public
             * @this FarseerPhysics.Dynamics.Joints.RevoluteJoint
             * @memberof FarseerPhysics.Dynamics.Joints.RevoluteJoint
             * @param   {FarseerPhysics.Dynamics.Body}       bodyA           The first body.
             * @param   {FarseerPhysics.Dynamics.Body}       bodyB           The second body.
             * @param   {Microsoft.Xna.Framework.Vector2}    localAnchorA    The first body anchor.
             * @param   {Microsoft.Xna.Framework.Vector2}    localAnchorB    The second anchor.
             * @return  {void}
             */
            $ctor1: function (bodyA, bodyB, localAnchorA, localAnchorB) {
                this.$initialize();
                FarseerPhysics.Dynamics.Joints.Joint.$ctor2.call(this, bodyA, bodyB);
                this.JointType = FarseerPhysics.Dynamics.Joints.JointType.Revolute;

                this.LocalAnchorA = localAnchorA.$clone();
                this.LocalAnchorB = localAnchorB.$clone();

                this.ReferenceAngle = this.BodyB.Rotation - this.BodyA.Rotation;

                this._impulse = Microsoft.Xna.Framework.Vector3.Zero.$clone();

                this._limitState = FarseerPhysics.Dynamics.Joints.LimitState.Inactive;
            }
        },
        methods: {
            GetReactionForce: function (inv_dt) {
                var P = new Microsoft.Xna.Framework.Vector2.$ctor2(this._impulse.X, this._impulse.Y);
                return Microsoft.Xna.Framework.Vector2.op_Multiply$2(inv_dt, P.$clone());
            },
            GetReactionTorque: function (inv_dt) {
                return inv_dt * this._impulse.Z;
            },
            InitVelocityConstraints: function (step) {
                var b1 = this.BodyA;
                var b2 = this.BodyB;

                if (this._enableMotor || this._enableLimit) {
                    System.Diagnostics.Debug.Assert(b1.InvI > 0.0 || b2.InvI > 0.0);
                }

                /* Transform xf1, xf2;
                b1.GetTransform(out xf1);
                b2.GetTransform(out xf2);*/

                var r1 = { v : FarseerPhysics.Common.MathUtils.Multiply(Bridge.ref(b1.Xf, "R"), Microsoft.Xna.Framework.Vector2.op_Subtraction(this.LocalAnchorA.$clone(), b1.LocalCenter.$clone())) };
                var r2 = { v : FarseerPhysics.Common.MathUtils.Multiply(Bridge.ref(b2.Xf, "R"), Microsoft.Xna.Framework.Vector2.op_Subtraction(this.LocalAnchorB.$clone(), b2.LocalCenter.$clone())) };



                var m1 = b1.InvMass, m2 = b2.InvMass;
                var i1 = b1.InvI, i2 = b2.InvI;

                this._mass.Col1.X = m1 + m2 + r1.v.Y * r1.v.Y * i1 + r2.v.Y * r2.v.Y * i2;
                this._mass.Col2.X = -r1.v.Y * r1.v.X * i1 - r2.v.Y * r2.v.X * i2;
                this._mass.Col3.X = -r1.v.Y * i1 - r2.v.Y * i2;
                this._mass.Col1.Y = this._mass.Col2.X;
                this._mass.Col2.Y = m1 + m2 + r1.v.X * r1.v.X * i1 + r2.v.X * r2.v.X * i2;
                this._mass.Col3.Y = r1.v.X * i1 + r2.v.X * i2;
                this._mass.Col1.Z = this._mass.Col3.X;
                this._mass.Col2.Z = this._mass.Col3.Y;
                this._mass.Col3.Z = i1 + i2;

                this._motorMass = i1 + i2;
                if (this._motorMass > 0.0) {
                    this._motorMass = 1.0 / this._motorMass;
                }

                if (this._enableMotor === false) {
                    this._motorImpulse = 0.0;
                }

                if (this._enableLimit) {
                    var jointAngle = b2.Sweep.A - b1.Sweep.A - this.ReferenceAngle;
                    if (Math.abs(this._upperAngle - this._lowerAngle) < 0.06981318) {
                        this._limitState = FarseerPhysics.Dynamics.Joints.LimitState.Equal;
                    } else if (jointAngle <= this._lowerAngle) {
                        if (this._limitState !== FarseerPhysics.Dynamics.Joints.LimitState.AtLower) {
                            this._impulse.Z = 0.0;
                        }
                        this._limitState = FarseerPhysics.Dynamics.Joints.LimitState.AtLower;
                    } else if (jointAngle >= this._upperAngle) {
                        if (this._limitState !== FarseerPhysics.Dynamics.Joints.LimitState.AtUpper) {
                            this._impulse.Z = 0.0;
                        }
                        this._limitState = FarseerPhysics.Dynamics.Joints.LimitState.AtUpper;
                    } else {
                        this._limitState = FarseerPhysics.Dynamics.Joints.LimitState.Inactive;
                        this._impulse.Z = 0.0;
                    }
                } else {
                    this._limitState = FarseerPhysics.Dynamics.Joints.LimitState.Inactive;
                }

                if (FarseerPhysics.Settings.EnableWarmstarting) {
                    this._impulse = Microsoft.Xna.Framework.Vector3.op_Multiply$1(this._impulse.$clone(), step.v.dtRatio);
                    this._motorImpulse *= step.v.dtRatio;

                    var P = { v : new Microsoft.Xna.Framework.Vector2.$ctor2(this._impulse.X, this._impulse.Y) };

                    b1.LinearVelocityInternal = Microsoft.Xna.Framework.Vector2.op_Subtraction(b1.LinearVelocityInternal.$clone(), Microsoft.Xna.Framework.Vector2.op_Multiply$2(m1, P.v.$clone()));
                    FarseerPhysics.Common.MathUtils.Cross$3(r1, P, Bridge.ref(this, "_tmpFloat1"));
                    b1.AngularVelocityInternal -= i1 * (this._tmpFloat1 + this._motorImpulse + this._impulse.Z);

                    b2.LinearVelocityInternal = Microsoft.Xna.Framework.Vector2.op_Addition(b2.LinearVelocityInternal.$clone(), Microsoft.Xna.Framework.Vector2.op_Multiply$2(m2, P.v.$clone()));
                    FarseerPhysics.Common.MathUtils.Cross$3(r2, P, Bridge.ref(this, "_tmpFloat1"));
                    b2.AngularVelocityInternal += i2 * (this._tmpFloat1 + this._motorImpulse + this._impulse.Z);
                } else {
                    this._impulse = Microsoft.Xna.Framework.Vector3.Zero.$clone();
                    this._motorImpulse = 0.0;
                }
            },
            SolveVelocityConstraints: function (step) {
                var b1 = this.BodyA;
                var b2 = this.BodyB;

                var v1 = b1.LinearVelocityInternal.$clone();
                var w1 = b1.AngularVelocityInternal;
                var v2 = b2.LinearVelocityInternal.$clone();
                var w2 = b2.AngularVelocityInternal;

                var m1 = b1.InvMass, m2 = b2.InvMass;
                var i1 = b1.InvI, i2 = b2.InvI;

                if (this._enableMotor && this._limitState !== FarseerPhysics.Dynamics.Joints.LimitState.Equal) {
                    var Cdot = w2 - w1 - this._motorSpeed;
                    var impulse = this._motorMass * (-Cdot);
                    var oldImpulse = this._motorImpulse;
                    var maxImpulse = step.v.dt * this._maxMotorTorque;
                    this._motorImpulse = FarseerPhysics.Common.MathUtils.Clamp$2(this._motorImpulse + impulse, -maxImpulse, maxImpulse);
                    impulse = this._motorImpulse - oldImpulse;

                    w1 -= i1 * impulse;
                    w2 += i2 * impulse;
                }

                if (this._enableLimit && this._limitState !== FarseerPhysics.Dynamics.Joints.LimitState.Inactive) {
                    /* Transform xf1, xf2;
                    b1.GetTransform(out xf1);
                    b2.GetTransform(out xf2);*/

                    var r1 = { v : FarseerPhysics.Common.MathUtils.Multiply(Bridge.ref(b1.Xf, "R"), Microsoft.Xna.Framework.Vector2.op_Subtraction(this.LocalAnchorA.$clone(), b1.LocalCenter.$clone())) };
                    var r2 = { v : FarseerPhysics.Common.MathUtils.Multiply(Bridge.ref(b2.Xf, "R"), Microsoft.Xna.Framework.Vector2.op_Subtraction(this.LocalAnchorB.$clone(), b2.LocalCenter.$clone())) };

                    FarseerPhysics.Common.MathUtils.Cross$4(w2, r2, Bridge.ref(this, "_tmpVector2"));
                    FarseerPhysics.Common.MathUtils.Cross$4(w1, r1, Bridge.ref(this, "_tmpVector1"));
                    var Cdot1 = Microsoft.Xna.Framework.Vector2.op_Subtraction(Microsoft.Xna.Framework.Vector2.op_Subtraction(Microsoft.Xna.Framework.Vector2.op_Addition(v2.$clone(), this._tmpVector2.$clone()), v1.$clone()), this._tmpVector1.$clone());
                    var Cdot2 = w2 - w1;
                    var Cdot3 = new Microsoft.Xna.Framework.Vector3.$ctor3(Cdot1.X, Cdot1.Y, Cdot2);

                    var impulse1 = this._mass.Solve33(Microsoft.Xna.Framework.Vector3.op_UnaryNegation(Cdot3.$clone()));

                    if (this._limitState === FarseerPhysics.Dynamics.Joints.LimitState.Equal) {
                        this._impulse = Microsoft.Xna.Framework.Vector3.op_Addition(this._impulse.$clone(), impulse1.$clone());
                    } else if (this._limitState === FarseerPhysics.Dynamics.Joints.LimitState.AtLower) {
                        var newImpulse = this._impulse.Z + impulse1.Z;
                        if (newImpulse < 0.0) {
                            var reduced = this._mass.Solve22(Microsoft.Xna.Framework.Vector2.op_UnaryNegation(Cdot1.$clone()));
                            impulse1.X = reduced.X;
                            impulse1.Y = reduced.Y;
                            impulse1.Z = -this._impulse.Z;
                            this._impulse.X += reduced.X;
                            this._impulse.Y += reduced.Y;
                            this._impulse.Z = 0.0;
                        }
                    } else if (this._limitState === FarseerPhysics.Dynamics.Joints.LimitState.AtUpper) {
                        var newImpulse1 = this._impulse.Z + impulse1.Z;
                        if (newImpulse1 > 0.0) {
                            var reduced1 = this._mass.Solve22(Microsoft.Xna.Framework.Vector2.op_UnaryNegation(Cdot1.$clone()));
                            impulse1.X = reduced1.X;
                            impulse1.Y = reduced1.Y;
                            impulse1.Z = -this._impulse.Z;
                            this._impulse.X += reduced1.X;
                            this._impulse.Y += reduced1.Y;
                            this._impulse.Z = 0.0;
                        }
                    }

                    var P = { v : new Microsoft.Xna.Framework.Vector2.$ctor2(impulse1.X, impulse1.Y) };

                    v1 = Microsoft.Xna.Framework.Vector2.op_Subtraction(v1.$clone(), Microsoft.Xna.Framework.Vector2.op_Multiply$2(m1, P.v.$clone()));
                    FarseerPhysics.Common.MathUtils.Cross$3(r1, P, Bridge.ref(this, "_tmpFloat1"));
                    w1 -= i1 * (this._tmpFloat1 + impulse1.Z);

                    v2 = Microsoft.Xna.Framework.Vector2.op_Addition(v2.$clone(), Microsoft.Xna.Framework.Vector2.op_Multiply$2(m2, P.v.$clone()));
                    FarseerPhysics.Common.MathUtils.Cross$3(r2, P, Bridge.ref(this, "_tmpFloat1"));
                    w2 += i2 * (this._tmpFloat1 + impulse1.Z);
                } else {
                    /* Transform xf1, xf2;
                    b1.GetTransform(out xf1);
                    b2.GetTransform(out xf2);*/

                    this._tmpVector1 = Microsoft.Xna.Framework.Vector2.op_Subtraction(this.LocalAnchorA.$clone(), b1.LocalCenter.$clone());
                    this._tmpVector2 = Microsoft.Xna.Framework.Vector2.op_Subtraction(this.LocalAnchorB.$clone(), b2.LocalCenter.$clone());
                    var r11 = { v : FarseerPhysics.Common.MathUtils.Multiply$1(Bridge.ref(b1.Xf, "R"), Bridge.ref(this, "_tmpVector1")) };
                    var r21 = { v : FarseerPhysics.Common.MathUtils.Multiply$1(Bridge.ref(b2.Xf, "R"), Bridge.ref(this, "_tmpVector2")) };

                    FarseerPhysics.Common.MathUtils.Cross$4(w2, r21, Bridge.ref(this, "_tmpVector2"));
                    FarseerPhysics.Common.MathUtils.Cross$4(w1, r11, Bridge.ref(this, "_tmpVector1"));
                    var Cdot4 = Microsoft.Xna.Framework.Vector2.op_Subtraction(Microsoft.Xna.Framework.Vector2.op_Subtraction(Microsoft.Xna.Framework.Vector2.op_Addition(v2.$clone(), this._tmpVector2.$clone()), v1.$clone()), this._tmpVector1.$clone());
                    var impulse2 = { v : this._mass.Solve22(Microsoft.Xna.Framework.Vector2.op_UnaryNegation(Cdot4.$clone())) };

                    this._impulse.X += impulse2.v.X;
                    this._impulse.Y += impulse2.v.Y;

                    v1 = Microsoft.Xna.Framework.Vector2.op_Subtraction(v1.$clone(), Microsoft.Xna.Framework.Vector2.op_Multiply$2(m1, impulse2.v.$clone()));
                    FarseerPhysics.Common.MathUtils.Cross$3(r11, impulse2, Bridge.ref(this, "_tmpFloat1"));
                    w1 -= i1 * this._tmpFloat1;

                    v2 = Microsoft.Xna.Framework.Vector2.op_Addition(v2.$clone(), Microsoft.Xna.Framework.Vector2.op_Multiply$2(m2, impulse2.v.$clone()));
                    FarseerPhysics.Common.MathUtils.Cross$3(r21, impulse2, Bridge.ref(this, "_tmpFloat1"));
                    w2 += i2 * this._tmpFloat1;
                }

                b1.LinearVelocityInternal = v1.$clone();
                b1.AngularVelocityInternal = w1;
                b2.LinearVelocityInternal = v2.$clone();
                b2.AngularVelocityInternal = w2;
            },
            SolvePositionConstraints: function () {

                var b1 = this.BodyA;
                var b2 = this.BodyB;

                var angularError = 0.0;
                var positionError;

                if (this._enableLimit && this._limitState !== FarseerPhysics.Dynamics.Joints.LimitState.Inactive) {
                    var angle = b2.Sweep.A - b1.Sweep.A - this.ReferenceAngle;
                    var limitImpulse = 0.0;

                    if (this._limitState === FarseerPhysics.Dynamics.Joints.LimitState.Equal) {
                        var C = FarseerPhysics.Common.MathUtils.Clamp$2(angle - this._lowerAngle, -0.139626354, FarseerPhysics.Settings.MaxAngularCorrection);
                        limitImpulse = -this._motorMass * C;
                        angularError = Math.abs(C);
                    } else if (this._limitState === FarseerPhysics.Dynamics.Joints.LimitState.AtLower) {
                        var C1 = angle - this._lowerAngle;
                        angularError = -C1;

                        C1 = FarseerPhysics.Common.MathUtils.Clamp$2(C1 + FarseerPhysics.Settings.AngularSlop, -0.139626354, 0.0);
                        limitImpulse = -this._motorMass * C1;
                    } else if (this._limitState === FarseerPhysics.Dynamics.Joints.LimitState.AtUpper) {
                        var C2 = angle - this._upperAngle;
                        angularError = C2;

                        C2 = FarseerPhysics.Common.MathUtils.Clamp$2(C2 - FarseerPhysics.Settings.AngularSlop, 0.0, FarseerPhysics.Settings.MaxAngularCorrection);
                        limitImpulse = -this._motorMass * C2;
                    }

                    b1.Sweep.A -= b1.InvI * limitImpulse;
                    b2.Sweep.A += b2.InvI * limitImpulse;

                    b1.SynchronizeTransform();
                    b2.SynchronizeTransform();
                }

                {
                    /* Transform xf1, xf2;
                    b1.GetTransform(out xf1);
                    b2.GetTransform(out xf2);*/

                    var r1 = { v : FarseerPhysics.Common.MathUtils.Multiply(Bridge.ref(b1.Xf, "R"), Microsoft.Xna.Framework.Vector2.op_Subtraction(this.LocalAnchorA.$clone(), b1.LocalCenter.$clone())) };
                    var r2 = { v : FarseerPhysics.Common.MathUtils.Multiply(Bridge.ref(b2.Xf, "R"), Microsoft.Xna.Framework.Vector2.op_Subtraction(this.LocalAnchorB.$clone(), b2.LocalCenter.$clone())) };

                    var C3 = Microsoft.Xna.Framework.Vector2.op_Subtraction(Microsoft.Xna.Framework.Vector2.op_Subtraction(Microsoft.Xna.Framework.Vector2.op_Addition(b2.Sweep.C.$clone(), r2.v.$clone()), b1.Sweep.C.$clone()), r1.v.$clone());
                    positionError = C3.Length();

                    var invMass1 = b1.InvMass, invMass2 = b2.InvMass;
                    var invI1 = b1.InvI, invI2 = b2.InvI;

                    var k_allowedStretch = 0.049999997;
                    if (C3.LengthSquared() > 0.00249999971) {
                        var u = C3.$clone();
                        u.Normalize();
                        var k = invMass1 + invMass2;
                        System.Diagnostics.Debug.Assert(k > FarseerPhysics.Settings.Epsilon);
                        var m = 1.0 / k;
                        var impulse2 = Microsoft.Xna.Framework.Vector2.op_Multiply$2(m, (Microsoft.Xna.Framework.Vector2.op_UnaryNegation(C3.$clone())));
                        var k_beta = 0.5;
                        b1.Sweep.C = Microsoft.Xna.Framework.Vector2.op_Subtraction(b1.Sweep.C.$clone(), Microsoft.Xna.Framework.Vector2.op_Multiply$2(k_beta * invMass1, impulse2.$clone()));
                        b2.Sweep.C = Microsoft.Xna.Framework.Vector2.op_Addition(b2.Sweep.C.$clone(), Microsoft.Xna.Framework.Vector2.op_Multiply$2(k_beta * invMass2, impulse2.$clone()));

                        C3 = Microsoft.Xna.Framework.Vector2.op_Subtraction(Microsoft.Xna.Framework.Vector2.op_Subtraction(Microsoft.Xna.Framework.Vector2.op_Addition(b2.Sweep.C.$clone(), r2.v.$clone()), b1.Sweep.C.$clone()), r1.v.$clone());
                    }

                    var K1 = { v : new FarseerPhysics.Common.Mat22.$ctor1(new Microsoft.Xna.Framework.Vector2.$ctor2(invMass1 + invMass2, 0.0), new Microsoft.Xna.Framework.Vector2.$ctor2(0.0, invMass1 + invMass2)) };
                    var K2 = { v : new FarseerPhysics.Common.Mat22.$ctor1(new Microsoft.Xna.Framework.Vector2.$ctor2(invI1 * r1.v.Y * r1.v.Y, -invI1 * r1.v.X * r1.v.Y), new Microsoft.Xna.Framework.Vector2.$ctor2(-invI1 * r1.v.X * r1.v.Y, invI1 * r1.v.X * r1.v.X)) };
                    var K3 = { v : new FarseerPhysics.Common.Mat22.$ctor1(new Microsoft.Xna.Framework.Vector2.$ctor2(invI2 * r2.v.Y * r2.v.Y, -invI2 * r2.v.X * r2.v.Y), new Microsoft.Xna.Framework.Vector2.$ctor2(-invI2 * r2.v.X * r2.v.Y, invI2 * r2.v.X * r2.v.X)) };

                    var Ka = { v : new FarseerPhysics.Common.Mat22() };
                    FarseerPhysics.Common.Mat22.Add(K1, K2, Ka);

                    var K = { v : new FarseerPhysics.Common.Mat22() };
                    FarseerPhysics.Common.Mat22.Add(Ka, K3, K);


                    var impulse = { v : K.v.Solve(Microsoft.Xna.Framework.Vector2.op_UnaryNegation(C3.$clone())) };

                    b1.Sweep.C = Microsoft.Xna.Framework.Vector2.op_Subtraction(b1.Sweep.C.$clone(), Microsoft.Xna.Framework.Vector2.op_Multiply$2(b1.InvMass, impulse.v.$clone()));
                    FarseerPhysics.Common.MathUtils.Cross$3(r1, impulse, Bridge.ref(this, "_tmpFloat1"));
                    b1.Sweep.A -= b1.InvI * this._tmpFloat1;

                    b2.Sweep.C = Microsoft.Xna.Framework.Vector2.op_Addition(b2.Sweep.C.$clone(), Microsoft.Xna.Framework.Vector2.op_Multiply$2(b2.InvMass, impulse.v.$clone()));
                    FarseerPhysics.Common.MathUtils.Cross$3(r2, impulse, Bridge.ref(this, "_tmpFloat1"));
                    b2.Sweep.A += b2.InvI * this._tmpFloat1;

                    b1.SynchronizeTransform();
                    b2.SynchronizeTransform();
                }

                return positionError <= FarseerPhysics.Settings.LinearSlop && angularError <= FarseerPhysics.Settings.AngularSlop;
            }
        }
    });

    /**
     * A rope joint enforces a maximum distance between two points
     on two bodies. It has no other effect.
     Warning: if you attempt to change the maximum length during
     the simulation you will get some non-physical behavior.
     A model that would allow you to dynamically modify the length
     would have some sponginess, so I chose not to implement it
     that way. See b2DistanceJoint if you want to dynamically
     control length.
     *
     * @public
     * @class FarseerPhysics.Dynamics.Joints.RopeJoint
     * @augments FarseerPhysics.Dynamics.Joints.Joint
     */
    Bridge.define("FarseerPhysics.Dynamics.Joints.RopeJoint", {
        inherits: [FarseerPhysics.Dynamics.Joints.Joint],
        fields: {
            LocalAnchorA: null,
            LocalAnchorB: null,
            _impulse: 0,
            _length: 0,
            _mass: 0,
            _rA: null,
            _rB: null,
            _state: 0,
            _u: null,
            /**
             * @instance
             * @public
             * @memberof FarseerPhysics.Dynamics.Joints.RopeJoint
             * @function MaxLength
             * @type number
             */
            MaxLength: 0
        },
        props: {
            State: {
                get: function () {
                    return this._state;
                }
            },
            WorldAnchorA: {
                get: function () {
                    return this.BodyA.GetWorldPoint(this.LocalAnchorA.$clone());
                }
            },
            WorldAnchorB: {
                get: function () {
                    return this.BodyB.GetWorldPoint(this.LocalAnchorB.$clone());
                },
                set: function (value) {
                    System.Diagnostics.Debug.Assert$1(false, "You can't set the world anchor on this joint type.");
                }
            }
        },
        ctors: {
            init: function () {
                this.LocalAnchorA = new Microsoft.Xna.Framework.Vector2();
                this.LocalAnchorB = new Microsoft.Xna.Framework.Vector2();
                this._rA = new Microsoft.Xna.Framework.Vector2();
                this._rB = new Microsoft.Xna.Framework.Vector2();
                this._u = new Microsoft.Xna.Framework.Vector2();
            },
            ctor: function () {
                this.$initialize();
                FarseerPhysics.Dynamics.Joints.Joint.ctor.call(this);
                this.JointType = FarseerPhysics.Dynamics.Joints.JointType.Rope;
            },
            $ctor1: function (bodyA, bodyB, localAnchorA, localAnchorB) {
                this.$initialize();
                FarseerPhysics.Dynamics.Joints.Joint.$ctor2.call(this, bodyA, bodyB);
                this.JointType = FarseerPhysics.Dynamics.Joints.JointType.Rope;
                this.LocalAnchorA = localAnchorA.$clone();
                this.LocalAnchorB = localAnchorB.$clone();

                var d = Microsoft.Xna.Framework.Vector2.op_Subtraction(this.WorldAnchorB.$clone(), this.WorldAnchorA.$clone());
                this.MaxLength = d.Length();

                this._mass = 0.0;
                this._impulse = 0.0;
                this._state = FarseerPhysics.Dynamics.Joints.LimitState.Inactive;
                this._length = 0.0;
            }
        },
        methods: {
            GetReactionForce: function (invDt) {
                return Microsoft.Xna.Framework.Vector2.op_Multiply$2((invDt * this._impulse), this._u.$clone());
            },
            GetReactionTorque: function (invDt) {
                return 0;
            },
            InitVelocityConstraints: function (step) {
                var bA = this.BodyA;
                var bB = this.BodyB;

                var xf1 = { v : new FarseerPhysics.Common.Transform() };
                bA.GetTransform(xf1);

                var xf2 = { v : new FarseerPhysics.Common.Transform() };
                bB.GetTransform(xf2);

                this._rA = FarseerPhysics.Common.MathUtils.Multiply(Bridge.ref(xf1.v, "R"), Microsoft.Xna.Framework.Vector2.op_Subtraction(this.LocalAnchorA.$clone(), bA.LocalCenter.$clone()));
                this._rB = FarseerPhysics.Common.MathUtils.Multiply(Bridge.ref(xf2.v, "R"), Microsoft.Xna.Framework.Vector2.op_Subtraction(this.LocalAnchorB.$clone(), bB.LocalCenter.$clone()));

                this._u = Microsoft.Xna.Framework.Vector2.op_Subtraction(Microsoft.Xna.Framework.Vector2.op_Subtraction(Microsoft.Xna.Framework.Vector2.op_Addition(bB.Sweep.C.$clone(), this._rB.$clone()), bA.Sweep.C.$clone()), this._rA.$clone());

                this._length = this._u.Length();

                var C = this._length - this.MaxLength;
                if (C > 0.0) {
                    this._state = FarseerPhysics.Dynamics.Joints.LimitState.AtUpper;
                } else {
                    this._state = FarseerPhysics.Dynamics.Joints.LimitState.Inactive;
                }

                if (this._length > FarseerPhysics.Settings.LinearSlop) {
                    this._u = Microsoft.Xna.Framework.Vector2.op_Multiply$1(this._u.$clone(), 1.0 / this._length);
                } else {
                    this._u = Microsoft.Xna.Framework.Vector2.Zero.$clone();
                    this._mass = 0.0;
                    this._impulse = 0.0;
                    return;
                }

                var crA = FarseerPhysics.Common.MathUtils.Cross$2(this._rA.$clone(), this._u.$clone());
                var crB = FarseerPhysics.Common.MathUtils.Cross$2(this._rB.$clone(), this._u.$clone());
                var invMass = bA.InvMass + bA.InvI * crA * crA + bB.InvMass + bB.InvI * crB * crB;

                this._mass = invMass !== 0.0 ? 1.0 / invMass : 0.0;

                if (FarseerPhysics.Settings.EnableWarmstarting) {
                    this._impulse *= step.v.dtRatio;

                    var P = Microsoft.Xna.Framework.Vector2.op_Multiply$2(this._impulse, this._u.$clone());
                    bA.LinearVelocity = Microsoft.Xna.Framework.Vector2.op_Subtraction(bA.LinearVelocity.$clone(), Microsoft.Xna.Framework.Vector2.op_Multiply$2(bA.InvMass, P.$clone()));
                    bA.AngularVelocity -= bA.InvI * FarseerPhysics.Common.MathUtils.Cross$2(this._rA.$clone(), P.$clone());
                    bB.LinearVelocity = Microsoft.Xna.Framework.Vector2.op_Addition(bB.LinearVelocity.$clone(), Microsoft.Xna.Framework.Vector2.op_Multiply$2(bB.InvMass, P.$clone()));
                    bB.AngularVelocity += bB.InvI * FarseerPhysics.Common.MathUtils.Cross$2(this._rB.$clone(), P.$clone());
                } else {
                    this._impulse = 0.0;
                }
            },
            SolveVelocityConstraints: function (step) {
                var bA = this.BodyA;
                var bB = this.BodyB;

                var vA = Microsoft.Xna.Framework.Vector2.op_Addition(bA.LinearVelocity.$clone(), FarseerPhysics.Common.MathUtils.Cross$1(bA.AngularVelocity, this._rA.$clone()));
                var vB = Microsoft.Xna.Framework.Vector2.op_Addition(bB.LinearVelocity.$clone(), FarseerPhysics.Common.MathUtils.Cross$1(bB.AngularVelocity, this._rB.$clone()));
                var C = this._length - this.MaxLength;
                var Cdot = Microsoft.Xna.Framework.Vector2.Dot(this._u.$clone(), Microsoft.Xna.Framework.Vector2.op_Subtraction(vB.$clone(), vA.$clone()));

                if (C < 0.0) {
                    Cdot += step.v.inv_dt * C;
                }

                var impulse = -this._mass * Cdot;
                var oldImpulse = this._impulse;
                this._impulse = Math.min(0.0, this._impulse + impulse);
                impulse = this._impulse - oldImpulse;

                var P = Microsoft.Xna.Framework.Vector2.op_Multiply$2(impulse, this._u.$clone());
                bA.LinearVelocity = Microsoft.Xna.Framework.Vector2.op_Subtraction(bA.LinearVelocity.$clone(), Microsoft.Xna.Framework.Vector2.op_Multiply$2(bA.InvMass, P.$clone()));
                bA.AngularVelocity -= bA.InvI * FarseerPhysics.Common.MathUtils.Cross$2(this._rA.$clone(), P.$clone());
                bB.LinearVelocity = Microsoft.Xna.Framework.Vector2.op_Addition(bB.LinearVelocity.$clone(), Microsoft.Xna.Framework.Vector2.op_Multiply$2(bB.InvMass, P.$clone()));
                bB.AngularVelocity += bB.InvI * FarseerPhysics.Common.MathUtils.Cross$2(this._rB.$clone(), P.$clone());
            },
            SolvePositionConstraints: function () {
                var bA = this.BodyA;
                var bB = this.BodyB;

                var xf1 = { v : new FarseerPhysics.Common.Transform() };
                bA.GetTransform(xf1);

                var xf2 = { v : new FarseerPhysics.Common.Transform() };
                bB.GetTransform(xf2);

                var rA = FarseerPhysics.Common.MathUtils.Multiply(Bridge.ref(xf1.v, "R"), Microsoft.Xna.Framework.Vector2.op_Subtraction(this.LocalAnchorA.$clone(), bA.LocalCenter.$clone()));
                var rB = FarseerPhysics.Common.MathUtils.Multiply(Bridge.ref(xf2.v, "R"), Microsoft.Xna.Framework.Vector2.op_Subtraction(this.LocalAnchorB.$clone(), bB.LocalCenter.$clone()));

                var u = Microsoft.Xna.Framework.Vector2.op_Subtraction(Microsoft.Xna.Framework.Vector2.op_Subtraction(Microsoft.Xna.Framework.Vector2.op_Addition(bB.Sweep.C.$clone(), rB.$clone()), bA.Sweep.C.$clone()), rA.$clone());


                var length = u.Length();
                u.Normalize();

                var C = length - this.MaxLength;

                C = FarseerPhysics.Common.MathUtils.Clamp$2(C, 0.0, FarseerPhysics.Settings.MaxLinearCorrection);

                var impulse = -this._mass * C;
                var P = Microsoft.Xna.Framework.Vector2.op_Multiply$2(impulse, u.$clone());

                bA.Sweep.C = Microsoft.Xna.Framework.Vector2.op_Subtraction(bA.Sweep.C.$clone(), Microsoft.Xna.Framework.Vector2.op_Multiply$2(bA.InvMass, P.$clone()));
                bA.Sweep.A -= bA.InvI * FarseerPhysics.Common.MathUtils.Cross$2(rA.$clone(), P.$clone());
                bB.Sweep.C = Microsoft.Xna.Framework.Vector2.op_Addition(bB.Sweep.C.$clone(), Microsoft.Xna.Framework.Vector2.op_Multiply$2(bB.InvMass, P.$clone()));
                bB.Sweep.A += bB.InvI * FarseerPhysics.Common.MathUtils.Cross$2(rB.$clone(), P.$clone());

                bA.SynchronizeTransform();
                bB.SynchronizeTransform();

                return length - this.MaxLength < FarseerPhysics.Settings.LinearSlop;
            }
        }
    });

    /**
     * A distance joint contrains two points on two bodies
     to remain at a fixed distance from each other. You can view
     this as a massless, rigid rod.
     *
     * @public
     * @class FarseerPhysics.Dynamics.Joints.SliderJoint
     * @augments FarseerPhysics.Dynamics.Joints.Joint
     */
    Bridge.define("FarseerPhysics.Dynamics.Joints.SliderJoint", {
        inherits: [FarseerPhysics.Dynamics.Joints.Joint],
        fields: {
            LocalAnchorA: null,
            LocalAnchorB: null,
            _bias: 0,
            _gamma: 0,
            _impulse: 0,
            _mass: 0,
            _u: null,
            /**
             * The maximum length between the anchor points.
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Dynamics.Joints.SliderJoint
             * @function MaxLength
             * @type number
             */
            MaxLength: 0,
            /**
             * The minimal length between the anchor points.
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Dynamics.Joints.SliderJoint
             * @function MinLength
             * @type number
             */
            MinLength: 0,
            /**
             * The mass-spring-damper frequency in Hertz.
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Dynamics.Joints.SliderJoint
             * @function Frequency
             * @type number
             */
            Frequency: 0,
            /**
             * The damping ratio. 0 = no damping, 1 = critical damping.
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Dynamics.Joints.SliderJoint
             * @function DampingRatio
             * @type number
             */
            DampingRatio: 0
        },
        props: {
            WorldAnchorA: {
                get: function () {
                    return this.BodyA.GetWorldPoint(this.LocalAnchorA.$clone());
                }
            },
            WorldAnchorB: {
                get: function () {
                    return this.BodyB.GetWorldPoint(this.LocalAnchorB.$clone());
                },
                set: function (value) {
                    System.Diagnostics.Debug.Assert$1(false, "You can't set the world anchor on this joint type.");
                }
            }
        },
        ctors: {
            init: function () {
                this.LocalAnchorA = new Microsoft.Xna.Framework.Vector2();
                this.LocalAnchorB = new Microsoft.Xna.Framework.Vector2();
                this._u = new Microsoft.Xna.Framework.Vector2();
            },
            ctor: function () {
                this.$initialize();
                FarseerPhysics.Dynamics.Joints.Joint.ctor.call(this);
                this.JointType = FarseerPhysics.Dynamics.Joints.JointType.Slider;
            },
            /**
             * Initializes a new instance of the {@link } class.
             Warning: Do not use a zero or short length.
             *
             * @instance
             * @public
             * @this FarseerPhysics.Dynamics.Joints.SliderJoint
             * @memberof FarseerPhysics.Dynamics.Joints.SliderJoint
             * @param   {FarseerPhysics.Dynamics.Body}       bodyA           The first body.
             * @param   {FarseerPhysics.Dynamics.Body}       bodyB           The second body.
             * @param   {Microsoft.Xna.Framework.Vector2}    localAnchorA    The first body anchor.
             * @param   {Microsoft.Xna.Framework.Vector2}    localAnchorB    The second body anchor.
             * @param   {number}                             minLength       The minimum length between anchorpoints
             * @param   {number}                             maxlength       The maximum length between anchorpoints.
             * @return  {void}
             */
            $ctor1: function (bodyA, bodyB, localAnchorA, localAnchorB, minLength, maxlength) {
                this.$initialize();
                FarseerPhysics.Dynamics.Joints.Joint.$ctor2.call(this, bodyA, bodyB);
                this.JointType = FarseerPhysics.Dynamics.Joints.JointType.Slider;

                this.LocalAnchorA = localAnchorA.$clone();
                this.LocalAnchorB = localAnchorB.$clone();
                this.MaxLength = maxlength;
                this.MinLength = minLength;
            }
        },
        methods: {
            GetReactionForce: function (inv_dt) {
                var F = Microsoft.Xna.Framework.Vector2.op_Multiply$2((inv_dt * this._impulse), this._u.$clone());
                return F.$clone();
            },
            GetReactionTorque: function (inv_dt) {
                return 0.0;
            },
            InitVelocityConstraints: function (step) {
                var b1 = this.BodyA;
                var b2 = this.BodyB;

                var xf1 = { v : new FarseerPhysics.Common.Transform() }, xf2 = { v : new FarseerPhysics.Common.Transform() };
                b1.GetTransform(xf1);
                b2.GetTransform(xf2);

                var r1 = FarseerPhysics.Common.MathUtils.Multiply(Bridge.ref(xf1.v, "R"), Microsoft.Xna.Framework.Vector2.op_Subtraction(this.LocalAnchorA.$clone(), b1.LocalCenter.$clone()));
                var r2 = FarseerPhysics.Common.MathUtils.Multiply(Bridge.ref(xf2.v, "R"), Microsoft.Xna.Framework.Vector2.op_Subtraction(this.LocalAnchorB.$clone(), b2.LocalCenter.$clone()));
                this._u = Microsoft.Xna.Framework.Vector2.op_Subtraction(Microsoft.Xna.Framework.Vector2.op_Subtraction(Microsoft.Xna.Framework.Vector2.op_Addition(b2.Sweep.C.$clone(), r2.$clone()), b1.Sweep.C.$clone()), r1.$clone());

                var length = this._u.Length();

                if (length < this.MaxLength && length > this.MinLength) {
                    return;
                }

                if (length > FarseerPhysics.Settings.LinearSlop) {
                    this._u = Microsoft.Xna.Framework.Vector2.op_Multiply$1(this._u.$clone(), 1.0 / length);
                } else {
                    this._u = Microsoft.Xna.Framework.Vector2.Zero.$clone();
                }

                var cr1u = FarseerPhysics.Common.MathUtils.Cross$2(r1.$clone(), this._u.$clone());
                var cr2u = FarseerPhysics.Common.MathUtils.Cross$2(r2.$clone(), this._u.$clone());
                var invMass = b1.InvMass + b1.InvI * cr1u * cr1u + b2.InvMass + b2.InvI * cr2u * cr2u;
                System.Diagnostics.Debug.Assert(invMass > FarseerPhysics.Settings.Epsilon);
                this._mass = invMass !== 0.0 ? 1.0 / invMass : 0.0;

                if (this.Frequency > 0.0) {
                    var C = length - this.MaxLength;

                    var omega = 6.28318548 * this.Frequency;

                    var d = 2.0 * this._mass * this.DampingRatio * omega;

                    var k = this._mass * omega * omega;

                    this._gamma = step.v.dt * (d + step.v.dt * k);
                    this._gamma = this._gamma !== 0.0 ? 1.0 / this._gamma : 0.0;
                    this._bias = C * step.v.dt * k * this._gamma;

                    this._mass = invMass + this._gamma;
                    this._mass = this._mass !== 0.0 ? 1.0 / this._mass : 0.0;
                }

                if (FarseerPhysics.Settings.EnableWarmstarting) {
                    this._impulse *= step.v.dtRatio;

                    var P = Microsoft.Xna.Framework.Vector2.op_Multiply$2(this._impulse, this._u.$clone());
                    b1.LinearVelocityInternal = Microsoft.Xna.Framework.Vector2.op_Subtraction(b1.LinearVelocityInternal.$clone(), Microsoft.Xna.Framework.Vector2.op_Multiply$2(b1.InvMass, P.$clone()));
                    b1.AngularVelocityInternal -= b1.InvI * FarseerPhysics.Common.MathUtils.Cross$2(r1.$clone(), P.$clone());
                    b2.LinearVelocityInternal = Microsoft.Xna.Framework.Vector2.op_Addition(b2.LinearVelocityInternal.$clone(), Microsoft.Xna.Framework.Vector2.op_Multiply$2(b2.InvMass, P.$clone()));
                    b2.AngularVelocityInternal += b2.InvI * FarseerPhysics.Common.MathUtils.Cross$2(r2.$clone(), P.$clone());
                } else {
                    this._impulse = 0.0;
                }
            },
            SolveVelocityConstraints: function (step) {
                var b1 = this.BodyA;
                var b2 = this.BodyB;

                var xf1 = { v : new FarseerPhysics.Common.Transform() }, xf2 = { v : new FarseerPhysics.Common.Transform() };
                b1.GetTransform(xf1);
                b2.GetTransform(xf2);

                var r1 = FarseerPhysics.Common.MathUtils.Multiply(Bridge.ref(xf1.v, "R"), Microsoft.Xna.Framework.Vector2.op_Subtraction(this.LocalAnchorA.$clone(), b1.LocalCenter.$clone()));
                var r2 = FarseerPhysics.Common.MathUtils.Multiply(Bridge.ref(xf2.v, "R"), Microsoft.Xna.Framework.Vector2.op_Subtraction(this.LocalAnchorB.$clone(), b2.LocalCenter.$clone()));

                var d = Microsoft.Xna.Framework.Vector2.op_Subtraction(Microsoft.Xna.Framework.Vector2.op_Subtraction(Microsoft.Xna.Framework.Vector2.op_Addition(b2.Sweep.C.$clone(), r2.$clone()), b1.Sweep.C.$clone()), r1.$clone());

                var length = d.Length();

                if (length < this.MaxLength && length > this.MinLength) {
                    return;
                }

                var v1 = Microsoft.Xna.Framework.Vector2.op_Addition(b1.LinearVelocityInternal.$clone(), FarseerPhysics.Common.MathUtils.Cross$1(b1.AngularVelocityInternal, r1.$clone()));
                var v2 = Microsoft.Xna.Framework.Vector2.op_Addition(b2.LinearVelocityInternal.$clone(), FarseerPhysics.Common.MathUtils.Cross$1(b2.AngularVelocityInternal, r2.$clone()));
                var Cdot = Microsoft.Xna.Framework.Vector2.Dot(this._u.$clone(), Microsoft.Xna.Framework.Vector2.op_Subtraction(v2.$clone(), v1.$clone()));

                var impulse = -this._mass * (Cdot + this._bias + this._gamma * this._impulse);
                this._impulse += impulse;

                var P = Microsoft.Xna.Framework.Vector2.op_Multiply$2(impulse, this._u.$clone());
                b1.LinearVelocityInternal = Microsoft.Xna.Framework.Vector2.op_Subtraction(b1.LinearVelocityInternal.$clone(), Microsoft.Xna.Framework.Vector2.op_Multiply$2(b1.InvMass, P.$clone()));
                b1.AngularVelocityInternal -= b1.InvI * FarseerPhysics.Common.MathUtils.Cross$2(r1.$clone(), P.$clone());
                b2.LinearVelocityInternal = Microsoft.Xna.Framework.Vector2.op_Addition(b2.LinearVelocityInternal.$clone(), Microsoft.Xna.Framework.Vector2.op_Multiply$2(b2.InvMass, P.$clone()));
                b2.AngularVelocityInternal += b2.InvI * FarseerPhysics.Common.MathUtils.Cross$2(r2.$clone(), P.$clone());
            },
            SolvePositionConstraints: function () {
                if (this.Frequency > 0.0) {
                    return true;
                }

                var b1 = this.BodyA;
                var b2 = this.BodyB;

                var xf1 = { v : new FarseerPhysics.Common.Transform() }, xf2 = { v : new FarseerPhysics.Common.Transform() };
                b1.GetTransform(xf1);
                b2.GetTransform(xf2);

                var r1 = FarseerPhysics.Common.MathUtils.Multiply(Bridge.ref(xf1.v, "R"), Microsoft.Xna.Framework.Vector2.op_Subtraction(this.LocalAnchorA.$clone(), b1.LocalCenter.$clone()));
                var r2 = FarseerPhysics.Common.MathUtils.Multiply(Bridge.ref(xf2.v, "R"), Microsoft.Xna.Framework.Vector2.op_Subtraction(this.LocalAnchorB.$clone(), b2.LocalCenter.$clone()));

                var d = Microsoft.Xna.Framework.Vector2.op_Subtraction(Microsoft.Xna.Framework.Vector2.op_Subtraction(Microsoft.Xna.Framework.Vector2.op_Addition(b2.Sweep.C.$clone(), r2.$clone()), b1.Sweep.C.$clone()), r1.$clone());

                var length = d.Length();

                if (length < this.MaxLength && length > this.MinLength) {
                    return true;
                }

                if (length === 0.0) {
                    return true;
                }

                d = Microsoft.Xna.Framework.Vector2.op_Division$1(d.$clone(), length);
                var C = length - this.MaxLength;
                C = FarseerPhysics.Common.MathUtils.Clamp$2(C, -0.2, FarseerPhysics.Settings.MaxLinearCorrection);

                var impulse = -this._mass * C;
                this._u = d.$clone();
                var P = Microsoft.Xna.Framework.Vector2.op_Multiply$2(impulse, this._u.$clone());

                b1.Sweep.C = Microsoft.Xna.Framework.Vector2.op_Subtraction(b1.Sweep.C.$clone(), Microsoft.Xna.Framework.Vector2.op_Multiply$2(b1.InvMass, P.$clone()));
                b1.Sweep.A -= b1.InvI * FarseerPhysics.Common.MathUtils.Cross$2(r1.$clone(), P.$clone());
                b2.Sweep.C = Microsoft.Xna.Framework.Vector2.op_Addition(b2.Sweep.C.$clone(), Microsoft.Xna.Framework.Vector2.op_Multiply$2(b2.InvMass, P.$clone()));
                b2.Sweep.A += b2.InvI * FarseerPhysics.Common.MathUtils.Cross$2(r2.$clone(), P.$clone());

                b1.SynchronizeTransform();
                b2.SynchronizeTransform();

                return Math.abs(C) < FarseerPhysics.Settings.LinearSlop;
            }
        }
    });

    /**
     * A weld joint essentially glues two bodies together. A weld joint may
     distort somewhat because the island constraint solver is approximate.
     *
     * @public
     * @class FarseerPhysics.Dynamics.Joints.WeldJoint
     * @augments FarseerPhysics.Dynamics.Joints.Joint
     */
    Bridge.define("FarseerPhysics.Dynamics.Joints.WeldJoint", {
        inherits: [FarseerPhysics.Dynamics.Joints.Joint],
        fields: {
            LocalAnchorA: null,
            LocalAnchorB: null,
            _impulse: null,
            _mass: null,
            /**
             * The body2 angle minus body1 angle in the reference state (radians).
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Dynamics.Joints.WeldJoint
             * @function ReferenceAngle
             * @type number
             */
            ReferenceAngle: 0
        },
        props: {
            WorldAnchorA: {
                get: function () {
                    return this.BodyA.GetWorldPoint(this.LocalAnchorA.$clone());
                }
            },
            WorldAnchorB: {
                get: function () {
                    return this.BodyB.GetWorldPoint(this.LocalAnchorB.$clone());
                },
                set: function (value) {
                    System.Diagnostics.Debug.Assert$1(false, "You can't set the world anchor on this joint type.");
                }
            }
        },
        ctors: {
            init: function () {
                this.LocalAnchorA = new Microsoft.Xna.Framework.Vector2();
                this.LocalAnchorB = new Microsoft.Xna.Framework.Vector2();
                this._impulse = new Microsoft.Xna.Framework.Vector3();
                this._mass = new FarseerPhysics.Common.Mat33();
            },
            ctor: function () {
                this.$initialize();
                FarseerPhysics.Dynamics.Joints.Joint.ctor.call(this);
                this.JointType = FarseerPhysics.Dynamics.Joints.JointType.Weld;
            },
            /**
             * You need to specify a local anchor point
             where they are attached and the relative body angle. The position
             of the anchor point is important for computing the reaction torque.
             You can change the anchor points relative to bodyA or bodyB by changing LocalAnchorA
             and/or LocalAnchorB.
             *
             * @instance
             * @public
             * @this FarseerPhysics.Dynamics.Joints.WeldJoint
             * @memberof FarseerPhysics.Dynamics.Joints.WeldJoint
             * @param   {FarseerPhysics.Dynamics.Body}       bodyA           The first body
             * @param   {FarseerPhysics.Dynamics.Body}       bodyB           The second body
             * @param   {Microsoft.Xna.Framework.Vector2}    localAnchorA    The first body anchor.
             * @param   {Microsoft.Xna.Framework.Vector2}    localAnchorB    The second body anchor.
             * @return  {void}
             */
            $ctor1: function (bodyA, bodyB, localAnchorA, localAnchorB) {
                this.$initialize();
                FarseerPhysics.Dynamics.Joints.Joint.$ctor2.call(this, bodyA, bodyB);
                this.JointType = FarseerPhysics.Dynamics.Joints.JointType.Weld;

                this.LocalAnchorA = localAnchorA.$clone();
                this.LocalAnchorB = localAnchorB.$clone();
                this.ReferenceAngle = this.BodyB.Rotation - this.BodyA.Rotation;
            }
        },
        methods: {
            GetReactionForce: function (inv_dt) {
                return Microsoft.Xna.Framework.Vector2.op_Multiply$2(inv_dt, new Microsoft.Xna.Framework.Vector2.$ctor2(this._impulse.X, this._impulse.Y));
            },
            GetReactionTorque: function (inv_dt) {
                return inv_dt * this._impulse.Z;
            },
            InitVelocityConstraints: function (step) {
                var bA = this.BodyA;
                var bB = this.BodyB;

                var xfA = { v : new FarseerPhysics.Common.Transform() }, xfB = { v : new FarseerPhysics.Common.Transform() };
                bA.GetTransform(xfA);
                bB.GetTransform(xfB);

                var rA = FarseerPhysics.Common.MathUtils.Multiply(Bridge.ref(xfA.v, "R"), Microsoft.Xna.Framework.Vector2.op_Subtraction(this.LocalAnchorA.$clone(), bA.LocalCenter.$clone()));
                var rB = FarseerPhysics.Common.MathUtils.Multiply(Bridge.ref(xfB.v, "R"), Microsoft.Xna.Framework.Vector2.op_Subtraction(this.LocalAnchorB.$clone(), bB.LocalCenter.$clone()));



                var mA = bA.InvMass, mB = bB.InvMass;
                var iA = bA.InvI, iB = bB.InvI;

                this._mass.Col1.X = mA + mB + rA.Y * rA.Y * iA + rB.Y * rB.Y * iB;
                this._mass.Col2.X = -rA.Y * rA.X * iA - rB.Y * rB.X * iB;
                this._mass.Col3.X = -rA.Y * iA - rB.Y * iB;
                this._mass.Col1.Y = this._mass.Col2.X;
                this._mass.Col2.Y = mA + mB + rA.X * rA.X * iA + rB.X * rB.X * iB;
                this._mass.Col3.Y = rA.X * iA + rB.X * iB;
                this._mass.Col1.Z = this._mass.Col3.X;
                this._mass.Col2.Z = this._mass.Col3.Y;
                this._mass.Col3.Z = iA + iB;

                if (FarseerPhysics.Settings.EnableWarmstarting) {
                    this._impulse = Microsoft.Xna.Framework.Vector3.op_Multiply$1(this._impulse.$clone(), step.v.dtRatio);

                    var P = new Microsoft.Xna.Framework.Vector2.$ctor2(this._impulse.X, this._impulse.Y);

                    bA.LinearVelocityInternal = Microsoft.Xna.Framework.Vector2.op_Subtraction(bA.LinearVelocityInternal.$clone(), Microsoft.Xna.Framework.Vector2.op_Multiply$2(mA, P.$clone()));
                    bA.AngularVelocityInternal -= iA * (FarseerPhysics.Common.MathUtils.Cross$2(rA.$clone(), P.$clone()) + this._impulse.Z);

                    bB.LinearVelocityInternal = Microsoft.Xna.Framework.Vector2.op_Addition(bB.LinearVelocityInternal.$clone(), Microsoft.Xna.Framework.Vector2.op_Multiply$2(mB, P.$clone()));
                    bB.AngularVelocityInternal += iB * (FarseerPhysics.Common.MathUtils.Cross$2(rB.$clone(), P.$clone()) + this._impulse.Z);
                } else {
                    this._impulse = Microsoft.Xna.Framework.Vector3.Zero.$clone();
                }
            },
            SolveVelocityConstraints: function (step) {
                var bA = this.BodyA;
                var bB = this.BodyB;

                var vA = bA.LinearVelocityInternal.$clone();
                var wA = bA.AngularVelocityInternal;
                var vB = bB.LinearVelocityInternal.$clone();
                var wB = bB.AngularVelocityInternal;

                var mA = bA.InvMass, mB = bB.InvMass;
                var iA = bA.InvI, iB = bB.InvI;

                var xfA = { v : new FarseerPhysics.Common.Transform() }, xfB = { v : new FarseerPhysics.Common.Transform() };
                bA.GetTransform(xfA);
                bB.GetTransform(xfB);

                var rA = FarseerPhysics.Common.MathUtils.Multiply(Bridge.ref(xfA.v, "R"), Microsoft.Xna.Framework.Vector2.op_Subtraction(this.LocalAnchorA.$clone(), bA.LocalCenter.$clone()));
                var rB = FarseerPhysics.Common.MathUtils.Multiply(Bridge.ref(xfB.v, "R"), Microsoft.Xna.Framework.Vector2.op_Subtraction(this.LocalAnchorB.$clone(), bB.LocalCenter.$clone()));

                var Cdot1 = Microsoft.Xna.Framework.Vector2.op_Subtraction(Microsoft.Xna.Framework.Vector2.op_Subtraction(Microsoft.Xna.Framework.Vector2.op_Addition(vB.$clone(), FarseerPhysics.Common.MathUtils.Cross$1(wB, rB.$clone())), vA.$clone()), FarseerPhysics.Common.MathUtils.Cross$1(wA, rA.$clone()));
                var Cdot2 = wB - wA;
                var Cdot = new Microsoft.Xna.Framework.Vector3.$ctor3(Cdot1.X, Cdot1.Y, Cdot2);

                var impulse = this._mass.Solve33(Microsoft.Xna.Framework.Vector3.op_UnaryNegation(Cdot.$clone()));
                this._impulse = Microsoft.Xna.Framework.Vector3.op_Addition(this._impulse.$clone(), impulse.$clone());

                var P = new Microsoft.Xna.Framework.Vector2.$ctor2(impulse.X, impulse.Y);

                vA = Microsoft.Xna.Framework.Vector2.op_Subtraction(vA.$clone(), Microsoft.Xna.Framework.Vector2.op_Multiply$2(mA, P.$clone()));
                wA -= iA * (FarseerPhysics.Common.MathUtils.Cross$2(rA.$clone(), P.$clone()) + impulse.Z);

                vB = Microsoft.Xna.Framework.Vector2.op_Addition(vB.$clone(), Microsoft.Xna.Framework.Vector2.op_Multiply$2(mB, P.$clone()));
                wB += iB * (FarseerPhysics.Common.MathUtils.Cross$2(rB.$clone(), P.$clone()) + impulse.Z);

                bA.LinearVelocityInternal = vA.$clone();
                bA.AngularVelocityInternal = wA;
                bB.LinearVelocityInternal = vB.$clone();
                bB.AngularVelocityInternal = wB;
            },
            SolvePositionConstraints: function () {
                var bA = this.BodyA;
                var bB = this.BodyB;

                var mA = bA.InvMass, mB = bB.InvMass;
                var iA = bA.InvI, iB = bB.InvI;

                var xfA = { v : new FarseerPhysics.Common.Transform() };
                var xfB = { v : new FarseerPhysics.Common.Transform() };
                bA.GetTransform(xfA);
                bB.GetTransform(xfB);

                var rA = FarseerPhysics.Common.MathUtils.Multiply(Bridge.ref(xfA.v, "R"), Microsoft.Xna.Framework.Vector2.op_Subtraction(this.LocalAnchorA.$clone(), bA.LocalCenter.$clone()));
                var rB = FarseerPhysics.Common.MathUtils.Multiply(Bridge.ref(xfB.v, "R"), Microsoft.Xna.Framework.Vector2.op_Subtraction(this.LocalAnchorB.$clone(), bB.LocalCenter.$clone()));

                var C1 = Microsoft.Xna.Framework.Vector2.op_Subtraction(Microsoft.Xna.Framework.Vector2.op_Subtraction(Microsoft.Xna.Framework.Vector2.op_Addition(bB.Sweep.C.$clone(), rB.$clone()), bA.Sweep.C.$clone()), rA.$clone());
                var C2 = bB.Sweep.A - bA.Sweep.A - this.ReferenceAngle;

                var k_allowedStretch = 0.049999997;
                var positionError = C1.Length();
                var angularError = Math.abs(C2);
                if (positionError > k_allowedStretch) {
                    iA *= 1.0;
                    iB *= 1.0;
                }

                this._mass.Col1.X = mA + mB + rA.Y * rA.Y * iA + rB.Y * rB.Y * iB;
                this._mass.Col2.X = -rA.Y * rA.X * iA - rB.Y * rB.X * iB;
                this._mass.Col3.X = -rA.Y * iA - rB.Y * iB;
                this._mass.Col1.Y = this._mass.Col2.X;
                this._mass.Col2.Y = mA + mB + rA.X * rA.X * iA + rB.X * rB.X * iB;
                this._mass.Col3.Y = rA.X * iA + rB.X * iB;
                this._mass.Col1.Z = this._mass.Col3.X;
                this._mass.Col2.Z = this._mass.Col3.Y;
                this._mass.Col3.Z = iA + iB;

                var C = new Microsoft.Xna.Framework.Vector3.$ctor3(C1.X, C1.Y, C2);

                var impulse = this._mass.Solve33(Microsoft.Xna.Framework.Vector3.op_UnaryNegation(C.$clone()));

                var P = new Microsoft.Xna.Framework.Vector2.$ctor2(impulse.X, impulse.Y);

                bA.Sweep.C = Microsoft.Xna.Framework.Vector2.op_Subtraction(bA.Sweep.C.$clone(), Microsoft.Xna.Framework.Vector2.op_Multiply$2(mA, P.$clone()));
                bA.Sweep.A -= iA * (FarseerPhysics.Common.MathUtils.Cross$2(rA.$clone(), P.$clone()) + impulse.Z);

                bB.Sweep.C = Microsoft.Xna.Framework.Vector2.op_Addition(bB.Sweep.C.$clone(), Microsoft.Xna.Framework.Vector2.op_Multiply$2(mB, P.$clone()));
                bB.Sweep.A += iB * (FarseerPhysics.Common.MathUtils.Cross$2(rB.$clone(), P.$clone()) + impulse.Z);

                bA.SynchronizeTransform();
                bB.SynchronizeTransform();

                return positionError <= FarseerPhysics.Settings.LinearSlop && angularError <= FarseerPhysics.Settings.AngularSlop;
            }
        }
    });

    Bridge.define("FarseerPhysics.Utility.PhysicsGameScreen", {
        inherits: [FarseerPhysics.Utility.GameScreen],
        fields: {
            Camera: null,
            World: null,
            _agentForce: 0,
            _agentTorque: 0,
            _fixedMouseJoint: null,
            _userAgent: null,
            EnableCameraControl: false
        },
        ctors: {
            ctor: function (screenManager) {
                this.$initialize();
                FarseerPhysics.Utility.GameScreen.ctor.call(this);
                this.HasCursor = true;
                this.EnableCameraControl = true;
                this._userAgent = null;
                this.World = null;
                this.Camera = null;

                this.ScreenManager = screenManager;
                FarseerPhysics.Settings.EnableDiagnostics = true;

                if (this.World == null) {
                    this.World = new FarseerPhysics.Dynamics.World.$ctor1(Microsoft.Xna.Framework.Vector2.Zero.$clone());
                } else {
                    this.World.Clear();
                }

                if (this.Camera == null) {
                    this.Camera = new FarseerPhysics.Utility.Camera2D(screenManager.GraphicsDevice);
                } else {
                    this.Camera.ResetCamera();
                }

            }
        },
        methods: {
            SetUserAgent: function (agent, force, torque) {
                this._userAgent = agent;
                this._agentForce = force;
                this._agentTorque = torque;
            },
            LoadContent: function () {
                FarseerPhysics.Utility.GameScreen.prototype.LoadContent.call(this);
            },
            Update: function (gameTime, otherScreenHasFocus, coveredByOtherScreen) {
                if (!coveredByOtherScreen && !otherScreenHasFocus) {
                    this.World.Step(Math.min(gameTime.ElapsedGameTime.getTotalSeconds(), (0.02)));
                } else {
                    this.World.Step(0.0);
                }
                this.Camera.Update(gameTime);
                FarseerPhysics.Utility.GameScreen.prototype.Update.call(this, gameTime, otherScreenHasFocus, coveredByOtherScreen);
            },
            Draw: function (gameTime) {
                var projection = this.Camera.SimProjection.$clone();
                var view = this.Camera.SimView.$clone();

                FarseerPhysics.Utility.GameScreen.prototype.Draw.call(this, gameTime);
            }
        }
    });

    Bridge.define("Poly2Tri.Triangulation.Delaunay.Sweep.DTSweepConstraint", {
        inherits: [Poly2Tri.Triangulation.TriangulationConstraint],
        ctors: {
            /**
             * Give two points in any order. Will always be ordered so
             that q.y &gt; p.y and q.x &gt; p.x if same y value
             *
             * @instance
             * @public
             * @this Poly2Tri.Triangulation.Delaunay.Sweep.DTSweepConstraint
             * @memberof Poly2Tri.Triangulation.Delaunay.Sweep.DTSweepConstraint
             * @param   {Poly2Tri.Triangulation.TriangulationPoint}    p1    
             * @param   {Poly2Tri.Triangulation.TriangulationPoint}    p2
             * @return  {void}
             */
            ctor: function (p1, p2) {
                this.$initialize();
                Poly2Tri.Triangulation.TriangulationConstraint.ctor.call(this);
                this.P = p1;
                this.Q = p2;
                if (p1.Y > p2.Y) {
                    this.Q = p1;
                    this.P = p2;
                } else if (p1.Y === p2.Y) {
                    if (p1.X > p2.X) {
                        this.Q = p1;
                        this.P = p2;
                    } else if (p1.X === p2.X) {
                    }
                }
                this.Q.AddEdge(this);
            }
        }
    });

    Bridge.define("Poly2Tri.Triangulation.Delaunay.Sweep.DTSweepContext", {
        inherits: [Poly2Tri.Triangulation.TriangulationContext],
        statics: {
            fields: {
                ALPHA: 0
            },
            ctors: {
                init: function () {
                    this.ALPHA = 0.3;
                }
            }
        },
        fields: {
            Basin: null,
            EdgeEvent: null,
            _comparator: null,
            aFront: null,
            Head: null,
            Tail: null
        },
        ctors: {
            init: function () {
                this.Basin = new Poly2Tri.Triangulation.Delaunay.Sweep.DTSweepContext.DTSweepBasin();
                this.EdgeEvent = new Poly2Tri.Triangulation.Delaunay.Sweep.DTSweepContext.DTSweepEdgeEvent();
                this._comparator = new Poly2Tri.Triangulation.Delaunay.Sweep.DTSweepPointComparator();
            },
            ctor: function () {
                this.$initialize();
                Poly2Tri.Triangulation.TriangulationContext.ctor.call(this);
                this.Clear();
            }
        },
        methods: {
            RemoveFromList: function (triangle) {
                this.Triangles.remove(triangle);
            },
            MeshClean: function (triangle) {
                this.MeshCleanReq(triangle);
            },
            MeshCleanReq: function (triangle) {
                if (triangle != null && !triangle.IsInterior) {
                    triangle.IsInterior = true;
                    this.Triangulatable.Poly2Tri$Triangulation$Triangulatable$AddTriangle(triangle);
                    for (var i = 0; i < 3; i = (i + 1) | 0) {
                        if (!triangle.EdgeIsConstrained.getItem(i)) {
                            this.MeshCleanReq(triangle.Neighbors.getItem(i));
                        }
                    }
                }
            },
            Clear: function () {
                Poly2Tri.Triangulation.TriangulationContext.prototype.Clear.call(this);
                this.Triangles.clear();
            },
            AddNode: function (node) {
                this.aFront.AddNode(node);
            },
            RemoveNode: function (node) {
                this.aFront.RemoveNode(node);
            },
            LocateNode: function (point) {
                return this.aFront.LocateNode(point);
            },
            CreateAdvancingFront: function () {
                var head, tail, middle;
                var iTriangle = new Poly2Tri.Triangulation.Delaunay.DelaunayTriangle(this.Points.getItem(0), this.Tail, this.Head);
                this.Triangles.add(iTriangle);

                head = new Poly2Tri.Triangulation.Delaunay.Sweep.AdvancingFrontNode(iTriangle.Points.getItem(1));
                head.Triangle = iTriangle;
                middle = new Poly2Tri.Triangulation.Delaunay.Sweep.AdvancingFrontNode(iTriangle.Points.getItem(0));
                middle.Triangle = iTriangle;
                tail = new Poly2Tri.Triangulation.Delaunay.Sweep.AdvancingFrontNode(iTriangle.Points.getItem(2));

                this.aFront = new Poly2Tri.Triangulation.Delaunay.Sweep.AdvancingFront(head, tail);
                this.aFront.AddNode(middle);

                this.aFront.Head.Next = middle;
                middle.Next = this.aFront.Tail;
                middle.Prev = this.aFront.Head;
                this.aFront.Tail.Prev = middle;
            },
            /**
             * Try to map a node to all sides of this triangle that don't have 
             a neighbor.
             *
             * @instance
             * @public
             * @this Poly2Tri.Triangulation.Delaunay.Sweep.DTSweepContext
             * @memberof Poly2Tri.Triangulation.Delaunay.Sweep.DTSweepContext
             * @param   {Poly2Tri.Triangulation.Delaunay.DelaunayTriangle}    t
             * @return  {void}
             */
            MapTriangleToNodes: function (t) {
                var n;
                for (var i = 0; i < 3; i = (i + 1) | 0) {
                    if (t.Neighbors.getItem(i) == null) {
                        n = this.aFront.LocatePoint(t.PointCW(t.Points.getItem(i)));
                        if (n != null) {
                            n.Triangle = t;
                        }
                    }
                }
            },
            PrepareTriangulation: function (t) {
                var $t;
                Poly2Tri.Triangulation.TriangulationContext.prototype.PrepareTriangulation.call(this, t);

                var xmax, xmin;
                var ymax, ymin;

                xmax = (xmin = this.Points.getItem(0).X);
                ymax = (ymin = this.Points.getItem(0).Y);

                $t = Bridge.getEnumerator(this.Points);
                try {
                    while ($t.moveNext()) {
                        var p = $t.Current;
                        if (p.X > xmax) {
                            xmax = p.X;
                        }
                        if (p.X < xmin) {
                            xmin = p.X;
                        }
                        if (p.Y > ymax) {
                            ymax = p.Y;
                        }
                        if (p.Y < ymin) {
                            ymin = p.Y;
                        }
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }
                var deltaX = Poly2Tri.Triangulation.Delaunay.Sweep.DTSweepContext.ALPHA * (xmax - xmin);
                var deltaY = Poly2Tri.Triangulation.Delaunay.Sweep.DTSweepContext.ALPHA * (ymax - ymin);
                var p1 = new Poly2Tri.Triangulation.TriangulationPoint(xmax + deltaX, ymin - deltaY);
                var p2 = new Poly2Tri.Triangulation.TriangulationPoint(xmin - deltaX, ymin - deltaY);

                this.Head = p1;
                this.Tail = p2;

                this.Points.Sort$1(this._comparator);
            },
            FinalizeTriangulation: function () {
                this.Triangulatable.Poly2Tri$Triangulation$Triangulatable$AddTriangles(this.Triangles);
                this.Triangles.clear();
            },
            NewConstraint: function (a, b) {
                return new Poly2Tri.Triangulation.Delaunay.Sweep.DTSweepConstraint(a, b);
            }
        }
    });

    Bridge.define("Poly2Tri.Triangulation.Delaunay.Sweep.DTSweepPointComparator", {
        inherits: [System.Collections.Generic.IComparer$1(Poly2Tri.Triangulation.TriangulationPoint)],
        alias: ["compare", ["System$Collections$Generic$IComparer$1$Poly2Tri$Triangulation$TriangulationPoint$compare", "System$Collections$Generic$IComparer$1$compare"]],
        methods: {
            compare: function (p1, p2) {
                if (p1.Y < p2.Y) {
                    return -1;
                } else if (p1.Y > p2.Y) {
                    return 1;
                } else {
                    if (p1.X < p2.X) {
                        return -1;
                    } else if (p1.X > p2.X) {
                        return 1;
                    } else {
                        return 0;
                    }
                }
            }
        }
    });

    Bridge.define("Poly2Tri.Triangulation.Polygon.Polygon", {
        inherits: [Poly2Tri.Triangulation.Triangulatable],
        fields: {
            _holes: null,
            _last: null,
            _points: null,
            _steinerPoints: null,
            _triangles: null
        },
        props: {
            Holes: {
                get: function () {
                    return this._holes;
                }
            },
            TriangulationMode: {
                get: function () {
                    return Poly2Tri.Triangulation.TriangulationMode.Polygon;
                }
            },
            Points: {
                get: function () {
                    return this._points;
                }
            },
            Triangles: {
                get: function () {
                    return this._triangles;
                }
            }
        },
        alias: [
            "TriangulationMode", "Poly2Tri$Triangulation$Triangulatable$TriangulationMode",
            "Points", "Poly2Tri$Triangulation$Triangulatable$Points",
            "Triangles", "Poly2Tri$Triangulation$Triangulatable$Triangles",
            "AddTriangle", "Poly2Tri$Triangulation$Triangulatable$AddTriangle",
            "AddTriangles", "Poly2Tri$Triangulation$Triangulatable$AddTriangles",
            "ClearTriangles", "Poly2Tri$Triangulation$Triangulatable$ClearTriangles",
            "PrepareTriangulation", "Poly2Tri$Triangulation$Triangulatable$PrepareTriangulation"
        ],
        ctors: {
            init: function () {
                this._points = new (System.Collections.Generic.List$1(Poly2Tri.Triangulation.TriangulationPoint)).ctor();
            },
            /**
             * Create a polygon from a list of at least 3 points with no duplicates.
             *
             * @instance
             * @public
             * @this Poly2Tri.Triangulation.Polygon.Polygon
             * @memberof Poly2Tri.Triangulation.Polygon.Polygon
             * @param   {System.Collections.Generic.IList$1}    points    A list of unique points
             * @return  {void}
             */
            $ctor2: function (points) {
                this.$initialize();
                if (System.Array.getCount(points, Poly2Tri.Triangulation.Polygon.PolygonPoint) < 3) {
                    throw new System.ArgumentException.$ctor3("List has fewer than 3 points", "points");
                }

                if (Bridge.equals(System.Array.getItem(points, 0, Poly2Tri.Triangulation.Polygon.PolygonPoint), System.Array.getItem(points, ((System.Array.getCount(points, Poly2Tri.Triangulation.Polygon.PolygonPoint) - 1) | 0), Poly2Tri.Triangulation.Polygon.PolygonPoint))) {
                    System.Array.removeAt(points, ((System.Array.getCount(points, Poly2Tri.Triangulation.Polygon.PolygonPoint) - 1) | 0), Poly2Tri.Triangulation.Polygon.PolygonPoint);
                }

                this._points.AddRange(System.Linq.Enumerable.from(points).select(function (x) { return Bridge.cast(x, Poly2Tri.Triangulation.TriangulationPoint); }));
            },
            /**
             * Create a polygon from a list of at least 3 points with no duplicates.
             *
             * @instance
             * @public
             * @this Poly2Tri.Triangulation.Polygon.Polygon
             * @memberof Poly2Tri.Triangulation.Polygon.Polygon
             * @param   {System.Collections.Generic.IEnumerable$1}    points    A list of unique points.
             * @return  {void}
             */
            $ctor1: function (points) {
                Poly2Tri.Triangulation.Polygon.Polygon.$ctor2.call(this, (Bridge.as(points, System.Collections.Generic.IList$1(Poly2Tri.Triangulation.Polygon.PolygonPoint))) || System.Linq.Enumerable.from(points).ToArray());
            },
            ctor: function () {
                this.$initialize();
            }
        },
        methods: {
            AddTriangle: function (t) {
                this._triangles.add(t);
            },
            AddTriangles: function (list) {
                this._triangles.AddRange(list);
            },
            ClearTriangles: function () {
                if (this._triangles != null) {
                    this._triangles.clear();
                }
            },
            /**
             * Creates constraints and populates the context with points
             *
             * @instance
             * @public
             * @this Poly2Tri.Triangulation.Polygon.Polygon
             * @memberof Poly2Tri.Triangulation.Polygon.Polygon
             * @param   {Poly2Tri.Triangulation.TriangulationContext}    tcx    The context
             * @return  {void}
             */
            PrepareTriangulation: function (tcx) {
                var $t;
                if (this._triangles == null) {
                    this._triangles = new (System.Collections.Generic.List$1(Poly2Tri.Triangulation.Delaunay.DelaunayTriangle)).$ctor2(this._points.Count);
                } else {
                    this._triangles.clear();
                }

                for (var i = 0; i < ((this._points.Count - 1) | 0); i = (i + 1) | 0) {
                    tcx.NewConstraint(this._points.getItem(i), this._points.getItem(((i + 1) | 0)));
                }
                tcx.NewConstraint(this._points.getItem(0), this._points.getItem(((this._points.Count - 1) | 0)));
                tcx.Points.AddRange(this._points);

                if (this._holes != null) {
                    $t = Bridge.getEnumerator(this._holes);
                    try {
                        while ($t.moveNext()) {
                            var p = $t.Current;
                            for (var i1 = 0; i1 < ((p._points.Count - 1) | 0); i1 = (i1 + 1) | 0) {
                                tcx.NewConstraint(p._points.getItem(i1), p._points.getItem(((i1 + 1) | 0)));
                            }
                            tcx.NewConstraint(p._points.getItem(0), p._points.getItem(((p._points.Count - 1) | 0)));
                            tcx.Points.AddRange(p._points);
                        }
                    } finally {
                        if (Bridge.is($t, System.IDisposable)) {
                            $t.System$IDisposable$Dispose();
                        }
                    }}

                if (this._steinerPoints != null) {
                    tcx.Points.AddRange(this._steinerPoints);
                }
            },
            AddSteinerPoint: function (point) {
                if (this._steinerPoints == null) {
                    this._steinerPoints = new (System.Collections.Generic.List$1(Poly2Tri.Triangulation.TriangulationPoint)).ctor();
                }
                this._steinerPoints.add(point);
            },
            AddSteinerPoints: function (points) {
                if (this._steinerPoints == null) {
                    this._steinerPoints = new (System.Collections.Generic.List$1(Poly2Tri.Triangulation.TriangulationPoint)).ctor();
                }
                this._steinerPoints.AddRange(points);
            },
            ClearSteinerPoints: function () {
                if (this._steinerPoints != null) {
                    this._steinerPoints.clear();
                }
            },
            /**
             * Add a hole to the polygon.
             *
             * @instance
             * @public
             * @this Poly2Tri.Triangulation.Polygon.Polygon
             * @memberof Poly2Tri.Triangulation.Polygon.Polygon
             * @param   {Poly2Tri.Triangulation.Polygon.Polygon}    poly    A subtraction polygon fully contained inside this polygon.
             * @return  {void}
             */
            AddHole: function (poly) {
                if (this._holes == null) {
                    this._holes = new (System.Collections.Generic.List$1(Poly2Tri.Triangulation.Polygon.Polygon)).ctor();
                }
                this._holes.add(poly);
            },
            /**
             * Inserts newPoint after point.
             *
             * @instance
             * @public
             * @this Poly2Tri.Triangulation.Polygon.Polygon
             * @memberof Poly2Tri.Triangulation.Polygon.Polygon
             * @param   {Poly2Tri.Triangulation.Polygon.PolygonPoint}    point       The point to insert after in the polygon
             * @param   {Poly2Tri.Triangulation.Polygon.PolygonPoint}    newPoint    The point to insert into the polygon
             * @return  {void}
             */
            InsertPointAfter: function (point, newPoint) {
                var index = this._points.indexOf(point);
                if (index === -1) {
                    throw new System.ArgumentException.$ctor3("Tried to insert a point into a Polygon after a point not belonging to the Polygon", "point");
                }
                newPoint.Next = point.Next;
                newPoint.Previous = point;
                point.Next.Previous = newPoint;
                point.Next = newPoint;
                this._points.insert(((index + 1) | 0), newPoint);
            },
            /**
             * Inserts list (after last point in polygon?)
             *
             * @instance
             * @public
             * @this Poly2Tri.Triangulation.Polygon.Polygon
             * @memberof Poly2Tri.Triangulation.Polygon.Polygon
             * @param   {System.Collections.Generic.IEnumerable$1}    list
             * @return  {void}
             */
            AddPoints: function (list) {
                var $t;
                var first;
                $t = Bridge.getEnumerator(list, Poly2Tri.Triangulation.Polygon.PolygonPoint);
                try {
                    while ($t.moveNext()) {
                        var p = $t.Current;
                        p.Previous = this._last;
                        if (this._last != null) {
                            p.Next = this._last.Next;
                            this._last.Next = p;
                        }
                        this._last = p;
                        this._points.add(p);
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }first = Bridge.cast(this._points.getItem(0), Poly2Tri.Triangulation.Polygon.PolygonPoint);
                this._last.Next = first;
                first.Previous = this._last;
            },
            /**
             * Adds a point after the last in the polygon.
             *
             * @instance
             * @public
             * @this Poly2Tri.Triangulation.Polygon.Polygon
             * @memberof Poly2Tri.Triangulation.Polygon.Polygon
             * @param   {Poly2Tri.Triangulation.Polygon.PolygonPoint}    p    The point to add
             * @return  {void}
             */
            AddPoint: function (p) {
                p.Previous = this._last;
                p.Next = this._last.Next;
                this._last.Next = p;
                this._points.add(p);
            },
            /**
             * Removes a point from the polygon.
             *
             * @instance
             * @public
             * @this Poly2Tri.Triangulation.Polygon.Polygon
             * @memberof Poly2Tri.Triangulation.Polygon.Polygon
             * @param   {Poly2Tri.Triangulation.Polygon.PolygonPoint}    p
             * @return  {void}
             */
            RemovePoint: function (p) {
                var next, prev;

                next = p.Next;
                prev = p.Previous;
                prev.Next = next;
                next.Previous = prev;
                this._points.remove(p);
            }
        }
    });

    Bridge.define("Poly2Tri.Triangulation.Polygon.PolygonPoint", {
        inherits: [Poly2Tri.Triangulation.TriangulationPoint],
        fields: {
            Next: null,
            Previous: null
        },
        ctors: {
            ctor: function (x, y) {
                this.$initialize();
                Poly2Tri.Triangulation.TriangulationPoint.ctor.call(this, x, y);
            }
        }
    });

    Bridge.define("Poly2Tri.Triangulation.Sets.PointSet", {
        inherits: [Poly2Tri.Triangulation.Triangulatable],
        fields: {
            Points: null,
            Triangles: null
        },
        props: {
            TriangulationMode: {
                get: function () {
                    return Poly2Tri.Triangulation.TriangulationMode.Unconstrained;
                }
            }
        },
        alias: [
            "Points", "Poly2Tri$Triangulation$Triangulatable$Points",
            "Triangles", "Poly2Tri$Triangulation$Triangulatable$Triangles",
            "TriangulationMode", "Poly2Tri$Triangulation$Triangulatable$TriangulationMode",
            "AddTriangle", "Poly2Tri$Triangulation$Triangulatable$AddTriangle",
            "AddTriangles", "Poly2Tri$Triangulation$Triangulatable$AddTriangles",
            "ClearTriangles", "Poly2Tri$Triangulation$Triangulatable$ClearTriangles",
            "PrepareTriangulation", "Poly2Tri$Triangulation$Triangulatable$PrepareTriangulation"
        ],
        ctors: {
            ctor: function (points) {
                this.$initialize();
                this.Points = new (System.Collections.Generic.List$1(Poly2Tri.Triangulation.TriangulationPoint)).$ctor1(points);
            }
        },
        methods: {
            AddTriangle: function (t) {
                System.Array.add(this.Triangles, t, Poly2Tri.Triangulation.Delaunay.DelaunayTriangle);
            },
            AddTriangles: function (list) {
                var $t;
                $t = Bridge.getEnumerator(list, Poly2Tri.Triangulation.Delaunay.DelaunayTriangle);
                try {
                    while ($t.moveNext()) {
                        var tri = $t.Current;
                        System.Array.add(this.Triangles, tri, Poly2Tri.Triangulation.Delaunay.DelaunayTriangle);
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }},
            ClearTriangles: function () {
                System.Array.clear(this.Triangles, Poly2Tri.Triangulation.Delaunay.DelaunayTriangle);
            },
            PrepareTriangulation: function (tcx) {
                if (this.Triangles == null) {
                    this.Triangles = new (System.Collections.Generic.List$1(Poly2Tri.Triangulation.Delaunay.DelaunayTriangle)).$ctor2(System.Array.getCount(this.Points, Poly2Tri.Triangulation.TriangulationPoint));
                } else {
                    System.Array.clear(this.Triangles, Poly2Tri.Triangulation.Delaunay.DelaunayTriangle);
                }
                tcx.Points.AddRange(this.Points);
            }
        }
    });

    Bridge.define("QuadTreeBroadPhase", {
        inherits: [FarseerPhysics.Collision.IBroadPhase],
        statics: {
            fields: {
                TreeUpdateThresh: 0
            },
            ctors: {
                init: function () {
                    this.TreeUpdateThresh = 10000;
                }
            }
        },
        fields: {
            _currID: 0,
            _idRegister: null,
            _moveBuffer: null,
            _pairBuffer: null,
            _quadTree: null,
            _treeMoveNum: 0
        },
        props: {
            /**
             * The number of proxies
             *
             * @instance
             * @public
             * @readonly
             * @memberof QuadTreeBroadPhase
             * @function ProxyCount
             * @type number
             */
            ProxyCount: {
                get: function () {
                    return this._idRegister.count;
                }
            }
        },
        alias: [
            "ProxyCount", "FarseerPhysics$Collision$IBroadPhase$ProxyCount",
            "GetFatAABB", "FarseerPhysics$Collision$IBroadPhase$GetFatAABB",
            "UpdatePairs", "FarseerPhysics$Collision$IBroadPhase$UpdatePairs",
            "TestOverlap", "FarseerPhysics$Collision$IBroadPhase$TestOverlap",
            "AddProxy", "FarseerPhysics$Collision$IBroadPhase$AddProxy",
            "RemoveProxy", "FarseerPhysics$Collision$IBroadPhase$RemoveProxy",
            "MoveProxy", "FarseerPhysics$Collision$IBroadPhase$MoveProxy",
            "GetProxy", "FarseerPhysics$Collision$IBroadPhase$GetProxy",
            "TouchProxy", "FarseerPhysics$Collision$IBroadPhase$TouchProxy",
            "Query", "FarseerPhysics$Collision$IBroadPhase$Query",
            "RayCast", "FarseerPhysics$Collision$IBroadPhase$RayCast"
        ],
        ctors: {
            /**
             * Creates a new quad tree broadphase with the specified span.
             *
             * @instance
             * @public
             * @this QuadTreeBroadPhase
             * @memberof QuadTreeBroadPhase
             * @param   {FarseerPhysics.Collision.AABB}    span    the maximum span of the tree (world size)
             * @return  {void}
             */
            ctor: function (span) {
                this.$initialize();
                this._quadTree = new (QuadTree$1(FarseerPhysics.Dynamics.FixtureProxy))(span.$clone(), 5, 10);
                this._idRegister = new (System.Collections.Generic.Dictionary$2(System.Int32,Element$1(FarseerPhysics.Dynamics.FixtureProxy)))();
                this._moveBuffer = new (System.Collections.Generic.List$1(Element$1(FarseerPhysics.Dynamics.FixtureProxy))).ctor();
                this._pairBuffer = new (System.Collections.Generic.List$1(FarseerPhysics.Collision.Pair)).ctor();
            }
        },
        methods: {
            GetFatAABB: function (proxyID, aabb) {
                if (this._idRegister.containsKey(proxyID)) {
                    aabb.v = this._idRegister.get(proxyID).Span.$clone();
                } else {
                    throw new System.Collections.Generic.KeyNotFoundException.$ctor1("proxyID not found in register");
                }
            },
            UpdatePairs: function (callback) {
                var $t;
                this._pairBuffer.clear();
                $t = Bridge.getEnumerator(this._moveBuffer);
                try {
                    while ($t.moveNext()) {
                        var qtnode = { v : $t.Current };
                        this.Query((function ($me, qtnode) {
                            return Bridge.fn.bind($me, function (proxyID) {
                                return this.PairBufferQueryCallback(proxyID, qtnode.v.Value.ProxyId);
                            });
                        })(this, qtnode), Bridge.ref(qtnode.v, "Span"));
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }this._moveBuffer.clear();

                this._pairBuffer.Sort();

                var i = 0;
                while (i < this._pairBuffer.Count) {
                    var primaryPair = this._pairBuffer.getItem(i).$clone();
                    var userDataA = { v : this.GetProxy(primaryPair.ProxyIdA) };
                    var userDataB = { v : this.GetProxy(primaryPair.ProxyIdB) };

                    callback(userDataA, userDataB);
                    i = (i + 1) | 0;

                    while (i < this._pairBuffer.Count && this._pairBuffer.getItem(i).$clone().ProxyIdA === primaryPair.ProxyIdA && this._pairBuffer.getItem(i).$clone().ProxyIdB === primaryPair.ProxyIdB) {
                        i = (i + 1) | 0;
                    }
                }
            },
            /**
             * Test overlap of fat AABBs.
             *
             * @instance
             * @public
             * @this QuadTreeBroadPhase
             * @memberof QuadTreeBroadPhase
             * @param   {number}     proxyIdA    The proxy id A.
             * @param   {number}     proxyIdB    The proxy id B.
             * @return  {boolean}
             */
            TestOverlap: function (proxyIdA, proxyIdB) {
                var aabb1 = { v : new FarseerPhysics.Collision.AABB() };
                var aabb2 = { v : new FarseerPhysics.Collision.AABB() };
                this.GetFatAABB(proxyIdA, aabb1);
                this.GetFatAABB(proxyIdB, aabb2);
                return FarseerPhysics.Collision.AABB.TestOverlap$1(aabb1, aabb2);
            },
            AddProxy: function (proxy) {
                var proxyID = Bridge.identity(this._currID, (this._currID = (this._currID + 1) | 0));
                proxy.v.ProxyId = proxyID;
                var aabb = this.Fatten(Bridge.ref(proxy.v, "AABB"));
                var qtnode = new (Element$1(FarseerPhysics.Dynamics.FixtureProxy))(proxy.v.$clone(), aabb.$clone());

                this._idRegister.add(proxyID, qtnode);
                this._quadTree.AddNode(qtnode);

                return proxyID;
            },
            RemoveProxy: function (proxyId) {
                if (this._idRegister.containsKey(proxyId)) {
                    var qtnode = this._idRegister.get(proxyId);
                    this.UnbufferMove(qtnode);
                    this._idRegister.remove(proxyId);
                    this._quadTree.RemoveNode(qtnode);
                } else {
                    throw new System.Collections.Generic.KeyNotFoundException.$ctor1("proxyID not found in register");
                }
            },
            MoveProxy: function (proxyId, aabb, displacement) {
                var fatAABB = { v : new FarseerPhysics.Collision.AABB() };
                this.GetFatAABB(proxyId, fatAABB);

                if (fatAABB.v.Contains(aabb)) {
                    return;
                }

                var b = aabb.v.$clone();
                var r = new Microsoft.Xna.Framework.Vector2.$ctor2(FarseerPhysics.Settings.AABBExtension, FarseerPhysics.Settings.AABBExtension);
                b.LowerBound = Microsoft.Xna.Framework.Vector2.op_Subtraction(b.LowerBound.$clone(), r.$clone());
                b.UpperBound = Microsoft.Xna.Framework.Vector2.op_Addition(b.UpperBound.$clone(), r.$clone());

                var d = Microsoft.Xna.Framework.Vector2.op_Multiply$2(FarseerPhysics.Settings.AABBMultiplier, displacement.$clone());

                if (d.X < 0.0) {
                    b.LowerBound.X += d.X;
                } else {
                    b.UpperBound.X += d.X;
                }

                if (d.Y < 0.0) {
                    b.LowerBound.Y += d.Y;
                } else {
                    b.UpperBound.Y += d.Y;
                }


                var qtnode = this._idRegister.get(proxyId);
                qtnode.Value.AABB = b.$clone();
                qtnode.Span = b.$clone();

                this.ReinsertNode(qtnode);

                this.BufferMove(qtnode);
            },
            GetProxy: function (proxyId) {
                if (this._idRegister.containsKey(proxyId)) {
                    return this._idRegister.get(proxyId).Value.$clone();
                } else {
                    throw new System.Collections.Generic.KeyNotFoundException.$ctor1("proxyID not found in register");
                }
            },
            TouchProxy: function (proxyId) {
                if (this._idRegister.containsKey(proxyId)) {
                    this.BufferMove(this._idRegister.get(proxyId));
                } else {
                    throw new System.Collections.Generic.KeyNotFoundException.$ctor1("proxyID not found in register");
                }
            },
            Query: function (callback, query) {
                this._quadTree.QueryAABB(this.TransformPredicate(callback), query);
            },
            RayCast: function (callback, input) {
                this._quadTree.RayCast(this.TransformRayCallback(callback), input);
            },
            Fatten: function (aabb) {
                var r = new Microsoft.Xna.Framework.Vector2.$ctor2(FarseerPhysics.Settings.AABBExtension, FarseerPhysics.Settings.AABBExtension);
                return new FarseerPhysics.Collision.AABB.$ctor1(Microsoft.Xna.Framework.Vector2.op_Subtraction(aabb.v.LowerBound.$clone(), r.$clone()), Microsoft.Xna.Framework.Vector2.op_Addition(aabb.v.UpperBound.$clone(), r.$clone()));
            },
            TransformPredicate: function (idPredicate) {
                var qtPred = function (qtnode) {
                    return idPredicate(qtnode.Value.ProxyId);
                };
                return qtPred;
            },
            TransformRayCallback: function (callback) {
                var newCallback = function (input, qtnode) {
                    return callback(input.$clone(), qtnode.Value.ProxyId);
                };
                return newCallback;
            },
            PairBufferQueryCallback: function (proxyID, baseID) {
                if (proxyID === baseID) {
                    return true;
                }

                var p = new FarseerPhysics.Collision.Pair();
                p.ProxyIdA = Math.min(proxyID, baseID);
                p.ProxyIdB = Math.max(proxyID, baseID);
                this._pairBuffer.add(p.$clone());

                return true;
            },
            ReconstructTree: function () {
                var $t;
                this._quadTree.Clear();
                $t = Bridge.getEnumerator(this._idRegister.getValues(), Element$1(FarseerPhysics.Dynamics.FixtureProxy));
                try {
                    while ($t.moveNext()) {
                        var elem = $t.Current;
                        this._quadTree.AddNode(elem);
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }},
            ReinsertNode: function (qtnode) {
                this._quadTree.RemoveNode(qtnode);
                this._quadTree.AddNode(qtnode);

                if (((this._treeMoveNum = (this._treeMoveNum + 1) | 0)) > QuadTreeBroadPhase.TreeUpdateThresh) {
                    this.ReconstructTree();
                    this._treeMoveNum = 0;
                }
            },
            BufferMove: function (proxy) {
                this._moveBuffer.add(proxy);
            },
            UnbufferMove: function (proxy) {
                this._moveBuffer.remove(proxy);
            }
        }
    });

    
    Bridge.define("FarseerPhysics.Common.PhysicsLogic.Explosion", {
        inherits: [FarseerPhysics.Common.PhysicsLogic.PhysicsLogic],
        statics: {
            fields: {
                /**
                 * Two degrees: maximum angle from edges to first ray tested
                 *
                 * @static
                 * @private
                 * @memberof FarseerPhysics.Common.PhysicsLogic.Explosion
                 * @constant
                 * @default 0.0349065848
                 * @type number
                 */
                MaxEdgeOffset: 0
            },
            ctors: {
                init: function () {
                    this.MaxEdgeOffset = 0.0349065848;
                }
            }
        },
        fields: {
            /**
             * Ratio of arc length to angle from edges to first ray tested.
             Defaults to 1/40.
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Common.PhysicsLogic.Explosion
             * @type number
             */
            EdgeRatio: 0,
            /**
             * Ignore Explosion if it happens inside a shape.
             Default value is false.
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Common.PhysicsLogic.Explosion
             * @default false
             * @type boolean
             */
            IgnoreWhenInsideShape: false,
            /**
             * Max angle between rays (used when segment is large).
             Defaults to 15 degrees
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Common.PhysicsLogic.Explosion
             * @type number
             */
            MaxAngle: 0,
            /**
             * Maximum number of shapes involved in the explosion.
             Defaults to 100
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Common.PhysicsLogic.Explosion
             * @default 100
             * @type number
             */
            MaxShapes: 0,
            /**
             * How many rays per shape/body/segment.
             Defaults to 5
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Common.PhysicsLogic.Explosion
             * @default 5
             * @type number
             */
            MinRays: 0,
            _data: null,
            _exploded: null,
            _rdc: null
        },
        ctors: {
            init: function () {
                this.EdgeRatio = 0.025;
                this.IgnoreWhenInsideShape = false;
                this.MaxAngle = 0.209439516;
                this.MaxShapes = 100;
                this.MinRays = 5;
                this._data = new (System.Collections.Generic.List$1(FarseerPhysics.Common.PhysicsLogic.ShapeData)).ctor();
            },
            ctor: function (world) {
                this.$initialize();
                FarseerPhysics.Common.PhysicsLogic.PhysicsLogic.ctor.call(this, world, FarseerPhysics.Common.PhysicsLogic.PhysicsLogicType.Explosion);
                this._exploded = new (System.Collections.Generic.Dictionary$2(FarseerPhysics.Dynamics.Fixture,System.Collections.Generic.List$1(Microsoft.Xna.Framework.Vector2)))();
                this._rdc = new FarseerPhysics.Common.PhysicsLogic.RayDataComparer();
                this._data = new (System.Collections.Generic.List$1(FarseerPhysics.Common.PhysicsLogic.ShapeData)).ctor();
            }
        },
        methods: {
            /**
             * This makes the explosive explode
             *
             * @instance
             * @public
             * @this FarseerPhysics.Common.PhysicsLogic.Explosion
             * @memberof FarseerPhysics.Common.PhysicsLogic.Explosion
             * @param   {Microsoft.Xna.Framework.Vector2}            pos         The position where the explosion happens
             * @param   {number}                                     radius      The explosion radius
             * @param   {number}                                     maxForce    The explosion force at the explosion point
             (then is inversely proportional to the square of the distance)
             * @return  {System.Collections.Generic.Dictionary$2}                A dictionnary containing all the "exploded" fixtures
             with a list of the applied impulses
             */
            Activate: function (pos, radius, maxForce) {
                pos = {v:pos};
                this._exploded.clear();

                var aabb = { v : new FarseerPhysics.Collision.AABB() };
                aabb.v.LowerBound = Microsoft.Xna.Framework.Vector2.op_Addition(pos.v.$clone(), new Microsoft.Xna.Framework.Vector2.$ctor2(-radius, -radius));
                aabb.v.UpperBound = Microsoft.Xna.Framework.Vector2.op_Addition(pos.v.$clone(), new Microsoft.Xna.Framework.Vector2.$ctor2(radius, radius));
                var shapes = System.Array.init(this.MaxShapes, null, FarseerPhysics.Dynamics.Fixture);

                var containedShapes = System.Array.init(5, null, FarseerPhysics.Dynamics.Fixture);
                var exit = false;

                var shapeCount = 0;
                var containedShapeCount = 0;

                this.World.QueryAABB(Bridge.fn.bind(this, function (fixture) {
                    if (fixture.TestPoint(pos)) {
                        if (this.IgnoreWhenInsideShape) {
                            exit = true;
                        } else {
                            containedShapes[System.Array.index(Bridge.identity(containedShapeCount, (containedShapeCount = (containedShapeCount + 1) | 0)), containedShapes)] = fixture;
                        }
                    } else {
                        shapes[System.Array.index(Bridge.identity(shapeCount, (shapeCount = (shapeCount + 1) | 0)), shapes)] = fixture;
                    }

                    return true;
                }), aabb);

                if (exit) {
                    return this._exploded;
                }

                var vals = System.Array.init(Bridge.Int.mul(shapeCount, 2), 0, System.Single);
                var valIndex = 0;
                for (var i = 0; i < shapeCount; i = (i + 1) | 0) {
                    var ps;
                    var cs = Bridge.as(shapes[System.Array.index(i, shapes)].Shape, FarseerPhysics.Collision.Shapes.CircleShape);
                    if (cs != null) {
                        var v = new FarseerPhysics.Common.Vertices.ctor();
                        var vec = Microsoft.Xna.Framework.Vector2.op_Addition(Microsoft.Xna.Framework.Vector2.Zero.$clone(), new Microsoft.Xna.Framework.Vector2.$ctor2(cs.Radius, 0));
                        v.add(vec.$clone());
                        vec = Microsoft.Xna.Framework.Vector2.op_Addition(Microsoft.Xna.Framework.Vector2.Zero.$clone(), new Microsoft.Xna.Framework.Vector2.$ctor2(0, cs.Radius));
                        v.add(vec.$clone());
                        vec = Microsoft.Xna.Framework.Vector2.op_Addition(Microsoft.Xna.Framework.Vector2.Zero.$clone(), new Microsoft.Xna.Framework.Vector2.$ctor2(-cs.Radius, cs.Radius));
                        v.add(vec.$clone());
                        vec = Microsoft.Xna.Framework.Vector2.op_Addition(Microsoft.Xna.Framework.Vector2.Zero.$clone(), new Microsoft.Xna.Framework.Vector2.$ctor2(0, -cs.Radius));
                        v.add(vec.$clone());
                        ps = new FarseerPhysics.Collision.Shapes.PolygonShape.$ctor1(v, 0);
                    } else {
                        ps = Bridge.as(shapes[System.Array.index(i, shapes)].Shape, FarseerPhysics.Collision.Shapes.PolygonShape);
                    }

                    if ((shapes[System.Array.index(i, shapes)].Body.BodyType === FarseerPhysics.Dynamics.BodyType.Dynamic) && ps != null) {
                        var toCentroid = Microsoft.Xna.Framework.Vector2.op_Subtraction(shapes[System.Array.index(i, shapes)].Body.GetWorldPoint(ps.MassData.Centroid.$clone()), pos.v.$clone());
                        var angleToCentroid = Math.atan2(toCentroid.Y, toCentroid.X);
                        var min = 3.40282347E+38;
                        var max = -3.40282347E+38;
                        var minAbsolute = 0.0;
                        var maxAbsolute = 0.0;

                        for (var j = 0; j < (System.Linq.Enumerable.from(ps.Vertices).count()); j = (j + 1) | 0) {
                            var toVertex = (Microsoft.Xna.Framework.Vector2.op_Subtraction(shapes[System.Array.index(i, shapes)].Body.GetWorldPoint(ps.Vertices.getItem(j).$clone()), pos.v.$clone()));
                            var newAngle = Math.atan2(toVertex.Y, toVertex.X);
                            var diff = (newAngle - angleToCentroid);

                            diff = (diff - Microsoft.Xna.Framework.MathHelper.Pi) % (6.28318548);

                            if (diff < 0.0) {
                                diff += 6.28318548;
                            }

                            diff -= Microsoft.Xna.Framework.MathHelper.Pi;

                            if (Math.abs(diff) > Microsoft.Xna.Framework.MathHelper.Pi) {
                                throw new System.ArgumentException.$ctor1("OMG!");
                            }

                            if (diff > max) {
                                max = diff;
                                maxAbsolute = newAngle;
                            }
                            if (diff < min) {
                                min = diff;
                                minAbsolute = newAngle;
                            }
                        }

                        vals[System.Array.index(valIndex, vals)] = minAbsolute;
                        valIndex = (valIndex + 1) | 0;
                        vals[System.Array.index(valIndex, vals)] = maxAbsolute;
                        valIndex = (valIndex + 1) | 0;
                    }
                }

                System.Array.sort(vals, 0, valIndex, this._rdc);
                this._data.clear();
                var rayMissed = true;

                for (var i1 = 0; i1 < valIndex; i1 = (i1 + 1) | 0) {
                    var shape = { v : null };
                    var midpt;

                    var iplus = (i1 === ((valIndex - 1) | 0) ? 0 : ((i1 + 1) | 0));
                    if (vals[System.Array.index(i1, vals)] === vals[System.Array.index(iplus, vals)]) {
                        continue;
                    }

                    if (i1 === ((valIndex - 1) | 0)) {
                        midpt = (vals[System.Array.index(0, vals)] + 6.28318548 + vals[System.Array.index(i1, vals)]);
                    } else {
                        midpt = (vals[System.Array.index(((i1 + 1) | 0), vals)] + vals[System.Array.index(i1, vals)]);
                    }

                    midpt = midpt / 2;

                    var p1 = pos.v.$clone();
                    var p2 = Microsoft.Xna.Framework.Vector2.op_Addition(Microsoft.Xna.Framework.Vector2.op_Multiply$2(radius, new Microsoft.Xna.Framework.Vector2.$ctor2(Math.cos(midpt), Math.sin(midpt))), pos.v.$clone());

                    var hitClosest = { v : false };
                    this.World.RayCast((function ($me, hitClosest, shape) {
                        return Bridge.fn.bind($me, function (f, p, n, fr) {
                            var body = f.Body;

                            if (!this.IsActiveOn(body)) {
                                return 0;
                            }

                            if (body.UserData != null) {
                                var index = System.Nullable.getValue(Bridge.cast(Bridge.unbox(body.UserData, System.Int32), System.Int32));
                                if (index === 0) {
                                    return -1.0;
                                }
                            }

                            hitClosest.v = true;
                            shape.v = f;
                            return fr;
                        });
                    })(this, hitClosest, shape), p1.$clone(), p2.$clone());

                    if ((hitClosest.v) && (shape.v.Body.BodyType === FarseerPhysics.Dynamics.BodyType.Dynamic)) {
                        if ((System.Linq.Enumerable.from(this._data).count() > 0) && (Bridge.referenceEquals(System.Linq.Enumerable.from(this._data).last().Body, shape.v.Body)) && (!rayMissed)) {
                            var laPos = (this._data.Count - 1) | 0;
                            var la = this._data.getItem(laPos).$clone();
                            la.Max = vals[System.Array.index(iplus, vals)];
                            this._data.setItem(laPos, la.$clone());
                        } else {
                            var d = new FarseerPhysics.Common.PhysicsLogic.ShapeData();
                            d.Body = shape.v.Body;
                            d.Min = vals[System.Array.index(i1, vals)];
                            d.Max = vals[System.Array.index(iplus, vals)];
                            this._data.add(d.$clone());
                        }

                        if ((System.Linq.Enumerable.from(this._data).count() > 1) && (i1 === ((valIndex - 1) | 0)) && (Bridge.referenceEquals(System.Linq.Enumerable.from(this._data).last().Body, System.Linq.Enumerable.from(this._data).first().Body)) && (System.Linq.Enumerable.from(this._data).last().Max === System.Linq.Enumerable.from(this._data).first().Min)) {
                            var fi = this._data.getItem(0).$clone();
                            fi.Min = System.Linq.Enumerable.from(this._data).last().Min;
                            this._data.removeAt(((System.Linq.Enumerable.from(this._data).count() - 1) | 0));
                            this._data.setItem(0, fi.$clone());
                            while (System.Linq.Enumerable.from(this._data).first().Min >= System.Linq.Enumerable.from(this._data).first().Max) {
                                fi.Min -= 6.28318548;
                                this._data.setItem(0, fi.$clone());
                            }
                        }

                        var lastPos = (this._data.Count - 1) | 0;
                        var last = this._data.getItem(lastPos).$clone();
                        while ((System.Linq.Enumerable.from(this._data).count() > 0) && (System.Linq.Enumerable.from(this._data).last().Min >= System.Linq.Enumerable.from(this._data).last().Max)) {
                            last.Min = System.Linq.Enumerable.from(this._data).last().Min - 6.28318548;
                            this._data.setItem(lastPos, last.$clone());
                        }
                        rayMissed = false;
                    } else {
                        rayMissed = true;
                    }
                }

                for (var i2 = 0; i2 < System.Linq.Enumerable.from(this._data).count(); i2 = (i2 + 1) | 0) {
                    if (!this.IsActiveOn(this._data.getItem(i2).$clone().Body)) {
                        continue;
                    }

                    var arclen = this._data.getItem(i2).$clone().Max - this._data.getItem(i2).$clone().Min;

                    var first = Microsoft.Xna.Framework.MathHelper.Min$1(FarseerPhysics.Common.PhysicsLogic.Explosion.MaxEdgeOffset, this.EdgeRatio * arclen);
                    var insertedRays = Bridge.Int.clip32(Math.ceil(((arclen - 2.0 * first) - (((this.MinRays - 1) | 0)) * this.MaxAngle) / this.MaxAngle));

                    if (insertedRays < 0) {
                        insertedRays = 0;
                    }

                    var offset = (arclen - first * 2.0) / (this.MinRays + insertedRays - 1);

                    for (var j1 = this._data.getItem(i2).$clone().Min + first; j1 < this._data.getItem(i2).$clone().Max || FarseerPhysics.Common.MathUtils.FloatEquals$1(j1, this._data.getItem(i2).$clone().Max, 0.0001); j1 += offset) {
                        var p11 = pos.v.$clone();
                        var p21 = Microsoft.Xna.Framework.Vector2.op_Addition(pos.v.$clone(), Microsoft.Xna.Framework.Vector2.op_Multiply$2(radius, new Microsoft.Xna.Framework.Vector2.$ctor2(Math.cos(j1), Math.sin(j1))));
                        var hitpoint = { v : Microsoft.Xna.Framework.Vector2.Zero.$clone() };
                        var minlambda = 3.40282347E+38;

                        var fl = this._data.getItem(i2).$clone().Body.FixtureList;
                        for (var x = 0; x < fl.Count; x = (x + 1) | 0) {
                            var f = fl.getItem(x);
                            var ri = { v : new FarseerPhysics.Collision.RayCastInput() };
                            ri.v.Point1 = p11.$clone();
                            ri.v.Point2 = p21.$clone();
                            ri.v.MaxFraction = 50.0;

                            var ro = { v : new FarseerPhysics.Collision.RayCastOutput() };
                            if (f.RayCast(ro, ri, 0)) {
                                if (minlambda > ro.v.Fraction) {
                                    minlambda = ro.v.Fraction;
                                    hitpoint.v = Microsoft.Xna.Framework.Vector2.op_Addition(Microsoft.Xna.Framework.Vector2.op_Multiply$2(ro.v.Fraction, p21.$clone()), Microsoft.Xna.Framework.Vector2.op_Multiply$2((1 - ro.v.Fraction), p11.$clone()));
                                }
                            }

                            var impulse = (arclen / (((this.MinRays + insertedRays) | 0))) * maxForce * 180.0 / Microsoft.Xna.Framework.MathHelper.Pi * (1.0 - Math.min(1.0, minlambda));

                            var vectImp = { v : Microsoft.Xna.Framework.Vector2.op_Multiply$2(Microsoft.Xna.Framework.Vector2.Dot(Microsoft.Xna.Framework.Vector2.op_Multiply$2(impulse, new Microsoft.Xna.Framework.Vector2.$ctor2(Math.cos(j1), Math.sin(j1))), Microsoft.Xna.Framework.Vector2.op_UnaryNegation(ro.v.Normal.$clone())), new Microsoft.Xna.Framework.Vector2.$ctor2(Math.cos(j1), Math.sin(j1))) };

                            this._data.getItem(i2).$clone().Body.ApplyLinearImpulse$3(vectImp, hitpoint);

                            var val = Microsoft.Xna.Framework.Vector2.Zero.$clone();
                            var vectorList = { };
                            if (this._exploded.tryGetValue(f, vectorList)) {
                                val.X += Math.abs(vectImp.v.X);
                                val.Y += Math.abs(vectImp.v.Y);

                                vectorList.v.add(val.$clone());
                            } else {
                                vectorList.v = new (System.Collections.Generic.List$1(Microsoft.Xna.Framework.Vector2)).ctor();
                                val.X = Math.abs(vectImp.v.X);
                                val.Y = Math.abs(vectImp.v.Y);

                                vectorList.v.add(val.$clone());
                                this._exploded.add(f, vectorList.v);
                            }

                            if (minlambda > 1.0) {
                                hitpoint.v = p21.$clone();
                            }
                        }
                    }
                }

                for (var i3 = 0; i3 < containedShapeCount; i3 = (i3 + 1) | 0) {
                    var fix = containedShapes[System.Array.index(i3, containedShapes)];

                    if (!this.IsActiveOn(fix.Body)) {
                        continue;
                    }

                    var impulse1 = this.MinRays * maxForce * 180.0 / Microsoft.Xna.Framework.MathHelper.Pi;
                    var hitPoint = { v : new Microsoft.Xna.Framework.Vector2() };

                    var circShape = Bridge.as(fix.Shape, FarseerPhysics.Collision.Shapes.CircleShape);
                    if (circShape != null) {
                        hitPoint.v = fix.Body.GetWorldPoint(circShape.Position.$clone());
                    } else {
                        var shape1 = Bridge.as(fix.Shape, FarseerPhysics.Collision.Shapes.PolygonShape);
                        hitPoint.v = fix.Body.GetWorldPoint(shape1.MassData.Centroid.$clone());
                    }

                    var vectImp1 = { v : Microsoft.Xna.Framework.Vector2.op_Multiply$2(impulse1, (Microsoft.Xna.Framework.Vector2.op_Subtraction(hitPoint.v.$clone(), pos.v.$clone()))) };

                    var vectorList1 = new (System.Collections.Generic.List$1(Microsoft.Xna.Framework.Vector2)).ctor();
                    vectorList1.add(vectImp1.v.$clone());

                    fix.Body.ApplyLinearImpulse$3(vectImp1, hitPoint);

                    if (!this._exploded.containsKey(fix)) {
                        this._exploded.add(fix, vectorList1);
                    }
                }

                return this._exploded;
            }
        }
    });

    Bridge.define("FarseerPhysics.Controllers.AbstractForceController", {
        inherits: [FarseerPhysics.Controllers.Controller],
        fields: {
            /**
             * Curve to be used for Decay in Curve mode
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Controllers.AbstractForceController
             * @type Microsoft.Xna.Framework.Curve
             */
            DecayCurve: null,
            /**
             * The Forcetype of the instance
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Controllers.AbstractForceController
             * @type number
             */
            ForceType: 0,
            /**
             * Provided for reuse to provide Variation functionality in 
             inheriting classes
             *
             * @instance
             * @protected
             * @memberof FarseerPhysics.Controllers.AbstractForceController
             * @type System.Random
             */
            Randomize: null,
            /**
             * Curve used by Curve Mode as an animated multiplier for the force 
             strength.
             Only positions between 0 and 1 are considered as that range is 
             stretched to have ImpulseLength.
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Controllers.AbstractForceController
             * @type Microsoft.Xna.Framework.Curve
             */
            StrengthCurve: null,
            /**
             * Global Strength of the force to be applied
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Controllers.AbstractForceController
             * @function Strength
             * @type number
             */
            Strength: 0,
            /**
             * Position of the Force. Can be ignored (left at (0,0) for forces
             that are not position-dependent
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Controllers.AbstractForceController
             * @function Position
             * @type Microsoft.Xna.Framework.Vector2
             */
            Position: null,
            /**
             * Maximum speed of the bodies. Bodies that are travelling faster are
             supposed to be ignored
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Controllers.AbstractForceController
             * @function MaximumSpeed
             * @type number
             */
            MaximumSpeed: 0,
            /**
             * Maximum Force to be applied. As opposed to Maximum Speed this is 
             independent of the velocity of
             the affected body
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Controllers.AbstractForceController
             * @function MaximumForce
             * @type number
             */
            MaximumForce: 0,
            /**
             * Timing Mode of the force instance
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Controllers.AbstractForceController
             * @function TimingMode
             * @type number
             */
            TimingMode: 0,
            /**
             * Time of the current impulse. Incremented in update till 
             ImpulseLength is reached
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Controllers.AbstractForceController
             * @function ImpulseTime
             * @type number
             */
            ImpulseTime: 0,
            /**
             * Length of a triggered impulse. Used in both Triggered and Curve Mode
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Controllers.AbstractForceController
             * @function ImpulseLength
             * @type number
             */
            ImpulseLength: 0,
            /**
             * Indicating if we are currently during an Impulse 
             (Triggered and Curve Mode)
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Controllers.AbstractForceController
             * @function Triggered
             * @type boolean
             */
            Triggered: false,
            /**
             * Variation of the force applied to each body affected
             !! Must be used in inheriting classes properly !!
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Controllers.AbstractForceController
             * @function Variation
             * @type number
             */
            Variation: 0,
            /**
             * See DecayModes
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Controllers.AbstractForceController
             * @function DecayMode
             * @type number
             */
            DecayMode: 0,
            /**
             * Start of the distance based Decay. To set a non decaying area
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Controllers.AbstractForceController
             * @function DecayStart
             * @type number
             */
            DecayStart: 0,
            /**
             * Maximum distance a force should be applied
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Controllers.AbstractForceController
             * @function DecayEnd
             * @type number
             */
            DecayEnd: 0
        },
        ctors: {
            init: function () {
                this.Position = new Microsoft.Xna.Framework.Vector2();
            },
            /**
             * Constructor
             *
             * @instance
             * @public
             * @this FarseerPhysics.Controllers.AbstractForceController
             * @memberof FarseerPhysics.Controllers.AbstractForceController
             * @return  {void}
             */
            ctor: function () {
                this.$initialize();
                FarseerPhysics.Controllers.Controller.ctor.call(this, FarseerPhysics.Controllers.ControllerType.AbstractForceController);
                this.Enabled = true;

                this.Strength = 1.0;
                this.Position = new Microsoft.Xna.Framework.Vector2.$ctor2(0, 0);
                this.MaximumSpeed = 100.0;
                this.TimingMode = FarseerPhysics.Controllers.AbstractForceController.TimingModes.Switched;
                this.ImpulseTime = 0.0;
                this.ImpulseLength = 1.0;
                this.Triggered = false;
                this.StrengthCurve = new Microsoft.Xna.Framework.Curve();
                this.Variation = 0.0;
                this.Randomize = new System.Random.$ctor1(1234);
                this.DecayMode = FarseerPhysics.Controllers.AbstractForceController.DecayModes.None;
                this.DecayCurve = new Microsoft.Xna.Framework.Curve();
                this.DecayStart = 0.0;
                this.DecayEnd = 0.0;

                this.StrengthCurve.Keys.add(new Microsoft.Xna.Framework.CurveKey.$ctor1(0, 5));
                this.StrengthCurve.Keys.add(new Microsoft.Xna.Framework.CurveKey.$ctor1(0.1, 5));
                this.StrengthCurve.Keys.add(new Microsoft.Xna.Framework.CurveKey.$ctor1(0.2, -4));
                this.StrengthCurve.Keys.add(new Microsoft.Xna.Framework.CurveKey.$ctor1(1.0, 0));
            },
            /**
             * Overloaded Contstructor with supplying Timing Mode
             *
             * @instance
             * @public
             * @this FarseerPhysics.Controllers.AbstractForceController
             * @memberof FarseerPhysics.Controllers.AbstractForceController
             * @param   {number}    mode
             * @return  {void}
             */
            $ctor1: function (mode) {
                this.$initialize();
                FarseerPhysics.Controllers.Controller.ctor.call(this, FarseerPhysics.Controllers.ControllerType.AbstractForceController);
                this.TimingMode = mode;
                switch (mode) {
                    case FarseerPhysics.Controllers.AbstractForceController.TimingModes.Switched: 
                        this.Enabled = true;
                        break;
                    case FarseerPhysics.Controllers.AbstractForceController.TimingModes.Triggered: 
                        this.Enabled = false;
                        break;
                    case FarseerPhysics.Controllers.AbstractForceController.TimingModes.Curve: 
                        this.Enabled = false;
                        break;
                }
            }
        },
        methods: {
            /**
             * Calculate the Decay for a given body. Meant to ease force 
             development and stick to the DRY principle and provide unified and 
             predictable decay math.
             *
             * @instance
             * @protected
             * @this FarseerPhysics.Controllers.AbstractForceController
             * @memberof FarseerPhysics.Controllers.AbstractForceController
             * @param   {FarseerPhysics.Dynamics.Body}    body    The body to calculate decay for
             * @return  {number}                                  A multiplier to multiply the force with to add decay 
             support in inheriting classes
             */
            GetDecayMultiplier: function (body) {
                var distance = (Microsoft.Xna.Framework.Vector2.op_Subtraction(body.Position.$clone(), this.Position.$clone())).Length();
                switch (this.DecayMode) {
                    case FarseerPhysics.Controllers.AbstractForceController.DecayModes.None: 
                        {
                            return 1.0;
                        }
                    case FarseerPhysics.Controllers.AbstractForceController.DecayModes.Step: 
                        {
                            if (distance < this.DecayEnd) {
                                return 1.0;
                            } else {
                                return 0.0;
                            }
                        }
                    case FarseerPhysics.Controllers.AbstractForceController.DecayModes.Linear: 
                        {
                            if (distance < this.DecayStart) {
                                return 1.0;
                            }
                            if (distance > this.DecayEnd) {
                                return 0.0;
                            }
                            return (this.DecayEnd - this.DecayStart / distance - this.DecayStart);
                        }
                    case FarseerPhysics.Controllers.AbstractForceController.DecayModes.InverseSquare: 
                        {
                            if (distance < this.DecayStart) {
                                return 1.0;
                            } else {
                                return 1.0 / ((distance - this.DecayStart) * (distance - this.DecayStart));
                            }
                        }
                    case FarseerPhysics.Controllers.AbstractForceController.DecayModes.Curve: 
                        {
                            if (distance < this.DecayStart) {
                                return 1.0;
                            } else {
                                return this.DecayCurve.Evaluate(distance - this.DecayStart);
                            }
                        }
                    default: 
                        return 1.0;
                }
            },
            /**
             * Triggers the trigger modes (Trigger and Curve)
             *
             * @instance
             * @public
             * @this FarseerPhysics.Controllers.AbstractForceController
             * @memberof FarseerPhysics.Controllers.AbstractForceController
             * @return  {void}
             */
            Trigger: function () {
                this.Triggered = true;
                this.ImpulseTime = 0;
            },
            /**
             * Inherited from Controller
             Depending on the TimingMode perform timing logic and call ApplyForce()
             *
             * @instance
             * @public
             * @override
             * @this FarseerPhysics.Controllers.AbstractForceController
             * @memberof FarseerPhysics.Controllers.AbstractForceController
             * @param   {number}    dt
             * @return  {void}
             */
            Update: function (dt) {
                switch (this.TimingMode) {
                    case FarseerPhysics.Controllers.AbstractForceController.TimingModes.Switched: 
                        {
                            if (this.Enabled) {
                                this.ApplyForce(dt, this.Strength);
                            }
                            break;
                        }
                    case FarseerPhysics.Controllers.AbstractForceController.TimingModes.Triggered: 
                        {
                            if (this.Enabled && this.Triggered) {
                                if (this.ImpulseTime < this.ImpulseLength) {
                                    this.ApplyForce(dt, this.Strength);
                                    this.ImpulseTime += dt;
                                } else {
                                    this.Triggered = false;
                                }
                            }
                            break;
                        }
                    case FarseerPhysics.Controllers.AbstractForceController.TimingModes.Curve: 
                        {
                            if (this.Enabled && this.Triggered) {
                                if (this.ImpulseTime < this.ImpulseLength) {
                                    this.ApplyForce(dt, this.Strength * this.StrengthCurve.Evaluate(this.ImpulseTime));
                                    this.ImpulseTime += dt;
                                } else {
                                    this.Triggered = false;
                                }
                            }
                            break;
                        }
                }
            }
        }
    });

    Bridge.define("FarseerPhysics.Controllers.BuoyancyController", {
        inherits: [FarseerPhysics.Controllers.Controller],
        fields: {
            /**
             * Controls the rotational drag that the fluid exerts on the bodies within it. Use higher values will simulate thick fluid, like honey, lower values to
             simulate water-like fluids.
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Controllers.BuoyancyController
             * @type number
             */
            AngularDragCoefficient: 0,
            /**
             * Density of the fluid. Higher values will make things more buoyant, lower values will cause things to sink.
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Controllers.BuoyancyController
             * @type number
             */
            Density: 0,
            /**
             * Controls the linear drag that the fluid exerts on the bodies within it.  Use higher values will simulate thick fluid, like honey, lower values to
             simulate water-like fluids.
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Controllers.BuoyancyController
             * @type number
             */
            LinearDragCoefficient: 0,
            /**
             * Acts like waterflow. Defaults to 0,0.
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Controllers.BuoyancyController
             * @type Microsoft.Xna.Framework.Vector2
             */
            Velocity: null,
            _container: null,
            _gravity: null,
            _normal: null,
            _offset: 0,
            _uniqueBodies: null
        },
        props: {
            Container: {
                get: function () {
                    return this._container.$clone();
                },
                set: function (value) {
                    this._container = value.$clone();
                    this._offset = this._container.UpperBound.Y;
                }
            }
        },
        ctors: {
            init: function () {
                this.Velocity = new Microsoft.Xna.Framework.Vector2();
                this._container = new FarseerPhysics.Collision.AABB();
                this._gravity = new Microsoft.Xna.Framework.Vector2();
                this._normal = new Microsoft.Xna.Framework.Vector2();
                this._uniqueBodies = new (System.Collections.Generic.Dictionary$2(System.Int32,FarseerPhysics.Dynamics.Body))();
            },
            /**
             * Initializes a new instance of the {@link } class.
             *
             * @instance
             * @public
             * @this FarseerPhysics.Controllers.BuoyancyController
             * @memberof FarseerPhysics.Controllers.BuoyancyController
             * @param   {FarseerPhysics.Collision.AABB}      container                    Only bodies inside this AABB will be influenced by the controller
             * @param   {number}                             density                      Density of the fluid
             * @param   {number}                             linearDragCoefficient        Linear drag coefficient of the fluid
             * @param   {number}                             rotationalDragCoefficient    Rotational drag coefficient of the fluid
             * @param   {Microsoft.Xna.Framework.Vector2}    gravity                      The direction gravity acts. Buoyancy force will act in opposite direction of gravity.
             * @return  {void}
             */
            ctor: function (container, density, linearDragCoefficient, rotationalDragCoefficient, gravity) {
                this.$initialize();
                FarseerPhysics.Controllers.Controller.ctor.call(this, FarseerPhysics.Controllers.ControllerType.BuoyancyController);
                this.Container = container.$clone();
                this._normal = new Microsoft.Xna.Framework.Vector2.$ctor2(0, 1);
                this.Density = density;
                this.LinearDragCoefficient = linearDragCoefficient;
                this.AngularDragCoefficient = rotationalDragCoefficient;
                this._gravity = gravity.$clone();
            }
        },
        methods: {
            Update: function (dt) {
                var $t;
                this._uniqueBodies.clear();
                this.World.QueryAABB(Bridge.fn.bind(this, function (fixture) {
                    if (fixture.Body.IsStatic || !fixture.Body.Awake) {
                        return true;
                    }

                    if (!this._uniqueBodies.containsKey(fixture.Body.BodyId)) {
                        this._uniqueBodies.add(fixture.Body.BodyId, fixture.Body);
                    }

                    return true;
                }), Bridge.ref(this, "_container"));

                $t = Bridge.getEnumerator(this._uniqueBodies);
                try {
                    while ($t.moveNext()) {
                        var kv = $t.Current;
                        var body = kv.value;

                        var areac = Microsoft.Xna.Framework.Vector2.Zero.$clone();
                        var massc = Microsoft.Xna.Framework.Vector2.Zero.$clone();
                        var area = 0;
                        var mass = 0;

                        for (var j = 0; j < body.FixtureList.Count; j = (j + 1) | 0) {
                            var fixture = body.FixtureList.getItem(j);

                            if (fixture.Shape.ShapeType !== FarseerPhysics.Collision.Shapes.ShapeType.Polygon && fixture.Shape.ShapeType !== FarseerPhysics.Collision.Shapes.ShapeType.Circle) {
                                continue;
                            }

                            var shape = fixture.Shape;

                            var sc = { v : new Microsoft.Xna.Framework.Vector2() };
                            var sarea = shape.ComputeSubmergedArea(this._normal.$clone(), this._offset, body.Xf.$clone(), sc);
                            area += sarea;
                            areac.X += sarea * sc.v.X;
                            areac.Y += sarea * sc.v.Y;

                            mass += sarea * shape.Density;
                            massc.X += sarea * sc.v.X * shape.Density;
                            massc.Y += sarea * sc.v.Y * shape.Density;
                        }

                        areac.X /= area;
                        areac.Y /= area;
                        massc.X /= mass;
                        massc.Y /= mass;

                        if (area < FarseerPhysics.Settings.Epsilon) {
                            continue;
                        }

                        var buoyancyForce = Microsoft.Xna.Framework.Vector2.op_Multiply$2(-this.Density * area, this._gravity.$clone());
                        body.ApplyForce$1(buoyancyForce.$clone(), massc.$clone());

                        var dragForce = Microsoft.Xna.Framework.Vector2.op_Subtraction(body.GetLinearVelocityFromWorldPoint(areac.$clone()), this.Velocity.$clone());
                        dragForce = Microsoft.Xna.Framework.Vector2.op_Multiply$1(dragForce.$clone(), -this.LinearDragCoefficient * area);
                        body.ApplyForce$1(dragForce.$clone(), areac.$clone());

                        body.ApplyTorque(-body.Inertia / body.Mass * area * body.AngularVelocity * this.AngularDragCoefficient);
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }}
        }
    });

    Bridge.define("FarseerPhysics.Controllers.GravityController", {
        inherits: [FarseerPhysics.Controllers.Controller],
        fields: {
            Bodies: null,
            Points: null,
            MinRadius: 0,
            MaxRadius: 0,
            Strength: 0,
            GravityType: 0
        },
        ctors: {
            init: function () {
                this.Bodies = new (System.Collections.Generic.List$1(FarseerPhysics.Dynamics.Body)).ctor();
                this.Points = new (System.Collections.Generic.List$1(Microsoft.Xna.Framework.Vector2)).ctor();
            },
            ctor: function (strength) {
                this.$initialize();
                FarseerPhysics.Controllers.Controller.ctor.call(this, FarseerPhysics.Controllers.ControllerType.GravityController);
                this.Strength = strength;
                this.MaxRadius = 3.40282347E+38;
            },
            $ctor1: function (strength, maxRadius, minRadius) {
                this.$initialize();
                FarseerPhysics.Controllers.Controller.ctor.call(this, FarseerPhysics.Controllers.ControllerType.GravityController);
                this.MinRadius = minRadius;
                this.MaxRadius = maxRadius;
                this.Strength = strength;
            }
        },
        methods: {
            Update: function (dt) {
                var $t, $t1, $t2;
                var f = { v : Microsoft.Xna.Framework.Vector2.Zero.$clone() };

                $t = Bridge.getEnumerator(this.World.BodyList);
                try {
                    while ($t.moveNext()) {
                        var body1 = $t.Current;
                        if (!this.IsActiveOn(body1)) {
                            continue;
                        }

                        $t1 = Bridge.getEnumerator(this.Bodies);
                        try {
                            while ($t1.moveNext()) {
                                var body2 = $t1.Current;
                                if (Bridge.referenceEquals(body1, body2) || (body1.IsStatic && body2.IsStatic) || !body2.Enabled) {
                                    continue;
                                }

                                var d = Microsoft.Xna.Framework.Vector2.op_Subtraction(body2.WorldCenter.$clone(), body1.WorldCenter.$clone());
                                var r2 = d.LengthSquared();

                                if (r2 < FarseerPhysics.Settings.Epsilon) {
                                    continue;
                                }

                                var r = d.Length();

                                if (r >= this.MaxRadius || r <= this.MinRadius) {
                                    continue;
                                }

                                switch (this.GravityType) {
                                    case FarseerPhysics.Controllers.GravityType.DistanceSquared: 
                                        f.v = Microsoft.Xna.Framework.Vector2.op_Multiply$2(this.Strength / r2 / Math.sqrt(r2) * body1.Mass * body2.Mass, d.$clone());
                                        break;
                                    case FarseerPhysics.Controllers.GravityType.Linear: 
                                        f.v = Microsoft.Xna.Framework.Vector2.op_Multiply$2(this.Strength / r2 * body1.Mass * body2.Mass, d.$clone());
                                        break;
                                }

                                body1.ApplyForce$2(f);
                                Microsoft.Xna.Framework.Vector2.Negate$1(f, f);
                                body2.ApplyForce$2(f);
                            }
                        } finally {
                            if (Bridge.is($t1, System.IDisposable)) {
                                $t1.System$IDisposable$Dispose();
                            }
                        }
                        $t2 = Bridge.getEnumerator(this.Points);
                        try {
                            while ($t2.moveNext()) {
                                var point = $t2.Current.$clone();
                                var d1 = Microsoft.Xna.Framework.Vector2.op_Subtraction(point.$clone(), body1.Position.$clone());
                                var r21 = d1.LengthSquared();

                                if (r21 < FarseerPhysics.Settings.Epsilon) {
                                    continue;
                                }

                                var r1 = d1.Length();

                                if (r1 >= this.MaxRadius || r1 <= this.MinRadius) {
                                    continue;
                                }

                                switch (this.GravityType) {
                                    case FarseerPhysics.Controllers.GravityType.DistanceSquared: 
                                        f.v = Microsoft.Xna.Framework.Vector2.op_Multiply$2(this.Strength / r21 / Math.sqrt(r21) * body1.Mass, d1.$clone());
                                        break;
                                    case FarseerPhysics.Controllers.GravityType.Linear: 
                                        f.v = Microsoft.Xna.Framework.Vector2.op_Multiply$2(this.Strength / r21 * body1.Mass, d1.$clone());
                                        break;
                                }

                                body1.ApplyForce$2(f);
                            }
                        } finally {
                            if (Bridge.is($t2, System.IDisposable)) {
                                $t2.System$IDisposable$Dispose();
                            }
                        }
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }},
            AddBody: function (body) {
                this.Bodies.add(body);
            },
            AddPoint: function (point) {
                this.Points.add(point.$clone());
            }
        }
    });

    /**
     * Put a limit on the linear (translation - the movespeed) and angular (rotation) velocity
     of bodies added to this controller.
     *
     * @public
     * @class FarseerPhysics.Controllers.VelocityLimitController
     * @augments FarseerPhysics.Controllers.Controller
     */
    Bridge.define("FarseerPhysics.Controllers.VelocityLimitController", {
        inherits: [FarseerPhysics.Controllers.Controller],
        fields: {
            LimitAngularVelocity: false,
            LimitLinearVelocity: false,
            _bodies: null,
            _maxAngularSqared: 0,
            _maxAngularVelocity: 0,
            _maxLinearSqared: 0,
            _maxLinearVelocity: 0
        },
        props: {
            /**
             * Gets or sets the max angular velocity.
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Controllers.VelocityLimitController
             * @function MaxAngularVelocity
             * @type number
             */
            MaxAngularVelocity: {
                get: function () {
                    return this._maxAngularVelocity;
                },
                set: function (value) {
                    this._maxAngularVelocity = value;
                    this._maxAngularSqared = this._maxAngularVelocity * this._maxAngularVelocity;
                }
            },
            /**
             * Gets or sets the max linear velocity.
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Controllers.VelocityLimitController
             * @function MaxLinearVelocity
             * @type number
             */
            MaxLinearVelocity: {
                get: function () {
                    return this._maxLinearVelocity;
                },
                set: function (value) {
                    this._maxLinearVelocity = value;
                    this._maxLinearSqared = this._maxLinearVelocity * this._maxLinearVelocity;
                }
            }
        },
        ctors: {
            init: function () {
                this.LimitAngularVelocity = true;
                this.LimitLinearVelocity = true;
                this._bodies = new (System.Collections.Generic.List$1(FarseerPhysics.Dynamics.Body)).ctor();
            },
            /**
             * Initializes a new instance of the {@link } class.
             Sets the max linear velocity to Settings.MaxTranslation
             Sets the max angular velocity to Settings.MaxRotation
             *
             * @instance
             * @public
             * @this FarseerPhysics.Controllers.VelocityLimitController
             * @memberof FarseerPhysics.Controllers.VelocityLimitController
             * @return  {void}
             */
            ctor: function () {
                this.$initialize();
                FarseerPhysics.Controllers.Controller.ctor.call(this, FarseerPhysics.Controllers.ControllerType.VelocityLimitController);
                this.MaxLinearVelocity = FarseerPhysics.Settings.MaxTranslation;
                this.MaxAngularVelocity = FarseerPhysics.Settings.MaxRotation;
            },
            /**
             * Initializes a new instance of the {@link } class.
             Pass in 0 or float.MaxValue to disable the limit.
             maxAngularVelocity = 0 will disable the angular velocity limit.
             *
             * @instance
             * @public
             * @this FarseerPhysics.Controllers.VelocityLimitController
             * @memberof FarseerPhysics.Controllers.VelocityLimitController
             * @param   {number}    maxLinearVelocity     The max linear velocity.
             * @param   {number}    maxAngularVelocity    The max angular velocity.
             * @return  {void}
             */
            $ctor1: function (maxLinearVelocity, maxAngularVelocity) {
                this.$initialize();
                FarseerPhysics.Controllers.Controller.ctor.call(this, FarseerPhysics.Controllers.ControllerType.VelocityLimitController);
                if (maxLinearVelocity === 0 || maxLinearVelocity === 3.40282347E+38) {
                    this.LimitLinearVelocity = false;
                }

                if (maxAngularVelocity === 0 || maxAngularVelocity === 3.40282347E+38) {
                    this.LimitAngularVelocity = false;
                }

                this.MaxLinearVelocity = maxLinearVelocity;
                this.MaxAngularVelocity = maxAngularVelocity;
            }
        },
        methods: {
            Update: function (dt) {
                var $t;
                $t = Bridge.getEnumerator(this._bodies);
                try {
                    while ($t.moveNext()) {
                        var body = $t.Current;
                        if (!this.IsActiveOn(body)) {
                            continue;
                        }

                        if (this.LimitLinearVelocity) {
                            var translationX = dt * body.LinearVelocityInternal.X;
                            var translationY = dt * body.LinearVelocityInternal.Y;
                            var result = translationX * translationX + translationY * translationY;

                            if (result > dt * this._maxLinearSqared) {
                                var sq = Math.sqrt(result);

                                var ratio = this._maxLinearVelocity / sq;
                                body.LinearVelocityInternal.X *= ratio;
                                body.LinearVelocityInternal.Y *= ratio;
                            }
                        }

                        if (this.LimitAngularVelocity) {
                            var rotation = dt * body.AngularVelocityInternal;
                            if (rotation * rotation > this._maxAngularSqared) {
                                var ratio1 = this._maxAngularVelocity / Math.abs(rotation);
                                body.AngularVelocityInternal *= ratio1;
                            }
                        }
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }},
            AddBody: function (body) {
                this._bodies.add(body);
            },
            RemoveBody: function (body) {
                this._bodies.remove(body);
            }
        }
    });

    Bridge.define("Poly2Tri.Triangulation.Sets.ConstrainedPointSet", {
        inherits: [Poly2Tri.Triangulation.Sets.PointSet],
        fields: {
            _constrainedPointList: null,
            EdgeIndex: null
        },
        props: {
            TriangulationMode: {
                get: function () {
                    return Poly2Tri.Triangulation.TriangulationMode.Constrained;
                }
            }
        },
        alias: [
            "TriangulationMode", "Poly2Tri$Triangulation$Triangulatable$TriangulationMode",
            "PrepareTriangulation", "Poly2Tri$Triangulation$Triangulatable$PrepareTriangulation"
        ],
        ctors: {
            $ctor1: function (points, index) {
                this.$initialize();
                Poly2Tri.Triangulation.Sets.PointSet.ctor.call(this, points);
                this.EdgeIndex = index;
            },
            ctor: function (points, constraints) {
                this.$initialize();
                Poly2Tri.Triangulation.Sets.PointSet.ctor.call(this, points);
                this._constrainedPointList = new (System.Collections.Generic.List$1(Poly2Tri.Triangulation.TriangulationPoint)).ctor();
                this._constrainedPointList.AddRange(constraints);
            }
        },
        methods: {
            PrepareTriangulation: function (tcx) {
                var $t, $t1;
                Poly2Tri.Triangulation.Sets.PointSet.prototype.PrepareTriangulation.call(this, tcx);
                if (this._constrainedPointList != null) {
                    var p1, p2;
                    var iterator = this._constrainedPointList.GetEnumerator();
                    while (iterator.moveNext()) {
                        p1 = iterator.Current;
                        iterator.moveNext();
                        p2 = iterator.Current;
                        tcx.NewConstraint(p1, p2);
                    }
                } else {
                    for (var i = 0; i < this.EdgeIndex.length; i = (i + 2) | 0) {
                        tcx.NewConstraint(System.Array.getItem(this.Points, ($t = this.EdgeIndex)[System.Array.index(i, $t)], Poly2Tri.Triangulation.TriangulationPoint), System.Array.getItem(this.Points, ($t1 = this.EdgeIndex)[System.Array.index(((i + 1) | 0), $t1)], Poly2Tri.Triangulation.TriangulationPoint));
                    }
                }
            },
            isValid: function () {
                return true;
            }
        }
    });

    /**
     * Reference implementation for forces based on AbstractForceController
     It supports all features provided by the base class and illustrates proper
     usage as an easy to understand example.
     As a side-effect it is a nice and easy to use wind force for your projects
     *
     * @public
     * @class FarseerPhysics.Controllers.SimpleWindForce
     * @augments FarseerPhysics.Controllers.AbstractForceController
     */
    Bridge.define("FarseerPhysics.Controllers.SimpleWindForce", {
        inherits: [FarseerPhysics.Controllers.AbstractForceController],
        fields: {
            /**
             * Direction of the windforce
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Controllers.SimpleWindForce
             * @function Direction
             * @type Microsoft.Xna.Framework.Vector2
             */
            Direction: null,
            /**
             * The amount of Direction randomization. Allowed range is 0-1.
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Controllers.SimpleWindForce
             * @function Divergence
             * @type number
             */
            Divergence: 0,
            /**
             * Ignore the position and apply the force. If off only in the "front" (relative to position and direction)
             will be affected
             *
             * @instance
             * @public
             * @memberof FarseerPhysics.Controllers.SimpleWindForce
             * @function IgnorePosition
             * @type boolean
             */
            IgnorePosition: false
        },
        ctors: {
            init: function () {
                this.Direction = new Microsoft.Xna.Framework.Vector2();
            }
        },
        methods: {
            ApplyForce: function (dt, strength) {
                var $t;
                $t = Bridge.getEnumerator(this.World.BodyList);
                try {
                    while ($t.moveNext()) {
                        var body = $t.Current;
                        var decayMultiplier = this.GetDecayMultiplier(body);

                        if (decayMultiplier !== 0) {
                            var forceVector = new Microsoft.Xna.Framework.Vector2();

                            if (this.ForceType === FarseerPhysics.Controllers.AbstractForceController.ForceTypes.Point) {
                                forceVector = Microsoft.Xna.Framework.Vector2.op_Subtraction(body.Position.$clone(), this.Position.$clone());
                            } else {
                                this.Direction.Normalize();

                                forceVector = this.Direction.$clone();

                                if (forceVector.Length() === 0) {
                                    forceVector = new Microsoft.Xna.Framework.Vector2.$ctor2(0, 1);
                                }
                            }


                            if (this.Variation !== 0) {
                                var strengthVariation = this.Randomize.NextDouble() * Microsoft.Xna.Framework.MathHelper.Clamp$1(this.Variation, 0, 1);
                                forceVector.Normalize();
                                body.ApplyForce(Microsoft.Xna.Framework.Vector2.op_Multiply$1(Microsoft.Xna.Framework.Vector2.op_Multiply$1(Microsoft.Xna.Framework.Vector2.op_Multiply$1(forceVector.$clone(), strength), decayMultiplier), strengthVariation));
                            } else {
                                forceVector.Normalize();
                                body.ApplyForce(Microsoft.Xna.Framework.Vector2.op_Multiply$1(Microsoft.Xna.Framework.Vector2.op_Multiply$1(forceVector.$clone(), strength), decayMultiplier));
                            }
                        }
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }}
        }
    });
});

//# sourceMappingURL=data:application/json;base64,ewogICJ2ZXJzaW9uIjogMywKICAiZmlsZSI6ICJGYXJzZWVyUGh5c2ljcy5qcyIsCiAgInNvdXJjZVJvb3QiOiAiIiwKICAic291cmNlcyI6IFsiQ29sbGlzaW9uL1F1YWRUcmVlLmNzIiwiQ29sbGlzaW9uL0NvbGxpc2lvbi5jcyIsIkNvbGxpc2lvbi9EaXN0YW5jZS5jcyIsIkNvbGxpc2lvbi9EeW5hbWljVHJlZS5jcyIsIkNvbGxpc2lvbi9EeW5hbWljVHJlZUJyb2FkUGhhc2UuY3MiLCJDb2xsaXNpb24vVGltZU9mSW1wYWN0LmNzIiwiQ29sbGlzaW9uL1NoYXBlcy9TaGFwZS5jcyIsIkNvbW1vbi9Db252ZXhIdWxsL0NoYWluSHVsbC5jcyIsIkNvbW1vbi9Db252ZXhIdWxsL0dpZnRXcmFwLmNzIiwiQ29tbW9uL0NvbnZleEh1bGwvTWVsa21hbi5jcyIsIkNvbW1vbi9EZWNvbXBvc2l0aW9uL0JheWF6aXREZWNvbXBvc2VyLmNzIiwiQ29tbW9uL0RlY29tcG9zaXRpb24vQ0RURGVjb21wb3Nlci5jcyIsIkNvbW1vbi9EZWNvbXBvc2l0aW9uL0VhcmNsaXBEZWNvbXBvc2VyLmNzIiwiQ29tbW9uL0RlY29tcG9zaXRpb24vU2VpZGVsRGVjb21wb3Nlci5jcyIsIkNvbW1vbi9EZWNvbXBvc2l0aW9uL0ZsaXBjb2RlRGVjb21wb3Nlci5jcyIsIkNvbW1vbi9WZXJ0aWNlcy5jcyIsIkNvbW1vbi9GaXhlZEFycmF5LmNzIiwiQ29tbW9uL0xpbmVUb29scy5jcyIsIkNvbW1vbi9UZXh0dXJlVG9vbHMvTWFyY2hpbmdTcXVhcmVzLmNzIiwiQ29tbW9uL01hdGguY3MiLCJDb21tb24vVGV4dHVyZVRvb2xzL01TVGVycmFpbi5jcyIsIkR5bmFtaWNzL1dvcmxkLmNzIiwiQ29tbW9uL1BoeXNpY3NMb2dpYy9QaHlzaWNzTG9naWMuY3MiLCJDb21tb24vUGh5c2ljc0xvZ2ljL0V4cGxvc2lvbi5jcyIsIkNvbW1vbi9Qb2x5Z29uTWFuaXB1bGF0aW9uL0N1dHRpbmdUb29scy5jcyIsIkNvbW1vbi9Qb2x5Z29uTWFuaXB1bGF0aW9uL1NpbXBsaWZ5VG9vbHMuY3MiLCJDb21tb24vUG9seWdvbk1hbmlwdWxhdGlvbi9ZdVBlbmdDbGlwcGVyLmNzIiwiQ29tbW9uL1BvbHlnb25Ub29scy5jcyIsIkNvbW1vbi9UZXh0dXJlVG9vbHMvVGV4dHVyZUNvbnZlcnRlci5jcyIsIkNvbnRyb2xsZXJzL0NvbnRyb2xsZXIuY3MiLCJEZWJ1Z1ZpZXcuY3MiLCJEeW5hbWljcy9Cb2R5LmNzIiwiRHluYW1pY3MvQnJlYWthYmxlQm9keS5jcyIsIkR5bmFtaWNzL0ZpeHR1cmUuY3MiLCJEeW5hbWljcy9Db250YWN0TWFuYWdlci5jcyIsIkR5bmFtaWNzL0NvbnRhY3RzL0NvbnRhY3QuY3MiLCJEeW5hbWljcy9Db250YWN0cy9Db250YWN0U29sdmVyLmNzIiwiRHluYW1pY3MvSXNsYW5kLmNzIiwiRHluYW1pY3MvSm9pbnRzL0pvaW50LmNzIiwiRmFjdG9yaWVzL0JvZHlGYWN0b3J5LmNzIiwiRmFjdG9yaWVzL0ZpeHR1cmVGYWN0b3J5LmNzIiwiRmFjdG9yaWVzL0pvaW50RmFjdG9yeS5jcyIsIlNldHRpbmdzLmNzIiwiU2NyZWVuU3lzdGVtL0NhbWVyYTJELmNzIiwiQ29tbW9uLmNzIiwiU2NyZWVuU3lzdGVtL0NvbnZlcnRVbml0cy5jcyIsIlNjcmVlblN5c3RlbS9HYW1lU2NyZWVuLmNzIiwiU2NyZWVuU3lzdGVtL1NjcmVlbk1hbmFnZXJDb21wb25lbnQuY3MiLCJEcmF3aW5nU3lzdGVtL1Nwcml0ZS5jcyIsIkNvbW1vbi9EZWNvbXBvc2l0aW9uL0NEVC9EZWxhdW5heS9EZWxhdW5heVRyaWFuZ2xlLmNzIiwiQ29tbW9uL0RlY29tcG9zaXRpb24vQ0RUL0RlbGF1bmF5L1N3ZWVwL0FkdmFuY2luZ0Zyb250LmNzIiwiQ29tbW9uL0RlY29tcG9zaXRpb24vQ0RUL0RlbGF1bmF5L1N3ZWVwL0FkdmFuY2luZ0Zyb250Tm9kZS5jcyIsIkNvbW1vbi9EZWNvbXBvc2l0aW9uL0NEVC9EZWxhdW5heS9Td2VlcC9EVFN3ZWVwLmNzIiwiQ29tbW9uL0RlY29tcG9zaXRpb24vQ0RUL1RyaWFuZ3VsYXRpb25Db250ZXh0LmNzIiwiQ29tbW9uL0RlY29tcG9zaXRpb24vQ0RUL1RyaWFuZ3VsYXRpb25Qb2ludC5jcyIsIkNvbW1vbi9EZWNvbXBvc2l0aW9uL0NEVC9EZWxhdW5heS9Td2VlcC9Qb2ludE9uRWRnZUV4Y2VwdGlvbi5jcyIsIkNvbW1vbi9EZWNvbXBvc2l0aW9uL0NEVC9Qb2x5Z29uL1BvbHlnb25TZXQuY3MiLCJDb21tb24vRGVjb21wb3NpdGlvbi9DRFQvVHJpYW5ndWxhdGlvblV0aWwuY3MiLCJDb21tb24vRGVjb21wb3NpdGlvbi9DRFQvVXRpbC9GaXhlZEFycmF5My5jcyIsIkNvbW1vbi9EZWNvbXBvc2l0aW9uL0NEVC9VdGlsL0ZpeGVkQml0QXJyYXkzLmNzIiwiQ29tbW9uL0RlY29tcG9zaXRpb24vQ0RUL1V0aWwvUG9pbnRHZW5lcmF0b3IuY3MiLCJDb21tb24vRGVjb21wb3NpdGlvbi9DRFQvVXRpbC9Qb2x5Z29uR2VuZXJhdG9yLmNzIiwiQ29sbGlzaW9uL1NoYXBlcy9DaXJjbGVTaGFwZS5jcyIsIkNvbGxpc2lvbi9TaGFwZXMvRWRnZVNoYXBlLmNzIiwiQ29sbGlzaW9uL1NoYXBlcy9Mb29wU2hhcGUuY3MiLCJDb2xsaXNpb24vU2hhcGVzL1BvbHlnb25TaGFwZS5jcyIsIkR5bmFtaWNzL0pvaW50cy9BbmdsZUpvaW50LmNzIiwiRHluYW1pY3MvSm9pbnRzL0Rpc3RhbmNlSm9pbnQuY3MiLCJEeW5hbWljcy9Kb2ludHMvRml4ZWRBbmdsZUpvaW50LmNzIiwiRHluYW1pY3MvSm9pbnRzL0ZpeGVkRGlzdGFuY2VKb2ludC5jcyIsIkR5bmFtaWNzL0pvaW50cy9GaXhlZEZyaWN0aW9uSm9pbnQuY3MiLCJEeW5hbWljcy9Kb2ludHMvRml4ZWRMaW5lSm9pbnQuY3MiLCJEeW5hbWljcy9Kb2ludHMvRml4ZWRNb3VzZUpvaW50LmNzIiwiRHluYW1pY3MvSm9pbnRzL0ZpeGVkUHJpc21hdGljSm9pbnQuY3MiLCJEeW5hbWljcy9Kb2ludHMvRml4ZWRSZXZvbHV0ZUpvaW50LmNzIiwiRHluYW1pY3MvSm9pbnRzL0ZyaWN0aW9uSm9pbnQuY3MiLCJEeW5hbWljcy9Kb2ludHMvR2VhckpvaW50LmNzIiwiRHluYW1pY3MvSm9pbnRzL0xpbmVKb2ludC5jcyIsIkR5bmFtaWNzL0pvaW50cy9QcmlzbWF0aWNKb2ludC5jcyIsIkR5bmFtaWNzL0pvaW50cy9QdWxsZXlKb2ludC5jcyIsIkR5bmFtaWNzL0pvaW50cy9SZXZvbHV0ZUpvaW50LmNzIiwiRHluYW1pY3MvSm9pbnRzL1JvcGVKb2ludC5jcyIsIkR5bmFtaWNzL0pvaW50cy9TbGlkZXJKb2ludC5jcyIsIkR5bmFtaWNzL0pvaW50cy9XZWxkSm9pbnQuY3MiLCJTY3JlZW5TeXN0ZW0vUGh5c2ljc0dhbWVTY3JlZW4uY3MiLCJDb21tb24vRGVjb21wb3NpdGlvbi9DRFQvRGVsYXVuYXkvU3dlZXAvRFRTd2VlcENvbnN0cmFpbnQuY3MiLCJDb21tb24vRGVjb21wb3NpdGlvbi9DRFQvRGVsYXVuYXkvU3dlZXAvRFRTd2VlcENvbnRleHQuY3MiLCJDb21tb24vRGVjb21wb3NpdGlvbi9DRFQvRGVsYXVuYXkvU3dlZXAvRFRTd2VlcFBvaW50Q29tcGFyYXRvci5jcyIsIkNvbW1vbi9EZWNvbXBvc2l0aW9uL0NEVC9Qb2x5Z29uL1BvbHlnb24uY3MiLCJDb21tb24vRGVjb21wb3NpdGlvbi9DRFQvUG9seWdvbi9Qb2x5Z29uUG9pbnQuY3MiLCJDb21tb24vRGVjb21wb3NpdGlvbi9DRFQvU2V0cy9Qb2ludFNldC5jcyIsIkNvbGxpc2lvbi9RdWFkVHJlZUJyb2FkUGhhc2UuY3MiLCJDb250cm9sbGVycy9BYnN0cmFjdEZvcmNlQ29udHJvbGxlci5jcyIsIkNvbnRyb2xsZXJzL0J1b3lhbmN5Q29udHJvbGxlci5jcyIsIkNvbnRyb2xsZXJzL0dyYXZpdHlDb250cm9sbGVyLmNzIiwiQ29udHJvbGxlcnMvVmVsb2NpdHlMaW1pdENvbnRyb2xsZXIuY3MiLCJDb21tb24vRGVjb21wb3NpdGlvbi9DRFQvU2V0cy9Db25zdHJhaW5lZFBvaW50U2V0LmNzIiwiQ29udHJvbGxlcnMvU2ltcGxlV2luZEZvcmNlLmNzIl0sCiAgIm5hbWVzIjogWyIiXSwKICAibWFwcGluZ3MiOiAiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7NEJBV21CQSxPQUFTQTs7Z0JBRXBCQSxZQUFPQTtnQkFDUEEsYUFBUUE7Z0JBQ1JBLGNBQVNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7a0NDOE02QkEsSUFBSUE7Ozs7dUNBd0xYQSxHQUFRQTs7O29CQUVuQ0EsT0FBT0EsNENBQWdCQSxHQUFPQTs7eUNBR0hBLEdBQVlBO29CQUV2Q0EsU0FBYUEsd0VBQWVBO29CQUM1QkEsU0FBYUEsd0VBQWVBOztvQkFFNUJBLElBQUlBLGNBQWVBO3dCQUNmQTs7O29CQUVKQSxJQUFJQSxjQUFlQTt3QkFDZkE7OztvQkFFSkE7O3lDQUcyQkEsUUFBY0EsUUFDZEEsUUFBY0EsUUFDZEEsS0FBbUJBO29CQUU5Q0EsZ0RBQWtCQSxRQUFRQTtvQkFDMUJBLGdEQUFrQkEsUUFBUUE7b0JBQzFCQSxrREFBb0JBO29CQUNwQkEsa0RBQW9CQTtvQkFDcEJBOztvQkFFQUE7b0JBQ0FBO29CQUNBQSxrREFBNkJBLFFBQVlBLE9BQU9BOztvQkFFaERBLE9BQU9BLG9CQUFrQkE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O29CQXRMbkJBLE9BQU9BLG1EQUFPQSxDQUFDQSxzRUFBYUE7Ozs7Ozs7Ozs7Ozs7OztvQkFTNUJBLE9BQU9BLG1EQUFPQSxDQUFDQSx5RUFBYUE7Ozs7Ozs7Ozs7Ozs7OztvQkFXOUJBLFNBQVdBLG9CQUFlQTtvQkFDMUJBLFNBQVdBLG9CQUFlQTtvQkFDMUJBLE9BQU9BLE1BQU9BLENBQUNBLEtBQUtBOzs7Ozs7Ozs7Ozs7Ozs7b0JBWXBCQSxlQUFvQkEsSUFBSUE7b0JBQ3hCQSxhQUFhQTtvQkFDYkEsYUFBYUEsSUFBSUEsdUNBQVFBLG1CQUFjQTtvQkFDdkNBLGFBQWFBO29CQUNiQSxhQUFhQSxJQUFJQSx1Q0FBUUEs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REE7Z0NBQ0FBLGdCQUFnQkEsa0hBQWNBLFdBQVdBIiwKICAic291cmNlc0NvbnRlbnQiOiBbInVzaW5nIFN5c3RlbTtcclxudXNpbmcgU3lzdGVtLkNvbGxlY3Rpb25zLkdlbmVyaWM7XHJcbnVzaW5nIEZhcnNlZXJQaHlzaWNzLkNvbGxpc2lvbjtcclxudXNpbmcgTWljcm9zb2Z0LlhuYS5GcmFtZXdvcms7XHJcblxyXG5wdWJsaWMgY2xhc3MgRWxlbWVudDxUPlxyXG57XHJcbiAgICBwdWJsaWMgUXVhZFRyZWU8VD4gUGFyZW50O1xyXG4gICAgcHVibGljIEFBQkIgU3BhbjtcclxuICAgIHB1YmxpYyBUIFZhbHVlO1xyXG5cclxuICAgIHB1YmxpYyBFbGVtZW50KFQgdmFsdWUsIEFBQkIgc3BhbilcclxuICAgIHtcclxuICAgICAgICBTcGFuID0gc3BhbjtcclxuICAgICAgICBWYWx1ZSA9IHZhbHVlO1xyXG4gICAgICAgIFBhcmVudCA9IG51bGw7XHJcbiAgICB9XHJcbn1cclxuXHJcbnB1YmxpYyBjbGFzcyBRdWFkVHJlZTxUPlxyXG57XHJcbiAgICBwdWJsaWMgaW50IE1heEJ1Y2tldDtcclxuICAgIHB1YmxpYyBpbnQgTWF4RGVwdGg7XHJcbiAgICBwdWJsaWMgTGlzdDxFbGVtZW50PFQ+PiBOb2RlcztcclxuICAgIHB1YmxpYyBBQUJCIFNwYW47XHJcbiAgICBwdWJsaWMgUXVhZFRyZWU8VD5bXSBTdWJUcmVlcztcclxuXHJcbiAgICBwdWJsaWMgUXVhZFRyZWUoQUFCQiBzcGFuLCBpbnQgbWF4YnVja2V0LCBpbnQgbWF4ZGVwdGgpXHJcbiAgICB7XHJcbiAgICAgICAgU3BhbiA9IHNwYW47XHJcbiAgICAgICAgTm9kZXMgPSBuZXcgTGlzdDxFbGVtZW50PFQ+PigpO1xyXG5cclxuICAgICAgICBNYXhCdWNrZXQgPSBtYXhidWNrZXQ7XHJcbiAgICAgICAgTWF4RGVwdGggPSBtYXhkZXB0aDtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgYm9vbCBJc1BhcnRpdGlvbmVkXHJcbiAgICB7XHJcbiAgICAgICAgZ2V0IHsgcmV0dXJuIFN1YlRyZWVzICE9IG51bGw7IH1cclxuICAgIH1cclxuXHJcbiAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAvLy8gcmV0dXJucyB0aGUgcXVhZHJhbnQgb2Ygc3BhbiB0aGF0IGVudGlyZWx5IGNvbnRhaW5zIHRlc3QuIGlmIG5vbmUsIHJldHVybiAwLlxyXG4gICAgLy8vIDwvc3VtbWFyeT5cclxuICAgIC8vLyA8cGFyYW0gbmFtZT1cInNwYW5cIj48L3BhcmFtPlxyXG4gICAgLy8vIDxwYXJhbSBuYW1lPVwidGVzdFwiPjwvcGFyYW0+XHJcbiAgICAvLy8gPHJldHVybnM+PC9yZXR1cm5zPlxyXG4gICAgcHJpdmF0ZSBpbnQgUGFydGl0aW9uKEFBQkIgc3BhbiwgQUFCQiB0ZXN0KVxyXG4gICAge1xyXG4gICAgICAgIGlmIChzcGFuLlExLkNvbnRhaW5zKHJlZiB0ZXN0KSkgcmV0dXJuIDE7XHJcbiAgICAgICAgaWYgKHNwYW4uUTIuQ29udGFpbnMocmVmIHRlc3QpKSByZXR1cm4gMjtcclxuICAgICAgICBpZiAoc3Bhbi5RMy5Db250YWlucyhyZWYgdGVzdCkpIHJldHVybiAzO1xyXG4gICAgICAgIGlmIChzcGFuLlE0LkNvbnRhaW5zKHJlZiB0ZXN0KSkgcmV0dXJuIDQ7XHJcblxyXG4gICAgICAgIHJldHVybiAwO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyB2b2lkIEFkZE5vZGUoRWxlbWVudDxUPiBub2RlKVxyXG4gICAge1xyXG4gICAgICAgIGlmICghSXNQYXJ0aXRpb25lZClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGlmIChOb2Rlcy5Db3VudCA+PSBNYXhCdWNrZXQgJiYgTWF4RGVwdGggPiAwKSAvL2JpbiBpcyBmdWxsIGFuZCBjYW4gc3RpbGwgc3ViZGl2aWRlXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIC8vXHJcbiAgICAgICAgICAgICAgICAvL3BhcnRpdGlvbiBpbnRvIHF1YWRyYW50cyBhbmQgc29ydCBleGlzdGluZyBub2RlcyBhbW9uc3QgcXVhZHMuXHJcbiAgICAgICAgICAgICAgICAvL1xyXG4gICAgICAgICAgICAgICAgTm9kZXMuQWRkKG5vZGUpOyAvL3RyZWF0IG5ldyBub2RlIGp1c3QgbGlrZSBvdGhlciBub2RlcyBmb3IgcGFydGl0aW9uaW5nXHJcblxyXG4gICAgICAgICAgICAgICAgU3ViVHJlZXMgPSBuZXcgUXVhZFRyZWU8VD5bNF07XHJcbiAgICAgICAgICAgICAgICBTdWJUcmVlc1swXSA9IG5ldyBRdWFkVHJlZTxUPihTcGFuLlExLCBNYXhCdWNrZXQsIE1heERlcHRoIC0gMSk7XHJcbiAgICAgICAgICAgICAgICBTdWJUcmVlc1sxXSA9IG5ldyBRdWFkVHJlZTxUPihTcGFuLlEyLCBNYXhCdWNrZXQsIE1heERlcHRoIC0gMSk7XHJcbiAgICAgICAgICAgICAgICBTdWJUcmVlc1syXSA9IG5ldyBRdWFkVHJlZTxUPihTcGFuLlEzLCBNYXhCdWNrZXQsIE1heERlcHRoIC0gMSk7XHJcbiAgICAgICAgICAgICAgICBTdWJUcmVlc1szXSA9IG5ldyBRdWFkVHJlZTxUPihTcGFuLlE0LCBNYXhCdWNrZXQsIE1heERlcHRoIC0gMSk7XHJcblxyXG4gICAgICAgICAgICAgICAgTGlzdDxFbGVtZW50PFQ+PiByZW1Ob2RlcyA9IG5ldyBMaXN0PEVsZW1lbnQ8VD4+KCk7XHJcbiAgICAgICAgICAgICAgICAvL25vZGVzIHRoYXQgYXJlIG5vdCBmdWxseSBjb250YWluZWQgYnkgYW55IHF1YWRyYW50XHJcblxyXG4gICAgICAgICAgICAgICAgZm9yZWFjaCAoRWxlbWVudDxUPiBuIGluIE5vZGVzKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoUGFydGl0aW9uKFNwYW4sIG4uU3BhbikpXHJcbiAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDE6IC8vcXVhZHJhbnQgMVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgU3ViVHJlZXNbMF0uQWRkTm9kZShuKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDI6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBTdWJUcmVlc1sxXS5BZGROb2RlKG4pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMzpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFN1YlRyZWVzWzJdLkFkZE5vZGUobik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSA0OlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgU3ViVHJlZXNbM10uQWRkTm9kZShuKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbi5QYXJlbnQgPSB0aGlzO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVtTm9kZXMuQWRkKG4pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIE5vZGVzID0gcmVtTm9kZXM7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBub2RlLlBhcmVudCA9IHRoaXM7XHJcbiAgICAgICAgICAgICAgICBOb2Rlcy5BZGQobm9kZSk7XHJcbiAgICAgICAgICAgICAgICAvL2lmIGJpbiBpcyBub3QgeWV0IGZ1bGwgb3IgbWF4IGRlcHRoIGhhcyBiZWVuIHJlYWNoZWQsIGp1c3QgYWRkIHRoZSBub2RlIHdpdGhvdXQgc3ViZGl2aWRpbmdcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIC8vd2UgYWxyZWFkeSBoYXZlIGNoaWxkcmVuIG5vZGVzXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICAvL1xyXG4gICAgICAgICAgICAvL2FkZCBub2RlIHRvIHNwZWNpZmljIHN1Yi10cmVlXHJcbiAgICAgICAgICAgIC8vXHJcbiAgICAgICAgICAgIHN3aXRjaCAoUGFydGl0aW9uKFNwYW4sIG5vZGUuU3BhbikpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGNhc2UgMTogLy9xdWFkcmFudCAxXHJcbiAgICAgICAgICAgICAgICAgICAgU3ViVHJlZXNbMF0uQWRkTm9kZShub2RlKTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgMjpcclxuICAgICAgICAgICAgICAgICAgICBTdWJUcmVlc1sxXS5BZGROb2RlKG5vZGUpO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSAzOlxyXG4gICAgICAgICAgICAgICAgICAgIFN1YlRyZWVzWzJdLkFkZE5vZGUobm9kZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDQ6XHJcbiAgICAgICAgICAgICAgICAgICAgU3ViVHJlZXNbM10uQWRkTm9kZShub2RlKTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICAgICAgbm9kZS5QYXJlbnQgPSB0aGlzO1xyXG4gICAgICAgICAgICAgICAgICAgIE5vZGVzLkFkZChub2RlKTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAvLy8gdGVzdHMgaWYgcmF5IGludGVyc2VjdHMgQUFCQlxyXG4gICAgLy8vIDwvc3VtbWFyeT5cclxuICAgIC8vLyA8cGFyYW0gbmFtZT1cImFhYmJcIj48L3BhcmFtPlxyXG4gICAgLy8vIDxyZXR1cm5zPjwvcmV0dXJucz5cclxuICAgIHB1YmxpYyBzdGF0aWMgYm9vbCBSYXlDYXN0QUFCQihBQUJCIGFhYmIsIFZlY3RvcjIgcDEsIFZlY3RvcjIgcDIpXHJcbiAgICB7XHJcbiAgICAgICAgQUFCQiBzZWdtZW50QUFCQiA9IG5ldyBBQUJCKCk7XHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBWZWN0b3IyLk1pbihyZWYgcDEsIHJlZiBwMiwgb3V0IHNlZ21lbnRBQUJCLkxvd2VyQm91bmQpO1xyXG4gICAgICAgICAgICBWZWN0b3IyLk1heChyZWYgcDEsIHJlZiBwMiwgb3V0IHNlZ21lbnRBQUJCLlVwcGVyQm91bmQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIUFBQkIuVGVzdE92ZXJsYXAoYWFiYiwgc2VnbWVudEFBQkIpKSByZXR1cm4gZmFsc2U7XHJcblxyXG4gICAgICAgIFZlY3RvcjIgcmF5RGlyID0gcDIgLSBwMTtcclxuICAgICAgICBWZWN0b3IyIHJheVBvcyA9IHAxO1xyXG5cclxuICAgICAgICBWZWN0b3IyIG5vcm0gPSBuZXcgVmVjdG9yMigtcmF5RGlyLlksIHJheURpci5YKTsgLy9ub3JtYWwgdG8gcmF5XHJcbiAgICAgICAgaWYgKG5vcm0uTGVuZ3RoKCkgPT0gMC4wKVxyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTsgLy9pZiByYXkgaXMganVzdCBhIHBvaW50LCByZXR1cm4gdHJ1ZSAoaWZmIHBvaW50IGlzIHdpdGhpbiBhYWJiLCBhcyB0ZXN0ZWQgZWFybGllcilcclxuICAgICAgICBub3JtLk5vcm1hbGl6ZSgpO1xyXG5cclxuICAgICAgICBmbG9hdCBkUG9zID0gVmVjdG9yMi5Eb3QocmF5UG9zLCBub3JtKTtcclxuXHJcbiAgICAgICAgVmVjdG9yMltdIHZlcnRzID0gYWFiYi5HZXRWZXJ0aWNlcygpO1xyXG4gICAgICAgIGZsb2F0IGQwID0gVmVjdG9yMi5Eb3QodmVydHNbMF0sIG5vcm0pIC0gZFBvcztcclxuICAgICAgICBmb3IgKGludCBpID0gMTsgaSA8IDQ7IGkrKylcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGZsb2F0IGQgPSBWZWN0b3IyLkRvdCh2ZXJ0c1tpXSwgbm9ybSkgLSBkUG9zO1xyXG4gICAgICAgICAgICBpZiAoTWF0aC5TaWduKGQpICE9IE1hdGguU2lnbihkMCkpXHJcbiAgICAgICAgICAgICAgICAvL3JldHVybiB0cnVlIGlmIHRoZSByYXkgc3BsaXRzIHRoZSB2ZXJ0aWNlcyAoaWU6IHNpZ24gb2YgZG90IHByb2R1Y3RzIHdpdGggbm9ybWFsIGFyZSBub3QgYWxsIHNhbWUpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgdm9pZCBRdWVyeUFBQkIoRnVuYzxFbGVtZW50PFQ+LCBib29sPiBjYWxsYmFjaywgcmVmIEFBQkIgc2VhcmNoUilcclxuICAgIHtcclxuICAgICAgICBTdGFjazxRdWFkVHJlZTxUPj4gc3RhY2sgPSBuZXcgU3RhY2s8UXVhZFRyZWU8VD4+KCk7XHJcbiAgICAgICAgc3RhY2suUHVzaCh0aGlzKTtcclxuXHJcbiAgICAgICAgd2hpbGUgKHN0YWNrLkNvdW50ID4gMClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIFF1YWRUcmVlPFQ+IHF0ID0gc3RhY2suUG9wKCk7XHJcbiAgICAgICAgICAgIGlmICghQUFCQi5UZXN0T3ZlcmxhcChyZWYgc2VhcmNoUiwgcmVmIHF0LlNwYW4pKVxyXG4gICAgICAgICAgICAgICAgY29udGludWU7XHJcblxyXG4gICAgICAgICAgICBmb3JlYWNoIChFbGVtZW50PFQ+IG4gaW4gcXQuTm9kZXMpXHJcbiAgICAgICAgICAgICAgICBpZiAoQUFCQi5UZXN0T3ZlcmxhcChyZWYgc2VhcmNoUiwgcmVmIG4uU3BhbikpXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFjYWxsYmFjayhuKSkgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKHF0LklzUGFydGl0aW9uZWQpXHJcbiAgICAgICAgICAgICAgICBmb3JlYWNoIChRdWFkVHJlZTxUPiBzdCBpbiBxdC5TdWJUcmVlcylcclxuICAgICAgICAgICAgICAgICAgICBzdGFjay5QdXNoKHN0KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIHZvaWQgUmF5Q2FzdChGdW5jPFJheUNhc3RJbnB1dCwgRWxlbWVudDxUPiwgZmxvYXQ+IGNhbGxiYWNrLCByZWYgUmF5Q2FzdElucHV0IGlucHV0KVxyXG4gICAge1xyXG4gICAgICAgIFN0YWNrPFF1YWRUcmVlPFQ+PiBzdGFjayA9IG5ldyBTdGFjazxRdWFkVHJlZTxUPj4oKTtcclxuICAgICAgICBzdGFjay5QdXNoKHRoaXMpO1xyXG5cclxuICAgICAgICBmbG9hdCBtYXhGcmFjdGlvbiA9IGlucHV0Lk1heEZyYWN0aW9uO1xyXG4gICAgICAgIFZlY3RvcjIgcDEgPSBpbnB1dC5Qb2ludDE7XHJcbiAgICAgICAgVmVjdG9yMiBwMiA9IHAxICsgKGlucHV0LlBvaW50MiAtIGlucHV0LlBvaW50MSkgKiBtYXhGcmFjdGlvbjtcclxuXHJcbiAgICAgICAgd2hpbGUgKHN0YWNrLkNvdW50ID4gMClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIFF1YWRUcmVlPFQ+IHF0ID0gc3RhY2suUG9wKCk7XHJcblxyXG4gICAgICAgICAgICBpZiAoIVJheUNhc3RBQUJCKHF0LlNwYW4sIHAxLCBwMikpXHJcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuXHJcbiAgICAgICAgICAgIGZvcmVhY2ggKEVsZW1lbnQ8VD4gbiBpbiBxdC5Ob2RlcylcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgaWYgKCFSYXlDYXN0QUFCQihuLlNwYW4sIHAxLCBwMikpXHJcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcblxyXG4gICAgICAgICAgICAgICAgUmF5Q2FzdElucHV0IHN1YklucHV0O1xyXG4gICAgICAgICAgICAgICAgc3ViSW5wdXQuUG9pbnQxID0gaW5wdXQuUG9pbnQxO1xyXG4gICAgICAgICAgICAgICAgc3ViSW5wdXQuUG9pbnQyID0gaW5wdXQuUG9pbnQyO1xyXG4gICAgICAgICAgICAgICAgc3ViSW5wdXQuTWF4RnJhY3Rpb24gPSBtYXhGcmFjdGlvbjtcclxuXHJcbiAgICAgICAgICAgICAgICBmbG9hdCB2YWx1ZSA9IGNhbGxiYWNrKHN1YklucHV0LCBuKTtcclxuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA9PSAwLjBmKVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjsgLy8gdGhlIGNsaWVudCBoYXMgdGVybWluYXRlZCB0aGUgcmF5Y2FzdC5cclxuXHJcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgPD0gMC4wZilcclxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuXHJcbiAgICAgICAgICAgICAgICBtYXhGcmFjdGlvbiA9IHZhbHVlO1xyXG4gICAgICAgICAgICAgICAgcDIgPSBwMSArIChpbnB1dC5Qb2ludDIgLSBpbnB1dC5Qb2ludDEpICogbWF4RnJhY3Rpb247IC8vdXBkYXRlIHNlZ21lbnQgZW5kcG9pbnRcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoSXNQYXJ0aXRpb25lZClcclxuICAgICAgICAgICAgICAgIGZvcmVhY2ggKFF1YWRUcmVlPFQ+IHN0IGluIHF0LlN1YlRyZWVzKVxyXG4gICAgICAgICAgICAgICAgICAgIHN0YWNrLlB1c2goc3QpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgdm9pZCBHZXRBbGxOb2Rlc1IocmVmIExpc3Q8RWxlbWVudDxUPj4gbm9kZXMpXHJcbiAgICB7XHJcbiAgICAgICAgbm9kZXMuQWRkUmFuZ2UoTm9kZXMpO1xyXG5cclxuICAgICAgICBpZiAoSXNQYXJ0aXRpb25lZClcclxuICAgICAgICAgICAgZm9yZWFjaCAoUXVhZFRyZWU8VD4gc3QgaW4gU3ViVHJlZXMpIHN0LkdldEFsbE5vZGVzUihyZWYgbm9kZXMpO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyB2b2lkIFJlbW92ZU5vZGUoRWxlbWVudDxUPiBub2RlKVxyXG4gICAge1xyXG4gICAgICAgIG5vZGUuUGFyZW50Lk5vZGVzLlJlbW92ZShub2RlKTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgdm9pZCBSZWNvbnN0cnVjdCgpXHJcbiAgICB7XHJcbiAgICAgICAgTGlzdDxFbGVtZW50PFQ+PiBhbGxOb2RlcyA9IG5ldyBMaXN0PEVsZW1lbnQ8VD4+KCk7XHJcbiAgICAgICAgR2V0QWxsTm9kZXNSKHJlZiBhbGxOb2Rlcyk7XHJcblxyXG4gICAgICAgIENsZWFyKCk7XHJcblxyXG4jaWYgTkVURlhfQ09SRVxyXG4gICAgICAgIGZvcmVhY2ggKHZhciBub2RlIGluIGFsbE5vZGVzKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgQWRkTm9kZShub2RlKTtcclxuICAgICAgICB9XHJcbiNlbHNlXHJcbiAgICAgICAgYWxsTm9kZXMuRm9yRWFjaCgoZ2xvYmFsOjpTeXN0ZW0uQWN0aW9uPGdsb2JhbDo6RWxlbWVudDxUPj4pQWRkTm9kZSk7XHJcbiNlbmRpZlxyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyB2b2lkIENsZWFyKClcclxuICAgIHtcclxuICAgICAgICBOb2Rlcy5DbGVhcigpO1xyXG4gICAgICAgIFN1YlRyZWVzID0gbnVsbDtcclxuICAgIH1cclxufSIsIi8qXHJcbiogRmFyc2VlciBQaHlzaWNzIEVuZ2luZSBiYXNlZCBvbiBCb3gyRC5YTkEgcG9ydDpcclxuKiBDb3B5cmlnaHQgKGMpIDIwMTAgSWFuIFF2aXN0XHJcbiogXHJcbiogQm94MkQuWE5BIHBvcnQgb2YgQm94MkQ6XHJcbiogQ29weXJpZ2h0IChjKSAyMDA5IEJyYW5kb24gRnVydHdhbmdsZXIsIE5hdGhhbiBGdXJ0d2FuZ2xlclxyXG4qXHJcbiogT3JpZ2luYWwgc291cmNlIEJveDJEOlxyXG4qIENvcHlyaWdodCAoYykgMjAwNi0yMDA5IEVyaW4gQ2F0dG8gaHR0cDovL3d3dy5ncGh5c2ljcy5jb20gXHJcbiogXHJcbiogVGhpcyBzb2Z0d2FyZSBpcyBwcm92aWRlZCAnYXMtaXMnLCB3aXRob3V0IGFueSBleHByZXNzIG9yIGltcGxpZWQgXHJcbiogd2FycmFudHkuICBJbiBubyBldmVudCB3aWxsIHRoZSBhdXRob3JzIGJlIGhlbGQgbGlhYmxlIGZvciBhbnkgZGFtYWdlcyBcclxuKiBhcmlzaW5nIGZyb20gdGhlIHVzZSBvZiB0aGlzIHNvZnR3YXJlLiBcclxuKiBQZXJtaXNzaW9uIGlzIGdyYW50ZWQgdG8gYW55b25lIHRvIHVzZSB0aGlzIHNvZnR3YXJlIGZvciBhbnkgcHVycG9zZSwgXHJcbiogaW5jbHVkaW5nIGNvbW1lcmNpYWwgYXBwbGljYXRpb25zLCBhbmQgdG8gYWx0ZXIgaXQgYW5kIHJlZGlzdHJpYnV0ZSBpdCBcclxuKiBmcmVlbHksIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyByZXN0cmljdGlvbnM6IFxyXG4qIDEuIFRoZSBvcmlnaW4gb2YgdGhpcyBzb2Z0d2FyZSBtdXN0IG5vdCBiZSBtaXNyZXByZXNlbnRlZDsgeW91IG11c3Qgbm90IFxyXG4qIGNsYWltIHRoYXQgeW91IHdyb3RlIHRoZSBvcmlnaW5hbCBzb2Z0d2FyZS4gSWYgeW91IHVzZSB0aGlzIHNvZnR3YXJlIFxyXG4qIGluIGEgcHJvZHVjdCwgYW4gYWNrbm93bGVkZ21lbnQgaW4gdGhlIHByb2R1Y3QgZG9jdW1lbnRhdGlvbiB3b3VsZCBiZSBcclxuKiBhcHByZWNpYXRlZCBidXQgaXMgbm90IHJlcXVpcmVkLiBcclxuKiAyLiBBbHRlcmVkIHNvdXJjZSB2ZXJzaW9ucyBtdXN0IGJlIHBsYWlubHkgbWFya2VkIGFzIHN1Y2gsIGFuZCBtdXN0IG5vdCBiZSBcclxuKiBtaXNyZXByZXNlbnRlZCBhcyBiZWluZyB0aGUgb3JpZ2luYWwgc29mdHdhcmUuIFxyXG4qIDMuIFRoaXMgbm90aWNlIG1heSBub3QgYmUgcmVtb3ZlZCBvciBhbHRlcmVkIGZyb20gYW55IHNvdXJjZSBkaXN0cmlidXRpb24uIFxyXG4qL1xyXG5cclxudXNpbmcgU3lzdGVtO1xyXG51c2luZyBTeXN0ZW0uRGlhZ25vc3RpY3M7XHJcbnVzaW5nIFN5c3RlbS5SdW50aW1lLkludGVyb3BTZXJ2aWNlcztcclxudXNpbmcgRmFyc2VlclBoeXNpY3MuQ29sbGlzaW9uLlNoYXBlcztcclxudXNpbmcgRmFyc2VlclBoeXNpY3MuQ29tbW9uO1xyXG51c2luZyBNaWNyb3NvZnQuWG5hLkZyYW1ld29yaztcclxuXHJcbm5hbWVzcGFjZSBGYXJzZWVyUGh5c2ljcy5Db2xsaXNpb25cclxue1xyXG4gICAgaW50ZXJuYWwgZW51bSBDb250YWN0RmVhdHVyZVR5cGUgOiBieXRlXHJcbiAgICB7XHJcbiAgICAgICAgVmVydGV4ID0gMCxcclxuICAgICAgICBGYWNlID0gMSxcclxuICAgIH1cclxuXHJcbiAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAvLy8gVGhlIGZlYXR1cmVzIHRoYXQgaW50ZXJzZWN0IHRvIGZvcm0gdGhlIGNvbnRhY3QgcG9pbnRcclxuICAgIC8vLyBUaGlzIG11c3QgYmUgNCBieXRlcyBvciBsZXNzLlxyXG4gICAgLy8vIDwvc3VtbWFyeT5cclxuICAgIHB1YmxpYyBzdHJ1Y3QgQ29udGFjdEZlYXR1cmVcclxuICAgIHtcclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIEZlYXR1cmUgaW5kZXggb24gU2hhcGVBXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICBwdWJsaWMgYnl0ZSBJbmRleEE7XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gRmVhdHVyZSBpbmRleCBvbiBTaGFwZUJcclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIHB1YmxpYyBieXRlIEluZGV4QjtcclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBUaGUgZmVhdHVyZSB0eXBlIG9uIFNoYXBlQVxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgcHVibGljIGJ5dGUgVHlwZUE7XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gVGhlIGZlYXR1cmUgdHlwZSBvbiBTaGFwZUJcclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIHB1YmxpYyBieXRlIFR5cGVCO1xyXG4gICAgfVxyXG5cclxuICAgIC8vLyA8c3VtbWFyeT5cclxuICAgIC8vLyBDb250YWN0IGlkcyB0byBmYWNpbGl0YXRlIHdhcm0gc3RhcnRpbmcuXHJcbiAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgW1N0cnVjdExheW91dChMYXlvdXRLaW5kLkV4cGxpY2l0KV1cclxuICAgIHB1YmxpYyBzdHJ1Y3QgQ29udGFjdElEXHJcbiAgICB7XHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBUaGUgZmVhdHVyZXMgdGhhdCBpbnRlcnNlY3QgdG8gZm9ybSB0aGUgY29udGFjdCBwb2ludFxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgW0ZpZWxkT2Zmc2V0KDApXVxyXG4gICAgICAgIHB1YmxpYyBDb250YWN0RmVhdHVyZSBGZWF0dXJlcztcclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBVc2VkIHRvIHF1aWNrbHkgY29tcGFyZSBjb250YWN0IGlkcy5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIFtGaWVsZE9mZnNldCgwKV1cclxuICAgICAgICBwdWJsaWMgdWludCBLZXk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgLy8vIEEgbWFuaWZvbGQgcG9pbnQgaXMgYSBjb250YWN0IHBvaW50IGJlbG9uZ2luZyB0byBhIGNvbnRhY3RcclxuICAgIC8vLyBtYW5pZm9sZC4gSXQgaG9sZHMgZGV0YWlscyByZWxhdGVkIHRvIHRoZSBnZW9tZXRyeSBhbmQgZHluYW1pY3NcclxuICAgIC8vLyBvZiB0aGUgY29udGFjdCBwb2ludHMuXHJcbiAgICAvLy8gVGhlIGxvY2FsIHBvaW50IHVzYWdlIGRlcGVuZHMgb24gdGhlIG1hbmlmb2xkIHR5cGU6XHJcbiAgICAvLy8gLVNoYXBlVHlwZS5DaXJjbGVzOiB0aGUgbG9jYWwgY2VudGVyIG9mIGNpcmNsZUJcclxuICAgIC8vLyAtU2VwYXJhdGlvbkZ1bmN0aW9uLkZhY2VBOiB0aGUgbG9jYWwgY2VudGVyIG9mIGNpcmxjZUIgb3IgdGhlIGNsaXAgcG9pbnQgb2YgcG9seWdvbkJcclxuICAgIC8vLyAtU2VwYXJhdGlvbkZ1bmN0aW9uLkZhY2VCOiB0aGUgY2xpcCBwb2ludCBvZiBwb2x5Z29uQVxyXG4gICAgLy8vIFRoaXMgc3RydWN0dXJlIGlzIHN0b3JlZCBhY3Jvc3MgdGltZSBzdGVwcywgc28gd2Uga2VlcCBpdCBzbWFsbC5cclxuICAgIC8vLyBOb3RlOiB0aGUgaW1wdWxzZXMgYXJlIHVzZWQgZm9yIGludGVybmFsIGNhY2hpbmcgYW5kIG1heSBub3RcclxuICAgIC8vLyBwcm92aWRlIHJlbGlhYmxlIGNvbnRhY3QgZm9yY2VzLCBlc3BlY2lhbGx5IGZvciBoaWdoIHNwZWVkIGNvbGxpc2lvbnMuXHJcbiAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgcHVibGljIHN0cnVjdCBNYW5pZm9sZFBvaW50XHJcbiAgICB7XHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBVbmlxdWVseSBpZGVudGlmaWVzIGEgY29udGFjdCBwb2ludCBiZXR3ZWVuIHR3byBTaGFwZXNcclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIHB1YmxpYyBDb250YWN0SUQgSWQ7XHJcblxyXG4gICAgICAgIHB1YmxpYyBWZWN0b3IyIExvY2FsUG9pbnQ7XHJcblxyXG4gICAgICAgIHB1YmxpYyBmbG9hdCBOb3JtYWxJbXB1bHNlO1xyXG5cclxuICAgICAgICBwdWJsaWMgZmxvYXQgVGFuZ2VudEltcHVsc2U7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGVudW0gTWFuaWZvbGRUeXBlXHJcbiAgICB7XHJcbiAgICAgICAgQ2lyY2xlcyxcclxuICAgICAgICBGYWNlQSxcclxuICAgICAgICBGYWNlQlxyXG4gICAgfVxyXG5cclxuICAgIC8vLyA8c3VtbWFyeT5cclxuICAgIC8vLyBBIG1hbmlmb2xkIGZvciB0d28gdG91Y2hpbmcgY29udmV4IFNoYXBlcy5cclxuICAgIC8vLyBCb3gyRCBzdXBwb3J0cyBtdWx0aXBsZSB0eXBlcyBvZiBjb250YWN0OlxyXG4gICAgLy8vIC0gY2xpcCBwb2ludCB2ZXJzdXMgcGxhbmUgd2l0aCByYWRpdXNcclxuICAgIC8vLyAtIHBvaW50IHZlcnN1cyBwb2ludCB3aXRoIHJhZGl1cyAoY2lyY2xlcylcclxuICAgIC8vLyBUaGUgbG9jYWwgcG9pbnQgdXNhZ2UgZGVwZW5kcyBvbiB0aGUgbWFuaWZvbGQgdHlwZTpcclxuICAgIC8vLyAtU2hhcGVUeXBlLkNpcmNsZXM6IHRoZSBsb2NhbCBjZW50ZXIgb2YgY2lyY2xlQVxyXG4gICAgLy8vIC1TZXBhcmF0aW9uRnVuY3Rpb24uRmFjZUE6IHRoZSBjZW50ZXIgb2YgZmFjZUFcclxuICAgIC8vLyAtU2VwYXJhdGlvbkZ1bmN0aW9uLkZhY2VCOiB0aGUgY2VudGVyIG9mIGZhY2VCXHJcbiAgICAvLy8gU2ltaWxhcmx5IHRoZSBsb2NhbCBub3JtYWwgdXNhZ2U6XHJcbiAgICAvLy8gLVNoYXBlVHlwZS5DaXJjbGVzOiBub3QgdXNlZFxyXG4gICAgLy8vIC1TZXBhcmF0aW9uRnVuY3Rpb24uRmFjZUE6IHRoZSBub3JtYWwgb24gcG9seWdvbkFcclxuICAgIC8vLyAtU2VwYXJhdGlvbkZ1bmN0aW9uLkZhY2VCOiB0aGUgbm9ybWFsIG9uIHBvbHlnb25CXHJcbiAgICAvLy8gV2Ugc3RvcmUgY29udGFjdHMgaW4gdGhpcyB3YXkgc28gdGhhdCBwb3NpdGlvbiBjb3JyZWN0aW9uIGNhblxyXG4gICAgLy8vIGFjY291bnQgZm9yIG1vdmVtZW50LCB3aGljaCBpcyBjcml0aWNhbCBmb3IgY29udGludW91cyBwaHlzaWNzLlxyXG4gICAgLy8vIEFsbCBjb250YWN0IHNjZW5hcmlvcyBtdXN0IGJlIGV4cHJlc3NlZCBpbiBvbmUgb2YgdGhlc2UgdHlwZXMuXHJcbiAgICAvLy8gVGhpcyBzdHJ1Y3R1cmUgaXMgc3RvcmVkIGFjcm9zcyB0aW1lIHN0ZXBzLCBzbyB3ZSBrZWVwIGl0IHNtYWxsLlxyXG4gICAgLy8vIDwvc3VtbWFyeT5cclxuICAgIHB1YmxpYyBzdHJ1Y3QgTWFuaWZvbGRcclxuICAgIHtcclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIE5vdCB1c2UgZm9yIFR5cGUuU2VwYXJhdGlvbkZ1bmN0aW9uLlBvaW50c1xyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgcHVibGljIFZlY3RvcjIgTG9jYWxOb3JtYWw7XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gVXNhZ2UgZGVwZW5kcyBvbiBtYW5pZm9sZCB0eXBlXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICBwdWJsaWMgVmVjdG9yMiBMb2NhbFBvaW50O1xyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIFRoZSBudW1iZXIgb2YgbWFuaWZvbGQgcG9pbnRzXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICBwdWJsaWMgaW50IFBvaW50Q291bnQ7XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gVGhlIHBvaW50cyBvZiBjb250YWN0XHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICBwdWJsaWMgRml4ZWRBcnJheTI8TWFuaWZvbGRQb2ludD4gUG9pbnRzO1xyXG5cclxuICAgICAgICBwdWJsaWMgTWFuaWZvbGRUeXBlIFR5cGU7XHJcbiAgICB9XHJcblxyXG4gICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgLy8vIFRoaXMgaXMgdXNlZCBmb3IgZGV0ZXJtaW5pbmcgdGhlIHN0YXRlIG9mIGNvbnRhY3QgcG9pbnRzLlxyXG4gICAgLy8vIDwvc3VtbWFyeT5cclxuICAgIHB1YmxpYyBlbnVtIFBvaW50U3RhdGVcclxuICAgIHtcclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIFBvaW50IGRvZXMgbm90IGV4aXN0XHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICBOdWxsLFxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIFBvaW50IHdhcyBhZGRlZCBpbiB0aGUgdXBkYXRlXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICBBZGQsXHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gUG9pbnQgcGVyc2lzdGVkIGFjcm9zcyB0aGUgdXBkYXRlXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICBQZXJzaXN0LFxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIFBvaW50IHdhcyByZW1vdmVkIGluIHRoZSB1cGRhdGVcclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIFJlbW92ZSxcclxuICAgIH1cclxuXHJcbiAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAvLy8gVXNlZCBmb3IgY29tcHV0aW5nIGNvbnRhY3QgbWFuaWZvbGRzLlxyXG4gICAgLy8vIDwvc3VtbWFyeT5cclxuICAgIHB1YmxpYyBzdHJ1Y3QgQ2xpcFZlcnRleFxyXG4gICAge1xyXG4gICAgICAgIHB1YmxpYyBDb250YWN0SUQgSUQ7XHJcbiAgICAgICAgcHVibGljIFZlY3RvcjIgVjtcclxuICAgIH1cclxuXHJcbiAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAvLy8gUmF5LWNhc3QgaW5wdXQgZGF0YS4gVGhlIHJheSBleHRlbmRzIGZyb20gcDEgdG8gcDEgKyBtYXhGcmFjdGlvbiAqIChwMiAtIHAxKS5cclxuICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICBwdWJsaWMgc3RydWN0IFJheUNhc3RJbnB1dFxyXG4gICAge1xyXG4gICAgICAgIHB1YmxpYyBmbG9hdCBNYXhGcmFjdGlvbjtcclxuICAgICAgICBwdWJsaWMgVmVjdG9yMiBQb2ludDEsIFBvaW50MjtcclxuICAgIH1cclxuXHJcbiAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAvLy8gUmF5LWNhc3Qgb3V0cHV0IGRhdGEuICBUaGUgcmF5IGhpdHMgYXQgcDEgKyBmcmFjdGlvbiAqIChwMiAtIHAxKSwgd2hlcmUgcDEgYW5kIHAyXHJcbiAgICAvLy8gY29tZSBmcm9tIFJheUNhc3RJbnB1dC4gXHJcbiAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgcHVibGljIHN0cnVjdCBSYXlDYXN0T3V0cHV0XHJcbiAgICB7XHJcbiAgICAgICAgcHVibGljIGZsb2F0IEZyYWN0aW9uO1xyXG4gICAgICAgIHB1YmxpYyBWZWN0b3IyIE5vcm1hbDtcclxuICAgIH1cclxuXHJcbiAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAvLy8gQW4gYXhpcyBhbGlnbmVkIGJvdW5kaW5nIGJveC5cclxuICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICBwdWJsaWMgc3RydWN0IEFBQkJcclxuICAgIHtcclxuICAgICAgICBwcml2YXRlIHN0YXRpYyBEaXN0YW5jZUlucHV0IF9pbnB1dCA9IG5ldyBEaXN0YW5jZUlucHV0KCk7XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gVGhlIGxvd2VyIHZlcnRleFxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgcHVibGljIFZlY3RvcjIgTG93ZXJCb3VuZDtcclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBUaGUgdXBwZXIgdmVydGV4XHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICBwdWJsaWMgVmVjdG9yMiBVcHBlckJvdW5kO1xyXG5cclxuICAgICAgICBwdWJsaWMgQUFCQihWZWN0b3IyIG1pbiwgVmVjdG9yMiBtYXgpXHJcbiAgICAgICAgICAgIDogdGhpcyhyZWYgbWluLCByZWYgbWF4KVxyXG4gICAgICAgIHtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHB1YmxpYyBBQUJCKHJlZiBWZWN0b3IyIG1pbiwgcmVmIFZlY3RvcjIgbWF4KVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgTG93ZXJCb3VuZCA9IG1pbjtcclxuICAgICAgICAgICAgVXBwZXJCb3VuZCA9IG1heDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHB1YmxpYyBBQUJCKFZlY3RvcjIgY2VudGVyLCBmbG9hdCB3aWR0aCwgZmxvYXQgaGVpZ2h0KVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgTG93ZXJCb3VuZCA9IGNlbnRlciAtIG5ldyBWZWN0b3IyKHdpZHRoIC8gMiwgaGVpZ2h0IC8gMik7XHJcbiAgICAgICAgICAgIFVwcGVyQm91bmQgPSBjZW50ZXIgKyBuZXcgVmVjdG9yMih3aWR0aCAvIDIsIGhlaWdodCAvIDIpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBHZXQgdGhlIGNlbnRlciBvZiB0aGUgQUFCQi5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8dmFsdWU+PC92YWx1ZT5cclxuICAgICAgICBwdWJsaWMgVmVjdG9yMiBDZW50ZXJcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGdldCB7IHJldHVybiAwLjVmICogKExvd2VyQm91bmQgKyBVcHBlckJvdW5kKTsgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBHZXQgdGhlIGV4dGVudHMgb2YgdGhlIEFBQkIgKGhhbGYtd2lkdGhzKS5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8dmFsdWU+PC92YWx1ZT5cclxuICAgICAgICBwdWJsaWMgVmVjdG9yMiBFeHRlbnRzXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBnZXQgeyByZXR1cm4gMC41ZiAqIChVcHBlckJvdW5kIC0gTG93ZXJCb3VuZCk7IH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gR2V0IHRoZSBwZXJpbWV0ZXIgbGVuZ3RoXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHZhbHVlPjwvdmFsdWU+XHJcbiAgICAgICAgcHVibGljIGZsb2F0IFBlcmltZXRlclxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgZ2V0XHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGZsb2F0IHd4ID0gVXBwZXJCb3VuZC5YIC0gTG93ZXJCb3VuZC5YO1xyXG4gICAgICAgICAgICAgICAgZmxvYXQgd3kgPSBVcHBlckJvdW5kLlkgLSBMb3dlckJvdW5kLlk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gMi4wZiAqICh3eCArIHd5KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBHZXRzIHRoZSB2ZXJ0aWNlcyBvZiB0aGUgQUFCQi5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8dmFsdWU+VGhlIGNvcm5lcnMgb2YgdGhlIEFBQkI8L3ZhbHVlPlxyXG4gICAgICAgIHB1YmxpYyBWZXJ0aWNlcyBWZXJ0aWNlc1xyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgZ2V0XHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIFZlcnRpY2VzIHZlcnRpY2VzID0gbmV3IFZlcnRpY2VzKCk7XHJcbiAgICAgICAgICAgICAgICB2ZXJ0aWNlcy5BZGQoTG93ZXJCb3VuZCk7XHJcbiAgICAgICAgICAgICAgICB2ZXJ0aWNlcy5BZGQobmV3IFZlY3RvcjIoTG93ZXJCb3VuZC5YLCBVcHBlckJvdW5kLlkpKTtcclxuICAgICAgICAgICAgICAgIHZlcnRpY2VzLkFkZChVcHBlckJvdW5kKTtcclxuICAgICAgICAgICAgICAgIHZlcnRpY2VzLkFkZChuZXcgVmVjdG9yMihVcHBlckJvdW5kLlgsIExvd2VyQm91bmQuWSkpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHZlcnRpY2VzO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIGZpcnN0IHF1YWRyYW50XHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICBwdWJsaWMgQUFCQiBRMVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgZ2V0IHsgcmV0dXJuIG5ldyBBQUJCKENlbnRlciwgVXBwZXJCb3VuZCk7IH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHB1YmxpYyBBQUJCIFEyXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBnZXRcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBBQUJCKG5ldyBWZWN0b3IyKExvd2VyQm91bmQuWCwgQ2VudGVyLlkpLCBuZXcgVmVjdG9yMihDZW50ZXIuWCwgVXBwZXJCb3VuZC5ZKSk7XHJcbiAgICAgICAgICAgICAgICA7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHB1YmxpYyBBQUJCIFEzXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBnZXQgeyByZXR1cm4gbmV3IEFBQkIoTG93ZXJCb3VuZCwgQ2VudGVyKTsgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHVibGljIEFBQkIgUTRcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGdldCB7IHJldHVybiBuZXcgQUFCQihuZXcgVmVjdG9yMihDZW50ZXIuWCwgTG93ZXJCb3VuZC5ZKSwgbmV3IFZlY3RvcjIoVXBwZXJCb3VuZC5YLCBDZW50ZXIuWSkpOyB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwdWJsaWMgVmVjdG9yMltdIEdldFZlcnRpY2VzKClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIFZlY3RvcjIgcDEgPSBVcHBlckJvdW5kO1xyXG4gICAgICAgICAgICBWZWN0b3IyIHAyID0gbmV3IFZlY3RvcjIoVXBwZXJCb3VuZC5YLCBMb3dlckJvdW5kLlkpO1xyXG4gICAgICAgICAgICBWZWN0b3IyIHAzID0gTG93ZXJCb3VuZDtcclxuICAgICAgICAgICAgVmVjdG9yMiBwNCA9IG5ldyBWZWN0b3IyKExvd2VyQm91bmQuWCwgVXBwZXJCb3VuZC5ZKTtcclxuICAgICAgICAgICAgcmV0dXJuIG5ld1tdIHsgcDEsIHAyLCBwMywgcDQgfTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gVmVyaWZ5IHRoYXQgdGhlIGJvdW5kcyBhcmUgc29ydGVkLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDxyZXR1cm5zPlxyXG4gICAgICAgIC8vLyBcdDxjPnRydWU8L2M+IGlmIHRoaXMgaW5zdGFuY2UgaXMgdmFsaWQ7IG90aGVyd2lzZSwgPGM+ZmFsc2U8L2M+LlxyXG4gICAgICAgIC8vLyA8L3JldHVybnM+XHJcbiAgICAgICAgcHVibGljIGJvb2wgSXNWYWxpZCgpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBWZWN0b3IyIGQgPSBVcHBlckJvdW5kIC0gTG93ZXJCb3VuZDtcclxuICAgICAgICAgICAgYm9vbCB2YWxpZCA9IGQuWCA+PSAwLjBmICYmIGQuWSA+PSAwLjBmO1xyXG4gICAgICAgICAgICB2YWxpZCA9IHZhbGlkICYmIExvd2VyQm91bmQuSXNWYWxpZCgpICYmIFVwcGVyQm91bmQuSXNWYWxpZCgpO1xyXG4gICAgICAgICAgICByZXR1cm4gdmFsaWQ7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIENvbWJpbmUgYW4gQUFCQiBpbnRvIHRoaXMgb25lLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwiYWFiYlwiPlRoZSBhYWJiLjwvcGFyYW0+XHJcbiAgICAgICAgcHVibGljIHZvaWQgQ29tYmluZShyZWYgQUFCQiBhYWJiKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgTG93ZXJCb3VuZCA9IFZlY3RvcjIuTWluKExvd2VyQm91bmQsIGFhYmIuTG93ZXJCb3VuZCk7XHJcbiAgICAgICAgICAgIFVwcGVyQm91bmQgPSBWZWN0b3IyLk1heChVcHBlckJvdW5kLCBhYWJiLlVwcGVyQm91bmQpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBDb21iaW5lIHR3byBBQUJCcyBpbnRvIHRoaXMgb25lLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwiYWFiYjFcIj5UaGUgYWFiYjEuPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJhYWJiMlwiPlRoZSBhYWJiMi48L3BhcmFtPlxyXG4gICAgICAgIHB1YmxpYyB2b2lkIENvbWJpbmUocmVmIEFBQkIgYWFiYjEsIHJlZiBBQUJCIGFhYmIyKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgTG93ZXJCb3VuZCA9IFZlY3RvcjIuTWluKGFhYmIxLkxvd2VyQm91bmQsIGFhYmIyLkxvd2VyQm91bmQpO1xyXG4gICAgICAgICAgICBVcHBlckJvdW5kID0gVmVjdG9yMi5NYXgoYWFiYjEuVXBwZXJCb3VuZCwgYWFiYjIuVXBwZXJCb3VuZCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIERvZXMgdGhpcyBhYWJiIGNvbnRhaW4gdGhlIHByb3ZpZGVkIEFBQkIuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJhYWJiXCI+VGhlIGFhYmIuPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHJldHVybnM+XHJcbiAgICAgICAgLy8vIFx0PGM+dHJ1ZTwvYz4gaWYgaXQgY29udGFpbnMgdGhlIHNwZWNpZmllZCBhYWJiOyBvdGhlcndpc2UsIDxjPmZhbHNlPC9jPi5cclxuICAgICAgICAvLy8gPC9yZXR1cm5zPlxyXG4gICAgICAgIHB1YmxpYyBib29sIENvbnRhaW5zKHJlZiBBQUJCIGFhYmIpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBib29sIHJlc3VsdCA9IHRydWU7XHJcbiAgICAgICAgICAgIHJlc3VsdCA9IHJlc3VsdCAmJiBMb3dlckJvdW5kLlggPD0gYWFiYi5Mb3dlckJvdW5kLlg7XHJcbiAgICAgICAgICAgIHJlc3VsdCA9IHJlc3VsdCAmJiBMb3dlckJvdW5kLlkgPD0gYWFiYi5Mb3dlckJvdW5kLlk7XHJcbiAgICAgICAgICAgIHJlc3VsdCA9IHJlc3VsdCAmJiBhYWJiLlVwcGVyQm91bmQuWCA8PSBVcHBlckJvdW5kLlg7XHJcbiAgICAgICAgICAgIHJlc3VsdCA9IHJlc3VsdCAmJiBhYWJiLlVwcGVyQm91bmQuWSA8PSBVcHBlckJvdW5kLlk7XHJcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIERldGVybWluZXMgd2hldGhlciB0aGUgQUFBQkIgY29udGFpbnMgdGhlIHNwZWNpZmllZCBwb2ludC5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cInBvaW50XCI+VGhlIHBvaW50LjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxyZXR1cm5zPlxyXG4gICAgICAgIC8vLyBcdDxjPnRydWU8L2M+IGlmIGl0IGNvbnRhaW5zIHRoZSBzcGVjaWZpZWQgcG9pbnQ7IG90aGVyd2lzZSwgPGM+ZmFsc2U8L2M+LlxyXG4gICAgICAgIC8vLyA8L3JldHVybnM+XHJcbiAgICAgICAgcHVibGljIGJvb2wgQ29udGFpbnMocmVmIFZlY3RvcjIgcG9pbnQpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICAvL3VzaW5nIGVwc2lsb24gdG8gdHJ5IGFuZCBnYXVyZCBhZ2FpbnN0IGZsb2F0IHJvdW5kaW5nIGVycm9ycy5cclxuICAgICAgICAgICAgaWYgKChwb2ludC5YID4gKExvd2VyQm91bmQuWCArIFNldHRpbmdzLkVwc2lsb24pICYmIHBvaW50LlggPCAoVXBwZXJCb3VuZC5YIC0gU2V0dGluZ3MuRXBzaWxvbikgJiZcclxuICAgICAgICAgICAgICAgICAocG9pbnQuWSA+IChMb3dlckJvdW5kLlkgKyBTZXR0aW5ncy5FcHNpbG9uKSAmJiBwb2ludC5ZIDwgKFVwcGVyQm91bmQuWSAtIFNldHRpbmdzLkVwc2lsb24pKSkpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHB1YmxpYyBzdGF0aWMgYm9vbCBUZXN0T3ZlcmxhcChBQUJCIGEsIEFBQkIgYilcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiBUZXN0T3ZlcmxhcChyZWYgYSwgcmVmIGIpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHVibGljIHN0YXRpYyBib29sIFRlc3RPdmVybGFwKHJlZiBBQUJCIGEsIHJlZiBBQUJCIGIpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBWZWN0b3IyIGQxID0gYi5Mb3dlckJvdW5kIC0gYS5VcHBlckJvdW5kO1xyXG4gICAgICAgICAgICBWZWN0b3IyIGQyID0gYS5Mb3dlckJvdW5kIC0gYi5VcHBlckJvdW5kO1xyXG5cclxuICAgICAgICAgICAgaWYgKGQxLlggPiAwLjBmIHx8IGQxLlkgPiAwLjBmKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG5cclxuICAgICAgICAgICAgaWYgKGQyLlggPiAwLjBmIHx8IGQyLlkgPiAwLjBmKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwdWJsaWMgc3RhdGljIGJvb2wgVGVzdE92ZXJsYXAoU2hhcGUgc2hhcGVBLCBpbnQgaW5kZXhBLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBTaGFwZSBzaGFwZUIsIGludCBpbmRleEIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlZiBUcmFuc2Zvcm0geGZBLCByZWYgVHJhbnNmb3JtIHhmQilcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIF9pbnB1dC5Qcm94eUEuU2V0KHNoYXBlQSwgaW5kZXhBKTtcclxuICAgICAgICAgICAgX2lucHV0LlByb3h5Qi5TZXQoc2hhcGVCLCBpbmRleEIpO1xyXG4gICAgICAgICAgICBfaW5wdXQuVHJhbnNmb3JtQSA9IHhmQTtcclxuICAgICAgICAgICAgX2lucHV0LlRyYW5zZm9ybUIgPSB4ZkI7XHJcbiAgICAgICAgICAgIF9pbnB1dC5Vc2VSYWRpaSA9IHRydWU7XHJcblxyXG4gICAgICAgICAgICBTaW1wbGV4Q2FjaGUgY2FjaGU7XHJcbiAgICAgICAgICAgIERpc3RhbmNlT3V0cHV0IG91dHB1dDtcclxuICAgICAgICAgICAgRGlzdGFuY2UuQ29tcHV0ZURpc3RhbmNlKG91dCBvdXRwdXQsIG91dCBjYWNoZSwgX2lucHV0KTtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiBvdXRwdXQuRGlzdGFuY2UgPCAxMC4wZiAqIFNldHRpbmdzLkVwc2lsb247XHJcbiAgICAgICAgfVxyXG5cclxuXHJcbiAgICAgICAgLy8gRnJvbSBSZWFsLXRpbWUgQ29sbGlzaW9uIERldGVjdGlvbiwgcDE3OS5cclxuICAgICAgICBwdWJsaWMgYm9vbCBSYXlDYXN0KG91dCBSYXlDYXN0T3V0cHV0IG91dHB1dCwgcmVmIFJheUNhc3RJbnB1dCBpbnB1dClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIG91dHB1dCA9IG5ldyBSYXlDYXN0T3V0cHV0KCk7XHJcblxyXG4gICAgICAgICAgICBmbG9hdCB0bWluID0gLVNldHRpbmdzLk1heEZsb2F0O1xyXG4gICAgICAgICAgICBmbG9hdCB0bWF4ID0gU2V0dGluZ3MuTWF4RmxvYXQ7XHJcblxyXG4gICAgICAgICAgICBWZWN0b3IyIHAgPSBpbnB1dC5Qb2ludDE7XHJcbiAgICAgICAgICAgIFZlY3RvcjIgZCA9IGlucHV0LlBvaW50MiAtIGlucHV0LlBvaW50MTtcclxuICAgICAgICAgICAgVmVjdG9yMiBhYnNEID0gTWF0aFV0aWxzLkFicyhkKTtcclxuXHJcbiAgICAgICAgICAgIFZlY3RvcjIgbm9ybWFsID0gVmVjdG9yMi5aZXJvO1xyXG5cclxuICAgICAgICAgICAgZm9yIChpbnQgaSA9IDA7IGkgPCAyOyArK2kpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGZsb2F0IGFic0RfaSA9IGkgPT0gMCA/IGFic0QuWCA6IGFic0QuWTtcclxuICAgICAgICAgICAgICAgIGZsb2F0IGxvd2VyQm91bmRfaSA9IGkgPT0gMCA/IExvd2VyQm91bmQuWCA6IExvd2VyQm91bmQuWTtcclxuICAgICAgICAgICAgICAgIGZsb2F0IHVwcGVyQm91bmRfaSA9IGkgPT0gMCA/IFVwcGVyQm91bmQuWCA6IFVwcGVyQm91bmQuWTtcclxuICAgICAgICAgICAgICAgIGZsb2F0IHBfaSA9IGkgPT0gMCA/IHAuWCA6IHAuWTtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoYWJzRF9pIDwgU2V0dGluZ3MuRXBzaWxvbilcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBQYXJhbGxlbC5cclxuICAgICAgICAgICAgICAgICAgICBpZiAocF9pIDwgbG93ZXJCb3VuZF9pIHx8IHVwcGVyQm91bmRfaSA8IHBfaSlcclxuICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgZmxvYXQgZF9pID0gaSA9PSAwID8gZC5YIDogZC5ZO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBmbG9hdCBpbnZfZCA9IDEuMGYgLyBkX2k7XHJcbiAgICAgICAgICAgICAgICAgICAgZmxvYXQgdDEgPSAobG93ZXJCb3VuZF9pIC0gcF9pKSAqIGludl9kO1xyXG4gICAgICAgICAgICAgICAgICAgIGZsb2F0IHQyID0gKHVwcGVyQm91bmRfaSAtIHBfaSkgKiBpbnZfZDtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gU2lnbiBvZiB0aGUgbm9ybWFsIHZlY3Rvci5cclxuICAgICAgICAgICAgICAgICAgICBmbG9hdCBzID0gLTEuMGY7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0MSA+IHQyKVxyXG4gICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgTWF0aFV0aWxzLlN3YXA8ZmxvYXQ+KHJlZiB0MSwgcmVmIHQyKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcyA9IDEuMGY7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBQdXNoIHRoZSBtaW4gdXBcclxuICAgICAgICAgICAgICAgICAgICBpZiAodDEgPiB0bWluKVxyXG4gICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGkgPT0gMClcclxuICAgICAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9ybWFsLlggPSBzO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9ybWFsLlkgPSBzO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0bWluID0gdDE7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBQdWxsIHRoZSBtYXggZG93blxyXG4gICAgICAgICAgICAgICAgICAgIHRtYXggPSBNYXRoLk1pbih0bWF4LCB0Mik7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0bWluID4gdG1heClcclxuICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIERvZXMgdGhlIHJheSBzdGFydCBpbnNpZGUgdGhlIGJveD9cclxuICAgICAgICAgICAgLy8gRG9lcyB0aGUgcmF5IGludGVyc2VjdCBiZXlvbmQgdGhlIG1heCBmcmFjdGlvbj9cclxuICAgICAgICAgICAgaWYgKHRtaW4gPCAwLjBmIHx8IGlucHV0Lk1heEZyYWN0aW9uIDwgdG1pbilcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBJbnRlcnNlY3Rpb24uXHJcbiAgICAgICAgICAgIG91dHB1dC5GcmFjdGlvbiA9IHRtaW47XHJcbiAgICAgICAgICAgIG91dHB1dC5Ob3JtYWwgPSBub3JtYWw7XHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAvLy8gRWRnZSBzaGFwZSBwbHVzIG1vcmUgc3R1ZmYuXHJcbiAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgcHVibGljIHN0cnVjdCBGYXRFZGdlXHJcbiAgICB7XHJcbiAgICAgICAgcHVibGljIGJvb2wgSGFzVmVydGV4MCwgSGFzVmVydGV4MztcclxuICAgICAgICBwdWJsaWMgVmVjdG9yMiBOb3JtYWw7XHJcbiAgICAgICAgcHVibGljIFZlY3RvcjIgVjAsIFYxLCBWMiwgVjM7XHJcbiAgICB9XHJcblxyXG4gICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgLy8vIFRoaXMgbGV0cyB1cyB0cmVhdGUgYW5kIGVkZ2Ugc2hhcGUgYW5kIGEgcG9seWdvbiBpbiB0aGUgc2FtZVxyXG4gICAgLy8vIHdheSBpbiB0aGUgU0FUIGNvbGxpZGVyLlxyXG4gICAgLy8vIDwvc3VtbWFyeT5cclxuICAgIHB1YmxpYyBjbGFzcyBFUFByb3h5XHJcbiAgICB7XHJcbiAgICAgICAgcHVibGljIFZlY3RvcjIgQ2VudHJvaWQ7XHJcbiAgICAgICAgcHVibGljIGludCBDb3VudDtcclxuICAgICAgICBwdWJsaWMgVmVjdG9yMltdIE5vcm1hbHMgPSBuZXcgVmVjdG9yMltTZXR0aW5ncy5NYXhQb2x5Z29uVmVydGljZXNdO1xyXG4gICAgICAgIHB1YmxpYyBWZWN0b3IyW10gVmVydGljZXMgPSBuZXcgVmVjdG9yMltTZXR0aW5ncy5NYXhQb2x5Z29uVmVydGljZXNdO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBzdHJ1Y3QgRVBBeGlzXHJcbiAgICB7XHJcbiAgICAgICAgcHVibGljIGludCBJbmRleDtcclxuICAgICAgICBwdWJsaWMgZmxvYXQgU2VwYXJhdGlvbjtcclxuICAgICAgICBwdWJsaWMgRVBBeGlzVHlwZSBUeXBlO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBlbnVtIEVQQXhpc1R5cGVcclxuICAgIHtcclxuICAgICAgICBVbmtub3duLFxyXG4gICAgICAgIEVkZ2VBLFxyXG4gICAgICAgIEVkZ2VCLFxyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBzdGF0aWMgY2xhc3MgQ29sbGlzaW9uXHJcbiAgICB7XHJcbiAgICAgICAgcHJpdmF0ZSBzdGF0aWMgRmF0RWRnZSBfZWRnZUE7XHJcblxyXG4gICAgICAgIHByaXZhdGUgc3RhdGljIEVQUHJveHkgX3Byb3h5QSA9IG5ldyBFUFByb3h5KCk7XHJcbiAgICAgICAgcHJpdmF0ZSBzdGF0aWMgRVBQcm94eSBfcHJveHlCID0gbmV3IEVQUHJveHkoKTtcclxuXHJcbiAgICAgICAgcHJpdmF0ZSBzdGF0aWMgVHJhbnNmb3JtIF94ZjtcclxuICAgICAgICBwcml2YXRlIHN0YXRpYyBWZWN0b3IyIF9saW1pdDExLCBfbGltaXQxMjtcclxuICAgICAgICBwcml2YXRlIHN0YXRpYyBWZWN0b3IyIF9saW1pdDIxLCBfbGltaXQyMjtcclxuICAgICAgICBwcml2YXRlIHN0YXRpYyBmbG9hdCBfcmFkaXVzO1xyXG4gICAgICAgIHByaXZhdGUgc3RhdGljIFZlY3RvcjJbXSBfdG1wTm9ybWFscyA9IG5ldyBWZWN0b3IyWzJdO1xyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIEV2YWx1YXRlIHRoZSBtYW5pZm9sZCB3aXRoIHN1cHBsaWVkIHRyYW5zZm9ybXMuIFRoaXMgYXNzdW1lc1xyXG4gICAgICAgIC8vLyBtb2Rlc3QgbW90aW9uIGZyb20gdGhlIG9yaWdpbmFsIHN0YXRlLiBUaGlzIGRvZXMgbm90IGNoYW5nZSB0aGVcclxuICAgICAgICAvLy8gcG9pbnQgY291bnQsIGltcHVsc2VzLCBldGMuIFRoZSByYWRpaSBtdXN0IGNvbWUgZnJvbSB0aGUgU2hhcGVzXHJcbiAgICAgICAgLy8vIHRoYXQgZ2VuZXJhdGVkIHRoZSBtYW5pZm9sZC5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cIm1hbmlmb2xkXCI+VGhlIG1hbmlmb2xkLjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwidHJhbnNmb3JtQVwiPlRoZSB0cmFuc2Zvcm0gZm9yIEEuPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJyYWRpdXNBXCI+VGhlIHJhZGl1cyBmb3IgQS48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cInRyYW5zZm9ybUJcIj5UaGUgdHJhbnNmb3JtIGZvciBCLjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwicmFkaXVzQlwiPlRoZSByYWRpdXMgZm9yIEIuPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJub3JtYWxcIj5Xb3JsZCB2ZWN0b3IgcG9pbnRpbmcgZnJvbSBBIHRvIEI8L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cInBvaW50c1wiPlRvcmxkIGNvbnRhY3QgcG9pbnQgKHBvaW50IG9mIGludGVyc2VjdGlvbikuPC9wYXJhbT5cclxuICAgICAgICBwdWJsaWMgc3RhdGljIHZvaWQgR2V0V29ybGRNYW5pZm9sZChyZWYgTWFuaWZvbGQgbWFuaWZvbGQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVmIFRyYW5zZm9ybSB0cmFuc2Zvcm1BLCBmbG9hdCByYWRpdXNBLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlZiBUcmFuc2Zvcm0gdHJhbnNmb3JtQiwgZmxvYXQgcmFkaXVzQiwgb3V0IFZlY3RvcjIgbm9ybWFsLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG91dCBGaXhlZEFycmF5MjxWZWN0b3IyPiBwb2ludHMpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBwb2ludHMgPSBuZXcgRml4ZWRBcnJheTI8VmVjdG9yMj4oKTtcclxuICAgICAgICAgICAgbm9ybWFsID0gVmVjdG9yMi5aZXJvO1xyXG5cclxuICAgICAgICAgICAgaWYgKG1hbmlmb2xkLlBvaW50Q291bnQgPT0gMClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgbm9ybWFsID0gVmVjdG9yMi5Vbml0WTtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgc3dpdGNoIChtYW5pZm9sZC5UeXBlKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBjYXNlIE1hbmlmb2xkVHlwZS5DaXJjbGVzOlxyXG4gICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgVmVjdG9yMiB0bXAgPSBtYW5pZm9sZC5Qb2ludHNbMF0uTG9jYWxQb2ludDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZmxvYXQgcG9pbnRBeCA9IHRyYW5zZm9ybUEuUG9zaXRpb24uWCArIHRyYW5zZm9ybUEuUi5Db2wxLlggKiBtYW5pZm9sZC5Mb2NhbFBvaW50LlggK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJhbnNmb3JtQS5SLkNvbDIuWCAqIG1hbmlmb2xkLkxvY2FsUG9pbnQuWTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZsb2F0IHBvaW50QXkgPSB0cmFuc2Zvcm1BLlBvc2l0aW9uLlkgKyB0cmFuc2Zvcm1BLlIuQ29sMS5ZICogbWFuaWZvbGQuTG9jYWxQb2ludC5YICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zZm9ybUEuUi5Db2wyLlkgKiBtYW5pZm9sZC5Mb2NhbFBvaW50Llk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBmbG9hdCBwb2ludEJ4ID0gdHJhbnNmb3JtQi5Qb3NpdGlvbi5YICsgdHJhbnNmb3JtQi5SLkNvbDEuWCAqIHRtcC5YICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zZm9ybUIuUi5Db2wyLlggKiB0bXAuWTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZsb2F0IHBvaW50QnkgPSB0cmFuc2Zvcm1CLlBvc2l0aW9uLlkgKyB0cmFuc2Zvcm1CLlIuQ29sMS5ZICogdG1wLlggK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJhbnNmb3JtQi5SLkNvbDIuWSAqIHRtcC5ZO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgbm9ybWFsLlggPSAxO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBub3JtYWwuWSA9IDA7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBmbG9hdCByZXN1bHQgPSAocG9pbnRBeCAtIHBvaW50QngpICogKHBvaW50QXggLSBwb2ludEJ4KSArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChwb2ludEF5IC0gcG9pbnRCeSkgKiAocG9pbnRBeSAtIHBvaW50QnkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVzdWx0ID4gU2V0dGluZ3MuRXBzaWxvbiAqIFNldHRpbmdzLkVwc2lsb24pXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZsb2F0IHRtcE5vcm1hbHggPSBwb2ludEJ4IC0gcG9pbnRBeDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZsb2F0IHRtcE5vcm1hbHkgPSBwb2ludEJ5IC0gcG9pbnRBeTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZsb2F0IGZhY3RvciA9IDFmIC8gKGZsb2F0KU1hdGguU3FydCh0bXBOb3JtYWx4ICogdG1wTm9ybWFseCArIHRtcE5vcm1hbHkgKiB0bXBOb3JtYWx5KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vcm1hbC5YID0gdG1wTm9ybWFseCAqIGZhY3RvcjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vcm1hbC5ZID0gdG1wTm9ybWFseSAqIGZhY3RvcjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgVmVjdG9yMiBjID0gVmVjdG9yMi5aZXJvO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjLlggPSAocG9pbnRBeCArIHJhZGl1c0EgKiBub3JtYWwuWCkgKyAocG9pbnRCeCAtIHJhZGl1c0IgKiBub3JtYWwuWCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGMuWSA9IChwb2ludEF5ICsgcmFkaXVzQSAqIG5vcm1hbC5ZKSArIChwb2ludEJ5IC0gcmFkaXVzQiAqIG5vcm1hbC5ZKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvaW50c1swXSA9IDAuNWYgKiBjO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgICAgICAgICBjYXNlIE1hbmlmb2xkVHlwZS5GYWNlQTpcclxuICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vcm1hbC5YID0gdHJhbnNmb3JtQS5SLkNvbDEuWCAqIG1hbmlmb2xkLkxvY2FsTm9ybWFsLlggK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zZm9ybUEuUi5Db2wyLlggKiBtYW5pZm9sZC5Mb2NhbE5vcm1hbC5ZO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBub3JtYWwuWSA9IHRyYW5zZm9ybUEuUi5Db2wxLlkgKiBtYW5pZm9sZC5Mb2NhbE5vcm1hbC5YICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cmFuc2Zvcm1BLlIuQ29sMi5ZICogbWFuaWZvbGQuTG9jYWxOb3JtYWwuWTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZsb2F0IHBsYW5lUG9pbnR4ID0gdHJhbnNmb3JtQS5Qb3NpdGlvbi5YICsgdHJhbnNmb3JtQS5SLkNvbDEuWCAqIG1hbmlmb2xkLkxvY2FsUG9pbnQuWCArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJhbnNmb3JtQS5SLkNvbDIuWCAqIG1hbmlmb2xkLkxvY2FsUG9pbnQuWTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZsb2F0IHBsYW5lUG9pbnR5ID0gdHJhbnNmb3JtQS5Qb3NpdGlvbi5ZICsgdHJhbnNmb3JtQS5SLkNvbDEuWSAqIG1hbmlmb2xkLkxvY2FsUG9pbnQuWCArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJhbnNmb3JtQS5SLkNvbDIuWSAqIG1hbmlmb2xkLkxvY2FsUG9pbnQuWTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoaW50IGkgPSAwOyBpIDwgbWFuaWZvbGQuUG9pbnRDb3VudDsgKytpKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBWZWN0b3IyIHRtcCA9IG1hbmlmb2xkLlBvaW50c1tpXS5Mb2NhbFBvaW50O1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZsb2F0IGNsaXBQb2ludHggPSB0cmFuc2Zvcm1CLlBvc2l0aW9uLlggKyB0cmFuc2Zvcm1CLlIuQ29sMS5YICogdG1wLlggK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zZm9ybUIuUi5Db2wyLlggKiB0bXAuWTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmbG9hdCBjbGlwUG9pbnR5ID0gdHJhbnNmb3JtQi5Qb3NpdGlvbi5ZICsgdHJhbnNmb3JtQi5SLkNvbDEuWSAqIHRtcC5YICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cmFuc2Zvcm1CLlIuQ29sMi5ZICogdG1wLlk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmxvYXQgdmFsdWUgPSAoY2xpcFBvaW50eCAtIHBsYW5lUG9pbnR4KSAqIG5vcm1hbC5YICsgKGNsaXBQb2ludHkgLSBwbGFuZVBvaW50eSkgKiBub3JtYWwuWTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBWZWN0b3IyIGMgPSBWZWN0b3IyLlplcm87XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjLlggPSAoY2xpcFBvaW50eCArIChyYWRpdXNBIC0gdmFsdWUpICogbm9ybWFsLlgpICsgKGNsaXBQb2ludHggLSByYWRpdXNCICogbm9ybWFsLlgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYy5ZID0gKGNsaXBQb2ludHkgKyAocmFkaXVzQSAtIHZhbHVlKSAqIG5vcm1hbC5ZKSArIChjbGlwUG9pbnR5IC0gcmFkaXVzQiAqIG5vcm1hbC5ZKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb2ludHNbaV0gPSAwLjVmICogYztcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgICAgICAgICBjYXNlIE1hbmlmb2xkVHlwZS5GYWNlQjpcclxuICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vcm1hbC5YID0gdHJhbnNmb3JtQi5SLkNvbDEuWCAqIG1hbmlmb2xkLkxvY2FsTm9ybWFsLlggK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zZm9ybUIuUi5Db2wyLlggKiBtYW5pZm9sZC5Mb2NhbE5vcm1hbC5ZO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBub3JtYWwuWSA9IHRyYW5zZm9ybUIuUi5Db2wxLlkgKiBtYW5pZm9sZC5Mb2NhbE5vcm1hbC5YICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cmFuc2Zvcm1CLlIuQ29sMi5ZICogbWFuaWZvbGQuTG9jYWxOb3JtYWwuWTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZsb2F0IHBsYW5lUG9pbnR4ID0gdHJhbnNmb3JtQi5Qb3NpdGlvbi5YICsgdHJhbnNmb3JtQi5SLkNvbDEuWCAqIG1hbmlmb2xkLkxvY2FsUG9pbnQuWCArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJhbnNmb3JtQi5SLkNvbDIuWCAqIG1hbmlmb2xkLkxvY2FsUG9pbnQuWTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZsb2F0IHBsYW5lUG9pbnR5ID0gdHJhbnNmb3JtQi5Qb3NpdGlvbi5ZICsgdHJhbnNmb3JtQi5SLkNvbDEuWSAqIG1hbmlmb2xkLkxvY2FsUG9pbnQuWCArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJhbnNmb3JtQi5SLkNvbDIuWSAqIG1hbmlmb2xkLkxvY2FsUG9pbnQuWTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoaW50IGkgPSAwOyBpIDwgbWFuaWZvbGQuUG9pbnRDb3VudDsgKytpKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBWZWN0b3IyIHRtcCA9IG1hbmlmb2xkLlBvaW50c1tpXS5Mb2NhbFBvaW50O1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZsb2F0IGNsaXBQb2ludHggPSB0cmFuc2Zvcm1BLlBvc2l0aW9uLlggKyB0cmFuc2Zvcm1BLlIuQ29sMS5YICogdG1wLlggK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zZm9ybUEuUi5Db2wyLlggKiB0bXAuWTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmbG9hdCBjbGlwUG9pbnR5ID0gdHJhbnNmb3JtQS5Qb3NpdGlvbi5ZICsgdHJhbnNmb3JtQS5SLkNvbDEuWSAqIHRtcC5YICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cmFuc2Zvcm1BLlIuQ29sMi5ZICogdG1wLlk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmxvYXQgdmFsdWUgPSAoY2xpcFBvaW50eCAtIHBsYW5lUG9pbnR4KSAqIG5vcm1hbC5YICsgKGNsaXBQb2ludHkgLSBwbGFuZVBvaW50eSkgKiBub3JtYWwuWTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBWZWN0b3IyIGMgPSBWZWN0b3IyLlplcm87XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjLlggPSAoY2xpcFBvaW50eCAtIHJhZGl1c0EgKiBub3JtYWwuWCkgKyAoY2xpcFBvaW50eCArIChyYWRpdXNCIC0gdmFsdWUpICogbm9ybWFsLlgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYy5ZID0gKGNsaXBQb2ludHkgLSByYWRpdXNBICogbm9ybWFsLlkpICsgKGNsaXBQb2ludHkgKyAocmFkaXVzQiAtIHZhbHVlKSAqIG5vcm1hbC5ZKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb2ludHNbaV0gPSAwLjVmICogYztcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBFbnN1cmUgbm9ybWFsIHBvaW50cyBmcm9tIEEgdG8gQi5cclxuICAgICAgICAgICAgICAgICAgICAgICAgbm9ybWFsICo9IC0xO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICAgICAgbm9ybWFsID0gVmVjdG9yMi5Vbml0WTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHVibGljIHN0YXRpYyB2b2lkIEdldFBvaW50U3RhdGVzKG91dCBGaXhlZEFycmF5MjxQb2ludFN0YXRlPiBzdGF0ZTEsIG91dCBGaXhlZEFycmF5MjxQb2ludFN0YXRlPiBzdGF0ZTIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlZiBNYW5pZm9sZCBtYW5pZm9sZDEsIHJlZiBNYW5pZm9sZCBtYW5pZm9sZDIpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBzdGF0ZTEgPSBuZXcgRml4ZWRBcnJheTI8UG9pbnRTdGF0ZT4oKTtcclxuICAgICAgICAgICAgc3RhdGUyID0gbmV3IEZpeGVkQXJyYXkyPFBvaW50U3RhdGU+KCk7XHJcblxyXG4gICAgICAgICAgICAvLyBEZXRlY3QgcGVyc2lzdHMgYW5kIHJlbW92ZXMuXHJcbiAgICAgICAgICAgIGZvciAoaW50IGkgPSAwOyBpIDwgbWFuaWZvbGQxLlBvaW50Q291bnQ7ICsraSlcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgQ29udGFjdElEIGlkID0gbWFuaWZvbGQxLlBvaW50c1tpXS5JZDtcclxuXHJcbiAgICAgICAgICAgICAgICBzdGF0ZTFbaV0gPSBQb2ludFN0YXRlLlJlbW92ZTtcclxuXHJcbiAgICAgICAgICAgICAgICBmb3IgKGludCBqID0gMDsgaiA8IG1hbmlmb2xkMi5Qb2ludENvdW50OyArK2opXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1hbmlmb2xkMi5Qb2ludHNbal0uSWQuS2V5ID09IGlkLktleSlcclxuICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlMVtpXSA9IFBvaW50U3RhdGUuUGVyc2lzdDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBEZXRlY3QgcGVyc2lzdHMgYW5kIGFkZHMuXHJcbiAgICAgICAgICAgIGZvciAoaW50IGkgPSAwOyBpIDwgbWFuaWZvbGQyLlBvaW50Q291bnQ7ICsraSlcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgQ29udGFjdElEIGlkID0gbWFuaWZvbGQyLlBvaW50c1tpXS5JZDtcclxuXHJcbiAgICAgICAgICAgICAgICBzdGF0ZTJbaV0gPSBQb2ludFN0YXRlLkFkZDtcclxuXHJcbiAgICAgICAgICAgICAgICBmb3IgKGludCBqID0gMDsgaiA8IG1hbmlmb2xkMS5Qb2ludENvdW50OyArK2opXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1hbmlmb2xkMS5Qb2ludHNbal0uSWQuS2V5ID09IGlkLktleSlcclxuICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlMltpXSA9IFBvaW50U3RhdGUuUGVyc2lzdDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuXHJcbiAgICAgICAgLy8vIENvbXB1dGUgdGhlIGNvbGxpc2lvbiBtYW5pZm9sZCBiZXR3ZWVuIHR3byBjaXJjbGVzLlxyXG4gICAgICAgIHB1YmxpYyBzdGF0aWMgdm9pZCBDb2xsaWRlQ2lyY2xlcyhyZWYgTWFuaWZvbGQgbWFuaWZvbGQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIENpcmNsZVNoYXBlIGNpcmNsZUEsIHJlZiBUcmFuc2Zvcm0geGZBLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBDaXJjbGVTaGFwZSBjaXJjbGVCLCByZWYgVHJhbnNmb3JtIHhmQilcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIG1hbmlmb2xkLlBvaW50Q291bnQgPSAwO1xyXG5cclxuICAgICAgICAgICAgZmxvYXQgcEF4ID0geGZBLlBvc2l0aW9uLlggKyB4ZkEuUi5Db2wxLlggKiBjaXJjbGVBLlBvc2l0aW9uLlggKyB4ZkEuUi5Db2wyLlggKiBjaXJjbGVBLlBvc2l0aW9uLlk7XHJcbiAgICAgICAgICAgIGZsb2F0IHBBeSA9IHhmQS5Qb3NpdGlvbi5ZICsgeGZBLlIuQ29sMS5ZICogY2lyY2xlQS5Qb3NpdGlvbi5YICsgeGZBLlIuQ29sMi5ZICogY2lyY2xlQS5Qb3NpdGlvbi5ZO1xyXG4gICAgICAgICAgICBmbG9hdCBwQnggPSB4ZkIuUG9zaXRpb24uWCArIHhmQi5SLkNvbDEuWCAqIGNpcmNsZUIuUG9zaXRpb24uWCArIHhmQi5SLkNvbDIuWCAqIGNpcmNsZUIuUG9zaXRpb24uWTtcclxuICAgICAgICAgICAgZmxvYXQgcEJ5ID0geGZCLlBvc2l0aW9uLlkgKyB4ZkIuUi5Db2wxLlkgKiBjaXJjbGVCLlBvc2l0aW9uLlggKyB4ZkIuUi5Db2wyLlkgKiBjaXJjbGVCLlBvc2l0aW9uLlk7XHJcblxyXG4gICAgICAgICAgICBmbG9hdCBkaXN0U3FyID0gKHBCeCAtIHBBeCkgKiAocEJ4IC0gcEF4KSArIChwQnkgLSBwQXkpICogKHBCeSAtIHBBeSk7XHJcbiAgICAgICAgICAgIGZsb2F0IHJhZGl1cyA9IGNpcmNsZUEuUmFkaXVzICsgY2lyY2xlQi5SYWRpdXM7XHJcbiAgICAgICAgICAgIGlmIChkaXN0U3FyID4gcmFkaXVzICogcmFkaXVzKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIG1hbmlmb2xkLlR5cGUgPSBNYW5pZm9sZFR5cGUuQ2lyY2xlcztcclxuICAgICAgICAgICAgbWFuaWZvbGQuTG9jYWxQb2ludCA9IGNpcmNsZUEuUG9zaXRpb247XHJcbiAgICAgICAgICAgIG1hbmlmb2xkLkxvY2FsTm9ybWFsID0gVmVjdG9yMi5aZXJvO1xyXG4gICAgICAgICAgICBtYW5pZm9sZC5Qb2ludENvdW50ID0gMTtcclxuXHJcbiAgICAgICAgICAgIE1hbmlmb2xkUG9pbnQgcDAgPSBtYW5pZm9sZC5Qb2ludHNbMF07XHJcblxyXG4gICAgICAgICAgICBwMC5Mb2NhbFBvaW50ID0gY2lyY2xlQi5Qb3NpdGlvbjtcclxuICAgICAgICAgICAgcDAuSWQuS2V5ID0gMDtcclxuXHJcbiAgICAgICAgICAgIG1hbmlmb2xkLlBvaW50c1swXSA9IHAwO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBDb21wdXRlIHRoZSBjb2xsaXNpb24gbWFuaWZvbGQgYmV0d2VlbiBhIHBvbHlnb24gYW5kIGEgY2lyY2xlLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwibWFuaWZvbGRcIj5UaGUgbWFuaWZvbGQuPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJwb2x5Z29uQVwiPlRoZSBwb2x5Z29uIEEuPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJ0cmFuc2Zvcm1BXCI+VGhlIHRyYW5zZm9ybSBvZiBBLjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwiY2lyY2xlQlwiPlRoZSBjaXJjbGUgQi48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cInRyYW5zZm9ybUJcIj5UaGUgdHJhbnNmb3JtIG9mIEIuPC9wYXJhbT5cclxuICAgICAgICBwdWJsaWMgc3RhdGljIHZvaWQgQ29sbGlkZVBvbHlnb25BbmRDaXJjbGUocmVmIE1hbmlmb2xkIG1hbmlmb2xkLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBQb2x5Z29uU2hhcGUgcG9seWdvbkEsIHJlZiBUcmFuc2Zvcm0gdHJhbnNmb3JtQSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgQ2lyY2xlU2hhcGUgY2lyY2xlQiwgcmVmIFRyYW5zZm9ybSB0cmFuc2Zvcm1CKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgbWFuaWZvbGQuUG9pbnRDb3VudCA9IDA7XHJcblxyXG4gICAgICAgICAgICAvLyBDb21wdXRlIGNpcmNsZSBwb3NpdGlvbiBpbiB0aGUgZnJhbWUgb2YgdGhlIHBvbHlnb24uXHJcbiAgICAgICAgICAgIFZlY3RvcjIgYyA9XHJcbiAgICAgICAgICAgICAgICBuZXcgVmVjdG9yMihcclxuICAgICAgICAgICAgICAgICAgICB0cmFuc2Zvcm1CLlBvc2l0aW9uLlggKyB0cmFuc2Zvcm1CLlIuQ29sMS5YICogY2lyY2xlQi5Qb3NpdGlvbi5YICtcclxuICAgICAgICAgICAgICAgICAgICB0cmFuc2Zvcm1CLlIuQ29sMi5YICogY2lyY2xlQi5Qb3NpdGlvbi5ZLFxyXG4gICAgICAgICAgICAgICAgICAgIHRyYW5zZm9ybUIuUG9zaXRpb24uWSArIHRyYW5zZm9ybUIuUi5Db2wxLlkgKiBjaXJjbGVCLlBvc2l0aW9uLlggK1xyXG4gICAgICAgICAgICAgICAgICAgIHRyYW5zZm9ybUIuUi5Db2wyLlkgKiBjaXJjbGVCLlBvc2l0aW9uLlkpO1xyXG4gICAgICAgICAgICBWZWN0b3IyIGNMb2NhbCA9XHJcbiAgICAgICAgICAgICAgICBuZXcgVmVjdG9yMihcclxuICAgICAgICAgICAgICAgICAgICAoYy5YIC0gdHJhbnNmb3JtQS5Qb3NpdGlvbi5YKSAqIHRyYW5zZm9ybUEuUi5Db2wxLlggK1xyXG4gICAgICAgICAgICAgICAgICAgIChjLlkgLSB0cmFuc2Zvcm1BLlBvc2l0aW9uLlkpICogdHJhbnNmb3JtQS5SLkNvbDEuWSxcclxuICAgICAgICAgICAgICAgICAgICAoYy5YIC0gdHJhbnNmb3JtQS5Qb3NpdGlvbi5YKSAqIHRyYW5zZm9ybUEuUi5Db2wyLlggK1xyXG4gICAgICAgICAgICAgICAgICAgIChjLlkgLSB0cmFuc2Zvcm1BLlBvc2l0aW9uLlkpICogdHJhbnNmb3JtQS5SLkNvbDIuWSk7XHJcblxyXG4gICAgICAgICAgICAvLyBGaW5kIHRoZSBtaW4gc2VwYXJhdGluZyBlZGdlLlxyXG4gICAgICAgICAgICBpbnQgbm9ybWFsSW5kZXggPSAwO1xyXG4gICAgICAgICAgICBmbG9hdCBzZXBhcmF0aW9uID0gLVNldHRpbmdzLk1heEZsb2F0O1xyXG4gICAgICAgICAgICBmbG9hdCByYWRpdXMgPSBwb2x5Z29uQS5SYWRpdXMgKyBjaXJjbGVCLlJhZGl1cztcclxuICAgICAgICAgICAgaW50IHZlcnRleENvdW50ID0gcG9seWdvbkEuVmVydGljZXMuQ291bnQ7XHJcblxyXG4gICAgICAgICAgICBmb3IgKGludCBpID0gMDsgaSA8IHZlcnRleENvdW50OyArK2kpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIFZlY3RvcjIgdmFsdWUxID0gcG9seWdvbkEuTm9ybWFsc1tpXTtcclxuICAgICAgICAgICAgICAgIFZlY3RvcjIgdmFsdWUyID0gY0xvY2FsIC0gcG9seWdvbkEuVmVydGljZXNbaV07XHJcbiAgICAgICAgICAgICAgICBmbG9hdCBzID0gdmFsdWUxLlggKiB2YWx1ZTIuWCArIHZhbHVlMS5ZICogdmFsdWUyLlk7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKHMgPiByYWRpdXMpXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gRWFybHkgb3V0LlxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBpZiAocyA+IHNlcGFyYXRpb24pXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgc2VwYXJhdGlvbiA9IHM7XHJcbiAgICAgICAgICAgICAgICAgICAgbm9ybWFsSW5kZXggPSBpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBWZXJ0aWNlcyB0aGF0IHN1YnRlbmQgdGhlIGluY2lkZW50IGZhY2UuXHJcbiAgICAgICAgICAgIGludCB2ZXJ0SW5kZXgxID0gbm9ybWFsSW5kZXg7XHJcbiAgICAgICAgICAgIGludCB2ZXJ0SW5kZXgyID0gdmVydEluZGV4MSArIDEgPCB2ZXJ0ZXhDb3VudCA/IHZlcnRJbmRleDEgKyAxIDogMDtcclxuICAgICAgICAgICAgVmVjdG9yMiB2MSA9IHBvbHlnb25BLlZlcnRpY2VzW3ZlcnRJbmRleDFdO1xyXG4gICAgICAgICAgICBWZWN0b3IyIHYyID0gcG9seWdvbkEuVmVydGljZXNbdmVydEluZGV4Ml07XHJcblxyXG4gICAgICAgICAgICAvLyBJZiB0aGUgY2VudGVyIGlzIGluc2lkZSB0aGUgcG9seWdvbiAuLi5cclxuICAgICAgICAgICAgaWYgKHNlcGFyYXRpb24gPCBTZXR0aW5ncy5FcHNpbG9uKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBtYW5pZm9sZC5Qb2ludENvdW50ID0gMTtcclxuICAgICAgICAgICAgICAgIG1hbmlmb2xkLlR5cGUgPSBNYW5pZm9sZFR5cGUuRmFjZUE7XHJcbiAgICAgICAgICAgICAgICBtYW5pZm9sZC5Mb2NhbE5vcm1hbCA9IHBvbHlnb25BLk5vcm1hbHNbbm9ybWFsSW5kZXhdO1xyXG4gICAgICAgICAgICAgICAgbWFuaWZvbGQuTG9jYWxQb2ludCA9IDAuNWYgKiAodjEgKyB2Mik7XHJcblxyXG4gICAgICAgICAgICAgICAgTWFuaWZvbGRQb2ludCBwMCA9IG1hbmlmb2xkLlBvaW50c1swXTtcclxuXHJcbiAgICAgICAgICAgICAgICBwMC5Mb2NhbFBvaW50ID0gY2lyY2xlQi5Qb3NpdGlvbjtcclxuICAgICAgICAgICAgICAgIHAwLklkLktleSA9IDA7XHJcblxyXG4gICAgICAgICAgICAgICAgbWFuaWZvbGQuUG9pbnRzWzBdID0gcDA7XHJcblxyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBDb21wdXRlIGJhcnljZW50cmljIGNvb3JkaW5hdGVzXHJcbiAgICAgICAgICAgIGZsb2F0IHUxID0gKGNMb2NhbC5YIC0gdjEuWCkgKiAodjIuWCAtIHYxLlgpICsgKGNMb2NhbC5ZIC0gdjEuWSkgKiAodjIuWSAtIHYxLlkpO1xyXG4gICAgICAgICAgICBmbG9hdCB1MiA9IChjTG9jYWwuWCAtIHYyLlgpICogKHYxLlggLSB2Mi5YKSArIChjTG9jYWwuWSAtIHYyLlkpICogKHYxLlkgLSB2Mi5ZKTtcclxuXHJcbiAgICAgICAgICAgIGlmICh1MSA8PSAwLjBmKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBmbG9hdCByID0gKGNMb2NhbC5YIC0gdjEuWCkgKiAoY0xvY2FsLlggLSB2MS5YKSArIChjTG9jYWwuWSAtIHYxLlkpICogKGNMb2NhbC5ZIC0gdjEuWSk7XHJcbiAgICAgICAgICAgICAgICBpZiAociA+IHJhZGl1cyAqIHJhZGl1cylcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgbWFuaWZvbGQuUG9pbnRDb3VudCA9IDE7XHJcbiAgICAgICAgICAgICAgICBtYW5pZm9sZC5UeXBlID0gTWFuaWZvbGRUeXBlLkZhY2VBO1xyXG4gICAgICAgICAgICAgICAgbWFuaWZvbGQuTG9jYWxOb3JtYWwgPSBjTG9jYWwgLSB2MTtcclxuICAgICAgICAgICAgICAgIGZsb2F0IGZhY3RvciA9IDFmIC9cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChmbG9hdClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE1hdGguU3FydChtYW5pZm9sZC5Mb2NhbE5vcm1hbC5YICogbWFuaWZvbGQuTG9jYWxOb3JtYWwuWCArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWFuaWZvbGQuTG9jYWxOb3JtYWwuWSAqIG1hbmlmb2xkLkxvY2FsTm9ybWFsLlkpO1xyXG4gICAgICAgICAgICAgICAgbWFuaWZvbGQuTG9jYWxOb3JtYWwuWCA9IG1hbmlmb2xkLkxvY2FsTm9ybWFsLlggKiBmYWN0b3I7XHJcbiAgICAgICAgICAgICAgICBtYW5pZm9sZC5Mb2NhbE5vcm1hbC5ZID0gbWFuaWZvbGQuTG9jYWxOb3JtYWwuWSAqIGZhY3RvcjtcclxuICAgICAgICAgICAgICAgIG1hbmlmb2xkLkxvY2FsUG9pbnQgPSB2MTtcclxuXHJcbiAgICAgICAgICAgICAgICBNYW5pZm9sZFBvaW50IHAwYiA9IG1hbmlmb2xkLlBvaW50c1swXTtcclxuXHJcbiAgICAgICAgICAgICAgICBwMGIuTG9jYWxQb2ludCA9IGNpcmNsZUIuUG9zaXRpb247XHJcbiAgICAgICAgICAgICAgICBwMGIuSWQuS2V5ID0gMDtcclxuXHJcbiAgICAgICAgICAgICAgICBtYW5pZm9sZC5Qb2ludHNbMF0gPSBwMGI7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAodTIgPD0gMC4wZilcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgZmxvYXQgciA9IChjTG9jYWwuWCAtIHYyLlgpICogKGNMb2NhbC5YIC0gdjIuWCkgKyAoY0xvY2FsLlkgLSB2Mi5ZKSAqIChjTG9jYWwuWSAtIHYyLlkpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHIgPiByYWRpdXMgKiByYWRpdXMpXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIG1hbmlmb2xkLlBvaW50Q291bnQgPSAxO1xyXG4gICAgICAgICAgICAgICAgbWFuaWZvbGQuVHlwZSA9IE1hbmlmb2xkVHlwZS5GYWNlQTtcclxuICAgICAgICAgICAgICAgIG1hbmlmb2xkLkxvY2FsTm9ybWFsID0gY0xvY2FsIC0gdjI7XHJcbiAgICAgICAgICAgICAgICBmbG9hdCBmYWN0b3IgPSAxZiAvXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoZmxvYXQpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBNYXRoLlNxcnQobWFuaWZvbGQuTG9jYWxOb3JtYWwuWCAqIG1hbmlmb2xkLkxvY2FsTm9ybWFsLlggK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hbmlmb2xkLkxvY2FsTm9ybWFsLlkgKiBtYW5pZm9sZC5Mb2NhbE5vcm1hbC5ZKTtcclxuICAgICAgICAgICAgICAgIG1hbmlmb2xkLkxvY2FsTm9ybWFsLlggPSBtYW5pZm9sZC5Mb2NhbE5vcm1hbC5YICogZmFjdG9yO1xyXG4gICAgICAgICAgICAgICAgbWFuaWZvbGQuTG9jYWxOb3JtYWwuWSA9IG1hbmlmb2xkLkxvY2FsTm9ybWFsLlkgKiBmYWN0b3I7XHJcbiAgICAgICAgICAgICAgICBtYW5pZm9sZC5Mb2NhbFBvaW50ID0gdjI7XHJcblxyXG4gICAgICAgICAgICAgICAgTWFuaWZvbGRQb2ludCBwMGMgPSBtYW5pZm9sZC5Qb2ludHNbMF07XHJcblxyXG4gICAgICAgICAgICAgICAgcDBjLkxvY2FsUG9pbnQgPSBjaXJjbGVCLlBvc2l0aW9uO1xyXG4gICAgICAgICAgICAgICAgcDBjLklkLktleSA9IDA7XHJcblxyXG4gICAgICAgICAgICAgICAgbWFuaWZvbGQuUG9pbnRzWzBdID0gcDBjO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgVmVjdG9yMiBmYWNlQ2VudGVyID0gMC41ZiAqICh2MSArIHYyKTtcclxuICAgICAgICAgICAgICAgIFZlY3RvcjIgdmFsdWUxID0gY0xvY2FsIC0gZmFjZUNlbnRlcjtcclxuICAgICAgICAgICAgICAgIFZlY3RvcjIgdmFsdWUyID0gcG9seWdvbkEuTm9ybWFsc1t2ZXJ0SW5kZXgxXTtcclxuICAgICAgICAgICAgICAgIGZsb2F0IHNlcGFyYXRpb24yID0gdmFsdWUxLlggKiB2YWx1ZTIuWCArIHZhbHVlMS5ZICogdmFsdWUyLlk7XHJcbiAgICAgICAgICAgICAgICBpZiAoc2VwYXJhdGlvbjIgPiByYWRpdXMpXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIG1hbmlmb2xkLlBvaW50Q291bnQgPSAxO1xyXG4gICAgICAgICAgICAgICAgbWFuaWZvbGQuVHlwZSA9IE1hbmlmb2xkVHlwZS5GYWNlQTtcclxuICAgICAgICAgICAgICAgIG1hbmlmb2xkLkxvY2FsTm9ybWFsID0gcG9seWdvbkEuTm9ybWFsc1t2ZXJ0SW5kZXgxXTtcclxuICAgICAgICAgICAgICAgIG1hbmlmb2xkLkxvY2FsUG9pbnQgPSBmYWNlQ2VudGVyO1xyXG5cclxuICAgICAgICAgICAgICAgIE1hbmlmb2xkUG9pbnQgcDBkID0gbWFuaWZvbGQuUG9pbnRzWzBdO1xyXG5cclxuICAgICAgICAgICAgICAgIHAwZC5Mb2NhbFBvaW50ID0gY2lyY2xlQi5Qb3NpdGlvbjtcclxuICAgICAgICAgICAgICAgIHAwZC5JZC5LZXkgPSAwO1xyXG5cclxuICAgICAgICAgICAgICAgIG1hbmlmb2xkLlBvaW50c1swXSA9IHAwZDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBDb21wdXRlIHRoZSBjb2xsaXNpb24gbWFuaWZvbGQgYmV0d2VlbiB0d28gcG9seWdvbnMuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJtYW5pZm9sZFwiPlRoZSBtYW5pZm9sZC48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cInBvbHlBXCI+VGhlIHBvbHkgQS48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cInRyYW5zZm9ybUFcIj5UaGUgdHJhbnNmb3JtIEEuPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJwb2x5QlwiPlRoZSBwb2x5IEIuPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJ0cmFuc2Zvcm1CXCI+VGhlIHRyYW5zZm9ybSBCLjwvcGFyYW0+XHJcbiAgICAgICAgcHVibGljIHN0YXRpYyB2b2lkIENvbGxpZGVQb2x5Z29ucyhyZWYgTWFuaWZvbGQgbWFuaWZvbGQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBQb2x5Z29uU2hhcGUgcG9seUEsIHJlZiBUcmFuc2Zvcm0gdHJhbnNmb3JtQSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFBvbHlnb25TaGFwZSBwb2x5QiwgcmVmIFRyYW5zZm9ybSB0cmFuc2Zvcm1CKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgbWFuaWZvbGQuUG9pbnRDb3VudCA9IDA7XHJcbiAgICAgICAgICAgIGZsb2F0IHRvdGFsUmFkaXVzID0gcG9seUEuUmFkaXVzICsgcG9seUIuUmFkaXVzO1xyXG5cclxuICAgICAgICAgICAgaW50IGVkZ2VBID0gMDtcclxuICAgICAgICAgICAgZmxvYXQgc2VwYXJhdGlvbkEgPSBGaW5kTWF4U2VwYXJhdGlvbihvdXQgZWRnZUEsIHBvbHlBLCByZWYgdHJhbnNmb3JtQSwgcG9seUIsIHJlZiB0cmFuc2Zvcm1CKTtcclxuICAgICAgICAgICAgaWYgKHNlcGFyYXRpb25BID4gdG90YWxSYWRpdXMpXHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcblxyXG4gICAgICAgICAgICBpbnQgZWRnZUIgPSAwO1xyXG4gICAgICAgICAgICBmbG9hdCBzZXBhcmF0aW9uQiA9IEZpbmRNYXhTZXBhcmF0aW9uKG91dCBlZGdlQiwgcG9seUIsIHJlZiB0cmFuc2Zvcm1CLCBwb2x5QSwgcmVmIHRyYW5zZm9ybUEpO1xyXG4gICAgICAgICAgICBpZiAoc2VwYXJhdGlvbkIgPiB0b3RhbFJhZGl1cylcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuXHJcbiAgICAgICAgICAgIFBvbHlnb25TaGFwZSBwb2x5MTsgLy8gcmVmZXJlbmNlIHBvbHlnb25cclxuICAgICAgICAgICAgUG9seWdvblNoYXBlIHBvbHkyOyAvLyBpbmNpZGVudCBwb2x5Z29uXHJcbiAgICAgICAgICAgIFRyYW5zZm9ybSB4ZjEsIHhmMjtcclxuICAgICAgICAgICAgaW50IGVkZ2UxOyAvLyByZWZlcmVuY2UgZWRnZVxyXG4gICAgICAgICAgICBib29sIGZsaXA7XHJcbiAgICAgICAgICAgIGNvbnN0IGZsb2F0IGtfcmVsYXRpdmVUb2wgPSAwLjk4ZjtcclxuICAgICAgICAgICAgY29uc3QgZmxvYXQga19hYnNvbHV0ZVRvbCA9IDAuMDAxZjtcclxuXHJcbiAgICAgICAgICAgIGlmIChzZXBhcmF0aW9uQiA+IGtfcmVsYXRpdmVUb2wgKiBzZXBhcmF0aW9uQSArIGtfYWJzb2x1dGVUb2wpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHBvbHkxID0gcG9seUI7XHJcbiAgICAgICAgICAgICAgICBwb2x5MiA9IHBvbHlBO1xyXG4gICAgICAgICAgICAgICAgeGYxID0gdHJhbnNmb3JtQjtcclxuICAgICAgICAgICAgICAgIHhmMiA9IHRyYW5zZm9ybUE7XHJcbiAgICAgICAgICAgICAgICBlZGdlMSA9IGVkZ2VCO1xyXG4gICAgICAgICAgICAgICAgbWFuaWZvbGQuVHlwZSA9IE1hbmlmb2xkVHlwZS5GYWNlQjtcclxuICAgICAgICAgICAgICAgIGZsaXAgPSB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgcG9seTEgPSBwb2x5QTtcclxuICAgICAgICAgICAgICAgIHBvbHkyID0gcG9seUI7XHJcbiAgICAgICAgICAgICAgICB4ZjEgPSB0cmFuc2Zvcm1BO1xyXG4gICAgICAgICAgICAgICAgeGYyID0gdHJhbnNmb3JtQjtcclxuICAgICAgICAgICAgICAgIGVkZ2UxID0gZWRnZUE7XHJcbiAgICAgICAgICAgICAgICBtYW5pZm9sZC5UeXBlID0gTWFuaWZvbGRUeXBlLkZhY2VBO1xyXG4gICAgICAgICAgICAgICAgZmxpcCA9IGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBGaXhlZEFycmF5MjxDbGlwVmVydGV4PiBpbmNpZGVudEVkZ2U7XHJcbiAgICAgICAgICAgIEZpbmRJbmNpZGVudEVkZ2Uob3V0IGluY2lkZW50RWRnZSwgcG9seTEsIHJlZiB4ZjEsIGVkZ2UxLCBwb2x5MiwgcmVmIHhmMik7XHJcblxyXG4gICAgICAgICAgICBpbnQgY291bnQxID0gcG9seTEuVmVydGljZXMuQ291bnQ7XHJcblxyXG4gICAgICAgICAgICBpbnQgaXYxID0gZWRnZTE7XHJcbiAgICAgICAgICAgIGludCBpdjIgPSBlZGdlMSArIDEgPCBjb3VudDEgPyBlZGdlMSArIDEgOiAwO1xyXG5cclxuICAgICAgICAgICAgVmVjdG9yMiB2MTEgPSBwb2x5MS5WZXJ0aWNlc1tpdjFdO1xyXG4gICAgICAgICAgICBWZWN0b3IyIHYxMiA9IHBvbHkxLlZlcnRpY2VzW2l2Ml07XHJcblxyXG4gICAgICAgICAgICBmbG9hdCBsb2NhbFRhbmdlbnRYID0gdjEyLlggLSB2MTEuWDtcclxuICAgICAgICAgICAgZmxvYXQgbG9jYWxUYW5nZW50WSA9IHYxMi5ZIC0gdjExLlk7XHJcblxyXG4gICAgICAgICAgICBmbG9hdCBmYWN0b3IgPSAxZiAvIChmbG9hdClNYXRoLlNxcnQobG9jYWxUYW5nZW50WCAqIGxvY2FsVGFuZ2VudFggKyBsb2NhbFRhbmdlbnRZICogbG9jYWxUYW5nZW50WSk7XHJcbiAgICAgICAgICAgIGxvY2FsVGFuZ2VudFggPSBsb2NhbFRhbmdlbnRYICogZmFjdG9yO1xyXG4gICAgICAgICAgICBsb2NhbFRhbmdlbnRZID0gbG9jYWxUYW5nZW50WSAqIGZhY3RvcjtcclxuXHJcbiAgICAgICAgICAgIFZlY3RvcjIgbG9jYWxOb3JtYWwgPSBuZXcgVmVjdG9yMihsb2NhbFRhbmdlbnRZLCAtbG9jYWxUYW5nZW50WCk7XHJcbiAgICAgICAgICAgIFZlY3RvcjIgcGxhbmVQb2ludCA9IDAuNWYgKiAodjExICsgdjEyKTtcclxuXHJcbiAgICAgICAgICAgIFZlY3RvcjIgdGFuZ2VudCA9IG5ldyBWZWN0b3IyKHhmMS5SLkNvbDEuWCAqIGxvY2FsVGFuZ2VudFggKyB4ZjEuUi5Db2wyLlggKiBsb2NhbFRhbmdlbnRZLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB4ZjEuUi5Db2wxLlkgKiBsb2NhbFRhbmdlbnRYICsgeGYxLlIuQ29sMi5ZICogbG9jYWxUYW5nZW50WSk7XHJcbiAgICAgICAgICAgIGZsb2F0IG5vcm1hbHggPSB0YW5nZW50Llk7XHJcbiAgICAgICAgICAgIGZsb2F0IG5vcm1hbHkgPSAtdGFuZ2VudC5YO1xyXG5cclxuICAgICAgICAgICAgdjExID0gbmV3IFZlY3RvcjIoeGYxLlBvc2l0aW9uLlggKyB4ZjEuUi5Db2wxLlggKiB2MTEuWCArIHhmMS5SLkNvbDIuWCAqIHYxMS5ZLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICB4ZjEuUG9zaXRpb24uWSArIHhmMS5SLkNvbDEuWSAqIHYxMS5YICsgeGYxLlIuQ29sMi5ZICogdjExLlkpO1xyXG4gICAgICAgICAgICB2MTIgPSBuZXcgVmVjdG9yMih4ZjEuUG9zaXRpb24uWCArIHhmMS5SLkNvbDEuWCAqIHYxMi5YICsgeGYxLlIuQ29sMi5YICogdjEyLlksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHhmMS5Qb3NpdGlvbi5ZICsgeGYxLlIuQ29sMS5ZICogdjEyLlggKyB4ZjEuUi5Db2wyLlkgKiB2MTIuWSk7XHJcblxyXG4gICAgICAgICAgICAvLyBGYWNlIG9mZnNldC5cclxuICAgICAgICAgICAgZmxvYXQgZnJvbnRPZmZzZXQgPSBub3JtYWx4ICogdjExLlggKyBub3JtYWx5ICogdjExLlk7XHJcblxyXG4gICAgICAgICAgICAvLyBTaWRlIG9mZnNldHMsIGV4dGVuZGVkIGJ5IHBvbHl0b3BlIHNraW4gdGhpY2tuZXNzLlxyXG4gICAgICAgICAgICBmbG9hdCBzaWRlT2Zmc2V0MSA9IC0odGFuZ2VudC5YICogdjExLlggKyB0YW5nZW50LlkgKiB2MTEuWSkgKyB0b3RhbFJhZGl1cztcclxuICAgICAgICAgICAgZmxvYXQgc2lkZU9mZnNldDIgPSB0YW5nZW50LlggKiB2MTIuWCArIHRhbmdlbnQuWSAqIHYxMi5ZICsgdG90YWxSYWRpdXM7XHJcblxyXG4gICAgICAgICAgICAvLyBDbGlwIGluY2lkZW50IGVkZ2UgYWdhaW5zdCBleHRydWRlZCBlZGdlMSBzaWRlIGVkZ2VzLlxyXG4gICAgICAgICAgICBGaXhlZEFycmF5MjxDbGlwVmVydGV4PiBjbGlwUG9pbnRzMTtcclxuICAgICAgICAgICAgRml4ZWRBcnJheTI8Q2xpcFZlcnRleD4gY2xpcFBvaW50czI7XHJcblxyXG4gICAgICAgICAgICAvLyBDbGlwIHRvIGJveCBzaWRlIDFcclxuICAgICAgICAgICAgaW50IG5wID0gQ2xpcFNlZ21lbnRUb0xpbmUob3V0IGNsaXBQb2ludHMxLCByZWYgaW5jaWRlbnRFZGdlLCAtdGFuZ2VudCwgc2lkZU9mZnNldDEsIGl2MSk7XHJcblxyXG4gICAgICAgICAgICBpZiAobnAgPCAyKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG5cclxuICAgICAgICAgICAgLy8gQ2xpcCB0byBuZWdhdGl2ZSBib3ggc2lkZSAxXHJcbiAgICAgICAgICAgIG5wID0gQ2xpcFNlZ21lbnRUb0xpbmUob3V0IGNsaXBQb2ludHMyLCByZWYgY2xpcFBvaW50czEsIHRhbmdlbnQsIHNpZGVPZmZzZXQyLCBpdjIpO1xyXG5cclxuICAgICAgICAgICAgaWYgKG5wIDwgMilcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBOb3cgY2xpcFBvaW50czIgY29udGFpbnMgdGhlIGNsaXBwZWQgcG9pbnRzLlxyXG4gICAgICAgICAgICBtYW5pZm9sZC5Mb2NhbE5vcm1hbCA9IGxvY2FsTm9ybWFsO1xyXG4gICAgICAgICAgICBtYW5pZm9sZC5Mb2NhbFBvaW50ID0gcGxhbmVQb2ludDtcclxuXHJcbiAgICAgICAgICAgIGludCBwb2ludENvdW50ID0gMDtcclxuICAgICAgICAgICAgZm9yIChpbnQgaSA9IDA7IGkgPCBTZXR0aW5ncy5NYXhNYW5pZm9sZFBvaW50czsgKytpKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBWZWN0b3IyIHZhbHVlID0gY2xpcFBvaW50czJbaV0uVjtcclxuICAgICAgICAgICAgICAgIGZsb2F0IHNlcGFyYXRpb24gPSBub3JtYWx4ICogdmFsdWUuWCArIG5vcm1hbHkgKiB2YWx1ZS5ZIC0gZnJvbnRPZmZzZXQ7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKHNlcGFyYXRpb24gPD0gdG90YWxSYWRpdXMpXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgTWFuaWZvbGRQb2ludCBjcCA9IG1hbmlmb2xkLlBvaW50c1twb2ludENvdW50XTtcclxuICAgICAgICAgICAgICAgICAgICBWZWN0b3IyIHRtcCA9IGNsaXBQb2ludHMyW2ldLlY7XHJcbiAgICAgICAgICAgICAgICAgICAgZmxvYXQgdG1wMVggPSB0bXAuWCAtIHhmMi5Qb3NpdGlvbi5YO1xyXG4gICAgICAgICAgICAgICAgICAgIGZsb2F0IHRtcDFZID0gdG1wLlkgLSB4ZjIuUG9zaXRpb24uWTtcclxuICAgICAgICAgICAgICAgICAgICBjcC5Mb2NhbFBvaW50LlggPSB0bXAxWCAqIHhmMi5SLkNvbDEuWCArIHRtcDFZICogeGYyLlIuQ29sMS5ZO1xyXG4gICAgICAgICAgICAgICAgICAgIGNwLkxvY2FsUG9pbnQuWSA9IHRtcDFYICogeGYyLlIuQ29sMi5YICsgdG1wMVkgKiB4ZjIuUi5Db2wyLlk7XHJcbiAgICAgICAgICAgICAgICAgICAgY3AuSWQgPSBjbGlwUG9pbnRzMltpXS5JRDtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGZsaXApXHJcbiAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBTd2FwIGZlYXR1cmVzXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIENvbnRhY3RGZWF0dXJlIGNmID0gY3AuSWQuRmVhdHVyZXM7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNwLklkLkZlYXR1cmVzLkluZGV4QSA9IGNmLkluZGV4QjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY3AuSWQuRmVhdHVyZXMuSW5kZXhCID0gY2YuSW5kZXhBO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjcC5JZC5GZWF0dXJlcy5UeXBlQSA9IGNmLlR5cGVCO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjcC5JZC5GZWF0dXJlcy5UeXBlQiA9IGNmLlR5cGVBO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgbWFuaWZvbGQuUG9pbnRzW3BvaW50Q291bnRdID0gY3A7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICsrcG9pbnRDb3VudDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgbWFuaWZvbGQuUG9pbnRDb3VudCA9IHBvaW50Q291bnQ7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIENvbXB1dGUgY29udGFjdCBwb2ludHMgZm9yIGVkZ2UgdmVyc3VzIGNpcmNsZS5cclxuICAgICAgICAvLy8gVGhpcyBhY2NvdW50cyBmb3IgZWRnZSBjb25uZWN0aXZpdHkuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJtYW5pZm9sZFwiPlRoZSBtYW5pZm9sZC48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cImVkZ2VBXCI+VGhlIGVkZ2UgQS48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cInRyYW5zZm9ybUFcIj5UaGUgdHJhbnNmb3JtIEEuPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJjaXJjbGVCXCI+VGhlIGNpcmNsZSBCLjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwidHJhbnNmb3JtQlwiPlRoZSB0cmFuc2Zvcm0gQi48L3BhcmFtPlxyXG4gICAgICAgIHB1YmxpYyBzdGF0aWMgdm9pZCBDb2xsaWRlRWRnZUFuZENpcmNsZShyZWYgTWFuaWZvbGQgbWFuaWZvbGQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEVkZ2VTaGFwZSBlZGdlQSwgcmVmIFRyYW5zZm9ybSB0cmFuc2Zvcm1BLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBDaXJjbGVTaGFwZSBjaXJjbGVCLCByZWYgVHJhbnNmb3JtIHRyYW5zZm9ybUIpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBtYW5pZm9sZC5Qb2ludENvdW50ID0gMDtcclxuXHJcbiAgICAgICAgICAgIC8vIENvbXB1dGUgY2lyY2xlIGluIGZyYW1lIG9mIGVkZ2VcclxuICAgICAgICAgICAgVmVjdG9yMiBRID0gTWF0aFV0aWxzLk11bHRpcGx5VChyZWYgdHJhbnNmb3JtQSwgTWF0aFV0aWxzLk11bHRpcGx5KHJlZiB0cmFuc2Zvcm1CLCByZWYgY2lyY2xlQi5fcG9zaXRpb24pKTtcclxuXHJcbiAgICAgICAgICAgIFZlY3RvcjIgQSA9IGVkZ2VBLlZlcnRleDEsIEIgPSBlZGdlQS5WZXJ0ZXgyO1xyXG4gICAgICAgICAgICBWZWN0b3IyIGUgPSBCIC0gQTtcclxuXHJcbiAgICAgICAgICAgIC8vIEJhcnljZW50cmljIGNvb3JkaW5hdGVzXHJcbiAgICAgICAgICAgIGZsb2F0IHUgPSBWZWN0b3IyLkRvdChlLCBCIC0gUSk7XHJcbiAgICAgICAgICAgIGZsb2F0IHYgPSBWZWN0b3IyLkRvdChlLCBRIC0gQSk7XHJcblxyXG4gICAgICAgICAgICBmbG9hdCByYWRpdXMgPSBlZGdlQS5SYWRpdXMgKyBjaXJjbGVCLlJhZGl1cztcclxuXHJcbiAgICAgICAgICAgIENvbnRhY3RGZWF0dXJlIGNmO1xyXG4gICAgICAgICAgICBjZi5JbmRleEIgPSAwO1xyXG4gICAgICAgICAgICBjZi5UeXBlQiA9IChieXRlKUNvbnRhY3RGZWF0dXJlVHlwZS5WZXJ0ZXg7XHJcblxyXG4gICAgICAgICAgICBWZWN0b3IyIFAsIGQ7XHJcblxyXG4gICAgICAgICAgICAvLyBSZWdpb24gQVxyXG4gICAgICAgICAgICBpZiAodiA8PSAwLjBmKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBQID0gQTtcclxuICAgICAgICAgICAgICAgIGQgPSBRIC0gUDtcclxuICAgICAgICAgICAgICAgIGZsb2F0IGRkO1xyXG4gICAgICAgICAgICAgICAgVmVjdG9yMi5Eb3QocmVmIGQsIHJlZiBkLCBvdXQgZGQpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGRkID4gcmFkaXVzICogcmFkaXVzKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAvLyBJcyB0aGVyZSBhbiBlZGdlIGNvbm5lY3RlZCB0byBBP1xyXG4gICAgICAgICAgICAgICAgaWYgKGVkZ2VBLkhhc1ZlcnRleDApXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgVmVjdG9yMiBBMSA9IGVkZ2VBLlZlcnRleDA7XHJcbiAgICAgICAgICAgICAgICAgICAgVmVjdG9yMiBCMSA9IEE7XHJcbiAgICAgICAgICAgICAgICAgICAgVmVjdG9yMiBlMSA9IEIxIC0gQTE7XHJcbiAgICAgICAgICAgICAgICAgICAgZmxvYXQgdTEgPSBWZWN0b3IyLkRvdChlMSwgQjEgLSBRKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gSXMgdGhlIGNpcmNsZSBpbiBSZWdpb24gQUIgb2YgdGhlIHByZXZpb3VzIGVkZ2U/XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHUxID4gMC4wZilcclxuICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgY2YuSW5kZXhBID0gMDtcclxuICAgICAgICAgICAgICAgIGNmLlR5cGVBID0gKGJ5dGUpQ29udGFjdEZlYXR1cmVUeXBlLlZlcnRleDtcclxuICAgICAgICAgICAgICAgIG1hbmlmb2xkLlBvaW50Q291bnQgPSAxO1xyXG4gICAgICAgICAgICAgICAgbWFuaWZvbGQuVHlwZSA9IE1hbmlmb2xkVHlwZS5DaXJjbGVzO1xyXG4gICAgICAgICAgICAgICAgbWFuaWZvbGQuTG9jYWxOb3JtYWwgPSBWZWN0b3IyLlplcm87XHJcbiAgICAgICAgICAgICAgICBtYW5pZm9sZC5Mb2NhbFBvaW50ID0gUDtcclxuICAgICAgICAgICAgICAgIE1hbmlmb2xkUG9pbnQgbXAgPSBuZXcgTWFuaWZvbGRQb2ludCgpO1xyXG4gICAgICAgICAgICAgICAgbXAuSWQuS2V5ID0gMDtcclxuICAgICAgICAgICAgICAgIG1wLklkLkZlYXR1cmVzID0gY2Y7XHJcbiAgICAgICAgICAgICAgICBtcC5Mb2NhbFBvaW50ID0gY2lyY2xlQi5Qb3NpdGlvbjtcclxuICAgICAgICAgICAgICAgIG1hbmlmb2xkLlBvaW50c1swXSA9IG1wO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBSZWdpb24gQlxyXG4gICAgICAgICAgICBpZiAodSA8PSAwLjBmKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBQID0gQjtcclxuICAgICAgICAgICAgICAgIGQgPSBRIC0gUDtcclxuICAgICAgICAgICAgICAgIGZsb2F0IGRkO1xyXG4gICAgICAgICAgICAgICAgVmVjdG9yMi5Eb3QocmVmIGQsIHJlZiBkLCBvdXQgZGQpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGRkID4gcmFkaXVzICogcmFkaXVzKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAvLyBJcyB0aGVyZSBhbiBlZGdlIGNvbm5lY3RlZCB0byBCP1xyXG4gICAgICAgICAgICAgICAgaWYgKGVkZ2VBLkhhc1ZlcnRleDMpXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgVmVjdG9yMiBCMiA9IGVkZ2VBLlZlcnRleDM7XHJcbiAgICAgICAgICAgICAgICAgICAgVmVjdG9yMiBBMiA9IEI7XHJcbiAgICAgICAgICAgICAgICAgICAgVmVjdG9yMiBlMiA9IEIyIC0gQTI7XHJcbiAgICAgICAgICAgICAgICAgICAgZmxvYXQgdjIgPSBWZWN0b3IyLkRvdChlMiwgUSAtIEEyKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gSXMgdGhlIGNpcmNsZSBpbiBSZWdpb24gQUIgb2YgdGhlIG5leHQgZWRnZT9cclxuICAgICAgICAgICAgICAgICAgICBpZiAodjIgPiAwLjBmKVxyXG4gICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBjZi5JbmRleEEgPSAxO1xyXG4gICAgICAgICAgICAgICAgY2YuVHlwZUEgPSAoYnl0ZSlDb250YWN0RmVhdHVyZVR5cGUuVmVydGV4O1xyXG4gICAgICAgICAgICAgICAgbWFuaWZvbGQuUG9pbnRDb3VudCA9IDE7XHJcbiAgICAgICAgICAgICAgICBtYW5pZm9sZC5UeXBlID0gTWFuaWZvbGRUeXBlLkNpcmNsZXM7XHJcbiAgICAgICAgICAgICAgICBtYW5pZm9sZC5Mb2NhbE5vcm1hbCA9IFZlY3RvcjIuWmVybztcclxuICAgICAgICAgICAgICAgIG1hbmlmb2xkLkxvY2FsUG9pbnQgPSBQO1xyXG4gICAgICAgICAgICAgICAgTWFuaWZvbGRQb2ludCBtcCA9IG5ldyBNYW5pZm9sZFBvaW50KCk7XHJcbiAgICAgICAgICAgICAgICBtcC5JZC5LZXkgPSAwO1xyXG4gICAgICAgICAgICAgICAgbXAuSWQuRmVhdHVyZXMgPSBjZjtcclxuICAgICAgICAgICAgICAgIG1wLkxvY2FsUG9pbnQgPSBjaXJjbGVCLlBvc2l0aW9uO1xyXG4gICAgICAgICAgICAgICAgbWFuaWZvbGQuUG9pbnRzWzBdID0gbXA7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIFJlZ2lvbiBBQlxyXG4gICAgICAgICAgICBmbG9hdCBkZW47XHJcbiAgICAgICAgICAgIFZlY3RvcjIuRG90KHJlZiBlLCByZWYgZSwgb3V0IGRlbik7XHJcbiAgICAgICAgICAgIERlYnVnLkFzc2VydChkZW4gPiAwLjBmKTtcclxuICAgICAgICAgICAgUCA9ICgxLjBmIC8gZGVuKSAqICh1ICogQSArIHYgKiBCKTtcclxuICAgICAgICAgICAgZCA9IFEgLSBQO1xyXG4gICAgICAgICAgICBmbG9hdCBkZDI7XHJcbiAgICAgICAgICAgIFZlY3RvcjIuRG90KHJlZiBkLCByZWYgZCwgb3V0IGRkMik7XHJcbiAgICAgICAgICAgIGlmIChkZDIgPiByYWRpdXMgKiByYWRpdXMpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgVmVjdG9yMiBuID0gbmV3IFZlY3RvcjIoLWUuWSwgZS5YKTtcclxuICAgICAgICAgICAgaWYgKFZlY3RvcjIuRG90KG4sIFEgLSBBKSA8IDAuMGYpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIG4gPSBuZXcgVmVjdG9yMigtbi5YLCAtbi5ZKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBuLk5vcm1hbGl6ZSgpO1xyXG5cclxuICAgICAgICAgICAgY2YuSW5kZXhBID0gMDtcclxuICAgICAgICAgICAgY2YuVHlwZUEgPSAoYnl0ZSlDb250YWN0RmVhdHVyZVR5cGUuRmFjZTtcclxuICAgICAgICAgICAgbWFuaWZvbGQuUG9pbnRDb3VudCA9IDE7XHJcbiAgICAgICAgICAgIG1hbmlmb2xkLlR5cGUgPSBNYW5pZm9sZFR5cGUuRmFjZUE7XHJcbiAgICAgICAgICAgIG1hbmlmb2xkLkxvY2FsTm9ybWFsID0gbjtcclxuICAgICAgICAgICAgbWFuaWZvbGQuTG9jYWxQb2ludCA9IEE7XHJcbiAgICAgICAgICAgIE1hbmlmb2xkUG9pbnQgbXAyID0gbmV3IE1hbmlmb2xkUG9pbnQoKTtcclxuICAgICAgICAgICAgbXAyLklkLktleSA9IDA7XHJcbiAgICAgICAgICAgIG1wMi5JZC5GZWF0dXJlcyA9IGNmO1xyXG4gICAgICAgICAgICBtcDIuTG9jYWxQb2ludCA9IGNpcmNsZUIuUG9zaXRpb247XHJcbiAgICAgICAgICAgIG1hbmlmb2xkLlBvaW50c1swXSA9IG1wMjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gQ29sbGlkZXMgYW5kIGVkZ2UgYW5kIGEgcG9seWdvbiwgdGFraW5nIGludG8gYWNjb3VudCBlZGdlIGFkamFjZW5jeS5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cIm1hbmlmb2xkXCI+VGhlIG1hbmlmb2xkLjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwiZWRnZUFcIj5UaGUgZWRnZSBBLjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwieGZBXCI+VGhlIHhmIEEuPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJwb2x5Z29uQlwiPlRoZSBwb2x5Z29uIEIuPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJ4ZkJcIj5UaGUgeGYgQi48L3BhcmFtPlxyXG4gICAgICAgIHB1YmxpYyBzdGF0aWMgdm9pZCBDb2xsaWRlRWRnZUFuZFBvbHlnb24ocmVmIE1hbmlmb2xkIG1hbmlmb2xkLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgRWRnZVNoYXBlIGVkZ2VBLCByZWYgVHJhbnNmb3JtIHhmQSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFBvbHlnb25TaGFwZSBwb2x5Z29uQiwgcmVmIFRyYW5zZm9ybSB4ZkIpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBNYXRoVXRpbHMuTXVsdGlwbHlUKHJlZiB4ZkEsIHJlZiB4ZkIsIG91dCBfeGYpO1xyXG5cclxuICAgICAgICAgICAgLy8gRWRnZSBnZW9tZXRyeVxyXG4gICAgICAgICAgICBfZWRnZUEuVjAgPSBlZGdlQS5WZXJ0ZXgwO1xyXG4gICAgICAgICAgICBfZWRnZUEuVjEgPSBlZGdlQS5WZXJ0ZXgxO1xyXG4gICAgICAgICAgICBfZWRnZUEuVjIgPSBlZGdlQS5WZXJ0ZXgyO1xyXG4gICAgICAgICAgICBfZWRnZUEuVjMgPSBlZGdlQS5WZXJ0ZXgzO1xyXG4gICAgICAgICAgICBWZWN0b3IyIGUgPSBfZWRnZUEuVjIgLSBfZWRnZUEuVjE7XHJcblxyXG4gICAgICAgICAgICAvLyBOb3JtYWwgcG9pbnRzIG91dHdhcmRzIGluIENDVyBvcmRlci5cclxuICAgICAgICAgICAgX2VkZ2VBLk5vcm1hbCA9IG5ldyBWZWN0b3IyKGUuWSwgLWUuWCk7XHJcbiAgICAgICAgICAgIF9lZGdlQS5Ob3JtYWwuTm9ybWFsaXplKCk7XHJcbiAgICAgICAgICAgIF9lZGdlQS5IYXNWZXJ0ZXgwID0gZWRnZUEuSGFzVmVydGV4MDtcclxuICAgICAgICAgICAgX2VkZ2VBLkhhc1ZlcnRleDMgPSBlZGdlQS5IYXNWZXJ0ZXgzO1xyXG5cclxuICAgICAgICAgICAgLy8gUHJveHkgZm9yIGVkZ2VcclxuICAgICAgICAgICAgX3Byb3h5QS5WZXJ0aWNlc1swXSA9IF9lZGdlQS5WMTtcclxuICAgICAgICAgICAgX3Byb3h5QS5WZXJ0aWNlc1sxXSA9IF9lZGdlQS5WMjtcclxuICAgICAgICAgICAgX3Byb3h5QS5Ob3JtYWxzWzBdID0gX2VkZ2VBLk5vcm1hbDtcclxuICAgICAgICAgICAgX3Byb3h5QS5Ob3JtYWxzWzFdID0gLV9lZGdlQS5Ob3JtYWw7XHJcbiAgICAgICAgICAgIF9wcm94eUEuQ2VudHJvaWQgPSAwLjVmICogKF9lZGdlQS5WMSArIF9lZGdlQS5WMik7XHJcbiAgICAgICAgICAgIF9wcm94eUEuQ291bnQgPSAyO1xyXG5cclxuICAgICAgICAgICAgLy8gUHJveHkgZm9yIHBvbHlnb25cclxuICAgICAgICAgICAgX3Byb3h5Qi5Db3VudCA9IHBvbHlnb25CLlZlcnRpY2VzLkNvdW50O1xyXG4gICAgICAgICAgICBfcHJveHlCLkNlbnRyb2lkID0gTWF0aFV0aWxzLk11bHRpcGx5KHJlZiBfeGYsIHJlZiBwb2x5Z29uQi5NYXNzRGF0YS5DZW50cm9pZCk7XHJcbiAgICAgICAgICAgIGZvciAoaW50IGkgPSAwOyBpIDwgcG9seWdvbkIuVmVydGljZXMuQ291bnQ7ICsraSlcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgX3Byb3h5Qi5WZXJ0aWNlc1tpXSA9IE1hdGhVdGlscy5NdWx0aXBseShyZWYgX3hmLCBwb2x5Z29uQi5WZXJ0aWNlc1tpXSk7XHJcbiAgICAgICAgICAgICAgICBfcHJveHlCLk5vcm1hbHNbaV0gPSBNYXRoVXRpbHMuTXVsdGlwbHkocmVmIF94Zi5SLCBwb2x5Z29uQi5Ob3JtYWxzW2ldKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgX3JhZGl1cyA9IDIuMGYgKiBTZXR0aW5ncy5Qb2x5Z29uUmFkaXVzO1xyXG5cclxuICAgICAgICAgICAgX2xpbWl0MTEgPSBWZWN0b3IyLlplcm87XHJcbiAgICAgICAgICAgIF9saW1pdDEyID0gVmVjdG9yMi5aZXJvO1xyXG4gICAgICAgICAgICBfbGltaXQyMSA9IFZlY3RvcjIuWmVybztcclxuICAgICAgICAgICAgX2xpbWl0MjIgPSBWZWN0b3IyLlplcm87XHJcblxyXG4gICAgICAgICAgICAvL0NvbGxpZGUocmVmIG1hbmlmb2xkKTsgaW5saW5lIHN0YXJ0XHJcbiAgICAgICAgICAgIG1hbmlmb2xkLlBvaW50Q291bnQgPSAwO1xyXG5cclxuICAgICAgICAgICAgLy9Db21wdXRlQWRqYWNlbmN5KCk7IGlubGluZSBzdGFydFxyXG4gICAgICAgICAgICBWZWN0b3IyIHYwID0gX2VkZ2VBLlYwO1xyXG4gICAgICAgICAgICBWZWN0b3IyIHYxID0gX2VkZ2VBLlYxO1xyXG4gICAgICAgICAgICBWZWN0b3IyIHYyID0gX2VkZ2VBLlYyO1xyXG4gICAgICAgICAgICBWZWN0b3IyIHYzID0gX2VkZ2VBLlYzO1xyXG5cclxuICAgICAgICAgICAgLy8gRGV0ZXJtaW5lIGFsbG93YWJsZSB0aGUgbm9ybWFsIHJlZ2lvbnMgYmFzZWQgb24gYWRqYWNlbmN5LlxyXG4gICAgICAgICAgICAvLyBOb3RlOiBpdCBtYXkgYmUgcG9zc2libGUgdGhhdCBubyBub3JtYWwgaXMgYWRtaXNzYWJsZS5cclxuICAgICAgICAgICAgVmVjdG9yMiBjZW50ZXJCID0gX3Byb3h5Qi5DZW50cm9pZDtcclxuICAgICAgICAgICAgaWYgKF9lZGdlQS5IYXNWZXJ0ZXgwKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBWZWN0b3IyIGUwID0gdjEgLSB2MDtcclxuICAgICAgICAgICAgICAgIFZlY3RvcjIgZTEgPSB2MiAtIHYxO1xyXG4gICAgICAgICAgICAgICAgVmVjdG9yMiBuMCA9IG5ldyBWZWN0b3IyKGUwLlksIC1lMC5YKTtcclxuICAgICAgICAgICAgICAgIFZlY3RvcjIgbjEgPSBuZXcgVmVjdG9yMihlMS5ZLCAtZTEuWCk7XHJcbiAgICAgICAgICAgICAgICBuMC5Ob3JtYWxpemUoKTtcclxuICAgICAgICAgICAgICAgIG4xLk5vcm1hbGl6ZSgpO1xyXG5cclxuICAgICAgICAgICAgICAgIGJvb2wgY29udmV4ID0gTWF0aFV0aWxzLkNyb3NzKG4wLCBuMSkgPj0gMC4wZjtcclxuICAgICAgICAgICAgICAgIGJvb2wgZnJvbnQwID0gVmVjdG9yMi5Eb3QobjAsIGNlbnRlckIgLSB2MCkgPj0gMC4wZjtcclxuICAgICAgICAgICAgICAgIGJvb2wgZnJvbnQxID0gVmVjdG9yMi5Eb3QobjEsIGNlbnRlckIgLSB2MSkgPj0gMC4wZjtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoY29udmV4KVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChmcm9udDAgfHwgZnJvbnQxKVxyXG4gICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgX2xpbWl0MTEgPSBuMTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgX2xpbWl0MTIgPSBuMDtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgX2xpbWl0MTEgPSAtbjE7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF9saW1pdDEyID0gLW4wO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoZnJvbnQwICYmIGZyb250MSlcclxuICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF9saW1pdDExID0gbjA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF9saW1pdDEyID0gbjE7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF9saW1pdDExID0gLW4wO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBfbGltaXQxMiA9IC1uMTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBfbGltaXQxMSA9IFZlY3RvcjIuWmVybztcclxuICAgICAgICAgICAgICAgIF9saW1pdDEyID0gVmVjdG9yMi5aZXJvO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAoX2VkZ2VBLkhhc1ZlcnRleDMpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIFZlY3RvcjIgZTEgPSB2MiAtIHYxO1xyXG4gICAgICAgICAgICAgICAgVmVjdG9yMiBlMiA9IHYzIC0gdjI7XHJcbiAgICAgICAgICAgICAgICBWZWN0b3IyIG4xID0gbmV3IFZlY3RvcjIoZTEuWSwgLWUxLlgpO1xyXG4gICAgICAgICAgICAgICAgVmVjdG9yMiBuMiA9IG5ldyBWZWN0b3IyKGUyLlksIC1lMi5YKTtcclxuICAgICAgICAgICAgICAgIG4xLk5vcm1hbGl6ZSgpO1xyXG4gICAgICAgICAgICAgICAgbjIuTm9ybWFsaXplKCk7XHJcblxyXG4gICAgICAgICAgICAgICAgYm9vbCBjb252ZXggPSBNYXRoVXRpbHMuQ3Jvc3MobjEsIG4yKSA+PSAwLjBmO1xyXG4gICAgICAgICAgICAgICAgYm9vbCBmcm9udDEgPSBWZWN0b3IyLkRvdChuMSwgY2VudGVyQiAtIHYxKSA+PSAwLjBmO1xyXG4gICAgICAgICAgICAgICAgYm9vbCBmcm9udDIgPSBWZWN0b3IyLkRvdChuMiwgY2VudGVyQiAtIHYyKSA+PSAwLjBmO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmIChjb252ZXgpXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGZyb250MSB8fCBmcm9udDIpXHJcbiAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBfbGltaXQyMSA9IG4yO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBfbGltaXQyMiA9IG4xO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBfbGltaXQyMSA9IC1uMjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgX2xpbWl0MjIgPSAtbjE7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChmcm9udDEgJiYgZnJvbnQyKVxyXG4gICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgX2xpbWl0MjEgPSBuMTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgX2xpbWl0MjIgPSBuMjtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgX2xpbWl0MjEgPSAtbjE7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF9saW1pdDIyID0gLW4yO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIF9saW1pdDIxID0gVmVjdG9yMi5aZXJvO1xyXG4gICAgICAgICAgICAgICAgX2xpbWl0MjIgPSBWZWN0b3IyLlplcm87XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vQ29tcHV0ZUFkamFjZW5jeSgpOyBpbmxpbmUgZW5kXHJcblxyXG4gICAgICAgICAgICAvL0VQQXhpcyBlZGdlQXhpcyA9IENvbXB1dGVFZGdlU2VwYXJhdGlvbigpOyBpbmxpbmUgc3RhcnRcclxuICAgICAgICAgICAgRVBBeGlzIGVkZ2VBeGlzID0gQ29tcHV0ZUVkZ2VTZXBhcmF0aW9uKCk7XHJcblxyXG4gICAgICAgICAgICAvLyBJZiBubyB2YWxpZCBub3JtYWwgY2FuIGJlIGZvdW5kIHRoYW4gdGhpcyBlZGdlIHNob3VsZCBub3QgY29sbGlkZS5cclxuICAgICAgICAgICAgLy8gVGhpcyBjYW4gaGFwcGVuIG9uIHRoZSBtaWRkbGUgZWRnZSBvZiBhIDMtZWRnZSB6aWctemFnIGNoYWluLlxyXG4gICAgICAgICAgICBpZiAoZWRnZUF4aXMuVHlwZSA9PSBFUEF4aXNUeXBlLlVua25vd24pXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKGVkZ2VBeGlzLlNlcGFyYXRpb24gPiBfcmFkaXVzKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIEVQQXhpcyBwb2x5Z29uQXhpcyA9IENvbXB1dGVQb2x5Z29uU2VwYXJhdGlvbigpO1xyXG4gICAgICAgICAgICBpZiAocG9seWdvbkF4aXMuVHlwZSAhPSBFUEF4aXNUeXBlLlVua25vd24gJiYgcG9seWdvbkF4aXMuU2VwYXJhdGlvbiA+IF9yYWRpdXMpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gVXNlIGh5c3RlcmVzaXMgZm9yIGppdHRlciByZWR1Y3Rpb24uXHJcbiAgICAgICAgICAgIGNvbnN0IGZsb2F0IGtfcmVsYXRpdmVUb2wgPSAwLjk4ZjtcclxuICAgICAgICAgICAgY29uc3QgZmxvYXQga19hYnNvbHV0ZVRvbCA9IDAuMDAxZjtcclxuXHJcbiAgICAgICAgICAgIEVQQXhpcyBwcmltYXJ5QXhpcztcclxuICAgICAgICAgICAgaWYgKHBvbHlnb25BeGlzLlR5cGUgPT0gRVBBeGlzVHlwZS5Vbmtub3duKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBwcmltYXJ5QXhpcyA9IGVkZ2VBeGlzO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKHBvbHlnb25BeGlzLlNlcGFyYXRpb24gPiBrX3JlbGF0aXZlVG9sICogZWRnZUF4aXMuU2VwYXJhdGlvbiArIGtfYWJzb2x1dGVUb2wpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHByaW1hcnlBeGlzID0gcG9seWdvbkF4aXM7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBwcmltYXJ5QXhpcyA9IGVkZ2VBeGlzO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBFUFByb3h5IHByb3h5MTtcclxuICAgICAgICAgICAgRVBQcm94eSBwcm94eTI7XHJcbiAgICAgICAgICAgIEZpeGVkQXJyYXkyPENsaXBWZXJ0ZXg+IGluY2lkZW50RWRnZSA9IG5ldyBGaXhlZEFycmF5MjxDbGlwVmVydGV4PigpO1xyXG4gICAgICAgICAgICBpZiAocHJpbWFyeUF4aXMuVHlwZSA9PSBFUEF4aXNUeXBlLkVkZ2VBKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBwcm94eTEgPSBfcHJveHlBO1xyXG4gICAgICAgICAgICAgICAgcHJveHkyID0gX3Byb3h5QjtcclxuICAgICAgICAgICAgICAgIG1hbmlmb2xkLlR5cGUgPSBNYW5pZm9sZFR5cGUuRmFjZUE7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBwcm94eTEgPSBfcHJveHlCO1xyXG4gICAgICAgICAgICAgICAgcHJveHkyID0gX3Byb3h5QTtcclxuICAgICAgICAgICAgICAgIG1hbmlmb2xkLlR5cGUgPSBNYW5pZm9sZFR5cGUuRmFjZUI7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGludCBlZGdlMSA9IHByaW1hcnlBeGlzLkluZGV4O1xyXG5cclxuICAgICAgICAgICAgRmluZEluY2lkZW50RWRnZShyZWYgaW5jaWRlbnRFZGdlLCBwcm94eTEsIHByaW1hcnlBeGlzLkluZGV4LCBwcm94eTIpO1xyXG4gICAgICAgICAgICBpbnQgY291bnQxID0gcHJveHkxLkNvdW50O1xyXG5cclxuICAgICAgICAgICAgaW50IGl2MSA9IGVkZ2UxO1xyXG4gICAgICAgICAgICBpbnQgaXYyID0gZWRnZTEgKyAxIDwgY291bnQxID8gZWRnZTEgKyAxIDogMDtcclxuXHJcbiAgICAgICAgICAgIFZlY3RvcjIgdjExID0gcHJveHkxLlZlcnRpY2VzW2l2MV07XHJcbiAgICAgICAgICAgIFZlY3RvcjIgdjEyID0gcHJveHkxLlZlcnRpY2VzW2l2Ml07XHJcblxyXG4gICAgICAgICAgICBWZWN0b3IyIHRhbmdlbnQgPSB2MTIgLSB2MTE7XHJcbiAgICAgICAgICAgIHRhbmdlbnQuTm9ybWFsaXplKCk7XHJcblxyXG4gICAgICAgICAgICBWZWN0b3IyIG5vcm1hbCA9IE1hdGhVdGlscy5Dcm9zcyh0YW5nZW50LCAxLjBmKTtcclxuICAgICAgICAgICAgVmVjdG9yMiBwbGFuZVBvaW50ID0gMC41ZiAqICh2MTEgKyB2MTIpO1xyXG5cclxuICAgICAgICAgICAgLy8gRmFjZSBvZmZzZXQuXHJcbiAgICAgICAgICAgIGZsb2F0IGZyb250T2Zmc2V0ID0gVmVjdG9yMi5Eb3Qobm9ybWFsLCB2MTEpO1xyXG5cclxuICAgICAgICAgICAgLy8gU2lkZSBvZmZzZXRzLCBleHRlbmRlZCBieSBwb2x5dG9wZSBza2luIHRoaWNrbmVzcy5cclxuICAgICAgICAgICAgZmxvYXQgc2lkZU9mZnNldDEgPSAtVmVjdG9yMi5Eb3QodGFuZ2VudCwgdjExKSArIF9yYWRpdXM7XHJcbiAgICAgICAgICAgIGZsb2F0IHNpZGVPZmZzZXQyID0gVmVjdG9yMi5Eb3QodGFuZ2VudCwgdjEyKSArIF9yYWRpdXM7XHJcblxyXG4gICAgICAgICAgICAvLyBDbGlwIGluY2lkZW50IGVkZ2UgYWdhaW5zdCBleHRydWRlZCBlZGdlMSBzaWRlIGVkZ2VzLlxyXG4gICAgICAgICAgICBGaXhlZEFycmF5MjxDbGlwVmVydGV4PiBjbGlwUG9pbnRzMTtcclxuICAgICAgICAgICAgRml4ZWRBcnJheTI8Q2xpcFZlcnRleD4gY2xpcFBvaW50czI7XHJcbiAgICAgICAgICAgIGludCBucDtcclxuXHJcbiAgICAgICAgICAgIC8vIENsaXAgdG8gYm94IHNpZGUgMVxyXG4gICAgICAgICAgICBucCA9IENsaXBTZWdtZW50VG9MaW5lKG91dCBjbGlwUG9pbnRzMSwgcmVmIGluY2lkZW50RWRnZSwgLXRhbmdlbnQsIHNpZGVPZmZzZXQxLCBpdjEpO1xyXG5cclxuICAgICAgICAgICAgaWYgKG5wIDwgU2V0dGluZ3MuTWF4TWFuaWZvbGRQb2ludHMpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gQ2xpcCB0byBuZWdhdGl2ZSBib3ggc2lkZSAxXHJcbiAgICAgICAgICAgIG5wID0gQ2xpcFNlZ21lbnRUb0xpbmUob3V0IGNsaXBQb2ludHMyLCByZWYgY2xpcFBvaW50czEsIHRhbmdlbnQsIHNpZGVPZmZzZXQyLCBpdjIpO1xyXG5cclxuICAgICAgICAgICAgaWYgKG5wIDwgU2V0dGluZ3MuTWF4TWFuaWZvbGRQb2ludHMpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gTm93IGNsaXBQb2ludHMyIGNvbnRhaW5zIHRoZSBjbGlwcGVkIHBvaW50cy5cclxuICAgICAgICAgICAgaWYgKHByaW1hcnlBeGlzLlR5cGUgPT0gRVBBeGlzVHlwZS5FZGdlQSlcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgbWFuaWZvbGQuTG9jYWxOb3JtYWwgPSBub3JtYWw7XHJcbiAgICAgICAgICAgICAgICBtYW5pZm9sZC5Mb2NhbFBvaW50ID0gcGxhbmVQb2ludDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIG1hbmlmb2xkLkxvY2FsTm9ybWFsID0gTWF0aFV0aWxzLk11bHRpcGx5VChyZWYgX3hmLlIsIHJlZiBub3JtYWwpO1xyXG4gICAgICAgICAgICAgICAgbWFuaWZvbGQuTG9jYWxQb2ludCA9IE1hdGhVdGlscy5NdWx0aXBseVQocmVmIF94ZiwgcmVmIHBsYW5lUG9pbnQpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpbnQgcG9pbnRDb3VudCA9IDA7XHJcbiAgICAgICAgICAgIGZvciAoaW50IGkxID0gMDsgaTEgPCBTZXR0aW5ncy5NYXhNYW5pZm9sZFBvaW50czsgKytpMSlcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgZmxvYXQgc2VwYXJhdGlvbiA9IFZlY3RvcjIuRG90KG5vcm1hbCwgY2xpcFBvaW50czJbaTFdLlYpIC0gZnJvbnRPZmZzZXQ7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKHNlcGFyYXRpb24gPD0gX3JhZGl1cylcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBNYW5pZm9sZFBvaW50IGNwID0gbWFuaWZvbGQuUG9pbnRzW3BvaW50Q291bnRdO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZiAocHJpbWFyeUF4aXMuVHlwZSA9PSBFUEF4aXNUeXBlLkVkZ2VBKVxyXG4gICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY3AuTG9jYWxQb2ludCA9IE1hdGhVdGlscy5NdWx0aXBseVQocmVmIF94ZiwgY2xpcFBvaW50czJbaTFdLlYpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjcC5JZCA9IGNsaXBQb2ludHMyW2kxXS5JRDtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY3AuTG9jYWxQb2ludCA9IGNsaXBQb2ludHMyW2kxXS5WO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjcC5JZC5GZWF0dXJlcy5UeXBlQSA9IGNsaXBQb2ludHMyW2kxXS5JRC5GZWF0dXJlcy5UeXBlQjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY3AuSWQuRmVhdHVyZXMuVHlwZUIgPSBjbGlwUG9pbnRzMltpMV0uSUQuRmVhdHVyZXMuVHlwZUE7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNwLklkLkZlYXR1cmVzLkluZGV4QSA9IGNsaXBQb2ludHMyW2kxXS5JRC5GZWF0dXJlcy5JbmRleEI7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNwLklkLkZlYXR1cmVzLkluZGV4QiA9IGNsaXBQb2ludHMyW2kxXS5JRC5GZWF0dXJlcy5JbmRleEE7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICBtYW5pZm9sZC5Qb2ludHNbcG9pbnRDb3VudF0gPSBjcDtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgKytwb2ludENvdW50O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBtYW5pZm9sZC5Qb2ludENvdW50ID0gcG9pbnRDb3VudDtcclxuXHJcbiAgICAgICAgICAgIC8vQ29sbGlkZShyZWYgbWFuaWZvbGQpOyBpbmxpbmUgZW5kXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwcml2YXRlIHN0YXRpYyBFUEF4aXMgQ29tcHV0ZUVkZ2VTZXBhcmF0aW9uKClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIC8vIEVkZ2VBIHNlcGFyYXRpb25cclxuICAgICAgICAgICAgRVBBeGlzIGJlc3RBeGlzO1xyXG4gICAgICAgICAgICBiZXN0QXhpcy5UeXBlID0gRVBBeGlzVHlwZS5Vbmtub3duO1xyXG4gICAgICAgICAgICBiZXN0QXhpcy5JbmRleCA9IC0xO1xyXG4gICAgICAgICAgICBiZXN0QXhpcy5TZXBhcmF0aW9uID0gLVNldHRpbmdzLk1heEZsb2F0O1xyXG4gICAgICAgICAgICBfdG1wTm9ybWFsc1swXSA9IF9lZGdlQS5Ob3JtYWw7XHJcbiAgICAgICAgICAgIF90bXBOb3JtYWxzWzFdID0gLV9lZGdlQS5Ob3JtYWw7XHJcblxyXG4gICAgICAgICAgICBmb3IgKGludCBpID0gMDsgaSA8IDI7ICsraSlcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgVmVjdG9yMiBuID0gX3RtcE5vcm1hbHNbaV07XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gQWRqYWNlbmN5XHJcbiAgICAgICAgICAgICAgICBib29sIHZhbGlkMSA9IE1hdGhVdGlscy5Dcm9zcyhuLCBfbGltaXQxMSkgPj0gLVNldHRpbmdzLkFuZ3VsYXJTbG9wICYmXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE1hdGhVdGlscy5Dcm9zcyhfbGltaXQxMiwgbikgPj0gLVNldHRpbmdzLkFuZ3VsYXJTbG9wO1xyXG4gICAgICAgICAgICAgICAgYm9vbCB2YWxpZDIgPSBNYXRoVXRpbHMuQ3Jvc3MobiwgX2xpbWl0MjEpID49IC1TZXR0aW5ncy5Bbmd1bGFyU2xvcCAmJlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBNYXRoVXRpbHMuQ3Jvc3MoX2xpbWl0MjIsIG4pID49IC1TZXR0aW5ncy5Bbmd1bGFyU2xvcDtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAodmFsaWQxID09IGZhbHNlIHx8IHZhbGlkMiA9PSBmYWxzZSlcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBFUEF4aXMgYXhpcztcclxuICAgICAgICAgICAgICAgIGF4aXMuVHlwZSA9IEVQQXhpc1R5cGUuRWRnZUE7XHJcbiAgICAgICAgICAgICAgICBheGlzLkluZGV4ID0gaTtcclxuICAgICAgICAgICAgICAgIGF4aXMuU2VwYXJhdGlvbiA9IFNldHRpbmdzLk1heEZsb2F0O1xyXG5cclxuICAgICAgICAgICAgICAgIGZvciAoaW50IGogPSAwOyBqIDwgX3Byb3h5Qi5Db3VudDsgKytqKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIGZsb2F0IHMgPSBWZWN0b3IyLkRvdChuLCBfcHJveHlCLlZlcnRpY2VzW2pdIC0gX2VkZ2VBLlYxKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAocyA8IGF4aXMuU2VwYXJhdGlvbilcclxuICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGF4aXMuU2VwYXJhdGlvbiA9IHM7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGlmIChheGlzLlNlcGFyYXRpb24gPiBfcmFkaXVzKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBheGlzO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGlmIChheGlzLlNlcGFyYXRpb24gPiBiZXN0QXhpcy5TZXBhcmF0aW9uKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIGJlc3RBeGlzID0gYXhpcztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuIGJlc3RBeGlzO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHJpdmF0ZSBzdGF0aWMgRVBBeGlzIENvbXB1dGVQb2x5Z29uU2VwYXJhdGlvbigpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBFUEF4aXMgYXhpcztcclxuICAgICAgICAgICAgYXhpcy5UeXBlID0gRVBBeGlzVHlwZS5Vbmtub3duO1xyXG4gICAgICAgICAgICBheGlzLkluZGV4ID0gLTE7XHJcbiAgICAgICAgICAgIGF4aXMuU2VwYXJhdGlvbiA9IC1TZXR0aW5ncy5NYXhGbG9hdDtcclxuICAgICAgICAgICAgZm9yIChpbnQgaSA9IDA7IGkgPCBfcHJveHlCLkNvdW50OyArK2kpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIFZlY3RvcjIgbiA9IC1fcHJveHlCLk5vcm1hbHNbaV07XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gQWRqYWNlbmN5XHJcbiAgICAgICAgICAgICAgICBib29sIHZhbGlkMSA9IE1hdGhVdGlscy5Dcm9zcyhuLCBfbGltaXQxMSkgPj0gLVNldHRpbmdzLkFuZ3VsYXJTbG9wICYmXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE1hdGhVdGlscy5Dcm9zcyhfbGltaXQxMiwgbikgPj0gLVNldHRpbmdzLkFuZ3VsYXJTbG9wO1xyXG4gICAgICAgICAgICAgICAgYm9vbCB2YWxpZDIgPSBNYXRoVXRpbHMuQ3Jvc3MobiwgX2xpbWl0MjEpID49IC1TZXR0aW5ncy5Bbmd1bGFyU2xvcCAmJlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBNYXRoVXRpbHMuQ3Jvc3MoX2xpbWl0MjIsIG4pID49IC1TZXR0aW5ncy5Bbmd1bGFyU2xvcDtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAodmFsaWQxID09IGZhbHNlICYmIHZhbGlkMiA9PSBmYWxzZSlcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBmbG9hdCBzMSA9IFZlY3RvcjIuRG90KG4sIF9wcm94eUIuVmVydGljZXNbaV0gLSBfZWRnZUEuVjEpO1xyXG4gICAgICAgICAgICAgICAgZmxvYXQgczIgPSBWZWN0b3IyLkRvdChuLCBfcHJveHlCLlZlcnRpY2VzW2ldIC0gX2VkZ2VBLlYyKTtcclxuICAgICAgICAgICAgICAgIGZsb2F0IHMgPSBNYXRoLk1pbihzMSwgczIpO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmIChzID4gX3JhZGl1cylcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBheGlzLlR5cGUgPSBFUEF4aXNUeXBlLkVkZ2VCO1xyXG4gICAgICAgICAgICAgICAgICAgIGF4aXMuSW5kZXggPSBpO1xyXG4gICAgICAgICAgICAgICAgICAgIGF4aXMuU2VwYXJhdGlvbiA9IHM7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKHMgPiBheGlzLlNlcGFyYXRpb24pXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgYXhpcy5UeXBlID0gRVBBeGlzVHlwZS5FZGdlQjtcclxuICAgICAgICAgICAgICAgICAgICBheGlzLkluZGV4ID0gaTtcclxuICAgICAgICAgICAgICAgICAgICBheGlzLlNlcGFyYXRpb24gPSBzO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gYXhpcztcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHByaXZhdGUgc3RhdGljIHZvaWQgRmluZEluY2lkZW50RWRnZShyZWYgRml4ZWRBcnJheTI8Q2xpcFZlcnRleD4gYywgRVBQcm94eSBwcm94eTEsIGludCBlZGdlMSwgRVBQcm94eSBwcm94eTIpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBpbnQgY291bnQyID0gcHJveHkyLkNvdW50O1xyXG5cclxuICAgICAgICAgICAgRGVidWcuQXNzZXJ0KDAgPD0gZWRnZTEgJiYgZWRnZTEgPCBwcm94eTEuQ291bnQpO1xyXG5cclxuICAgICAgICAgICAgLy8gR2V0IHRoZSBub3JtYWwgb2YgdGhlIHJlZmVyZW5jZSBlZGdlIGluIHByb3h5MidzIGZyYW1lLlxyXG4gICAgICAgICAgICBWZWN0b3IyIG5vcm1hbDEgPSBwcm94eTEuTm9ybWFsc1tlZGdlMV07XHJcblxyXG4gICAgICAgICAgICAvLyBGaW5kIHRoZSBpbmNpZGVudCBlZGdlIG9uIHByb3h5Mi5cclxuICAgICAgICAgICAgaW50IGluZGV4ID0gMDtcclxuICAgICAgICAgICAgZmxvYXQgbWluRG90ID0gZmxvYXQuTWF4VmFsdWU7XHJcbiAgICAgICAgICAgIGZvciAoaW50IGkgPSAwOyBpIDwgY291bnQyOyArK2kpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGZsb2F0IGRvdCA9IFZlY3RvcjIuRG90KG5vcm1hbDEsIHByb3h5Mi5Ob3JtYWxzW2ldKTtcclxuICAgICAgICAgICAgICAgIGlmIChkb3QgPCBtaW5Eb3QpXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgbWluRG90ID0gZG90O1xyXG4gICAgICAgICAgICAgICAgICAgIGluZGV4ID0gaTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gQnVpbGQgdGhlIGNsaXAgdmVydGljZXMgZm9yIHRoZSBpbmNpZGVudCBlZGdlLlxyXG4gICAgICAgICAgICBpbnQgaTEgPSBpbmRleDtcclxuICAgICAgICAgICAgaW50IGkyID0gaTEgKyAxIDwgY291bnQyID8gaTEgKyAxIDogMDtcclxuXHJcbiAgICAgICAgICAgIENsaXBWZXJ0ZXggY1RlbXAgPSBuZXcgQ2xpcFZlcnRleCgpO1xyXG4gICAgICAgICAgICBjVGVtcC5WID0gcHJveHkyLlZlcnRpY2VzW2kxXTtcclxuICAgICAgICAgICAgY1RlbXAuSUQuRmVhdHVyZXMuSW5kZXhBID0gKGJ5dGUpZWRnZTE7XHJcbiAgICAgICAgICAgIGNUZW1wLklELkZlYXR1cmVzLkluZGV4QiA9IChieXRlKWkxO1xyXG4gICAgICAgICAgICBjVGVtcC5JRC5GZWF0dXJlcy5UeXBlQSA9IChieXRlKUNvbnRhY3RGZWF0dXJlVHlwZS5GYWNlO1xyXG4gICAgICAgICAgICBjVGVtcC5JRC5GZWF0dXJlcy5UeXBlQiA9IChieXRlKUNvbnRhY3RGZWF0dXJlVHlwZS5WZXJ0ZXg7XHJcbiAgICAgICAgICAgIGNbMF0gPSBjVGVtcDtcclxuXHJcbiAgICAgICAgICAgIGNUZW1wLlYgPSBwcm94eTIuVmVydGljZXNbaTJdO1xyXG4gICAgICAgICAgICBjVGVtcC5JRC5GZWF0dXJlcy5JbmRleEEgPSAoYnl0ZSllZGdlMTtcclxuICAgICAgICAgICAgY1RlbXAuSUQuRmVhdHVyZXMuSW5kZXhCID0gKGJ5dGUpaTI7XHJcbiAgICAgICAgICAgIGNUZW1wLklELkZlYXR1cmVzLlR5cGVBID0gKGJ5dGUpQ29udGFjdEZlYXR1cmVUeXBlLkZhY2U7XHJcbiAgICAgICAgICAgIGNUZW1wLklELkZlYXR1cmVzLlR5cGVCID0gKGJ5dGUpQ29udGFjdEZlYXR1cmVUeXBlLlZlcnRleDtcclxuICAgICAgICAgICAgY1sxXSA9IGNUZW1wO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBDbGlwcGluZyBmb3IgY29udGFjdCBtYW5pZm9sZHMuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJ2T3V0XCI+VGhlIHYgb3V0LjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwidkluXCI+VGhlIHYgaW4uPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJub3JtYWxcIj5UaGUgbm9ybWFsLjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwib2Zmc2V0XCI+VGhlIG9mZnNldC48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cInZlcnRleEluZGV4QVwiPlRoZSB2ZXJ0ZXggaW5kZXggQS48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cmV0dXJucz48L3JldHVybnM+XHJcbiAgICAgICAgcHJpdmF0ZSBzdGF0aWMgaW50IENsaXBTZWdtZW50VG9MaW5lKG91dCBGaXhlZEFycmF5MjxDbGlwVmVydGV4PiB2T3V0LCByZWYgRml4ZWRBcnJheTI8Q2xpcFZlcnRleD4gdkluLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBWZWN0b3IyIG5vcm1hbCwgZmxvYXQgb2Zmc2V0LCBpbnQgdmVydGV4SW5kZXhBKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdk91dCA9IG5ldyBGaXhlZEFycmF5MjxDbGlwVmVydGV4PigpO1xyXG5cclxuICAgICAgICAgICAgQ2xpcFZlcnRleCB2MCA9IHZJblswXTtcclxuICAgICAgICAgICAgQ2xpcFZlcnRleCB2MSA9IHZJblsxXTtcclxuXHJcbiAgICAgICAgICAgIC8vIFN0YXJ0IHdpdGggbm8gb3V0cHV0IHBvaW50c1xyXG4gICAgICAgICAgICBpbnQgbnVtT3V0ID0gMDtcclxuXHJcbiAgICAgICAgICAgIC8vIENhbGN1bGF0ZSB0aGUgZGlzdGFuY2Ugb2YgZW5kIHBvaW50cyB0byB0aGUgbGluZVxyXG4gICAgICAgICAgICBmbG9hdCBkaXN0YW5jZTAgPSBub3JtYWwuWCAqIHYwLlYuWCArIG5vcm1hbC5ZICogdjAuVi5ZIC0gb2Zmc2V0O1xyXG4gICAgICAgICAgICBmbG9hdCBkaXN0YW5jZTEgPSBub3JtYWwuWCAqIHYxLlYuWCArIG5vcm1hbC5ZICogdjEuVi5ZIC0gb2Zmc2V0O1xyXG5cclxuICAgICAgICAgICAgLy8gSWYgdGhlIHBvaW50cyBhcmUgYmVoaW5kIHRoZSBwbGFuZVxyXG4gICAgICAgICAgICBpZiAoZGlzdGFuY2UwIDw9IDAuMGYpIHZPdXRbbnVtT3V0KytdID0gdjA7XHJcbiAgICAgICAgICAgIGlmIChkaXN0YW5jZTEgPD0gMC4wZikgdk91dFtudW1PdXQrK10gPSB2MTtcclxuXHJcbiAgICAgICAgICAgIC8vIElmIHRoZSBwb2ludHMgYXJlIG9uIGRpZmZlcmVudCBzaWRlcyBvZiB0aGUgcGxhbmVcclxuICAgICAgICAgICAgaWYgKGRpc3RhbmNlMCAqIGRpc3RhbmNlMSA8IDAuMGYpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIC8vIEZpbmQgaW50ZXJzZWN0aW9uIHBvaW50IG9mIGVkZ2UgYW5kIHBsYW5lXHJcbiAgICAgICAgICAgICAgICBmbG9hdCBpbnRlcnAgPSBkaXN0YW5jZTAgLyAoZGlzdGFuY2UwIC0gZGlzdGFuY2UxKTtcclxuXHJcbiAgICAgICAgICAgICAgICBDbGlwVmVydGV4IGN2ID0gdk91dFtudW1PdXRdO1xyXG5cclxuICAgICAgICAgICAgICAgIGN2LlYuWCA9IHYwLlYuWCArIGludGVycCAqICh2MS5WLlggLSB2MC5WLlgpO1xyXG4gICAgICAgICAgICAgICAgY3YuVi5ZID0gdjAuVi5ZICsgaW50ZXJwICogKHYxLlYuWSAtIHYwLlYuWSk7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gVmVydGV4QSBpcyBoaXR0aW5nIGVkZ2VCLlxyXG4gICAgICAgICAgICAgICAgY3YuSUQuRmVhdHVyZXMuSW5kZXhBID0gKGJ5dGUpdmVydGV4SW5kZXhBO1xyXG4gICAgICAgICAgICAgICAgY3YuSUQuRmVhdHVyZXMuSW5kZXhCID0gdjAuSUQuRmVhdHVyZXMuSW5kZXhCO1xyXG4gICAgICAgICAgICAgICAgY3YuSUQuRmVhdHVyZXMuVHlwZUEgPSAoYnl0ZSlDb250YWN0RmVhdHVyZVR5cGUuVmVydGV4O1xyXG4gICAgICAgICAgICAgICAgY3YuSUQuRmVhdHVyZXMuVHlwZUIgPSAoYnl0ZSlDb250YWN0RmVhdHVyZVR5cGUuRmFjZTtcclxuXHJcbiAgICAgICAgICAgICAgICB2T3V0W251bU91dF0gPSBjdjtcclxuXHJcbiAgICAgICAgICAgICAgICArK251bU91dDtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuIG51bU91dDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gRmluZCB0aGUgc2VwYXJhdGlvbiBiZXR3ZWVuIHBvbHkxIGFuZCBwb2x5MiBmb3IgYSBnaXZlIGVkZ2Ugbm9ybWFsIG9uIHBvbHkxLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwicG9seTFcIj5UaGUgcG9seTEuPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJ4ZjFcIj5UaGUgWEYxLjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwiZWRnZTFcIj5UaGUgZWRnZTEuPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJwb2x5MlwiPlRoZSBwb2x5Mi48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cInhmMlwiPlRoZSBYRjIuPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHJldHVybnM+PC9yZXR1cm5zPlxyXG4gICAgICAgIHByaXZhdGUgc3RhdGljIGZsb2F0IEVkZ2VTZXBhcmF0aW9uKFBvbHlnb25TaGFwZSBwb2x5MSwgcmVmIFRyYW5zZm9ybSB4ZjEsIGludCBlZGdlMSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBQb2x5Z29uU2hhcGUgcG9seTIsIHJlZiBUcmFuc2Zvcm0geGYyKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgaW50IGNvdW50MiA9IHBvbHkyLlZlcnRpY2VzLkNvdW50O1xyXG5cclxuICAgICAgICAgICAgRGVidWcuQXNzZXJ0KDAgPD0gZWRnZTEgJiYgZWRnZTEgPCBwb2x5MS5WZXJ0aWNlcy5Db3VudCk7XHJcblxyXG4gICAgICAgICAgICAvLyBDb252ZXJ0IG5vcm1hbCBmcm9tIHBvbHkxJ3MgZnJhbWUgaW50byBwb2x5MidzIGZyYW1lLlxyXG4gICAgICAgICAgICBWZWN0b3IyIHAxbiA9IHBvbHkxLk5vcm1hbHNbZWRnZTFdO1xyXG5cclxuICAgICAgICAgICAgZmxvYXQgbm9ybWFsV29ybGR4ID0geGYxLlIuQ29sMS5YICogcDFuLlggKyB4ZjEuUi5Db2wyLlggKiBwMW4uWTtcclxuICAgICAgICAgICAgZmxvYXQgbm9ybWFsV29ybGR5ID0geGYxLlIuQ29sMS5ZICogcDFuLlggKyB4ZjEuUi5Db2wyLlkgKiBwMW4uWTtcclxuXHJcbiAgICAgICAgICAgIFZlY3RvcjIgbm9ybWFsID0gbmV3IFZlY3RvcjIobm9ybWFsV29ybGR4ICogeGYyLlIuQ29sMS5YICsgbm9ybWFsV29ybGR5ICogeGYyLlIuQ29sMS5ZLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vcm1hbFdvcmxkeCAqIHhmMi5SLkNvbDIuWCArIG5vcm1hbFdvcmxkeSAqIHhmMi5SLkNvbDIuWSk7XHJcblxyXG4gICAgICAgICAgICAvLyBGaW5kIHN1cHBvcnQgdmVydGV4IG9uIHBvbHkyIGZvciAtbm9ybWFsLlxyXG4gICAgICAgICAgICBpbnQgaW5kZXggPSAwO1xyXG4gICAgICAgICAgICBmbG9hdCBtaW5Eb3QgPSBTZXR0aW5ncy5NYXhGbG9hdDtcclxuXHJcbiAgICAgICAgICAgIGZvciAoaW50IGkgPSAwOyBpIDwgY291bnQyOyArK2kpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGZsb2F0IGRvdCA9IFZlY3RvcjIuRG90KHBvbHkyLlZlcnRpY2VzW2ldLCBub3JtYWwpO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmIChkb3QgPCBtaW5Eb3QpXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgbWluRG90ID0gZG90O1xyXG4gICAgICAgICAgICAgICAgICAgIGluZGV4ID0gaTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgVmVjdG9yMiBwMXZlID0gcG9seTEuVmVydGljZXNbZWRnZTFdO1xyXG4gICAgICAgICAgICBWZWN0b3IyIHAydmkgPSBwb2x5Mi5WZXJ0aWNlc1tpbmRleF07XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gKCh4ZjIuUG9zaXRpb24uWCArIHhmMi5SLkNvbDEuWCAqIHAydmkuWCArIHhmMi5SLkNvbDIuWCAqIHAydmkuWSkgLVxyXG4gICAgICAgICAgICAgICAgICAgICh4ZjEuUG9zaXRpb24uWCArIHhmMS5SLkNvbDEuWCAqIHAxdmUuWCArIHhmMS5SLkNvbDIuWCAqIHAxdmUuWSkpICogbm9ybWFsV29ybGR4ICtcclxuICAgICAgICAgICAgICAgICAgICgoeGYyLlBvc2l0aW9uLlkgKyB4ZjIuUi5Db2wxLlkgKiBwMnZpLlggKyB4ZjIuUi5Db2wyLlkgKiBwMnZpLlkpIC1cclxuICAgICAgICAgICAgICAgICAgICAoeGYxLlBvc2l0aW9uLlkgKyB4ZjEuUi5Db2wxLlkgKiBwMXZlLlggKyB4ZjEuUi5Db2wyLlkgKiBwMXZlLlkpKSAqIG5vcm1hbFdvcmxkeTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gRmluZCB0aGUgbWF4IHNlcGFyYXRpb24gYmV0d2VlbiBwb2x5MSBhbmQgcG9seTIgdXNpbmcgZWRnZSBub3JtYWxzIGZyb20gcG9seTEuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJlZGdlSW5kZXhcIj5JbmRleCBvZiB0aGUgZWRnZS48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cInBvbHkxXCI+VGhlIHBvbHkxLjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwieGYxXCI+VGhlIFhGMS48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cInBvbHkyXCI+VGhlIHBvbHkyLjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwieGYyXCI+VGhlIFhGMi48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cmV0dXJucz48L3JldHVybnM+XHJcbiAgICAgICAgcHJpdmF0ZSBzdGF0aWMgZmxvYXQgRmluZE1heFNlcGFyYXRpb24ob3V0IGludCBlZGdlSW5kZXgsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgUG9seWdvblNoYXBlIHBvbHkxLCByZWYgVHJhbnNmb3JtIHhmMSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBQb2x5Z29uU2hhcGUgcG9seTIsIHJlZiBUcmFuc2Zvcm0geGYyKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgaW50IGNvdW50MSA9IHBvbHkxLlZlcnRpY2VzLkNvdW50O1xyXG5cclxuICAgICAgICAgICAgLy8gVmVjdG9yIHBvaW50aW5nIGZyb20gdGhlIGNlbnRyb2lkIG9mIHBvbHkxIHRvIHRoZSBjZW50cm9pZCBvZiBwb2x5Mi5cclxuICAgICAgICAgICAgZmxvYXQgZHggPSAoeGYyLlBvc2l0aW9uLlggKyB4ZjIuUi5Db2wxLlggKiBwb2x5Mi5NYXNzRGF0YS5DZW50cm9pZC5YICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgeGYyLlIuQ29sMi5YICogcG9seTIuTWFzc0RhdGEuQ2VudHJvaWQuWSkgLVxyXG4gICAgICAgICAgICAgICAgICAgICAgICh4ZjEuUG9zaXRpb24uWCArIHhmMS5SLkNvbDEuWCAqIHBvbHkxLk1hc3NEYXRhLkNlbnRyb2lkLlggK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB4ZjEuUi5Db2wyLlggKiBwb2x5MS5NYXNzRGF0YS5DZW50cm9pZC5ZKTtcclxuICAgICAgICAgICAgZmxvYXQgZHkgPSAoeGYyLlBvc2l0aW9uLlkgKyB4ZjIuUi5Db2wxLlkgKiBwb2x5Mi5NYXNzRGF0YS5DZW50cm9pZC5YICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgeGYyLlIuQ29sMi5ZICogcG9seTIuTWFzc0RhdGEuQ2VudHJvaWQuWSkgLVxyXG4gICAgICAgICAgICAgICAgICAgICAgICh4ZjEuUG9zaXRpb24uWSArIHhmMS5SLkNvbDEuWSAqIHBvbHkxLk1hc3NEYXRhLkNlbnRyb2lkLlggK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB4ZjEuUi5Db2wyLlkgKiBwb2x5MS5NYXNzRGF0YS5DZW50cm9pZC5ZKTtcclxuICAgICAgICAgICAgVmVjdG9yMiBkTG9jYWwxID0gbmV3IFZlY3RvcjIoZHggKiB4ZjEuUi5Db2wxLlggKyBkeSAqIHhmMS5SLkNvbDEuWSwgZHggKiB4ZjEuUi5Db2wyLlggKyBkeSAqIHhmMS5SLkNvbDIuWSk7XHJcblxyXG4gICAgICAgICAgICAvLyBGaW5kIGVkZ2Ugbm9ybWFsIG9uIHBvbHkxIHRoYXQgaGFzIHRoZSBsYXJnZXN0IHByb2plY3Rpb24gb250byBkLlxyXG4gICAgICAgICAgICBpbnQgZWRnZSA9IDA7XHJcbiAgICAgICAgICAgIGZsb2F0IG1heERvdCA9IC1TZXR0aW5ncy5NYXhGbG9hdDtcclxuICAgICAgICAgICAgZm9yIChpbnQgaSA9IDA7IGkgPCBjb3VudDE7ICsraSlcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgZmxvYXQgZG90ID0gVmVjdG9yMi5Eb3QocG9seTEuTm9ybWFsc1tpXSwgZExvY2FsMSk7XHJcbiAgICAgICAgICAgICAgICBpZiAoZG90ID4gbWF4RG90KVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIG1heERvdCA9IGRvdDtcclxuICAgICAgICAgICAgICAgICAgICBlZGdlID0gaTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gR2V0IHRoZSBzZXBhcmF0aW9uIGZvciB0aGUgZWRnZSBub3JtYWwuXHJcbiAgICAgICAgICAgIGZsb2F0IHMgPSBFZGdlU2VwYXJhdGlvbihwb2x5MSwgcmVmIHhmMSwgZWRnZSwgcG9seTIsIHJlZiB4ZjIpO1xyXG5cclxuICAgICAgICAgICAgLy8gQ2hlY2sgdGhlIHNlcGFyYXRpb24gZm9yIHRoZSBwcmV2aW91cyBlZGdlIG5vcm1hbC5cclxuICAgICAgICAgICAgaW50IHByZXZFZGdlID0gZWRnZSAtIDEgPj0gMCA/IGVkZ2UgLSAxIDogY291bnQxIC0gMTtcclxuICAgICAgICAgICAgZmxvYXQgc1ByZXYgPSBFZGdlU2VwYXJhdGlvbihwb2x5MSwgcmVmIHhmMSwgcHJldkVkZ2UsIHBvbHkyLCByZWYgeGYyKTtcclxuXHJcbiAgICAgICAgICAgIC8vIENoZWNrIHRoZSBzZXBhcmF0aW9uIGZvciB0aGUgbmV4dCBlZGdlIG5vcm1hbC5cclxuICAgICAgICAgICAgaW50IG5leHRFZGdlID0gZWRnZSArIDEgPCBjb3VudDEgPyBlZGdlICsgMSA6IDA7XHJcbiAgICAgICAgICAgIGZsb2F0IHNOZXh0ID0gRWRnZVNlcGFyYXRpb24ocG9seTEsIHJlZiB4ZjEsIG5leHRFZGdlLCBwb2x5MiwgcmVmIHhmMik7XHJcblxyXG4gICAgICAgICAgICAvLyBGaW5kIHRoZSBiZXN0IGVkZ2UgYW5kIHRoZSBzZWFyY2ggZGlyZWN0aW9uLlxyXG4gICAgICAgICAgICBpbnQgYmVzdEVkZ2U7XHJcbiAgICAgICAgICAgIGZsb2F0IGJlc3RTZXBhcmF0aW9uO1xyXG4gICAgICAgICAgICBpbnQgaW5jcmVtZW50O1xyXG4gICAgICAgICAgICBpZiAoc1ByZXYgPiBzICYmIHNQcmV2ID4gc05leHQpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGluY3JlbWVudCA9IC0xO1xyXG4gICAgICAgICAgICAgICAgYmVzdEVkZ2UgPSBwcmV2RWRnZTtcclxuICAgICAgICAgICAgICAgIGJlc3RTZXBhcmF0aW9uID0gc1ByZXY7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoc05leHQgPiBzKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBpbmNyZW1lbnQgPSAxO1xyXG4gICAgICAgICAgICAgICAgYmVzdEVkZ2UgPSBuZXh0RWRnZTtcclxuICAgICAgICAgICAgICAgIGJlc3RTZXBhcmF0aW9uID0gc05leHQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBlZGdlSW5kZXggPSBlZGdlO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHM7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIFBlcmZvcm0gYSBsb2NhbCBzZWFyY2ggZm9yIHRoZSBiZXN0IGVkZ2Ugbm9ybWFsLlxyXG4gICAgICAgICAgICBmb3IgKDsgOyApXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGlmIChpbmNyZW1lbnQgPT0gLTEpXHJcbiAgICAgICAgICAgICAgICAgICAgZWRnZSA9IGJlc3RFZGdlIC0gMSA+PSAwID8gYmVzdEVkZ2UgLSAxIDogY291bnQxIC0gMTtcclxuICAgICAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgICAgICBlZGdlID0gYmVzdEVkZ2UgKyAxIDwgY291bnQxID8gYmVzdEVkZ2UgKyAxIDogMDtcclxuXHJcbiAgICAgICAgICAgICAgICBzID0gRWRnZVNlcGFyYXRpb24ocG9seTEsIHJlZiB4ZjEsIGVkZ2UsIHBvbHkyLCByZWYgeGYyKTtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAocyA+IGJlc3RTZXBhcmF0aW9uKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIGJlc3RFZGdlID0gZWRnZTtcclxuICAgICAgICAgICAgICAgICAgICBiZXN0U2VwYXJhdGlvbiA9IHM7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGVkZ2VJbmRleCA9IGJlc3RFZGdlO1xyXG4gICAgICAgICAgICByZXR1cm4gYmVzdFNlcGFyYXRpb247XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwcml2YXRlIHN0YXRpYyB2b2lkIEZpbmRJbmNpZGVudEVkZ2Uob3V0IEZpeGVkQXJyYXkyPENsaXBWZXJ0ZXg+IGMsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFBvbHlnb25TaGFwZSBwb2x5MSwgcmVmIFRyYW5zZm9ybSB4ZjEsIGludCBlZGdlMSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgUG9seWdvblNoYXBlIHBvbHkyLCByZWYgVHJhbnNmb3JtIHhmMilcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGMgPSBuZXcgRml4ZWRBcnJheTI8Q2xpcFZlcnRleD4oKTtcclxuXHJcbiAgICAgICAgICAgIGludCBjb3VudDIgPSBwb2x5Mi5WZXJ0aWNlcy5Db3VudDtcclxuXHJcbiAgICAgICAgICAgIERlYnVnLkFzc2VydCgwIDw9IGVkZ2UxICYmIGVkZ2UxIDwgcG9seTEuVmVydGljZXMuQ291bnQpO1xyXG5cclxuICAgICAgICAgICAgLy8gR2V0IHRoZSBub3JtYWwgb2YgdGhlIHJlZmVyZW5jZSBlZGdlIGluIHBvbHkyJ3MgZnJhbWUuXHJcbiAgICAgICAgICAgIFZlY3RvcjIgdiA9IHBvbHkxLk5vcm1hbHNbZWRnZTFdO1xyXG4gICAgICAgICAgICBmbG9hdCB0bXB4ID0geGYxLlIuQ29sMS5YICogdi5YICsgeGYxLlIuQ29sMi5YICogdi5ZO1xyXG4gICAgICAgICAgICBmbG9hdCB0bXB5ID0geGYxLlIuQ29sMS5ZICogdi5YICsgeGYxLlIuQ29sMi5ZICogdi5ZO1xyXG4gICAgICAgICAgICBWZWN0b3IyIG5vcm1hbDEgPSBuZXcgVmVjdG9yMih0bXB4ICogeGYyLlIuQ29sMS5YICsgdG1weSAqIHhmMi5SLkNvbDEuWSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdG1weCAqIHhmMi5SLkNvbDIuWCArIHRtcHkgKiB4ZjIuUi5Db2wyLlkpO1xyXG5cclxuICAgICAgICAgICAgLy8gRmluZCB0aGUgaW5jaWRlbnQgZWRnZSBvbiBwb2x5Mi5cclxuICAgICAgICAgICAgaW50IGluZGV4ID0gMDtcclxuICAgICAgICAgICAgZmxvYXQgbWluRG90ID0gU2V0dGluZ3MuTWF4RmxvYXQ7XHJcbiAgICAgICAgICAgIGZvciAoaW50IGkgPSAwOyBpIDwgY291bnQyOyArK2kpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGZsb2F0IGRvdCA9IFZlY3RvcjIuRG90KG5vcm1hbDEsIHBvbHkyLk5vcm1hbHNbaV0pO1xyXG4gICAgICAgICAgICAgICAgaWYgKGRvdCA8IG1pbkRvdClcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBtaW5Eb3QgPSBkb3Q7XHJcbiAgICAgICAgICAgICAgICAgICAgaW5kZXggPSBpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBCdWlsZCB0aGUgY2xpcCB2ZXJ0aWNlcyBmb3IgdGhlIGluY2lkZW50IGVkZ2UuXHJcbiAgICAgICAgICAgIGludCBpMSA9IGluZGV4O1xyXG4gICAgICAgICAgICBpbnQgaTIgPSBpMSArIDEgPCBjb3VudDIgPyBpMSArIDEgOiAwO1xyXG5cclxuICAgICAgICAgICAgQ2xpcFZlcnRleCBjdjAgPSBjWzBdO1xyXG5cclxuICAgICAgICAgICAgVmVjdG9yMiB2MSA9IHBvbHkyLlZlcnRpY2VzW2kxXTtcclxuICAgICAgICAgICAgY3YwLlYuWCA9IHhmMi5Qb3NpdGlvbi5YICsgeGYyLlIuQ29sMS5YICogdjEuWCArIHhmMi5SLkNvbDIuWCAqIHYxLlk7XHJcbiAgICAgICAgICAgIGN2MC5WLlkgPSB4ZjIuUG9zaXRpb24uWSArIHhmMi5SLkNvbDEuWSAqIHYxLlggKyB4ZjIuUi5Db2wyLlkgKiB2MS5ZO1xyXG4gICAgICAgICAgICBjdjAuSUQuRmVhdHVyZXMuSW5kZXhBID0gKGJ5dGUpZWRnZTE7XHJcbiAgICAgICAgICAgIGN2MC5JRC5GZWF0dXJlcy5JbmRleEIgPSAoYnl0ZSlpMTtcclxuICAgICAgICAgICAgY3YwLklELkZlYXR1cmVzLlR5cGVBID0gKGJ5dGUpQ29udGFjdEZlYXR1cmVUeXBlLkZhY2U7XHJcbiAgICAgICAgICAgIGN2MC5JRC5GZWF0dXJlcy5UeXBlQiA9IChieXRlKUNvbnRhY3RGZWF0dXJlVHlwZS5WZXJ0ZXg7XHJcblxyXG4gICAgICAgICAgICBjWzBdID0gY3YwO1xyXG5cclxuICAgICAgICAgICAgQ2xpcFZlcnRleCBjdjEgPSBjWzFdO1xyXG4gICAgICAgICAgICBWZWN0b3IyIHYyID0gcG9seTIuVmVydGljZXNbaTJdO1xyXG4gICAgICAgICAgICBjdjEuVi5YID0geGYyLlBvc2l0aW9uLlggKyB4ZjIuUi5Db2wxLlggKiB2Mi5YICsgeGYyLlIuQ29sMi5YICogdjIuWTtcclxuICAgICAgICAgICAgY3YxLlYuWSA9IHhmMi5Qb3NpdGlvbi5ZICsgeGYyLlIuQ29sMS5ZICogdjIuWCArIHhmMi5SLkNvbDIuWSAqIHYyLlk7XHJcbiAgICAgICAgICAgIGN2MS5JRC5GZWF0dXJlcy5JbmRleEEgPSAoYnl0ZSllZGdlMTtcclxuICAgICAgICAgICAgY3YxLklELkZlYXR1cmVzLkluZGV4QiA9IChieXRlKWkyO1xyXG4gICAgICAgICAgICBjdjEuSUQuRmVhdHVyZXMuVHlwZUEgPSAoYnl0ZSlDb250YWN0RmVhdHVyZVR5cGUuRmFjZTtcclxuICAgICAgICAgICAgY3YxLklELkZlYXR1cmVzLlR5cGVCID0gKGJ5dGUpQ29udGFjdEZlYXR1cmVUeXBlLlZlcnRleDtcclxuXHJcbiAgICAgICAgICAgIGNbMV0gPSBjdjE7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59IiwiLypcclxuKiBGYXJzZWVyIFBoeXNpY3MgRW5naW5lIGJhc2VkIG9uIEJveDJELlhOQSBwb3J0OlxyXG4qIENvcHlyaWdodCAoYykgMjAxMCBJYW4gUXZpc3RcclxuKiBcclxuKiBCb3gyRC5YTkEgcG9ydCBvZiBCb3gyRDpcclxuKiBDb3B5cmlnaHQgKGMpIDIwMDkgQnJhbmRvbiBGdXJ0d2FuZ2xlciwgTmF0aGFuIEZ1cnR3YW5nbGVyXHJcbipcclxuKiBPcmlnaW5hbCBzb3VyY2UgQm94MkQ6XHJcbiogQ29weXJpZ2h0IChjKSAyMDA2LTIwMDkgRXJpbiBDYXR0byBodHRwOi8vd3d3LmdwaHlzaWNzLmNvbSBcclxuKiBcclxuKiBUaGlzIHNvZnR3YXJlIGlzIHByb3ZpZGVkICdhcy1pcycsIHdpdGhvdXQgYW55IGV4cHJlc3Mgb3IgaW1wbGllZCBcclxuKiB3YXJyYW50eS4gIEluIG5vIGV2ZW50IHdpbGwgdGhlIGF1dGhvcnMgYmUgaGVsZCBsaWFibGUgZm9yIGFueSBkYW1hZ2VzIFxyXG4qIGFyaXNpbmcgZnJvbSB0aGUgdXNlIG9mIHRoaXMgc29mdHdhcmUuIFxyXG4qIFBlcm1pc3Npb24gaXMgZ3JhbnRlZCB0byBhbnlvbmUgdG8gdXNlIHRoaXMgc29mdHdhcmUgZm9yIGFueSBwdXJwb3NlLCBcclxuKiBpbmNsdWRpbmcgY29tbWVyY2lhbCBhcHBsaWNhdGlvbnMsIGFuZCB0byBhbHRlciBpdCBhbmQgcmVkaXN0cmlidXRlIGl0IFxyXG4qIGZyZWVseSwgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIHJlc3RyaWN0aW9uczogXHJcbiogMS4gVGhlIG9yaWdpbiBvZiB0aGlzIHNvZnR3YXJlIG11c3Qgbm90IGJlIG1pc3JlcHJlc2VudGVkOyB5b3UgbXVzdCBub3QgXHJcbiogY2xhaW0gdGhhdCB5b3Ugd3JvdGUgdGhlIG9yaWdpbmFsIHNvZnR3YXJlLiBJZiB5b3UgdXNlIHRoaXMgc29mdHdhcmUgXHJcbiogaW4gYSBwcm9kdWN0LCBhbiBhY2tub3dsZWRnbWVudCBpbiB0aGUgcHJvZHVjdCBkb2N1bWVudGF0aW9uIHdvdWxkIGJlIFxyXG4qIGFwcHJlY2lhdGVkIGJ1dCBpcyBub3QgcmVxdWlyZWQuIFxyXG4qIDIuIEFsdGVyZWQgc291cmNlIHZlcnNpb25zIG11c3QgYmUgcGxhaW5seSBtYXJrZWQgYXMgc3VjaCwgYW5kIG11c3Qgbm90IGJlIFxyXG4qIG1pc3JlcHJlc2VudGVkIGFzIGJlaW5nIHRoZSBvcmlnaW5hbCBzb2Z0d2FyZS4gXHJcbiogMy4gVGhpcyBub3RpY2UgbWF5IG5vdCBiZSByZW1vdmVkIG9yIGFsdGVyZWQgZnJvbSBhbnkgc291cmNlIGRpc3RyaWJ1dGlvbi4gXHJcbiovXHJcblxyXG51c2luZyBTeXN0ZW07XHJcbnVzaW5nIFN5c3RlbS5EaWFnbm9zdGljcztcclxudXNpbmcgRmFyc2VlclBoeXNpY3MuQ29sbGlzaW9uLlNoYXBlcztcclxudXNpbmcgRmFyc2VlclBoeXNpY3MuQ29tbW9uO1xyXG51c2luZyBNaWNyb3NvZnQuWG5hLkZyYW1ld29yaztcclxuXHJcbm5hbWVzcGFjZSBGYXJzZWVyUGh5c2ljcy5Db2xsaXNpb25cclxue1xyXG4gICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgLy8vIEEgZGlzdGFuY2UgcHJveHkgaXMgdXNlZCBieSB0aGUgR0pLIGFsZ29yaXRobS5cclxuICAgIC8vLyBJdCBlbmNhcHN1bGF0ZXMgYW55IHNoYXBlLlxyXG4gICAgLy8vIDwvc3VtbWFyeT5cclxuICAgIHB1YmxpYyBjbGFzcyBEaXN0YW5jZVByb3h5XHJcbiAgICB7XHJcbiAgICAgICAgaW50ZXJuYWwgZmxvYXQgUmFkaXVzO1xyXG4gICAgICAgIGludGVybmFsIFZlcnRpY2VzIFZlcnRpY2VzID0gbmV3IFZlcnRpY2VzKCk7XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gSW5pdGlhbGl6ZSB0aGUgcHJveHkgdXNpbmcgdGhlIGdpdmVuIHNoYXBlLiBUaGUgc2hhcGVcclxuICAgICAgICAvLy8gbXVzdCByZW1haW4gaW4gc2NvcGUgd2hpbGUgdGhlIHByb3h5IGlzIGluIHVzZS5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cInNoYXBlXCI+VGhlIHNoYXBlLjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwiaW5kZXhcIj5UaGUgaW5kZXguPC9wYXJhbT5cclxuICAgICAgICBwdWJsaWMgdm9pZCBTZXQoU2hhcGUgc2hhcGUsIGludCBpbmRleClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHN3aXRjaCAoc2hhcGUuU2hhcGVUeXBlKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBjYXNlIFNoYXBlVHlwZS5DaXJjbGU6XHJcbiAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBDaXJjbGVTaGFwZSBjaXJjbGUgPSAoQ2lyY2xlU2hhcGUpc2hhcGU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIFZlcnRpY2VzLkNsZWFyKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIFZlcnRpY2VzLkFkZChjaXJjbGUuUG9zaXRpb24pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBSYWRpdXMgPSBjaXJjbGUuUmFkaXVzO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgICAgICAgICBjYXNlIFNoYXBlVHlwZS5Qb2x5Z29uOlxyXG4gICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgUG9seWdvblNoYXBlIHBvbHlnb24gPSAoUG9seWdvblNoYXBlKXNoYXBlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBWZXJ0aWNlcy5DbGVhcigpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGludCBpID0gMDsgaSA8IHBvbHlnb24uVmVydGljZXMuQ291bnQ7IGkrKylcclxuICAgICAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgVmVydGljZXMuQWRkKHBvbHlnb24uVmVydGljZXNbaV0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIFJhZGl1cyA9IHBvbHlnb24uUmFkaXVzO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgICAgICAgICBjYXNlIFNoYXBlVHlwZS5Mb29wOlxyXG4gICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgTG9vcFNoYXBlIGxvb3AgPSAoTG9vcFNoYXBlKXNoYXBlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBEZWJ1Zy5Bc3NlcnQoMCA8PSBpbmRleCAmJiBpbmRleCA8IGxvb3AuVmVydGljZXMuQ291bnQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBWZXJ0aWNlcy5DbGVhcigpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBWZXJ0aWNlcy5BZGQobG9vcC5WZXJ0aWNlc1tpbmRleF0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBWZXJ0aWNlcy5BZGQoaW5kZXggKyAxIDwgbG9vcC5WZXJ0aWNlcy5Db3VudCA/IGxvb3AuVmVydGljZXNbaW5kZXggKyAxXSA6IGxvb3AuVmVydGljZXNbMF0pO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgUmFkaXVzID0gbG9vcC5SYWRpdXM7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICAgICAgICAgIGNhc2UgU2hhcGVUeXBlLkVkZ2U6XHJcbiAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBFZGdlU2hhcGUgZWRnZSA9IChFZGdlU2hhcGUpc2hhcGU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIFZlcnRpY2VzLkNsZWFyKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIFZlcnRpY2VzLkFkZChlZGdlLlZlcnRleDEpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBWZXJ0aWNlcy5BZGQoZWRnZS5WZXJ0ZXgyKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgUmFkaXVzID0gZWRnZS5SYWRpdXM7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICAgICAgRGVidWcuQXNzZXJ0KGZhbHNlKTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBHZXQgdGhlIHN1cHBvcnRpbmcgdmVydGV4IGluZGV4IGluIHRoZSBnaXZlbiBkaXJlY3Rpb24uXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJkaXJlY3Rpb25cIj5UaGUgZGlyZWN0aW9uLjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxyZXR1cm5zPjwvcmV0dXJucz5cclxuICAgICAgICBwdWJsaWMgaW50IEdldFN1cHBvcnQoVmVjdG9yMiBkaXJlY3Rpb24pXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBpbnQgYmVzdEluZGV4ID0gMDtcclxuICAgICAgICAgICAgZmxvYXQgYmVzdFZhbHVlID0gVmVjdG9yMi5Eb3QoVmVydGljZXNbMF0sIGRpcmVjdGlvbik7XHJcbiAgICAgICAgICAgIGZvciAoaW50IGkgPSAxOyBpIDwgVmVydGljZXMuQ291bnQ7ICsraSlcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgZmxvYXQgdmFsdWUgPSBWZWN0b3IyLkRvdChWZXJ0aWNlc1tpXSwgZGlyZWN0aW9uKTtcclxuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA+IGJlc3RWYWx1ZSlcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBiZXN0SW5kZXggPSBpO1xyXG4gICAgICAgICAgICAgICAgICAgIGJlc3RWYWx1ZSA9IHZhbHVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gYmVzdEluZGV4O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBHZXQgdGhlIHN1cHBvcnRpbmcgdmVydGV4IGluIHRoZSBnaXZlbiBkaXJlY3Rpb24uXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJkaXJlY3Rpb25cIj5UaGUgZGlyZWN0aW9uLjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxyZXR1cm5zPjwvcmV0dXJucz5cclxuICAgICAgICBwdWJsaWMgVmVjdG9yMiBHZXRTdXBwb3J0VmVydGV4KFZlY3RvcjIgZGlyZWN0aW9uKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgaW50IGJlc3RJbmRleCA9IDA7XHJcbiAgICAgICAgICAgIGZsb2F0IGJlc3RWYWx1ZSA9IFZlY3RvcjIuRG90KFZlcnRpY2VzWzBdLCBkaXJlY3Rpb24pO1xyXG4gICAgICAgICAgICBmb3IgKGludCBpID0gMTsgaSA8IFZlcnRpY2VzLkNvdW50OyArK2kpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGZsb2F0IHZhbHVlID0gVmVjdG9yMi5Eb3QoVmVydGljZXNbaV0sIGRpcmVjdGlvbik7XHJcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgPiBiZXN0VmFsdWUpXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgYmVzdEluZGV4ID0gaTtcclxuICAgICAgICAgICAgICAgICAgICBiZXN0VmFsdWUgPSB2YWx1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuIFZlcnRpY2VzW2Jlc3RJbmRleF07XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8vLyA8c3VtbWFyeT5cclxuICAgIC8vLyBVc2VkIHRvIHdhcm0gc3RhcnQgQ29tcHV0ZURpc3RhbmNlLlxyXG4gICAgLy8vIFNldCBjb3VudCB0byB6ZXJvIG9uIGZpcnN0IGNhbGwuXHJcbiAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgcHVibGljIHN0cnVjdCBTaW1wbGV4Q2FjaGVcclxuICAgIHtcclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIExlbmd0aCBvciBhcmVhXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICBwdWJsaWMgdXNob3J0IENvdW50O1xyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIFZlcnRpY2VzIG9uIHNoYXBlIEFcclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIHB1YmxpYyBGaXhlZEFycmF5MzxieXRlPiBJbmRleEE7XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gVmVydGljZXMgb24gc2hhcGUgQlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgcHVibGljIEZpeGVkQXJyYXkzPGJ5dGU+IEluZGV4QjtcclxuXHJcbiAgICAgICAgcHVibGljIGZsb2F0IE1ldHJpYztcclxuICAgIH1cclxuXHJcbiAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAvLy8gSW5wdXQgZm9yIENvbXB1dGVEaXN0YW5jZS5cclxuICAgIC8vLyBZb3UgaGF2ZSB0byBvcHRpb24gdG8gdXNlIHRoZSBzaGFwZSByYWRpaVxyXG4gICAgLy8vIGluIHRoZSBjb21wdXRhdGlvbi4gXHJcbiAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgcHVibGljIGNsYXNzIERpc3RhbmNlSW5wdXRcclxuICAgIHtcclxuICAgICAgICBwdWJsaWMgRGlzdGFuY2VQcm94eSBQcm94eUEgPSBuZXcgRGlzdGFuY2VQcm94eSgpO1xyXG4gICAgICAgIHB1YmxpYyBEaXN0YW5jZVByb3h5IFByb3h5QiA9IG5ldyBEaXN0YW5jZVByb3h5KCk7XHJcbiAgICAgICAgcHVibGljIFRyYW5zZm9ybSBUcmFuc2Zvcm1BO1xyXG4gICAgICAgIHB1YmxpYyBUcmFuc2Zvcm0gVHJhbnNmb3JtQjtcclxuICAgICAgICBwdWJsaWMgYm9vbCBVc2VSYWRpaTtcclxuICAgIH1cclxuXHJcbiAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAvLy8gT3V0cHV0IGZvciBDb21wdXRlRGlzdGFuY2UuXHJcbiAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgcHVibGljIHN0cnVjdCBEaXN0YW5jZU91dHB1dFxyXG4gICAge1xyXG4gICAgICAgIHB1YmxpYyBmbG9hdCBEaXN0YW5jZTtcclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBOdW1iZXIgb2YgR0pLIGl0ZXJhdGlvbnMgdXNlZFxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgcHVibGljIGludCBJdGVyYXRpb25zO1xyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIENsb3Nlc3QgcG9pbnQgb24gc2hhcGVBXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICBwdWJsaWMgVmVjdG9yMiBQb2ludEE7XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gQ2xvc2VzdCBwb2ludCBvbiBzaGFwZUJcclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIHB1YmxpYyBWZWN0b3IyIFBvaW50QjtcclxuICAgIH1cclxuXHJcbiAgICBpbnRlcm5hbCBzdHJ1Y3QgU2ltcGxleFZlcnRleFxyXG4gICAge1xyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gQmFyeWNlbnRyaWMgY29vcmRpbmF0ZSBmb3IgY2xvc2VzdCBwb2ludCBcclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIHB1YmxpYyBmbG9hdCBBO1xyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIHdBIGluZGV4XHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICBwdWJsaWMgaW50IEluZGV4QTtcclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyB3QiBpbmRleFxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgcHVibGljIGludCBJbmRleEI7XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gd0IgLSB3QVxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgcHVibGljIFZlY3RvcjIgVztcclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBTdXBwb3J0IHBvaW50IGluIHByb3h5QVxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgcHVibGljIFZlY3RvcjIgV0E7XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gU3VwcG9ydCBwb2ludCBpbiBwcm94eUJcclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIHB1YmxpYyBWZWN0b3IyIFdCO1xyXG4gICAgfVxyXG5cclxuICAgIGludGVybmFsIHN0cnVjdCBTaW1wbGV4XHJcbiAgICB7XHJcbiAgICAgICAgaW50ZXJuYWwgaW50IENvdW50O1xyXG4gICAgICAgIGludGVybmFsIEZpeGVkQXJyYXkzPFNpbXBsZXhWZXJ0ZXg+IFY7XHJcblxyXG4gICAgICAgIGludGVybmFsIHZvaWQgUmVhZENhY2hlKHJlZiBTaW1wbGV4Q2FjaGUgY2FjaGUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgRGlzdGFuY2VQcm94eSBwcm94eUEsIHJlZiBUcmFuc2Zvcm0gdHJhbnNmb3JtQSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBEaXN0YW5jZVByb3h5IHByb3h5QiwgcmVmIFRyYW5zZm9ybSB0cmFuc2Zvcm1CKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgRGVidWcuQXNzZXJ0KGNhY2hlLkNvdW50IDw9IDMpO1xyXG5cclxuICAgICAgICAgICAgLy8gQ29weSBkYXRhIGZyb20gY2FjaGUuXHJcbiAgICAgICAgICAgIENvdW50ID0gY2FjaGUuQ291bnQ7XHJcbiAgICAgICAgICAgIGZvciAoaW50IGkgPSAwOyBpIDwgQ291bnQ7ICsraSlcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgU2ltcGxleFZlcnRleCB2ID0gVltpXTtcclxuICAgICAgICAgICAgICAgIHYuSW5kZXhBID0gY2FjaGUuSW5kZXhBW2ldO1xyXG4gICAgICAgICAgICAgICAgdi5JbmRleEIgPSBjYWNoZS5JbmRleEJbaV07XHJcbiAgICAgICAgICAgICAgICBWZWN0b3IyIHdBTG9jYWwgPSBwcm94eUEuVmVydGljZXNbdi5JbmRleEFdO1xyXG4gICAgICAgICAgICAgICAgVmVjdG9yMiB3QkxvY2FsID0gcHJveHlCLlZlcnRpY2VzW3YuSW5kZXhCXTtcclxuICAgICAgICAgICAgICAgIHYuV0EgPSBNYXRoVXRpbHMuTXVsdGlwbHkocmVmIHRyYW5zZm9ybUEsIHdBTG9jYWwpO1xyXG4gICAgICAgICAgICAgICAgdi5XQiA9IE1hdGhVdGlscy5NdWx0aXBseShyZWYgdHJhbnNmb3JtQiwgd0JMb2NhbCk7XHJcbiAgICAgICAgICAgICAgICB2LlcgPSB2LldCIC0gdi5XQTtcclxuICAgICAgICAgICAgICAgIHYuQSA9IDAuMGY7XHJcbiAgICAgICAgICAgICAgICBWW2ldID0gdjtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gQ29tcHV0ZSB0aGUgbmV3IHNpbXBsZXggbWV0cmljLCBpZiBpdCBpcyBzdWJzdGFudGlhbGx5IGRpZmZlcmVudCB0aGFuXHJcbiAgICAgICAgICAgIC8vIG9sZCBtZXRyaWMgdGhlbiBmbHVzaCB0aGUgc2ltcGxleC5cclxuICAgICAgICAgICAgaWYgKENvdW50ID4gMSlcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgZmxvYXQgbWV0cmljMSA9IGNhY2hlLk1ldHJpYztcclxuICAgICAgICAgICAgICAgIGZsb2F0IG1ldHJpYzIgPSBHZXRNZXRyaWMoKTtcclxuICAgICAgICAgICAgICAgIGlmIChtZXRyaWMyIDwgMC41ZiAqIG1ldHJpYzEgfHwgMi4wZiAqIG1ldHJpYzEgPCBtZXRyaWMyIHx8IG1ldHJpYzIgPCBTZXR0aW5ncy5FcHNpbG9uKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIFJlc2V0IHRoZSBzaW1wbGV4LlxyXG4gICAgICAgICAgICAgICAgICAgIENvdW50ID0gMDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gSWYgdGhlIGNhY2hlIGlzIGVtcHR5IG9yIGludmFsaWQgLi4uXHJcbiAgICAgICAgICAgIGlmIChDb3VudCA9PSAwKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBTaW1wbGV4VmVydGV4IHYgPSBWWzBdO1xyXG4gICAgICAgICAgICAgICAgdi5JbmRleEEgPSAwO1xyXG4gICAgICAgICAgICAgICAgdi5JbmRleEIgPSAwO1xyXG4gICAgICAgICAgICAgICAgVmVjdG9yMiB3QUxvY2FsID0gcHJveHlBLlZlcnRpY2VzWzBdO1xyXG4gICAgICAgICAgICAgICAgVmVjdG9yMiB3QkxvY2FsID0gcHJveHlCLlZlcnRpY2VzWzBdO1xyXG4gICAgICAgICAgICAgICAgdi5XQSA9IE1hdGhVdGlscy5NdWx0aXBseShyZWYgdHJhbnNmb3JtQSwgd0FMb2NhbCk7XHJcbiAgICAgICAgICAgICAgICB2LldCID0gTWF0aFV0aWxzLk11bHRpcGx5KHJlZiB0cmFuc2Zvcm1CLCB3QkxvY2FsKTtcclxuICAgICAgICAgICAgICAgIHYuVyA9IHYuV0IgLSB2LldBO1xyXG4gICAgICAgICAgICAgICAgVlswXSA9IHY7XHJcbiAgICAgICAgICAgICAgICBDb3VudCA9IDE7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGludGVybmFsIHZvaWQgV3JpdGVDYWNoZShyZWYgU2ltcGxleENhY2hlIGNhY2hlKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgY2FjaGUuTWV0cmljID0gR2V0TWV0cmljKCk7XHJcbiAgICAgICAgICAgIGNhY2hlLkNvdW50ID0gKFVJbnQxNilDb3VudDtcclxuICAgICAgICAgICAgZm9yIChpbnQgaSA9IDA7IGkgPCBDb3VudDsgKytpKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBjYWNoZS5JbmRleEFbaV0gPSAoYnl0ZSkoVltpXS5JbmRleEEpO1xyXG4gICAgICAgICAgICAgICAgY2FjaGUuSW5kZXhCW2ldID0gKGJ5dGUpKFZbaV0uSW5kZXhCKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaW50ZXJuYWwgVmVjdG9yMiBHZXRTZWFyY2hEaXJlY3Rpb24oKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgc3dpdGNoIChDb3VudClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgY2FzZSAxOlxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAtVlswXS5XO1xyXG5cclxuICAgICAgICAgICAgICAgIGNhc2UgMjpcclxuICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIFZlY3RvcjIgZTEyID0gVlsxXS5XIC0gVlswXS5XO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBmbG9hdCBzZ24gPSBNYXRoVXRpbHMuQ3Jvc3MoZTEyLCAtVlswXS5XKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNnbiA+IDAuMGYpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIE9yaWdpbiBpcyBsZWZ0IG9mIGUxMi5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgVmVjdG9yMigtZTEyLlksIGUxMi5YKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIE9yaWdpbiBpcyByaWdodCBvZiBlMTIuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFZlY3RvcjIoZTEyLlksIC1lMTIuWCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgICAgICBEZWJ1Zy5Bc3NlcnQoZmFsc2UpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBWZWN0b3IyLlplcm87XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGludGVybmFsIFZlY3RvcjIgR2V0Q2xvc2VzdFBvaW50KClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHN3aXRjaCAoQ291bnQpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGNhc2UgMDpcclxuICAgICAgICAgICAgICAgICAgICBEZWJ1Zy5Bc3NlcnQoZmFsc2UpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBWZWN0b3IyLlplcm87XHJcblxyXG4gICAgICAgICAgICAgICAgY2FzZSAxOlxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBWWzBdLlc7XHJcblxyXG4gICAgICAgICAgICAgICAgY2FzZSAyOlxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBWWzBdLkEgKiBWWzBdLlcgKyBWWzFdLkEgKiBWWzFdLlc7XHJcblxyXG4gICAgICAgICAgICAgICAgY2FzZSAzOlxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBWZWN0b3IyLlplcm87XHJcblxyXG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgICAgICBEZWJ1Zy5Bc3NlcnQoZmFsc2UpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBWZWN0b3IyLlplcm87XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGludGVybmFsIHZvaWQgR2V0V2l0bmVzc1BvaW50cyhvdXQgVmVjdG9yMiBwQSwgb3V0IFZlY3RvcjIgcEIpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBzd2l0Y2ggKENvdW50KVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDA6XHJcbiAgICAgICAgICAgICAgICAgICAgcEEgPSBWZWN0b3IyLlplcm87XHJcbiAgICAgICAgICAgICAgICAgICAgcEIgPSBWZWN0b3IyLlplcm87XHJcbiAgICAgICAgICAgICAgICAgICAgRGVidWcuQXNzZXJ0KGZhbHNlKTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgICAgICAgICBjYXNlIDE6XHJcbiAgICAgICAgICAgICAgICAgICAgcEEgPSBWWzBdLldBO1xyXG4gICAgICAgICAgICAgICAgICAgIHBCID0gVlswXS5XQjtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgICAgICAgICBjYXNlIDI6XHJcbiAgICAgICAgICAgICAgICAgICAgcEEgPSBWWzBdLkEgKiBWWzBdLldBICsgVlsxXS5BICogVlsxXS5XQTtcclxuICAgICAgICAgICAgICAgICAgICBwQiA9IFZbMF0uQSAqIFZbMF0uV0IgKyBWWzFdLkEgKiBWWzFdLldCO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICAgICAgICAgIGNhc2UgMzpcclxuICAgICAgICAgICAgICAgICAgICBwQSA9IFZbMF0uQSAqIFZbMF0uV0EgKyBWWzFdLkEgKiBWWzFdLldBICsgVlsyXS5BICogVlsyXS5XQTtcclxuICAgICAgICAgICAgICAgICAgICBwQiA9IHBBO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEV4Y2VwdGlvbigpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpbnRlcm5hbCBmbG9hdCBHZXRNZXRyaWMoKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgc3dpdGNoIChDb3VudClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgY2FzZSAwOlxyXG4gICAgICAgICAgICAgICAgICAgIERlYnVnLkFzc2VydChmYWxzZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDAuMGY7XHJcblxyXG4gICAgICAgICAgICAgICAgY2FzZSAxOlxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAwLjBmO1xyXG5cclxuICAgICAgICAgICAgICAgIGNhc2UgMjpcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gKFZbMF0uVyAtIFZbMV0uVykuTGVuZ3RoKCk7XHJcblxyXG4gICAgICAgICAgICAgICAgY2FzZSAzOlxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBNYXRoVXRpbHMuQ3Jvc3MoVlsxXS5XIC0gVlswXS5XLCBWWzJdLlcgLSBWWzBdLlcpO1xyXG5cclxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICAgICAgRGVidWcuQXNzZXJ0KGZhbHNlKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gMC4wZjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gU29sdmUgYSBsaW5lIHNlZ21lbnQgdXNpbmcgYmFyeWNlbnRyaWMgY29vcmRpbmF0ZXMuXHJcbiAgICAgICAgLy9cclxuICAgICAgICAvLyBwID0gYTEgKiB3MSArIGEyICogdzJcclxuICAgICAgICAvLyBhMSArIGEyID0gMVxyXG4gICAgICAgIC8vXHJcbiAgICAgICAgLy8gVGhlIHZlY3RvciBmcm9tIHRoZSBvcmlnaW4gdG8gdGhlIGNsb3Nlc3QgcG9pbnQgb24gdGhlIGxpbmUgaXNcclxuICAgICAgICAvLyBwZXJwZW5kaWN1bGFyIHRvIHRoZSBsaW5lLlxyXG4gICAgICAgIC8vIGUxMiA9IHcyIC0gdzFcclxuICAgICAgICAvLyBkb3QocCwgZSkgPSAwXHJcbiAgICAgICAgLy8gYTEgKiBkb3QodzEsIGUpICsgYTIgKiBkb3QodzIsIGUpID0gMFxyXG4gICAgICAgIC8vXHJcbiAgICAgICAgLy8gMi1ieS0yIGxpbmVhciBzeXN0ZW1cclxuICAgICAgICAvLyBbMSAgICAgIDEgICAgIF1bYTFdID0gWzFdXHJcbiAgICAgICAgLy8gW3cxLmUxMiB3Mi5lMTJdW2EyXSA9IFswXVxyXG4gICAgICAgIC8vXHJcbiAgICAgICAgLy8gRGVmaW5lXHJcbiAgICAgICAgLy8gZDEyXzEgPSAgZG90KHcyLCBlMTIpXHJcbiAgICAgICAgLy8gZDEyXzIgPSAtZG90KHcxLCBlMTIpXHJcbiAgICAgICAgLy8gZDEyID0gZDEyXzEgKyBkMTJfMlxyXG4gICAgICAgIC8vXHJcbiAgICAgICAgLy8gU29sdXRpb25cclxuICAgICAgICAvLyBhMSA9IGQxMl8xIC8gZDEyXHJcbiAgICAgICAgLy8gYTIgPSBkMTJfMiAvIGQxMlxyXG5cclxuICAgICAgICBpbnRlcm5hbCB2b2lkIFNvbHZlMigpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBWZWN0b3IyIHcxID0gVlswXS5XO1xyXG4gICAgICAgICAgICBWZWN0b3IyIHcyID0gVlsxXS5XO1xyXG4gICAgICAgICAgICBWZWN0b3IyIGUxMiA9IHcyIC0gdzE7XHJcblxyXG4gICAgICAgICAgICAvLyB3MSByZWdpb25cclxuICAgICAgICAgICAgZmxvYXQgZDEyXzIgPSAtVmVjdG9yMi5Eb3QodzEsIGUxMik7XHJcbiAgICAgICAgICAgIGlmIChkMTJfMiA8PSAwLjBmKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAvLyBhMiA8PSAwLCBzbyB3ZSBjbGFtcCBpdCB0byAwXHJcbiAgICAgICAgICAgICAgICBTaW1wbGV4VmVydGV4IHYwID0gVlswXTtcclxuICAgICAgICAgICAgICAgIHYwLkEgPSAxLjBmO1xyXG4gICAgICAgICAgICAgICAgVlswXSA9IHYwO1xyXG4gICAgICAgICAgICAgICAgQ291bnQgPSAxO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyB3MiByZWdpb25cclxuICAgICAgICAgICAgZmxvYXQgZDEyXzEgPSBWZWN0b3IyLkRvdCh3MiwgZTEyKTtcclxuICAgICAgICAgICAgaWYgKGQxMl8xIDw9IDAuMGYpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIC8vIGExIDw9IDAsIHNvIHdlIGNsYW1wIGl0IHRvIDBcclxuICAgICAgICAgICAgICAgIFNpbXBsZXhWZXJ0ZXggdjEgPSBWWzFdO1xyXG4gICAgICAgICAgICAgICAgdjEuQSA9IDEuMGY7XHJcbiAgICAgICAgICAgICAgICBWWzFdID0gdjE7XHJcbiAgICAgICAgICAgICAgICBDb3VudCA9IDE7XHJcbiAgICAgICAgICAgICAgICBWWzBdID0gVlsxXTtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gTXVzdCBiZSBpbiBlMTIgcmVnaW9uLlxyXG4gICAgICAgICAgICBmbG9hdCBpbnZfZDEyID0gMS4wZiAvIChkMTJfMSArIGQxMl8yKTtcclxuICAgICAgICAgICAgU2ltcGxleFZlcnRleCB2MF8yID0gVlswXTtcclxuICAgICAgICAgICAgU2ltcGxleFZlcnRleCB2MV8yID0gVlsxXTtcclxuICAgICAgICAgICAgdjBfMi5BID0gZDEyXzEgKiBpbnZfZDEyO1xyXG4gICAgICAgICAgICB2MV8yLkEgPSBkMTJfMiAqIGludl9kMTI7XHJcbiAgICAgICAgICAgIFZbMF0gPSB2MF8yO1xyXG4gICAgICAgICAgICBWWzFdID0gdjFfMjtcclxuICAgICAgICAgICAgQ291bnQgPSAyO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gUG9zc2libGUgcmVnaW9uczpcclxuICAgICAgICAvLyAtIHBvaW50c1syXVxyXG4gICAgICAgIC8vIC0gZWRnZSBwb2ludHNbMF0tcG9pbnRzWzJdXHJcbiAgICAgICAgLy8gLSBlZGdlIHBvaW50c1sxXS1wb2ludHNbMl1cclxuICAgICAgICAvLyAtIGluc2lkZSB0aGUgdHJpYW5nbGVcclxuICAgICAgICBpbnRlcm5hbCB2b2lkIFNvbHZlMygpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBWZWN0b3IyIHcxID0gVlswXS5XO1xyXG4gICAgICAgICAgICBWZWN0b3IyIHcyID0gVlsxXS5XO1xyXG4gICAgICAgICAgICBWZWN0b3IyIHczID0gVlsyXS5XO1xyXG5cclxuICAgICAgICAgICAgLy8gRWRnZTEyXHJcbiAgICAgICAgICAgIC8vIFsxICAgICAgMSAgICAgXVthMV0gPSBbMV1cclxuICAgICAgICAgICAgLy8gW3cxLmUxMiB3Mi5lMTJdW2EyXSA9IFswXVxyXG4gICAgICAgICAgICAvLyBhMyA9IDBcclxuICAgICAgICAgICAgVmVjdG9yMiBlMTIgPSB3MiAtIHcxO1xyXG4gICAgICAgICAgICBmbG9hdCB3MWUxMiA9IFZlY3RvcjIuRG90KHcxLCBlMTIpO1xyXG4gICAgICAgICAgICBmbG9hdCB3MmUxMiA9IFZlY3RvcjIuRG90KHcyLCBlMTIpO1xyXG4gICAgICAgICAgICBmbG9hdCBkMTJfMSA9IHcyZTEyO1xyXG4gICAgICAgICAgICBmbG9hdCBkMTJfMiA9IC13MWUxMjtcclxuXHJcbiAgICAgICAgICAgIC8vIEVkZ2UxM1xyXG4gICAgICAgICAgICAvLyBbMSAgICAgIDEgICAgIF1bYTFdID0gWzFdXHJcbiAgICAgICAgICAgIC8vIFt3MS5lMTMgdzMuZTEzXVthM10gPSBbMF1cclxuICAgICAgICAgICAgLy8gYTIgPSAwXHJcbiAgICAgICAgICAgIFZlY3RvcjIgZTEzID0gdzMgLSB3MTtcclxuICAgICAgICAgICAgZmxvYXQgdzFlMTMgPSBWZWN0b3IyLkRvdCh3MSwgZTEzKTtcclxuICAgICAgICAgICAgZmxvYXQgdzNlMTMgPSBWZWN0b3IyLkRvdCh3MywgZTEzKTtcclxuICAgICAgICAgICAgZmxvYXQgZDEzXzEgPSB3M2UxMztcclxuICAgICAgICAgICAgZmxvYXQgZDEzXzIgPSAtdzFlMTM7XHJcblxyXG4gICAgICAgICAgICAvLyBFZGdlMjNcclxuICAgICAgICAgICAgLy8gWzEgICAgICAxICAgICBdW2EyXSA9IFsxXVxyXG4gICAgICAgICAgICAvLyBbdzIuZTIzIHczLmUyM11bYTNdID0gWzBdXHJcbiAgICAgICAgICAgIC8vIGExID0gMFxyXG4gICAgICAgICAgICBWZWN0b3IyIGUyMyA9IHczIC0gdzI7XHJcbiAgICAgICAgICAgIGZsb2F0IHcyZTIzID0gVmVjdG9yMi5Eb3QodzIsIGUyMyk7XHJcbiAgICAgICAgICAgIGZsb2F0IHczZTIzID0gVmVjdG9yMi5Eb3QodzMsIGUyMyk7XHJcbiAgICAgICAgICAgIGZsb2F0IGQyM18xID0gdzNlMjM7XHJcbiAgICAgICAgICAgIGZsb2F0IGQyM18yID0gLXcyZTIzO1xyXG5cclxuICAgICAgICAgICAgLy8gVHJpYW5nbGUxMjNcclxuICAgICAgICAgICAgZmxvYXQgbjEyMyA9IE1hdGhVdGlscy5Dcm9zcyhlMTIsIGUxMyk7XHJcblxyXG4gICAgICAgICAgICBmbG9hdCBkMTIzXzEgPSBuMTIzICogTWF0aFV0aWxzLkNyb3NzKHcyLCB3Myk7XHJcbiAgICAgICAgICAgIGZsb2F0IGQxMjNfMiA9IG4xMjMgKiBNYXRoVXRpbHMuQ3Jvc3ModzMsIHcxKTtcclxuICAgICAgICAgICAgZmxvYXQgZDEyM18zID0gbjEyMyAqIE1hdGhVdGlscy5Dcm9zcyh3MSwgdzIpO1xyXG5cclxuICAgICAgICAgICAgLy8gdzEgcmVnaW9uXHJcbiAgICAgICAgICAgIGlmIChkMTJfMiA8PSAwLjBmICYmIGQxM18yIDw9IDAuMGYpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIFNpbXBsZXhWZXJ0ZXggdjBfMSA9IFZbMF07XHJcbiAgICAgICAgICAgICAgICB2MF8xLkEgPSAxLjBmO1xyXG4gICAgICAgICAgICAgICAgVlswXSA9IHYwXzE7XHJcbiAgICAgICAgICAgICAgICBDb3VudCA9IDE7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIGUxMlxyXG4gICAgICAgICAgICBpZiAoZDEyXzEgPiAwLjBmICYmIGQxMl8yID4gMC4wZiAmJiBkMTIzXzMgPD0gMC4wZilcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgZmxvYXQgaW52X2QxMiA9IDEuMGYgLyAoZDEyXzEgKyBkMTJfMik7XHJcbiAgICAgICAgICAgICAgICBTaW1wbGV4VmVydGV4IHYwXzIgPSBWWzBdO1xyXG4gICAgICAgICAgICAgICAgU2ltcGxleFZlcnRleCB2MV8yID0gVlsxXTtcclxuICAgICAgICAgICAgICAgIHYwXzIuQSA9IGQxMl8xICogaW52X2QxMjtcclxuICAgICAgICAgICAgICAgIHYxXzIuQSA9IGQxMl8yICogaW52X2QxMjtcclxuICAgICAgICAgICAgICAgIFZbMF0gPSB2MF8yO1xyXG4gICAgICAgICAgICAgICAgVlsxXSA9IHYxXzI7XHJcbiAgICAgICAgICAgICAgICBDb3VudCA9IDI7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIGUxM1xyXG4gICAgICAgICAgICBpZiAoZDEzXzEgPiAwLjBmICYmIGQxM18yID4gMC4wZiAmJiBkMTIzXzIgPD0gMC4wZilcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgZmxvYXQgaW52X2QxMyA9IDEuMGYgLyAoZDEzXzEgKyBkMTNfMik7XHJcbiAgICAgICAgICAgICAgICBTaW1wbGV4VmVydGV4IHYwXzMgPSBWWzBdO1xyXG4gICAgICAgICAgICAgICAgU2ltcGxleFZlcnRleCB2Ml8zID0gVlsyXTtcclxuICAgICAgICAgICAgICAgIHYwXzMuQSA9IGQxM18xICogaW52X2QxMztcclxuICAgICAgICAgICAgICAgIHYyXzMuQSA9IGQxM18yICogaW52X2QxMztcclxuICAgICAgICAgICAgICAgIFZbMF0gPSB2MF8zO1xyXG4gICAgICAgICAgICAgICAgVlsyXSA9IHYyXzM7XHJcbiAgICAgICAgICAgICAgICBDb3VudCA9IDI7XHJcbiAgICAgICAgICAgICAgICBWWzFdID0gVlsyXTtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gdzIgcmVnaW9uXHJcbiAgICAgICAgICAgIGlmIChkMTJfMSA8PSAwLjBmICYmIGQyM18yIDw9IDAuMGYpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIFNpbXBsZXhWZXJ0ZXggdjFfNCA9IFZbMV07XHJcbiAgICAgICAgICAgICAgICB2MV80LkEgPSAxLjBmO1xyXG4gICAgICAgICAgICAgICAgVlsxXSA9IHYxXzQ7XHJcbiAgICAgICAgICAgICAgICBDb3VudCA9IDE7XHJcbiAgICAgICAgICAgICAgICBWWzBdID0gVlsxXTtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gdzMgcmVnaW9uXHJcbiAgICAgICAgICAgIGlmIChkMTNfMSA8PSAwLjBmICYmIGQyM18xIDw9IDAuMGYpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIFNpbXBsZXhWZXJ0ZXggdjJfNSA9IFZbMl07XHJcbiAgICAgICAgICAgICAgICB2Ml81LkEgPSAxLjBmO1xyXG4gICAgICAgICAgICAgICAgVlsyXSA9IHYyXzU7XHJcbiAgICAgICAgICAgICAgICBDb3VudCA9IDE7XHJcbiAgICAgICAgICAgICAgICBWWzBdID0gVlsyXTtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gZTIzXHJcbiAgICAgICAgICAgIGlmIChkMjNfMSA+IDAuMGYgJiYgZDIzXzIgPiAwLjBmICYmIGQxMjNfMSA8PSAwLjBmKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBmbG9hdCBpbnZfZDIzID0gMS4wZiAvIChkMjNfMSArIGQyM18yKTtcclxuICAgICAgICAgICAgICAgIFNpbXBsZXhWZXJ0ZXggdjFfNiA9IFZbMV07XHJcbiAgICAgICAgICAgICAgICBTaW1wbGV4VmVydGV4IHYyXzYgPSBWWzJdO1xyXG4gICAgICAgICAgICAgICAgdjFfNi5BID0gZDIzXzEgKiBpbnZfZDIzO1xyXG4gICAgICAgICAgICAgICAgdjJfNi5BID0gZDIzXzIgKiBpbnZfZDIzO1xyXG4gICAgICAgICAgICAgICAgVlsxXSA9IHYxXzY7XHJcbiAgICAgICAgICAgICAgICBWWzJdID0gdjJfNjtcclxuICAgICAgICAgICAgICAgIENvdW50ID0gMjtcclxuICAgICAgICAgICAgICAgIFZbMF0gPSBWWzJdO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBNdXN0IGJlIGluIHRyaWFuZ2xlMTIzXHJcbiAgICAgICAgICAgIGZsb2F0IGludl9kMTIzID0gMS4wZiAvIChkMTIzXzEgKyBkMTIzXzIgKyBkMTIzXzMpO1xyXG4gICAgICAgICAgICBTaW1wbGV4VmVydGV4IHYwXzcgPSBWWzBdO1xyXG4gICAgICAgICAgICBTaW1wbGV4VmVydGV4IHYxXzcgPSBWWzFdO1xyXG4gICAgICAgICAgICBTaW1wbGV4VmVydGV4IHYyXzcgPSBWWzJdO1xyXG4gICAgICAgICAgICB2MF83LkEgPSBkMTIzXzEgKiBpbnZfZDEyMztcclxuICAgICAgICAgICAgdjFfNy5BID0gZDEyM18yICogaW52X2QxMjM7XHJcbiAgICAgICAgICAgIHYyXzcuQSA9IGQxMjNfMyAqIGludl9kMTIzO1xyXG4gICAgICAgICAgICBWWzBdID0gdjBfNztcclxuICAgICAgICAgICAgVlsxXSA9IHYxXzc7XHJcbiAgICAgICAgICAgIFZbMl0gPSB2Ml83O1xyXG4gICAgICAgICAgICBDb3VudCA9IDM7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBzdGF0aWMgY2xhc3MgRGlzdGFuY2VcclxuICAgIHtcclxuICAgICAgICBwdWJsaWMgc3RhdGljIGludCBHSktDYWxscywgR0pLSXRlcnMsIEdKS01heEl0ZXJzO1xyXG5cclxuICAgICAgICBwdWJsaWMgc3RhdGljIHZvaWQgQ29tcHV0ZURpc3RhbmNlKG91dCBEaXN0YW5jZU91dHB1dCBvdXRwdXQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdXQgU2ltcGxleENhY2hlIGNhY2hlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgRGlzdGFuY2VJbnB1dCBpbnB1dClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGNhY2hlID0gbmV3IFNpbXBsZXhDYWNoZSgpO1xyXG4gICAgICAgICAgICArK0dKS0NhbGxzO1xyXG5cclxuICAgICAgICAgICAgLy8gSW5pdGlhbGl6ZSB0aGUgc2ltcGxleC5cclxuICAgICAgICAgICAgU2ltcGxleCBzaW1wbGV4ID0gbmV3IFNpbXBsZXgoKTtcclxuICAgICAgICAgICAgc2ltcGxleC5SZWFkQ2FjaGUocmVmIGNhY2hlLCBpbnB1dC5Qcm94eUEsIHJlZiBpbnB1dC5UcmFuc2Zvcm1BLCBpbnB1dC5Qcm94eUIsIHJlZiBpbnB1dC5UcmFuc2Zvcm1CKTtcclxuXHJcbiAgICAgICAgICAgIC8vIEdldCBzaW1wbGV4IHZlcnRpY2VzIGFzIGFuIGFycmF5LlxyXG4gICAgICAgICAgICBjb25zdCBpbnQga19tYXhJdGVycyA9IDIwO1xyXG5cclxuICAgICAgICAgICAgLy8gVGhlc2Ugc3RvcmUgdGhlIHZlcnRpY2VzIG9mIHRoZSBsYXN0IHNpbXBsZXggc28gdGhhdCB3ZVxyXG4gICAgICAgICAgICAvLyBjYW4gY2hlY2sgZm9yIGR1cGxpY2F0ZXMgYW5kIHByZXZlbnQgY3ljbGluZy5cclxuICAgICAgICAgICAgRml4ZWRBcnJheTM8aW50PiBzYXZlQSA9IG5ldyBGaXhlZEFycmF5MzxpbnQ+KCk7XHJcbiAgICAgICAgICAgIEZpeGVkQXJyYXkzPGludD4gc2F2ZUIgPSBuZXcgRml4ZWRBcnJheTM8aW50PigpO1xyXG5cclxuICAgICAgICAgICAgVmVjdG9yMiBjbG9zZXN0UG9pbnQgPSBzaW1wbGV4LkdldENsb3Nlc3RQb2ludCgpO1xyXG4gICAgICAgICAgICBmbG9hdCBkaXN0YW5jZVNxcjEgPSBjbG9zZXN0UG9pbnQuTGVuZ3RoU3F1YXJlZCgpO1xyXG4gICAgICAgICAgICBmbG9hdCBkaXN0YW5jZVNxcjIgPSBkaXN0YW5jZVNxcjE7XHJcblxyXG4gICAgICAgICAgICAvLyBNYWluIGl0ZXJhdGlvbiBsb29wLlxyXG4gICAgICAgICAgICBpbnQgaXRlciA9IDA7XHJcbiAgICAgICAgICAgIHdoaWxlIChpdGVyIDwga19tYXhJdGVycylcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgLy8gQ29weSBzaW1wbGV4IHNvIHdlIGNhbiBpZGVudGlmeSBkdXBsaWNhdGVzLlxyXG4gICAgICAgICAgICAgICAgaW50IHNhdmVDb3VudCA9IHNpbXBsZXguQ291bnQ7XHJcbiAgICAgICAgICAgICAgICBmb3IgKGludCBpID0gMDsgaSA8IHNhdmVDb3VudDsgKytpKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIHNhdmVBW2ldID0gc2ltcGxleC5WW2ldLkluZGV4QTtcclxuICAgICAgICAgICAgICAgICAgICBzYXZlQltpXSA9IHNpbXBsZXguVltpXS5JbmRleEI7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgc3dpdGNoIChzaW1wbGV4LkNvdW50KVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMjpcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2ltcGxleC5Tb2x2ZTIoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMzpcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2ltcGxleC5Tb2x2ZTMoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIERlYnVnLkFzc2VydChmYWxzZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIC8vIElmIHdlIGhhdmUgMyBwb2ludHMsIHRoZW4gdGhlIG9yaWdpbiBpcyBpbiB0aGUgY29ycmVzcG9uZGluZyB0cmlhbmdsZS5cclxuICAgICAgICAgICAgICAgIGlmIChzaW1wbGV4LkNvdW50ID09IDMpXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gQ29tcHV0ZSBjbG9zZXN0IHBvaW50LlxyXG4gICAgICAgICAgICAgICAgVmVjdG9yMiBwID0gc2ltcGxleC5HZXRDbG9zZXN0UG9pbnQoKTtcclxuICAgICAgICAgICAgICAgIGRpc3RhbmNlU3FyMiA9IHAuTGVuZ3RoU3F1YXJlZCgpO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIEVuc3VyZSBwcm9ncmVzc1xyXG4gICAgICAgICAgICAgICAgaWYgKGRpc3RhbmNlU3FyMiA+PSBkaXN0YW5jZVNxcjEpXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy9icmVhaztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGRpc3RhbmNlU3FyMSA9IGRpc3RhbmNlU3FyMjtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBHZXQgc2VhcmNoIGRpcmVjdGlvbi5cclxuICAgICAgICAgICAgICAgIFZlY3RvcjIgZCA9IHNpbXBsZXguR2V0U2VhcmNoRGlyZWN0aW9uKCk7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gRW5zdXJlIHRoZSBzZWFyY2ggZGlyZWN0aW9uIGlzIG51bWVyaWNhbGx5IGZpdC5cclxuICAgICAgICAgICAgICAgIGlmIChkLkxlbmd0aFNxdWFyZWQoKSA8IFNldHRpbmdzLkVwc2lsb24gKiBTZXR0aW5ncy5FcHNpbG9uKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIFRoZSBvcmlnaW4gaXMgcHJvYmFibHkgY29udGFpbmVkIGJ5IGEgbGluZSBzZWdtZW50XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gb3IgdHJpYW5nbGUuIFRodXMgdGhlIHNoYXBlcyBhcmUgb3ZlcmxhcHBlZC5cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gV2UgY2FuJ3QgcmV0dXJuIHplcm8gaGVyZSBldmVuIHRob3VnaCB0aGVyZSBtYXkgYmUgb3ZlcmxhcC5cclxuICAgICAgICAgICAgICAgICAgICAvLyBJbiBjYXNlIHRoZSBzaW1wbGV4IGlzIGEgcG9pbnQsIHNlZ21lbnQsIG9yIHRyaWFuZ2xlIGl0IGlzIGRpZmZpY3VsdFxyXG4gICAgICAgICAgICAgICAgICAgIC8vIHRvIGRldGVybWluZSBpZiB0aGUgb3JpZ2luIGlzIGNvbnRhaW5lZCBpbiB0aGUgQ1NPIG9yIHZlcnkgY2xvc2UgdG8gaXQuXHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gQ29tcHV0ZSBhIHRlbnRhdGl2ZSBuZXcgc2ltcGxleCB2ZXJ0ZXggdXNpbmcgc3VwcG9ydCBwb2ludHMuXHJcbiAgICAgICAgICAgICAgICBTaW1wbGV4VmVydGV4IHZlcnRleCA9IHNpbXBsZXguVltzaW1wbGV4LkNvdW50XTtcclxuICAgICAgICAgICAgICAgIHZlcnRleC5JbmRleEEgPSBpbnB1dC5Qcm94eUEuR2V0U3VwcG9ydChNYXRoVXRpbHMuTXVsdGlwbHlUKHJlZiBpbnB1dC5UcmFuc2Zvcm1BLlIsIC1kKSk7XHJcbiAgICAgICAgICAgICAgICB2ZXJ0ZXguV0EgPSBNYXRoVXRpbHMuTXVsdGlwbHkocmVmIGlucHV0LlRyYW5zZm9ybUEsIGlucHV0LlByb3h5QS5WZXJ0aWNlc1t2ZXJ0ZXguSW5kZXhBXSk7XHJcblxyXG4gICAgICAgICAgICAgICAgdmVydGV4LkluZGV4QiA9IGlucHV0LlByb3h5Qi5HZXRTdXBwb3J0KE1hdGhVdGlscy5NdWx0aXBseVQocmVmIGlucHV0LlRyYW5zZm9ybUIuUiwgZCkpO1xyXG4gICAgICAgICAgICAgICAgdmVydGV4LldCID0gTWF0aFV0aWxzLk11bHRpcGx5KHJlZiBpbnB1dC5UcmFuc2Zvcm1CLCBpbnB1dC5Qcm94eUIuVmVydGljZXNbdmVydGV4LkluZGV4Ql0pO1xyXG4gICAgICAgICAgICAgICAgdmVydGV4LlcgPSB2ZXJ0ZXguV0IgLSB2ZXJ0ZXguV0E7XHJcbiAgICAgICAgICAgICAgICBzaW1wbGV4LlZbc2ltcGxleC5Db3VudF0gPSB2ZXJ0ZXg7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gSXRlcmF0aW9uIGNvdW50IGlzIGVxdWF0ZWQgdG8gdGhlIG51bWJlciBvZiBzdXBwb3J0IHBvaW50IGNhbGxzLlxyXG4gICAgICAgICAgICAgICAgKytpdGVyO1xyXG4gICAgICAgICAgICAgICAgKytHSktJdGVycztcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBDaGVjayBmb3IgZHVwbGljYXRlIHN1cHBvcnQgcG9pbnRzLiBUaGlzIGlzIHRoZSBtYWluIHRlcm1pbmF0aW9uIGNyaXRlcmlhLlxyXG4gICAgICAgICAgICAgICAgYm9vbCBkdXBsaWNhdGUgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgIGZvciAoaW50IGkgPSAwOyBpIDwgc2F2ZUNvdW50OyArK2kpXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZlcnRleC5JbmRleEEgPT0gc2F2ZUFbaV0gJiYgdmVydGV4LkluZGV4QiA9PSBzYXZlQltpXSlcclxuICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGR1cGxpY2F0ZSA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAvLyBJZiB3ZSBmb3VuZCBhIGR1cGxpY2F0ZSBzdXBwb3J0IHBvaW50IHdlIG11c3QgZXhpdCB0byBhdm9pZCBjeWNsaW5nLlxyXG4gICAgICAgICAgICAgICAgaWYgKGR1cGxpY2F0ZSlcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAvLyBOZXcgdmVydGV4IGlzIG9rIGFuZCBuZWVkZWQuXHJcbiAgICAgICAgICAgICAgICArK3NpbXBsZXguQ291bnQ7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIEdKS01heEl0ZXJzID0gTWF0aC5NYXgoR0pLTWF4SXRlcnMsIGl0ZXIpO1xyXG5cclxuICAgICAgICAgICAgLy8gUHJlcGFyZSBvdXRwdXQuXHJcbiAgICAgICAgICAgIHNpbXBsZXguR2V0V2l0bmVzc1BvaW50cyhvdXQgb3V0cHV0LlBvaW50QSwgb3V0IG91dHB1dC5Qb2ludEIpO1xyXG4gICAgICAgICAgICBvdXRwdXQuRGlzdGFuY2UgPSAob3V0cHV0LlBvaW50QSAtIG91dHB1dC5Qb2ludEIpLkxlbmd0aCgpO1xyXG4gICAgICAgICAgICBvdXRwdXQuSXRlcmF0aW9ucyA9IGl0ZXI7XHJcblxyXG4gICAgICAgICAgICAvLyBDYWNoZSB0aGUgc2ltcGxleC5cclxuICAgICAgICAgICAgc2ltcGxleC5Xcml0ZUNhY2hlKHJlZiBjYWNoZSk7XHJcblxyXG4gICAgICAgICAgICAvLyBBcHBseSByYWRpaSBpZiByZXF1ZXN0ZWQuXHJcbiAgICAgICAgICAgIGlmIChpbnB1dC5Vc2VSYWRpaSlcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgZmxvYXQgckEgPSBpbnB1dC5Qcm94eUEuUmFkaXVzO1xyXG4gICAgICAgICAgICAgICAgZmxvYXQgckIgPSBpbnB1dC5Qcm94eUIuUmFkaXVzO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmIChvdXRwdXQuRGlzdGFuY2UgPiByQSArIHJCICYmIG91dHB1dC5EaXN0YW5jZSA+IFNldHRpbmdzLkVwc2lsb24pXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gU2hhcGVzIGFyZSBzdGlsbCBubyBvdmVybGFwcGVkLlxyXG4gICAgICAgICAgICAgICAgICAgIC8vIE1vdmUgdGhlIHdpdG5lc3MgcG9pbnRzIHRvIHRoZSBvdXRlciBzdXJmYWNlLlxyXG4gICAgICAgICAgICAgICAgICAgIG91dHB1dC5EaXN0YW5jZSAtPSByQSArIHJCO1xyXG4gICAgICAgICAgICAgICAgICAgIFZlY3RvcjIgbm9ybWFsID0gb3V0cHV0LlBvaW50QiAtIG91dHB1dC5Qb2ludEE7XHJcbiAgICAgICAgICAgICAgICAgICAgbm9ybWFsLk5vcm1hbGl6ZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgIG91dHB1dC5Qb2ludEEgKz0gckEgKiBub3JtYWw7XHJcbiAgICAgICAgICAgICAgICAgICAgb3V0cHV0LlBvaW50QiAtPSByQiAqIG5vcm1hbDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBTaGFwZXMgYXJlIG92ZXJsYXBwZWQgd2hlbiByYWRpaSBhcmUgY29uc2lkZXJlZC5cclxuICAgICAgICAgICAgICAgICAgICAvLyBNb3ZlIHRoZSB3aXRuZXNzIHBvaW50cyB0byB0aGUgbWlkZGxlLlxyXG4gICAgICAgICAgICAgICAgICAgIFZlY3RvcjIgcCA9IDAuNWYgKiAob3V0cHV0LlBvaW50QSArIG91dHB1dC5Qb2ludEIpO1xyXG4gICAgICAgICAgICAgICAgICAgIG91dHB1dC5Qb2ludEEgPSBwO1xyXG4gICAgICAgICAgICAgICAgICAgIG91dHB1dC5Qb2ludEIgPSBwO1xyXG4gICAgICAgICAgICAgICAgICAgIG91dHB1dC5EaXN0YW5jZSA9IDAuMGY7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbn0iLCIvKlxyXG4qIEZhcnNlZXIgUGh5c2ljcyBFbmdpbmUgYmFzZWQgb24gQm94MkQuWE5BIHBvcnQ6XHJcbiogQ29weXJpZ2h0IChjKSAyMDEwIElhbiBRdmlzdFxyXG4qIFxyXG4qIEJveDJELlhOQSBwb3J0IG9mIEJveDJEOlxyXG4qIENvcHlyaWdodCAoYykgMjAwOSBCcmFuZG9uIEZ1cnR3YW5nbGVyLCBOYXRoYW4gRnVydHdhbmdsZXJcclxuKlxyXG4qIE9yaWdpbmFsIHNvdXJjZSBCb3gyRDpcclxuKiBDb3B5cmlnaHQgKGMpIDIwMDYtMjAwOSBFcmluIENhdHRvIGh0dHA6Ly93d3cuZ3BoeXNpY3MuY29tIFxyXG4qIFxyXG4qIFRoaXMgc29mdHdhcmUgaXMgcHJvdmlkZWQgJ2FzLWlzJywgd2l0aG91dCBhbnkgZXhwcmVzcyBvciBpbXBsaWVkIFxyXG4qIHdhcnJhbnR5LiAgSW4gbm8gZXZlbnQgd2lsbCB0aGUgYXV0aG9ycyBiZSBoZWxkIGxpYWJsZSBmb3IgYW55IGRhbWFnZXMgXHJcbiogYXJpc2luZyBmcm9tIHRoZSB1c2Ugb2YgdGhpcyBzb2Z0d2FyZS4gXHJcbiogUGVybWlzc2lvbiBpcyBncmFudGVkIHRvIGFueW9uZSB0byB1c2UgdGhpcyBzb2Z0d2FyZSBmb3IgYW55IHB1cnBvc2UsIFxyXG4qIGluY2x1ZGluZyBjb21tZXJjaWFsIGFwcGxpY2F0aW9ucywgYW5kIHRvIGFsdGVyIGl0IGFuZCByZWRpc3RyaWJ1dGUgaXQgXHJcbiogZnJlZWx5LCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgcmVzdHJpY3Rpb25zOiBcclxuKiAxLiBUaGUgb3JpZ2luIG9mIHRoaXMgc29mdHdhcmUgbXVzdCBub3QgYmUgbWlzcmVwcmVzZW50ZWQ7IHlvdSBtdXN0IG5vdCBcclxuKiBjbGFpbSB0aGF0IHlvdSB3cm90ZSB0aGUgb3JpZ2luYWwgc29mdHdhcmUuIElmIHlvdSB1c2UgdGhpcyBzb2Z0d2FyZSBcclxuKiBpbiBhIHByb2R1Y3QsIGFuIGFja25vd2xlZGdtZW50IGluIHRoZSBwcm9kdWN0IGRvY3VtZW50YXRpb24gd291bGQgYmUgXHJcbiogYXBwcmVjaWF0ZWQgYnV0IGlzIG5vdCByZXF1aXJlZC4gXHJcbiogMi4gQWx0ZXJlZCBzb3VyY2UgdmVyc2lvbnMgbXVzdCBiZSBwbGFpbmx5IG1hcmtlZCBhcyBzdWNoLCBhbmQgbXVzdCBub3QgYmUgXHJcbiogbWlzcmVwcmVzZW50ZWQgYXMgYmVpbmcgdGhlIG9yaWdpbmFsIHNvZnR3YXJlLiBcclxuKiAzLiBUaGlzIG5vdGljZSBtYXkgbm90IGJlIHJlbW92ZWQgb3IgYWx0ZXJlZCBmcm9tIGFueSBzb3VyY2UgZGlzdHJpYnV0aW9uLiBcclxuKi9cclxuXHJcbnVzaW5nIFN5c3RlbTtcclxudXNpbmcgU3lzdGVtLkNvbGxlY3Rpb25zLkdlbmVyaWM7XHJcbnVzaW5nIFN5c3RlbS5EaWFnbm9zdGljcztcclxudXNpbmcgRmFyc2VlclBoeXNpY3MuQ29tbW9uO1xyXG51c2luZyBNaWNyb3NvZnQuWG5hLkZyYW1ld29yaztcclxuXHJcbm5hbWVzcGFjZSBGYXJzZWVyUGh5c2ljcy5Db2xsaXNpb25cclxue1xyXG4gICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgLy8vIEEgbm9kZSBpbiB0aGUgZHluYW1pYyB0cmVlLiBUaGUgY2xpZW50IGRvZXMgbm90IGludGVyYWN0IHdpdGggdGhpcyBkaXJlY3RseS5cclxuICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICBpbnRlcm5hbCBzdHJ1Y3QgRHluYW1pY1RyZWVOb2RlPFQ+XHJcbiAgICB7XHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBUaGlzIGlzIHRoZSBmYXR0ZW5lZCBBQUJCLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgaW50ZXJuYWwgQUFCQiBBQUJCO1xyXG5cclxuICAgICAgICBpbnRlcm5hbCBpbnQgQ2hpbGQxO1xyXG4gICAgICAgIGludGVybmFsIGludCBDaGlsZDI7XHJcblxyXG4gICAgICAgIGludGVybmFsIGludCBMZWFmQ291bnQ7XHJcbiAgICAgICAgaW50ZXJuYWwgaW50IFBhcmVudE9yTmV4dDtcclxuICAgICAgICBpbnRlcm5hbCBUIFVzZXJEYXRhO1xyXG5cclxuICAgICAgICBpbnRlcm5hbCBib29sIElzTGVhZigpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gQ2hpbGQxID09IER5bmFtaWNUcmVlPFQ+Lk51bGxOb2RlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAvLy8gQSBkeW5hbWljIHRyZWUgYXJyYW5nZXMgZGF0YSBpbiBhIGJpbmFyeSB0cmVlIHRvIGFjY2VsZXJhdGVcclxuICAgIC8vLyBxdWVyaWVzIHN1Y2ggYXMgdm9sdW1lIHF1ZXJpZXMgYW5kIHJheSBjYXN0cy4gTGVhZnMgYXJlIHByb3hpZXNcclxuICAgIC8vLyB3aXRoIGFuIEFBQkIuIEluIHRoZSB0cmVlIHdlIGV4cGFuZCB0aGUgcHJveHkgQUFCQiBieSBTZXR0aW5ncy5iMl9mYXRBQUJCRmFjdG9yXHJcbiAgICAvLy8gc28gdGhhdCB0aGUgcHJveHkgQUFCQiBpcyBiaWdnZXIgdGhhbiB0aGUgY2xpZW50IG9iamVjdC4gVGhpcyBhbGxvd3MgdGhlIGNsaWVudFxyXG4gICAgLy8vIG9iamVjdCB0byBtb3ZlIGJ5IHNtYWxsIGFtb3VudHMgd2l0aG91dCB0cmlnZ2VyaW5nIGEgdHJlZSB1cGRhdGUuXHJcbiAgICAvLy9cclxuICAgIC8vLyBOb2RlcyBhcmUgcG9vbGVkIGFuZCByZWxvY2F0YWJsZSwgc28gd2UgdXNlIG5vZGUgaW5kaWNlcyByYXRoZXIgdGhhbiBwb2ludGVycy5cclxuICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICBwdWJsaWMgY2xhc3MgRHluYW1pY1RyZWU8VD5cclxuICAgIHtcclxuICAgICAgICBpbnRlcm5hbCBjb25zdCBpbnQgTnVsbE5vZGUgPSAtMTtcclxuICAgICAgICBwcml2YXRlIHN0YXRpYyBTdGFjazxpbnQ+IF9zdGFjayA9IG5ldyBTdGFjazxpbnQ+KDI1Nik7XHJcbiAgICAgICAgcHJpdmF0ZSBpbnQgX2ZyZWVMaXN0O1xyXG4gICAgICAgIHByaXZhdGUgaW50IF9pbnNlcnRpb25Db3VudDtcclxuICAgICAgICBwcml2YXRlIGludCBfbm9kZUNhcGFjaXR5O1xyXG4gICAgICAgIHByaXZhdGUgaW50IF9ub2RlQ291bnQ7XHJcbiAgICAgICAgcHJpdmF0ZSBEeW5hbWljVHJlZU5vZGU8VD5bXSBfbm9kZXM7XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gVGhpcyBpcyB1c2VkIGluY3JlbWVudGFsbHkgdHJhdmVyc2UgdGhlIHRyZWUgZm9yIHJlLWJhbGFuY2luZy5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIHByaXZhdGUgaW50IF9wYXRoO1xyXG5cclxuICAgICAgICBwcml2YXRlIGludCBfcm9vdDtcclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBDb25zdHJ1Y3RpbmcgdGhlIHRyZWUgaW5pdGlhbGl6ZXMgdGhlIG5vZGUgcG9vbC5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIHB1YmxpYyBEeW5hbWljVHJlZSgpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBfcm9vdCA9IE51bGxOb2RlO1xyXG5cclxuICAgICAgICAgICAgX25vZGVDYXBhY2l0eSA9IDE2O1xyXG4gICAgICAgICAgICBfbm9kZXMgPSBuZXcgRHluYW1pY1RyZWVOb2RlPFQ+W19ub2RlQ2FwYWNpdHldO1xyXG5cclxuICAgICAgICAgICAgLy8gQnVpbGQgYSBsaW5rZWQgbGlzdCBmb3IgdGhlIGZyZWUgbGlzdC5cclxuICAgICAgICAgICAgZm9yIChpbnQgaSA9IDA7IGkgPCBfbm9kZUNhcGFjaXR5IC0gMTsgKytpKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBfbm9kZXNbaV0uUGFyZW50T3JOZXh0ID0gaSArIDE7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgX25vZGVzW19ub2RlQ2FwYWNpdHkgLSAxXS5QYXJlbnRPck5leHQgPSBOdWxsTm9kZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gQ3JlYXRlIGEgcHJveHkgaW4gdGhlIHRyZWUgYXMgYSBsZWFmIG5vZGUuIFdlIHJldHVybiB0aGUgaW5kZXhcclxuICAgICAgICAvLy8gb2YgdGhlIG5vZGUgaW5zdGVhZCBvZiBhIHBvaW50ZXIgc28gdGhhdCB3ZSBjYW4gZ3Jvd1xyXG4gICAgICAgIC8vLyB0aGUgbm9kZSBwb29sLiAgICAgICAgXHJcbiAgICAgICAgLy8vIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwiYWFiYlwiPlRoZSBhYWJiLjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwidXNlckRhdGFcIj5UaGUgdXNlciBkYXRhLjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxyZXR1cm5zPkluZGV4IG9mIHRoZSBjcmVhdGVkIHByb3h5PC9yZXR1cm5zPlxyXG4gICAgICAgIHB1YmxpYyBpbnQgQWRkUHJveHkocmVmIEFBQkIgYWFiYiwgVCB1c2VyRGF0YSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGludCBwcm94eUlkID0gQWxsb2NhdGVOb2RlKCk7XHJcblxyXG4gICAgICAgICAgICAvLyBGYXR0ZW4gdGhlIGFhYmIuXHJcbiAgICAgICAgICAgIFZlY3RvcjIgciA9IG5ldyBWZWN0b3IyKFNldHRpbmdzLkFBQkJFeHRlbnNpb24sIFNldHRpbmdzLkFBQkJFeHRlbnNpb24pO1xyXG4gICAgICAgICAgICBfbm9kZXNbcHJveHlJZF0uQUFCQi5Mb3dlckJvdW5kID0gYWFiYi5Mb3dlckJvdW5kIC0gcjtcclxuICAgICAgICAgICAgX25vZGVzW3Byb3h5SWRdLkFBQkIuVXBwZXJCb3VuZCA9IGFhYmIuVXBwZXJCb3VuZCArIHI7XHJcbiAgICAgICAgICAgIF9ub2Rlc1twcm94eUlkXS5Vc2VyRGF0YSA9IHVzZXJEYXRhO1xyXG4gICAgICAgICAgICBfbm9kZXNbcHJveHlJZF0uTGVhZkNvdW50ID0gMTtcclxuXHJcbiAgICAgICAgICAgIEluc2VydExlYWYocHJveHlJZCk7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gcHJveHlJZDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gRGVzdHJveSBhIHByb3h5LiBUaGlzIGFzc2VydHMgaWYgdGhlIGlkIGlzIGludmFsaWQuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJwcm94eUlkXCI+VGhlIHByb3h5IGlkLjwvcGFyYW0+XHJcbiAgICAgICAgcHVibGljIHZvaWQgUmVtb3ZlUHJveHkoaW50IHByb3h5SWQpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBEZWJ1Zy5Bc3NlcnQoMCA8PSBwcm94eUlkICYmIHByb3h5SWQgPCBfbm9kZUNhcGFjaXR5KTtcclxuICAgICAgICAgICAgRGVidWcuQXNzZXJ0KF9ub2Rlc1twcm94eUlkXS5Jc0xlYWYoKSk7XHJcblxyXG4gICAgICAgICAgICBSZW1vdmVMZWFmKHByb3h5SWQpO1xyXG4gICAgICAgICAgICBGcmVlTm9kZShwcm94eUlkKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gTW92ZSBhIHByb3h5IHdpdGggYSBzd2VwdGVkIEFBQkIuIElmIHRoZSBwcm94eSBoYXMgbW92ZWQgb3V0c2lkZSBvZiBpdHMgZmF0dGVuZWQgQUFCQixcclxuICAgICAgICAvLy8gdGhlbiB0aGUgcHJveHkgaXMgcmVtb3ZlZCBmcm9tIHRoZSB0cmVlIGFuZCByZS1pbnNlcnRlZC4gT3RoZXJ3aXNlXHJcbiAgICAgICAgLy8vIHRoZSBmdW5jdGlvbiByZXR1cm5zIGltbWVkaWF0ZWx5LlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwicHJveHlJZFwiPlRoZSBwcm94eSBpZC48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cImFhYmJcIj5UaGUgYWFiYi48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cImRpc3BsYWNlbWVudFwiPlRoZSBkaXNwbGFjZW1lbnQuPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHJldHVybnM+dHJ1ZSBpZiB0aGUgcHJveHkgd2FzIHJlLWluc2VydGVkLjwvcmV0dXJucz5cclxuICAgICAgICBwdWJsaWMgYm9vbCBNb3ZlUHJveHkoaW50IHByb3h5SWQsIHJlZiBBQUJCIGFhYmIsIFZlY3RvcjIgZGlzcGxhY2VtZW50KVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgRGVidWcuQXNzZXJ0KDAgPD0gcHJveHlJZCAmJiBwcm94eUlkIDwgX25vZGVDYXBhY2l0eSk7XHJcblxyXG4gICAgICAgICAgICBEZWJ1Zy5Bc3NlcnQoX25vZGVzW3Byb3h5SWRdLklzTGVhZigpKTtcclxuXHJcbiAgICAgICAgICAgIGlmIChfbm9kZXNbcHJveHlJZF0uQUFCQi5Db250YWlucyhyZWYgYWFiYikpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgUmVtb3ZlTGVhZihwcm94eUlkKTtcclxuXHJcbiAgICAgICAgICAgIC8vIEV4dGVuZCBBQUJCLlxyXG4gICAgICAgICAgICBBQUJCIGIgPSBhYWJiO1xyXG4gICAgICAgICAgICBWZWN0b3IyIHIgPSBuZXcgVmVjdG9yMihTZXR0aW5ncy5BQUJCRXh0ZW5zaW9uLCBTZXR0aW5ncy5BQUJCRXh0ZW5zaW9uKTtcclxuICAgICAgICAgICAgYi5Mb3dlckJvdW5kID0gYi5Mb3dlckJvdW5kIC0gcjtcclxuICAgICAgICAgICAgYi5VcHBlckJvdW5kID0gYi5VcHBlckJvdW5kICsgcjtcclxuXHJcbiAgICAgICAgICAgIC8vIFByZWRpY3QgQUFCQiBkaXNwbGFjZW1lbnQuXHJcbiAgICAgICAgICAgIFZlY3RvcjIgZCA9IFNldHRpbmdzLkFBQkJNdWx0aXBsaWVyICogZGlzcGxhY2VtZW50O1xyXG5cclxuICAgICAgICAgICAgaWYgKGQuWCA8IDAuMGYpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGIuTG93ZXJCb3VuZC5YICs9IGQuWDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGIuVXBwZXJCb3VuZC5YICs9IGQuWDtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKGQuWSA8IDAuMGYpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGIuTG93ZXJCb3VuZC5ZICs9IGQuWTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGIuVXBwZXJCb3VuZC5ZICs9IGQuWTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgX25vZGVzW3Byb3h5SWRdLkFBQkIgPSBiO1xyXG5cclxuICAgICAgICAgICAgSW5zZXJ0TGVhZihwcm94eUlkKTtcclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIFBlcmZvcm0gc29tZSBpdGVyYXRpb25zIHRvIHJlLWJhbGFuY2UgdGhlIHRyZWUuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJpdGVyYXRpb25zXCI+VGhlIGl0ZXJhdGlvbnMuPC9wYXJhbT5cclxuICAgICAgICBwdWJsaWMgdm9pZCBSZWJhbGFuY2UoaW50IGl0ZXJhdGlvbnMpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBpZiAoX3Jvb3QgPT0gTnVsbE5vZGUpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gUmViYWxhbmNlIHRoZSB0cmVlIGJ5IHJlbW92aW5nIGFuZCByZS1pbnNlcnRpbmcgbGVhdmVzLlxyXG4gICAgICAgICAgICBmb3IgKGludCBpID0gMDsgaSA8IGl0ZXJhdGlvbnM7ICsraSlcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgaW50IG5vZGUgPSBfcm9vdDtcclxuXHJcbiAgICAgICAgICAgICAgICBpbnQgYml0ID0gMDtcclxuICAgICAgICAgICAgICAgIHdoaWxlIChfbm9kZXNbbm9kZV0uSXNMZWFmKCkgPT0gZmFsc2UpXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gQ2hpbGQgc2VsZWN0b3IgYmFzZWQgb24gYSBiaXQgaW4gdGhlIHBhdGhcclxuICAgICAgICAgICAgICAgICAgICBpbnQgc2VsZWN0b3IgPSAoX3BhdGggPj4gYml0KSAmIDE7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIFNlbGVjdCB0aGUgY2hpbGQgbm9kXHJcbiAgICAgICAgICAgICAgICAgICAgbm9kZSA9IChzZWxlY3RvciA9PSAwKSA/IF9ub2Rlc1tub2RlXS5DaGlsZDEgOiBfbm9kZXNbbm9kZV0uQ2hpbGQyO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBLZWVwIGJpdCBiZXR3ZWVuIDAgYW5kIDMxIGJlY2F1c2UgX3BhdGggaGFzIDMyIGJpdHNcclxuICAgICAgICAgICAgICAgICAgICAvLyBiaXQgPSAoYml0ICsgMSkgJSAzMVxyXG4gICAgICAgICAgICAgICAgICAgIGJpdCA9IChiaXQgKyAxKSAmIDB4MUY7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICArK19wYXRoO1xyXG5cclxuICAgICAgICAgICAgICAgIFJlbW92ZUxlYWYobm9kZSk7XHJcbiAgICAgICAgICAgICAgICBJbnNlcnRMZWFmKG5vZGUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIEdldCBwcm94eSB1c2VyIGRhdGEuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHR5cGVwYXJhbSBuYW1lPVwiVFwiPjwvdHlwZXBhcmFtPlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cInByb3h5SWRcIj5UaGUgcHJveHkgaWQuPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHJldHVybnM+dGhlIHByb3h5IHVzZXIgZGF0YSBvciAwIGlmIHRoZSBpZCBpcyBpbnZhbGlkLjwvcmV0dXJucz5cclxuICAgICAgICBwdWJsaWMgVCBHZXRVc2VyRGF0YShpbnQgcHJveHlJZClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIERlYnVnLkFzc2VydCgwIDw9IHByb3h5SWQgJiYgcHJveHlJZCA8IF9ub2RlQ2FwYWNpdHkpO1xyXG4gICAgICAgICAgICByZXR1cm4gX25vZGVzW3Byb3h5SWRdLlVzZXJEYXRhO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBHZXQgdGhlIGZhdCBBQUJCIGZvciBhIHByb3h5LlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwicHJveHlJZFwiPlRoZSBwcm94eSBpZC48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cImZhdEFBQkJcIj5UaGUgZmF0IEFBQkIuPC9wYXJhbT5cclxuICAgICAgICBwdWJsaWMgdm9pZCBHZXRGYXRBQUJCKGludCBwcm94eUlkLCBvdXQgQUFCQiBmYXRBQUJCKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgRGVidWcuQXNzZXJ0KDAgPD0gcHJveHlJZCAmJiBwcm94eUlkIDwgX25vZGVDYXBhY2l0eSk7XHJcbiAgICAgICAgICAgIGZhdEFBQkIgPSBfbm9kZXNbcHJveHlJZF0uQUFCQjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gQ29tcHV0ZSB0aGUgaGVpZ2h0IG9mIHRoZSBiaW5hcnkgdHJlZSBpbiBPKE4pIHRpbWUuIFNob3VsZCBub3QgYmVcclxuICAgICAgICAvLy8gY2FsbGVkIG9mdGVuLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDxyZXR1cm5zPjwvcmV0dXJucz5cclxuICAgICAgICBwdWJsaWMgaW50IENvbXB1dGVIZWlnaHQoKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIENvbXB1dGVIZWlnaHQoX3Jvb3QpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBRdWVyeSBhbiBBQUJCIGZvciBvdmVybGFwcGluZyBwcm94aWVzLiBUaGUgY2FsbGJhY2sgY2xhc3NcclxuICAgICAgICAvLy8gaXMgY2FsbGVkIGZvciBlYWNoIHByb3h5IHRoYXQgb3ZlcmxhcHMgdGhlIHN1cHBsaWVkIEFBQkIuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJjYWxsYmFja1wiPlRoZSBjYWxsYmFjay48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cImFhYmJcIj5UaGUgYWFiYi48L3BhcmFtPlxyXG4gICAgICAgIHB1YmxpYyB2b2lkIFF1ZXJ5KEZ1bmM8aW50LCBib29sPiBjYWxsYmFjaywgcmVmIEFBQkIgYWFiYilcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIF9zdGFjay5DbGVhcigpO1xyXG4gICAgICAgICAgICBfc3RhY2suUHVzaChfcm9vdCk7XHJcblxyXG4gICAgICAgICAgICB3aGlsZSAoX3N0YWNrLkNvdW50ID4gMClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgaW50IG5vZGVJZCA9IF9zdGFjay5Qb3AoKTtcclxuICAgICAgICAgICAgICAgIGlmIChub2RlSWQgPT0gTnVsbE5vZGUpXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgRHluYW1pY1RyZWVOb2RlPFQ+IG5vZGUgPSBfbm9kZXNbbm9kZUlkXTtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoQUFCQi5UZXN0T3ZlcmxhcChyZWYgbm9kZS5BQUJCLCByZWYgYWFiYikpXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5vZGUuSXNMZWFmKCkpXHJcbiAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBib29sIHByb2NlZWQgPSBjYWxsYmFjayhub2RlSWQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocHJvY2VlZCA9PSBmYWxzZSlcclxuICAgICAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF9zdGFjay5QdXNoKG5vZGUuQ2hpbGQxKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgX3N0YWNrLlB1c2gobm9kZS5DaGlsZDIpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBSYXktY2FzdCBhZ2FpbnN0IHRoZSBwcm94aWVzIGluIHRoZSB0cmVlLiBUaGlzIHJlbGllcyBvbiB0aGUgY2FsbGJhY2tcclxuICAgICAgICAvLy8gdG8gcGVyZm9ybSBhIGV4YWN0IHJheS1jYXN0IGluIHRoZSBjYXNlIHdlcmUgdGhlIHByb3h5IGNvbnRhaW5zIGEgU2hhcGUuXHJcbiAgICAgICAgLy8vIFRoZSBjYWxsYmFjayBhbHNvIHBlcmZvcm1zIHRoZSBhbnkgY29sbGlzaW9uIGZpbHRlcmluZy4gVGhpcyBoYXMgcGVyZm9ybWFuY2VcclxuICAgICAgICAvLy8gcm91Z2hseSBlcXVhbCB0byBrICogbG9nKG4pLCB3aGVyZSBrIGlzIHRoZSBudW1iZXIgb2YgY29sbGlzaW9ucyBhbmQgbiBpcyB0aGVcclxuICAgICAgICAvLy8gbnVtYmVyIG9mIHByb3hpZXMgaW4gdGhlIHRyZWUuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJjYWxsYmFja1wiPkEgY2FsbGJhY2sgY2xhc3MgdGhhdCBpcyBjYWxsZWQgZm9yIGVhY2ggcHJveHkgdGhhdCBpcyBoaXQgYnkgdGhlIHJheS48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cImlucHV0XCI+VGhlIHJheS1jYXN0IGlucHV0IGRhdGEuIFRoZSByYXkgZXh0ZW5kcyBmcm9tIHAxIHRvIHAxICsgbWF4RnJhY3Rpb24gKiAocDIgLSBwMSkuPC9wYXJhbT5cclxuICAgICAgICBwdWJsaWMgdm9pZCBSYXlDYXN0KEZ1bmM8UmF5Q2FzdElucHV0LCBpbnQsIGZsb2F0PiBjYWxsYmFjaywgcmVmIFJheUNhc3RJbnB1dCBpbnB1dClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIFZlY3RvcjIgcDEgPSBpbnB1dC5Qb2ludDE7XHJcbiAgICAgICAgICAgIFZlY3RvcjIgcDIgPSBpbnB1dC5Qb2ludDI7XHJcbiAgICAgICAgICAgIFZlY3RvcjIgciA9IHAyIC0gcDE7XHJcbiAgICAgICAgICAgIERlYnVnLkFzc2VydChyLkxlbmd0aFNxdWFyZWQoKSA+IDAuMGYpO1xyXG4gICAgICAgICAgICByLk5vcm1hbGl6ZSgpO1xyXG5cclxuICAgICAgICAgICAgLy8gdiBpcyBwZXJwZW5kaWN1bGFyIHRvIHRoZSBzZWdtZW50LlxyXG4gICAgICAgICAgICBWZWN0b3IyIGFic1YgPSBNYXRoVXRpbHMuQWJzKG5ldyBWZWN0b3IyKC1yLlksIHIuWCkpO1xyXG5cclxuICAgICAgICAgICAgLy8gU2VwYXJhdGluZyBheGlzIGZvciBzZWdtZW50IChHaW5vLCBwODApLlxyXG4gICAgICAgICAgICAvLyB8ZG90KHYsIHAxIC0gYyl8ID4gZG90KHx2fCwgaClcclxuXHJcbiAgICAgICAgICAgIGZsb2F0IG1heEZyYWN0aW9uID0gaW5wdXQuTWF4RnJhY3Rpb247XHJcblxyXG4gICAgICAgICAgICAvLyBCdWlsZCBhIGJvdW5kaW5nIGJveCBmb3IgdGhlIHNlZ21lbnQuXHJcbiAgICAgICAgICAgIEFBQkIgc2VnbWVudEFBQkIgPSBuZXcgQUFCQigpO1xyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBWZWN0b3IyIHQgPSBwMSArIG1heEZyYWN0aW9uICogKHAyIC0gcDEpO1xyXG4gICAgICAgICAgICAgICAgVmVjdG9yMi5NaW4ocmVmIHAxLCByZWYgdCwgb3V0IHNlZ21lbnRBQUJCLkxvd2VyQm91bmQpO1xyXG4gICAgICAgICAgICAgICAgVmVjdG9yMi5NYXgocmVmIHAxLCByZWYgdCwgb3V0IHNlZ21lbnRBQUJCLlVwcGVyQm91bmQpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBfc3RhY2suQ2xlYXIoKTtcclxuICAgICAgICAgICAgX3N0YWNrLlB1c2goX3Jvb3QpO1xyXG5cclxuICAgICAgICAgICAgd2hpbGUgKF9zdGFjay5Db3VudCA+IDApXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGludCBub2RlSWQgPSBfc3RhY2suUG9wKCk7XHJcbiAgICAgICAgICAgICAgICBpZiAobm9kZUlkID09IE51bGxOb2RlKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIER5bmFtaWNUcmVlTm9kZTxUPiBub2RlID0gX25vZGVzW25vZGVJZF07XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKEFBQkIuVGVzdE92ZXJsYXAocmVmIG5vZGUuQUFCQiwgcmVmIHNlZ21lbnRBQUJCKSA9PSBmYWxzZSlcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAvLyBTZXBhcmF0aW5nIGF4aXMgZm9yIHNlZ21lbnQgKEdpbm8sIHA4MCkuXHJcbiAgICAgICAgICAgICAgICAvLyB8ZG90KHYsIHAxIC0gYyl8ID4gZG90KHx2fCwgaClcclxuICAgICAgICAgICAgICAgIFZlY3RvcjIgYyA9IG5vZGUuQUFCQi5DZW50ZXI7XHJcbiAgICAgICAgICAgICAgICBWZWN0b3IyIGggPSBub2RlLkFBQkIuRXh0ZW50cztcclxuICAgICAgICAgICAgICAgIGZsb2F0IHNlcGFyYXRpb24gPSAoZmxvYXQpTWF0aC5BYnMoVmVjdG9yMi5Eb3QobmV3IFZlY3RvcjIoLXIuWSwgci5YKSwgcDEgLSBjKSkgLSBWZWN0b3IyLkRvdChhYnNWLCBoKTtcclxuICAgICAgICAgICAgICAgIGlmIChzZXBhcmF0aW9uID4gMC4wZilcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBpZiAobm9kZS5Jc0xlYWYoKSlcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBSYXlDYXN0SW5wdXQgc3ViSW5wdXQ7XHJcbiAgICAgICAgICAgICAgICAgICAgc3ViSW5wdXQuUG9pbnQxID0gaW5wdXQuUG9pbnQxO1xyXG4gICAgICAgICAgICAgICAgICAgIHN1YklucHV0LlBvaW50MiA9IGlucHV0LlBvaW50MjtcclxuICAgICAgICAgICAgICAgICAgICBzdWJJbnB1dC5NYXhGcmFjdGlvbiA9IG1heEZyYWN0aW9uO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBmbG9hdCB2YWx1ZSA9IGNhbGxiYWNrKHN1YklucHV0LCBub2RlSWQpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWUgPT0gMC4wZilcclxuICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRoZSBjbGllbnQgaGFzIHRlcm1pbmF0ZWQgdGhlIHJheWNhc3QuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA+IDAuMGYpXHJcbiAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBVcGRhdGUgc2VnbWVudCBib3VuZGluZyBib3guXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1heEZyYWN0aW9uID0gdmFsdWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIFZlY3RvcjIgdCA9IHAxICsgbWF4RnJhY3Rpb24gKiAocDIgLSBwMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlZ21lbnRBQUJCLkxvd2VyQm91bmQgPSBWZWN0b3IyLk1pbihwMSwgdCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlZ21lbnRBQUJCLlVwcGVyQm91bmQgPSBWZWN0b3IyLk1heChwMSwgdCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIF9zdGFjay5QdXNoKG5vZGUuQ2hpbGQxKTtcclxuICAgICAgICAgICAgICAgICAgICBfc3RhY2suUHVzaChub2RlLkNoaWxkMik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHByaXZhdGUgaW50IENvdW50TGVhdmVzKGludCBub2RlSWQpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBpZiAobm9kZUlkID09IE51bGxOb2RlKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gMDtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgRGVidWcuQXNzZXJ0KDAgPD0gbm9kZUlkICYmIG5vZGVJZCA8IF9ub2RlQ2FwYWNpdHkpO1xyXG4gICAgICAgICAgICBEeW5hbWljVHJlZU5vZGU8VD4gbm9kZSA9IF9ub2Rlc1tub2RlSWRdO1xyXG5cclxuICAgICAgICAgICAgaWYgKG5vZGUuSXNMZWFmKCkpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIERlYnVnLkFzc2VydChub2RlLkxlYWZDb3VudCA9PSAxKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiAxO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpbnQgY291bnQxID0gQ291bnRMZWF2ZXMobm9kZS5DaGlsZDEpO1xyXG4gICAgICAgICAgICBpbnQgY291bnQyID0gQ291bnRMZWF2ZXMobm9kZS5DaGlsZDIpO1xyXG4gICAgICAgICAgICBpbnQgY291bnQgPSBjb3VudDEgKyBjb3VudDI7XHJcbiAgICAgICAgICAgIERlYnVnLkFzc2VydChjb3VudCA9PSBub2RlLkxlYWZDb3VudCk7XHJcbiAgICAgICAgICAgIHJldHVybiBjb3VudDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHByaXZhdGUgdm9pZCBWYWxpZGF0ZSgpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBDb3VudExlYXZlcyhfcm9vdCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwcml2YXRlIGludCBBbGxvY2F0ZU5vZGUoKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgLy8gRXhwYW5kIHRoZSBub2RlIHBvb2wgYXMgbmVlZGVkLlxyXG4gICAgICAgICAgICBpZiAoX2ZyZWVMaXN0ID09IE51bGxOb2RlKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBEZWJ1Zy5Bc3NlcnQoX25vZGVDb3VudCA9PSBfbm9kZUNhcGFjaXR5KTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBUaGUgZnJlZSBsaXN0IGlzIGVtcHR5LiBSZWJ1aWxkIGEgYmlnZ2VyIHBvb2wuXHJcbiAgICAgICAgICAgICAgICBEeW5hbWljVHJlZU5vZGU8VD5bXSBvbGROb2RlcyA9IF9ub2RlcztcclxuICAgICAgICAgICAgICAgIF9ub2RlQ2FwYWNpdHkgKj0gMjtcclxuICAgICAgICAgICAgICAgIF9ub2RlcyA9IG5ldyBEeW5hbWljVHJlZU5vZGU8VD5bX25vZGVDYXBhY2l0eV07XHJcbiAgICAgICAgICAgICAgICBBcnJheS5Db3B5KG9sZE5vZGVzLCBfbm9kZXMsIF9ub2RlQ291bnQpO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIEJ1aWxkIGEgbGlua2VkIGxpc3QgZm9yIHRoZSBmcmVlIGxpc3QuIFRoZSBwYXJlbnRcclxuICAgICAgICAgICAgICAgIC8vIHBvaW50ZXIgYmVjb21lcyB0aGUgXCJuZXh0XCIgcG9pbnRlci5cclxuICAgICAgICAgICAgICAgIGZvciAoaW50IGkgPSBfbm9kZUNvdW50OyBpIDwgX25vZGVDYXBhY2l0eSAtIDE7ICsraSlcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBfbm9kZXNbaV0uUGFyZW50T3JOZXh0ID0gaSArIDE7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBfbm9kZXNbX25vZGVDYXBhY2l0eSAtIDFdLlBhcmVudE9yTmV4dCA9IE51bGxOb2RlO1xyXG4gICAgICAgICAgICAgICAgX2ZyZWVMaXN0ID0gX25vZGVDb3VudDtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gUGVlbCBhIG5vZGUgb2ZmIHRoZSBmcmVlIGxpc3QuXHJcbiAgICAgICAgICAgIGludCBub2RlSWQgPSBfZnJlZUxpc3Q7XHJcbiAgICAgICAgICAgIF9mcmVlTGlzdCA9IF9ub2Rlc1tub2RlSWRdLlBhcmVudE9yTmV4dDtcclxuICAgICAgICAgICAgX25vZGVzW25vZGVJZF0uUGFyZW50T3JOZXh0ID0gTnVsbE5vZGU7XHJcbiAgICAgICAgICAgIF9ub2Rlc1tub2RlSWRdLkNoaWxkMSA9IE51bGxOb2RlO1xyXG4gICAgICAgICAgICBfbm9kZXNbbm9kZUlkXS5DaGlsZDIgPSBOdWxsTm9kZTtcclxuICAgICAgICAgICAgX25vZGVzW25vZGVJZF0uTGVhZkNvdW50ID0gMDtcclxuICAgICAgICAgICAgKytfbm9kZUNvdW50O1xyXG4gICAgICAgICAgICByZXR1cm4gbm9kZUlkO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHJpdmF0ZSB2b2lkIEZyZWVOb2RlKGludCBub2RlSWQpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBEZWJ1Zy5Bc3NlcnQoMCA8PSBub2RlSWQgJiYgbm9kZUlkIDwgX25vZGVDYXBhY2l0eSk7XHJcbiAgICAgICAgICAgIERlYnVnLkFzc2VydCgwIDwgX25vZGVDb3VudCk7XHJcbiAgICAgICAgICAgIF9ub2Rlc1tub2RlSWRdLlBhcmVudE9yTmV4dCA9IF9mcmVlTGlzdDtcclxuICAgICAgICAgICAgX2ZyZWVMaXN0ID0gbm9kZUlkO1xyXG4gICAgICAgICAgICAtLV9ub2RlQ291bnQ7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwcml2YXRlIHZvaWQgSW5zZXJ0TGVhZihpbnQgbGVhZilcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgICsrX2luc2VydGlvbkNvdW50O1xyXG5cclxuICAgICAgICAgICAgaWYgKF9yb290ID09IE51bGxOb2RlKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBfcm9vdCA9IGxlYWY7XHJcbiAgICAgICAgICAgICAgICBfbm9kZXNbX3Jvb3RdLlBhcmVudE9yTmV4dCA9IE51bGxOb2RlO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBGaW5kIHRoZSBiZXN0IHNpYmxpbmcgZm9yIHRoaXMgbm9kZVxyXG4gICAgICAgICAgICBBQUJCIGxlYWZBQUJCID0gX25vZGVzW2xlYWZdLkFBQkI7XHJcbiAgICAgICAgICAgIGludCBzaWJsaW5nID0gX3Jvb3Q7XHJcbiAgICAgICAgICAgIHdoaWxlIChfbm9kZXNbc2libGluZ10uSXNMZWFmKCkgPT0gZmFsc2UpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGludCBjaGlsZDEgPSBfbm9kZXNbc2libGluZ10uQ2hpbGQxO1xyXG4gICAgICAgICAgICAgICAgaW50IGNoaWxkMiA9IF9ub2Rlc1tzaWJsaW5nXS5DaGlsZDI7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gRXhwYW5kIHRoZSBub2RlJ3MgQUFCQi5cclxuICAgICAgICAgICAgICAgIF9ub2Rlc1tzaWJsaW5nXS5BQUJCLkNvbWJpbmUocmVmIGxlYWZBQUJCKTtcclxuICAgICAgICAgICAgICAgIF9ub2Rlc1tzaWJsaW5nXS5MZWFmQ291bnQgKz0gMTtcclxuXHJcbiAgICAgICAgICAgICAgICBmbG9hdCBzaWJsaW5nQXJlYSA9IF9ub2Rlc1tzaWJsaW5nXS5BQUJCLlBlcmltZXRlcjtcclxuICAgICAgICAgICAgICAgIEFBQkIgcGFyZW50QUFCQiA9IG5ldyBBQUJCKCk7XHJcbiAgICAgICAgICAgICAgICBwYXJlbnRBQUJCLkNvbWJpbmUocmVmIF9ub2Rlc1tzaWJsaW5nXS5BQUJCLCByZWYgbGVhZkFBQkIpO1xyXG4gICAgICAgICAgICAgICAgZmxvYXQgcGFyZW50QXJlYSA9IHBhcmVudEFBQkIuUGVyaW1ldGVyO1xyXG4gICAgICAgICAgICAgICAgZmxvYXQgY29zdDEgPSAyLjBmICogcGFyZW50QXJlYTtcclxuXHJcbiAgICAgICAgICAgICAgICBmbG9hdCBpbmhlcml0YW5jZUNvc3QgPSAyLjBmICogKHBhcmVudEFyZWEgLSBzaWJsaW5nQXJlYSk7XHJcblxyXG4gICAgICAgICAgICAgICAgZmxvYXQgY29zdDI7XHJcbiAgICAgICAgICAgICAgICBpZiAoX25vZGVzW2NoaWxkMV0uSXNMZWFmKCkpXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgQUFCQiBhYWJiID0gbmV3IEFBQkIoKTtcclxuICAgICAgICAgICAgICAgICAgICBhYWJiLkNvbWJpbmUocmVmIGxlYWZBQUJCLCByZWYgX25vZGVzW2NoaWxkMV0uQUFCQik7XHJcbiAgICAgICAgICAgICAgICAgICAgY29zdDIgPSBhYWJiLlBlcmltZXRlciArIGluaGVyaXRhbmNlQ29zdDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBBQUJCIGFhYmIgPSBuZXcgQUFCQigpO1xyXG4gICAgICAgICAgICAgICAgICAgIGFhYmIuQ29tYmluZShyZWYgbGVhZkFBQkIsIHJlZiBfbm9kZXNbY2hpbGQxXS5BQUJCKTtcclxuICAgICAgICAgICAgICAgICAgICBmbG9hdCBvbGRBcmVhID0gX25vZGVzW2NoaWxkMV0uQUFCQi5QZXJpbWV0ZXI7XHJcbiAgICAgICAgICAgICAgICAgICAgZmxvYXQgbmV3QXJlYSA9IGFhYmIuUGVyaW1ldGVyO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvc3QyID0gKG5ld0FyZWEgLSBvbGRBcmVhKSArIGluaGVyaXRhbmNlQ29zdDtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBmbG9hdCBjb3N0MztcclxuICAgICAgICAgICAgICAgIGlmIChfbm9kZXNbY2hpbGQyXS5Jc0xlYWYoKSlcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBBQUJCIGFhYmIgPSBuZXcgQUFCQigpO1xyXG4gICAgICAgICAgICAgICAgICAgIGFhYmIuQ29tYmluZShyZWYgbGVhZkFBQkIsIHJlZiBfbm9kZXNbY2hpbGQyXS5BQUJCKTtcclxuICAgICAgICAgICAgICAgICAgICBjb3N0MyA9IGFhYmIuUGVyaW1ldGVyICsgaW5oZXJpdGFuY2VDb3N0O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIEFBQkIgYWFiYiA9IG5ldyBBQUJCKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgYWFiYi5Db21iaW5lKHJlZiBsZWFmQUFCQiwgcmVmIF9ub2Rlc1tjaGlsZDJdLkFBQkIpO1xyXG4gICAgICAgICAgICAgICAgICAgIGZsb2F0IG9sZEFyZWEgPSBfbm9kZXNbY2hpbGQyXS5BQUJCLlBlcmltZXRlcjtcclxuICAgICAgICAgICAgICAgICAgICBmbG9hdCBuZXdBcmVhID0gYWFiYi5QZXJpbWV0ZXI7XHJcbiAgICAgICAgICAgICAgICAgICAgY29zdDMgPSBuZXdBcmVhIC0gb2xkQXJlYSArIGluaGVyaXRhbmNlQ29zdDtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAvLyBEZXNjZW5kIGFjY29yZGluZyB0byB0aGUgbWluaW11bSBjb3N0LlxyXG4gICAgICAgICAgICAgICAgaWYgKGNvc3QxIDwgY29zdDIgJiYgY29zdDEgPCBjb3N0MylcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAvLyBFeHBhbmQgdGhlIG5vZGUncyBBQUJCIHRvIGFjY291bnQgZm9yIHRoZSBuZXcgbGVhZi5cclxuICAgICAgICAgICAgICAgIF9ub2Rlc1tzaWJsaW5nXS5BQUJCLkNvbWJpbmUocmVmIGxlYWZBQUJCKTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBEZXNjZW5kXHJcbiAgICAgICAgICAgICAgICBpZiAoY29zdDIgPCBjb3N0MylcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBzaWJsaW5nID0gY2hpbGQxO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIHNpYmxpbmcgPSBjaGlsZDI7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIENyZWF0ZSBhIG5ldyBwYXJlbnQgZm9yIHRoZSBzaWJsaW5ncy5cclxuICAgICAgICAgICAgaW50IG9sZFBhcmVudCA9IF9ub2Rlc1tzaWJsaW5nXS5QYXJlbnRPck5leHQ7XHJcbiAgICAgICAgICAgIGludCBuZXdQYXJlbnQgPSBBbGxvY2F0ZU5vZGUoKTtcclxuICAgICAgICAgICAgX25vZGVzW25ld1BhcmVudF0uUGFyZW50T3JOZXh0ID0gb2xkUGFyZW50O1xyXG4gICAgICAgICAgICBfbm9kZXNbbmV3UGFyZW50XS5Vc2VyRGF0YSA9IGRlZmF1bHQoVCk7XHJcbiAgICAgICAgICAgIF9ub2Rlc1tuZXdQYXJlbnRdLkFBQkIuQ29tYmluZShyZWYgbGVhZkFBQkIsIHJlZiBfbm9kZXNbc2libGluZ10uQUFCQik7XHJcbiAgICAgICAgICAgIF9ub2Rlc1tuZXdQYXJlbnRdLkxlYWZDb3VudCA9IF9ub2Rlc1tzaWJsaW5nXS5MZWFmQ291bnQgKyAxO1xyXG5cclxuICAgICAgICAgICAgaWYgKG9sZFBhcmVudCAhPSBOdWxsTm9kZSlcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgLy8gVGhlIHNpYmxpbmcgd2FzIG5vdCB0aGUgcm9vdC5cclxuICAgICAgICAgICAgICAgIGlmIChfbm9kZXNbb2xkUGFyZW50XS5DaGlsZDEgPT0gc2libGluZylcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBfbm9kZXNbb2xkUGFyZW50XS5DaGlsZDEgPSBuZXdQYXJlbnQ7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgX25vZGVzW29sZFBhcmVudF0uQ2hpbGQyID0gbmV3UGFyZW50O1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIF9ub2Rlc1tuZXdQYXJlbnRdLkNoaWxkMSA9IHNpYmxpbmc7XHJcbiAgICAgICAgICAgICAgICBfbm9kZXNbbmV3UGFyZW50XS5DaGlsZDIgPSBsZWFmO1xyXG4gICAgICAgICAgICAgICAgX25vZGVzW3NpYmxpbmddLlBhcmVudE9yTmV4dCA9IG5ld1BhcmVudDtcclxuICAgICAgICAgICAgICAgIF9ub2Rlc1tsZWFmXS5QYXJlbnRPck5leHQgPSBuZXdQYXJlbnQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAvLyBUaGUgc2libGluZyB3YXMgdGhlIHJvb3QuXHJcbiAgICAgICAgICAgICAgICBfbm9kZXNbbmV3UGFyZW50XS5DaGlsZDEgPSBzaWJsaW5nO1xyXG4gICAgICAgICAgICAgICAgX25vZGVzW25ld1BhcmVudF0uQ2hpbGQyID0gbGVhZjtcclxuICAgICAgICAgICAgICAgIF9ub2Rlc1tzaWJsaW5nXS5QYXJlbnRPck5leHQgPSBuZXdQYXJlbnQ7XHJcbiAgICAgICAgICAgICAgICBfbm9kZXNbbGVhZl0uUGFyZW50T3JOZXh0ID0gbmV3UGFyZW50O1xyXG4gICAgICAgICAgICAgICAgX3Jvb3QgPSBuZXdQYXJlbnQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHByaXZhdGUgdm9pZCBSZW1vdmVMZWFmKGludCBsZWFmKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgaWYgKGxlYWYgPT0gX3Jvb3QpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIF9yb290ID0gTnVsbE5vZGU7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGludCBwYXJlbnQgPSBfbm9kZXNbbGVhZl0uUGFyZW50T3JOZXh0O1xyXG4gICAgICAgICAgICBpbnQgZ3JhbmRQYXJlbnQgPSBfbm9kZXNbcGFyZW50XS5QYXJlbnRPck5leHQ7XHJcbiAgICAgICAgICAgIGludCBzaWJsaW5nO1xyXG4gICAgICAgICAgICBpZiAoX25vZGVzW3BhcmVudF0uQ2hpbGQxID09IGxlYWYpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHNpYmxpbmcgPSBfbm9kZXNbcGFyZW50XS5DaGlsZDI7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBzaWJsaW5nID0gX25vZGVzW3BhcmVudF0uQ2hpbGQxO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAoZ3JhbmRQYXJlbnQgIT0gTnVsbE5vZGUpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIC8vIERlc3Ryb3kgcGFyZW50IGFuZCBjb25uZWN0IHNpYmxpbmcgdG8gZ3JhbmRQYXJlbnQuXHJcbiAgICAgICAgICAgICAgICBpZiAoX25vZGVzW2dyYW5kUGFyZW50XS5DaGlsZDEgPT0gcGFyZW50KVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIF9ub2Rlc1tncmFuZFBhcmVudF0uQ2hpbGQxID0gc2libGluZztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBfbm9kZXNbZ3JhbmRQYXJlbnRdLkNoaWxkMiA9IHNpYmxpbmc7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBfbm9kZXNbc2libGluZ10uUGFyZW50T3JOZXh0ID0gZ3JhbmRQYXJlbnQ7XHJcbiAgICAgICAgICAgICAgICBGcmVlTm9kZShwYXJlbnQpO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIEFkanVzdCBhbmNlc3RvciBib3VuZHMuXHJcbiAgICAgICAgICAgICAgICBwYXJlbnQgPSBncmFuZFBhcmVudDtcclxuICAgICAgICAgICAgICAgIHdoaWxlIChwYXJlbnQgIT0gTnVsbE5vZGUpXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgX25vZGVzW3BhcmVudF0uQUFCQi5Db21iaW5lKHJlZiBfbm9kZXNbX25vZGVzW3BhcmVudF0uQ2hpbGQxXS5BQUJCLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWYgX25vZGVzW19ub2Rlc1twYXJlbnRdLkNoaWxkMl0uQUFCQik7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIERlYnVnLkFzc2VydChfbm9kZXNbcGFyZW50XS5MZWFmQ291bnQgPiAwKTtcclxuICAgICAgICAgICAgICAgICAgICBfbm9kZXNbcGFyZW50XS5MZWFmQ291bnQgLT0gMTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgcGFyZW50ID0gX25vZGVzW3BhcmVudF0uUGFyZW50T3JOZXh0O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgX3Jvb3QgPSBzaWJsaW5nO1xyXG4gICAgICAgICAgICAgICAgX25vZGVzW3NpYmxpbmddLlBhcmVudE9yTmV4dCA9IE51bGxOb2RlO1xyXG4gICAgICAgICAgICAgICAgRnJlZU5vZGUocGFyZW50KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHJpdmF0ZSBpbnQgQ29tcHV0ZUhlaWdodChpbnQgbm9kZUlkKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgaWYgKG5vZGVJZCA9PSBOdWxsTm9kZSlcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIDA7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIERlYnVnLkFzc2VydCgwIDw9IG5vZGVJZCAmJiBub2RlSWQgPCBfbm9kZUNhcGFjaXR5KTtcclxuICAgICAgICAgICAgRHluYW1pY1RyZWVOb2RlPFQ+IG5vZGUgPSBfbm9kZXNbbm9kZUlkXTtcclxuICAgICAgICAgICAgaW50IGhlaWdodDEgPSBDb21wdXRlSGVpZ2h0KG5vZGUuQ2hpbGQxKTtcclxuICAgICAgICAgICAgaW50IGhlaWdodDIgPSBDb21wdXRlSGVpZ2h0KG5vZGUuQ2hpbGQyKTtcclxuICAgICAgICAgICAgcmV0dXJuIDEgKyBNYXRoLk1heChoZWlnaHQxLCBoZWlnaHQyKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn0iLCIvKlxyXG4qIEZhcnNlZXIgUGh5c2ljcyBFbmdpbmUgYmFzZWQgb24gQm94MkQuWE5BIHBvcnQ6XHJcbiogQ29weXJpZ2h0IChjKSAyMDEwIElhbiBRdmlzdFxyXG4qIFxyXG4qIEJveDJELlhOQSBwb3J0IG9mIEJveDJEOlxyXG4qIENvcHlyaWdodCAoYykgMjAwOSBCcmFuZG9uIEZ1cnR3YW5nbGVyLCBOYXRoYW4gRnVydHdhbmdsZXJcclxuKlxyXG4qIE9yaWdpbmFsIHNvdXJjZSBCb3gyRDpcclxuKiBDb3B5cmlnaHQgKGMpIDIwMDYtMjAwOSBFcmluIENhdHRvIGh0dHA6Ly93d3cuZ3BoeXNpY3MuY29tIFxyXG4qIFxyXG4qIFRoaXMgc29mdHdhcmUgaXMgcHJvdmlkZWQgJ2FzLWlzJywgd2l0aG91dCBhbnkgZXhwcmVzcyBvciBpbXBsaWVkIFxyXG4qIHdhcnJhbnR5LiAgSW4gbm8gZXZlbnQgd2lsbCB0aGUgYXV0aG9ycyBiZSBoZWxkIGxpYWJsZSBmb3IgYW55IGRhbWFnZXMgXHJcbiogYXJpc2luZyBmcm9tIHRoZSB1c2Ugb2YgdGhpcyBzb2Z0d2FyZS4gXHJcbiogUGVybWlzc2lvbiBpcyBncmFudGVkIHRvIGFueW9uZSB0byB1c2UgdGhpcyBzb2Z0d2FyZSBmb3IgYW55IHB1cnBvc2UsIFxyXG4qIGluY2x1ZGluZyBjb21tZXJjaWFsIGFwcGxpY2F0aW9ucywgYW5kIHRvIGFsdGVyIGl0IGFuZCByZWRpc3RyaWJ1dGUgaXQgXHJcbiogZnJlZWx5LCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgcmVzdHJpY3Rpb25zOiBcclxuKiAxLiBUaGUgb3JpZ2luIG9mIHRoaXMgc29mdHdhcmUgbXVzdCBub3QgYmUgbWlzcmVwcmVzZW50ZWQ7IHlvdSBtdXN0IG5vdCBcclxuKiBjbGFpbSB0aGF0IHlvdSB3cm90ZSB0aGUgb3JpZ2luYWwgc29mdHdhcmUuIElmIHlvdSB1c2UgdGhpcyBzb2Z0d2FyZSBcclxuKiBpbiBhIHByb2R1Y3QsIGFuIGFja25vd2xlZGdtZW50IGluIHRoZSBwcm9kdWN0IGRvY3VtZW50YXRpb24gd291bGQgYmUgXHJcbiogYXBwcmVjaWF0ZWQgYnV0IGlzIG5vdCByZXF1aXJlZC4gXHJcbiogMi4gQWx0ZXJlZCBzb3VyY2UgdmVyc2lvbnMgbXVzdCBiZSBwbGFpbmx5IG1hcmtlZCBhcyBzdWNoLCBhbmQgbXVzdCBub3QgYmUgXHJcbiogbWlzcmVwcmVzZW50ZWQgYXMgYmVpbmcgdGhlIG9yaWdpbmFsIHNvZnR3YXJlLiBcclxuKiAzLiBUaGlzIG5vdGljZSBtYXkgbm90IGJlIHJlbW92ZWQgb3IgYWx0ZXJlZCBmcm9tIGFueSBzb3VyY2UgZGlzdHJpYnV0aW9uLiBcclxuKi9cclxuXHJcbnVzaW5nIFN5c3RlbTtcclxudXNpbmcgRmFyc2VlclBoeXNpY3MuRHluYW1pY3M7XHJcbnVzaW5nIE1pY3Jvc29mdC5YbmEuRnJhbWV3b3JrO1xyXG5cclxubmFtZXNwYWNlIEZhcnNlZXJQaHlzaWNzLkNvbGxpc2lvblxyXG57XHJcbiAgICBpbnRlcm5hbCBzdHJ1Y3QgUGFpciA6IElDb21wYXJhYmxlPFBhaXI+XHJcbiAgICB7XHJcbiAgICAgICAgcHVibGljIGludCBQcm94eUlkQTtcclxuICAgICAgICBwdWJsaWMgaW50IFByb3h5SWRCO1xyXG5cclxuICAgICAgICAjcmVnaW9uIElDb21wYXJhYmxlPFBhaXI+IE1lbWJlcnNcclxuXHJcbiAgICAgICAgcHVibGljIGludCBDb21wYXJlVG8oUGFpciBvdGhlcilcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGlmIChQcm94eUlkQSA8IG90aGVyLlByb3h5SWRBKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gLTE7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKFByb3h5SWRBID09IG90aGVyLlByb3h5SWRBKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBpZiAoUHJveHlJZEIgPCBvdGhlci5Qcm94eUlkQilcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gLTE7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoUHJveHlJZEIgPT0gb3RoZXIuUHJveHlJZEIpXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDA7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHJldHVybiAxO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgI2VuZHJlZ2lvblxyXG4gICAgfVxyXG5cclxuICAgIC8vLyA8c3VtbWFyeT5cclxuICAgIC8vLyBUaGUgYnJvYWQtcGhhc2UgaXMgdXNlZCBmb3IgY29tcHV0aW5nIHBhaXJzIGFuZCBwZXJmb3JtaW5nIHZvbHVtZSBxdWVyaWVzIGFuZCByYXkgY2FzdHMuXHJcbiAgICAvLy8gVGhpcyBicm9hZC1waGFzZSBkb2VzIG5vdCBwZXJzaXN0IHBhaXJzLiBJbnN0ZWFkLCB0aGlzIHJlcG9ydHMgcG90ZW50aWFsbHkgbmV3IHBhaXJzLlxyXG4gICAgLy8vIEl0IGlzIHVwIHRvIHRoZSBjbGllbnQgdG8gY29uc3VtZSB0aGUgbmV3IHBhaXJzIGFuZCB0byB0cmFjayBzdWJzZXF1ZW50IG92ZXJsYXAuXHJcbiAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgcHVibGljIGNsYXNzIER5bmFtaWNUcmVlQnJvYWRQaGFzZSA6IElCcm9hZFBoYXNlXHJcbiAgICB7XHJcbiAgICAgICAgcHJpdmF0ZSBpbnRbXSBfbW92ZUJ1ZmZlcjtcclxuICAgICAgICBwcml2YXRlIGludCBfbW92ZUNhcGFjaXR5O1xyXG4gICAgICAgIHByaXZhdGUgaW50IF9tb3ZlQ291bnQ7XHJcblxyXG4gICAgICAgIHByaXZhdGUgUGFpcltdIF9wYWlyQnVmZmVyO1xyXG4gICAgICAgIHByaXZhdGUgaW50IF9wYWlyQ2FwYWNpdHk7XHJcbiAgICAgICAgcHJpdmF0ZSBpbnQgX3BhaXJDb3VudDtcclxuICAgICAgICBwcml2YXRlIGludCBfcHJveHlDb3VudDtcclxuICAgICAgICBwcml2YXRlIEZ1bmM8aW50LCBib29sPiBfcXVlcnlDYWxsYmFjaztcclxuICAgICAgICBwcml2YXRlIGludCBfcXVlcnlQcm94eUlkO1xyXG4gICAgICAgIHByaXZhdGUgRHluYW1pY1RyZWU8Rml4dHVyZVByb3h5PiBfdHJlZSA9IG5ldyBEeW5hbWljVHJlZTxGaXh0dXJlUHJveHk+KCk7XHJcblxyXG4gICAgICAgIHB1YmxpYyBEeW5hbWljVHJlZUJyb2FkUGhhc2UoKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgX3F1ZXJ5Q2FsbGJhY2sgPSBuZXcgRnVuYzxpbnQsIGJvb2w+KFF1ZXJ5Q2FsbGJhY2spO1xyXG5cclxuICAgICAgICAgICAgX3BhaXJDYXBhY2l0eSA9IDE2O1xyXG4gICAgICAgICAgICBfcGFpckJ1ZmZlciA9IG5ldyBQYWlyW19wYWlyQ2FwYWNpdHldO1xyXG5cclxuICAgICAgICAgICAgX21vdmVDYXBhY2l0eSA9IDE2O1xyXG4gICAgICAgICAgICBfbW92ZUJ1ZmZlciA9IG5ldyBpbnRbX21vdmVDYXBhY2l0eV07XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAjcmVnaW9uIElCcm9hZFBoYXNlIE1lbWJlcnNcclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBHZXQgdGhlIG51bWJlciBvZiBwcm94aWVzLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDx2YWx1ZT5UaGUgcHJveHkgY291bnQuPC92YWx1ZT5cclxuICAgICAgICBwdWJsaWMgaW50IFByb3h5Q291bnRcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGdldCB7IHJldHVybiBfcHJveHlDb3VudDsgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBDcmVhdGUgYSBwcm94eSB3aXRoIGFuIGluaXRpYWwgQUFCQi4gUGFpcnMgYXJlIG5vdCByZXBvcnRlZCB1bnRpbFxyXG4gICAgICAgIC8vLyBVcGRhdGVQYWlycyBpcyBjYWxsZWQuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJhYWJiXCI+VGhlIGFhYmIuPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJwcm94eVwiPlRoZSB1c2VyIGRhdGEuPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHJldHVybnM+PC9yZXR1cm5zPlxyXG4gICAgICAgIHB1YmxpYyBpbnQgQWRkUHJveHkocmVmIEZpeHR1cmVQcm94eSBwcm94eSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGludCBwcm94eUlkID0gX3RyZWUuQWRkUHJveHkocmVmIHByb3h5LkFBQkIsIHByb3h5KTtcclxuICAgICAgICAgICAgKytfcHJveHlDb3VudDtcclxuICAgICAgICAgICAgQnVmZmVyTW92ZShwcm94eUlkKTtcclxuICAgICAgICAgICAgcmV0dXJuIHByb3h5SWQ7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIERlc3Ryb3kgYSBwcm94eS4gSXQgaXMgdXAgdG8gdGhlIGNsaWVudCB0byByZW1vdmUgYW55IHBhaXJzLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwicHJveHlJZFwiPlRoZSBwcm94eSBpZC48L3BhcmFtPlxyXG4gICAgICAgIHB1YmxpYyB2b2lkIFJlbW92ZVByb3h5KGludCBwcm94eUlkKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgVW5CdWZmZXJNb3ZlKHByb3h5SWQpO1xyXG4gICAgICAgICAgICAtLV9wcm94eUNvdW50O1xyXG4gICAgICAgICAgICBfdHJlZS5SZW1vdmVQcm94eShwcm94eUlkKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHB1YmxpYyB2b2lkIE1vdmVQcm94eShpbnQgcHJveHlJZCwgcmVmIEFBQkIgYWFiYiwgVmVjdG9yMiBkaXNwbGFjZW1lbnQpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBib29sIGJ1ZmZlciA9IF90cmVlLk1vdmVQcm94eShwcm94eUlkLCByZWYgYWFiYiwgZGlzcGxhY2VtZW50KTtcclxuICAgICAgICAgICAgaWYgKGJ1ZmZlcilcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgQnVmZmVyTW92ZShwcm94eUlkKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBHZXQgdGhlIEFBQkIgZm9yIGEgcHJveHkuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJwcm94eUlkXCI+VGhlIHByb3h5IGlkLjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwiYWFiYlwiPlRoZSBhYWJiLjwvcGFyYW0+XHJcbiAgICAgICAgcHVibGljIHZvaWQgR2V0RmF0QUFCQihpbnQgcHJveHlJZCwgb3V0IEFBQkIgYWFiYilcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIF90cmVlLkdldEZhdEFBQkIocHJveHlJZCwgb3V0IGFhYmIpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBHZXQgdXNlciBkYXRhIGZyb20gYSBwcm94eS4gUmV0dXJucyBudWxsIGlmIHRoZSBpZCBpcyBpbnZhbGlkLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwicHJveHlJZFwiPlRoZSBwcm94eSBpZC48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cmV0dXJucz48L3JldHVybnM+XHJcbiAgICAgICAgcHVibGljIEZpeHR1cmVQcm94eSBHZXRQcm94eShpbnQgcHJveHlJZClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiBfdHJlZS5HZXRVc2VyRGF0YShwcm94eUlkKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gVGVzdCBvdmVybGFwIG9mIGZhdCBBQUJCcy5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cInByb3h5SWRBXCI+VGhlIHByb3h5IGlkIEEuPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJwcm94eUlkQlwiPlRoZSBwcm94eSBpZCBCLjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxyZXR1cm5zPjwvcmV0dXJucz5cclxuICAgICAgICBwdWJsaWMgYm9vbCBUZXN0T3ZlcmxhcChpbnQgcHJveHlJZEEsIGludCBwcm94eUlkQilcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIEFBQkIgYWFiYkEsIGFhYmJCO1xyXG4gICAgICAgICAgICBfdHJlZS5HZXRGYXRBQUJCKHByb3h5SWRBLCBvdXQgYWFiYkEpO1xyXG4gICAgICAgICAgICBfdHJlZS5HZXRGYXRBQUJCKHByb3h5SWRCLCBvdXQgYWFiYkIpO1xyXG4gICAgICAgICAgICByZXR1cm4gQUFCQi5UZXN0T3ZlcmxhcChyZWYgYWFiYkEsIHJlZiBhYWJiQik7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIFVwZGF0ZSB0aGUgcGFpcnMuIFRoaXMgcmVzdWx0cyBpbiBwYWlyIGNhbGxiYWNrcy4gVGhpcyBjYW4gb25seSBhZGQgcGFpcnMuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJjYWxsYmFja1wiPlRoZSBjYWxsYmFjay48L3BhcmFtPlxyXG4gICAgICAgIHB1YmxpYyB2b2lkIFVwZGF0ZVBhaXJzKEJyb2FkcGhhc2VEZWxlZ2F0ZSBjYWxsYmFjaylcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIC8vIFJlc2V0IHBhaXIgYnVmZmVyXHJcbiAgICAgICAgICAgIF9wYWlyQ291bnQgPSAwO1xyXG5cclxuICAgICAgICAgICAgLy8gUGVyZm9ybSB0cmVlIHF1ZXJpZXMgZm9yIGFsbCBtb3ZpbmcgcHJveGllcy5cclxuICAgICAgICAgICAgZm9yIChpbnQgaiA9IDA7IGogPCBfbW92ZUNvdW50OyArK2opXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIF9xdWVyeVByb3h5SWQgPSBfbW92ZUJ1ZmZlcltqXTtcclxuICAgICAgICAgICAgICAgIGlmIChfcXVlcnlQcm94eUlkID09IC0xKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIC8vIFdlIGhhdmUgdG8gcXVlcnkgdGhlIHRyZWUgd2l0aCB0aGUgZmF0IEFBQkIgc28gdGhhdFxyXG4gICAgICAgICAgICAgICAgLy8gd2UgZG9uJ3QgZmFpbCB0byBjcmVhdGUgYSBwYWlyIHRoYXQgbWF5IHRvdWNoIGxhdGVyLlxyXG4gICAgICAgICAgICAgICAgQUFCQiBmYXRBQUJCO1xyXG4gICAgICAgICAgICAgICAgX3RyZWUuR2V0RmF0QUFCQihfcXVlcnlQcm94eUlkLCBvdXQgZmF0QUFCQik7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gUXVlcnkgdHJlZSwgY3JlYXRlIHBhaXJzIGFuZCBhZGQgdGhlbSBwYWlyIGJ1ZmZlci5cclxuICAgICAgICAgICAgICAgIF90cmVlLlF1ZXJ5KChnbG9iYWw6OlN5c3RlbS5GdW5jPGludCwgYm9vbD4pX3F1ZXJ5Q2FsbGJhY2ssIHJlZiBmYXRBQUJCKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gUmVzZXQgbW92ZSBidWZmZXJcclxuICAgICAgICAgICAgX21vdmVDb3VudCA9IDA7XHJcblxyXG4gICAgICAgICAgICAvLyBTb3J0IHRoZSBwYWlyIGJ1ZmZlciB0byBleHBvc2UgZHVwbGljYXRlcy5cclxuICAgICAgICAgICAgQXJyYXkuU29ydDxnbG9iYWw6OkZhcnNlZXJQaHlzaWNzLkNvbGxpc2lvbi5QYWlyPihfcGFpckJ1ZmZlciwgMCwgX3BhaXJDb3VudCk7XHJcblxyXG4gICAgICAgICAgICAvLyBTZW5kIHRoZSBwYWlycyBiYWNrIHRvIHRoZSBjbGllbnQuXHJcbiAgICAgICAgICAgIGludCBpID0gMDtcclxuICAgICAgICAgICAgd2hpbGUgKGkgPCBfcGFpckNvdW50KVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBQYWlyIHByaW1hcnlQYWlyID0gX3BhaXJCdWZmZXJbaV07XHJcbiAgICAgICAgICAgICAgICBGaXh0dXJlUHJveHkgdXNlckRhdGFBID0gX3RyZWUuR2V0VXNlckRhdGEocHJpbWFyeVBhaXIuUHJveHlJZEEpO1xyXG4gICAgICAgICAgICAgICAgRml4dHVyZVByb3h5IHVzZXJEYXRhQiA9IF90cmVlLkdldFVzZXJEYXRhKHByaW1hcnlQYWlyLlByb3h5SWRCKTtcclxuXHJcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhyZWYgdXNlckRhdGFBLCByZWYgdXNlckRhdGFCKTtcclxuICAgICAgICAgICAgICAgICsraTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBTa2lwIGFueSBkdXBsaWNhdGUgcGFpcnMuXHJcbiAgICAgICAgICAgICAgICB3aGlsZSAoaSA8IF9wYWlyQ291bnQpXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgUGFpciBwYWlyID0gX3BhaXJCdWZmZXJbaV07XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBhaXIuUHJveHlJZEEgIT0gcHJpbWFyeVBhaXIuUHJveHlJZEEgfHwgcGFpci5Qcm94eUlkQiAhPSBwcmltYXJ5UGFpci5Qcm94eUlkQilcclxuICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICArK2k7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIFRyeSB0byBrZWVwIHRoZSB0cmVlIGJhbGFuY2VkLlxyXG4gICAgICAgICAgICBfdHJlZS5SZWJhbGFuY2UoNCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIFF1ZXJ5IGFuIEFBQkIgZm9yIG92ZXJsYXBwaW5nIHByb3hpZXMuIFRoZSBjYWxsYmFjayBjbGFzc1xyXG4gICAgICAgIC8vLyBpcyBjYWxsZWQgZm9yIGVhY2ggcHJveHkgdGhhdCBvdmVybGFwcyB0aGUgc3VwcGxpZWQgQUFCQi5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cImNhbGxiYWNrXCI+VGhlIGNhbGxiYWNrLjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwiYWFiYlwiPlRoZSBhYWJiLjwvcGFyYW0+XHJcbiAgICAgICAgcHVibGljIHZvaWQgUXVlcnkoRnVuYzxpbnQsIGJvb2w+IGNhbGxiYWNrLCByZWYgQUFCQiBhYWJiKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgX3RyZWUuUXVlcnkoKGdsb2JhbDo6U3lzdGVtLkZ1bmM8aW50LCBib29sPiljYWxsYmFjaywgcmVmIGFhYmIpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBSYXktY2FzdCBhZ2FpbnN0IHRoZSBwcm94aWVzIGluIHRoZSB0cmVlLiBUaGlzIHJlbGllcyBvbiB0aGUgY2FsbGJhY2tcclxuICAgICAgICAvLy8gdG8gcGVyZm9ybSBhIGV4YWN0IHJheS1jYXN0IGluIHRoZSBjYXNlIHdlcmUgdGhlIHByb3h5IGNvbnRhaW5zIGEgc2hhcGUuXHJcbiAgICAgICAgLy8vIFRoZSBjYWxsYmFjayBhbHNvIHBlcmZvcm1zIHRoZSBhbnkgY29sbGlzaW9uIGZpbHRlcmluZy4gVGhpcyBoYXMgcGVyZm9ybWFuY2VcclxuICAgICAgICAvLy8gcm91Z2hseSBlcXVhbCB0byBrICogbG9nKG4pLCB3aGVyZSBrIGlzIHRoZSBudW1iZXIgb2YgY29sbGlzaW9ucyBhbmQgbiBpcyB0aGVcclxuICAgICAgICAvLy8gbnVtYmVyIG9mIHByb3hpZXMgaW4gdGhlIHRyZWUuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJjYWxsYmFja1wiPkEgY2FsbGJhY2sgY2xhc3MgdGhhdCBpcyBjYWxsZWQgZm9yIGVhY2ggcHJveHkgdGhhdCBpcyBoaXQgYnkgdGhlIHJheS48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cImlucHV0XCI+VGhlIHJheS1jYXN0IGlucHV0IGRhdGEuIFRoZSByYXkgZXh0ZW5kcyBmcm9tIHAxIHRvIHAxICsgbWF4RnJhY3Rpb24gKiAocDIgLSBwMSkuPC9wYXJhbT5cclxuICAgICAgICBwdWJsaWMgdm9pZCBSYXlDYXN0KEZ1bmM8UmF5Q2FzdElucHV0LCBpbnQsIGZsb2F0PiBjYWxsYmFjaywgcmVmIFJheUNhc3RJbnB1dCBpbnB1dClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIF90cmVlLlJheUNhc3QoKGdsb2JhbDo6U3lzdGVtLkZ1bmM8Z2xvYmFsOjpGYXJzZWVyUGh5c2ljcy5Db2xsaXNpb24uUmF5Q2FzdElucHV0LCBpbnQsIGZsb2F0PiljYWxsYmFjaywgcmVmIGlucHV0KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHB1YmxpYyB2b2lkIFRvdWNoUHJveHkoaW50IHByb3h5SWQpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBCdWZmZXJNb3ZlKHByb3h5SWQpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgI2VuZHJlZ2lvblxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIENvbXB1dGUgdGhlIGhlaWdodCBvZiB0aGUgZW1iZWRkZWQgdHJlZS5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8cmV0dXJucz48L3JldHVybnM+XHJcbiAgICAgICAgcHVibGljIGludCBDb21wdXRlSGVpZ2h0KClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiBfdHJlZS5Db21wdXRlSGVpZ2h0KCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwcml2YXRlIHZvaWQgQnVmZmVyTW92ZShpbnQgcHJveHlJZClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGlmIChfbW92ZUNvdW50ID09IF9tb3ZlQ2FwYWNpdHkpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGludFtdIG9sZEJ1ZmZlciA9IF9tb3ZlQnVmZmVyO1xyXG4gICAgICAgICAgICAgICAgX21vdmVDYXBhY2l0eSAqPSAyO1xyXG4gICAgICAgICAgICAgICAgX21vdmVCdWZmZXIgPSBuZXcgaW50W19tb3ZlQ2FwYWNpdHldO1xyXG4gICAgICAgICAgICAgICAgQXJyYXkuQ29weShvbGRCdWZmZXIsIF9tb3ZlQnVmZmVyLCBfbW92ZUNvdW50KTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgX21vdmVCdWZmZXJbX21vdmVDb3VudF0gPSBwcm94eUlkO1xyXG4gICAgICAgICAgICArK19tb3ZlQ291bnQ7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwcml2YXRlIHZvaWQgVW5CdWZmZXJNb3ZlKGludCBwcm94eUlkKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgZm9yIChpbnQgaSA9IDA7IGkgPCBfbW92ZUNvdW50OyArK2kpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGlmIChfbW92ZUJ1ZmZlcltpXSA9PSBwcm94eUlkKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIF9tb3ZlQnVmZmVyW2ldID0gLTE7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwcml2YXRlIGJvb2wgUXVlcnlDYWxsYmFjayhpbnQgcHJveHlJZClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIC8vIEEgcHJveHkgY2Fubm90IGZvcm0gYSBwYWlyIHdpdGggaXRzZWxmLlxyXG4gICAgICAgICAgICBpZiAocHJveHlJZCA9PSBfcXVlcnlQcm94eUlkKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gR3JvdyB0aGUgcGFpciBidWZmZXIgYXMgbmVlZGVkLlxyXG4gICAgICAgICAgICBpZiAoX3BhaXJDb3VudCA9PSBfcGFpckNhcGFjaXR5KVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBQYWlyW10gb2xkQnVmZmVyID0gX3BhaXJCdWZmZXI7XHJcbiAgICAgICAgICAgICAgICBfcGFpckNhcGFjaXR5ICo9IDI7XHJcbiAgICAgICAgICAgICAgICBfcGFpckJ1ZmZlciA9IG5ldyBQYWlyW19wYWlyQ2FwYWNpdHldO1xyXG4gICAgICAgICAgICAgICAgQXJyYXkuQ29weShvbGRCdWZmZXIsIF9wYWlyQnVmZmVyLCBfcGFpckNvdW50KTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgX3BhaXJCdWZmZXJbX3BhaXJDb3VudF0uUHJveHlJZEEgPSBNYXRoLk1pbihwcm94eUlkLCBfcXVlcnlQcm94eUlkKTtcclxuICAgICAgICAgICAgX3BhaXJCdWZmZXJbX3BhaXJDb3VudF0uUHJveHlJZEIgPSBNYXRoLk1heChwcm94eUlkLCBfcXVlcnlQcm94eUlkKTtcclxuICAgICAgICAgICAgKytfcGFpckNvdW50O1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59IiwiLypcclxuKiBGYXJzZWVyIFBoeXNpY3MgRW5naW5lIGJhc2VkIG9uIEJveDJELlhOQSBwb3J0OlxyXG4qIENvcHlyaWdodCAoYykgMjAxMCBJYW4gUXZpc3RcclxuKiBcclxuKiBCb3gyRC5YTkEgcG9ydCBvZiBCb3gyRDpcclxuKiBDb3B5cmlnaHQgKGMpIDIwMDkgQnJhbmRvbiBGdXJ0d2FuZ2xlciwgTmF0aGFuIEZ1cnR3YW5nbGVyXHJcbipcclxuKiBPcmlnaW5hbCBzb3VyY2UgQm94MkQ6XHJcbiogQ29weXJpZ2h0IChjKSAyMDA2LTIwMDkgRXJpbiBDYXR0byBodHRwOi8vd3d3LmdwaHlzaWNzLmNvbSBcclxuKiBcclxuKiBUaGlzIHNvZnR3YXJlIGlzIHByb3ZpZGVkICdhcy1pcycsIHdpdGhvdXQgYW55IGV4cHJlc3Mgb3IgaW1wbGllZCBcclxuKiB3YXJyYW50eS4gIEluIG5vIGV2ZW50IHdpbGwgdGhlIGF1dGhvcnMgYmUgaGVsZCBsaWFibGUgZm9yIGFueSBkYW1hZ2VzIFxyXG4qIGFyaXNpbmcgZnJvbSB0aGUgdXNlIG9mIHRoaXMgc29mdHdhcmUuIFxyXG4qIFBlcm1pc3Npb24gaXMgZ3JhbnRlZCB0byBhbnlvbmUgdG8gdXNlIHRoaXMgc29mdHdhcmUgZm9yIGFueSBwdXJwb3NlLCBcclxuKiBpbmNsdWRpbmcgY29tbWVyY2lhbCBhcHBsaWNhdGlvbnMsIGFuZCB0byBhbHRlciBpdCBhbmQgcmVkaXN0cmlidXRlIGl0IFxyXG4qIGZyZWVseSwgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIHJlc3RyaWN0aW9uczogXHJcbiogMS4gVGhlIG9yaWdpbiBvZiB0aGlzIHNvZnR3YXJlIG11c3Qgbm90IGJlIG1pc3JlcHJlc2VudGVkOyB5b3UgbXVzdCBub3QgXHJcbiogY2xhaW0gdGhhdCB5b3Ugd3JvdGUgdGhlIG9yaWdpbmFsIHNvZnR3YXJlLiBJZiB5b3UgdXNlIHRoaXMgc29mdHdhcmUgXHJcbiogaW4gYSBwcm9kdWN0LCBhbiBhY2tub3dsZWRnbWVudCBpbiB0aGUgcHJvZHVjdCBkb2N1bWVudGF0aW9uIHdvdWxkIGJlIFxyXG4qIGFwcHJlY2lhdGVkIGJ1dCBpcyBub3QgcmVxdWlyZWQuIFxyXG4qIDIuIEFsdGVyZWQgc291cmNlIHZlcnNpb25zIG11c3QgYmUgcGxhaW5seSBtYXJrZWQgYXMgc3VjaCwgYW5kIG11c3Qgbm90IGJlIFxyXG4qIG1pc3JlcHJlc2VudGVkIGFzIGJlaW5nIHRoZSBvcmlnaW5hbCBzb2Z0d2FyZS4gXHJcbiogMy4gVGhpcyBub3RpY2UgbWF5IG5vdCBiZSByZW1vdmVkIG9yIGFsdGVyZWQgZnJvbSBhbnkgc291cmNlIGRpc3RyaWJ1dGlvbi4gXHJcbiovXHJcblxyXG51c2luZyBTeXN0ZW07XHJcbnVzaW5nIFN5c3RlbS5EaWFnbm9zdGljcztcclxudXNpbmcgRmFyc2VlclBoeXNpY3MuQ29tbW9uO1xyXG51c2luZyBNaWNyb3NvZnQuWG5hLkZyYW1ld29yaztcclxuXHJcbm5hbWVzcGFjZSBGYXJzZWVyUGh5c2ljcy5Db2xsaXNpb25cclxue1xyXG4gICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgLy8vIElucHV0IHBhcmFtZXRlcnMgZm9yIENhbGN1bGF0ZVRpbWVPZkltcGFjdFxyXG4gICAgLy8vIDwvc3VtbWFyeT5cclxuICAgIHB1YmxpYyBjbGFzcyBUT0lJbnB1dFxyXG4gICAge1xyXG4gICAgICAgIHB1YmxpYyBEaXN0YW5jZVByb3h5IFByb3h5QSA9IG5ldyBEaXN0YW5jZVByb3h5KCk7XHJcbiAgICAgICAgcHVibGljIERpc3RhbmNlUHJveHkgUHJveHlCID0gbmV3IERpc3RhbmNlUHJveHkoKTtcclxuICAgICAgICBwdWJsaWMgU3dlZXAgU3dlZXBBO1xyXG4gICAgICAgIHB1YmxpYyBTd2VlcCBTd2VlcEI7XHJcbiAgICAgICAgcHVibGljIGZsb2F0IFRNYXg7IC8vIGRlZmluZXMgc3dlZXAgaW50ZXJ2YWwgWzAsIHRNYXhdXHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGVudW0gVE9JT3V0cHV0U3RhdGVcclxuICAgIHtcclxuICAgICAgICBVbmtub3duLFxyXG4gICAgICAgIEZhaWxlZCxcclxuICAgICAgICBPdmVybGFwcGVkLFxyXG4gICAgICAgIFRvdWNoaW5nLFxyXG4gICAgICAgIFNlcGVyYXRlZCxcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgc3RydWN0IFRPSU91dHB1dFxyXG4gICAge1xyXG4gICAgICAgIHB1YmxpYyBUT0lPdXRwdXRTdGF0ZSBTdGF0ZTtcclxuICAgICAgICBwdWJsaWMgZmxvYXQgVDtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgZW51bSBTZXBhcmF0aW9uRnVuY3Rpb25UeXBlXHJcbiAgICB7XHJcbiAgICAgICAgUG9pbnRzLFxyXG4gICAgICAgIEZhY2VBLFxyXG4gICAgICAgIEZhY2VCXHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIHN0YXRpYyBjbGFzcyBTZXBhcmF0aW9uRnVuY3Rpb25cclxuICAgIHtcclxuICAgICAgICBwcml2YXRlIHN0YXRpYyBWZWN0b3IyIF9heGlzO1xyXG4gICAgICAgIHByaXZhdGUgc3RhdGljIFZlY3RvcjIgX2xvY2FsUG9pbnQ7XHJcbiAgICAgICAgcHJpdmF0ZSBzdGF0aWMgRGlzdGFuY2VQcm94eSBfcHJveHlBID0gbmV3IERpc3RhbmNlUHJveHkoKTtcclxuICAgICAgICBwcml2YXRlIHN0YXRpYyBEaXN0YW5jZVByb3h5IF9wcm94eUIgPSBuZXcgRGlzdGFuY2VQcm94eSgpO1xyXG4gICAgICAgIHByaXZhdGUgc3RhdGljIFN3ZWVwIF9zd2VlcEEsIF9zd2VlcEI7XHJcbiAgICAgICAgcHJpdmF0ZSBzdGF0aWMgU2VwYXJhdGlvbkZ1bmN0aW9uVHlwZSBfdHlwZTtcclxuXHJcbiAgICAgICAgcHVibGljIHN0YXRpYyB2b2lkIFNldChyZWYgU2ltcGxleENhY2hlIGNhY2hlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgRGlzdGFuY2VQcm94eSBwcm94eUEsIHJlZiBTd2VlcCBzd2VlcEEsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBEaXN0YW5jZVByb3h5IHByb3h5QiwgcmVmIFN3ZWVwIHN3ZWVwQixcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZsb2F0IHQxKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgX2xvY2FsUG9pbnQgPSBWZWN0b3IyLlplcm87XHJcbiAgICAgICAgICAgIF9wcm94eUEgPSBwcm94eUE7XHJcbiAgICAgICAgICAgIF9wcm94eUIgPSBwcm94eUI7XHJcbiAgICAgICAgICAgIGludCBjb3VudCA9IGNhY2hlLkNvdW50O1xyXG4gICAgICAgICAgICBEZWJ1Zy5Bc3NlcnQoMCA8IGNvdW50ICYmIGNvdW50IDwgMyk7XHJcblxyXG4gICAgICAgICAgICBfc3dlZXBBID0gc3dlZXBBO1xyXG4gICAgICAgICAgICBfc3dlZXBCID0gc3dlZXBCO1xyXG5cclxuICAgICAgICAgICAgVHJhbnNmb3JtIHhmQSwgeGZCO1xyXG4gICAgICAgICAgICBfc3dlZXBBLkdldFRyYW5zZm9ybShvdXQgeGZBLCB0MSk7XHJcbiAgICAgICAgICAgIF9zd2VlcEIuR2V0VHJhbnNmb3JtKG91dCB4ZkIsIHQxKTtcclxuXHJcbiAgICAgICAgICAgIGlmIChjb3VudCA9PSAxKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBfdHlwZSA9IFNlcGFyYXRpb25GdW5jdGlvblR5cGUuUG9pbnRzO1xyXG4gICAgICAgICAgICAgICAgVmVjdG9yMiBsb2NhbFBvaW50QSA9IF9wcm94eUEuVmVydGljZXNbY2FjaGUuSW5kZXhBWzBdXTtcclxuICAgICAgICAgICAgICAgIFZlY3RvcjIgbG9jYWxQb2ludEIgPSBfcHJveHlCLlZlcnRpY2VzW2NhY2hlLkluZGV4QlswXV07XHJcbiAgICAgICAgICAgICAgICBWZWN0b3IyIHBvaW50QSA9IE1hdGhVdGlscy5NdWx0aXBseShyZWYgeGZBLCBsb2NhbFBvaW50QSk7XHJcbiAgICAgICAgICAgICAgICBWZWN0b3IyIHBvaW50QiA9IE1hdGhVdGlscy5NdWx0aXBseShyZWYgeGZCLCBsb2NhbFBvaW50Qik7XHJcbiAgICAgICAgICAgICAgICBfYXhpcyA9IHBvaW50QiAtIHBvaW50QTtcclxuICAgICAgICAgICAgICAgIF9heGlzLk5vcm1hbGl6ZSgpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGNhY2hlLkluZGV4QVswXSA9PSBjYWNoZS5JbmRleEFbMV0pXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIC8vIFR3byBwb2ludHMgb24gQiBhbmQgb25lIG9uIEEuXHJcbiAgICAgICAgICAgICAgICBfdHlwZSA9IFNlcGFyYXRpb25GdW5jdGlvblR5cGUuRmFjZUI7XHJcbiAgICAgICAgICAgICAgICBWZWN0b3IyIGxvY2FsUG9pbnRCMSA9IHByb3h5Qi5WZXJ0aWNlc1tjYWNoZS5JbmRleEJbMF1dO1xyXG4gICAgICAgICAgICAgICAgVmVjdG9yMiBsb2NhbFBvaW50QjIgPSBwcm94eUIuVmVydGljZXNbY2FjaGUuSW5kZXhCWzFdXTtcclxuXHJcbiAgICAgICAgICAgICAgICBWZWN0b3IyIGEgPSBsb2NhbFBvaW50QjIgLSBsb2NhbFBvaW50QjE7XHJcbiAgICAgICAgICAgICAgICBfYXhpcyA9IG5ldyBWZWN0b3IyKGEuWSwgLWEuWCk7XHJcbiAgICAgICAgICAgICAgICBfYXhpcy5Ob3JtYWxpemUoKTtcclxuICAgICAgICAgICAgICAgIFZlY3RvcjIgbm9ybWFsID0gTWF0aFV0aWxzLk11bHRpcGx5KHJlZiB4ZkIuUiwgX2F4aXMpO1xyXG5cclxuICAgICAgICAgICAgICAgIF9sb2NhbFBvaW50ID0gMC41ZiAqIChsb2NhbFBvaW50QjEgKyBsb2NhbFBvaW50QjIpO1xyXG4gICAgICAgICAgICAgICAgVmVjdG9yMiBwb2ludEIgPSBNYXRoVXRpbHMuTXVsdGlwbHkocmVmIHhmQiwgX2xvY2FsUG9pbnQpO1xyXG5cclxuICAgICAgICAgICAgICAgIFZlY3RvcjIgbG9jYWxQb2ludEEgPSBwcm94eUEuVmVydGljZXNbY2FjaGUuSW5kZXhBWzBdXTtcclxuICAgICAgICAgICAgICAgIFZlY3RvcjIgcG9pbnRBID0gTWF0aFV0aWxzLk11bHRpcGx5KHJlZiB4ZkEsIGxvY2FsUG9pbnRBKTtcclxuXHJcbiAgICAgICAgICAgICAgICBmbG9hdCBzID0gVmVjdG9yMi5Eb3QocG9pbnRBIC0gcG9pbnRCLCBub3JtYWwpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHMgPCAwLjBmKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIF9heGlzID0gLV9heGlzO1xyXG4gICAgICAgICAgICAgICAgICAgIHMgPSAtcztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIC8vIFR3byBwb2ludHMgb24gQSBhbmQgb25lIG9yIHR3byBwb2ludHMgb24gQi5cclxuICAgICAgICAgICAgICAgIF90eXBlID0gU2VwYXJhdGlvbkZ1bmN0aW9uVHlwZS5GYWNlQTtcclxuICAgICAgICAgICAgICAgIFZlY3RvcjIgbG9jYWxQb2ludEExID0gX3Byb3h5QS5WZXJ0aWNlc1tjYWNoZS5JbmRleEFbMF1dO1xyXG4gICAgICAgICAgICAgICAgVmVjdG9yMiBsb2NhbFBvaW50QTIgPSBfcHJveHlBLlZlcnRpY2VzW2NhY2hlLkluZGV4QVsxXV07XHJcblxyXG4gICAgICAgICAgICAgICAgVmVjdG9yMiBhID0gbG9jYWxQb2ludEEyIC0gbG9jYWxQb2ludEExO1xyXG4gICAgICAgICAgICAgICAgX2F4aXMgPSBuZXcgVmVjdG9yMihhLlksIC1hLlgpO1xyXG4gICAgICAgICAgICAgICAgX2F4aXMuTm9ybWFsaXplKCk7XHJcbiAgICAgICAgICAgICAgICBWZWN0b3IyIG5vcm1hbCA9IE1hdGhVdGlscy5NdWx0aXBseShyZWYgeGZBLlIsIF9heGlzKTtcclxuXHJcbiAgICAgICAgICAgICAgICBfbG9jYWxQb2ludCA9IDAuNWYgKiAobG9jYWxQb2ludEExICsgbG9jYWxQb2ludEEyKTtcclxuICAgICAgICAgICAgICAgIFZlY3RvcjIgcG9pbnRBID0gTWF0aFV0aWxzLk11bHRpcGx5KHJlZiB4ZkEsIF9sb2NhbFBvaW50KTtcclxuXHJcbiAgICAgICAgICAgICAgICBWZWN0b3IyIGxvY2FsUG9pbnRCID0gX3Byb3h5Qi5WZXJ0aWNlc1tjYWNoZS5JbmRleEJbMF1dO1xyXG4gICAgICAgICAgICAgICAgVmVjdG9yMiBwb2ludEIgPSBNYXRoVXRpbHMuTXVsdGlwbHkocmVmIHhmQiwgbG9jYWxQb2ludEIpO1xyXG5cclxuICAgICAgICAgICAgICAgIGZsb2F0IHMgPSBWZWN0b3IyLkRvdChwb2ludEIgLSBwb2ludEEsIG5vcm1hbCk7XHJcbiAgICAgICAgICAgICAgICBpZiAocyA8IDAuMGYpXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgX2F4aXMgPSAtX2F4aXM7XHJcbiAgICAgICAgICAgICAgICAgICAgcyA9IC1zO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwdWJsaWMgc3RhdGljIGZsb2F0IEZpbmRNaW5TZXBhcmF0aW9uKG91dCBpbnQgaW5kZXhBLCBvdXQgaW50IGluZGV4QiwgZmxvYXQgdClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIFRyYW5zZm9ybSB4ZkEsIHhmQjtcclxuICAgICAgICAgICAgX3N3ZWVwQS5HZXRUcmFuc2Zvcm0ob3V0IHhmQSwgdCk7XHJcbiAgICAgICAgICAgIF9zd2VlcEIuR2V0VHJhbnNmb3JtKG91dCB4ZkIsIHQpO1xyXG5cclxuICAgICAgICAgICAgc3dpdGNoIChfdHlwZSlcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgY2FzZSBTZXBhcmF0aW9uRnVuY3Rpb25UeXBlLlBvaW50czpcclxuICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIFZlY3RvcjIgYXhpc0EgPSBNYXRoVXRpbHMuTXVsdGlwbHlUKHJlZiB4ZkEuUiwgX2F4aXMpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBWZWN0b3IyIGF4aXNCID0gTWF0aFV0aWxzLk11bHRpcGx5VChyZWYgeGZCLlIsIC1fYXhpcyk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpbmRleEEgPSBfcHJveHlBLkdldFN1cHBvcnQoYXhpc0EpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpbmRleEIgPSBfcHJveHlCLkdldFN1cHBvcnQoYXhpc0IpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgVmVjdG9yMiBsb2NhbFBvaW50QSA9IF9wcm94eUEuVmVydGljZXNbaW5kZXhBXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgVmVjdG9yMiBsb2NhbFBvaW50QiA9IF9wcm94eUIuVmVydGljZXNbaW5kZXhCXTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIFZlY3RvcjIgcG9pbnRBID0gTWF0aFV0aWxzLk11bHRpcGx5KHJlZiB4ZkEsIGxvY2FsUG9pbnRBKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgVmVjdG9yMiBwb2ludEIgPSBNYXRoVXRpbHMuTXVsdGlwbHkocmVmIHhmQiwgbG9jYWxQb2ludEIpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgZmxvYXQgc2VwYXJhdGlvbiA9IFZlY3RvcjIuRG90KHBvaW50QiAtIHBvaW50QSwgX2F4aXMpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2VwYXJhdGlvbjtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgY2FzZSBTZXBhcmF0aW9uRnVuY3Rpb25UeXBlLkZhY2VBOlxyXG4gICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgVmVjdG9yMiBub3JtYWwgPSBNYXRoVXRpbHMuTXVsdGlwbHkocmVmIHhmQS5SLCBfYXhpcyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIFZlY3RvcjIgcG9pbnRBID0gTWF0aFV0aWxzLk11bHRpcGx5KHJlZiB4ZkEsIF9sb2NhbFBvaW50KTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIFZlY3RvcjIgYXhpc0IgPSBNYXRoVXRpbHMuTXVsdGlwbHlUKHJlZiB4ZkIuUiwgLW5vcm1hbCk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpbmRleEEgPSAtMTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXhCID0gX3Byb3h5Qi5HZXRTdXBwb3J0KGF4aXNCKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIFZlY3RvcjIgbG9jYWxQb2ludEIgPSBfcHJveHlCLlZlcnRpY2VzW2luZGV4Ql07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIFZlY3RvcjIgcG9pbnRCID0gTWF0aFV0aWxzLk11bHRpcGx5KHJlZiB4ZkIsIGxvY2FsUG9pbnRCKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZsb2F0IHNlcGFyYXRpb24gPSBWZWN0b3IyLkRvdChwb2ludEIgLSBwb2ludEEsIG5vcm1hbCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzZXBhcmF0aW9uO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBjYXNlIFNlcGFyYXRpb25GdW5jdGlvblR5cGUuRmFjZUI6XHJcbiAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBWZWN0b3IyIG5vcm1hbCA9IE1hdGhVdGlscy5NdWx0aXBseShyZWYgeGZCLlIsIF9heGlzKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgVmVjdG9yMiBwb2ludEIgPSBNYXRoVXRpbHMuTXVsdGlwbHkocmVmIHhmQiwgX2xvY2FsUG9pbnQpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgVmVjdG9yMiBheGlzQSA9IE1hdGhVdGlscy5NdWx0aXBseVQocmVmIHhmQS5SLCAtbm9ybWFsKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4QiA9IC0xO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpbmRleEEgPSBfcHJveHlBLkdldFN1cHBvcnQoYXhpc0EpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgVmVjdG9yMiBsb2NhbFBvaW50QSA9IF9wcm94eUEuVmVydGljZXNbaW5kZXhBXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgVmVjdG9yMiBwb2ludEEgPSBNYXRoVXRpbHMuTXVsdGlwbHkocmVmIHhmQSwgbG9jYWxQb2ludEEpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgZmxvYXQgc2VwYXJhdGlvbiA9IFZlY3RvcjIuRG90KHBvaW50QSAtIHBvaW50Qiwgbm9ybWFsKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNlcGFyYXRpb247XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICAgICAgRGVidWcuQXNzZXJ0KGZhbHNlKTtcclxuICAgICAgICAgICAgICAgICAgICBpbmRleEEgPSAtMTtcclxuICAgICAgICAgICAgICAgICAgICBpbmRleEIgPSAtMTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gMC4wZjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHVibGljIHN0YXRpYyBmbG9hdCBFdmFsdWF0ZShpbnQgaW5kZXhBLCBpbnQgaW5kZXhCLCBmbG9hdCB0KVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgVHJhbnNmb3JtIHhmQSwgeGZCO1xyXG4gICAgICAgICAgICBfc3dlZXBBLkdldFRyYW5zZm9ybShvdXQgeGZBLCB0KTtcclxuICAgICAgICAgICAgX3N3ZWVwQi5HZXRUcmFuc2Zvcm0ob3V0IHhmQiwgdCk7XHJcblxyXG4gICAgICAgICAgICBzd2l0Y2ggKF90eXBlKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBjYXNlIFNlcGFyYXRpb25GdW5jdGlvblR5cGUuUG9pbnRzOlxyXG4gICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgVmVjdG9yMiBheGlzQSA9IE1hdGhVdGlscy5NdWx0aXBseVQocmVmIHhmQS5SLCBfYXhpcyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIFZlY3RvcjIgYXhpc0IgPSBNYXRoVXRpbHMuTXVsdGlwbHlUKHJlZiB4ZkIuUiwgLV9heGlzKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIFZlY3RvcjIgbG9jYWxQb2ludEEgPSBfcHJveHlBLlZlcnRpY2VzW2luZGV4QV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIFZlY3RvcjIgbG9jYWxQb2ludEIgPSBfcHJveHlCLlZlcnRpY2VzW2luZGV4Ql07XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBWZWN0b3IyIHBvaW50QSA9IE1hdGhVdGlscy5NdWx0aXBseShyZWYgeGZBLCBsb2NhbFBvaW50QSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIFZlY3RvcjIgcG9pbnRCID0gTWF0aFV0aWxzLk11bHRpcGx5KHJlZiB4ZkIsIGxvY2FsUG9pbnRCKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZmxvYXQgc2VwYXJhdGlvbiA9IFZlY3RvcjIuRG90KHBvaW50QiAtIHBvaW50QSwgX2F4aXMpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNlcGFyYXRpb247XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGNhc2UgU2VwYXJhdGlvbkZ1bmN0aW9uVHlwZS5GYWNlQTpcclxuICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIFZlY3RvcjIgbm9ybWFsID0gTWF0aFV0aWxzLk11bHRpcGx5KHJlZiB4ZkEuUiwgX2F4aXMpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBWZWN0b3IyIHBvaW50QSA9IE1hdGhVdGlscy5NdWx0aXBseShyZWYgeGZBLCBfbG9jYWxQb2ludCk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBWZWN0b3IyIGF4aXNCID0gTWF0aFV0aWxzLk11bHRpcGx5VChyZWYgeGZCLlIsIC1ub3JtYWwpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgVmVjdG9yMiBsb2NhbFBvaW50QiA9IF9wcm94eUIuVmVydGljZXNbaW5kZXhCXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgVmVjdG9yMiBwb2ludEIgPSBNYXRoVXRpbHMuTXVsdGlwbHkocmVmIHhmQiwgbG9jYWxQb2ludEIpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgZmxvYXQgc2VwYXJhdGlvbiA9IFZlY3RvcjIuRG90KHBvaW50QiAtIHBvaW50QSwgbm9ybWFsKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNlcGFyYXRpb247XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGNhc2UgU2VwYXJhdGlvbkZ1bmN0aW9uVHlwZS5GYWNlQjpcclxuICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIFZlY3RvcjIgbm9ybWFsID0gTWF0aFV0aWxzLk11bHRpcGx5KHJlZiB4ZkIuUiwgX2F4aXMpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBWZWN0b3IyIHBvaW50QiA9IE1hdGhVdGlscy5NdWx0aXBseShyZWYgeGZCLCBfbG9jYWxQb2ludCk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBWZWN0b3IyIGF4aXNBID0gTWF0aFV0aWxzLk11bHRpcGx5VChyZWYgeGZBLlIsIC1ub3JtYWwpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgVmVjdG9yMiBsb2NhbFBvaW50QSA9IF9wcm94eUEuVmVydGljZXNbaW5kZXhBXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgVmVjdG9yMiBwb2ludEEgPSBNYXRoVXRpbHMuTXVsdGlwbHkocmVmIHhmQSwgbG9jYWxQb2ludEEpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgZmxvYXQgc2VwYXJhdGlvbiA9IFZlY3RvcjIuRG90KHBvaW50QSAtIHBvaW50Qiwgbm9ybWFsKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNlcGFyYXRpb247XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICAgICAgRGVidWcuQXNzZXJ0KGZhbHNlKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gMC4wZjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgc3RhdGljIGNsYXNzIFRpbWVPZkltcGFjdFxyXG4gICAge1xyXG4gICAgICAgIC8vIENDRCB2aWEgdGhlIGxvY2FsIHNlcGFyYXRpbmcgYXhpcyBtZXRob2QuIFRoaXMgc2Vla3MgcHJvZ3Jlc3Npb25cclxuICAgICAgICAvLyBieSBjb21wdXRpbmcgdGhlIGxhcmdlc3QgdGltZSBhdCB3aGljaCBzZXBhcmF0aW9uIGlzIG1haW50YWluZWQuXHJcblxyXG4gICAgICAgIHB1YmxpYyBzdGF0aWMgaW50IFRPSUNhbGxzLCBUT0lJdGVycywgVE9JTWF4SXRlcnM7XHJcbiAgICAgICAgcHVibGljIHN0YXRpYyBpbnQgVE9JUm9vdEl0ZXJzLCBUT0lNYXhSb290SXRlcnM7XHJcbiAgICAgICAgcHJpdmF0ZSBzdGF0aWMgRGlzdGFuY2VJbnB1dCBfZGlzdGFuY2VJbnB1dCA9IG5ldyBEaXN0YW5jZUlucHV0KCk7XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gQ29tcHV0ZSB0aGUgdXBwZXIgYm91bmQgb24gdGltZSBiZWZvcmUgdHdvIHNoYXBlcyBwZW5ldHJhdGUuIFRpbWUgaXMgcmVwcmVzZW50ZWQgYXNcclxuICAgICAgICAvLy8gYSBmcmFjdGlvbiBiZXR3ZWVuIFswLHRNYXhdLiBUaGlzIHVzZXMgYSBzd2VwdCBzZXBhcmF0aW5nIGF4aXMgYW5kIG1heSBtaXNzIHNvbWUgaW50ZXJtZWRpYXRlLFxyXG4gICAgICAgIC8vLyBub24tdHVubmVsaW5nIGNvbGxpc2lvbi4gSWYgeW91IGNoYW5nZSB0aGUgdGltZSBpbnRlcnZhbCwgeW91IHNob3VsZCBjYWxsIHRoaXMgZnVuY3Rpb25cclxuICAgICAgICAvLy8gYWdhaW4uXHJcbiAgICAgICAgLy8vIE5vdGU6IHVzZSBEaXN0YW5jZSgpIHRvIGNvbXB1dGUgdGhlIGNvbnRhY3QgcG9pbnQgYW5kIG5vcm1hbCBhdCB0aGUgdGltZSBvZiBpbXBhY3QuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJvdXRwdXRcIj5UaGUgb3V0cHV0LjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwiaW5wdXRcIj5UaGUgaW5wdXQuPC9wYXJhbT5cclxuICAgICAgICBwdWJsaWMgc3RhdGljIHZvaWQgQ2FsY3VsYXRlVGltZU9mSW1wYWN0KG91dCBUT0lPdXRwdXQgb3V0cHV0LCBUT0lJbnB1dCBpbnB1dClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgICsrVE9JQ2FsbHM7XHJcblxyXG4gICAgICAgICAgICBvdXRwdXQgPSBuZXcgVE9JT3V0cHV0KCk7XHJcbiAgICAgICAgICAgIG91dHB1dC5TdGF0ZSA9IFRPSU91dHB1dFN0YXRlLlVua25vd247XHJcbiAgICAgICAgICAgIG91dHB1dC5UID0gaW5wdXQuVE1heDtcclxuXHJcbiAgICAgICAgICAgIFN3ZWVwIHN3ZWVwQSA9IGlucHV0LlN3ZWVwQTtcclxuICAgICAgICAgICAgU3dlZXAgc3dlZXBCID0gaW5wdXQuU3dlZXBCO1xyXG5cclxuICAgICAgICAgICAgLy8gTGFyZ2Ugcm90YXRpb25zIGNhbiBtYWtlIHRoZSByb290IGZpbmRlciBmYWlsLCBzbyB3ZSBub3JtYWxpemUgdGhlXHJcbiAgICAgICAgICAgIC8vIHN3ZWVwIGFuZ2xlcy5cclxuICAgICAgICAgICAgc3dlZXBBLk5vcm1hbGl6ZSgpO1xyXG4gICAgICAgICAgICBzd2VlcEIuTm9ybWFsaXplKCk7XHJcblxyXG4gICAgICAgICAgICBmbG9hdCB0TWF4ID0gaW5wdXQuVE1heDtcclxuXHJcbiAgICAgICAgICAgIGZsb2F0IHRvdGFsUmFkaXVzID0gaW5wdXQuUHJveHlBLlJhZGl1cyArIGlucHV0LlByb3h5Qi5SYWRpdXM7XHJcbiAgICAgICAgICAgIGZsb2F0IHRhcmdldCA9IE1hdGguTWF4KFNldHRpbmdzLkxpbmVhclNsb3AsIHRvdGFsUmFkaXVzIC0gMy4wZiAqIFNldHRpbmdzLkxpbmVhclNsb3ApO1xyXG4gICAgICAgICAgICBjb25zdCBmbG9hdCB0b2xlcmFuY2UgPSAwLjI1ZiAqIFNldHRpbmdzLkxpbmVhclNsb3A7XHJcbiAgICAgICAgICAgIERlYnVnLkFzc2VydCh0YXJnZXQgPiB0b2xlcmFuY2UpO1xyXG5cclxuICAgICAgICAgICAgZmxvYXQgdDEgPSAwLjBmO1xyXG4gICAgICAgICAgICBjb25zdCBpbnQga19tYXhJdGVyYXRpb25zID0gMjA7XHJcbiAgICAgICAgICAgIGludCBpdGVyID0gMDtcclxuXHJcbiAgICAgICAgICAgIC8vIFByZXBhcmUgaW5wdXQgZm9yIGRpc3RhbmNlIHF1ZXJ5LlxyXG4gICAgICAgICAgICBTaW1wbGV4Q2FjaGUgY2FjaGU7XHJcbiAgICAgICAgICAgIF9kaXN0YW5jZUlucHV0LlByb3h5QSA9IGlucHV0LlByb3h5QTtcclxuICAgICAgICAgICAgX2Rpc3RhbmNlSW5wdXQuUHJveHlCID0gaW5wdXQuUHJveHlCO1xyXG4gICAgICAgICAgICBfZGlzdGFuY2VJbnB1dC5Vc2VSYWRpaSA9IGZhbHNlO1xyXG5cclxuICAgICAgICAgICAgLy8gVGhlIG91dGVyIGxvb3AgcHJvZ3Jlc3NpdmVseSBhdHRlbXB0cyB0byBjb21wdXRlIG5ldyBzZXBhcmF0aW5nIGF4ZXMuXHJcbiAgICAgICAgICAgIC8vIFRoaXMgbG9vcCB0ZXJtaW5hdGVzIHdoZW4gYW4gYXhpcyBpcyByZXBlYXRlZCAobm8gcHJvZ3Jlc3MgaXMgbWFkZSkuXHJcbiAgICAgICAgICAgIGZvciAoOyA7IClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgVHJhbnNmb3JtIHhmQSwgeGZCO1xyXG4gICAgICAgICAgICAgICAgc3dlZXBBLkdldFRyYW5zZm9ybShvdXQgeGZBLCB0MSk7XHJcbiAgICAgICAgICAgICAgICBzd2VlcEIuR2V0VHJhbnNmb3JtKG91dCB4ZkIsIHQxKTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBHZXQgdGhlIGRpc3RhbmNlIGJldHdlZW4gc2hhcGVzLiBXZSBjYW4gYWxzbyB1c2UgdGhlIHJlc3VsdHNcclxuICAgICAgICAgICAgICAgIC8vIHRvIGdldCBhIHNlcGFyYXRpbmcgYXhpcy5cclxuICAgICAgICAgICAgICAgIF9kaXN0YW5jZUlucHV0LlRyYW5zZm9ybUEgPSB4ZkE7XHJcbiAgICAgICAgICAgICAgICBfZGlzdGFuY2VJbnB1dC5UcmFuc2Zvcm1CID0geGZCO1xyXG4gICAgICAgICAgICAgICAgRGlzdGFuY2VPdXRwdXQgZGlzdGFuY2VPdXRwdXQ7XHJcbiAgICAgICAgICAgICAgICBEaXN0YW5jZS5Db21wdXRlRGlzdGFuY2Uob3V0IGRpc3RhbmNlT3V0cHV0LCBvdXQgY2FjaGUsIF9kaXN0YW5jZUlucHV0KTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBJZiB0aGUgc2hhcGVzIGFyZSBvdmVybGFwcGVkLCB3ZSBnaXZlIHVwIG9uIGNvbnRpbnVvdXMgY29sbGlzaW9uLlxyXG4gICAgICAgICAgICAgICAgaWYgKGRpc3RhbmNlT3V0cHV0LkRpc3RhbmNlIDw9IDAuMGYpXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gRmFpbHVyZSFcclxuICAgICAgICAgICAgICAgICAgICBvdXRwdXQuU3RhdGUgPSBUT0lPdXRwdXRTdGF0ZS5PdmVybGFwcGVkO1xyXG4gICAgICAgICAgICAgICAgICAgIG91dHB1dC5UID0gMC4wZjtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoZGlzdGFuY2VPdXRwdXQuRGlzdGFuY2UgPCB0YXJnZXQgKyB0b2xlcmFuY2UpXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gVmljdG9yeSFcclxuICAgICAgICAgICAgICAgICAgICBvdXRwdXQuU3RhdGUgPSBUT0lPdXRwdXRTdGF0ZS5Ub3VjaGluZztcclxuICAgICAgICAgICAgICAgICAgICBvdXRwdXQuVCA9IHQxO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIFNlcGFyYXRpb25GdW5jdGlvbi5TZXQocmVmIGNhY2hlLCBpbnB1dC5Qcm94eUEsIHJlZiBzd2VlcEEsIGlucHV0LlByb3h5QiwgcmVmIHN3ZWVwQiwgdDEpO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIENvbXB1dGUgdGhlIFRPSSBvbiB0aGUgc2VwYXJhdGluZyBheGlzLiBXZSBkbyB0aGlzIGJ5IHN1Y2Nlc3NpdmVseVxyXG4gICAgICAgICAgICAgICAgLy8gcmVzb2x2aW5nIHRoZSBkZWVwZXN0IHBvaW50LiBUaGlzIGxvb3AgaXMgYm91bmRlZCBieSB0aGUgbnVtYmVyIG9mIHZlcnRpY2VzLlxyXG4gICAgICAgICAgICAgICAgYm9vbCBkb25lID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICBmbG9hdCB0MiA9IHRNYXg7XHJcbiAgICAgICAgICAgICAgICBpbnQgcHVzaEJhY2tJdGVyID0gMDtcclxuICAgICAgICAgICAgICAgIGZvciAoOyA7IClcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBGaW5kIHRoZSBkZWVwZXN0IHBvaW50IGF0IHQyLiBTdG9yZSB0aGUgd2l0bmVzcyBwb2ludCBpbmRpY2VzLlxyXG4gICAgICAgICAgICAgICAgICAgIGludCBpbmRleEEsIGluZGV4QjtcclxuICAgICAgICAgICAgICAgICAgICBmbG9hdCBzMiA9IFNlcGFyYXRpb25GdW5jdGlvbi5GaW5kTWluU2VwYXJhdGlvbihvdXQgaW5kZXhBLCBvdXQgaW5kZXhCLCB0Mik7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIElzIHRoZSBmaW5hbCBjb25maWd1cmF0aW9uIHNlcGFyYXRlZD9cclxuICAgICAgICAgICAgICAgICAgICBpZiAoczIgPiB0YXJnZXQgKyB0b2xlcmFuY2UpXHJcbiAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBWaWN0b3J5IVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXQuU3RhdGUgPSBUT0lPdXRwdXRTdGF0ZS5TZXBlcmF0ZWQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dC5UID0gdE1heDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZG9uZSA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gSGFzIHRoZSBzZXBhcmF0aW9uIHJlYWNoZWQgdG9sZXJhbmNlP1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChzMiA+IHRhcmdldCAtIHRvbGVyYW5jZSlcclxuICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEFkdmFuY2UgdGhlIHN3ZWVwc1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0MSA9IHQyO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIENvbXB1dGUgdGhlIGluaXRpYWwgc2VwYXJhdGlvbiBvZiB0aGUgd2l0bmVzcyBwb2ludHMuXHJcbiAgICAgICAgICAgICAgICAgICAgZmxvYXQgczEgPSBTZXBhcmF0aW9uRnVuY3Rpb24uRXZhbHVhdGUoaW5kZXhBLCBpbmRleEIsIHQxKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gQ2hlY2sgZm9yIGluaXRpYWwgb3ZlcmxhcC4gVGhpcyBtaWdodCBoYXBwZW4gaWYgdGhlIHJvb3QgZmluZGVyXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gcnVucyBvdXQgb2YgaXRlcmF0aW9ucy5cclxuICAgICAgICAgICAgICAgICAgICBpZiAoczEgPCB0YXJnZXQgLSB0b2xlcmFuY2UpXHJcbiAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXQuU3RhdGUgPSBUT0lPdXRwdXRTdGF0ZS5GYWlsZWQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dC5UID0gdDE7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRvbmUgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIENoZWNrIGZvciB0b3VjaGluZ1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChzMSA8PSB0YXJnZXQgKyB0b2xlcmFuY2UpXHJcbiAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBWaWN0b3J5ISB0MSBzaG91bGQgaG9sZCB0aGUgVE9JIChjb3VsZCBiZSAwLjApLlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXQuU3RhdGUgPSBUT0lPdXRwdXRTdGF0ZS5Ub3VjaGluZztcclxuICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0LlQgPSB0MTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZG9uZSA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gQ29tcHV0ZSAxRCByb290IG9mOiBmKHgpIC0gdGFyZ2V0ID0gMFxyXG4gICAgICAgICAgICAgICAgICAgIGludCByb290SXRlckNvdW50ID0gMDtcclxuICAgICAgICAgICAgICAgICAgICBmbG9hdCBhMSA9IHQxLCBhMiA9IHQyO1xyXG4gICAgICAgICAgICAgICAgICAgIGZvciAoOyA7IClcclxuICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFVzZSBhIG1peCBvZiB0aGUgc2VjYW50IHJ1bGUgYW5kIGJpc2VjdGlvbi5cclxuICAgICAgICAgICAgICAgICAgICAgICAgZmxvYXQgdDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKChyb290SXRlckNvdW50ICYgMSkgIT0gMClcclxuICAgICAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gU2VjYW50IHJ1bGUgdG8gaW1wcm92ZSBjb252ZXJnZW5jZS5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHQgPSBhMSArICh0YXJnZXQgLSBzMSkgKiAoYTIgLSBhMSkgLyAoczIgLSBzMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBCaXNlY3Rpb24gdG8gZ3VhcmFudGVlIHByb2dyZXNzLlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdCA9IDAuNWYgKiAoYTEgKyBhMik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZsb2F0IHMgPSBTZXBhcmF0aW9uRnVuY3Rpb24uRXZhbHVhdGUoaW5kZXhBLCBpbmRleEIsIHQpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKE1hdGguQWJzKHMgLSB0YXJnZXQpIDwgdG9sZXJhbmNlKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB0MiBob2xkcyBhIHRlbnRhdGl2ZSB2YWx1ZSBmb3IgdDFcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHQyID0gdDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBFbnN1cmUgd2UgY29udGludWUgdG8gYnJhY2tldCB0aGUgcm9vdC5cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHMgPiB0YXJnZXQpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGExID0gdDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHMxID0gcztcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGEyID0gdDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHMyID0gcztcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgKytyb290SXRlckNvdW50O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICArK1RPSVJvb3RJdGVycztcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyb290SXRlckNvdW50ID09IDUwKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgVE9JTWF4Um9vdEl0ZXJzID0gTWF0aC5NYXgoVE9JTWF4Um9vdEl0ZXJzLCByb290SXRlckNvdW50KTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgKytwdXNoQmFja0l0ZXI7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChwdXNoQmFja0l0ZXIgPT0gU2V0dGluZ3MuTWF4UG9seWdvblZlcnRpY2VzKVxyXG4gICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICsraXRlcjtcclxuICAgICAgICAgICAgICAgICsrVE9JSXRlcnM7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKGRvbmUpXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKGl0ZXIgPT0ga19tYXhJdGVyYXRpb25zKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIFJvb3QgZmluZGVyIGdvdCBzdHVjay4gU2VtaS12aWN0b3J5LlxyXG4gICAgICAgICAgICAgICAgICAgIG91dHB1dC5TdGF0ZSA9IFRPSU91dHB1dFN0YXRlLkZhaWxlZDtcclxuICAgICAgICAgICAgICAgICAgICBvdXRwdXQuVCA9IHQxO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBUT0lNYXhJdGVycyA9IE1hdGguTWF4KFRPSU1heEl0ZXJzLCBpdGVyKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn0iLCIvKlxyXG4qIEZhcnNlZXIgUGh5c2ljcyBFbmdpbmUgYmFzZWQgb24gQm94MkQuWE5BIHBvcnQ6XHJcbiogQ29weXJpZ2h0IChjKSAyMDEwIElhbiBRdmlzdFxyXG4qIFxyXG4qIEJveDJELlhOQSBwb3J0IG9mIEJveDJEOlxyXG4qIENvcHlyaWdodCAoYykgMjAwOSBCcmFuZG9uIEZ1cnR3YW5nbGVyLCBOYXRoYW4gRnVydHdhbmdsZXJcclxuKlxyXG4qIE9yaWdpbmFsIHNvdXJjZSBCb3gyRDpcclxuKiBDb3B5cmlnaHQgKGMpIDIwMDYtMjAwOSBFcmluIENhdHRvIGh0dHA6Ly93d3cuZ3BoeXNpY3MuY29tIFxyXG4qIFxyXG4qIFRoaXMgc29mdHdhcmUgaXMgcHJvdmlkZWQgJ2FzLWlzJywgd2l0aG91dCBhbnkgZXhwcmVzcyBvciBpbXBsaWVkIFxyXG4qIHdhcnJhbnR5LiAgSW4gbm8gZXZlbnQgd2lsbCB0aGUgYXV0aG9ycyBiZSBoZWxkIGxpYWJsZSBmb3IgYW55IGRhbWFnZXMgXHJcbiogYXJpc2luZyBmcm9tIHRoZSB1c2Ugb2YgdGhpcyBzb2Z0d2FyZS4gXHJcbiogUGVybWlzc2lvbiBpcyBncmFudGVkIHRvIGFueW9uZSB0byB1c2UgdGhpcyBzb2Z0d2FyZSBmb3IgYW55IHB1cnBvc2UsIFxyXG4qIGluY2x1ZGluZyBjb21tZXJjaWFsIGFwcGxpY2F0aW9ucywgYW5kIHRvIGFsdGVyIGl0IGFuZCByZWRpc3RyaWJ1dGUgaXQgXHJcbiogZnJlZWx5LCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgcmVzdHJpY3Rpb25zOiBcclxuKiAxLiBUaGUgb3JpZ2luIG9mIHRoaXMgc29mdHdhcmUgbXVzdCBub3QgYmUgbWlzcmVwcmVzZW50ZWQ7IHlvdSBtdXN0IG5vdCBcclxuKiBjbGFpbSB0aGF0IHlvdSB3cm90ZSB0aGUgb3JpZ2luYWwgc29mdHdhcmUuIElmIHlvdSB1c2UgdGhpcyBzb2Z0d2FyZSBcclxuKiBpbiBhIHByb2R1Y3QsIGFuIGFja25vd2xlZGdtZW50IGluIHRoZSBwcm9kdWN0IGRvY3VtZW50YXRpb24gd291bGQgYmUgXHJcbiogYXBwcmVjaWF0ZWQgYnV0IGlzIG5vdCByZXF1aXJlZC4gXHJcbiogMi4gQWx0ZXJlZCBzb3VyY2UgdmVyc2lvbnMgbXVzdCBiZSBwbGFpbmx5IG1hcmtlZCBhcyBzdWNoLCBhbmQgbXVzdCBub3QgYmUgXHJcbiogbWlzcmVwcmVzZW50ZWQgYXMgYmVpbmcgdGhlIG9yaWdpbmFsIHNvZnR3YXJlLiBcclxuKiAzLiBUaGlzIG5vdGljZSBtYXkgbm90IGJlIHJlbW92ZWQgb3IgYWx0ZXJlZCBmcm9tIGFueSBzb3VyY2UgZGlzdHJpYnV0aW9uLiBcclxuKi9cclxuXHJcbnVzaW5nIFN5c3RlbTtcclxudXNpbmcgRmFyc2VlclBoeXNpY3MuQ29tbW9uO1xyXG51c2luZyBNaWNyb3NvZnQuWG5hLkZyYW1ld29yaztcclxuXHJcbm5hbWVzcGFjZSBGYXJzZWVyUGh5c2ljcy5Db2xsaXNpb24uU2hhcGVzXHJcbntcclxuICAgIC8vLyA8c3VtbWFyeT5cclxuICAgIC8vLyBUaGlzIGhvbGRzIHRoZSBtYXNzIGRhdGEgY29tcHV0ZWQgZm9yIGEgc2hhcGUuXHJcbiAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgcHVibGljIHN0cnVjdCBNYXNzRGF0YSA6IElFcXVhdGFibGU8TWFzc0RhdGE+XHJcbiAgICB7XHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBUaGUgYXJlYSBvZiB0aGUgc2hhcGVcclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIHB1YmxpYyBmbG9hdCBBcmVhO1xyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIFRoZSBwb3NpdGlvbiBvZiB0aGUgc2hhcGUncyBjZW50cm9pZCByZWxhdGl2ZSB0byB0aGUgc2hhcGUncyBvcmlnaW4uXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICBwdWJsaWMgVmVjdG9yMiBDZW50cm9pZDtcclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBUaGUgcm90YXRpb25hbCBpbmVydGlhIG9mIHRoZSBzaGFwZSBhYm91dCB0aGUgbG9jYWwgb3JpZ2luLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgcHVibGljIGZsb2F0IEluZXJ0aWE7XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gVGhlIG1hc3Mgb2YgdGhlIHNoYXBlLCB1c3VhbGx5IGluIGtpbG9ncmFtcy5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIHB1YmxpYyBmbG9hdCBNYXNzO1xyXG5cclxuICAgICAgICAjcmVnaW9uIElFcXVhdGFibGU8TWFzc0RhdGE+IE1lbWJlcnNcclxuXHJcbiAgICAgICAgcHVibGljIGJvb2wgRXF1YWxzKE1hc3NEYXRhIG90aGVyKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMgPT0gb3RoZXI7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAjZW5kcmVnaW9uXHJcblxyXG4gICAgICAgIHB1YmxpYyBzdGF0aWMgYm9vbCBvcGVyYXRvciA9PShNYXNzRGF0YSBsZWZ0LCBNYXNzRGF0YSByaWdodClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiAobGVmdC5BcmVhID09IHJpZ2h0LkFyZWEgJiYgbGVmdC5NYXNzID09IHJpZ2h0Lk1hc3MgJiYgbGVmdC5DZW50cm9pZCA9PSByaWdodC5DZW50cm9pZCAmJlxyXG4gICAgICAgICAgICAgICAgICAgIGxlZnQuSW5lcnRpYSA9PSByaWdodC5JbmVydGlhKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHB1YmxpYyBzdGF0aWMgYm9vbCBvcGVyYXRvciAhPShNYXNzRGF0YSBsZWZ0LCBNYXNzRGF0YSByaWdodClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiAhKGxlZnQgPT0gcmlnaHQpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHVibGljIG92ZXJyaWRlIGJvb2wgRXF1YWxzKG9iamVjdCBvYmopXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBpZiAoUmVmZXJlbmNlRXF1YWxzKG51bGwsIG9iaikpIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgaWYgKG9iai5HZXRUeXBlKCkgIT0gdHlwZW9mKE1hc3NEYXRhKSkgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICByZXR1cm4gRXF1YWxzKChNYXNzRGF0YSlvYmopO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHVibGljIG92ZXJyaWRlIGludCBHZXRIYXNoQ29kZSgpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB1bmNoZWNrZWRcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgaW50IHJlc3VsdCA9IEFyZWEuR2V0SGFzaENvZGUoKTtcclxuICAgICAgICAgICAgICAgIHJlc3VsdCA9IChyZXN1bHQgKiAzOTcpIF4gQ2VudHJvaWQuR2V0SGFzaENvZGUoKTtcclxuICAgICAgICAgICAgICAgIHJlc3VsdCA9IChyZXN1bHQgKiAzOTcpIF4gSW5lcnRpYS5HZXRIYXNoQ29kZSgpO1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gKHJlc3VsdCAqIDM5NykgXiBNYXNzLkdldEhhc2hDb2RlKCk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBlbnVtIFNoYXBlVHlwZVxyXG4gICAge1xyXG4gICAgICAgIFVua25vd24gPSAtMSxcclxuICAgICAgICBDaXJjbGUgPSAwLFxyXG4gICAgICAgIEVkZ2UgPSAxLFxyXG4gICAgICAgIFBvbHlnb24gPSAyLFxyXG4gICAgICAgIExvb3AgPSAzLFxyXG4gICAgICAgIFR5cGVDb3VudCA9IDQsXHJcbiAgICB9XHJcblxyXG4gICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgLy8vIEEgc2hhcGUgaXMgdXNlZCBmb3IgY29sbGlzaW9uIGRldGVjdGlvbi4gWW91IGNhbiBjcmVhdGUgYSBzaGFwZSBob3dldmVyIHlvdSBsaWtlLlxyXG4gICAgLy8vIFNoYXBlcyB1c2VkIGZvciBzaW11bGF0aW9uIGluIFdvcmxkIGFyZSBjcmVhdGVkIGF1dG9tYXRpY2FsbHkgd2hlbiBhIEZpeHR1cmVcclxuICAgIC8vLyBpcyBjcmVhdGVkLiBTaGFwZXMgbWF5IGVuY2Fwc3VsYXRlIGEgb25lIG9yIG1vcmUgY2hpbGQgc2hhcGVzLlxyXG4gICAgLy8vIDwvc3VtbWFyeT5cclxuICAgIHB1YmxpYyBhYnN0cmFjdCBjbGFzcyBTaGFwZVxyXG4gICAge1xyXG4gICAgICAgIHByaXZhdGUgc3RhdGljIGludCBfc2hhcGVJZENvdW50ZXI7XHJcbiAgICAgICAgcHVibGljIE1hc3NEYXRhIE1hc3NEYXRhO1xyXG4gICAgICAgIHB1YmxpYyBpbnQgU2hhcGVJZDtcclxuXHJcbiAgICAgICAgaW50ZXJuYWwgZmxvYXQgX2RlbnNpdHk7XHJcbiAgICAgICAgaW50ZXJuYWwgZmxvYXQgX3JhZGl1cztcclxuXHJcbiAgICAgICAgcHJvdGVjdGVkIFNoYXBlKGZsb2F0IGRlbnNpdHkpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBfZGVuc2l0eSA9IGRlbnNpdHk7XHJcbiAgICAgICAgICAgIFNoYXBlVHlwZSA9IFNoYXBlVHlwZS5Vbmtub3duO1xyXG4gICAgICAgICAgICBTaGFwZUlkID0gX3NoYXBlSWRDb3VudGVyKys7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIEdldCB0aGUgdHlwZSBvZiB0aGlzIHNoYXBlLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDx2YWx1ZT5UaGUgdHlwZSBvZiB0aGUgc2hhcGUuPC92YWx1ZT5cclxuICAgICAgICBwdWJsaWMgU2hhcGVUeXBlIFNoYXBlVHlwZSB7IGdldDsgaW50ZXJuYWwgc2V0OyB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gR2V0IHRoZSBudW1iZXIgb2YgY2hpbGQgcHJpbWl0aXZlcy5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8dmFsdWU+PC92YWx1ZT5cclxuICAgICAgICBwdWJsaWMgYWJzdHJhY3QgaW50IENoaWxkQ291bnQgeyBnZXQ7IH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBHZXRzIG9yIHNldHMgdGhlIGRlbnNpdHkuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHZhbHVlPlRoZSBkZW5zaXR5LjwvdmFsdWU+XHJcbiAgICAgICAgcHVibGljIGZsb2F0IERlbnNpdHlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGdldCB7IHJldHVybiBfZGVuc2l0eTsgfVxyXG4gICAgICAgICAgICBzZXRcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgX2RlbnNpdHkgPSB2YWx1ZTtcclxuICAgICAgICAgICAgICAgIENvbXB1dGVQcm9wZXJ0aWVzKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gUmFkaXVzIG9mIHRoZSBTaGFwZVxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgcHVibGljIGZsb2F0IFJhZGl1c1xyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgZ2V0IHsgcmV0dXJuIF9yYWRpdXM7IH1cclxuICAgICAgICAgICAgc2V0XHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIF9yYWRpdXMgPSB2YWx1ZTtcclxuICAgICAgICAgICAgICAgIENvbXB1dGVQcm9wZXJ0aWVzKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gQ2xvbmUgdGhlIGNvbmNyZXRlIHNoYXBlXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHJldHVybnM+QSBjbG9uZSBvZiB0aGUgc2hhcGU8L3JldHVybnM+XHJcbiAgICAgICAgcHVibGljIGFic3RyYWN0IFNoYXBlIENsb25lKCk7XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gVGVzdCBhIHBvaW50IGZvciBjb250YWlubWVudCBpbiB0aGlzIHNoYXBlLiBUaGlzIG9ubHkgd29ya3MgZm9yIGNvbnZleCBzaGFwZXMuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJ0cmFuc2Zvcm1cIj5UaGUgc2hhcGUgd29ybGQgdHJhbnNmb3JtLjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwicG9pbnRcIj5hIHBvaW50IGluIHdvcmxkIGNvb3JkaW5hdGVzLjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxyZXR1cm5zPlRydWUgaWYgdGhlIHBvaW50IGlzIGluc2lkZSB0aGUgc2hhcGU8L3JldHVybnM+XHJcbiAgICAgICAgcHVibGljIGFic3RyYWN0IGJvb2wgVGVzdFBvaW50KHJlZiBUcmFuc2Zvcm0gdHJhbnNmb3JtLCByZWYgVmVjdG9yMiBwb2ludCk7XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gQ2FzdCBhIHJheSBhZ2FpbnN0IGEgY2hpbGQgc2hhcGUuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJvdXRwdXRcIj5UaGUgcmF5LWNhc3QgcmVzdWx0cy48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cImlucHV0XCI+VGhlIHJheS1jYXN0IGlucHV0IHBhcmFtZXRlcnMuPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJ0cmFuc2Zvcm1cIj5UaGUgdHJhbnNmb3JtIHRvIGJlIGFwcGxpZWQgdG8gdGhlIHNoYXBlLjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwiY2hpbGRJbmRleFwiPlRoZSBjaGlsZCBzaGFwZSBpbmRleC48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cmV0dXJucz5UcnVlIGlmIHRoZSByYXktY2FzdCBoaXRzIHRoZSBzaGFwZTwvcmV0dXJucz5cclxuICAgICAgICBwdWJsaWMgYWJzdHJhY3QgYm9vbCBSYXlDYXN0KG91dCBSYXlDYXN0T3V0cHV0IG91dHB1dCwgcmVmIFJheUNhc3RJbnB1dCBpbnB1dCwgcmVmIFRyYW5zZm9ybSB0cmFuc2Zvcm0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnQgY2hpbGRJbmRleCk7XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gR2l2ZW4gYSB0cmFuc2Zvcm0sIGNvbXB1dGUgdGhlIGFzc29jaWF0ZWQgYXhpcyBhbGlnbmVkIGJvdW5kaW5nIGJveCBmb3IgYSBjaGlsZCBzaGFwZS5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cImFhYmJcIj5UaGUgYWFiYiByZXN1bHRzLjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwidHJhbnNmb3JtXCI+VGhlIHdvcmxkIHRyYW5zZm9ybSBvZiB0aGUgc2hhcGUuPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJjaGlsZEluZGV4XCI+VGhlIGNoaWxkIHNoYXBlIGluZGV4LjwvcGFyYW0+XHJcbiAgICAgICAgcHVibGljIGFic3RyYWN0IHZvaWQgQ29tcHV0ZUFBQkIob3V0IEFBQkIgYWFiYiwgcmVmIFRyYW5zZm9ybSB0cmFuc2Zvcm0sIGludCBjaGlsZEluZGV4KTtcclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBDb21wdXRlIHRoZSBtYXNzIHByb3BlcnRpZXMgb2YgdGhpcyBzaGFwZSB1c2luZyBpdHMgZGltZW5zaW9ucyBhbmQgZGVuc2l0eS5cclxuICAgICAgICAvLy8gVGhlIGluZXJ0aWEgdGVuc29yIGlzIGNvbXB1dGVkIGFib3V0IHRoZSBsb2NhbCBvcmlnaW4sIG5vdCB0aGUgY2VudHJvaWQuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICBwdWJsaWMgYWJzdHJhY3Qgdm9pZCBDb21wdXRlUHJvcGVydGllcygpO1xyXG5cclxuICAgICAgICBwdWJsaWMgYm9vbCBDb21wYXJlVG8oU2hhcGUgc2hhcGUpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBpZiAoc2hhcGUgaXMgUG9seWdvblNoYXBlICYmIHRoaXMgaXMgUG9seWdvblNoYXBlKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuICgoUG9seWdvblNoYXBlKXRoaXMpLkNvbXBhcmVUbygoUG9seWdvblNoYXBlKXNoYXBlKTtcclxuXHJcbiAgICAgICAgICAgIGlmIChzaGFwZSBpcyBDaXJjbGVTaGFwZSAmJiB0aGlzIGlzIENpcmNsZVNoYXBlKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuICgoQ2lyY2xlU2hhcGUpdGhpcykuQ29tcGFyZVRvKChDaXJjbGVTaGFwZSlzaGFwZSk7XHJcblxyXG4gICAgICAgICAgICBpZiAoc2hhcGUgaXMgRWRnZVNoYXBlICYmIHRoaXMgaXMgRWRnZVNoYXBlKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuICgoRWRnZVNoYXBlKXRoaXMpLkNvbXBhcmVUbygoRWRnZVNoYXBlKXNoYXBlKTtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHB1YmxpYyBhYnN0cmFjdCBmbG9hdCBDb21wdXRlU3VibWVyZ2VkQXJlYShWZWN0b3IyIG5vcm1hbCwgZmxvYXQgb2Zmc2V0LCBUcmFuc2Zvcm0geGYsIG91dCBWZWN0b3IyIHNjKTtcclxuICAgIH1cclxufSIsInVzaW5nIFN5c3RlbS5Db2xsZWN0aW9ucy5HZW5lcmljO1xyXG51c2luZyBNaWNyb3NvZnQuWG5hLkZyYW1ld29yaztcclxuXHJcbm5hbWVzcGFjZSBGYXJzZWVyUGh5c2ljcy5Db21tb24uQ29udmV4SHVsbFxyXG57XHJcbiAgICBwdWJsaWMgc3RhdGljIGNsYXNzIENoYWluSHVsbFxyXG4gICAge1xyXG4gICAgICAgIC8vQW5kcmV3J3MgbW9ub3RvbmUgY2hhaW4gMkQgY29udmV4IGh1bGwgYWxnb3JpdGhtLlxyXG4gICAgICAgIC8vQ29weXJpZ2h0IDIwMDEsIHNvZnRTdXJmZXIgKHd3dy5zb2Z0c3VyZmVyLmNvbSlcclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBHZXRzIHRoZSBjb252ZXggaHVsbC5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8cmVtYXJrcz5cclxuICAgICAgICAvLy8gaHR0cDovL3d3dy5zb2Z0c3VyZmVyLmNvbS9BcmNoaXZlL2FsZ29yaXRobV8wMTA5L2FsZ29yaXRobV8wMTA5Lmh0bVxyXG4gICAgICAgIC8vLyA8L3JlbWFya3M+XHJcbiAgICAgICAgLy8vIDxyZXR1cm5zPjwvcmV0dXJucz5cclxuICAgICAgICBwdWJsaWMgc3RhdGljIFZlcnRpY2VzIEdldENvbnZleEh1bGwoVmVydGljZXMgUClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIFAuU29ydChuZXcgUG9pbnRDb21wYXJlcigpKTtcclxuXHJcbiAgICAgICAgICAgIFZlY3RvcjJbXSBIID0gbmV3IFZlY3RvcjJbUC5Db3VudF07XHJcbiAgICAgICAgICAgIFZlcnRpY2VzIHJlcyA9IG5ldyBWZXJ0aWNlcygpO1xyXG5cclxuICAgICAgICAgICAgaW50IG4gPSBQLkNvdW50O1xyXG5cclxuICAgICAgICAgICAgaW50IGJvdCwgdG9wID0gLTE7IC8vIGluZGljZXMgZm9yIGJvdHRvbSBhbmQgdG9wIG9mIHRoZSBzdGFja1xyXG4gICAgICAgICAgICBpbnQgaTsgLy8gYXJyYXkgc2NhbiBpbmRleFxyXG5cclxuICAgICAgICAgICAgLy8gR2V0IHRoZSBpbmRpY2VzIG9mIHBvaW50cyB3aXRoIG1pbiB4LWNvb3JkIGFuZCBtaW58bWF4IHktY29vcmRcclxuICAgICAgICAgICAgaW50IG1pbm1pbiA9IDAsIG1pbm1heDtcclxuICAgICAgICAgICAgZmxvYXQgeG1pbiA9IFBbMF0uWDtcclxuICAgICAgICAgICAgZm9yIChpID0gMTsgaSA8IG47IGkrKylcclxuICAgICAgICAgICAgICAgIGlmIChQW2ldLlggIT0geG1pbikgYnJlYWs7XHJcbiAgICAgICAgICAgIG1pbm1heCA9IGkgLSAxO1xyXG4gICAgICAgICAgICBpZiAobWlubWF4ID09IG4gLSAxKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAvLyBkZWdlbmVyYXRlIGNhc2U6IGFsbCB4LWNvb3JkcyA9PSB4bWluXHJcbiAgICAgICAgICAgICAgICBIWysrdG9wXSA9IFBbbWlubWluXTtcclxuICAgICAgICAgICAgICAgIGlmIChQW21pbm1heF0uWSAhPSBQW21pbm1pbl0uWSkgLy8gYSBub250cml2aWFsIHNlZ21lbnRcclxuICAgICAgICAgICAgICAgICAgICBIWysrdG9wXSA9IFBbbWlubWF4XTtcclxuICAgICAgICAgICAgICAgIEhbKyt0b3BdID0gUFttaW5taW5dOyAvLyBhZGQgcG9seWdvbiBlbmRwb2ludFxyXG5cclxuICAgICAgICAgICAgICAgIGZvciAoaW50IGogPSAwOyBqIDwgdG9wICsgMTsgaisrKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlcy5BZGQoSFtqXSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlcztcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdG9wID0gcmVzLkNvdW50IC0gMTtcclxuXHJcbiAgICAgICAgICAgIC8vIEdldCB0aGUgaW5kaWNlcyBvZiBwb2ludHMgd2l0aCBtYXggeC1jb29yZCBhbmQgbWlufG1heCB5LWNvb3JkXHJcbiAgICAgICAgICAgIGludCBtYXhtaW4sIG1heG1heCA9IG4gLSAxO1xyXG4gICAgICAgICAgICBmbG9hdCB4bWF4ID0gUFtuIC0gMV0uWDtcclxuICAgICAgICAgICAgZm9yIChpID0gbiAtIDI7IGkgPj0gMDsgaS0tKVxyXG4gICAgICAgICAgICAgICAgaWYgKFBbaV0uWCAhPSB4bWF4KSBicmVhaztcclxuICAgICAgICAgICAgbWF4bWluID0gaSArIDE7XHJcblxyXG4gICAgICAgICAgICAvLyBDb21wdXRlIHRoZSBsb3dlciBodWxsIG9uIHRoZSBzdGFjayBIXHJcbiAgICAgICAgICAgIEhbKyt0b3BdID0gUFttaW5taW5dOyAvLyBwdXNoIG1pbm1pbiBwb2ludCBvbnRvIHN0YWNrXHJcbiAgICAgICAgICAgIGkgPSBtaW5tYXg7XHJcbiAgICAgICAgICAgIHdoaWxlICgrK2kgPD0gbWF4bWluKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAvLyB0aGUgbG93ZXIgbGluZSBqb2lucyBQW21pbm1pbl0gd2l0aCBQW21heG1pbl1cclxuICAgICAgICAgICAgICAgIGlmIChNYXRoVXRpbHMuQXJlYShQW21pbm1pbl0sIFBbbWF4bWluXSwgUFtpXSkgPj0gMCAmJiBpIDwgbWF4bWluKVxyXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlOyAvLyBpZ25vcmUgUFtpXSBhYm92ZSBvciBvbiB0aGUgbG93ZXIgbGluZVxyXG5cclxuICAgICAgICAgICAgICAgIHdoaWxlICh0b3AgPiAwKSAvLyB0aGVyZSBhcmUgYXQgbGVhc3QgMiBwb2ludHMgb24gdGhlIHN0YWNrXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gdGVzdCBpZiBQW2ldIGlzIGxlZnQgb2YgdGhlIGxpbmUgYXQgdGhlIHN0YWNrIHRvcFxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChNYXRoVXRpbHMuQXJlYShIW3RvcCAtIDFdLCBIW3RvcF0sIFBbaV0pID4gMClcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7IC8vIFBbaV0gaXMgYSBuZXcgaHVsbCB2ZXJ0ZXhcclxuICAgICAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvcC0tOyAvLyBwb3AgdG9wIHBvaW50IG9mZiBzdGFja1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgSFsrK3RvcF0gPSBQW2ldOyAvLyBwdXNoIFBbaV0gb250byBzdGFja1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBOZXh0LCBjb21wdXRlIHRoZSB1cHBlciBodWxsIG9uIHRoZSBzdGFjayBIIGFib3ZlIHRoZSBib3R0b20gaHVsbFxyXG4gICAgICAgICAgICBpZiAobWF4bWF4ICE9IG1heG1pbikgLy8gaWYgZGlzdGluY3QgeG1heCBwb2ludHNcclxuICAgICAgICAgICAgICAgIEhbKyt0b3BdID0gUFttYXhtYXhdOyAvLyBwdXNoIG1heG1heCBwb2ludCBvbnRvIHN0YWNrXHJcbiAgICAgICAgICAgIGJvdCA9IHRvcDsgLy8gdGhlIGJvdHRvbSBwb2ludCBvZiB0aGUgdXBwZXIgaHVsbCBzdGFja1xyXG4gICAgICAgICAgICBpID0gbWF4bWluO1xyXG4gICAgICAgICAgICB3aGlsZSAoLS1pID49IG1pbm1heClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgLy8gdGhlIHVwcGVyIGxpbmUgam9pbnMgUFttYXhtYXhdIHdpdGggUFttaW5tYXhdXHJcbiAgICAgICAgICAgICAgICBpZiAoTWF0aFV0aWxzLkFyZWEoUFttYXhtYXhdLCBQW21pbm1heF0sIFBbaV0pID49IDAgJiYgaSA+IG1pbm1heClcclxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTsgLy8gaWdub3JlIFBbaV0gYmVsb3cgb3Igb24gdGhlIHVwcGVyIGxpbmVcclxuXHJcbiAgICAgICAgICAgICAgICB3aGlsZSAodG9wID4gYm90KSAvLyBhdCBsZWFzdCAyIHBvaW50cyBvbiB0aGUgdXBwZXIgc3RhY2tcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyB0ZXN0IGlmIFBbaV0gaXMgbGVmdCBvZiB0aGUgbGluZSBhdCB0aGUgc3RhY2sgdG9wXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKE1hdGhVdGlscy5BcmVhKEhbdG9wIC0gMV0sIEhbdG9wXSwgUFtpXSkgPiAwKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhazsgLy8gUFtpXSBpcyBhIG5ldyBodWxsIHZlcnRleFxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgICAgICAgICAgdG9wLS07IC8vIHBvcCB0b3AgcG9pbnQgb2ZmIHN0YWNrXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBIWysrdG9wXSA9IFBbaV07IC8vIHB1c2ggUFtpXSBvbnRvIHN0YWNrXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKG1pbm1heCAhPSBtaW5taW4pXHJcbiAgICAgICAgICAgICAgICBIWysrdG9wXSA9IFBbbWlubWluXTsgLy8gcHVzaCBqb2luaW5nIGVuZHBvaW50IG9udG8gc3RhY2tcclxuXHJcbiAgICAgICAgICAgIGZvciAoaW50IGogPSAwOyBqIDwgdG9wICsgMTsgaisrKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICByZXMuQWRkKEhbal0pO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gcmVzO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgI3JlZ2lvbiBOZXN0ZWQgdHlwZTogUG9pbnRDb21wYXJlclxyXG5cclxuICAgICAgICBwdWJsaWMgY2xhc3MgUG9pbnRDb21wYXJlciA6IENvbXBhcmVyPFZlY3RvcjI+XHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBwdWJsaWMgb3ZlcnJpZGUgaW50IENvbXBhcmUoVmVjdG9yMiBhLCBWZWN0b3IyIGIpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGludCBmID0gYS5YLkNvbXBhcmVUbyhiLlgpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGYgIT0gMCA/IGYgOiBhLlkuQ29tcGFyZVRvKGIuWSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgICNlbmRyZWdpb25cclxuICAgIH1cclxufSIsInVzaW5nIFN5c3RlbTtcclxuXHJcbm5hbWVzcGFjZSBGYXJzZWVyUGh5c2ljcy5Db21tb24uQ29udmV4SHVsbFxyXG57XHJcbiAgICBwdWJsaWMgc3RhdGljIGNsYXNzIEdpZnRXcmFwXHJcbiAgICB7XHJcbiAgICAgICAgLy8gRnJvbSBFcmljIEpvcmRhbidzIGNvbnZleCBkZWNvbXBvc2l0aW9uIGxpYnJhcnkgKGJveDJEIHJldiAzMilcclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBGaW5kIHRoZSBjb252ZXggaHVsbCBvZiBhIHBvaW50IGNsb3VkIHVzaW5nIFwiR2lmdC13cmFwXCIgYWxnb3JpdGhtIC0gc3RhcnRcclxuICAgICAgICAvLy8gd2l0aCBhbiBleHRyZW1hbCBwb2ludCwgYW5kIHdhbGsgYXJvdW5kIHRoZSBvdXRzaWRlIGVkZ2UgYnkgdGVzdGluZ1xyXG4gICAgICAgIC8vLyBhbmdsZXMuXHJcbiAgICAgICAgLy8vIFxyXG4gICAgICAgIC8vLyBSdW5zIGluIE8oTipTKSB0aW1lIHdoZXJlIFMgaXMgbnVtYmVyIG9mIHNpZGVzIG9mIHJlc3VsdGluZyBwb2x5Z29uLlxyXG4gICAgICAgIC8vLyBXb3JzdCBjYXNlOiBwb2ludCBjbG91ZCBpcyBhbGwgdmVydGljZXMgb2YgY29udmV4IHBvbHlnb246IE8oTl4yKS5cclxuICAgICAgICAvLy8gVGhlcmUgbWF5IGJlIGZhc3RlciBhbGdvcml0aG1zIHRvIGRvIHRoaXMsIHNob3VsZCB5b3UgbmVlZCBvbmUgLVxyXG4gICAgICAgIC8vLyB0aGlzIGlzIGp1c3QgdGhlIHNpbXBsZXN0LiBZb3UgY2FuIGdldCBPKE4gbG9nIE4pIGV4cGVjdGVkIHRpbWUgaWYgeW91XHJcbiAgICAgICAgLy8vIHRyeSwgSSB0aGluaywgYW5kIE8oTikgaWYgeW91IHJlc3RyaWN0IGlucHV0cyB0byBzaW1wbGUgcG9seWdvbnMuXHJcbiAgICAgICAgLy8vIFJldHVybnMgbnVsbCBpZiBudW1iZXIgb2YgdmVydGljZXMgcGFzc2VkIGlzIGxlc3MgdGhhbiAzLlxyXG4gICAgICAgIC8vLyBSZXN1bHRzIHNob3VsZCBiZSBwYXNzZWQgdGhyb3VnaCBjb252ZXggZGVjb21wb3NpdGlvbiBhZnRlcndhcmRzXHJcbiAgICAgICAgLy8vIHRvIGVuc3VyZSB0aGF0IGVhY2ggc2hhcGUgaGFzIGZldyBlbm91Z2ggcG9pbnRzIHRvIGJlIHVzZWQgaW4gQm94MmQuXHJcbiAgICAgICAgLy8vIFxyXG4gICAgICAgIC8vLyBXYXJuaW5nOiBNYXkgYmUgYnVnZ3kgd2l0aCBjb2xpbmVhciBwb2ludHMgb24gaHVsbC5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cInZlcnRpY2VzXCI+VGhlIHZlcnRpY2VzLjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxyZXR1cm5zPjwvcmV0dXJucz5cclxuICAgICAgICBwdWJsaWMgc3RhdGljIFZlcnRpY2VzIEdldENvbnZleEh1bGwoVmVydGljZXMgdmVydGljZXMpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBpZiAodmVydGljZXMuQ291bnQgPCAzKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHZlcnRpY2VzO1xyXG5cclxuICAgICAgICAgICAgaW50W10gZWRnZUxpc3QgPSBuZXcgaW50W3ZlcnRpY2VzLkNvdW50XTtcclxuICAgICAgICAgICAgaW50IG51bUVkZ2VzID0gMDtcclxuXHJcbiAgICAgICAgICAgIGZsb2F0IG1pblkgPSBmbG9hdC5NYXhWYWx1ZTtcclxuICAgICAgICAgICAgaW50IG1pbllJbmRleCA9IHZlcnRpY2VzLkNvdW50O1xyXG4gICAgICAgICAgICBmb3IgKGludCBpID0gMDsgaSA8IHZlcnRpY2VzLkNvdW50OyArK2kpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGlmICh2ZXJ0aWNlc1tpXS5ZIDwgbWluWSlcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBtaW5ZID0gdmVydGljZXNbaV0uWTtcclxuICAgICAgICAgICAgICAgICAgICBtaW5ZSW5kZXggPSBpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpbnQgc3RhcnRJbmRleCA9IG1pbllJbmRleDtcclxuICAgICAgICAgICAgaW50IHdpbkluZGV4ID0gLTE7XHJcbiAgICAgICAgICAgIGZsb2F0IGR4ID0gLTEuMGY7XHJcbiAgICAgICAgICAgIGZsb2F0IGR5ID0gMC4wZjtcclxuICAgICAgICAgICAgd2hpbGUgKHdpbkluZGV4ICE9IG1pbllJbmRleClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgZmxvYXQgbWF4RG90ID0gLTIuMGY7XHJcbiAgICAgICAgICAgICAgICBmbG9hdCBucm07XHJcblxyXG4gICAgICAgICAgICAgICAgZm9yIChpbnQgaSA9IDA7IGkgPCB2ZXJ0aWNlcy5Db3VudDsgKytpKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChpID09IHN0YXJ0SW5kZXgpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIGZsb2F0IG5ld2R4ID0gdmVydGljZXNbaV0uWCAtIHZlcnRpY2VzW3N0YXJ0SW5kZXhdLlg7XHJcbiAgICAgICAgICAgICAgICAgICAgZmxvYXQgbmV3ZHkgPSB2ZXJ0aWNlc1tpXS5ZIC0gdmVydGljZXNbc3RhcnRJbmRleF0uWTtcclxuICAgICAgICAgICAgICAgICAgICBucm0gPSAoZmxvYXQpTWF0aC5TcXJ0KG5ld2R4ICogbmV3ZHggKyBuZXdkeSAqIG5ld2R5KTtcclxuICAgICAgICAgICAgICAgICAgICBucm0gPSAobnJtID09IDAuMGYpID8gMS4wZiA6IG5ybTtcclxuICAgICAgICAgICAgICAgICAgICBuZXdkeCAvPSBucm07XHJcbiAgICAgICAgICAgICAgICAgICAgbmV3ZHkgLz0gbnJtO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvL0RvdCBwcm9kdWN0cyBhY3QgYXMgcHJveHkgZm9yIGFuZ2xlXHJcbiAgICAgICAgICAgICAgICAgICAgLy93aXRob3V0IHJlcXVpcmluZyBpbnZlcnNlIHRyaWcuXHJcbiAgICAgICAgICAgICAgICAgICAgZmxvYXQgbmV3RG90ID0gbmV3ZHggKiBkeCArIG5ld2R5ICogZHk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5ld0RvdCA+IG1heERvdClcclxuICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1heERvdCA9IG5ld0RvdDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgd2luSW5kZXggPSBpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVkZ2VMaXN0W251bUVkZ2VzKytdID0gd2luSW5kZXg7XHJcbiAgICAgICAgICAgICAgICBkeCA9IHZlcnRpY2VzW3dpbkluZGV4XS5YIC0gdmVydGljZXNbc3RhcnRJbmRleF0uWDtcclxuICAgICAgICAgICAgICAgIGR5ID0gdmVydGljZXNbd2luSW5kZXhdLlkgLSB2ZXJ0aWNlc1tzdGFydEluZGV4XS5ZO1xyXG4gICAgICAgICAgICAgICAgbnJtID0gKGZsb2F0KU1hdGguU3FydChkeCAqIGR4ICsgZHkgKiBkeSk7XHJcbiAgICAgICAgICAgICAgICBucm0gPSAobnJtID09IDAuMGYpID8gMS4wZiA6IG5ybTtcclxuICAgICAgICAgICAgICAgIGR4IC89IG5ybTtcclxuICAgICAgICAgICAgICAgIGR5IC89IG5ybTtcclxuICAgICAgICAgICAgICAgIHN0YXJ0SW5kZXggPSB3aW5JbmRleDtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgVmVydGljZXMgcmV0dXJuVmFsID0gbmV3IFZlcnRpY2VzKG51bUVkZ2VzKTtcclxuXHJcbiAgICAgICAgICAgIGZvciAoaW50IGkgPSAwOyBpIDwgbnVtRWRnZXM7IGkrKylcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuVmFsLkFkZCh2ZXJ0aWNlc1tlZGdlTGlzdFtpXV0pO1xyXG4gICAgICAgICAgICAgICAgLy9EZWJ1Zy5Xcml0ZUxpbmUoc3RyaW5nLkZvcm1hdChcInswfSwgezF9XCIsIHZlcnRpY2VzW2VkZ2VMaXN0W2ldXS5YLCB2ZXJ0aWNlc1tlZGdlTGlzdFtpXV0uWSkpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvL05vdCBzdXJlIGlmIHdlIG5lZWQgdGhpc1xyXG4gICAgICAgICAgICAvL3JldHVyblZhbC5NZXJnZVBhcmFsbGVsRWRnZXMoU2V0dGluZ3MuYjJfYW5ndWxhclNsb3ApO1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIHJldHVyblZhbDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn0iLCJ1c2luZyBNaWNyb3NvZnQuWG5hLkZyYW1ld29yaztcclxuXHJcbm5hbWVzcGFjZSBGYXJzZWVyUGh5c2ljcy5Db21tb24uQ29udmV4SHVsbFxyXG57XHJcbiAgICBwdWJsaWMgc3RhdGljIGNsYXNzIE1lbGttYW5cclxuICAgIHtcclxuICAgICAgICAvL01lbGttYW4gYmFzZWQgY29udmV4IGh1bGwgYWxnb3JpdGhtIGNvbnRyaWJ1dGVkIGJ5IENvd2RvemVyXHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gQ3JlYXRlcyBhIGNvbnZleCBodWxsLlxyXG4gICAgICAgIC8vLyBOb3RlOlxyXG4gICAgICAgIC8vLyAxLiBWZXJ0aWNlcyBtdXN0IGJlIG9mIGEgc2ltcGxlIHBvbHlnb24sIGkuZS4gZWRnZXMgZG8gbm90IG92ZXJsYXAuXHJcbiAgICAgICAgLy8vIDIuIE1lbGttYW4gZG9lcyBub3Qgd29yayBvbiBwb2ludCBjbG91ZHNcclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8cmVtYXJrcz5cclxuICAgICAgICAvLy8gSW1wbGVtZW50ZWQgdXNpbmcgTWVsa21hbidzIENvbnZleCBIdWxsIEFsZ29yaXRobSAtIE8obikgdGltZSBjb21wbGV4aXR5LlxyXG4gICAgICAgIC8vLyBSZWZlcmVuY2U6IGh0dHA6Ly93d3cuYW1zLnN1bnlzYi5lZHUvfmpzYm0vY291cnNlcy8zNDUvbWVsa21hbi5wZGZcclxuICAgICAgICAvLy8gPC9yZW1hcmtzPlxyXG4gICAgICAgIC8vLyA8cmV0dXJucz5BIGNvbnZleCBodWxsIGluIGNvdW50ZXJjbG9ja3dpc2Ugd2luZGluZyBvcmRlci48L3JldHVybnM+XHJcbiAgICAgICAgcHVibGljIHN0YXRpYyBWZXJ0aWNlcyBHZXRDb252ZXhIdWxsKFZlcnRpY2VzIHZlcnRpY2VzKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgLy9XaXRoIGxlc3MgdGhhbiAzIHZlcnRpY2VzLCB0aGlzIGlzIGFib3V0IHRoZSBiZXN0IHdlIGNhbiBkbyBmb3IgYSBjb252ZXggaHVsbFxyXG4gICAgICAgICAgICBpZiAodmVydGljZXMuQ291bnQgPCAzKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHZlcnRpY2VzO1xyXG5cclxuICAgICAgICAgICAgLy9XZSdsbCBuZXZlciBuZWVkIGEgcXVldWUgbGFyZ2VyIHRoYW4gdGhlIGN1cnJlbnQgbnVtYmVyIG9mIFZlcnRpY2VzICsxXHJcbiAgICAgICAgICAgIC8vQ3JlYXRlIGRvdWJsZS1lbmRlZCBxdWV1ZVxyXG4gICAgICAgICAgICBWZWN0b3IyW10gZGVxdWUgPSBuZXcgVmVjdG9yMlt2ZXJ0aWNlcy5Db3VudCArIDFdO1xyXG4gICAgICAgICAgICBpbnQgcWYgPSAzLCBxYiA9IDA7IC8vUXVldWUgZnJvbnQgaW5kZXgsIHF1ZXVlIGJhY2sgaW5kZXhcclxuICAgICAgICAgICAgaW50IHFmbTEsIHFibTE7IC8vcWZtMSA9IHNlY29uZCBlbGVtZW50LCBxYm0xID0gc2Vjb25kIGxhc3QgZWxlbWVudFxyXG5cclxuICAgICAgICAgICAgLy9TdGFydCBieSBwbGFjaW5nIGZpcnN0IDMgdmVydGljZXMgaW4gY29udmV4IENDVyBvcmRlclxyXG4gICAgICAgICAgICBpbnQgc3RhcnRJbmRleCA9IDM7XHJcbiAgICAgICAgICAgIGZsb2F0IGsgPSBNYXRoVXRpbHMuQXJlYSh2ZXJ0aWNlc1swXSwgdmVydGljZXNbMV0sIHZlcnRpY2VzWzJdKTtcclxuICAgICAgICAgICAgaWYgKGsgPT0gMClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgLy9WZXJ0aWNlcyBhcmUgY29sbGluZWFyLlxyXG4gICAgICAgICAgICAgICAgZGVxdWVbMF0gPSB2ZXJ0aWNlc1swXTtcclxuICAgICAgICAgICAgICAgIGRlcXVlWzFdID0gdmVydGljZXNbMl07IC8vV2UgY2FuIHNraXAgdmVydGV4IDEgYmVjYXVzZSBpdCBzaG91bGQgYmUgYmV0d2VlbiAwIGFuZCAyXHJcbiAgICAgICAgICAgICAgICBkZXF1ZVsyXSA9IHZlcnRpY2VzWzBdO1xyXG4gICAgICAgICAgICAgICAgcWYgPSAyO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vR28gdW50aWwgdGhlIGVuZCBvZiB0aGUgY29sbGluZWFyIHNlcXVlbmNlIG9mIHZlcnRpY2VzXHJcbiAgICAgICAgICAgICAgICBmb3IgKHN0YXJ0SW5kZXggPSAzOyBzdGFydEluZGV4IDwgdmVydGljZXMuQ291bnQ7IHN0YXJ0SW5kZXgrKylcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBWZWN0b3IyIHRtcCA9IHZlcnRpY2VzW3N0YXJ0SW5kZXhdO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChNYXRoVXRpbHMuQXJlYShyZWYgZGVxdWVbMF0sIHJlZiBkZXF1ZVsxXSwgcmVmIHRtcCkgPT0gMCkgLy9UaGlzIHBvaW50IGlzIGFsc28gY29sbGluZWFyXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlcXVlWzFdID0gdmVydGljZXNbc3RhcnRJbmRleF07XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBicmVhaztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGRlcXVlWzBdID0gZGVxdWVbM10gPSB2ZXJ0aWNlc1syXTtcclxuICAgICAgICAgICAgICAgIGlmIChrID4gMClcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAvL0lzIExlZnQuICBTZXQgZGVxdWUgPSB7MiwgMCwgMSwgMn1cclxuICAgICAgICAgICAgICAgICAgICBkZXF1ZVsxXSA9IHZlcnRpY2VzWzBdO1xyXG4gICAgICAgICAgICAgICAgICAgIGRlcXVlWzJdID0gdmVydGljZXNbMV07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy9JcyBSaWdodC4gU2V0IGRlcXVlID0gezIsIDEsIDAsIDJ9XHJcbiAgICAgICAgICAgICAgICAgICAgZGVxdWVbMV0gPSB2ZXJ0aWNlc1sxXTtcclxuICAgICAgICAgICAgICAgICAgICBkZXF1ZVsyXSA9IHZlcnRpY2VzWzBdO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBxZm0xID0gcWYgPT0gMCA/IGRlcXVlLkxlbmd0aCAtIDEgOiBxZiAtIDE7IC8vcWZtMSA9IHFmIC0gMTtcclxuICAgICAgICAgICAgcWJtMSA9IHFiID09IGRlcXVlLkxlbmd0aCAtIDEgPyAwIDogcWIgKyAxOyAvL3FibTEgPSBxYiArIDE7XHJcblxyXG4gICAgICAgICAgICAvL0FkZCB2ZXJ0aWNlcyBvbmUgYXQgYSB0aW1lIGFuZCBhZGp1c3QgY29udmV4IGh1bGwgYXMgbmVlZGVkXHJcbiAgICAgICAgICAgIGZvciAoaW50IGkgPSBzdGFydEluZGV4OyBpIDwgdmVydGljZXMuQ291bnQ7IGkrKylcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgVmVjdG9yMiBuZXh0UHQgPSB2ZXJ0aWNlc1tpXTtcclxuXHJcbiAgICAgICAgICAgICAgICAvL0lnbm9yZSBpZiBpdCBpcyBhbHJlYWR5IHdpdGhpbiB0aGUgY29udmV4IGh1bGwgd2UgaGF2ZSBjb25zdHJ1Y3RlZFxyXG4gICAgICAgICAgICAgICAgaWYgKE1hdGhVdGlscy5BcmVhKHJlZiBkZXF1ZVtxZm0xXSwgcmVmIGRlcXVlW3FmXSwgcmVmIG5leHRQdCkgPiAwICYmXHJcbiAgICAgICAgICAgICAgICAgICAgTWF0aFV0aWxzLkFyZWEocmVmIGRlcXVlW3FiXSwgcmVmIGRlcXVlW3FibTFdLCByZWYgbmV4dFB0KSA+IDApXHJcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcblxyXG4gICAgICAgICAgICAgICAgLy9Qb3AgZnJvbnQgdW50aWwgY29udmV4XHJcbiAgICAgICAgICAgICAgICB3aGlsZSAoIShNYXRoVXRpbHMuQXJlYShyZWYgZGVxdWVbcWZtMV0sIHJlZiBkZXF1ZVtxZl0sIHJlZiBuZXh0UHQpID4gMCkpXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy9Qb3AgdGhlIGZyb250IGVsZW1lbnQgZnJvbSB0aGUgcXVldWVcclxuICAgICAgICAgICAgICAgICAgICBxZiA9IHFmbTE7IC8vcWYtLTtcclxuICAgICAgICAgICAgICAgICAgICBxZm0xID0gcWYgPT0gMCA/IGRlcXVlLkxlbmd0aCAtIDEgOiBxZiAtIDE7IC8vcWZtMSA9IHFmIC0gMTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIC8vQWRkIHZlcnRleCB0byB0aGUgZnJvbnQgb2YgdGhlIHF1ZXVlXHJcbiAgICAgICAgICAgICAgICBxZiA9IHFmID09IGRlcXVlLkxlbmd0aCAtIDEgPyAwIDogcWYgKyAxOyAvL3FmKys7XHJcbiAgICAgICAgICAgICAgICBxZm0xID0gcWYgPT0gMCA/IGRlcXVlLkxlbmd0aCAtIDEgOiBxZiAtIDE7IC8vcWZtMSA9IHFmIC0gMTtcclxuICAgICAgICAgICAgICAgIGRlcXVlW3FmXSA9IG5leHRQdDtcclxuXHJcbiAgICAgICAgICAgICAgICAvL1BvcCBiYWNrIHVudGlsIGNvbnZleFxyXG4gICAgICAgICAgICAgICAgd2hpbGUgKCEoTWF0aFV0aWxzLkFyZWEocmVmIGRlcXVlW3FiXSwgcmVmIGRlcXVlW3FibTFdLCByZWYgbmV4dFB0KSA+IDApKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vUG9wIHRoZSBiYWNrIGVsZW1lbnQgZnJvbSB0aGUgcXVldWVcclxuICAgICAgICAgICAgICAgICAgICBxYiA9IHFibTE7IC8vcWIrKztcclxuICAgICAgICAgICAgICAgICAgICBxYm0xID0gcWIgPT0gZGVxdWUuTGVuZ3RoIC0gMSA/IDAgOiBxYiArIDE7IC8vcWJtMSA9IHFiICsgMTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIC8vQWRkIHZlcnRleCB0byB0aGUgYmFjayBvZiB0aGUgcXVldWVcclxuICAgICAgICAgICAgICAgIHFiID0gcWIgPT0gMCA/IGRlcXVlLkxlbmd0aCAtIDEgOiBxYiAtIDE7IC8vcWItLTtcclxuICAgICAgICAgICAgICAgIHFibTEgPSBxYiA9PSBkZXF1ZS5MZW5ndGggLSAxID8gMCA6IHFiICsgMTsgLy9xYm0xID0gcWIgKyAxO1xyXG4gICAgICAgICAgICAgICAgZGVxdWVbcWJdID0gbmV4dFB0O1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvL0NyZWF0ZSB0aGUgY29udmV4IGh1bGwgZnJvbSB3aGF0IGlzIGxlZnQgaW4gdGhlIGRlcXVlXHJcbiAgICAgICAgICAgIFZlcnRpY2VzIGNvbnZleEh1bGwgPSBuZXcgVmVydGljZXModmVydGljZXMuQ291bnQgKyAxKTtcclxuICAgICAgICAgICAgaWYgKHFiIDwgcWYpXHJcbiAgICAgICAgICAgICAgICBmb3IgKGludCBpID0gcWI7IGkgPCBxZjsgaSsrKVxyXG4gICAgICAgICAgICAgICAgICAgIGNvbnZleEh1bGwuQWRkKGRlcXVlW2ldKTtcclxuICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBmb3IgKGludCBpID0gMDsgaSA8IHFmOyBpKyspXHJcbiAgICAgICAgICAgICAgICAgICAgY29udmV4SHVsbC5BZGQoZGVxdWVbaV0pO1xyXG4gICAgICAgICAgICAgICAgZm9yIChpbnQgaSA9IHFiOyBpIDwgZGVxdWUuTGVuZ3RoOyBpKyspXHJcbiAgICAgICAgICAgICAgICAgICAgY29udmV4SHVsbC5BZGQoZGVxdWVbaV0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBjb252ZXhIdWxsO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufSIsInVzaW5nIFN5c3RlbS5Db2xsZWN0aW9ucy5HZW5lcmljO1xyXG51c2luZyBGYXJzZWVyUGh5c2ljcy5Db21tb24uUG9seWdvbk1hbmlwdWxhdGlvbjtcclxudXNpbmcgTWljcm9zb2Z0LlhuYS5GcmFtZXdvcms7XHJcblxyXG5uYW1lc3BhY2UgRmFyc2VlclBoeXNpY3MuQ29tbW9uLkRlY29tcG9zaXRpb25cclxue1xyXG4gICAgLy9Gcm9tIHBoZWQgcmV2IDM2XHJcblxyXG4gICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgLy8vIENvbnZleCBkZWNvbXBvc2l0aW9uIGFsZ29yaXRobSBjcmVhdGVkIGJ5IE1hcmsgQmF5YXppdCAoaHR0cDovL21uYmF5YXppdC5jb20vKVxyXG4gICAgLy8vIEZvciBtb3JlIGluZm9ybWF0aW9uIGFib3V0IHRoaXMgYWxnb3JpdGhtLCBzZWUgaHR0cDovL21uYmF5YXppdC5jb20vNDA2L2JheWF6aXRcclxuICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICBwdWJsaWMgc3RhdGljIGNsYXNzIEJheWF6aXREZWNvbXBvc2VyXHJcbiAgICB7XHJcbiAgICAgICAgcHJpdmF0ZSBzdGF0aWMgVmVjdG9yMiBBdChpbnQgaSwgVmVydGljZXMgdmVydGljZXMpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBpbnQgcyA9IHZlcnRpY2VzLkNvdW50O1xyXG4gICAgICAgICAgICByZXR1cm4gdmVydGljZXNbaSA8IDAgPyBzIC0gKC1pICUgcykgOiBpICUgc107XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwcml2YXRlIHN0YXRpYyBWZXJ0aWNlcyBDb3B5KGludCBpLCBpbnQgaiwgVmVydGljZXMgdmVydGljZXMpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBWZXJ0aWNlcyBwID0gbmV3IFZlcnRpY2VzKCk7XHJcbiAgICAgICAgICAgIHdoaWxlIChqIDwgaSkgaiArPSB2ZXJ0aWNlcy5Db3VudDtcclxuICAgICAgICAgICAgLy9wLnJlc2VydmUoaiAtIGkgKyAxKTtcclxuICAgICAgICAgICAgZm9yICg7IGkgPD0gajsgKytpKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBwLkFkZChBdChpLCB2ZXJ0aWNlcykpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBwO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBEZWNvbXBvc2UgdGhlIHBvbHlnb24gaW50byBzZXZlcmFsIHNtYWxsZXIgbm9uLWNvbmNhdmUgcG9seWdvbi5cclxuICAgICAgICAvLy8gSWYgdGhlIHBvbHlnb24gaXMgYWxyZWFkeSBjb252ZXgsIGl0IHdpbGwgcmV0dXJuIHRoZSBvcmlnaW5hbCBwb2x5Z29uLCB1bmxlc3MgaXQgaXMgb3ZlciBTZXR0aW5ncy5NYXhQb2x5Z29uVmVydGljZXMuXHJcbiAgICAgICAgLy8vIFByZWNvbmRpdGlvbjogQ291bnRlciBDbG9ja3dpc2UgcG9seWdvblxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwidmVydGljZXNcIj48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cmV0dXJucz48L3JldHVybnM+XHJcbiAgICAgICAgcHVibGljIHN0YXRpYyBMaXN0PFZlcnRpY2VzPiBDb252ZXhQYXJ0aXRpb24oVmVydGljZXMgdmVydGljZXMpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICAvL1dlIGZvcmNlIGl0IHRvIENDVyBhcyBpdCBpcyBhIHByZWNvbmRpdGlvbiBpbiB0aGlzIGFsZ29yaXRobS5cclxuICAgICAgICAgICAgdmVydGljZXMuRm9yY2VDb3VudGVyQ2xvY2tXaXNlKCk7XHJcblxyXG4gICAgICAgICAgICBMaXN0PFZlcnRpY2VzPiBsaXN0ID0gbmV3IExpc3Q8VmVydGljZXM+KCk7XHJcbiAgICAgICAgICAgIGZsb2F0IGQsIGxvd2VyRGlzdCwgdXBwZXJEaXN0O1xyXG4gICAgICAgICAgICBWZWN0b3IyIHA7XHJcbiAgICAgICAgICAgIFZlY3RvcjIgbG93ZXJJbnQgPSBuZXcgVmVjdG9yMigpO1xyXG4gICAgICAgICAgICBWZWN0b3IyIHVwcGVySW50ID0gbmV3IFZlY3RvcjIoKTsgLy8gaW50ZXJzZWN0aW9uIHBvaW50c1xyXG4gICAgICAgICAgICBpbnQgbG93ZXJJbmRleCA9IDAsIHVwcGVySW5kZXggPSAwO1xyXG4gICAgICAgICAgICBWZXJ0aWNlcyBsb3dlclBvbHksIHVwcGVyUG9seTtcclxuXHJcbiAgICAgICAgICAgIGZvciAoaW50IGkgPSAwOyBpIDwgdmVydGljZXMuQ291bnQ7ICsraSlcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgaWYgKFJlZmxleChpLCB2ZXJ0aWNlcykpXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgbG93ZXJEaXN0ID0gdXBwZXJEaXN0ID0gZmxvYXQuTWF4VmFsdWU7IC8vIHN0ZDo6bnVtZXJpY19saW1pdHM8cXJlYWw+OjptYXgoKTtcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKGludCBqID0gMDsgaiA8IHZlcnRpY2VzLkNvdW50OyArK2opXHJcbiAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBpZiBsaW5lIGludGVyc2VjdHMgd2l0aCBhbiBlZGdlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChMZWZ0KEF0KGkgLSAxLCB2ZXJ0aWNlcyksIEF0KGksIHZlcnRpY2VzKSwgQXQoaiwgdmVydGljZXMpKSAmJlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgUmlnaHRPbihBdChpIC0gMSwgdmVydGljZXMpLCBBdChpLCB2ZXJ0aWNlcyksIEF0KGogLSAxLCB2ZXJ0aWNlcykpKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBmaW5kIHRoZSBwb2ludCBvZiBpbnRlcnNlY3Rpb25cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHAgPSBMaW5lVG9vbHMuTGluZUludGVyc2VjdChBdChpIC0gMSwgdmVydGljZXMpLCBBdChpLCB2ZXJ0aWNlcyksIEF0KGosIHZlcnRpY2VzKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBBdChqIC0gMSwgdmVydGljZXMpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChSaWdodChBdChpICsgMSwgdmVydGljZXMpLCBBdChpLCB2ZXJ0aWNlcyksIHApKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIG1ha2Ugc3VyZSBpdCdzIGluc2lkZSB0aGUgcG9seVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGQgPSBTcXVhcmVEaXN0KEF0KGksIHZlcnRpY2VzKSwgcCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGQgPCBsb3dlckRpc3QpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBrZWVwIG9ubHkgdGhlIGNsb3Nlc3QgaW50ZXJzZWN0aW9uXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvd2VyRGlzdCA9IGQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvd2VySW50ID0gcDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbG93ZXJJbmRleCA9IGo7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoTGVmdChBdChpICsgMSwgdmVydGljZXMpLCBBdChpLCB2ZXJ0aWNlcyksIEF0KGogKyAxLCB2ZXJ0aWNlcykpICYmXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBSaWdodE9uKEF0KGkgKyAxLCB2ZXJ0aWNlcyksIEF0KGksIHZlcnRpY2VzKSwgQXQoaiwgdmVydGljZXMpKSlcclxuICAgICAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcCA9IExpbmVUb29scy5MaW5lSW50ZXJzZWN0KEF0KGkgKyAxLCB2ZXJ0aWNlcyksIEF0KGksIHZlcnRpY2VzKSwgQXQoaiwgdmVydGljZXMpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEF0KGogKyAxLCB2ZXJ0aWNlcykpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKExlZnQoQXQoaSAtIDEsIHZlcnRpY2VzKSwgQXQoaSwgdmVydGljZXMpLCBwKSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkID0gU3F1YXJlRGlzdChBdChpLCB2ZXJ0aWNlcyksIHApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkIDwgdXBwZXJEaXN0KVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdXBwZXJEaXN0ID0gZDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdXBwZXJJbmRleCA9IGo7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVwcGVySW50ID0gcDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIGlmIHRoZXJlIGFyZSBubyB2ZXJ0aWNlcyB0byBjb25uZWN0IHRvLCBjaG9vc2UgYSBwb2ludCBpbiB0aGUgbWlkZGxlXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGxvd2VySW5kZXggPT0gKHVwcGVySW5kZXggKyAxKSAlIHZlcnRpY2VzLkNvdW50KVxyXG4gICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgVmVjdG9yMiBzcCA9ICgobG93ZXJJbnQgKyB1cHBlckludCkgLyAyKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvd2VyUG9seSA9IENvcHkoaSwgdXBwZXJJbmRleCwgdmVydGljZXMpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBsb3dlclBvbHkuQWRkKHNwKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdXBwZXJQb2x5ID0gQ29weShsb3dlckluZGV4LCBpLCB2ZXJ0aWNlcyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHVwcGVyUG9seS5BZGQoc3ApO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBkb3VibGUgaGlnaGVzdFNjb3JlID0gMCwgYmVzdEluZGV4ID0gbG93ZXJJbmRleDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKHVwcGVySW5kZXggPCBsb3dlckluZGV4KSB1cHBlckluZGV4ICs9IHZlcnRpY2VzLkNvdW50O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGludCBqID0gbG93ZXJJbmRleDsgaiA8PSB1cHBlckluZGV4OyArK2opXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChDYW5TZWUoaSwgaiwgdmVydGljZXMpKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvdWJsZSBzY29yZSA9IDEgLyAoU3F1YXJlRGlzdChBdChpLCB2ZXJ0aWNlcyksIEF0KGosIHZlcnRpY2VzKSkgKyAxKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoUmVmbGV4KGosIHZlcnRpY2VzKSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChSaWdodE9uKEF0KGogLSAxLCB2ZXJ0aWNlcyksIEF0KGosIHZlcnRpY2VzKSwgQXQoaSwgdmVydGljZXMpKSAmJlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgTGVmdE9uKEF0KGogKyAxLCB2ZXJ0aWNlcyksIEF0KGosIHZlcnRpY2VzKSwgQXQoaSwgdmVydGljZXMpKSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2NvcmUgKz0gMztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNjb3JlICs9IDI7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2NvcmUgKz0gMTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNjb3JlID4gaGlnaGVzdFNjb3JlKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYmVzdEluZGV4ID0gajtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaGlnaGVzdFNjb3JlID0gc2NvcmU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvd2VyUG9seSA9IENvcHkoaSwgKGludCliZXN0SW5kZXgsIHZlcnRpY2VzKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdXBwZXJQb2x5ID0gQ29weSgoaW50KWJlc3RJbmRleCwgaSwgdmVydGljZXMpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBsaXN0LkFkZFJhbmdlKENvbnZleFBhcnRpdGlvbihsb3dlclBvbHkpKTtcclxuICAgICAgICAgICAgICAgICAgICBsaXN0LkFkZFJhbmdlKENvbnZleFBhcnRpdGlvbih1cHBlclBvbHkpKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbGlzdDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gcG9seWdvbiBpcyBhbHJlYWR5IGNvbnZleFxyXG4gICAgICAgICAgICBpZiAodmVydGljZXMuQ291bnQgPiBTZXR0aW5ncy5NYXhQb2x5Z29uVmVydGljZXMpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGxvd2VyUG9seSA9IENvcHkoMCwgdmVydGljZXMuQ291bnQgLyAyLCB2ZXJ0aWNlcyk7XHJcbiAgICAgICAgICAgICAgICB1cHBlclBvbHkgPSBDb3B5KHZlcnRpY2VzLkNvdW50IC8gMiwgMCwgdmVydGljZXMpO1xyXG4gICAgICAgICAgICAgICAgbGlzdC5BZGRSYW5nZShDb252ZXhQYXJ0aXRpb24obG93ZXJQb2x5KSk7XHJcbiAgICAgICAgICAgICAgICBsaXN0LkFkZFJhbmdlKENvbnZleFBhcnRpdGlvbih1cHBlclBvbHkpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICBsaXN0LkFkZCh2ZXJ0aWNlcyk7XHJcblxyXG4gICAgICAgICAgICAvL1RoZSBwb2x5Z29ucyBhcmUgbm90IGd1YXJhbnRlZWQgdG8gYmUgd2l0aG91dCBjb2xsaW5lYXIgcG9pbnRzLiBXZSByZW1vdmVcclxuICAgICAgICAgICAgLy90aGVtIHRvIGJlIHN1cmUuXHJcbiAgICAgICAgICAgIGZvciAoaW50IGkgPSAwOyBpIDwgbGlzdC5Db3VudDsgaSsrKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBsaXN0W2ldID0gU2ltcGxpZnlUb29scy5Db2xsaW5lYXJTaW1wbGlmeShsaXN0W2ldLCAwKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy9SZW1vdmUgZW1wdHkgdmVydGljZSBjb2xsZWN0aW9uc1xyXG4gICAgICAgICAgICBmb3IgKGludCBpID0gbGlzdC5Db3VudCAtIDE7IGkgPj0gMDsgaS0tKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBpZiAobGlzdFtpXS5Db3VudCA9PSAwKVxyXG4gICAgICAgICAgICAgICAgICAgIGxpc3QuUmVtb3ZlQXQoaSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHJldHVybiBsaXN0O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHJpdmF0ZSBzdGF0aWMgYm9vbCBDYW5TZWUoaW50IGksIGludCBqLCBWZXJ0aWNlcyB2ZXJ0aWNlcylcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGlmIChSZWZsZXgoaSwgdmVydGljZXMpKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBpZiAoTGVmdE9uKEF0KGksIHZlcnRpY2VzKSwgQXQoaSAtIDEsIHZlcnRpY2VzKSwgQXQoaiwgdmVydGljZXMpKSAmJlxyXG4gICAgICAgICAgICAgICAgICAgIFJpZ2h0T24oQXQoaSwgdmVydGljZXMpLCBBdChpICsgMSwgdmVydGljZXMpLCBBdChqLCB2ZXJ0aWNlcykpKSByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBpZiAoUmlnaHRPbihBdChpLCB2ZXJ0aWNlcyksIEF0KGkgKyAxLCB2ZXJ0aWNlcyksIEF0KGosIHZlcnRpY2VzKSkgfHxcclxuICAgICAgICAgICAgICAgICAgICBMZWZ0T24oQXQoaSwgdmVydGljZXMpLCBBdChpIC0gMSwgdmVydGljZXMpLCBBdChqLCB2ZXJ0aWNlcykpKSByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKFJlZmxleChqLCB2ZXJ0aWNlcykpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGlmIChMZWZ0T24oQXQoaiwgdmVydGljZXMpLCBBdChqIC0gMSwgdmVydGljZXMpLCBBdChpLCB2ZXJ0aWNlcykpICYmXHJcbiAgICAgICAgICAgICAgICAgICAgUmlnaHRPbihBdChqLCB2ZXJ0aWNlcyksIEF0KGogKyAxLCB2ZXJ0aWNlcyksIEF0KGksIHZlcnRpY2VzKSkpIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGlmIChSaWdodE9uKEF0KGosIHZlcnRpY2VzKSwgQXQoaiArIDEsIHZlcnRpY2VzKSwgQXQoaSwgdmVydGljZXMpKSB8fFxyXG4gICAgICAgICAgICAgICAgICAgIExlZnRPbihBdChqLCB2ZXJ0aWNlcyksIEF0KGogLSAxLCB2ZXJ0aWNlcyksIEF0KGksIHZlcnRpY2VzKSkpIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBmb3IgKGludCBrID0gMDsgayA8IHZlcnRpY2VzLkNvdW50OyArK2spXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGlmICgoayArIDEpICUgdmVydGljZXMuQ291bnQgPT0gaSB8fCBrID09IGkgfHwgKGsgKyAxKSAlIHZlcnRpY2VzLkNvdW50ID09IGogfHwgayA9PSBqKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlOyAvLyBpZ25vcmUgaW5jaWRlbnQgZWRnZXNcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIFZlY3RvcjIgaW50ZXJzZWN0aW9uUG9pbnQ7XHJcbiAgICAgICAgICAgICAgICBpZiAoTGluZVRvb2xzLkxpbmVJbnRlcnNlY3QoQXQoaSwgdmVydGljZXMpLCBBdChqLCB2ZXJ0aWNlcyksIEF0KGssIHZlcnRpY2VzKSwgQXQoayArIDEsIHZlcnRpY2VzKSwgb3V0IGludGVyc2VjdGlvblBvaW50KSlcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBwcmVjb25kaXRpb246IGNjd1xyXG4gICAgICAgIHByaXZhdGUgc3RhdGljIGJvb2wgUmVmbGV4KGludCBpLCBWZXJ0aWNlcyB2ZXJ0aWNlcylcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiBSaWdodChpLCB2ZXJ0aWNlcyk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwcml2YXRlIHN0YXRpYyBib29sIFJpZ2h0KGludCBpLCBWZXJ0aWNlcyB2ZXJ0aWNlcylcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiBSaWdodChBdChpIC0gMSwgdmVydGljZXMpLCBBdChpLCB2ZXJ0aWNlcyksIEF0KGkgKyAxLCB2ZXJ0aWNlcykpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHJpdmF0ZSBzdGF0aWMgYm9vbCBMZWZ0KFZlY3RvcjIgYSwgVmVjdG9yMiBiLCBWZWN0b3IyIGMpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gTWF0aFV0aWxzLkFyZWEocmVmIGEsIHJlZiBiLCByZWYgYykgPiAwO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHJpdmF0ZSBzdGF0aWMgYm9vbCBMZWZ0T24oVmVjdG9yMiBhLCBWZWN0b3IyIGIsIFZlY3RvcjIgYylcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiBNYXRoVXRpbHMuQXJlYShyZWYgYSwgcmVmIGIsIHJlZiBjKSA+PSAwO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHJpdmF0ZSBzdGF0aWMgYm9vbCBSaWdodChWZWN0b3IyIGEsIFZlY3RvcjIgYiwgVmVjdG9yMiBjKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIE1hdGhVdGlscy5BcmVhKHJlZiBhLCByZWYgYiwgcmVmIGMpIDwgMDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHByaXZhdGUgc3RhdGljIGJvb2wgUmlnaHRPbihWZWN0b3IyIGEsIFZlY3RvcjIgYiwgVmVjdG9yMiBjKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIE1hdGhVdGlscy5BcmVhKHJlZiBhLCByZWYgYiwgcmVmIGMpIDw9IDA7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwcml2YXRlIHN0YXRpYyBmbG9hdCBTcXVhcmVEaXN0KFZlY3RvcjIgYSwgVmVjdG9yMiBiKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgZmxvYXQgZHggPSBiLlggLSBhLlg7XHJcbiAgICAgICAgICAgIGZsb2F0IGR5ID0gYi5ZIC0gYS5ZO1xyXG4gICAgICAgICAgICByZXR1cm4gZHggKiBkeCArIGR5ICogZHk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59IiwiLyogUG9seTJUcmlcclxuICogQ29weXJpZ2h0IChjKSAyMDA5LTIwMTAsIFBvbHkyVHJpIENvbnRyaWJ1dG9yc1xyXG4gKiBodHRwOi8vY29kZS5nb29nbGUuY29tL3AvcG9seTJ0cmkvXHJcbiAqXHJcbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqXHJcbiAqIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGggb3Igd2l0aG91dCBtb2RpZmljYXRpb24sXHJcbiAqIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnMgYXJlIG1ldDpcclxuICpcclxuICogKiBSZWRpc3RyaWJ1dGlvbnMgb2Ygc291cmNlIGNvZGUgbXVzdCByZXRhaW4gdGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UsXHJcbiAqICAgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lci5cclxuICogKiBSZWRpc3RyaWJ1dGlvbnMgaW4gYmluYXJ5IGZvcm0gbXVzdCByZXByb2R1Y2UgdGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UsXHJcbiAqICAgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lciBpbiB0aGUgZG9jdW1lbnRhdGlvblxyXG4gKiAgIGFuZC9vciBvdGhlciBtYXRlcmlhbHMgcHJvdmlkZWQgd2l0aCB0aGUgZGlzdHJpYnV0aW9uLlxyXG4gKiAqIE5laXRoZXIgdGhlIG5hbWUgb2YgUG9seTJUcmkgbm9yIHRoZSBuYW1lcyBvZiBpdHMgY29udHJpYnV0b3JzIG1heSBiZVxyXG4gKiAgIHVzZWQgdG8gZW5kb3JzZSBvciBwcm9tb3RlIHByb2R1Y3RzIGRlcml2ZWQgZnJvbSB0aGlzIHNvZnR3YXJlIHdpdGhvdXQgc3BlY2lmaWNcclxuICogICBwcmlvciB3cml0dGVuIHBlcm1pc3Npb24uXHJcbiAqXHJcbiAqIFRISVMgU09GVFdBUkUgSVMgUFJPVklERUQgQlkgVEhFIENPUFlSSUdIVCBIT0xERVJTIEFORCBDT05UUklCVVRPUlNcclxuICogXCJBUyBJU1wiIEFORCBBTlkgRVhQUkVTUyBPUiBJTVBMSUVEIFdBUlJBTlRJRVMsIElOQ0xVRElORywgQlVUIE5PVFxyXG4gKiBMSU1JVEVEIFRPLCBUSEUgSU1QTElFRCBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSBBTkQgRklUTkVTUyBGT1JcclxuICogQSBQQVJUSUNVTEFSIFBVUlBPU0UgQVJFIERJU0NMQUlNRUQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBDT1BZUklHSFQgT1dORVIgT1JcclxuICogQ09OVFJJQlVUT1JTIEJFIExJQUJMRSBGT1IgQU5ZIERJUkVDVCwgSU5ESVJFQ1QsIElOQ0lERU5UQUwsIFNQRUNJQUwsXHJcbiAqIEVYRU1QTEFSWSwgT1IgQ09OU0VRVUVOVElBTCBEQU1BR0VTIChJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRCBUTyxcclxuICogUFJPQ1VSRU1FTlQgT0YgU1VCU1RJVFVURSBHT09EUyBPUiBTRVJWSUNFUzsgTE9TUyBPRiBVU0UsIERBVEEsIE9SXHJcbiAqIFBST0ZJVFM7IE9SIEJVU0lORVNTIElOVEVSUlVQVElPTikgSE9XRVZFUiBDQVVTRUQgQU5EIE9OIEFOWSBUSEVPUlkgT0ZcclxuICogTElBQklMSVRZLCBXSEVUSEVSIElOIENPTlRSQUNULCBTVFJJQ1QgTElBQklMSVRZLCBPUiBUT1JUIChJTkNMVURJTkdcclxuICogTkVHTElHRU5DRSBPUiBPVEhFUldJU0UpIEFSSVNJTkcgSU4gQU5ZIFdBWSBPVVQgT0YgVEhFIFVTRSBPRiBUSElTXHJcbiAqIFNPRlRXQVJFLCBFVkVOIElGIEFEVklTRUQgT0YgVEhFIFBPU1NJQklMSVRZIE9GIFNVQ0ggREFNQUdFLlxyXG4gKi9cclxuXHJcbnVzaW5nIFN5c3RlbS5Db2xsZWN0aW9ucy5HZW5lcmljO1xyXG51c2luZyBNaWNyb3NvZnQuWG5hLkZyYW1ld29yaztcclxudXNpbmcgUG9seTJUcmkuVHJpYW5ndWxhdGlvbjtcclxudXNpbmcgUG9seTJUcmkuVHJpYW5ndWxhdGlvbi5EZWxhdW5heTtcclxudXNpbmcgUG9seTJUcmkuVHJpYW5ndWxhdGlvbi5EZWxhdW5heS5Td2VlcDtcclxudXNpbmcgUG9seTJUcmkuVHJpYW5ndWxhdGlvbi5Qb2x5Z29uO1xyXG5cclxudXNpbmcgU3lzdGVtLkxpbnE7XHJcblxyXG5uYW1lc3BhY2UgRmFyc2VlclBoeXNpY3MuQ29tbW9uLkRlY29tcG9zaXRpb25cclxue1xyXG4gICAgcHVibGljIHN0YXRpYyBjbGFzcyBDRFREZWNvbXBvc2VyXHJcbiAgICB7XHJcbiAgICAgICAgcHVibGljIHN0YXRpYyBMaXN0PFZlcnRpY2VzPiBDb252ZXhQYXJ0aXRpb24oVmVydGljZXMgdmVydGljZXMpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBQb2x5Z29uIHBvbHkgPSBuZXcgUG9seWdvbigpO1xyXG5cclxuICAgICAgICAgICAgZm9yZWFjaCAoVmVjdG9yMiB2ZXJ0ZXggaW4gdmVydGljZXMpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHBvbHkuUG9pbnRzLkFkZChuZXcgVHJpYW5ndWxhdGlvblBvaW50KHZlcnRleC5YLCB2ZXJ0ZXguWSkpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBEVFN3ZWVwQ29udGV4dCB0Y3ggPSBuZXcgRFRTd2VlcENvbnRleHQoKTtcclxuICAgICAgICAgICAgdGN4LlByZXBhcmVUcmlhbmd1bGF0aW9uKHBvbHkpO1xyXG4gICAgICAgICAgICBEVFN3ZWVwLlRyaWFuZ3VsYXRlKHRjeCk7XHJcblxyXG4gICAgICAgICAgICBMaXN0PFZlcnRpY2VzPiByZXN1bHRzID0gbmV3IExpc3Q8VmVydGljZXM+KCk7XHJcblxyXG4gICAgICAgICAgICBmb3JlYWNoIChEZWxhdW5heVRyaWFuZ2xlIHRyaWFuZ2xlIGluIHBvbHkuVHJpYW5nbGVzKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBWZXJ0aWNlcyB2ID0gbmV3IFZlcnRpY2VzKCk7XHJcbiAgICAgICAgICAgICAgICBmb3JlYWNoIChUcmlhbmd1bGF0aW9uUG9pbnQgcCBpbiB0cmlhbmdsZS5Qb2ludHMpXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgdi5BZGQobmV3IFZlY3RvcjIoKGZsb2F0KXAuWCwgKGZsb2F0KXAuWSkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmVzdWx0cy5BZGQodik7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHJldHVybiByZXN1bHRzO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHVibGljIHN0YXRpYyBMaXN0PFZlcnRpY2VzPiBDb252ZXhQYXJ0aXRpb24oRGV0ZWN0ZWRWZXJ0aWNlcyB2ZXJ0aWNlcylcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIFBvbHlnb24gcG9seSA9IG5ldyBQb2x5Z29uKCk7XHJcbiAgICAgICAgICAgIGZvcmVhY2ggKHZhciB2ZXJ0ZXggaW4gdmVydGljZXMpXHJcbiAgICAgICAgICAgICAgICBwb2x5LlBvaW50cy5BZGQobmV3IFRyaWFuZ3VsYXRpb25Qb2ludCh2ZXJ0ZXguWCwgdmVydGV4LlkpKTtcclxuXHJcbiAgICAgICAgICAgIGlmICh2ZXJ0aWNlcy5Ib2xlcyAhPSBudWxsKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBmb3JlYWNoICh2YXIgaG9sZVZlcnRpY2VzIGluIHZlcnRpY2VzLkhvbGVzKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIFBvbHlnb24gaG9sZSA9IG5ldyBQb2x5Z29uKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yZWFjaCAodmFyIHZlcnRleCBpbiBob2xlVmVydGljZXMpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGhvbGUuUG9pbnRzLkFkZChuZXcgVHJpYW5ndWxhdGlvblBvaW50KHZlcnRleC5YLCB2ZXJ0ZXguWSkpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBwb2x5LkFkZEhvbGUoaG9sZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIERUU3dlZXBDb250ZXh0IHRjeCA9IG5ldyBEVFN3ZWVwQ29udGV4dCgpO1xyXG4gICAgICAgICAgICB0Y3guUHJlcGFyZVRyaWFuZ3VsYXRpb24ocG9seSk7XHJcbiAgICAgICAgICAgIERUU3dlZXAuVHJpYW5ndWxhdGUodGN4KTtcclxuXHJcbiAgICAgICAgICAgIExpc3Q8VmVydGljZXM+IHJlc3VsdHMgPSBuZXcgTGlzdDxWZXJ0aWNlcz4oKTtcclxuXHJcbiAgICAgICAgICAgIGZvcmVhY2ggKERlbGF1bmF5VHJpYW5nbGUgdHJpYW5nbGUgaW4gcG9seS5UcmlhbmdsZXMpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIFZlcnRpY2VzIHYgPSBuZXcgVmVydGljZXMoKTtcclxuICAgICAgICAgICAgICAgIGZvcmVhY2ggKFRyaWFuZ3VsYXRpb25Qb2ludCBwIGluIHRyaWFuZ2xlLlBvaW50cylcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICB2LkFkZChuZXcgVmVjdG9yMigoZmxvYXQpcC5YLCAoZmxvYXQpcC5ZKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXN1bHRzLkFkZCh2KTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdHM7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59IiwiLypcclxuICogQyMgVmVyc2lvbiBQb3J0ZWQgYnkgTWF0dCBCZXR0Y2hlciBhbmQgSWFuIFF2aXN0IDIwMDktMjAxMFxyXG4gKiBcclxuICogT3JpZ2luYWwgQysrIFZlcnNpb24gQ29weXJpZ2h0IChjKSAyMDA3IEVyaWMgSm9yZGFuXHJcbiAqXHJcbiAqIFRoaXMgc29mdHdhcmUgaXMgcHJvdmlkZWQgJ2FzLWlzJywgd2l0aG91dCBhbnkgZXhwcmVzcyBvciBpbXBsaWVkXHJcbiAqIHdhcnJhbnR5LiAgSW4gbm8gZXZlbnQgd2lsbCB0aGUgYXV0aG9ycyBiZSBoZWxkIGxpYWJsZSBmb3IgYW55IGRhbWFnZXNcclxuICogYXJpc2luZyBmcm9tIHRoZSB1c2Ugb2YgdGhpcyBzb2Z0d2FyZS5cclxuICogUGVybWlzc2lvbiBpcyBncmFudGVkIHRvIGFueW9uZSB0byB1c2UgdGhpcyBzb2Z0d2FyZSBmb3IgYW55IHB1cnBvc2UsXHJcbiAqIGluY2x1ZGluZyBjb21tZXJjaWFsIGFwcGxpY2F0aW9ucywgYW5kIHRvIGFsdGVyIGl0IGFuZCByZWRpc3RyaWJ1dGUgaXRcclxuICogZnJlZWx5LCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgcmVzdHJpY3Rpb25zOlxyXG4gKiAxLiBUaGUgb3JpZ2luIG9mIHRoaXMgc29mdHdhcmUgbXVzdCBub3QgYmUgbWlzcmVwcmVzZW50ZWQ7IHlvdSBtdXN0IG5vdFxyXG4gKiBjbGFpbSB0aGF0IHlvdSB3cm90ZSB0aGUgb3JpZ2luYWwgc29mdHdhcmUuIElmIHlvdSB1c2UgdGhpcyBzb2Z0d2FyZVxyXG4gKiBpbiBhIHByb2R1Y3QsIGFuIGFja25vd2xlZGdtZW50IGluIHRoZSBwcm9kdWN0IGRvY3VtZW50YXRpb24gd291bGQgYmVcclxuICogYXBwcmVjaWF0ZWQgYnV0IGlzIG5vdCByZXF1aXJlZC5cclxuICogMi4gQWx0ZXJlZCBzb3VyY2UgdmVyc2lvbnMgbXVzdCBiZSBwbGFpbmx5IG1hcmtlZCBhcyBzdWNoLCBhbmQgbXVzdCBub3QgYmVcclxuICogbWlzcmVwcmVzZW50ZWQgYXMgYmVpbmcgdGhlIG9yaWdpbmFsIHNvZnR3YXJlLlxyXG4gKiAzLiBUaGlzIG5vdGljZSBtYXkgbm90IGJlIHJlbW92ZWQgb3IgYWx0ZXJlZCBmcm9tIGFueSBzb3VyY2UgZGlzdHJpYnV0aW9uLlxyXG4gKi9cclxuXHJcbnVzaW5nIFN5c3RlbTtcclxudXNpbmcgU3lzdGVtLkNvbGxlY3Rpb25zLkdlbmVyaWM7XHJcbnVzaW5nIEZhcnNlZXJQaHlzaWNzLkNvbW1vbi5Qb2x5Z29uTWFuaXB1bGF0aW9uO1xyXG51c2luZyBNaWNyb3NvZnQuWG5hLkZyYW1ld29yaztcclxuXHJcbm5hbWVzcGFjZSBGYXJzZWVyUGh5c2ljcy5Db21tb24uRGVjb21wb3NpdGlvblxyXG57XHJcbiAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAvLy8gUG9ydGVkIGZyb20gakJveDJELiBPcmlnaW5hbCBhdXRob3I6IGV3am9yZGFuIFxyXG4gICAgLy8vIFRyaWFuZ3VsYXRlcyBhIHBvbHlnb24gdXNpbmcgc2ltcGxlIGVhci1jbGlwcGluZyBhbGdvcml0aG0uXHJcbiAgICAvLy8gXHJcbiAgICAvLy8gT25seSB3b3JrcyBvbiBzaW1wbGUgcG9seWdvbnMuXHJcbiAgICAvLy8gXHJcbiAgICAvLy8gVHJpYW5nbGVzIG1heSBiZSBkZWdlbmVyYXRlLCBlc3BlY2lhbGx5IGlmIHlvdSBoYXZlIGlkZW50aWNhbCBwb2ludHNcclxuICAgIC8vLyBpbiB0aGUgaW5wdXQgdG8gdGhlIGFsZ29yaXRobS4gIENoZWNrIHRoaXMgYmVmb3JlIHlvdSB1c2UgdGhlbS5cclxuICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICBwdWJsaWMgc3RhdGljIGNsYXNzIEVhcmNsaXBEZWNvbXBvc2VyXHJcbiAgICB7XHJcbiAgICAgICAgLy9ib3gyRCByZXYgMzIgLSBmb3IgZGV0YWlscywgc2VlIGh0dHA6Ly93d3cuYm94MmQub3JnL2ZvcnVtL3ZpZXd0b3BpYy5waHA/Zj00JnQ9ODMmc3RhcnQ9NTBcclxuXHJcbiAgICAgICAgcHJpdmF0ZSBjb25zdCBmbG9hdCBUb2wgPSAuMDAxZjtcclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBEZWNvbXBvc2VzIGEgbm9uLWNvbnZleCBwb2x5Z29uIGludG8gYSBudW1iZXIgb2YgY29udmV4IHBvbHlnb25zLCB1cFxyXG4gICAgICAgIC8vLyB0byBtYXhQb2x5cyAocmVtYWluaW5nIHBpZWNlcyBhcmUgdGhyb3duIG91dCkuXHJcbiAgICAgICAgLy8vXHJcbiAgICAgICAgLy8vIEVhY2ggcmVzdWx0aW5nIHBvbHlnb24gd2lsbCBoYXZlIG5vIG1vcmUgdGhhbiBTZXR0aW5ncy5NYXhQb2x5Z29uVmVydGljZXNcclxuICAgICAgICAvLy8gdmVydGljZXMuXHJcbiAgICAgICAgLy8vIFxyXG4gICAgICAgIC8vLyBXYXJuaW5nOiBPbmx5IHdvcmtzIG9uIHNpbXBsZSBwb2x5Z29uc1xyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwidmVydGljZXNcIj5UaGUgdmVydGljZXMuPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHJldHVybnM+PC9yZXR1cm5zPlxyXG4gICAgICAgIHB1YmxpYyBzdGF0aWMgTGlzdDxWZXJ0aWNlcz4gQ29udmV4UGFydGl0aW9uKFZlcnRpY2VzIHZlcnRpY2VzKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIENvbnZleFBhcnRpdGlvbih2ZXJ0aWNlcywgaW50Lk1heFZhbHVlLCAwKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gRGVjb21wb3NlcyBhIG5vbi1jb252ZXggcG9seWdvbiBpbnRvIGEgbnVtYmVyIG9mIGNvbnZleCBwb2x5Z29ucywgdXBcclxuICAgICAgICAvLy8gdG8gbWF4UG9seXMgKHJlbWFpbmluZyBwaWVjZXMgYXJlIHRocm93biBvdXQpLlxyXG4gICAgICAgIC8vLyBFYWNoIHJlc3VsdGluZyBwb2x5Z29uIHdpbGwgaGF2ZSBubyBtb3JlIHRoYW4gU2V0dGluZ3MuTWF4UG9seWdvblZlcnRpY2VzXHJcbiAgICAgICAgLy8vIHZlcnRpY2VzLlxyXG4gICAgICAgIC8vLyBXYXJuaW5nOiBPbmx5IHdvcmtzIG9uIHNpbXBsZSBwb2x5Z29uc1xyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwidmVydGljZXNcIj5UaGUgdmVydGljZXMuPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJtYXhQb2x5c1wiPlRoZSBtYXhpbXVtIG51bWJlciBvZiBwb2x5Z29ucy48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cInRvbGVyYW5jZVwiPlRoZSB0b2xlcmFuY2UuPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHJldHVybnM+PC9yZXR1cm5zPlxyXG4gICAgICAgIHB1YmxpYyBzdGF0aWMgTGlzdDxWZXJ0aWNlcz4gQ29udmV4UGFydGl0aW9uKFZlcnRpY2VzIHZlcnRpY2VzLCBpbnQgbWF4UG9seXMsIGZsb2F0IHRvbGVyYW5jZSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGlmICh2ZXJ0aWNlcy5Db3VudCA8IDMpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZ2xvYmFsOjpCcmlkZ2UuU2NyaXB0LkNhbGxGb3IobmV3IExpc3Q8VmVydGljZXM+KCksKF9vMSk9PntfbzEuQWRkKHZlcnRpY2VzKTtyZXR1cm4gX28xO30pO1xyXG4gICAgICAgICAgICAvKlxyXG4gICAgICAgICAgICBpZiAodmVydGljZXMuSXNDb252ZXgoKSAmJiB2ZXJ0aWNlcy5Db3VudCA8PSBTZXR0aW5ncy5NYXhQb2x5Z29uVmVydGljZXMpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGlmICh2ZXJ0aWNlcy5Jc0NvdW50ZXJDbG9ja1dpc2UoKSlcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBWZXJ0aWNlcyB0ZW1wUCA9IG5ldyBWZXJ0aWNlcyh2ZXJ0aWNlcyk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGVtcFAuUmV2ZXJzZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRlbXBQID0gU2ltcGxpZnlUb29scy5Db2xsaW5lYXJTaW1wbGlmeSh0ZW1wUCk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGVtcFAuRm9yY2VDb3VudGVyQ2xvY2tXaXNlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBMaXN0PFZlcnRpY2VzPiB7IHRlbXBQIH07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB2ZXJ0aWNlcyA9IFNpbXBsaWZ5VG9vbHMuQ29sbGluZWFyU2ltcGxpZnkodmVydGljZXMpO1xyXG4gICAgICAgICAgICAgICAgdmVydGljZXMuRm9yY2VDb3VudGVyQ2xvY2tXaXNlKCk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IExpc3Q8VmVydGljZXM+IHsgdmVydGljZXMgfTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBMaXN0PFRyaWFuZ2xlPiB0cmlhbmd1bGF0ZWQ7XHJcblxyXG4gICAgICAgICAgICBpZiAodmVydGljZXMuSXNDb3VudGVyQ2xvY2tXaXNlKCkpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIFZlcnRpY2VzIHRlbXBQID0gbmV3IFZlcnRpY2VzKHZlcnRpY2VzKTtcclxuICAgICAgICAgICAgICAgIHRlbXBQLlJldmVyc2UoKTtcclxuICAgICAgICAgICAgICAgIHRyaWFuZ3VsYXRlZCA9IFRyaWFuZ3VsYXRlUG9seWdvbih0ZW1wUCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB0cmlhbmd1bGF0ZWQgPSBUcmlhbmd1bGF0ZVBvbHlnb24odmVydGljZXMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICh0cmlhbmd1bGF0ZWQuQ291bnQgPCAxKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAvL1N0aWxsIG5vIGx1Y2s/ICBPaCB3ZWxsLi4uXHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXhjZXB0aW9uKFwiQ2FuJ3QgdHJpYW5ndWxhdGUgeW91ciBwb2x5Z29uLlwiKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgTGlzdDxWZXJ0aWNlcz4gcG9seWdvbml6ZWRUcmlhbmdsZXMgPSBQb2x5Z29uaXplVHJpYW5nbGVzKHRyaWFuZ3VsYXRlZCwgbWF4UG9seXMsIHRvbGVyYW5jZSk7XHJcblxyXG4gICAgICAgICAgICAvL1RoZSBwb2x5Z29uaXplZCB0cmlhbmdsZXMgYXJlIG5vdCBndWFyYW50ZWVkIHRvIGJlIHdpdGhvdXQgY29sbGluZWFyIHBvaW50cy4gV2UgcmVtb3ZlXHJcbiAgICAgICAgICAgIC8vdGhlbSB0byBiZSBzdXJlLlxyXG4gICAgICAgICAgICBmb3IgKGludCBpID0gMDsgaSA8IHBvbHlnb25pemVkVHJpYW5nbGVzLkNvdW50OyBpKyspXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHBvbHlnb25pemVkVHJpYW5nbGVzW2ldID0gU2ltcGxpZnlUb29scy5Db2xsaW5lYXJTaW1wbGlmeShwb2x5Z29uaXplZFRyaWFuZ2xlc1tpXSwgMCk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vUmVtb3ZlIGVtcHR5IHZlcnRpY2UgY29sbGVjdGlvbnNcclxuICAgICAgICAgICAgZm9yIChpbnQgaSA9IHBvbHlnb25pemVkVHJpYW5nbGVzLkNvdW50IC0gMTsgaSA+PSAwOyBpLS0pXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGlmIChwb2x5Z29uaXplZFRyaWFuZ2xlc1tpXS5Db3VudCA9PSAwKVxyXG4gICAgICAgICAgICAgICAgICAgIHBvbHlnb25pemVkVHJpYW5nbGVzLlJlbW92ZUF0KGkpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gcG9seWdvbml6ZWRUcmlhbmdsZXM7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIFR1cm5zIGEgbGlzdCBvZiB0cmlhbmdsZXMgaW50byBhIGxpc3Qgb2YgY29udmV4IHBvbHlnb25zLiBWZXJ5IHNpbXBsZVxyXG4gICAgICAgIC8vLyBtZXRob2QgLSBzdGFydCB3aXRoIGEgc2VlZCB0cmlhbmdsZSwga2VlcCBhZGRpbmcgdHJpYW5nbGVzIHRvIGl0IHVudGlsXHJcbiAgICAgICAgLy8vIHlvdSBjYW4ndCBhZGQgYW55IG1vcmUgd2l0aG91dCBtYWtpbmcgdGhlIHBvbHlnb24gbm9uLWNvbnZleC5cclxuICAgICAgICAvLy9cclxuICAgICAgICAvLy8gUmV0dXJucyBhbiBpbnRlZ2VyIHRlbGxpbmcgaG93IG1hbnkgcG9seWdvbnMgd2VyZSBjcmVhdGVkLiAgV2lsbCBmaWxsXHJcbiAgICAgICAgLy8vIHBvbHlzIGFycmF5IHVwIHRvIHBvbHlzTGVuZ3RoIGVudHJpZXMsIHdoaWNoIG1heSBiZSBzbWFsbGVyIG9yIGxhcmdlclxyXG4gICAgICAgIC8vLyB0aGFuIHRoZSByZXR1cm4gdmFsdWUuXHJcbiAgICAgICAgLy8vIFxyXG4gICAgICAgIC8vLyBUYWtlcyBPKE4vLy9QKSB3aGVyZSBQIGlzIHRoZSBudW1iZXIgb2YgcmVzdWx0YW50IHBvbHlnb25zLCBOIGlzIHRyaWFuZ2xlXHJcbiAgICAgICAgLy8vIGNvdW50LlxyXG4gICAgICAgIC8vLyBcclxuICAgICAgICAvLy8gVGhlIGZpbmFsIHBvbHlnb24gbGlzdCB3aWxsIG5vdCBuZWNlc3NhcmlseSBiZSBtaW5pbWFsLCB0aG91Z2ggaW5cclxuICAgICAgICAvLy8gcHJhY3RpY2UgaXQgd29ya3MgZmFpcmx5IHdlbGwuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJ0cmlhbmd1bGF0ZWRcIj5UaGUgdHJpYW5ndWxhdGVkLjwvcGFyYW0+XHJcbiAgICAgICAgLy8vPHBhcmFtIG5hbWU9XCJtYXhQb2x5c1wiPlRoZSBtYXhpbXVuIG51bWJlciBvZiBwb2x5Z29uczwvcGFyYW0+XHJcbiAgICAgICAgLy8vPHBhcmFtIG5hbWU9XCJ0b2xlcmFuY2VcIj5UaGUgdG9sZXJhbmNlPC9wYXJhbT5cclxuICAgICAgICAvLy88cmV0dXJucz48L3JldHVybnM+XHJcbiAgICAgICAgcHVibGljIHN0YXRpYyBMaXN0PFZlcnRpY2VzPiBQb2x5Z29uaXplVHJpYW5nbGVzKExpc3Q8VHJpYW5nbGU+IHRyaWFuZ3VsYXRlZCwgaW50IG1heFBvbHlzLCBmbG9hdCB0b2xlcmFuY2UpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBMaXN0PFZlcnRpY2VzPiBwb2x5cyA9IG5ldyBMaXN0PFZlcnRpY2VzPig1MCk7XHJcblxyXG4gICAgICAgICAgICBpbnQgcG9seUluZGV4ID0gMDtcclxuXHJcbiAgICAgICAgICAgIGlmICh0cmlhbmd1bGF0ZWQuQ291bnQgPD0gMClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgLy9yZXR1cm4gZW1wdHkgcG9seWdvbiBsaXN0XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcG9seXM7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGJvb2xbXSBjb3ZlcmVkID0gbmV3IGJvb2xbdHJpYW5ndWxhdGVkLkNvdW50XTtcclxuICAgICAgICAgICAgZm9yIChpbnQgaSA9IDA7IGkgPCB0cmlhbmd1bGF0ZWQuQ291bnQ7ICsraSlcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgY292ZXJlZFtpXSA9IGZhbHNlO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vQ2hlY2sgaGVyZSBmb3IgZGVnZW5lcmF0ZSB0cmlhbmdsZXNcclxuICAgICAgICAgICAgICAgIGlmICgoKHRyaWFuZ3VsYXRlZFtpXS5YWzBdID09IHRyaWFuZ3VsYXRlZFtpXS5YWzFdKSAmJiAodHJpYW5ndWxhdGVkW2ldLllbMF0gPT0gdHJpYW5ndWxhdGVkW2ldLllbMV0pKVxyXG4gICAgICAgICAgICAgICAgICAgIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgKCh0cmlhbmd1bGF0ZWRbaV0uWFsxXSA9PSB0cmlhbmd1bGF0ZWRbaV0uWFsyXSkgJiYgKHRyaWFuZ3VsYXRlZFtpXS5ZWzFdID09IHRyaWFuZ3VsYXRlZFtpXS5ZWzJdKSlcclxuICAgICAgICAgICAgICAgICAgICB8fFxyXG4gICAgICAgICAgICAgICAgICAgICgodHJpYW5ndWxhdGVkW2ldLlhbMF0gPT0gdHJpYW5ndWxhdGVkW2ldLlhbMl0pICYmICh0cmlhbmd1bGF0ZWRbaV0uWVswXSA9PSB0cmlhbmd1bGF0ZWRbaV0uWVsyXSkpKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvdmVyZWRbaV0gPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBib29sIG5vdERvbmUgPSB0cnVlO1xyXG4gICAgICAgICAgICB3aGlsZSAobm90RG9uZSlcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgaW50IGN1cnJUcmkgPSAtMTtcclxuICAgICAgICAgICAgICAgIGZvciAoaW50IGkgPSAwOyBpIDwgdHJpYW5ndWxhdGVkLkNvdW50OyArK2kpXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvdmVyZWRbaV0pXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIGN1cnJUcmkgPSBpO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKGN1cnJUcmkgPT0gLTEpXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgbm90RG9uZSA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIFZlcnRpY2VzIHBvbHkgPSBuZXcgVmVydGljZXMoMyk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGZvciAoaW50IGkgPSAwOyBpIDwgMzsgaSsrKVxyXG4gICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcG9seS5BZGQobmV3IFZlY3RvcjIodHJpYW5ndWxhdGVkW2N1cnJUcmldLlhbaV0sIHRyaWFuZ3VsYXRlZFtjdXJyVHJpXS5ZW2ldKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICBjb3ZlcmVkW2N1cnJUcmldID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICBpbnQgaW5kZXggPSAwO1xyXG4gICAgICAgICAgICAgICAgICAgIGZvciAoaW50IGkgPSAwOyBpIDwgMiAqIHRyaWFuZ3VsYXRlZC5Db3VudDsgKytpLCArK2luZGV4KVxyXG4gICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKGluZGV4ID49IHRyaWFuZ3VsYXRlZC5Db3VudCkgaW5kZXggLT0gdHJpYW5ndWxhdGVkLkNvdW50O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY292ZXJlZFtpbmRleF0pXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIFZlcnRpY2VzIG5ld1AgPSBBZGRUcmlhbmdsZSh0cmlhbmd1bGF0ZWRbaW5kZXhdLCBwb2x5KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5ld1AgPT0gbnVsbClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlOyAvLyBpcyB0aGlzIHJpZ2h0XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobmV3UC5Db3VudCA+IFNldHRpbmdzLk1heFBvbHlnb25WZXJ0aWNlcylcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5ld1AuSXNDb252ZXgoKSlcclxuICAgICAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9PciBzaG91bGQgaXQgYmUgSXNVc2FibGU/ICBNYXliZSByZS13cml0ZSBJc0NvbnZleCB0byBhcHBseSB0aGUgYW5nbGUgdGhyZXNob2xkIGZyb20gQm94MmRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvbHkgPSBuZXcgVmVydGljZXMobmV3UCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb3ZlcmVkW2luZGV4XSA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vV2UgaGF2ZSBhIG1heGltdW0gb2YgcG9seWdvbnMgdGhhdCB3ZSBuZWVkIHRvIGtlZXAgdW5kZXIuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBvbHlJbmRleCA8IG1heFBvbHlzKVxyXG4gICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy9TaW1wbGlmeVRvb2xzLk1lcmdlUGFyYWxsZWxFZGdlcyhwb2x5LCB0b2xlcmFuY2UpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy9JZiBpZGVudGljYWwgcG9pbnRzIGFyZSBwcmVzZW50LCBhIHRyaWFuZ2xlIGdldHNcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy9ib3JrZWQgYnkgdGhlIE1lcmdlUGFyYWxsZWxFZGdlcyBmdW5jdGlvbiwgaGVuY2VcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy90aGUgdmVydGV4IG51bWJlciBjaGVja1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocG9seS5Db3VudCA+PSAzKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9seXMuQWRkKG5ldyBWZXJ0aWNlcyhwb2x5KSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vZWxzZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyAgICBwcmludGYoXCJTa2lwcGluZyBjb3JydXB0IHBvbHlcXG5cIik7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChwb2x5LkNvdW50ID49IDMpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvbHlJbmRleCsrOyAvL011c3QgYmUgb3V0c2lkZSAocG9seUluZGV4IDwgcG9seXNMZW5ndGgpIHRlc3RcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuIHBvbHlzO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBUcmlhbmd1bGF0ZXMgYSBwb2x5Z29uIHVzaW5nIHNpbXBsZSBlYXItY2xpcHBpbmcgYWxnb3JpdGhtLiBSZXR1cm5zXHJcbiAgICAgICAgLy8vIHNpemUgb2YgVHJpYW5nbGUgYXJyYXkgdW5sZXNzIHRoZSBwb2x5Z29uIGNhbid0IGJlIHRyaWFuZ3VsYXRlZC5cclxuICAgICAgICAvLy8gVGhpcyBzaG91bGQgb25seSBoYXBwZW4gaWYgdGhlIHBvbHlnb24gc2VsZi1pbnRlcnNlY3RzLFxyXG4gICAgICAgIC8vLyB0aG91Z2ggaXQgd2lsbCBub3QgX2Fsd2F5c18gcmV0dXJuIG51bGwgZm9yIGEgYmFkIHBvbHlnb24gLSBpdCBpcyB0aGVcclxuICAgICAgICAvLy8gY2FsbGVyJ3MgcmVzcG9uc2liaWxpdHkgdG8gY2hlY2sgZm9yIHNlbGYtaW50ZXJzZWN0aW9uLCBhbmQgaWYgaXRcclxuICAgICAgICAvLy8gZG9lc24ndCwgaXQgc2hvdWxkIGF0IGxlYXN0IGNoZWNrIHRoYXQgdGhlIHJldHVybiB2YWx1ZSBpcyBub24tbnVsbFxyXG4gICAgICAgIC8vLyBiZWZvcmUgdXNpbmcuIFlvdSdyZSB3YXJuZWQhXHJcbiAgICAgICAgLy8vXHJcbiAgICAgICAgLy8vIFRyaWFuZ2xlcyBtYXkgYmUgZGVnZW5lcmF0ZSwgZXNwZWNpYWxseSBpZiB5b3UgaGF2ZSBpZGVudGljYWwgcG9pbnRzXHJcbiAgICAgICAgLy8vIGluIHRoZSBpbnB1dCB0byB0aGUgYWxnb3JpdGhtLiAgQ2hlY2sgdGhpcyBiZWZvcmUgeW91IHVzZSB0aGVtLlxyXG4gICAgICAgIC8vL1xyXG4gICAgICAgIC8vLyBUaGlzIGlzIHRvdGFsbHkgdW5vcHRpbWl6ZWQsIHNvIGZvciBsYXJnZSBwb2x5Z29ucyBpdCBzaG91bGQgbm90IGJlIHBhcnRcclxuICAgICAgICAvLy8gb2YgdGhlIHNpbXVsYXRpb24gbG9vcC5cclxuICAgICAgICAvLy9cclxuICAgICAgICAvLy8gV2FybmluZzogT25seSB3b3JrcyBvbiBzaW1wbGUgcG9seWdvbnMuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHJldHVybnM+PC9yZXR1cm5zPlxyXG4gICAgICAgIHB1YmxpYyBzdGF0aWMgTGlzdDxUcmlhbmdsZT4gVHJpYW5ndWxhdGVQb2x5Z29uKFZlcnRpY2VzIHZlcnRpY2VzKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgTGlzdDxUcmlhbmdsZT4gcmVzdWx0cyA9IG5ldyBMaXN0PFRyaWFuZ2xlPigpO1xyXG4gICAgICAgICAgICBpZiAodmVydGljZXMuQ291bnQgPCAzKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBMaXN0PFRyaWFuZ2xlPigpO1xyXG5cclxuICAgICAgICAgICAgLy9SZWN1cnNlIGFuZCBzcGxpdCBvbiBwaW5jaCBwb2ludHNcclxuICAgICAgICAgICAgVmVydGljZXMgcEEsIHBCO1xyXG4gICAgICAgICAgICBWZXJ0aWNlcyBwaW4gPSBuZXcgVmVydGljZXModmVydGljZXMpO1xyXG4gICAgICAgICAgICBpZiAoUmVzb2x2ZVBpbmNoUG9pbnQocGluLCBvdXQgcEEsIG91dCBwQikpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIExpc3Q8VHJpYW5nbGU+IG1lcmdlQSA9IFRyaWFuZ3VsYXRlUG9seWdvbihwQSk7XHJcbiAgICAgICAgICAgICAgICBMaXN0PFRyaWFuZ2xlPiBtZXJnZUIgPSBUcmlhbmd1bGF0ZVBvbHlnb24ocEIpO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmIChtZXJnZUEuQ291bnQgPT0gLTEgfHwgbWVyZ2VCLkNvdW50ID09IC0xKVxyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFeGNlcHRpb24oXCJDYW4ndCB0cmlhbmd1bGF0ZSB5b3VyIHBvbHlnb24uXCIpO1xyXG5cclxuICAgICAgICAgICAgICAgIGZvciAoaW50IGkgPSAwOyBpIDwgbWVyZ2VBLkNvdW50OyArK2kpXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0cy5BZGQobmV3IFRyaWFuZ2xlKG1lcmdlQVtpXSkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZm9yIChpbnQgaSA9IDA7IGkgPCBtZXJnZUIuQ291bnQ7ICsraSlcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICByZXN1bHRzLkFkZChuZXcgVHJpYW5nbGUobWVyZ2VCW2ldKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdHM7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIFRyaWFuZ2xlW10gYnVmZmVyID0gbmV3IFRyaWFuZ2xlW3ZlcnRpY2VzLkNvdW50IC0gMl07XHJcbiAgICAgICAgICAgIGludCBidWZmZXJTaXplID0gMDtcclxuICAgICAgICAgICAgZmxvYXRbXSB4cmVtID0gbmV3IGZsb2F0W3ZlcnRpY2VzLkNvdW50XTtcclxuICAgICAgICAgICAgZmxvYXRbXSB5cmVtID0gbmV3IGZsb2F0W3ZlcnRpY2VzLkNvdW50XTtcclxuICAgICAgICAgICAgZm9yIChpbnQgaSA9IDA7IGkgPCB2ZXJ0aWNlcy5Db3VudDsgKytpKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB4cmVtW2ldID0gdmVydGljZXNbaV0uWDtcclxuICAgICAgICAgICAgICAgIHlyZW1baV0gPSB2ZXJ0aWNlc1tpXS5ZO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpbnQgdk51bSA9IHZlcnRpY2VzLkNvdW50O1xyXG5cclxuICAgICAgICAgICAgd2hpbGUgKHZOdW0gPiAzKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAvLyBGaW5kIGFuIGVhclxyXG4gICAgICAgICAgICAgICAgaW50IGVhckluZGV4ID0gLTE7XHJcbiAgICAgICAgICAgICAgICBmbG9hdCBlYXJNYXhNaW5Dcm9zcyA9IC0xMC4wZjtcclxuICAgICAgICAgICAgICAgIGZvciAoaW50IGkgPSAwOyBpIDwgdk51bTsgKytpKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChJc0VhcihpLCB4cmVtLCB5cmVtLCB2TnVtKSlcclxuICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGludCBsb3dlciA9IFJlbWFpbmRlcihpIC0gMSwgdk51bSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGludCB1cHBlciA9IFJlbWFpbmRlcihpICsgMSwgdk51bSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIFZlY3RvcjIgZDEgPSBuZXcgVmVjdG9yMih4cmVtW3VwcGVyXSAtIHhyZW1baV0sIHlyZW1bdXBwZXJdIC0geXJlbVtpXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIFZlY3RvcjIgZDIgPSBuZXcgVmVjdG9yMih4cmVtW2ldIC0geHJlbVtsb3dlcl0sIHlyZW1baV0gLSB5cmVtW2xvd2VyXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIFZlY3RvcjIgZDMgPSBuZXcgVmVjdG9yMih4cmVtW2xvd2VyXSAtIHhyZW1bdXBwZXJdLCB5cmVtW2xvd2VyXSAtIHlyZW1bdXBwZXJdKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGQxLk5vcm1hbGl6ZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBkMi5Ob3JtYWxpemUoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZDMuTm9ybWFsaXplKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZsb2F0IGNyb3NzMTI7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIE1hdGhVdGlscy5Dcm9zcyhyZWYgZDEsIHJlZiBkMiwgb3V0IGNyb3NzMTIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjcm9zczEyID0gKGZsb2F0KU1hdGguQWJzKGNyb3NzMTIpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgZmxvYXQgY3Jvc3MyMztcclxuICAgICAgICAgICAgICAgICAgICAgICAgTWF0aFV0aWxzLkNyb3NzKHJlZiBkMiwgcmVmIGQzLCBvdXQgY3Jvc3MyMyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNyb3NzMjMgPSAoZmxvYXQpTWF0aC5BYnMoY3Jvc3MyMyk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBmbG9hdCBjcm9zczMxO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBNYXRoVXRpbHMuQ3Jvc3MocmVmIGQzLCByZWYgZDEsIG91dCBjcm9zczMxKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY3Jvc3MzMSA9IChmbG9hdClNYXRoLkFicyhjcm9zczMxKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vRmluZCB0aGUgbWF4aW11bSBtaW5pbXVtIGFuZ2xlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZsb2F0IG1pbkNyb3NzID0gTWF0aC5NaW4oY3Jvc3MxMiwgTWF0aC5NaW4oY3Jvc3MyMywgY3Jvc3MzMSkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobWluQ3Jvc3MgPiBlYXJNYXhNaW5Dcm9zcylcclxuICAgICAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWFySW5kZXggPSBpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWFyTWF4TWluQ3Jvc3MgPSBtaW5Dcm9zcztcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAvLyBJZiB3ZSBzdGlsbCBoYXZlbid0IGZvdW5kIGFuIGVhciwgd2UncmUgc2NyZXdlZC5cclxuICAgICAgICAgICAgICAgIC8vIE5vdGU6IHNvbWV0aW1lcyB0aGlzIGlzIGhhcHBlbmluZyBiZWNhdXNlIHRoZVxyXG4gICAgICAgICAgICAgICAgLy8gcmVtYWluaW5nIHBvaW50cyBhcmUgY29sbGluZWFyLiAgUmVhbGx5IHRoZXNlXHJcbiAgICAgICAgICAgICAgICAvLyBzaG91bGQganVzdCBiZSB0aHJvd24gb3V0IHdpdGhvdXQgaGFsdGluZyB0cmlhbmd1bGF0aW9uLlxyXG4gICAgICAgICAgICAgICAgaWYgKGVhckluZGV4ID09IC0xKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIGZvciAoaW50IGkgPSAwOyBpIDwgYnVmZmVyU2l6ZTsgaSsrKVxyXG4gICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0cy5BZGQobmV3IFRyaWFuZ2xlKGJ1ZmZlcltpXSkpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdHM7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gQ2xpcCBvZmYgdGhlIGVhcjpcclxuICAgICAgICAgICAgICAgIC8vIC0gcmVtb3ZlIHRoZSBlYXIgdGlwIGZyb20gdGhlIGxpc3RcclxuXHJcbiAgICAgICAgICAgICAgICAtLXZOdW07XHJcbiAgICAgICAgICAgICAgICBmbG9hdFtdIG5ld3ggPSBuZXcgZmxvYXRbdk51bV07XHJcbiAgICAgICAgICAgICAgICBmbG9hdFtdIG5ld3kgPSBuZXcgZmxvYXRbdk51bV07XHJcbiAgICAgICAgICAgICAgICBpbnQgY3VyckRlc3QgPSAwO1xyXG4gICAgICAgICAgICAgICAgZm9yIChpbnQgaSA9IDA7IGkgPCB2TnVtOyArK2kpXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGN1cnJEZXN0ID09IGVhckluZGV4KSArK2N1cnJEZXN0O1xyXG4gICAgICAgICAgICAgICAgICAgIG5ld3hbaV0gPSB4cmVtW2N1cnJEZXN0XTtcclxuICAgICAgICAgICAgICAgICAgICBuZXd5W2ldID0geXJlbVtjdXJyRGVzdF07XHJcbiAgICAgICAgICAgICAgICAgICAgKytjdXJyRGVzdDtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAvLyAtIGFkZCB0aGUgY2xpcHBlZCB0cmlhbmdsZSB0byB0aGUgdHJpYW5nbGUgbGlzdFxyXG4gICAgICAgICAgICAgICAgaW50IHVuZGVyID0gKGVhckluZGV4ID09IDApID8gKHZOdW0pIDogKGVhckluZGV4IC0gMSk7XHJcbiAgICAgICAgICAgICAgICBpbnQgb3ZlciA9IChlYXJJbmRleCA9PSB2TnVtKSA/IDAgOiAoZWFySW5kZXggKyAxKTtcclxuICAgICAgICAgICAgICAgIFRyaWFuZ2xlIHRvQWRkID0gbmV3IFRyaWFuZ2xlKHhyZW1bZWFySW5kZXhdLCB5cmVtW2VhckluZGV4XSwgeHJlbVtvdmVyXSwgeXJlbVtvdmVyXSwgeHJlbVt1bmRlcl0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB5cmVtW3VuZGVyXSk7XHJcbiAgICAgICAgICAgICAgICBidWZmZXJbYnVmZmVyU2l6ZV0gPSB0b0FkZDtcclxuICAgICAgICAgICAgICAgICsrYnVmZmVyU2l6ZTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyAtIHJlcGxhY2UgdGhlIG9sZCBsaXN0IHdpdGggdGhlIG5ldyBvbmVcclxuICAgICAgICAgICAgICAgIHhyZW0gPSBuZXd4O1xyXG4gICAgICAgICAgICAgICAgeXJlbSA9IG5ld3k7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIFRyaWFuZ2xlIHRvb0FkZCA9IG5ldyBUcmlhbmdsZSh4cmVtWzFdLCB5cmVtWzFdLCB4cmVtWzJdLCB5cmVtWzJdLCB4cmVtWzBdLCB5cmVtWzBdKTtcclxuICAgICAgICAgICAgYnVmZmVyW2J1ZmZlclNpemVdID0gdG9vQWRkO1xyXG4gICAgICAgICAgICArK2J1ZmZlclNpemU7XHJcblxyXG4gICAgICAgICAgICBmb3IgKGludCBpID0gMDsgaSA8IGJ1ZmZlclNpemU7IGkrKylcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0cy5BZGQobmV3IFRyaWFuZ2xlKGJ1ZmZlcltpXSkpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0cztcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gRmluZHMgYW5kIGZpeGVzIFwicGluY2ggcG9pbnRzLFwiIHBvaW50cyB3aGVyZSB0d28gcG9seWdvblxyXG4gICAgICAgIC8vLyB2ZXJ0aWNlcyBhcmUgYXQgdGhlIHNhbWUgcG9pbnQuXHJcbiAgICAgICAgLy8vIFxyXG4gICAgICAgIC8vLyBJZiBhIHBpbmNoIHBvaW50IGlzIGZvdW5kLCBwaW4gaXMgYnJva2VuIHVwIGludG8gcG91dEEgYW5kIHBvdXRCXHJcbiAgICAgICAgLy8vIGFuZCB0cnVlIGlzIHJldHVybmVkOyBvdGhlcndpc2UsIHJldHVybnMgZmFsc2UuXHJcbiAgICAgICAgLy8vIFxyXG4gICAgICAgIC8vLyBNb3N0bHkgZm9yIGludGVybmFsIHVzZS5cclxuICAgICAgICAvLy8gXHJcbiAgICAgICAgLy8vIE8oTl4yKSB0aW1lLCB3aGljaCBzdWNrcy4uLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwicGluXCI+VGhlIHBpbi48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cInBvdXRBXCI+VGhlIHBvdXQgQS48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cInBvdXRCXCI+VGhlIHBvdXQgQi48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cmV0dXJucz48L3JldHVybnM+XHJcbiAgICAgICAgcHJpdmF0ZSBzdGF0aWMgYm9vbCBSZXNvbHZlUGluY2hQb2ludChWZXJ0aWNlcyBwaW4sIG91dCBWZXJ0aWNlcyBwb3V0QSwgb3V0IFZlcnRpY2VzIHBvdXRCKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcG91dEEgPSBuZXcgVmVydGljZXMoKTtcclxuICAgICAgICAgICAgcG91dEIgPSBuZXcgVmVydGljZXMoKTtcclxuXHJcbiAgICAgICAgICAgIGlmIChwaW4uQ291bnQgPCAzKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG5cclxuICAgICAgICAgICAgYm9vbCBoYXNQaW5jaFBvaW50ID0gZmFsc2U7XHJcbiAgICAgICAgICAgIGludCBwaW5jaEluZGV4QSA9IC0xO1xyXG4gICAgICAgICAgICBpbnQgcGluY2hJbmRleEIgPSAtMTtcclxuICAgICAgICAgICAgZm9yIChpbnQgaSA9IDA7IGkgPCBwaW4uQ291bnQ7ICsraSlcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgZm9yIChpbnQgaiA9IGkgKyAxOyBqIDwgcGluLkNvdW50OyArK2opXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy9Eb24ndCB3b3JyeSBhYm91dCBwaW5jaCBwb2ludHMgd2hlcmUgdGhlIHBvaW50c1xyXG4gICAgICAgICAgICAgICAgICAgIC8vYXJlIGFjdHVhbGx5IGp1c3QgZHVwZSBuZWlnaGJvcnNcclxuICAgICAgICAgICAgICAgICAgICBpZiAoTWF0aC5BYnMocGluW2ldLlggLSBwaW5bal0uWCkgPCBUb2wgJiYgTWF0aC5BYnMocGluW2ldLlkgLSBwaW5bal0uWSkgPCBUb2wgJiYgaiAhPSBpICsgMSlcclxuICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBpbmNoSW5kZXhBID0gaTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcGluY2hJbmRleEIgPSBqO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBoYXNQaW5jaFBvaW50ID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKGhhc1BpbmNoUG9pbnQpIGJyZWFrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChoYXNQaW5jaFBvaW50KVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBpbnQgc2l6ZUEgPSBwaW5jaEluZGV4QiAtIHBpbmNoSW5kZXhBO1xyXG4gICAgICAgICAgICAgICAgaWYgKHNpemVBID09IHBpbi5Db3VudCkgcmV0dXJuIGZhbHNlOyAvL2hhcyBkdXBlIHBvaW50cyBhdCB3cmFwYXJvdW5kLCBub3QgYSBwcm9ibGVtIGhlcmVcclxuICAgICAgICAgICAgICAgIGZvciAoaW50IGkgPSAwOyBpIDwgc2l6ZUE7ICsraSlcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBpbnQgaW5kID0gUmVtYWluZGVyKHBpbmNoSW5kZXhBICsgaSwgcGluLkNvdW50KTsgLy8gaXMgdGhpcyByaWdodFxyXG4gICAgICAgICAgICAgICAgICAgIHBvdXRBLkFkZChwaW5baW5kXSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgaW50IHNpemVCID0gcGluLkNvdW50IC0gc2l6ZUE7XHJcbiAgICAgICAgICAgICAgICBmb3IgKGludCBpID0gMDsgaSA8IHNpemVCOyArK2kpXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgaW50IGluZCA9IFJlbWFpbmRlcihwaW5jaEluZGV4QiArIGksIHBpbi5Db3VudCk7IC8vIGlzIHRoaXMgcmlnaHQgICAgXHJcbiAgICAgICAgICAgICAgICAgICAgcG91dEIuQWRkKHBpbltpbmRdKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gaGFzUGluY2hQb2ludDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gRml4IGZvciBvYm5veGlvdXMgYmVoYXZpb3IgZm9yIHRoZSAlIG9wZXJhdG9yIGZvciBuZWdhdGl2ZSBudW1iZXJzLi4uXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJ4XCI+VGhlIHguPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJtb2R1bHVzXCI+VGhlIG1vZHVsdXMuPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHJldHVybnM+PC9yZXR1cm5zPlxyXG4gICAgICAgIHByaXZhdGUgc3RhdGljIGludCBSZW1haW5kZXIoaW50IHgsIGludCBtb2R1bHVzKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgaW50IHJlbSA9IHggJSBtb2R1bHVzO1xyXG4gICAgICAgICAgICB3aGlsZSAocmVtIDwgMClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgcmVtICs9IG1vZHVsdXM7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHJlbTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHByaXZhdGUgc3RhdGljIFZlcnRpY2VzIEFkZFRyaWFuZ2xlKFRyaWFuZ2xlIHQsIFZlcnRpY2VzIHZlcnRpY2VzKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgLy8gRmlyc3QsIGZpbmQgdmVydGljZXMgdGhhdCBjb25uZWN0XHJcbiAgICAgICAgICAgIGludCBmaXJzdFAgPSAtMTtcclxuICAgICAgICAgICAgaW50IGZpcnN0VCA9IC0xO1xyXG4gICAgICAgICAgICBpbnQgc2Vjb25kUCA9IC0xO1xyXG4gICAgICAgICAgICBpbnQgc2Vjb25kVCA9IC0xO1xyXG4gICAgICAgICAgICBmb3IgKGludCBpID0gMDsgaSA8IHZlcnRpY2VzLkNvdW50OyBpKyspXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGlmICh0LlhbMF0gPT0gdmVydGljZXNbaV0uWCAmJiB0LllbMF0gPT0gdmVydGljZXNbaV0uWSlcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoZmlyc3RQID09IC0xKVxyXG4gICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZmlyc3RQID0gaTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZmlyc3RUID0gMDtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2Vjb25kUCA9IGk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlY29uZFQgPSAwO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHQuWFsxXSA9PSB2ZXJ0aWNlc1tpXS5YICYmIHQuWVsxXSA9PSB2ZXJ0aWNlc1tpXS5ZKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChmaXJzdFAgPT0gLTEpXHJcbiAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBmaXJzdFAgPSBpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBmaXJzdFQgPSAxO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzZWNvbmRQID0gaTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2Vjb25kVCA9IDE7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodC5YWzJdID09IHZlcnRpY2VzW2ldLlggJiYgdC5ZWzJdID09IHZlcnRpY2VzW2ldLlkpXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGZpcnN0UCA9PSAtMSlcclxuICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpcnN0UCA9IGk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpcnN0VCA9IDI7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlY29uZFAgPSBpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzZWNvbmRUID0gMjtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gRml4IG9yZGVyaW5nIGlmIGZpcnN0IHNob3VsZCBiZSBsYXN0IHZlcnRleCBvZiBwb2x5XHJcbiAgICAgICAgICAgIGlmIChmaXJzdFAgPT0gMCAmJiBzZWNvbmRQID09IHZlcnRpY2VzLkNvdW50IC0gMSlcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgZmlyc3RQID0gdmVydGljZXMuQ291bnQgLSAxO1xyXG4gICAgICAgICAgICAgICAgc2Vjb25kUCA9IDA7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIERpZG4ndCBmaW5kIGl0XHJcbiAgICAgICAgICAgIGlmIChzZWNvbmRQID09IC0xKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gRmluZCB0aXAgaW5kZXggb24gdHJpYW5nbGVcclxuICAgICAgICAgICAgaW50IHRpcFQgPSAwO1xyXG4gICAgICAgICAgICBpZiAodGlwVCA9PSBmaXJzdFQgfHwgdGlwVCA9PSBzZWNvbmRUKVxyXG4gICAgICAgICAgICAgICAgdGlwVCA9IDE7XHJcbiAgICAgICAgICAgIGlmICh0aXBUID09IGZpcnN0VCB8fCB0aXBUID09IHNlY29uZFQpXHJcbiAgICAgICAgICAgICAgICB0aXBUID0gMjtcclxuXHJcbiAgICAgICAgICAgIFZlcnRpY2VzIHJlc3VsdCA9IG5ldyBWZXJ0aWNlcyh2ZXJ0aWNlcy5Db3VudCArIDEpO1xyXG4gICAgICAgICAgICBmb3IgKGludCBpID0gMDsgaSA8IHZlcnRpY2VzLkNvdW50OyBpKyspXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHJlc3VsdC5BZGQodmVydGljZXNbaV0pO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmIChpID09IGZpcnN0UClcclxuICAgICAgICAgICAgICAgICAgICByZXN1bHQuQWRkKG5ldyBWZWN0b3IyKHQuWFt0aXBUXSwgdC5ZW3RpcFRdKSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIENoZWNrcyBpZiB2ZXJ0ZXggaSBpcyB0aGUgdGlwIG9mIGFuIGVhciBpbiBwb2x5Z29uIGRlZmluZWQgYnkgeHZbXSBhbmRcclxuICAgICAgICAvLy8geXZbXS5cclxuICAgICAgICAvLy9cclxuICAgICAgICAvLy8gQXNzdW1lcyBjbG9ja3dpc2Ugb3JpZW50YXRpb24gb2YgcG9seWdvbi4uLmlja1xyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwiaVwiPlRoZSBpLjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwieHZcIj5UaGUgeHYuPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJ5dlwiPlRoZSB5di48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cInh2TGVuZ3RoXCI+TGVuZ3RoIG9mIHRoZSB4di48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cmV0dXJucz5cclxuICAgICAgICAvLy8gXHQ8Yz50cnVlPC9jPiBpZiB0aGUgc3BlY2lmaWVkIGkgaXMgZWFyOyBvdGhlcndpc2UsIDxjPmZhbHNlPC9jPi5cclxuICAgICAgICAvLy8gPC9yZXR1cm5zPlxyXG4gICAgICAgIHByaXZhdGUgc3RhdGljIGJvb2wgSXNFYXIoaW50IGksIGZsb2F0W10geHYsIGZsb2F0W10geXYsIGludCB4dkxlbmd0aClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGZsb2F0IGR4MCwgZHkwLCBkeDEsIGR5MTtcclxuICAgICAgICAgICAgaWYgKGkgPj0geHZMZW5ndGggfHwgaSA8IDAgfHwgeHZMZW5ndGggPCAzKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaW50IHVwcGVyID0gaSArIDE7XHJcbiAgICAgICAgICAgIGludCBsb3dlciA9IGkgLSAxO1xyXG4gICAgICAgICAgICBpZiAoaSA9PSAwKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBkeDAgPSB4dlswXSAtIHh2W3h2TGVuZ3RoIC0gMV07XHJcbiAgICAgICAgICAgICAgICBkeTAgPSB5dlswXSAtIHl2W3h2TGVuZ3RoIC0gMV07XHJcbiAgICAgICAgICAgICAgICBkeDEgPSB4dlsxXSAtIHh2WzBdO1xyXG4gICAgICAgICAgICAgICAgZHkxID0geXZbMV0gLSB5dlswXTtcclxuICAgICAgICAgICAgICAgIGxvd2VyID0geHZMZW5ndGggLSAxO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGkgPT0geHZMZW5ndGggLSAxKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBkeDAgPSB4dltpXSAtIHh2W2kgLSAxXTtcclxuICAgICAgICAgICAgICAgIGR5MCA9IHl2W2ldIC0geXZbaSAtIDFdO1xyXG4gICAgICAgICAgICAgICAgZHgxID0geHZbMF0gLSB4dltpXTtcclxuICAgICAgICAgICAgICAgIGR5MSA9IHl2WzBdIC0geXZbaV07XHJcbiAgICAgICAgICAgICAgICB1cHBlciA9IDA7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBkeDAgPSB4dltpXSAtIHh2W2kgLSAxXTtcclxuICAgICAgICAgICAgICAgIGR5MCA9IHl2W2ldIC0geXZbaSAtIDFdO1xyXG4gICAgICAgICAgICAgICAgZHgxID0geHZbaSArIDFdIC0geHZbaV07XHJcbiAgICAgICAgICAgICAgICBkeTEgPSB5dltpICsgMV0gLSB5dltpXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBmbG9hdCBjcm9zcyA9IGR4MCAqIGR5MSAtIGR4MSAqIGR5MDtcclxuICAgICAgICAgICAgaWYgKGNyb3NzID4gMClcclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgVHJpYW5nbGUgbXlUcmkgPSBuZXcgVHJpYW5nbGUoeHZbaV0sIHl2W2ldLCB4dlt1cHBlcl0sIHl2W3VwcGVyXSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeHZbbG93ZXJdLCB5dltsb3dlcl0pO1xyXG4gICAgICAgICAgICBmb3IgKGludCBqID0gMDsgaiA8IHh2TGVuZ3RoOyArK2opXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGlmIChqID09IGkgfHwgaiA9PSBsb3dlciB8fCBqID09IHVwcGVyKVxyXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgaWYgKG15VHJpLklzSW5zaWRlKHh2W2pdLCB5dltqXSkpXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgY2xhc3MgVHJpYW5nbGVcclxuICAgIHtcclxuICAgICAgICBwdWJsaWMgZmxvYXRbXSBYO1xyXG4gICAgICAgIHB1YmxpYyBmbG9hdFtdIFk7XHJcblxyXG4gICAgICAgIC8vQ29uc3RydWN0b3IgYXV0b21hdGljYWxseSBmaXhlcyBvcmllbnRhdGlvbiB0byBjY3dcclxuICAgICAgICBwdWJsaWMgVHJpYW5nbGUoZmxvYXQgeDEsIGZsb2F0IHkxLCBmbG9hdCB4MiwgZmxvYXQgeTIsIGZsb2F0IHgzLCBmbG9hdCB5MylcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIFggPSBuZXcgZmxvYXRbM107XHJcbiAgICAgICAgICAgIFkgPSBuZXcgZmxvYXRbM107XHJcbiAgICAgICAgICAgIGZsb2F0IGR4MSA9IHgyIC0geDE7XHJcbiAgICAgICAgICAgIGZsb2F0IGR4MiA9IHgzIC0geDE7XHJcbiAgICAgICAgICAgIGZsb2F0IGR5MSA9IHkyIC0geTE7XHJcbiAgICAgICAgICAgIGZsb2F0IGR5MiA9IHkzIC0geTE7XHJcbiAgICAgICAgICAgIGZsb2F0IGNyb3NzID0gZHgxICogZHkyIC0gZHgyICogZHkxO1xyXG4gICAgICAgICAgICBib29sIGNjdyA9IChjcm9zcyA+IDApO1xyXG4gICAgICAgICAgICBpZiAoY2N3KVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBYWzBdID0geDE7XHJcbiAgICAgICAgICAgICAgICBYWzFdID0geDI7XHJcbiAgICAgICAgICAgICAgICBYWzJdID0geDM7XHJcbiAgICAgICAgICAgICAgICBZWzBdID0geTE7XHJcbiAgICAgICAgICAgICAgICBZWzFdID0geTI7XHJcbiAgICAgICAgICAgICAgICBZWzJdID0geTM7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBYWzBdID0geDE7XHJcbiAgICAgICAgICAgICAgICBYWzFdID0geDM7XHJcbiAgICAgICAgICAgICAgICBYWzJdID0geDI7XHJcbiAgICAgICAgICAgICAgICBZWzBdID0geTE7XHJcbiAgICAgICAgICAgICAgICBZWzFdID0geTM7XHJcbiAgICAgICAgICAgICAgICBZWzJdID0geTI7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHB1YmxpYyBUcmlhbmdsZShUcmlhbmdsZSB0KVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgWCA9IG5ldyBmbG9hdFszXTtcclxuICAgICAgICAgICAgWSA9IG5ldyBmbG9hdFszXTtcclxuXHJcbiAgICAgICAgICAgIFhbMF0gPSB0LlhbMF07XHJcbiAgICAgICAgICAgIFhbMV0gPSB0LlhbMV07XHJcbiAgICAgICAgICAgIFhbMl0gPSB0LlhbMl07XHJcbiAgICAgICAgICAgIFlbMF0gPSB0LllbMF07XHJcbiAgICAgICAgICAgIFlbMV0gPSB0LllbMV07XHJcbiAgICAgICAgICAgIFlbMl0gPSB0LllbMl07XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwdWJsaWMgYm9vbCBJc0luc2lkZShmbG9hdCB4LCBmbG9hdCB5KVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgaWYgKHggPCBYWzBdICYmIHggPCBYWzFdICYmIHggPCBYWzJdKSByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgIGlmICh4ID4gWFswXSAmJiB4ID4gWFsxXSAmJiB4ID4gWFsyXSkgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICBpZiAoeSA8IFlbMF0gJiYgeSA8IFlbMV0gJiYgeSA8IFlbMl0pIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgaWYgKHkgPiBZWzBdICYmIHkgPiBZWzFdICYmIHkgPiBZWzJdKSByZXR1cm4gZmFsc2U7XHJcblxyXG4gICAgICAgICAgICBmbG9hdCB2eDIgPSB4IC0gWFswXTtcclxuICAgICAgICAgICAgZmxvYXQgdnkyID0geSAtIFlbMF07XHJcbiAgICAgICAgICAgIGZsb2F0IHZ4MSA9IFhbMV0gLSBYWzBdO1xyXG4gICAgICAgICAgICBmbG9hdCB2eTEgPSBZWzFdIC0gWVswXTtcclxuICAgICAgICAgICAgZmxvYXQgdngwID0gWFsyXSAtIFhbMF07XHJcbiAgICAgICAgICAgIGZsb2F0IHZ5MCA9IFlbMl0gLSBZWzBdO1xyXG5cclxuICAgICAgICAgICAgZmxvYXQgZG90MDAgPSB2eDAgKiB2eDAgKyB2eTAgKiB2eTA7XHJcbiAgICAgICAgICAgIGZsb2F0IGRvdDAxID0gdngwICogdngxICsgdnkwICogdnkxO1xyXG4gICAgICAgICAgICBmbG9hdCBkb3QwMiA9IHZ4MCAqIHZ4MiArIHZ5MCAqIHZ5MjtcclxuICAgICAgICAgICAgZmxvYXQgZG90MTEgPSB2eDEgKiB2eDEgKyB2eTEgKiB2eTE7XHJcbiAgICAgICAgICAgIGZsb2F0IGRvdDEyID0gdngxICogdngyICsgdnkxICogdnkyO1xyXG4gICAgICAgICAgICBmbG9hdCBpbnZEZW5vbSA9IDEuMGYgLyAoZG90MDAgKiBkb3QxMSAtIGRvdDAxICogZG90MDEpO1xyXG4gICAgICAgICAgICBmbG9hdCB1ID0gKGRvdDExICogZG90MDIgLSBkb3QwMSAqIGRvdDEyKSAqIGludkRlbm9tO1xyXG4gICAgICAgICAgICBmbG9hdCB2ID0gKGRvdDAwICogZG90MTIgLSBkb3QwMSAqIGRvdDAyKSAqIGludkRlbm9tO1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuICgodSA+IDApICYmICh2ID4gMCkgJiYgKHUgKyB2IDwgMSkpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufSIsInVzaW5nIFN5c3RlbTtcclxudXNpbmcgU3lzdGVtLkNvbGxlY3Rpb25zLkdlbmVyaWM7XHJcbnVzaW5nIFN5c3RlbS5EaWFnbm9zdGljcztcclxudXNpbmcgTWljcm9zb2Z0LlhuYS5GcmFtZXdvcms7XHJcblxyXG5uYW1lc3BhY2UgRmFyc2VlclBoeXNpY3MuQ29tbW9uLkRlY29tcG9zaXRpb25cclxue1xyXG4gICAgLy9Gcm9tIHRoZSBQb2x5MlRyaSBwcm9qZWN0IGJ5IE1hc29uIEdyZWVuOiBodHRwOi8vY29kZS5nb29nbGUuY29tL3AvcG9seTJ0cmkvc291cmNlL2Jyb3dzZT9yZXBvPWFyY2hpdmUjaGcvc2NhbGEvc3JjL29yZy9wb2x5MnRyaS9zZWlkZWxcclxuXHJcbiAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAvLy8gQ29udmV4IGRlY29tcG9zaXRpb24gYWxnb3JpdGhtIGJhc2VkIG9uIFJhaW11bmQgU2VpZGVsJ3MgcGFwZXIgXCJBIHNpbXBsZSBhbmQgZmFzdCBpbmNyZW1lbnRhbCByYW5kb21pemVkXHJcbiAgICAvLy8gYWxnb3JpdGhtIGZvciBjb21wdXRpbmcgdHJhcGV6b2lkYWwgZGVjb21wb3NpdGlvbnMgYW5kIGZvciB0cmlhbmd1bGF0aW5nIHBvbHlnb25zXCJcclxuICAgIC8vLyBTZWUgYWxzbzogXCJDb21wdXRhdGlvbmFsIEdlb21ldHJ5XCIsIDNyZCBlZGl0aW9uLCBieSBNYXJrIGRlIEJlcmcgZXQgYWwsIENoYXB0ZXIgNi4yXHJcbiAgICAvLy8gICAgICAgICAgIFwiQ29tcHV0YXRpb25hbCBHZW9tZXRyeSBpbiBDXCIsIDJuZCBlZGl0aW9uLCBieSBKb3NlcGggTydSb3Vya2VcclxuICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICBwdWJsaWMgc3RhdGljIGNsYXNzIFNlaWRlbERlY29tcG9zZXJcclxuICAgIHtcclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIERlY29tcG9zZSB0aGUgcG9seWdvbiBpbnRvIHNldmVyYWwgc21hbGxlciBub24tY29uY2F2ZSBwb2x5Z29uLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwidmVydGljZXNcIj5UaGUgcG9seWdvbiB0byBkZWNvbXBvc2UuPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJzaGVlclwiPlRoZSBzaGVlciB0byB1c2UuIElmIHlvdSBnZXQgYmFkIHJlc3VsdHMsIHRyeSB1c2luZyBhIGhpZ2hlciB2YWx1ZS4gVGhlIGRlZmF1bHQgdmFsdWUgaXMgMC4wMDE8L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cmV0dXJucz5BIGxpc3Qgb2YgdHJpYW5nbGVzPC9yZXR1cm5zPlxyXG4gICAgICAgIHB1YmxpYyBzdGF0aWMgTGlzdDxWZXJ0aWNlcz4gQ29udmV4UGFydGl0aW9uKFZlcnRpY2VzIHZlcnRpY2VzLCBmbG9hdCBzaGVlcilcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIExpc3Q8UG9pbnQ+IGNvbXBhdExpc3QgPSBuZXcgTGlzdDxQb2ludD4odmVydGljZXMuQ291bnQpO1xyXG5cclxuICAgICAgICAgICAgZm9yZWFjaCAoVmVjdG9yMiB2ZXJ0ZXggaW4gdmVydGljZXMpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGNvbXBhdExpc3QuQWRkKG5ldyBQb2ludCh2ZXJ0ZXguWCwgdmVydGV4LlkpKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgVHJpYW5ndWxhdG9yIHQgPSBuZXcgVHJpYW5ndWxhdG9yKGNvbXBhdExpc3QsIHNoZWVyKTtcclxuXHJcbiAgICAgICAgICAgIExpc3Q8VmVydGljZXM+IGxpc3QgPSBuZXcgTGlzdDxWZXJ0aWNlcz4oKTtcclxuXHJcbiAgICAgICAgICAgIGZvcmVhY2ggKExpc3Q8UG9pbnQ+IHRyaWFuZ2xlIGluIHQuVHJpYW5nbGVzKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBWZXJ0aWNlcyB2ZXJ0cyA9IG5ldyBWZXJ0aWNlcyh0cmlhbmdsZS5Db3VudCk7XHJcblxyXG4gICAgICAgICAgICAgICAgZm9yZWFjaCAoUG9pbnQgcG9pbnQgaW4gdHJpYW5nbGUpXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmVydHMuQWRkKG5ldyBWZWN0b3IyKHBvaW50LlgsIHBvaW50LlkpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBsaXN0LkFkZCh2ZXJ0cyk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHJldHVybiBsaXN0O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBEZWNvbXBvc2UgdGhlIHBvbHlnb24gaW50byBzZXZlcmFsIHNtYWxsZXIgbm9uLWNvbmNhdmUgcG9seWdvbi5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cInZlcnRpY2VzXCI+VGhlIHBvbHlnb24gdG8gZGVjb21wb3NlLjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwic2hlZXJcIj5UaGUgc2hlZXIgdG8gdXNlLiBJZiB5b3UgZ2V0IGJhZCByZXN1bHRzLCB0cnkgdXNpbmcgYSBoaWdoZXIgdmFsdWUuIFRoZSBkZWZhdWx0IHZhbHVlIGlzIDAuMDAxPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHJldHVybnM+QSBsaXN0IG9mIHRyYXBlem9pZHM8L3JldHVybnM+XHJcbiAgICAgICAgcHVibGljIHN0YXRpYyBMaXN0PFZlcnRpY2VzPiBDb252ZXhQYXJ0aXRpb25UcmFwZXpvaWQoVmVydGljZXMgdmVydGljZXMsIGZsb2F0IHNoZWVyKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgTGlzdDxQb2ludD4gY29tcGF0TGlzdCA9IG5ldyBMaXN0PFBvaW50Pih2ZXJ0aWNlcy5Db3VudCk7XHJcblxyXG4gICAgICAgICAgICBmb3JlYWNoIChWZWN0b3IyIHZlcnRleCBpbiB2ZXJ0aWNlcylcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgY29tcGF0TGlzdC5BZGQobmV3IFBvaW50KHZlcnRleC5YLCB2ZXJ0ZXguWSkpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBUcmlhbmd1bGF0b3IgdCA9IG5ldyBUcmlhbmd1bGF0b3IoY29tcGF0TGlzdCwgc2hlZXIpO1xyXG5cclxuICAgICAgICAgICAgTGlzdDxWZXJ0aWNlcz4gbGlzdCA9IG5ldyBMaXN0PFZlcnRpY2VzPigpO1xyXG5cclxuICAgICAgICAgICAgZm9yZWFjaCAoVHJhcGV6b2lkIHRyYXBlem9pZCBpbiB0LlRyYXBlem9pZHMpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIFZlcnRpY2VzIHZlcnRzID0gbmV3IFZlcnRpY2VzKCk7XHJcblxyXG4gICAgICAgICAgICAgICAgTGlzdDxQb2ludD4gcG9pbnRzID0gdHJhcGV6b2lkLlZlcnRpY2VzKCk7XHJcbiAgICAgICAgICAgICAgICBmb3JlYWNoIChQb2ludCBwb2ludCBpbiBwb2ludHMpXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmVydHMuQWRkKG5ldyBWZWN0b3IyKHBvaW50LlgsIHBvaW50LlkpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBsaXN0LkFkZCh2ZXJ0cyk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHJldHVybiBsaXN0O1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBpbnRlcm5hbCBjbGFzcyBNb25vdG9uZU1vdW50YWluXHJcbiAgICB7XHJcbiAgICAgICAgcHJpdmF0ZSBjb25zdCBmbG9hdCBQaVNsb3AgPSAzLjFmO1xyXG4gICAgICAgIHB1YmxpYyBMaXN0PExpc3Q8UG9pbnQ+PiBUcmlhbmdsZXM7XHJcbiAgICAgICAgcHJpdmF0ZSBIYXNoU2V0PFBvaW50PiBfY29udmV4UG9pbnRzO1xyXG4gICAgICAgIHByaXZhdGUgUG9pbnQgX2hlYWQ7XHJcblxyXG4gICAgICAgIC8vIE1vbm90b25lIG1vdW50YWluIHBvaW50c1xyXG4gICAgICAgIHByaXZhdGUgTGlzdDxQb2ludD4gX21vbm9Qb2x5O1xyXG5cclxuICAgICAgICAvLyBUcmlhbmdsZXMgdGhhdCBjb25zdGl0dXRlIHRoZSBtb3VudGFpblxyXG5cclxuICAgICAgICAvLyBVc2VkIHRvIHRyYWNrIHdoaWNoIHNpZGUgb2YgdGhlIGxpbmUgd2UgYXJlIG9uXHJcbiAgICAgICAgcHJpdmF0ZSBib29sIF9wb3NpdGl2ZTtcclxuICAgICAgICBwcml2YXRlIGludCBfc2l6ZTtcclxuICAgICAgICBwcml2YXRlIFBvaW50IF90YWlsO1xyXG5cclxuICAgICAgICAvLyBBbG1vc3QgUGkhXHJcblxyXG4gICAgICAgIHB1YmxpYyBNb25vdG9uZU1vdW50YWluKClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIF9zaXplID0gMDtcclxuICAgICAgICAgICAgX3RhaWwgPSBudWxsO1xyXG4gICAgICAgICAgICBfaGVhZCA9IG51bGw7XHJcbiAgICAgICAgICAgIF9wb3NpdGl2ZSA9IGZhbHNlO1xyXG4gICAgICAgICAgICBfY29udmV4UG9pbnRzID0gbmV3IEhhc2hTZXQ8UG9pbnQ+KCk7XHJcbiAgICAgICAgICAgIF9tb25vUG9seSA9IG5ldyBMaXN0PFBvaW50PigpO1xyXG4gICAgICAgICAgICBUcmlhbmdsZXMgPSBuZXcgTGlzdDxMaXN0PFBvaW50Pj4oKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIEFwcGVuZCBhIHBvaW50IHRvIHRoZSBsaXN0XHJcbiAgICAgICAgcHVibGljIHZvaWQgQWRkKFBvaW50IHBvaW50KVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgaWYgKF9zaXplID09IDApXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIF9oZWFkID0gcG9pbnQ7XHJcbiAgICAgICAgICAgICAgICBfc2l6ZSA9IDE7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoX3NpemUgPT0gMSlcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgLy8gS2VlcCByZXBlYXQgcG9pbnRzIG91dCBvZiB0aGUgbGlzdFxyXG4gICAgICAgICAgICAgICAgX3RhaWwgPSBwb2ludDtcclxuICAgICAgICAgICAgICAgIF90YWlsLlByZXYgPSBfaGVhZDtcclxuICAgICAgICAgICAgICAgIF9oZWFkLk5leHQgPSBfdGFpbDtcclxuICAgICAgICAgICAgICAgIF9zaXplID0gMjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIC8vIEtlZXAgcmVwZWF0IHBvaW50cyBvdXQgb2YgdGhlIGxpc3RcclxuICAgICAgICAgICAgICAgIF90YWlsLk5leHQgPSBwb2ludDtcclxuICAgICAgICAgICAgICAgIHBvaW50LlByZXYgPSBfdGFpbDtcclxuICAgICAgICAgICAgICAgIF90YWlsID0gcG9pbnQ7XHJcbiAgICAgICAgICAgICAgICBfc2l6ZSArPSAxO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBSZW1vdmUgYSBwb2ludCBmcm9tIHRoZSBsaXN0XHJcbiAgICAgICAgcHVibGljIHZvaWQgUmVtb3ZlKFBvaW50IHBvaW50KVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgUG9pbnQgbmV4dCA9IHBvaW50Lk5leHQ7XHJcbiAgICAgICAgICAgIFBvaW50IHByZXYgPSBwb2ludC5QcmV2O1xyXG4gICAgICAgICAgICBwb2ludC5QcmV2Lk5leHQgPSBuZXh0O1xyXG4gICAgICAgICAgICBwb2ludC5OZXh0LlByZXYgPSBwcmV2O1xyXG4gICAgICAgICAgICBfc2l6ZSAtPSAxO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gUGFydGl0aW9uIGEgeC1tb25vdG9uZSBtb3VudGFpbiBpbnRvIHRyaWFuZ2xlcyBPKG4pXHJcbiAgICAgICAgLy8gU2VlIFwiQ29tcHV0YXRpb25hbCBHZW9tZXRyeSBpbiBDXCIsIDJuZCBlZGl0aW9uLCBieSBKb3NlcGggTydSb3Vya2UsIHBhZ2UgNTJcclxuICAgICAgICBwdWJsaWMgdm9pZCBQcm9jZXNzKClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIC8vIEVzdGFibGlzaCB0aGUgcHJvcGVyIHNpZ25cclxuICAgICAgICAgICAgX3Bvc2l0aXZlID0gQW5nbGVTaWduKCk7XHJcbiAgICAgICAgICAgIC8vIGNyZWF0ZSBtb25vdG9uZSBwb2x5Z29uIC0gZm9yIGR1YnVnIHB1cnBvc2VzXHJcbiAgICAgICAgICAgIEdlbk1vbm9Qb2x5KCk7XHJcblxyXG4gICAgICAgICAgICAvLyBJbml0aWFsaXplIGludGVybmFsIGFuZ2xlcyBhdCBlYWNoIG5vbmJhc2UgdmVydGV4XHJcbiAgICAgICAgICAgIC8vIExpbmsgc3RyaWN0bHkgY29udmV4IHZlcnRpY2VzIGludG8gYSBsaXN0LCBpZ25vcmUgcmVmbGV4IHZlcnRpY2VzXHJcbiAgICAgICAgICAgIFBvaW50IHAgPSBfaGVhZC5OZXh0O1xyXG4gICAgICAgICAgICB3aGlsZSAocC5OZXEoX3RhaWwpKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBmbG9hdCBhID0gQW5nbGUocCk7XHJcbiAgICAgICAgICAgICAgICAvLyBJZiB0aGUgcG9pbnQgaXMgYWxtb3N0IGNvbGluZWFyIHdpdGggaXQncyBuZWlnaGJvciwgcmVtb3ZlIGl0IVxyXG4gICAgICAgICAgICAgICAgaWYgKGEgPj0gUGlTbG9wIHx8IGEgPD0gLVBpU2xvcCB8fCBhID09IDAuMClcclxuICAgICAgICAgICAgICAgICAgICBSZW1vdmUocCk7XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChJc0NvbnZleChwKSlcclxuICAgICAgICAgICAgICAgICAgICBfY29udmV4UG9pbnRzLkFkZChwKTtcclxuICAgICAgICAgICAgICAgIHAgPSBwLk5leHQ7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIFRyaWFuZ3VsYXRlKCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwcml2YXRlIHZvaWQgVHJpYW5ndWxhdGUoKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgd2hpbGUgKF9jb252ZXhQb2ludHMuQ291bnQgIT0gMClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgSUVudW1lcmF0b3I8UG9pbnQ+IGUgPSBfY29udmV4UG9pbnRzLkdldEVudW1lcmF0b3IoKTtcclxuICAgICAgICAgICAgICAgIGUuTW92ZU5leHQoKTtcclxuICAgICAgICAgICAgICAgIFBvaW50IGVhciA9IGUuQ3VycmVudDtcclxuXHJcbiAgICAgICAgICAgICAgICBfY29udmV4UG9pbnRzLlJlbW92ZShlYXIpO1xyXG4gICAgICAgICAgICAgICAgUG9pbnQgYSA9IGVhci5QcmV2O1xyXG4gICAgICAgICAgICAgICAgUG9pbnQgYiA9IGVhcjtcclxuICAgICAgICAgICAgICAgIFBvaW50IGMgPSBlYXIuTmV4dDtcclxuICAgICAgICAgICAgICAgIExpc3Q8UG9pbnQ+IHRyaWFuZ2xlID0gbmV3IExpc3Q8UG9pbnQ+KDMpO1xyXG4gICAgICAgICAgICAgICAgdHJpYW5nbGUuQWRkKGEpO1xyXG4gICAgICAgICAgICAgICAgdHJpYW5nbGUuQWRkKGIpO1xyXG4gICAgICAgICAgICAgICAgdHJpYW5nbGUuQWRkKGMpO1xyXG5cclxuICAgICAgICAgICAgICAgIFRyaWFuZ2xlcy5BZGQodHJpYW5nbGUpO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIFJlbW92ZSBlYXIsIHVwZGF0ZSBhbmdsZXMgYW5kIGNvbnZleCBsaXN0XHJcbiAgICAgICAgICAgICAgICBSZW1vdmUoZWFyKTtcclxuICAgICAgICAgICAgICAgIGlmIChWYWxpZChhKSlcclxuICAgICAgICAgICAgICAgICAgICBfY29udmV4UG9pbnRzLkFkZChhKTtcclxuICAgICAgICAgICAgICAgIGlmIChWYWxpZChjKSlcclxuICAgICAgICAgICAgICAgICAgICBfY29udmV4UG9pbnRzLkFkZChjKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgRGVidWcuQXNzZXJ0KF9zaXplIDw9IDMsIFwiVHJpYW5ndWxhdGlvbiBidWcsIHBsZWFzZSByZXBvcnRcIik7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwcml2YXRlIGJvb2wgVmFsaWQoUG9pbnQgcClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiBwLk5lcShfaGVhZCkgJiYgcC5OZXEoX3RhaWwpICYmIElzQ29udmV4KHApO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gQ3JlYXRlIHRoZSBtb25vdG9uZSBwb2x5Z29uXHJcbiAgICAgICAgcHJpdmF0ZSB2b2lkIEdlbk1vbm9Qb2x5KClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIFBvaW50IHAgPSBfaGVhZDtcclxuICAgICAgICAgICAgd2hpbGUgKHAgIT0gbnVsbClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgX21vbm9Qb2x5LkFkZChwKTtcclxuICAgICAgICAgICAgICAgIHAgPSBwLk5leHQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHByaXZhdGUgZmxvYXQgQW5nbGUoUG9pbnQgcClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIFBvaW50IGEgPSAocC5OZXh0IC0gcCk7XHJcbiAgICAgICAgICAgIFBvaW50IGIgPSAocC5QcmV2IC0gcCk7XHJcbiAgICAgICAgICAgIHJldHVybiAoZmxvYXQpTWF0aC5BdGFuMihhLkNyb3NzKGIpLCBhLkRvdChiKSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwcml2YXRlIGJvb2wgQW5nbGVTaWduKClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIFBvaW50IGEgPSAoX2hlYWQuTmV4dCAtIF9oZWFkKTtcclxuICAgICAgICAgICAgUG9pbnQgYiA9IChfdGFpbCAtIF9oZWFkKTtcclxuICAgICAgICAgICAgcmV0dXJuIE1hdGguQXRhbjIoYS5Dcm9zcyhiKSwgYS5Eb3QoYikpID49IDA7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBEZXRlcm1pbmVzIGlmIHRoZSBpbnNsaWRlIGFuZ2xlIGlzIGNvbnZleCBvciByZWZsZXhcclxuICAgICAgICBwcml2YXRlIGJvb2wgSXNDb252ZXgoUG9pbnQgcClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGlmIChfcG9zaXRpdmUgIT0gKEFuZ2xlKHApID49IDApKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLy8gTm9kZSBmb3IgYSBEaXJlY3RlZCBBY3ljbGljIGdyYXBoIChEQUcpXHJcbiAgICBpbnRlcm5hbCBhYnN0cmFjdCBjbGFzcyBOb2RlXHJcbiAgICB7XHJcbiAgICAgICAgcHJvdGVjdGVkIE5vZGUgTGVmdENoaWxkO1xyXG4gICAgICAgIHB1YmxpYyBMaXN0PE5vZGU+IFBhcmVudExpc3Q7XHJcbiAgICAgICAgcHJvdGVjdGVkIE5vZGUgUmlnaHRDaGlsZDtcclxuXHJcbiAgICAgICAgcHJvdGVjdGVkIE5vZGUoTm9kZSBsZWZ0LCBOb2RlIHJpZ2h0KVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgUGFyZW50TGlzdCA9IG5ldyBMaXN0PE5vZGU+KCk7XHJcbiAgICAgICAgICAgIExlZnRDaGlsZCA9IGxlZnQ7XHJcbiAgICAgICAgICAgIFJpZ2h0Q2hpbGQgPSByaWdodDtcclxuXHJcbiAgICAgICAgICAgIGlmIChsZWZ0ICE9IG51bGwpXHJcbiAgICAgICAgICAgICAgICBsZWZ0LlBhcmVudExpc3QuQWRkKHRoaXMpO1xyXG4gICAgICAgICAgICBpZiAocmlnaHQgIT0gbnVsbClcclxuICAgICAgICAgICAgICAgIHJpZ2h0LlBhcmVudExpc3QuQWRkKHRoaXMpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHVibGljIGFic3RyYWN0IFNpbmsgTG9jYXRlKEVkZ2Ugcyk7XHJcblxyXG4gICAgICAgIC8vIFJlcGxhY2UgYSBub2RlIGluIHRoZSBncmFwaCB3aXRoIHRoaXMgbm9kZVxyXG4gICAgICAgIC8vIE1ha2Ugc3VyZSBwYXJlbnQgcG9pbnRlcnMgYXJlIHVwZGF0ZWRcclxuICAgICAgICBwdWJsaWMgdm9pZCBSZXBsYWNlKE5vZGUgbm9kZSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGZvcmVhY2ggKE5vZGUgcGFyZW50IGluIG5vZGUuUGFyZW50TGlzdClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgLy8gU2VsZWN0IHRoZSBjb3JyZWN0IG5vZGUgdG8gcmVwbGFjZSAobGVmdCBvciByaWdodCBjaGlsZClcclxuICAgICAgICAgICAgICAgIGlmIChwYXJlbnQuTGVmdENoaWxkID09IG5vZGUpXHJcbiAgICAgICAgICAgICAgICAgICAgcGFyZW50LkxlZnRDaGlsZCA9IHRoaXM7XHJcbiAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICAgICAgcGFyZW50LlJpZ2h0Q2hpbGQgPSB0aGlzO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIFBhcmVudExpc3QuQWRkUmFuZ2Uobm9kZS5QYXJlbnRMaXN0KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLy8gRGlyZWN0ZWQgQWN5Y2xpYyBncmFwaCAoREFHKVxyXG4gICAgLy8gU2VlIFwiQ29tcHV0YXRpb25hbCBHZW9tZXRyeVwiLCAzcmQgZWRpdGlvbiwgYnkgTWFyayBkZSBCZXJnIGV0IGFsLCBDaGFwdGVyIDYuMlxyXG4gICAgaW50ZXJuYWwgY2xhc3MgUXVlcnlHcmFwaFxyXG4gICAge1xyXG4gICAgICAgIHByaXZhdGUgTm9kZSBfaGVhZDtcclxuXHJcbiAgICAgICAgcHVibGljIFF1ZXJ5R3JhcGgoTm9kZSBoZWFkKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgX2hlYWQgPSBoZWFkO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHJpdmF0ZSBUcmFwZXpvaWQgTG9jYXRlKEVkZ2UgZWRnZSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiBfaGVhZC5Mb2NhdGUoZWRnZSkuVHJhcGV6b2lkO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHVibGljIExpc3Q8VHJhcGV6b2lkPiBGb2xsb3dFZGdlKEVkZ2UgZWRnZSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIExpc3Q8VHJhcGV6b2lkPiB0cmFwZXpvaWRzID0gbmV3IExpc3Q8VHJhcGV6b2lkPigpO1xyXG4gICAgICAgICAgICB0cmFwZXpvaWRzLkFkZChMb2NhdGUoZWRnZSkpO1xyXG4gICAgICAgICAgICBpbnQgaiA9IDA7XHJcblxyXG4gICAgICAgICAgICB3aGlsZSAoZWRnZS5RLlggPiB0cmFwZXpvaWRzW2pdLlJpZ2h0UG9pbnQuWClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgaWYgKGVkZ2UuSXNBYm92ZSh0cmFwZXpvaWRzW2pdLlJpZ2h0UG9pbnQpKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIHRyYXBlem9pZHMuQWRkKHRyYXBlem9pZHNbal0uVXBwZXJSaWdodCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgdHJhcGV6b2lkcy5BZGQodHJhcGV6b2lkc1tqXS5Mb3dlclJpZ2h0KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGogKz0gMTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gdHJhcGV6b2lkcztcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHByaXZhdGUgdm9pZCBSZXBsYWNlKFNpbmsgc2luaywgTm9kZSBub2RlKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgaWYgKHNpbmsuUGFyZW50TGlzdC5Db3VudCA9PSAwKVxyXG4gICAgICAgICAgICAgICAgX2hlYWQgPSBub2RlO1xyXG4gICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICBub2RlLlJlcGxhY2Uoc2luayk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwdWJsaWMgdm9pZCBDYXNlMShTaW5rIHNpbmssIEVkZ2UgZWRnZSwgVHJhcGV6b2lkW10gdExpc3QpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBZTm9kZSB5Tm9kZSA9IG5ldyBZTm9kZShlZGdlLCBTaW5rLklzaW5rKHRMaXN0WzFdKSwgU2luay5Jc2luayh0TGlzdFsyXSkpO1xyXG4gICAgICAgICAgICBYTm9kZSBxTm9kZSA9IG5ldyBYTm9kZShlZGdlLlEsIHlOb2RlLCBTaW5rLklzaW5rKHRMaXN0WzNdKSk7XHJcbiAgICAgICAgICAgIFhOb2RlIHBOb2RlID0gbmV3IFhOb2RlKGVkZ2UuUCwgU2luay5Jc2luayh0TGlzdFswXSksIHFOb2RlKTtcclxuICAgICAgICAgICAgUmVwbGFjZShzaW5rLCBwTm9kZSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwdWJsaWMgdm9pZCBDYXNlMihTaW5rIHNpbmssIEVkZ2UgZWRnZSwgVHJhcGV6b2lkW10gdExpc3QpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBZTm9kZSB5Tm9kZSA9IG5ldyBZTm9kZShlZGdlLCBTaW5rLklzaW5rKHRMaXN0WzFdKSwgU2luay5Jc2luayh0TGlzdFsyXSkpO1xyXG4gICAgICAgICAgICBYTm9kZSBwTm9kZSA9IG5ldyBYTm9kZShlZGdlLlAsIFNpbmsuSXNpbmsodExpc3RbMF0pLCB5Tm9kZSk7XHJcbiAgICAgICAgICAgIFJlcGxhY2Uoc2luaywgcE5vZGUpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHVibGljIHZvaWQgQ2FzZTMoU2luayBzaW5rLCBFZGdlIGVkZ2UsIFRyYXBlem9pZFtdIHRMaXN0KVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgWU5vZGUgeU5vZGUgPSBuZXcgWU5vZGUoZWRnZSwgU2luay5Jc2luayh0TGlzdFswXSksIFNpbmsuSXNpbmsodExpc3RbMV0pKTtcclxuICAgICAgICAgICAgUmVwbGFjZShzaW5rLCB5Tm9kZSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwdWJsaWMgdm9pZCBDYXNlNChTaW5rIHNpbmssIEVkZ2UgZWRnZSwgVHJhcGV6b2lkW10gdExpc3QpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBZTm9kZSB5Tm9kZSA9IG5ldyBZTm9kZShlZGdlLCBTaW5rLklzaW5rKHRMaXN0WzBdKSwgU2luay5Jc2luayh0TGlzdFsxXSkpO1xyXG4gICAgICAgICAgICBYTm9kZSBxTm9kZSA9IG5ldyBYTm9kZShlZGdlLlEsIHlOb2RlLCBTaW5rLklzaW5rKHRMaXN0WzJdKSk7XHJcbiAgICAgICAgICAgIFJlcGxhY2Uoc2luaywgcU5vZGUpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBpbnRlcm5hbCBjbGFzcyBTaW5rIDogTm9kZVxyXG4gICAge1xyXG4gICAgICAgIHB1YmxpYyBUcmFwZXpvaWQgVHJhcGV6b2lkO1xyXG5cclxuICAgICAgICBwcml2YXRlIFNpbmsoVHJhcGV6b2lkIHRyYXBlem9pZClcclxuICAgICAgICAgICAgOiBiYXNlKG51bGwsIG51bGwpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBUcmFwZXpvaWQgPSB0cmFwZXpvaWQ7XHJcbiAgICAgICAgICAgIHRyYXBlem9pZC5TaW5rID0gdGhpcztcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHB1YmxpYyBzdGF0aWMgU2luayBJc2luayhUcmFwZXpvaWQgdHJhcGV6b2lkKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgaWYgKHRyYXBlem9pZC5TaW5rID09IG51bGwpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFNpbmsodHJhcGV6b2lkKTtcclxuICAgICAgICAgICAgcmV0dXJuIHRyYXBlem9pZC5TaW5rO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHVibGljIG92ZXJyaWRlIFNpbmsgTG9jYXRlKEVkZ2UgZWRnZSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvLyBTZWUgXCJDb21wdXRhdGlvbmFsIEdlb21ldHJ5XCIsIDNyZCBlZGl0aW9uLCBieSBNYXJrIGRlIEJlcmcgZXQgYWwsIENoYXB0ZXIgNi4yXHJcbiAgICBpbnRlcm5hbCBjbGFzcyBUcmFwZXpvaWRhbE1hcFxyXG4gICAge1xyXG4gICAgICAgIC8vIFRyYXBlem9pZCBjb250YWluZXJcclxuICAgICAgICBwdWJsaWMgSGFzaFNldDxUcmFwZXpvaWQ+IE1hcDtcclxuXHJcbiAgICAgICAgLy8gQUFCQiBtYXJnaW5cclxuXHJcbiAgICAgICAgLy8gQm90dG9tIHNlZ21lbnQgdGhhdCBzcGFucyBtdWx0aXBsZSB0cmFwZXpvaWRzXHJcbiAgICAgICAgcHJpdmF0ZSBFZGdlIF9iQ3Jvc3M7XHJcblxyXG4gICAgICAgIC8vIFRvcCBzZWdtZW50IHRoYXQgc3BhbnMgbXVsdGlwbGUgdHJhcGV6b2lkc1xyXG4gICAgICAgIHByaXZhdGUgRWRnZSBfY3Jvc3M7XHJcbiAgICAgICAgcHJpdmF0ZSBmbG9hdCBfbWFyZ2luO1xyXG5cclxuICAgICAgICBwdWJsaWMgVHJhcGV6b2lkYWxNYXAoKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgTWFwID0gbmV3IEhhc2hTZXQ8VHJhcGV6b2lkPigpO1xyXG4gICAgICAgICAgICBfbWFyZ2luID0gNTAuMGY7XHJcbiAgICAgICAgICAgIF9iQ3Jvc3MgPSBudWxsO1xyXG4gICAgICAgICAgICBfY3Jvc3MgPSBudWxsO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHVibGljIHZvaWQgQ2xlYXIoKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgX2JDcm9zcyA9IG51bGw7XHJcbiAgICAgICAgICAgIF9jcm9zcyA9IG51bGw7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBDYXNlIDE6IHNlZ21lbnQgY29tcGxldGVseSBlbmNsb3NlZCBieSB0cmFwZXpvaWRcclxuICAgICAgICAvLyAgICAgICAgIGJyZWFrIHRyYXBlem9pZCBpbnRvIDQgc21hbGxlciB0cmFwZXpvaWRzXHJcbiAgICAgICAgcHVibGljIFRyYXBlem9pZFtdIENhc2UxKFRyYXBlem9pZCB0LCBFZGdlIGUpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBUcmFwZXpvaWRbXSB0cmFwZXpvaWRzID0gbmV3IFRyYXBlem9pZFs0XTtcclxuICAgICAgICAgICAgdHJhcGV6b2lkc1swXSA9IG5ldyBUcmFwZXpvaWQodC5MZWZ0UG9pbnQsIGUuUCwgdC5Ub3AsIHQuQm90dG9tKTtcclxuICAgICAgICAgICAgdHJhcGV6b2lkc1sxXSA9IG5ldyBUcmFwZXpvaWQoZS5QLCBlLlEsIHQuVG9wLCBlKTtcclxuICAgICAgICAgICAgdHJhcGV6b2lkc1syXSA9IG5ldyBUcmFwZXpvaWQoZS5QLCBlLlEsIGUsIHQuQm90dG9tKTtcclxuICAgICAgICAgICAgdHJhcGV6b2lkc1szXSA9IG5ldyBUcmFwZXpvaWQoZS5RLCB0LlJpZ2h0UG9pbnQsIHQuVG9wLCB0LkJvdHRvbSk7XHJcblxyXG4gICAgICAgICAgICB0cmFwZXpvaWRzWzBdLlVwZGF0ZUxlZnQodC5VcHBlckxlZnQsIHQuTG93ZXJMZWZ0KTtcclxuICAgICAgICAgICAgdHJhcGV6b2lkc1sxXS5VcGRhdGVMZWZ0UmlnaHQodHJhcGV6b2lkc1swXSwgbnVsbCwgdHJhcGV6b2lkc1szXSwgbnVsbCk7XHJcbiAgICAgICAgICAgIHRyYXBlem9pZHNbMl0uVXBkYXRlTGVmdFJpZ2h0KG51bGwsIHRyYXBlem9pZHNbMF0sIG51bGwsIHRyYXBlem9pZHNbM10pO1xyXG4gICAgICAgICAgICB0cmFwZXpvaWRzWzNdLlVwZGF0ZVJpZ2h0KHQuVXBwZXJSaWdodCwgdC5Mb3dlclJpZ2h0KTtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiB0cmFwZXpvaWRzO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gQ2FzZSAyOiBUcmFwZXpvaWQgY29udGFpbnMgcG9pbnQgcCwgcSBsaWVzIG91dHNpZGVcclxuICAgICAgICAvLyAgICAgICAgIGJyZWFrIHRyYXBlem9pZCBpbnRvIDMgc21hbGxlciB0cmFwZXpvaWRzXHJcbiAgICAgICAgcHVibGljIFRyYXBlem9pZFtdIENhc2UyKFRyYXBlem9pZCB0LCBFZGdlIGUpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBQb2ludCBycDtcclxuICAgICAgICAgICAgaWYgKGUuUS5YID09IHQuUmlnaHRQb2ludC5YKVxyXG4gICAgICAgICAgICAgICAgcnAgPSBlLlE7XHJcbiAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgIHJwID0gdC5SaWdodFBvaW50O1xyXG5cclxuICAgICAgICAgICAgVHJhcGV6b2lkW10gdHJhcGV6b2lkcyA9IG5ldyBUcmFwZXpvaWRbM107XHJcbiAgICAgICAgICAgIHRyYXBlem9pZHNbMF0gPSBuZXcgVHJhcGV6b2lkKHQuTGVmdFBvaW50LCBlLlAsIHQuVG9wLCB0LkJvdHRvbSk7XHJcbiAgICAgICAgICAgIHRyYXBlem9pZHNbMV0gPSBuZXcgVHJhcGV6b2lkKGUuUCwgcnAsIHQuVG9wLCBlKTtcclxuICAgICAgICAgICAgdHJhcGV6b2lkc1syXSA9IG5ldyBUcmFwZXpvaWQoZS5QLCBycCwgZSwgdC5Cb3R0b20pO1xyXG5cclxuICAgICAgICAgICAgdHJhcGV6b2lkc1swXS5VcGRhdGVMZWZ0KHQuVXBwZXJMZWZ0LCB0Lkxvd2VyTGVmdCk7XHJcbiAgICAgICAgICAgIHRyYXBlem9pZHNbMV0uVXBkYXRlTGVmdFJpZ2h0KHRyYXBlem9pZHNbMF0sIG51bGwsIHQuVXBwZXJSaWdodCwgbnVsbCk7XHJcbiAgICAgICAgICAgIHRyYXBlem9pZHNbMl0uVXBkYXRlTGVmdFJpZ2h0KG51bGwsIHRyYXBlem9pZHNbMF0sIG51bGwsIHQuTG93ZXJSaWdodCk7XHJcblxyXG4gICAgICAgICAgICBfYkNyb3NzID0gdC5Cb3R0b207XHJcbiAgICAgICAgICAgIF9jcm9zcyA9IHQuVG9wO1xyXG5cclxuICAgICAgICAgICAgZS5BYm92ZSA9IHRyYXBlem9pZHNbMV07XHJcbiAgICAgICAgICAgIGUuQmVsb3cgPSB0cmFwZXpvaWRzWzJdO1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIHRyYXBlem9pZHM7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBDYXNlIDM6IFRyYXBlem9pZCBpcyBiaXNlY3RlZFxyXG4gICAgICAgIHB1YmxpYyBUcmFwZXpvaWRbXSBDYXNlMyhUcmFwZXpvaWQgdCwgRWRnZSBlKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgUG9pbnQgbHA7XHJcbiAgICAgICAgICAgIGlmIChlLlAuWCA9PSB0LkxlZnRQb2ludC5YKVxyXG4gICAgICAgICAgICAgICAgbHAgPSBlLlA7XHJcbiAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgIGxwID0gdC5MZWZ0UG9pbnQ7XHJcblxyXG4gICAgICAgICAgICBQb2ludCBycDtcclxuICAgICAgICAgICAgaWYgKGUuUS5YID09IHQuUmlnaHRQb2ludC5YKVxyXG4gICAgICAgICAgICAgICAgcnAgPSBlLlE7XHJcbiAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgIHJwID0gdC5SaWdodFBvaW50O1xyXG5cclxuICAgICAgICAgICAgVHJhcGV6b2lkW10gdHJhcGV6b2lkcyA9IG5ldyBUcmFwZXpvaWRbMl07XHJcblxyXG4gICAgICAgICAgICBpZiAoX2Nyb3NzID09IHQuVG9wKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB0cmFwZXpvaWRzWzBdID0gdC5VcHBlckxlZnQ7XHJcbiAgICAgICAgICAgICAgICB0cmFwZXpvaWRzWzBdLlVwZGF0ZVJpZ2h0KHQuVXBwZXJSaWdodCwgbnVsbCk7XHJcbiAgICAgICAgICAgICAgICB0cmFwZXpvaWRzWzBdLlJpZ2h0UG9pbnQgPSBycDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHRyYXBlem9pZHNbMF0gPSBuZXcgVHJhcGV6b2lkKGxwLCBycCwgdC5Ub3AsIGUpO1xyXG4gICAgICAgICAgICAgICAgdHJhcGV6b2lkc1swXS5VcGRhdGVMZWZ0UmlnaHQodC5VcHBlckxlZnQsIGUuQWJvdmUsIHQuVXBwZXJSaWdodCwgbnVsbCk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmIChfYkNyb3NzID09IHQuQm90dG9tKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB0cmFwZXpvaWRzWzFdID0gdC5Mb3dlckxlZnQ7XHJcbiAgICAgICAgICAgICAgICB0cmFwZXpvaWRzWzFdLlVwZGF0ZVJpZ2h0KG51bGwsIHQuTG93ZXJSaWdodCk7XHJcbiAgICAgICAgICAgICAgICB0cmFwZXpvaWRzWzFdLlJpZ2h0UG9pbnQgPSBycDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHRyYXBlem9pZHNbMV0gPSBuZXcgVHJhcGV6b2lkKGxwLCBycCwgZSwgdC5Cb3R0b20pO1xyXG4gICAgICAgICAgICAgICAgdHJhcGV6b2lkc1sxXS5VcGRhdGVMZWZ0UmlnaHQoZS5CZWxvdywgdC5Mb3dlckxlZnQsIG51bGwsIHQuTG93ZXJSaWdodCk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIF9iQ3Jvc3MgPSB0LkJvdHRvbTtcclxuICAgICAgICAgICAgX2Nyb3NzID0gdC5Ub3A7XHJcblxyXG4gICAgICAgICAgICBlLkFib3ZlID0gdHJhcGV6b2lkc1swXTtcclxuICAgICAgICAgICAgZS5CZWxvdyA9IHRyYXBlem9pZHNbMV07XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gdHJhcGV6b2lkcztcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIENhc2UgNDogVHJhcGV6b2lkIGNvbnRhaW5zIHBvaW50IHEsIHAgbGllcyBvdXRzaWRlXHJcbiAgICAgICAgLy8gICAgICAgICBicmVhayB0cmFwZXpvaWQgaW50byAzIHNtYWxsZXIgdHJhcGV6b2lkc1xyXG4gICAgICAgIHB1YmxpYyBUcmFwZXpvaWRbXSBDYXNlNChUcmFwZXpvaWQgdCwgRWRnZSBlKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgUG9pbnQgbHA7XHJcbiAgICAgICAgICAgIGlmIChlLlAuWCA9PSB0LkxlZnRQb2ludC5YKVxyXG4gICAgICAgICAgICAgICAgbHAgPSBlLlA7XHJcbiAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgIGxwID0gdC5MZWZ0UG9pbnQ7XHJcblxyXG4gICAgICAgICAgICBUcmFwZXpvaWRbXSB0cmFwZXpvaWRzID0gbmV3IFRyYXBlem9pZFszXTtcclxuXHJcbiAgICAgICAgICAgIGlmIChfY3Jvc3MgPT0gdC5Ub3ApXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHRyYXBlem9pZHNbMF0gPSB0LlVwcGVyTGVmdDtcclxuICAgICAgICAgICAgICAgIHRyYXBlem9pZHNbMF0uUmlnaHRQb2ludCA9IGUuUTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHRyYXBlem9pZHNbMF0gPSBuZXcgVHJhcGV6b2lkKGxwLCBlLlEsIHQuVG9wLCBlKTtcclxuICAgICAgICAgICAgICAgIHRyYXBlem9pZHNbMF0uVXBkYXRlTGVmdCh0LlVwcGVyTGVmdCwgZS5BYm92ZSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmIChfYkNyb3NzID09IHQuQm90dG9tKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB0cmFwZXpvaWRzWzFdID0gdC5Mb3dlckxlZnQ7XHJcbiAgICAgICAgICAgICAgICB0cmFwZXpvaWRzWzFdLlJpZ2h0UG9pbnQgPSBlLlE7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB0cmFwZXpvaWRzWzFdID0gbmV3IFRyYXBlem9pZChscCwgZS5RLCBlLCB0LkJvdHRvbSk7XHJcbiAgICAgICAgICAgICAgICB0cmFwZXpvaWRzWzFdLlVwZGF0ZUxlZnQoZS5CZWxvdywgdC5Mb3dlckxlZnQpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB0cmFwZXpvaWRzWzJdID0gbmV3IFRyYXBlem9pZChlLlEsIHQuUmlnaHRQb2ludCwgdC5Ub3AsIHQuQm90dG9tKTtcclxuICAgICAgICAgICAgdHJhcGV6b2lkc1syXS5VcGRhdGVMZWZ0UmlnaHQodHJhcGV6b2lkc1swXSwgdHJhcGV6b2lkc1sxXSwgdC5VcHBlclJpZ2h0LCB0Lkxvd2VyUmlnaHQpO1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIHRyYXBlem9pZHM7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBDcmVhdGUgYW4gQUFCQiBhcm91bmQgc2VnbWVudHNcclxuICAgICAgICBwdWJsaWMgVHJhcGV6b2lkIEJvdW5kaW5nQm94KExpc3Q8RWRnZT4gZWRnZXMpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBQb2ludCBtYXggPSBlZGdlc1swXS5QICsgX21hcmdpbjtcclxuICAgICAgICAgICAgUG9pbnQgbWluID0gZWRnZXNbMF0uUSAtIF9tYXJnaW47XHJcblxyXG4gICAgICAgICAgICBmb3JlYWNoIChFZGdlIGUgaW4gZWRnZXMpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGlmIChlLlAuWCA+IG1heC5YKSBtYXggPSBuZXcgUG9pbnQoZS5QLlggKyBfbWFyZ2luLCBtYXguWSk7XHJcbiAgICAgICAgICAgICAgICBpZiAoZS5QLlkgPiBtYXguWSkgbWF4ID0gbmV3IFBvaW50KG1heC5YLCBlLlAuWSArIF9tYXJnaW4pO1xyXG4gICAgICAgICAgICAgICAgaWYgKGUuUS5YID4gbWF4LlgpIG1heCA9IG5ldyBQb2ludChlLlEuWCArIF9tYXJnaW4sIG1heC5ZKTtcclxuICAgICAgICAgICAgICAgIGlmIChlLlEuWSA+IG1heC5ZKSBtYXggPSBuZXcgUG9pbnQobWF4LlgsIGUuUS5ZICsgX21hcmdpbik7XHJcbiAgICAgICAgICAgICAgICBpZiAoZS5QLlggPCBtaW4uWCkgbWluID0gbmV3IFBvaW50KGUuUC5YIC0gX21hcmdpbiwgbWluLlkpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGUuUC5ZIDwgbWluLlkpIG1pbiA9IG5ldyBQb2ludChtaW4uWCwgZS5QLlkgLSBfbWFyZ2luKTtcclxuICAgICAgICAgICAgICAgIGlmIChlLlEuWCA8IG1pbi5YKSBtaW4gPSBuZXcgUG9pbnQoZS5RLlggLSBfbWFyZ2luLCBtaW4uWSk7XHJcbiAgICAgICAgICAgICAgICBpZiAoZS5RLlkgPCBtaW4uWSkgbWluID0gbmV3IFBvaW50KG1pbi5YLCBlLlEuWSAtIF9tYXJnaW4pO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBFZGdlIHRvcCA9IG5ldyBFZGdlKG5ldyBQb2ludChtaW4uWCwgbWF4LlkpLCBuZXcgUG9pbnQobWF4LlgsIG1heC5ZKSk7XHJcbiAgICAgICAgICAgIEVkZ2UgYm90dG9tID0gbmV3IEVkZ2UobmV3IFBvaW50KG1pbi5YLCBtaW4uWSksIG5ldyBQb2ludChtYXguWCwgbWluLlkpKTtcclxuICAgICAgICAgICAgUG9pbnQgbGVmdCA9IGJvdHRvbS5QO1xyXG4gICAgICAgICAgICBQb2ludCByaWdodCA9IHRvcC5RO1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBUcmFwZXpvaWQobGVmdCwgcmlnaHQsIHRvcCwgYm90dG9tKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgaW50ZXJuYWwgY2xhc3MgUG9pbnRcclxuICAgIHtcclxuICAgICAgICAvLyBQb2ludGVycyB0byBuZXh0IGFuZCBwcmV2aW91cyBwb2ludHMgaW4gTW9ub250b25lIE1vdW50YWluXHJcbiAgICAgICAgcHVibGljIFBvaW50IE5leHQsIFByZXY7XHJcbiAgICAgICAgcHVibGljIGZsb2F0IFgsIFk7XHJcblxyXG4gICAgICAgIHB1YmxpYyBQb2ludChmbG9hdCB4LCBmbG9hdCB5KVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgWCA9IHg7XHJcbiAgICAgICAgICAgIFkgPSB5O1xyXG4gICAgICAgICAgICBOZXh0ID0gbnVsbDtcclxuICAgICAgICAgICAgUHJldiA9IG51bGw7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwdWJsaWMgc3RhdGljIFBvaW50IG9wZXJhdG9yIC0oUG9pbnQgcDEsIFBvaW50IHAyKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBQb2ludChwMS5YIC0gcDIuWCwgcDEuWSAtIHAyLlkpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHVibGljIHN0YXRpYyBQb2ludCBvcGVyYXRvciArKFBvaW50IHAxLCBQb2ludCBwMilcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgUG9pbnQocDEuWCArIHAyLlgsIHAxLlkgKyBwMi5ZKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHB1YmxpYyBzdGF0aWMgUG9pbnQgb3BlcmF0b3IgLShQb2ludCBwMSwgZmxvYXQgZilcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgUG9pbnQocDEuWCAtIGYsIHAxLlkgLSBmKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHB1YmxpYyBzdGF0aWMgUG9pbnQgb3BlcmF0b3IgKyhQb2ludCBwMSwgZmxvYXQgZilcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgUG9pbnQocDEuWCArIGYsIHAxLlkgKyBmKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHB1YmxpYyBmbG9hdCBDcm9zcyhQb2ludCBwKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIFggKiBwLlkgLSBZICogcC5YO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHVibGljIGZsb2F0IERvdChQb2ludCBwKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIFggKiBwLlggKyBZICogcC5ZO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHVibGljIGJvb2wgTmVxKFBvaW50IHApXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gcC5YICE9IFggfHwgcC5ZICE9IFk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwdWJsaWMgZmxvYXQgT3JpZW50MkQoUG9pbnQgcGIsIFBvaW50IHBjKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgZmxvYXQgYWN4ID0gWCAtIHBjLlg7XHJcbiAgICAgICAgICAgIGZsb2F0IGJjeCA9IHBiLlggLSBwYy5YO1xyXG4gICAgICAgICAgICBmbG9hdCBhY3kgPSBZIC0gcGMuWTtcclxuICAgICAgICAgICAgZmxvYXQgYmN5ID0gcGIuWSAtIHBjLlk7XHJcbiAgICAgICAgICAgIHJldHVybiBhY3ggKiBiY3kgLSBhY3kgKiBiY3g7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGludGVybmFsIGNsYXNzIEVkZ2VcclxuICAgIHtcclxuICAgICAgICAvLyBQb2ludGVycyB1c2VkIGZvciBidWlsZGluZyB0cmFwZXpvaWRhbCBtYXBcclxuICAgICAgICBwdWJsaWMgVHJhcGV6b2lkIEFib3ZlO1xyXG4gICAgICAgIHB1YmxpYyBmbG9hdCBCO1xyXG4gICAgICAgIHB1YmxpYyBUcmFwZXpvaWQgQmVsb3c7XHJcblxyXG4gICAgICAgIC8vIEVxdWF0aW9uIG9mIGEgbGluZTogeSA9IG0qeCArIGJcclxuICAgICAgICAvLyBTbG9wZSBvZiB0aGUgbGluZSAobSlcclxuXHJcbiAgICAgICAgLy8gTW9udG9uZSBtb3VudGFpbiBwb2ludHNcclxuICAgICAgICBwdWJsaWMgSGFzaFNldDxQb2ludD4gTVBvaW50cztcclxuICAgICAgICBwdWJsaWMgUG9pbnQgUDtcclxuICAgICAgICBwdWJsaWMgUG9pbnQgUTtcclxuICAgICAgICBwdWJsaWMgZmxvYXQgU2xvcGU7XHJcblxyXG4gICAgICAgIC8vIFkgaW50ZXJjZXB0XHJcblxyXG4gICAgICAgIHB1YmxpYyBFZGdlKFBvaW50IHAsIFBvaW50IHEpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBQID0gcDtcclxuICAgICAgICAgICAgUSA9IHE7XHJcblxyXG4gICAgICAgICAgICBpZiAocS5YIC0gcC5YICE9IDApXHJcbiAgICAgICAgICAgICAgICBTbG9wZSA9IChxLlkgLSBwLlkpIC8gKHEuWCAtIHAuWCk7XHJcbiAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgIFNsb3BlID0gMDtcclxuXHJcbiAgICAgICAgICAgIEIgPSBwLlkgLSAocC5YICogU2xvcGUpO1xyXG4gICAgICAgICAgICBBYm92ZSA9IG51bGw7XHJcbiAgICAgICAgICAgIEJlbG93ID0gbnVsbDtcclxuICAgICAgICAgICAgTVBvaW50cyA9IG5ldyBIYXNoU2V0PFBvaW50PigpO1xyXG4gICAgICAgICAgICBNUG9pbnRzLkFkZChwKTtcclxuICAgICAgICAgICAgTVBvaW50cy5BZGQocSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwdWJsaWMgYm9vbCBJc0Fib3ZlKFBvaW50IHBvaW50KVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIFAuT3JpZW50MkQoUSwgcG9pbnQpIDwgMDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHB1YmxpYyBib29sIElzQmVsb3coUG9pbnQgcG9pbnQpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gUC5PcmllbnQyRChRLCBwb2ludCkgPiAwO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHVibGljIHZvaWQgQWRkTXBvaW50KFBvaW50IHBvaW50KVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgZm9yZWFjaCAoUG9pbnQgbXAgaW4gTVBvaW50cylcclxuICAgICAgICAgICAgICAgIGlmICghbXAuTmVxKHBvaW50KSlcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcblxyXG4gICAgICAgICAgICBNUG9pbnRzLkFkZChwb2ludCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGludGVybmFsIGNsYXNzIFRyYXBlem9pZFxyXG4gICAge1xyXG4gICAgICAgIHB1YmxpYyBFZGdlIEJvdHRvbTtcclxuICAgICAgICBwdWJsaWMgYm9vbCBJbnNpZGU7XHJcbiAgICAgICAgcHVibGljIFBvaW50IExlZnRQb2ludDtcclxuXHJcbiAgICAgICAgLy8gTmVpZ2hib3IgcG9pbnRlcnNcclxuICAgICAgICBwdWJsaWMgVHJhcGV6b2lkIExvd2VyTGVmdDtcclxuICAgICAgICBwdWJsaWMgVHJhcGV6b2lkIExvd2VyUmlnaHQ7XHJcblxyXG4gICAgICAgIHB1YmxpYyBQb2ludCBSaWdodFBvaW50O1xyXG4gICAgICAgIHB1YmxpYyBTaW5rIFNpbms7XHJcblxyXG4gICAgICAgIHB1YmxpYyBFZGdlIFRvcDtcclxuICAgICAgICBwdWJsaWMgVHJhcGV6b2lkIFVwcGVyTGVmdDtcclxuICAgICAgICBwdWJsaWMgVHJhcGV6b2lkIFVwcGVyUmlnaHQ7XHJcblxyXG4gICAgICAgIHB1YmxpYyBUcmFwZXpvaWQoUG9pbnQgbGVmdFBvaW50LCBQb2ludCByaWdodFBvaW50LCBFZGdlIHRvcCwgRWRnZSBib3R0b20pXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBMZWZ0UG9pbnQgPSBsZWZ0UG9pbnQ7XHJcbiAgICAgICAgICAgIFJpZ2h0UG9pbnQgPSByaWdodFBvaW50O1xyXG4gICAgICAgICAgICBUb3AgPSB0b3A7XHJcbiAgICAgICAgICAgIEJvdHRvbSA9IGJvdHRvbTtcclxuICAgICAgICAgICAgVXBwZXJMZWZ0ID0gbnVsbDtcclxuICAgICAgICAgICAgVXBwZXJSaWdodCA9IG51bGw7XHJcbiAgICAgICAgICAgIExvd2VyTGVmdCA9IG51bGw7XHJcbiAgICAgICAgICAgIExvd2VyUmlnaHQgPSBudWxsO1xyXG4gICAgICAgICAgICBJbnNpZGUgPSB0cnVlO1xyXG4gICAgICAgICAgICBTaW5rID0gbnVsbDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIFVwZGF0ZSBuZWlnaGJvcnMgdG8gdGhlIGxlZnRcclxuICAgICAgICBwdWJsaWMgdm9pZCBVcGRhdGVMZWZ0KFRyYXBlem9pZCB1bCwgVHJhcGV6b2lkIGxsKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgVXBwZXJMZWZ0ID0gdWw7XHJcbiAgICAgICAgICAgIGlmICh1bCAhPSBudWxsKSB1bC5VcHBlclJpZ2h0ID0gdGhpcztcclxuICAgICAgICAgICAgTG93ZXJMZWZ0ID0gbGw7XHJcbiAgICAgICAgICAgIGlmIChsbCAhPSBudWxsKSBsbC5Mb3dlclJpZ2h0ID0gdGhpcztcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIFVwZGF0ZSBuZWlnaGJvcnMgdG8gdGhlIHJpZ2h0XHJcbiAgICAgICAgcHVibGljIHZvaWQgVXBkYXRlUmlnaHQoVHJhcGV6b2lkIHVyLCBUcmFwZXpvaWQgbHIpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBVcHBlclJpZ2h0ID0gdXI7XHJcbiAgICAgICAgICAgIGlmICh1ciAhPSBudWxsKSB1ci5VcHBlckxlZnQgPSB0aGlzO1xyXG4gICAgICAgICAgICBMb3dlclJpZ2h0ID0gbHI7XHJcbiAgICAgICAgICAgIGlmIChsciAhPSBudWxsKSBsci5Mb3dlckxlZnQgPSB0aGlzO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gVXBkYXRlIG5laWdoYm9ycyBvbiBib3RoIHNpZGVzXHJcbiAgICAgICAgcHVibGljIHZvaWQgVXBkYXRlTGVmdFJpZ2h0KFRyYXBlem9pZCB1bCwgVHJhcGV6b2lkIGxsLCBUcmFwZXpvaWQgdXIsIFRyYXBlem9pZCBscilcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIFVwcGVyTGVmdCA9IHVsO1xyXG4gICAgICAgICAgICBpZiAodWwgIT0gbnVsbCkgdWwuVXBwZXJSaWdodCA9IHRoaXM7XHJcbiAgICAgICAgICAgIExvd2VyTGVmdCA9IGxsO1xyXG4gICAgICAgICAgICBpZiAobGwgIT0gbnVsbCkgbGwuTG93ZXJSaWdodCA9IHRoaXM7XHJcbiAgICAgICAgICAgIFVwcGVyUmlnaHQgPSB1cjtcclxuICAgICAgICAgICAgaWYgKHVyICE9IG51bGwpIHVyLlVwcGVyTGVmdCA9IHRoaXM7XHJcbiAgICAgICAgICAgIExvd2VyUmlnaHQgPSBscjtcclxuICAgICAgICAgICAgaWYgKGxyICE9IG51bGwpIGxyLkxvd2VyTGVmdCA9IHRoaXM7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBSZWN1cnNpdmVseSB0cmltIG91dHNpZGUgbmVpZ2hib3JzXHJcbiAgICAgICAgcHVibGljIHZvaWQgVHJpbU5laWdoYm9ycygpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBpZiAoSW5zaWRlKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBJbnNpZGUgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgIGlmIChVcHBlckxlZnQgIT0gbnVsbCkgVXBwZXJMZWZ0LlRyaW1OZWlnaGJvcnMoKTtcclxuICAgICAgICAgICAgICAgIGlmIChMb3dlckxlZnQgIT0gbnVsbCkgTG93ZXJMZWZ0LlRyaW1OZWlnaGJvcnMoKTtcclxuICAgICAgICAgICAgICAgIGlmIChVcHBlclJpZ2h0ICE9IG51bGwpIFVwcGVyUmlnaHQuVHJpbU5laWdoYm9ycygpO1xyXG4gICAgICAgICAgICAgICAgaWYgKExvd2VyUmlnaHQgIT0gbnVsbCkgTG93ZXJSaWdodC5UcmltTmVpZ2hib3JzKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIERldGVybWluZXMgaWYgdGhpcyBwb2ludCBsaWVzIGluc2lkZSB0aGUgdHJhcGV6b2lkXHJcbiAgICAgICAgcHVibGljIGJvb2wgQ29udGFpbnMoUG9pbnQgcG9pbnQpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gKHBvaW50LlggPiBMZWZ0UG9pbnQuWCAmJiBwb2ludC5YIDwgUmlnaHRQb2ludC5YICYmIFRvcC5Jc0Fib3ZlKHBvaW50KSAmJiBCb3R0b20uSXNCZWxvdyhwb2ludCkpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHVibGljIExpc3Q8UG9pbnQ+IFZlcnRpY2VzKClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIExpc3Q8UG9pbnQ+IHZlcnRzID0gbmV3IExpc3Q8UG9pbnQ+KDQpO1xyXG4gICAgICAgICAgICB2ZXJ0cy5BZGQoTGluZUludGVyc2VjdChUb3AsIExlZnRQb2ludC5YKSk7XHJcbiAgICAgICAgICAgIHZlcnRzLkFkZChMaW5lSW50ZXJzZWN0KEJvdHRvbSwgTGVmdFBvaW50LlgpKTtcclxuICAgICAgICAgICAgdmVydHMuQWRkKExpbmVJbnRlcnNlY3QoQm90dG9tLCBSaWdodFBvaW50LlgpKTtcclxuICAgICAgICAgICAgdmVydHMuQWRkKExpbmVJbnRlcnNlY3QoVG9wLCBSaWdodFBvaW50LlgpKTtcclxuICAgICAgICAgICAgcmV0dXJuIHZlcnRzO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHJpdmF0ZSBQb2ludCBMaW5lSW50ZXJzZWN0KEVkZ2UgZWRnZSwgZmxvYXQgeClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGZsb2F0IHkgPSBlZGdlLlNsb3BlICogeCArIGVkZ2UuQjtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBQb2ludCh4LCB5KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIEFkZCBwb2ludHMgdG8gbW9ub3RvbmUgbW91bnRhaW5cclxuICAgICAgICBwdWJsaWMgdm9pZCBBZGRQb2ludHMoKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgaWYgKExlZnRQb2ludCAhPSBCb3R0b20uUClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgQm90dG9tLkFkZE1wb2ludChMZWZ0UG9pbnQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChSaWdodFBvaW50ICE9IEJvdHRvbS5RKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBCb3R0b20uQWRkTXBvaW50KFJpZ2h0UG9pbnQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChMZWZ0UG9pbnQgIT0gVG9wLlApXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIFRvcC5BZGRNcG9pbnQoTGVmdFBvaW50KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoUmlnaHRQb2ludCAhPSBUb3AuUSlcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgVG9wLkFkZE1wb2ludChSaWdodFBvaW50KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBpbnRlcm5hbCBjbGFzcyBYTm9kZSA6IE5vZGVcclxuICAgIHtcclxuICAgICAgICBwcml2YXRlIFBvaW50IF9wb2ludDtcclxuXHJcbiAgICAgICAgcHVibGljIFhOb2RlKFBvaW50IHBvaW50LCBOb2RlIGxDaGlsZCwgTm9kZSByQ2hpbGQpXHJcbiAgICAgICAgICAgIDogYmFzZShsQ2hpbGQsIHJDaGlsZClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIF9wb2ludCA9IHBvaW50O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHVibGljIG92ZXJyaWRlIFNpbmsgTG9jYXRlKEVkZ2UgZWRnZSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGlmIChlZGdlLlAuWCA+PSBfcG9pbnQuWClcclxuICAgICAgICAgICAgICAgIC8vIE1vdmUgdG8gdGhlIHJpZ2h0IGluIHRoZSBncmFwaFxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFJpZ2h0Q2hpbGQuTG9jYXRlKGVkZ2UpO1xyXG4gICAgICAgICAgICAvLyBNb3ZlIHRvIHRoZSBsZWZ0IGluIHRoZSBncmFwaFxyXG4gICAgICAgICAgICByZXR1cm4gTGVmdENoaWxkLkxvY2F0ZShlZGdlKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgaW50ZXJuYWwgY2xhc3MgWU5vZGUgOiBOb2RlXHJcbiAgICB7XHJcbiAgICAgICAgcHJpdmF0ZSBFZGdlIF9lZGdlO1xyXG5cclxuICAgICAgICBwdWJsaWMgWU5vZGUoRWRnZSBlZGdlLCBOb2RlIGxDaGlsZCwgTm9kZSByQ2hpbGQpXHJcbiAgICAgICAgICAgIDogYmFzZShsQ2hpbGQsIHJDaGlsZClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIF9lZGdlID0gZWRnZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHB1YmxpYyBvdmVycmlkZSBTaW5rIExvY2F0ZShFZGdlIGVkZ2UpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBpZiAoX2VkZ2UuSXNBYm92ZShlZGdlLlApKVxyXG4gICAgICAgICAgICAgICAgLy8gTW92ZSBkb3duIHRoZSBncmFwaFxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFJpZ2h0Q2hpbGQuTG9jYXRlKGVkZ2UpO1xyXG5cclxuICAgICAgICAgICAgaWYgKF9lZGdlLklzQmVsb3coZWRnZS5QKSlcclxuICAgICAgICAgICAgICAgIC8vIE1vdmUgdXAgdGhlIGdyYXBoXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gTGVmdENoaWxkLkxvY2F0ZShlZGdlKTtcclxuXHJcbiAgICAgICAgICAgIC8vIHMgYW5kIHNlZ21lbnQgc2hhcmUgdGhlIHNhbWUgZW5kcG9pbnQsIHBcclxuICAgICAgICAgICAgaWYgKGVkZ2UuU2xvcGUgPCBfZWRnZS5TbG9wZSlcclxuICAgICAgICAgICAgICAgIC8vIE1vdmUgZG93biB0aGUgZ3JhcGhcclxuICAgICAgICAgICAgICAgIHJldHVybiBSaWdodENoaWxkLkxvY2F0ZShlZGdlKTtcclxuXHJcbiAgICAgICAgICAgIC8vIE1vdmUgdXAgdGhlIGdyYXBoXHJcbiAgICAgICAgICAgIHJldHVybiBMZWZ0Q2hpbGQuTG9jYXRlKGVkZ2UpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBpbnRlcm5hbCBjbGFzcyBUcmlhbmd1bGF0b3JcclxuICAgIHtcclxuICAgICAgICAvLyBUcmFwZXpvaWQgZGVjb21wb3NpdGlvbiBsaXN0XHJcbiAgICAgICAgcHVibGljIExpc3Q8VHJhcGV6b2lkPiBUcmFwZXpvaWRzO1xyXG4gICAgICAgIHB1YmxpYyBMaXN0PExpc3Q8UG9pbnQ+PiBUcmlhbmdsZXM7XHJcblxyXG4gICAgICAgIC8vIEluaXRpYWxpemUgdHJhcGV6b2lkYWwgbWFwIGFuZCBxdWVyeSBzdHJ1Y3R1cmVcclxuICAgICAgICBwcml2YXRlIFRyYXBlem9pZCBfYm91bmRpbmdCb3g7XHJcbiAgICAgICAgcHJpdmF0ZSBMaXN0PEVkZ2U+IF9lZGdlTGlzdDtcclxuICAgICAgICBwcml2YXRlIFF1ZXJ5R3JhcGggX3F1ZXJ5R3JhcGg7XHJcbiAgICAgICAgcHJpdmF0ZSBmbG9hdCBfc2hlZXIgPSAwLjAwMWY7XHJcbiAgICAgICAgcHJpdmF0ZSBUcmFwZXpvaWRhbE1hcCBfdHJhcGV6b2lkYWxNYXA7XHJcbiAgICAgICAgcHJpdmF0ZSBMaXN0PE1vbm90b25lTW91bnRhaW4+IF94TW9ub1BvbHk7XHJcblxyXG4gICAgICAgIHB1YmxpYyBUcmlhbmd1bGF0b3IoTGlzdDxQb2ludD4gcG9seUxpbmUsIGZsb2F0IHNoZWVyKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgX3NoZWVyID0gc2hlZXI7XHJcbiAgICAgICAgICAgIFRyaWFuZ2xlcyA9IG5ldyBMaXN0PExpc3Q8UG9pbnQ+PigpO1xyXG4gICAgICAgICAgICBUcmFwZXpvaWRzID0gbmV3IExpc3Q8VHJhcGV6b2lkPigpO1xyXG4gICAgICAgICAgICBfeE1vbm9Qb2x5ID0gbmV3IExpc3Q8TW9ub3RvbmVNb3VudGFpbj4oKTtcclxuICAgICAgICAgICAgX2VkZ2VMaXN0ID0gSW5pdEVkZ2VzKHBvbHlMaW5lKTtcclxuICAgICAgICAgICAgX3RyYXBlem9pZGFsTWFwID0gbmV3IFRyYXBlem9pZGFsTWFwKCk7XHJcbiAgICAgICAgICAgIF9ib3VuZGluZ0JveCA9IF90cmFwZXpvaWRhbE1hcC5Cb3VuZGluZ0JveChfZWRnZUxpc3QpO1xyXG4gICAgICAgICAgICBfcXVlcnlHcmFwaCA9IG5ldyBRdWVyeUdyYXBoKFNpbmsuSXNpbmsoX2JvdW5kaW5nQm94KSk7XHJcblxyXG4gICAgICAgICAgICBQcm9jZXNzKCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBCdWlsZCB0aGUgdHJhcGV6b2lkYWwgbWFwIGFuZCBxdWVyeSBncmFwaFxyXG4gICAgICAgIHByaXZhdGUgdm9pZCBQcm9jZXNzKClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGZvcmVhY2ggKEVkZ2UgZWRnZSBpbiBfZWRnZUxpc3QpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIExpc3Q8VHJhcGV6b2lkPiB0cmFwcyA9IF9xdWVyeUdyYXBoLkZvbGxvd0VkZ2UoZWRnZSk7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gUmVtb3ZlIHRyYXBlem9pZHMgZnJvbSB0cmFwZXpvaWRhbCBNYXBcclxuICAgICAgICAgICAgICAgIGZvcmVhY2ggKFRyYXBlem9pZCB0IGluIHRyYXBzKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIF90cmFwZXpvaWRhbE1hcC5NYXAuUmVtb3ZlKHQpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBib29sIGNwID0gdC5Db250YWlucyhlZGdlLlApO1xyXG4gICAgICAgICAgICAgICAgICAgIGJvb2wgY3EgPSB0LkNvbnRhaW5zKGVkZ2UuUSk7XHJcbiAgICAgICAgICAgICAgICAgICAgVHJhcGV6b2lkW10gdExpc3Q7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChjcCAmJiBjcSlcclxuICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRMaXN0ID0gX3RyYXBlem9pZGFsTWFwLkNhc2UxKHQsIGVkZ2UpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBfcXVlcnlHcmFwaC5DYXNlMSh0LlNpbmssIGVkZ2UsIHRMaXN0KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoY3AgJiYgIWNxKVxyXG4gICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdExpc3QgPSBfdHJhcGV6b2lkYWxNYXAuQ2FzZTIodCwgZWRnZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF9xdWVyeUdyYXBoLkNhc2UyKHQuU2luaywgZWRnZSwgdExpc3QpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICghY3AgJiYgIWNxKVxyXG4gICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdExpc3QgPSBfdHJhcGV6b2lkYWxNYXAuQ2FzZTModCwgZWRnZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF9xdWVyeUdyYXBoLkNhc2UzKHQuU2luaywgZWRnZSwgdExpc3QpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0TGlzdCA9IF90cmFwZXpvaWRhbE1hcC5DYXNlNCh0LCBlZGdlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgX3F1ZXJ5R3JhcGguQ2FzZTQodC5TaW5rLCBlZGdlLCB0TGlzdCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIC8vIEFkZCBuZXcgdHJhcGV6b2lkcyB0byBtYXBcclxuICAgICAgICAgICAgICAgICAgICBmb3JlYWNoIChUcmFwZXpvaWQgeSBpbiB0TGlzdClcclxuICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF90cmFwZXpvaWRhbE1hcC5NYXAuQWRkKHkpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIF90cmFwZXpvaWRhbE1hcC5DbGVhcigpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBNYXJrIG91dHNpZGUgdHJhcGV6b2lkc1xyXG4gICAgICAgICAgICBmb3JlYWNoIChUcmFwZXpvaWQgdCBpbiBfdHJhcGV6b2lkYWxNYXAuTWFwKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBNYXJrT3V0c2lkZSh0KTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gQ29sbGVjdCBpbnRlcmlvciB0cmFwZXpvaWRzXHJcbiAgICAgICAgICAgIGZvcmVhY2ggKFRyYXBlem9pZCB0IGluIF90cmFwZXpvaWRhbE1hcC5NYXApXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGlmICh0Lkluc2lkZSlcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBUcmFwZXpvaWRzLkFkZCh0KTtcclxuICAgICAgICAgICAgICAgICAgICB0LkFkZFBvaW50cygpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBHZW5lcmF0ZSB0aGUgdHJpYW5nbGVzXHJcbiAgICAgICAgICAgIENyZWF0ZU1vdW50YWlucygpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gQnVpbGQgYSBsaXN0IG9mIHgtbW9ub3RvbmUgbW91bnRhaW5zXHJcbiAgICAgICAgcHJpdmF0ZSB2b2lkIENyZWF0ZU1vdW50YWlucygpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBmb3JlYWNoIChFZGdlIGVkZ2UgaW4gX2VkZ2VMaXN0KVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBpZiAoZWRnZS5NUG9pbnRzLkNvdW50ID4gMilcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBNb25vdG9uZU1vdW50YWluIG1vdW50YWluID0gbmV3IE1vbm90b25lTW91bnRhaW4oKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gU29ydGluZyBpcyBhIHBlcmZyb21hbmNlIGhpdC4gTGl0ZXJhdHVyZSBzYXlzIHRoaXMgY2FuIGJlIGFjY29tcGxpc2VkIGluXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gbGluZWFyIHRpbWUsIGFsdGhvdWdoIEkgZG9uJ3Qgc2VlIGEgd2F5IGFyb3VuZCB1c2luZyB0cmFkaXRpb25hbCBtZXRob2RzXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gd2hlbiB1c2luZyBhIHJhbmRvbWl6ZWQgaW5jcmVtZW50YWwgYWxnb3JpdGhtXHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIEluc2VydGlvbiBzb3J0IGlzIG9uZSBvZiB0aGUgZmFzdGVzdCBhbGdvcml0aG1zIGZvciBzb3J0aW5nIGFycmF5cyBjb250YWluaW5nIFxyXG4gICAgICAgICAgICAgICAgICAgIC8vIGZld2VyIHRoYW4gdGVuIGVsZW1lbnRzLCBvciBmb3IgbGlzdHMgdGhhdCBhcmUgYWxyZWFkeSBtb3N0bHkgc29ydGVkLlxyXG5cclxuICAgICAgICAgICAgICAgICAgICBMaXN0PFBvaW50PiBwb2ludHMgPSBuZXcgTGlzdDxQb2ludD4oZWRnZS5NUG9pbnRzKTtcclxuICAgICAgICAgICAgICAgICAgICBwb2ludHMuU29ydCgoZ2xvYmFsOjpTeXN0ZW0uQ29tcGFyaXNvbjxnbG9iYWw6OkZhcnNlZXJQaHlzaWNzLkNvbW1vbi5EZWNvbXBvc2l0aW9uLlBvaW50PikoKHAxLCBwMikgPT4gcDEuWC5Db21wYXJlVG8ocDIuWCkpKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgZm9yZWFjaCAoUG9pbnQgcCBpbiBwb2ludHMpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1vdW50YWluLkFkZChwKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gVHJpYW5ndWxhdGUgbW9ub3RvbmUgbW91bnRhaW5cclxuICAgICAgICAgICAgICAgICAgICBtb3VudGFpbi5Qcm9jZXNzKCk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIEV4dHJhY3QgdGhlIHRyaWFuZ2xlcyBpbnRvIGEgc2luZ2xlIGxpc3RcclxuICAgICAgICAgICAgICAgICAgICBmb3JlYWNoIChMaXN0PFBvaW50PiB0IGluIG1vdW50YWluLlRyaWFuZ2xlcylcclxuICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIFRyaWFuZ2xlcy5BZGQodCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICBfeE1vbm9Qb2x5LkFkZChtb3VudGFpbik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIE1hcmsgdGhlIG91dHNpZGUgdHJhcGV6b2lkcyBzdXJyb3VuZGluZyB0aGUgcG9seWdvblxyXG4gICAgICAgIHByaXZhdGUgdm9pZCBNYXJrT3V0c2lkZShUcmFwZXpvaWQgdClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGlmICh0LlRvcCA9PSBfYm91bmRpbmdCb3guVG9wIHx8IHQuQm90dG9tID09IF9ib3VuZGluZ0JveC5Cb3R0b20pXHJcbiAgICAgICAgICAgICAgICB0LlRyaW1OZWlnaGJvcnMoKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIENyZWF0ZSBzZWdtZW50cyBhbmQgY29ubmVjdCBlbmQgcG9pbnRzOyB1cGRhdGUgZWRnZSBldmVudCBwb2ludGVyXHJcbiAgICAgICAgcHJpdmF0ZSBMaXN0PEVkZ2U+IEluaXRFZGdlcyhMaXN0PFBvaW50PiBwb2ludHMpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBMaXN0PEVkZ2U+IGVkZ2VzID0gbmV3IExpc3Q8RWRnZT4oKTtcclxuXHJcbiAgICAgICAgICAgIGZvciAoaW50IGkgPSAwOyBpIDwgcG9pbnRzLkNvdW50IC0gMTsgaSsrKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBlZGdlcy5BZGQobmV3IEVkZ2UocG9pbnRzW2ldLCBwb2ludHNbaSArIDFdKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWRnZXMuQWRkKG5ldyBFZGdlKHBvaW50c1swXSwgcG9pbnRzW3BvaW50cy5Db3VudCAtIDFdKSk7XHJcbiAgICAgICAgICAgIHJldHVybiBPcmRlclNlZ21lbnRzKGVkZ2VzKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHByaXZhdGUgTGlzdDxFZGdlPiBPcmRlclNlZ21lbnRzKExpc3Q8RWRnZT4gZWRnZUlucHV0KVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgLy8gSWdub3JlIHZlcnRpY2FsIHNlZ21lbnRzIVxyXG4gICAgICAgICAgICBMaXN0PEVkZ2U+IGVkZ2VzID0gbmV3IExpc3Q8RWRnZT4oKTtcclxuXHJcbiAgICAgICAgICAgIGZvcmVhY2ggKEVkZ2UgZSBpbiBlZGdlSW5wdXQpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIFBvaW50IHAgPSBTaGVhclRyYW5zZm9ybShlLlApO1xyXG4gICAgICAgICAgICAgICAgUG9pbnQgcSA9IFNoZWFyVHJhbnNmb3JtKGUuUSk7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gUG9pbnQgcCBtdXN0IGJlIHRvIHRoZSBsZWZ0IG9mIHBvaW50IHFcclxuICAgICAgICAgICAgICAgIGlmIChwLlggPiBxLlgpXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgZWRnZXMuQWRkKG5ldyBFZGdlKHEsIHApKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHAuWCA8IHEuWClcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBlZGdlcy5BZGQobmV3IEVkZ2UocCwgcSkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBSYW5kb21pemVkIHRyaWFuZ3VsYXRpb24gaW1wcm92ZXMgcGVyZm9ybWFuY2VcclxuICAgICAgICAgICAgLy8gU2VlIFNlaWRlbCdzIHBhcGVyLCBvciBPJ1JvdXJrZSdzIGJvb2ssIHAuIDU3IFxyXG4gICAgICAgICAgICBTaHVmZmxlPGdsb2JhbDo6RmFyc2VlclBoeXNpY3MuQ29tbW9uLkRlY29tcG9zaXRpb24uRWRnZT4oZWRnZXMpO1xyXG4gICAgICAgICAgICByZXR1cm4gZWRnZXM7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwcml2YXRlIHN0YXRpYyB2b2lkIFNodWZmbGU8VD4oSUxpc3Q8VD4gbGlzdClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIFJhbmRvbSBybmcgPSBuZXcgUmFuZG9tKCk7XHJcbiAgICAgICAgICAgIGludCBuID0gbGlzdC5Db3VudDtcclxuICAgICAgICAgICAgd2hpbGUgKG4gPiAxKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBuLS07XHJcbiAgICAgICAgICAgICAgICBpbnQgayA9IHJuZy5OZXh0KG4gKyAxKTtcclxuICAgICAgICAgICAgICAgIFQgdmFsdWUgPSBsaXN0W2tdO1xyXG4gICAgICAgICAgICAgICAgbGlzdFtrXSA9IGxpc3Rbbl07XHJcbiAgICAgICAgICAgICAgICBsaXN0W25dID0gdmFsdWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIFByZXZlbnRzIGFueSB0d28gZGlzdGluY3QgZW5kcG9pbnRzIGZyb20gbHlpbmcgb24gYSBjb21tb24gdmVydGljYWwgbGluZSwgYW5kIGF2b2lkaW5nXHJcbiAgICAgICAgLy8gdGhlIGRlZ2VuZXJhdGUgY2FzZS4gU2VlIE1hcmsgZGUgQmVyZyBldCBhbCwgQ2hhcHRlciA2LjNcclxuICAgICAgICBwcml2YXRlIFBvaW50IFNoZWFyVHJhbnNmb3JtKFBvaW50IHBvaW50KVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBQb2ludChwb2ludC5YICsgX3NoZWVyICogcG9pbnQuWSwgcG9pbnQuWSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59IiwidXNpbmcgU3lzdGVtLkNvbGxlY3Rpb25zLkdlbmVyaWM7XHJcbnVzaW5nIE1pY3Jvc29mdC5YbmEuRnJhbWV3b3JrO1xyXG5cclxubmFtZXNwYWNlIEZhcnNlZXJQaHlzaWNzLkNvbW1vbi5EZWNvbXBvc2l0aW9uXHJcbntcclxuICAgIC8vIE9yaWdpbmFsIGNvZGUgY2FuIGJlIGZvdW5kIGhlcmU6IGh0dHA6Ly93d3cuZmxpcGNvZGUuY29tL2FyY2hpdmVzL0VmZmljaWVudF9Qb2x5Z29uX1RyaWFuZ3VsYXRpb24uc2h0bWxcclxuXHJcbiAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAvLy8gVHJpYW5ndWxhdGVzIGEgcG9seWdvbiBpbnRvIHRyaWFuZ2xlcy5cclxuICAgIC8vLyBEb2Vzbid0IGhhbmRsZSBob2xlcy5cclxuICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICBwdWJsaWMgc3RhdGljIGNsYXNzIEZsaXBjb2RlRGVjb21wb3NlclxyXG4gICAge1xyXG4gICAgICAgIHByaXZhdGUgc3RhdGljIFZlY3RvcjIgX3RtcEE7XHJcbiAgICAgICAgcHJpdmF0ZSBzdGF0aWMgVmVjdG9yMiBfdG1wQjtcclxuICAgICAgICBwcml2YXRlIHN0YXRpYyBWZWN0b3IyIF90bXBDO1xyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIENoZWNrIGlmIHRoZSBwb2ludCBQIGlzIGluc2lkZSB0aGUgdHJpYW5nbGUgZGVmaW5lZCBieVxyXG4gICAgICAgIC8vLyB0aGUgcG9pbnRzIEEsIEIsIENcclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cImFcIj5UaGUgQSBwb2ludC48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cImJcIj5UaGUgQiBwb2ludC48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cImNcIj5UaGUgQyBwb2ludC48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cInBcIj5UaGUgcG9pbnQgdG8gYmUgdGVzdGVkLjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxyZXR1cm5zPlRydWUgaWYgdGhlIHBvaW50IGlzIGluc2lkZSB0aGUgdHJpYW5nbGU8L3JldHVybnM+XHJcbiAgICAgICAgcHJpdmF0ZSBzdGF0aWMgYm9vbCBJbnNpZGVUcmlhbmdsZShyZWYgVmVjdG9yMiBhLCByZWYgVmVjdG9yMiBiLCByZWYgVmVjdG9yMiBjLCByZWYgVmVjdG9yMiBwKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgLy9BIGNyb3NzIGJwXHJcbiAgICAgICAgICAgIGZsb2F0IGFicCA9IChjLlggLSBiLlgpICogKHAuWSAtIGIuWSkgLSAoYy5ZIC0gYi5ZKSAqIChwLlggLSBiLlgpO1xyXG5cclxuICAgICAgICAgICAgLy9BIGNyb3NzIGFwXHJcbiAgICAgICAgICAgIGZsb2F0IGFhcCA9IChiLlggLSBhLlgpICogKHAuWSAtIGEuWSkgLSAoYi5ZIC0gYS5ZKSAqIChwLlggLSBhLlgpO1xyXG5cclxuICAgICAgICAgICAgLy9iIGNyb3NzIGNwXHJcbiAgICAgICAgICAgIGZsb2F0IGJjcCA9IChhLlggLSBjLlgpICogKHAuWSAtIGMuWSkgLSAoYS5ZIC0gYy5ZKSAqIChwLlggLSBjLlgpO1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuICgoYWJwID49IDAuMGYpICYmIChiY3AgPj0gMC4wZikgJiYgKGFhcCA+PSAwLjBmKSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIEN1dCBhIHRoZSBjb250b3VyIGFuZCBhZGQgYSB0cmlhbmdsZSBpbnRvIFYgdG8gZGVzY3JpYmUgdGhlIFxyXG4gICAgICAgIC8vLyBsb2NhdGlvbiBvZiB0aGUgY3V0XHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJjb250b3VyXCI+VGhlIGxpc3Qgb2YgcG9pbnRzIGRlZmluaW5nIHRoZSBwb2x5Z29uPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJ1XCI+VGhlIGluZGV4IG9mIHRoZSBmaXJzdCBwb2ludDwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwidlwiPlRoZSBpbmRleCBvZiB0aGUgc2Vjb25kIHBvaW50PC9wYXJhbT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJ3XCI+VGhlIGluZGV4IG9mIHRoZSB0aGlyZCBwb2ludDwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwiblwiPlRoZSBudW1iZXIgb2YgZWxlbWVudHMgaW4gdGhlIGFycmF5LjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwiVlwiPlRoZSBhcnJheSB0byBwb3B1bGF0ZSB3aXRoIGluZGljaWVzIG9mIHRyaWFuZ2xlcy48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cmV0dXJucz5UcnVlIGlmIGEgdHJpYW5nbGUgd2FzIGZvdW5kPC9yZXR1cm5zPlxyXG4gICAgICAgIHByaXZhdGUgc3RhdGljIGJvb2wgU25pcChWZXJ0aWNlcyBjb250b3VyLCBpbnQgdSwgaW50IHYsIGludCB3LCBpbnQgbixcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW50W10gVilcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGlmIChTZXR0aW5ncy5FcHNpbG9uID4gTWF0aFV0aWxzLkFyZWEocmVmIF90bXBBLCByZWYgX3RtcEIsIHJlZiBfdG1wQykpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgZm9yIChpbnQgcCA9IDA7IHAgPCBuOyBwKyspXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGlmICgocCA9PSB1KSB8fCAocCA9PSB2KSB8fCAocCA9PSB3KSlcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBWZWN0b3IyIHBvaW50ID0gY29udG91cltWW3BdXTtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoSW5zaWRlVHJpYW5nbGUocmVmIF90bXBBLCByZWYgX3RtcEIsIHJlZiBfdG1wQywgcmVmIHBvaW50KSlcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBEZWNvbXBvc2UgdGhlIHBvbHlnb24gaW50byB0cmlhbmdsZXNcclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cImNvbnRvdXJcIj5UaGUgbGlzdCBvZiBwb2ludHMgZGVzY3JpYmluZyB0aGUgcG9seWdvbjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxyZXR1cm5zPjwvcmV0dXJucz5cclxuICAgICAgICBwdWJsaWMgc3RhdGljIExpc3Q8VmVydGljZXM+IENvbnZleFBhcnRpdGlvbihWZXJ0aWNlcyBjb250b3VyKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgaW50IG4gPSBjb250b3VyLkNvdW50O1xyXG4gICAgICAgICAgICBpZiAobiA8IDMpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IExpc3Q8VmVydGljZXM+KCk7XHJcblxyXG4gICAgICAgICAgICBpbnRbXSBWID0gbmV3IGludFtuXTtcclxuXHJcbiAgICAgICAgICAgIC8vIFdlIHdhbnQgYSBjb3VudGVyLWNsb2Nrd2lzZSBwb2x5Z29uIGluIFZcclxuICAgICAgICAgICAgaWYgKGNvbnRvdXIuSXNDb3VudGVyQ2xvY2tXaXNlKCkpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGZvciAoaW50IHYgPSAwOyB2IDwgbjsgdisrKVxyXG4gICAgICAgICAgICAgICAgICAgIFZbdl0gPSB2O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgZm9yIChpbnQgdiA9IDA7IHYgPCBuOyB2KyspXHJcbiAgICAgICAgICAgICAgICAgICAgVlt2XSA9IChuIC0gMSkgLSB2O1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpbnQgbnYgPSBuO1xyXG5cclxuICAgICAgICAgICAgLy8gUmVtb3ZlIG52LTIgVmVydGljZXMsIGNyZWF0aW5nIDEgdHJpYW5nbGUgZXZlcnkgdGltZVxyXG4gICAgICAgICAgICBpbnQgY291bnQgPSAyICogbnY7IC8qIGVycm9yIGRldGVjdGlvbiAqL1xyXG5cclxuICAgICAgICAgICAgTGlzdDxWZXJ0aWNlcz4gcmVzdWx0ID0gbmV3IExpc3Q8VmVydGljZXM+KCk7XHJcblxyXG4gICAgICAgICAgICBmb3IgKGludCB2ID0gbnYgLSAxOyBudiA+IDI7IClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgLy8gSWYgd2UgbG9vcCwgaXQgaXMgcHJvYmFibHkgYSBub24tc2ltcGxlIHBvbHlnb24gXHJcbiAgICAgICAgICAgICAgICBpZiAoMCA+PSAoY291bnQtLSkpXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gVHJpYW5ndWxhdGU6IEVSUk9SIC0gcHJvYmFibGUgYmFkIHBvbHlnb24hXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBMaXN0PFZlcnRpY2VzPigpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIC8vIFRocmVlIGNvbnNlY3V0aXZlIHZlcnRpY2VzIGluIGN1cnJlbnQgcG9seWdvbiwgPHUsdix3PlxyXG4gICAgICAgICAgICAgICAgaW50IHUgPSB2O1xyXG4gICAgICAgICAgICAgICAgaWYgKG52IDw9IHUpXHJcbiAgICAgICAgICAgICAgICAgICAgdSA9IDA7IC8vIFByZXZpb3VzIFxyXG4gICAgICAgICAgICAgICAgdiA9IHUgKyAxO1xyXG4gICAgICAgICAgICAgICAgaWYgKG52IDw9IHYpXHJcbiAgICAgICAgICAgICAgICAgICAgdiA9IDA7IC8vIE5ldyB2ICAgXHJcbiAgICAgICAgICAgICAgICBpbnQgdyA9IHYgKyAxO1xyXG4gICAgICAgICAgICAgICAgaWYgKG52IDw9IHcpXHJcbiAgICAgICAgICAgICAgICAgICAgdyA9IDA7IC8vIE5leHQgXHJcblxyXG4gICAgICAgICAgICAgICAgX3RtcEEgPSBjb250b3VyW1ZbdV1dO1xyXG4gICAgICAgICAgICAgICAgX3RtcEIgPSBjb250b3VyW1Zbdl1dO1xyXG4gICAgICAgICAgICAgICAgX3RtcEMgPSBjb250b3VyW1Zbd11dO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmIChTbmlwKGNvbnRvdXIsIHUsIHYsIHcsIG52LCBWKSlcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBpbnQgcywgdDtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gT3V0cHV0IFRyaWFuZ2xlXHJcbiAgICAgICAgICAgICAgICAgICAgVmVydGljZXMgdHJpYW5nbGUgPSBuZXcgVmVydGljZXMoMyk7XHJcbiAgICAgICAgICAgICAgICAgICAgdHJpYW5nbGUuQWRkKF90bXBBKTtcclxuICAgICAgICAgICAgICAgICAgICB0cmlhbmdsZS5BZGQoX3RtcEIpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRyaWFuZ2xlLkFkZChfdG1wQyk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LkFkZCh0cmlhbmdsZSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIFJlbW92ZSB2IGZyb20gcmVtYWluaW5nIHBvbHlnb24gXHJcbiAgICAgICAgICAgICAgICAgICAgZm9yIChzID0gdiwgdCA9IHYgKyAxOyB0IDwgbnY7IHMrKywgdCsrKVxyXG4gICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgVltzXSA9IFZbdF07XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIG52LS07XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIFJlc2V0IGVycm9yIGRldGVjdGlvbiBjb3VudGVyXHJcbiAgICAgICAgICAgICAgICAgICAgY291bnQgPSAyICogbnY7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59IiwidXNpbmcgU3lzdGVtO1xyXG51c2luZyBTeXN0ZW0uQ29sbGVjdGlvbnMuR2VuZXJpYztcclxudXNpbmcgU3lzdGVtLkRpYWdub3N0aWNzO1xyXG51c2luZyBTeXN0ZW0uVGV4dDtcclxudXNpbmcgRmFyc2VlclBoeXNpY3MuQ29sbGlzaW9uO1xyXG51c2luZyBNaWNyb3NvZnQuWG5hLkZyYW1ld29yaztcclxuXHJcbm5hbWVzcGFjZSBGYXJzZWVyUGh5c2ljcy5Db21tb25cclxue1xyXG4jaWYgIShYQk9YMzYwKVxyXG4gICAgW0RlYnVnZ2VyRGlzcGxheShcIkNvdW50ID0ge0NvdW50fSBWZXJ0aWNlcyA9IHtUb1N0cmluZygpfVwiKV1cclxuI2VuZGlmXHJcbiAgICBwdWJsaWMgY2xhc3MgVmVydGljZXMgOiBMaXN0PFZlY3RvcjI+XHJcbiAgICB7XHJcbiAgICAgICAgcHVibGljIFZlcnRpY2VzKClcclxuICAgICAgICB7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwdWJsaWMgVmVydGljZXMoaW50IGNhcGFjaXR5KVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgQ2FwYWNpdHkgPSBjYXBhY2l0eTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHB1YmxpYyBWZXJ0aWNlcyhWZWN0b3IyW10gdmVjdG9yMilcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGZvciAoaW50IGkgPSAwOyBpIDwgdmVjdG9yMi5MZW5ndGg7IGkrKylcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgQWRkKHZlY3RvcjJbaV0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwdWJsaWMgVmVydGljZXMoSUxpc3Q8VmVjdG9yMj4gdmVydGljZXMpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBmb3IgKGludCBpID0gMDsgaSA8IHZlcnRpY2VzLkNvdW50OyBpKyspXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIEFkZCh2ZXJ0aWNlc1tpXSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gTmV4dHMgdGhlIGluZGV4LlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwiaW5kZXhcIj5UaGUgaW5kZXguPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHJldHVybnM+PC9yZXR1cm5zPlxyXG4gICAgICAgIHB1YmxpYyBpbnQgTmV4dEluZGV4KGludCBpbmRleClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGlmIChpbmRleCA9PSBDb3VudCAtIDEpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiAwO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBpbmRleCArIDE7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwdWJsaWMgVmVjdG9yMiBOZXh0VmVydGV4KGludCBpbmRleClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzW05leHRJbmRleChpbmRleCldO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBHZXRzIHRoZSBwcmV2aW91cyBpbmRleC5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cImluZGV4XCI+VGhlIGluZGV4LjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxyZXR1cm5zPjwvcmV0dXJucz5cclxuICAgICAgICBwdWJsaWMgaW50IFByZXZpb3VzSW5kZXgoaW50IGluZGV4KVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgaWYgKGluZGV4ID09IDApXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBDb3VudCAtIDE7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIGluZGV4IC0gMTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHB1YmxpYyBWZWN0b3IyIFByZXZpb3VzVmVydGV4KGludCBpbmRleClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzW1ByZXZpb3VzSW5kZXgoaW5kZXgpXTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gR2V0cyB0aGUgc2lnbmVkIGFyZWEuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHJldHVybnM+PC9yZXR1cm5zPlxyXG4gICAgICAgIHB1YmxpYyBmbG9hdCBHZXRTaWduZWRBcmVhKClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGludCBpO1xyXG4gICAgICAgICAgICBmbG9hdCBhcmVhID0gMDtcclxuXHJcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBDb3VudDsgaSsrKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBpbnQgaiA9IChpICsgMSkgJSBDb3VudDtcclxuICAgICAgICAgICAgICAgIGFyZWEgKz0gdGhpc1tpXS5YICogdGhpc1tqXS5ZO1xyXG4gICAgICAgICAgICAgICAgYXJlYSAtPSB0aGlzW2ldLlkgKiB0aGlzW2pdLlg7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgYXJlYSAvPSAyLjBmO1xyXG4gICAgICAgICAgICByZXR1cm4gYXJlYTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gR2V0cyB0aGUgYXJlYS5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8cmV0dXJucz48L3JldHVybnM+XHJcbiAgICAgICAgcHVibGljIGZsb2F0IEdldEFyZWEoKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgaW50IGk7XHJcbiAgICAgICAgICAgIGZsb2F0IGFyZWEgPSAwO1xyXG5cclxuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IENvdW50OyBpKyspXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGludCBqID0gKGkgKyAxKSAlIENvdW50O1xyXG4gICAgICAgICAgICAgICAgYXJlYSArPSB0aGlzW2ldLlggKiB0aGlzW2pdLlk7XHJcbiAgICAgICAgICAgICAgICBhcmVhIC09IHRoaXNbaV0uWSAqIHRoaXNbal0uWDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBhcmVhIC89IDIuMGY7XHJcbiAgICAgICAgICAgIHJldHVybiAoYXJlYSA8IDAgPyAtYXJlYSA6IGFyZWEpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBHZXRzIHRoZSBjZW50cm9pZC5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8cmV0dXJucz48L3JldHVybnM+XHJcbiAgICAgICAgcHVibGljIFZlY3RvcjIgR2V0Q2VudHJvaWQoKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgLy8gU2FtZSBhbGdvcml0aG0gaXMgdXNlZCBieSBCb3gyRFxyXG5cclxuICAgICAgICAgICAgVmVjdG9yMiBjID0gVmVjdG9yMi5aZXJvO1xyXG4gICAgICAgICAgICBmbG9hdCBhcmVhID0gMC4wZjtcclxuXHJcbiAgICAgICAgICAgIGNvbnN0IGZsb2F0IGludjMgPSAxLjBmIC8gMy4wZjtcclxuICAgICAgICAgICAgVmVjdG9yMiBwUmVmID0gVmVjdG9yMi5aZXJvO1xyXG4gICAgICAgICAgICBmb3IgKGludCBpID0gMDsgaSA8IENvdW50OyArK2kpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIC8vIFRyaWFuZ2xlIHZlcnRpY2VzLlxyXG4gICAgICAgICAgICAgICAgVmVjdG9yMiBwMSA9IHBSZWY7XHJcbiAgICAgICAgICAgICAgICBWZWN0b3IyIHAyID0gdGhpc1tpXTtcclxuICAgICAgICAgICAgICAgIFZlY3RvcjIgcDMgPSBpICsgMSA8IENvdW50ID8gdGhpc1tpICsgMV0gOiB0aGlzWzBdO1xyXG5cclxuICAgICAgICAgICAgICAgIFZlY3RvcjIgZTEgPSBwMiAtIHAxO1xyXG4gICAgICAgICAgICAgICAgVmVjdG9yMiBlMiA9IHAzIC0gcDE7XHJcblxyXG4gICAgICAgICAgICAgICAgZmxvYXQgRCA9IE1hdGhVdGlscy5Dcm9zcyhlMSwgZTIpO1xyXG5cclxuICAgICAgICAgICAgICAgIGZsb2F0IHRyaWFuZ2xlQXJlYSA9IDAuNWYgKiBEO1xyXG4gICAgICAgICAgICAgICAgYXJlYSArPSB0cmlhbmdsZUFyZWE7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gQXJlYSB3ZWlnaHRlZCBjZW50cm9pZFxyXG4gICAgICAgICAgICAgICAgYyArPSB0cmlhbmdsZUFyZWEgKiBpbnYzICogKHAxICsgcDIgKyBwMyk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIENlbnRyb2lkXHJcbiAgICAgICAgICAgIGMgKj0gMS4wZiAvIGFyZWE7XHJcbiAgICAgICAgICAgIHJldHVybiBjO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBHZXRzIHRoZSByYWRpdXMgYmFzZWQgb24gYXJlYS5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8cmV0dXJucz48L3JldHVybnM+XHJcbiAgICAgICAgcHVibGljIGZsb2F0IEdldFJhZGl1cygpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBmbG9hdCBhcmVhID0gR2V0U2lnbmVkQXJlYSgpO1xyXG5cclxuICAgICAgICAgICAgZG91YmxlIHJhZGl1c1NxcmQgPSAoZG91YmxlKWFyZWEgLyBNYXRoSGVscGVyLlBpO1xyXG4gICAgICAgICAgICBpZiAocmFkaXVzU3FyZCA8IDApXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHJhZGl1c1NxcmQgKj0gLTE7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHJldHVybiAoZmxvYXQpTWF0aC5TcXJ0KHJhZGl1c1NxcmQpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBSZXR1cm5zIGFuIEFBQkIgZm9yIHZlcnRleC5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8cmV0dXJucz48L3JldHVybnM+XHJcbiAgICAgICAgcHVibGljIEFBQkIgR2V0Q29sbGlzaW9uQm94KClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIEFBQkIgYWFiYjtcclxuICAgICAgICAgICAgVmVjdG9yMiBsb3dlckJvdW5kID0gbmV3IFZlY3RvcjIoZmxvYXQuTWF4VmFsdWUsIGZsb2F0Lk1heFZhbHVlKTtcclxuICAgICAgICAgICAgVmVjdG9yMiB1cHBlckJvdW5kID0gbmV3IFZlY3RvcjIoZmxvYXQuTWluVmFsdWUsIGZsb2F0Lk1pblZhbHVlKTtcclxuXHJcbiAgICAgICAgICAgIGZvciAoaW50IGkgPSAwOyBpIDwgQ291bnQ7ICsraSlcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXNbaV0uWCA8IGxvd2VyQm91bmQuWClcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBsb3dlckJvdW5kLlggPSB0aGlzW2ldLlg7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpc1tpXS5YID4gdXBwZXJCb3VuZC5YKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIHVwcGVyQm91bmQuWCA9IHRoaXNbaV0uWDtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBpZiAodGhpc1tpXS5ZIDwgbG93ZXJCb3VuZC5ZKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIGxvd2VyQm91bmQuWSA9IHRoaXNbaV0uWTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmICh0aGlzW2ldLlkgPiB1cHBlckJvdW5kLlkpXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgdXBwZXJCb3VuZC5ZID0gdGhpc1tpXS5ZO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBhYWJiLkxvd2VyQm91bmQgPSBsb3dlckJvdW5kO1xyXG4gICAgICAgICAgICBhYWJiLlVwcGVyQm91bmQgPSB1cHBlckJvdW5kO1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIGFhYmI7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwdWJsaWMgdm9pZCBUcmFuc2xhdGUoVmVjdG9yMiB2ZWN0b3IpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBUcmFuc2xhdGUocmVmIHZlY3Rvcik7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIFRyYW5zbGF0ZXMgdGhlIHZlcnRpY2VzIHdpdGggdGhlIHNwZWNpZmllZCB2ZWN0b3IuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJ2ZWN0b3JcIj5UaGUgdmVjdG9yLjwvcGFyYW0+XHJcbiAgICAgICAgcHVibGljIHZvaWQgVHJhbnNsYXRlKHJlZiBWZWN0b3IyIHZlY3RvcilcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGZvciAoaW50IGkgPSAwOyBpIDwgQ291bnQ7IGkrKylcclxuICAgICAgICAgICAgICAgIHRoaXNbaV0gPSBWZWN0b3IyLkFkZCh0aGlzW2ldLCB2ZWN0b3IpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBTY2FsZXMgdGhlIHZlcnRpY2VzIHdpdGggdGhlIHNwZWNpZmllZCB2ZWN0b3IuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJ2YWx1ZVwiPlRoZSBWYWx1ZS48L3BhcmFtPlxyXG4gICAgICAgIHB1YmxpYyB2b2lkIFNjYWxlKHJlZiBWZWN0b3IyIHZhbHVlKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgZm9yIChpbnQgaSA9IDA7IGkgPCBDb3VudDsgaSsrKVxyXG4gICAgICAgICAgICAgICAgdGhpc1tpXSA9IFZlY3RvcjIuTXVsdGlwbHkodGhpc1tpXSwgdmFsdWUpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBSb3RhdGUgdGhlIHZlcnRpY2VzIHdpdGggdGhlIGRlZmluZWQgdmFsdWUgaW4gcmFkaWFucy5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cInZhbHVlXCI+VGhlIGFtb3VudCB0byByb3RhdGUgYnkgaW4gcmFkaWFucy48L3BhcmFtPlxyXG4gICAgICAgIHB1YmxpYyB2b2lkIFJvdGF0ZShmbG9hdCB2YWx1ZSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIE1hdHJpeCByb3RhdGlvbk1hdHJpeDtcclxuICAgICAgICAgICAgTWF0cml4LkNyZWF0ZVJvdGF0aW9uWih2YWx1ZSwgb3V0IHJvdGF0aW9uTWF0cml4KTtcclxuXHJcbiAgICAgICAgICAgIGZvciAoaW50IGkgPSAwOyBpIDwgQ291bnQ7IGkrKylcclxuICAgICAgICAgICAgICAgIHRoaXNbaV0gPSBWZWN0b3IyLlRyYW5zZm9ybSh0aGlzW2ldLCByb3RhdGlvbk1hdHJpeCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIEFzc3VtaW5nIHRoZSBwb2x5Z29uIGlzIHNpbXBsZTsgZGV0ZXJtaW5lcyB3aGV0aGVyIHRoZSBwb2x5Z29uIGlzIGNvbnZleC5cclxuICAgICAgICAvLy8gTk9URTogSXQgd2lsbCBhbHNvIHJldHVybiBmYWxzZSBpZiB0aGUgaW5wdXQgY29udGFpbnMgY29saW5lYXIgZWRnZXMuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHJldHVybnM+XHJcbiAgICAgICAgLy8vIFx0PGM+dHJ1ZTwvYz4gaWYgaXQgaXMgY29udmV4OyBvdGhlcndpc2UsIDxjPmZhbHNlPC9jPi5cclxuICAgICAgICAvLy8gPC9yZXR1cm5zPlxyXG4gICAgICAgIHB1YmxpYyBib29sIElzQ29udmV4KClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIC8vIEVuc3VyZSB0aGUgcG9seWdvbiBpcyBjb252ZXggYW5kIHRoZSBpbnRlcmlvclxyXG4gICAgICAgICAgICAvLyBpcyB0byB0aGUgbGVmdCBvZiBlYWNoIGVkZ2UuXHJcbiAgICAgICAgICAgIGZvciAoaW50IGkgPSAwOyBpIDwgQ291bnQ7ICsraSlcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgaW50IGkxID0gaTtcclxuICAgICAgICAgICAgICAgIGludCBpMiA9IGkgKyAxIDwgQ291bnQgPyBpICsgMSA6IDA7XHJcbiAgICAgICAgICAgICAgICBWZWN0b3IyIGVkZ2UgPSB0aGlzW2kyXSAtIHRoaXNbaTFdO1xyXG5cclxuICAgICAgICAgICAgICAgIGZvciAoaW50IGogPSAwOyBqIDwgQ291bnQ7ICsrailcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBEb24ndCBjaGVjayB2ZXJ0aWNlcyBvbiB0aGUgY3VycmVudCBlZGdlLlxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChqID09IGkxIHx8IGogPT0gaTIpXHJcbiAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIFZlY3RvcjIgciA9IHRoaXNbal0gLSB0aGlzW2kxXTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgZmxvYXQgcyA9IGVkZ2UuWCAqIHIuWSAtIGVkZ2UuWSAqIHIuWDtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHMgPD0gMC4wZilcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHVibGljIGJvb2wgSXNDb3VudGVyQ2xvY2tXaXNlKClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIC8vV2UganVzdCByZXR1cm4gdHJ1ZSBmb3IgbGluZXNcclxuICAgICAgICAgICAgaWYgKENvdW50IDwgMylcclxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIChHZXRTaWduZWRBcmVhKCkgPiAwLjBmKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gRm9yY2VzIGNvdW50ZXIgY2xvY2sgd2lzZSBvcmRlci5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIHB1YmxpYyB2b2lkIEZvcmNlQ291bnRlckNsb2NrV2lzZSgpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBpZiAoIUlzQ291bnRlckNsb2NrV2lzZSgpKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBSZXZlcnNlKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gQ2hlY2sgZm9yIGVkZ2UgY3Jvc3NpbmdzXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHJldHVybnM+PC9yZXR1cm5zPlxyXG4gICAgICAgIHB1YmxpYyBib29sIElzU2ltcGxlKClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGZvciAoaW50IGkgPSAwOyBpIDwgQ291bnQ7ICsraSlcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgaW50IGlwbHVzID0gKGkgKyAxID4gQ291bnQgLSAxKSA/IDAgOiBpICsgMTtcclxuICAgICAgICAgICAgICAgIFZlY3RvcjIgYTEgPSBuZXcgVmVjdG9yMih0aGlzW2ldLlgsIHRoaXNbaV0uWSk7XHJcbiAgICAgICAgICAgICAgICBWZWN0b3IyIGEyID0gbmV3IFZlY3RvcjIodGhpc1tpcGx1c10uWCwgdGhpc1tpcGx1c10uWSk7XHJcbiAgICAgICAgICAgICAgICBmb3IgKGludCBqID0gaSArIDE7IGogPCBDb3VudDsgKytqKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIGludCBqcGx1cyA9IChqICsgMSA+IENvdW50IC0gMSkgPyAwIDogaiArIDE7XHJcbiAgICAgICAgICAgICAgICAgICAgVmVjdG9yMiBiMSA9IG5ldyBWZWN0b3IyKHRoaXNbal0uWCwgdGhpc1tqXS5ZKTtcclxuICAgICAgICAgICAgICAgICAgICBWZWN0b3IyIGIyID0gbmV3IFZlY3RvcjIodGhpc1tqcGx1c10uWCwgdGhpc1tqcGx1c10uWSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIFZlY3RvcjIgdGVtcDtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKExpbmVUb29scy5MaW5lSW50ZXJzZWN0MihhMSwgYTIsIGIxLCBiMiwgb3V0IHRlbXApKVxyXG4gICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vVE9ETzogVGVzdFxyXG4gICAgICAgIC8vSW1wbGVtZW50YXRpb24gZm91bmQgaGVyZTogaHR0cDovL3d3dy5nYW1lZGV2Lm5ldC9jb21tdW5pdHkvZm9ydW1zL3RvcGljLmFzcD90b3BpY19pZD01NDg0NzdcclxuICAgICAgICBwdWJsaWMgYm9vbCBJc1NpbXBsZTIoKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgZm9yIChpbnQgaSA9IDA7IGkgPCBDb3VudDsgKytpKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBpZiAoaSA8IENvdW50IC0gMSlcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKGludCBoID0gaSArIDE7IGggPCBDb3VudDsgKytoKVxyXG4gICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gRG8gdHdvIHZlcnRpY2VzIGxpZSBvbiB0b3Agb2Ygb25lIGFub3RoZXI/XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzW2ldID09IHRoaXNbaF0pXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGludCBqID0gKGkgKyAxKSAlIENvdW50O1xyXG4gICAgICAgICAgICAgICAgVmVjdG9yMiBpVG9qID0gdGhpc1tqXSAtIHRoaXNbaV07XHJcbiAgICAgICAgICAgICAgICBWZWN0b3IyIGlUb2pOb3JtYWwgPSBuZXcgVmVjdG9yMihpVG9qLlksIC1pVG9qLlgpO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIGkgaXMgdGhlIGZpcnN0IHZlcnRleCBhbmQgaiBpcyB0aGUgc2Vjb25kXHJcbiAgICAgICAgICAgICAgICBpbnQgc3RhcnRLID0gKGogKyAxKSAlIENvdW50O1xyXG4gICAgICAgICAgICAgICAgaW50IGVuZEsgPSAoaSAtIDEgKyBDb3VudCkgJSBDb3VudDtcclxuICAgICAgICAgICAgICAgIGVuZEsgKz0gc3RhcnRLIDwgZW5kSyA/IDAgOiBzdGFydEsgKyAxO1xyXG4gICAgICAgICAgICAgICAgaW50IGsgPSBzdGFydEs7XHJcbiAgICAgICAgICAgICAgICBWZWN0b3IyIGlUb2sgPSB0aGlzW2tdIC0gdGhpc1tpXTtcclxuICAgICAgICAgICAgICAgIGJvb2wgb25MZWZ0U2lkZSA9IFZlY3RvcjIuRG90KGlUb2ssIGlUb2pOb3JtYWwpID49IDA7XHJcbiAgICAgICAgICAgICAgICBWZWN0b3IyIHByZXZLID0gdGhpc1trXTtcclxuICAgICAgICAgICAgICAgICsraztcclxuICAgICAgICAgICAgICAgIGZvciAoOyBrIDw9IGVuZEs7ICsraylcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBpbnQgbW9kSyA9IGsgJSBDb3VudDtcclxuICAgICAgICAgICAgICAgICAgICBpVG9rID0gdGhpc1ttb2RLXSAtIHRoaXNbaV07XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9uTGVmdFNpZGUgIT0gVmVjdG9yMi5Eb3QoaVRvaywgaVRvak5vcm1hbCkgPj0gMClcclxuICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIFZlY3RvcjIgcHJldkt0b0sgPSB0aGlzW21vZEtdIC0gcHJldks7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIFZlY3RvcjIgcHJldkt0b0tOb3JtYWwgPSBuZXcgVmVjdG9yMihwcmV2S3RvSy5ZLCAtcHJldkt0b0suWCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgoVmVjdG9yMi5Eb3QodGhpc1tpXSAtIHByZXZLLCBwcmV2S3RvS05vcm1hbCkgPj0gMCkgIT1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIChWZWN0b3IyLkRvdCh0aGlzW2pdIC0gcHJldkssIHByZXZLdG9LTm9ybWFsKSA+PSAwKSlcclxuICAgICAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgb25MZWZ0U2lkZSA9IFZlY3RvcjIuRG90KGlUb2ssIGlUb2pOb3JtYWwpID4gMDtcclxuICAgICAgICAgICAgICAgICAgICBwcmV2SyA9IHRoaXNbbW9kS107XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gRnJvbSBFcmljIEpvcmRhbidzIGNvbnZleCBkZWNvbXBvc2l0aW9uIGxpYnJhcnlcclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBDaGVja3MgaWYgcG9seWdvbiBpcyB2YWxpZCBmb3IgdXNlIGluIEJveDJkIGVuZ2luZS5cclxuICAgICAgICAvLy8gTGFzdCBkaXRjaCBlZmZvcnQgdG8gZW5zdXJlIG5vIGludmFsaWQgcG9seWdvbnMgYXJlXHJcbiAgICAgICAgLy8vIGFkZGVkIHRvIHdvcmxkIGdlb21ldHJ5LlxyXG4gICAgICAgIC8vL1xyXG4gICAgICAgIC8vLyBQZXJmb3JtcyBhIGZ1bGwgY2hlY2ssIGZvciBzaW1wbGljaXR5LCBjb252ZXhpdHksXHJcbiAgICAgICAgLy8vIG9yaWVudGF0aW9uLCBtaW5pbXVtIGFuZ2xlLCBhbmQgdm9sdW1lLiAgVGhpcyB3b24ndFxyXG4gICAgICAgIC8vLyBiZSB2ZXJ5IGVmZmljaWVudCwgYW5kIGEgbG90IG9mIGl0IGlzIHJlZHVuZGFudCB3aGVuXHJcbiAgICAgICAgLy8vIG90aGVyIHRvb2xzIGluIHRoaXMgc2VjdGlvbiBhcmUgdXNlZC5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8cmV0dXJucz48L3JldHVybnM+XHJcbiAgICAgICAgcHVibGljIGJvb2wgQ2hlY2tQb2x5Z29uKClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGludCBlcnJvciA9IC0xO1xyXG4gICAgICAgICAgICBpZiAoQ291bnQgPCAzIHx8IENvdW50ID4gU2V0dGluZ3MuTWF4UG9seWdvblZlcnRpY2VzKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBlcnJvciA9IDA7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKCFJc0NvbnZleCgpKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBlcnJvciA9IDE7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKCFJc1NpbXBsZSgpKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBlcnJvciA9IDI7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKEdldEFyZWEoKSA8IFNldHRpbmdzLkVwc2lsb24pXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGVycm9yID0gMztcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy9Db21wdXRlIG5vcm1hbHNcclxuICAgICAgICAgICAgVmVjdG9yMltdIG5vcm1hbHMgPSBuZXcgVmVjdG9yMltDb3VudF07XHJcbiAgICAgICAgICAgIFZlcnRpY2VzIHZlcnRpY2VzID0gbmV3IFZlcnRpY2VzKENvdW50KTtcclxuICAgICAgICAgICAgZm9yIChpbnQgaSA9IDA7IGkgPCBDb3VudDsgKytpKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB2ZXJ0aWNlcy5BZGQobmV3IFZlY3RvcjIodGhpc1tpXS5YLCB0aGlzW2ldLlkpKTtcclxuICAgICAgICAgICAgICAgIGludCBpMSA9IGk7XHJcbiAgICAgICAgICAgICAgICBpbnQgaTIgPSBpICsgMSA8IENvdW50ID8gaSArIDEgOiAwO1xyXG4gICAgICAgICAgICAgICAgVmVjdG9yMiBlZGdlID0gbmV3IFZlY3RvcjIodGhpc1tpMl0uWCAtIHRoaXNbaTFdLlgsIHRoaXNbaTJdLlkgLSB0aGlzW2kxXS5ZKTtcclxuICAgICAgICAgICAgICAgIG5vcm1hbHNbaV0gPSBNYXRoVXRpbHMuQ3Jvc3MoZWRnZSwgMS4wZik7XHJcbiAgICAgICAgICAgICAgICBub3JtYWxzW2ldLk5vcm1hbGl6ZSgpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvL1JlcXVpcmVkIHNpZGUgY2hlY2tzXHJcbiAgICAgICAgICAgIGZvciAoaW50IGkgPSAwOyBpIDwgQ291bnQ7ICsraSlcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgaW50IGltaW51cyA9IChpID09IDApID8gQ291bnQgLSAxIDogaSAtIDE7XHJcblxyXG4gICAgICAgICAgICAgICAgLy9QYXJhbGxlbCBzaWRlcyBjaGVja1xyXG4gICAgICAgICAgICAgICAgZmxvYXQgY3Jvc3MgPSBNYXRoVXRpbHMuQ3Jvc3Mobm9ybWFsc1tpbWludXNdLCBub3JtYWxzW2ldKTtcclxuICAgICAgICAgICAgICAgIGNyb3NzID0gTWF0aFV0aWxzLkNsYW1wKGNyb3NzLCAtMS4wZiwgMS4wZik7XHJcbiAgICAgICAgICAgICAgICBmbG9hdCBhbmdsZSA9IChmbG9hdClNYXRoLkFzaW4oY3Jvc3MpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGFuZ2xlIDw9IFNldHRpbmdzLkFuZ3VsYXJTbG9wKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIGVycm9yID0gNDtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAvL1RvbyBza2lubnkgY2hlY2tcclxuICAgICAgICAgICAgICAgIGZvciAoaW50IGogPSAwOyBqIDwgQ291bnQ7ICsrailcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoaiA9PSBpIHx8IGogPT0gKGkgKyAxKSAlIENvdW50KVxyXG4gICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGZsb2F0IHMgPSBWZWN0b3IyLkRvdChub3JtYWxzW2ldLCB2ZXJ0aWNlc1tqXSAtIHZlcnRpY2VzW2ldKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAocyA+PSAtU2V0dGluZ3MuTGluZWFyU2xvcClcclxuICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yID0gNTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG5cclxuICAgICAgICAgICAgICAgIFZlY3RvcjIgY2VudHJvaWQgPSB2ZXJ0aWNlcy5HZXRDZW50cm9pZCgpO1xyXG4gICAgICAgICAgICAgICAgVmVjdG9yMiBuMSA9IG5vcm1hbHNbaW1pbnVzXTtcclxuICAgICAgICAgICAgICAgIFZlY3RvcjIgbjIgPSBub3JtYWxzW2ldO1xyXG4gICAgICAgICAgICAgICAgVmVjdG9yMiB2ID0gdmVydGljZXNbaV0gLSBjZW50cm9pZDtcclxuXHJcbiAgICAgICAgICAgICAgICBWZWN0b3IyIGQgPSBuZXcgVmVjdG9yMigpO1xyXG4gICAgICAgICAgICAgICAgZC5YID0gVmVjdG9yMi5Eb3QobjEsIHYpOyAvLyAtIHRvaVNsb3A7XHJcbiAgICAgICAgICAgICAgICBkLlkgPSBWZWN0b3IyLkRvdChuMiwgdik7IC8vIC0gdG9pU2xvcDtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBTaGlmdGluZyB0aGUgZWRnZSBpbndhcmQgYnkgdG9pU2xvcCBzaG91bGRcclxuICAgICAgICAgICAgICAgIC8vIG5vdCBjYXVzZSB0aGUgcGxhbmUgdG8gcGFzcyB0aGUgY2VudHJvaWQuXHJcbiAgICAgICAgICAgICAgICBpZiAoKGQuWCA8IDAuMGYpIHx8IChkLlkgPCAwLjBmKSlcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBlcnJvciA9IDY7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmIChlcnJvciAhPSAtMSlcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgRGVidWcuV3JpdGVMaW5lKFwiRm91bmQgaW52YWxpZCBwb2x5Z29uLCBcIik7XHJcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKGVycm9yKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgRGVidWcuV3JpdGVMaW5lKHN0cmluZy5Gb3JtYXQoXCJtdXN0IGhhdmUgYmV0d2VlbiAzIGFuZCB7MH0gdmVydGljZXMuXFxuXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFNldHRpbmdzLk1heFBvbHlnb25WZXJ0aWNlcykpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIERlYnVnLldyaXRlTGluZShcIm11c3QgYmUgY29udmV4LlxcblwiKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAyOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBEZWJ1Zy5Xcml0ZUxpbmUoXCJtdXN0IGJlIHNpbXBsZSAoY2Fubm90IGludGVyc2VjdCBpdHNlbGYpLlxcblwiKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAzOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBEZWJ1Zy5Xcml0ZUxpbmUoXCJhcmVhIGlzIHRvbyBzbWFsbC5cXG5cIik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgNDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgRGVidWcuV3JpdGVMaW5lKFwic2lkZXMgYXJlIHRvbyBjbG9zZSB0byBwYXJhbGxlbC5cXG5cIik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgNTpcclxuICAgICAgICAgICAgICAgICAgICAgICAgRGVidWcuV3JpdGVMaW5lKFwicG9seWdvbiBpcyB0b28gdGhpbi5cXG5cIik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgNjpcclxuICAgICAgICAgICAgICAgICAgICAgICAgRGVidWcuV3JpdGVMaW5lKFwiY29yZSBzaGFwZSBnZW5lcmF0aW9uIHdvdWxkIG1vdmUgZWRnZSBwYXN0IGNlbnRyb2lkICh0b28gdGhpbikuXFxuXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBEZWJ1Zy5Xcml0ZUxpbmUoXCJkb24ndCBrbm93IHdoeS5cXG5cIik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBlcnJvciAhPSAtMTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIEZyb20gRXJpYyBKb3JkYW4ncyBjb252ZXggZGVjb21wb3NpdGlvbiBsaWJyYXJ5XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gVHJhY2UgdGhlIGVkZ2Ugb2YgYSBub24tc2ltcGxlIHBvbHlnb24gYW5kIHJldHVybiBhIHNpbXBsZSBwb2x5Z29uLlxyXG4gICAgICAgIC8vLyBcclxuICAgICAgICAvLy8gTWV0aG9kOlxyXG4gICAgICAgIC8vLyBTdGFydCBhdCB2ZXJ0ZXggd2l0aCBtaW5pbXVtIHkgKHBpY2sgbWF4aW11bSB4IG9uZSBpZiB0aGVyZSBhcmUgdHdvKS5cclxuICAgICAgICAvLy8gV2UgYWltIG91ciBcImxhc3REaXJcIiB2ZWN0b3IgYXQgKDEuMCwgMClcclxuICAgICAgICAvLy8gV2UgbG9vayBhdCB0aGUgdHdvIHJheXMgZ29pbmcgb2ZmIGZyb20gb3VyIHN0YXJ0IHZlcnRleCwgYW5kIGZvbGxvdyB3aGljaGV2ZXJcclxuICAgICAgICAvLy8gaGFzIHRoZSBzbWFsbGVzdCBhbmdsZSAoaW4gLVBpIC4gUGkpIHdydCBsYXN0RGlyIChcInJpZ2h0ZXN0XCIgdHVybilcclxuICAgICAgICAvLy8gTG9vcCB1bnRpbCB3ZSBoaXQgc3RhcnRpbmcgdmVydGV4OlxyXG4gICAgICAgIC8vLyBXZSBhZGQgb3VyIGN1cnJlbnQgdmVydGV4IHRvIHRoZSBsaXN0LlxyXG4gICAgICAgIC8vLyBXZSBjaGVjayB0aGUgc2VnIGZyb20gY3VycmVudCB2ZXJ0ZXggdG8gbmV4dCB2ZXJ0ZXggZm9yIGludGVyc2VjdGlvbnNcclxuICAgICAgICAvLy8gLSBpZiBubyBpbnRlcnNlY3Rpb25zLCBmb2xsb3cgdG8gbmV4dCB2ZXJ0ZXggYW5kIGNvbnRpbnVlXHJcbiAgICAgICAgLy8vIC0gaWYgaW50ZXJzZWN0aW9ucywgcGljayBvbmUgd2l0aCBtaW5pbXVtIGRpc3RhbmNlXHJcbiAgICAgICAgLy8vIC0gaWYgbW9yZSB0aGFuIG9uZSwgcGljayBvbmUgd2l0aCBcInJpZ2h0ZXN0XCIgbmV4dCBwb2ludCAodHdvIHBvc3NpYmlsaXRpZXMgZm9yIGVhY2gpXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJ2ZXJ0c1wiPlRoZSB2ZXJ0aWNlcy48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cmV0dXJucz48L3JldHVybnM+XHJcbiAgICAgICAgcHVibGljIFZlcnRpY2VzIFRyYWNlRWRnZShWZXJ0aWNlcyB2ZXJ0cylcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIFBvbHlOb2RlW10gbm9kZXMgPSBuZXcgUG9seU5vZGVbdmVydHMuQ291bnQgKiB2ZXJ0cy5Db3VudF07XHJcbiAgICAgICAgICAgIC8vb3ZlcmtpbGwsIGJ1dCBzdWZmaWNpZW50IChvcmRlciBvZiBtYWcuIGlzIHJpZ2h0KVxyXG4gICAgICAgICAgICBpbnQgbk5vZGVzID0gMDtcclxuXHJcbiAgICAgICAgICAgIC8vQWRkIGJhc2Ugbm9kZXMgKHJhdyBvdXRsaW5lKVxyXG4gICAgICAgICAgICBmb3IgKGludCBpID0gMDsgaSA8IHZlcnRzLkNvdW50OyArK2kpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIFZlY3RvcjIgcG9zID0gbmV3IFZlY3RvcjIodmVydHNbaV0uWCwgdmVydHNbaV0uWSk7XHJcbiAgICAgICAgICAgICAgICBub2Rlc1tpXS5Qb3NpdGlvbiA9IHBvcztcclxuICAgICAgICAgICAgICAgICsrbk5vZGVzO1xyXG4gICAgICAgICAgICAgICAgaW50IGlwbHVzID0gKGkgPT0gdmVydHMuQ291bnQgLSAxKSA/IDAgOiBpICsgMTtcclxuICAgICAgICAgICAgICAgIGludCBpbWludXMgPSAoaSA9PSAwKSA/IHZlcnRzLkNvdW50IC0gMSA6IGkgLSAxO1xyXG4gICAgICAgICAgICAgICAgbm9kZXNbaV0uQWRkQ29ubmVjdGlvbihub2Rlc1tpcGx1c10pO1xyXG4gICAgICAgICAgICAgICAgbm9kZXNbaV0uQWRkQ29ubmVjdGlvbihub2Rlc1tpbWludXNdKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy9Qcm9jZXNzIGludGVyc2VjdGlvbiBub2RlcyAtIGhvcnJpYmx5IGluZWZmaWNpZW50XHJcbiAgICAgICAgICAgIGJvb2wgZGlydHkgPSB0cnVlO1xyXG4gICAgICAgICAgICBpbnQgY291bnRlciA9IDA7XHJcbiAgICAgICAgICAgIHdoaWxlIChkaXJ0eSlcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgZGlydHkgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgIGZvciAoaW50IGkgPSAwOyBpIDwgbk5vZGVzOyArK2kpXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yIChpbnQgaiA9IDA7IGogPCBub2Rlc1tpXS5OQ29ubmVjdGVkOyArK2opXHJcbiAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGludCBrID0gMDsgayA8IG5Ob2RlczsgKytrKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoayA9PSBpIHx8IG5vZGVzW2tdID09IG5vZGVzW2ldLkNvbm5lY3RlZFtqXSkgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGludCBsID0gMDsgbCA8IG5vZGVzW2tdLk5Db25uZWN0ZWQ7ICsrbClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobm9kZXNba10uQ29ubmVjdGVkW2xdID09IG5vZGVzW2ldLkNvbm5lY3RlZFtqXSB8fFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBub2Rlc1trXS5Db25uZWN0ZWRbbF0gPT0gbm9kZXNbaV0pIGNvbnRpbnVlO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL0NoZWNrIGludGVyc2VjdGlvblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFZlY3RvcjIgaW50ZXJzZWN0UHQ7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJvb2wgY3Jvc3NlcyA9IExpbmVUb29scy5MaW5lSW50ZXJzZWN0KG5vZGVzW2ldLlBvc2l0aW9uLCBub2Rlc1tpXS5Db25uZWN0ZWRbal0uUG9zaXRpb24sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9kZXNba10uUG9zaXRpb24sIG5vZGVzW2tdLkNvbm5lY3RlZFtsXS5Qb3NpdGlvbixcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdXQgaW50ZXJzZWN0UHQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjcm9zc2VzKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGlydHkgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL0Rlc3Ryb3kgYW5kIHJlLWhvb2sgY29ubmVjdGlvbnMgYXQgY3Jvc3NpbmcgcG9pbnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgUG9seU5vZGUgY29ubmogPSBub2Rlc1tpXS5Db25uZWN0ZWRbal07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFBvbHlOb2RlIGNvbm5sID0gbm9kZXNba10uQ29ubmVjdGVkW2xdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBub2Rlc1tpXS5Db25uZWN0ZWRbal0uUmVtb3ZlQ29ubmVjdGlvbihub2Rlc1tpXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vZGVzW2ldLlJlbW92ZUNvbm5lY3Rpb24oY29ubmopO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBub2Rlc1trXS5Db25uZWN0ZWRbbF0uUmVtb3ZlQ29ubmVjdGlvbihub2Rlc1trXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vZGVzW2tdLlJlbW92ZUNvbm5lY3Rpb24oY29ubmwpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBub2Rlc1tuTm9kZXNdID0gbmV3IFBvbHlOb2RlKGludGVyc2VjdFB0KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9kZXNbbk5vZGVzXS5BZGRDb25uZWN0aW9uKG5vZGVzW2ldKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9kZXNbaV0uQWRkQ29ubmVjdGlvbihub2Rlc1tuTm9kZXNdKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9kZXNbbk5vZGVzXS5BZGRDb25uZWN0aW9uKG5vZGVzW2tdKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9kZXNba10uQWRkQ29ubmVjdGlvbihub2Rlc1tuTm9kZXNdKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9kZXNbbk5vZGVzXS5BZGRDb25uZWN0aW9uKGNvbm5qKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29ubmouQWRkQ29ubmVjdGlvbihub2Rlc1tuTm9kZXNdKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9kZXNbbk5vZGVzXS5BZGRDb25uZWN0aW9uKGNvbm5sKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29ubmwuQWRkQ29ubmVjdGlvbihub2Rlc1tuTm9kZXNdKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKytuTm9kZXM7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdvdG8gU2tpcE91dDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIFNraXBPdXQ6XHJcbiAgICAgICAgICAgICAgICArK2NvdW50ZXI7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vQ29sbGFwc2UgZHVwbGljYXRlIHBvaW50c1xyXG4gICAgICAgICAgICBib29sIGZvdW5kRHVwZSA9IHRydWU7XHJcbiAgICAgICAgICAgIGludCBuQWN0aXZlID0gbk5vZGVzO1xyXG4gICAgICAgICAgICB3aGlsZSAoZm91bmREdXBlKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBmb3VuZER1cGUgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgIGZvciAoaW50IGkgPSAwOyBpIDwgbk5vZGVzOyArK2kpXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5vZGVzW2ldLk5Db25uZWN0ZWQgPT0gMCkgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yIChpbnQgaiA9IGkgKyAxOyBqIDwgbk5vZGVzOyArK2opXHJcbiAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobm9kZXNbal0uTkNvbm5lY3RlZCA9PSAwKSBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgVmVjdG9yMiBkaWZmID0gbm9kZXNbaV0uUG9zaXRpb24gLSBub2Rlc1tqXS5Qb3NpdGlvbjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRpZmYuTGVuZ3RoU3F1YXJlZCgpIDw9IFNldHRpbmdzLkVwc2lsb24gKiBTZXR0aW5ncy5FcHNpbG9uKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobkFjdGl2ZSA8PSAzKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgVmVydGljZXMoKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL3ByaW50ZihcIkZvdW5kIGR1cGUsICVkIGxlZnRcXG5cIixuQWN0aXZlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC0tbkFjdGl2ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvdW5kRHVwZSA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBQb2x5Tm9kZSBpbm9kZSA9IG5vZGVzW2ldO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgUG9seU5vZGUgam5vZGUgPSBub2Rlc1tqXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vTW92ZSBhbGwgb2YgaidzIGNvbm5lY3Rpb25zIHRvIGksIGFuZCBvcnBoYW4galxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW50IG5qQ29ubiA9IGpub2RlLk5Db25uZWN0ZWQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGludCBrID0gMDsgayA8IG5qQ29ubjsgKytrKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFBvbHlOb2RlIGtub2RlID0gam5vZGUuQ29ubmVjdGVkW2tdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIERlYnVnLkFzc2VydChrbm9kZSAhPSBqbm9kZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGtub2RlICE9IGlub2RlKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5vZGUuQWRkQ29ubmVjdGlvbihrbm9kZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtub2RlLkFkZENvbm5lY3Rpb24oaW5vZGUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBrbm9kZS5SZW1vdmVDb25uZWN0aW9uKGpub2RlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGpub2RlLk5Db25uZWN0ZWQgPSAwO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvL05vdyB3YWxrIHRoZSBlZGdlIG9mIHRoZSBsaXN0XHJcblxyXG4gICAgICAgICAgICAvL0ZpbmQgbm9kZSB3aXRoIG1pbmltdW0geSB2YWx1ZSAobWF4IHggaWYgZXF1YWwpXHJcbiAgICAgICAgICAgIGZsb2F0IG1pblkgPSBmbG9hdC5NYXhWYWx1ZTtcclxuICAgICAgICAgICAgZmxvYXQgbWF4WCA9IC1mbG9hdC5NYXhWYWx1ZTtcclxuICAgICAgICAgICAgaW50IG1pbllJbmRleCA9IC0xO1xyXG4gICAgICAgICAgICBmb3IgKGludCBpID0gMDsgaSA8IG5Ob2RlczsgKytpKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBpZiAobm9kZXNbaV0uUG9zaXRpb24uWSA8IG1pblkgJiYgbm9kZXNbaV0uTkNvbm5lY3RlZCA+IDEpXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgbWluWSA9IG5vZGVzW2ldLlBvc2l0aW9uLlk7XHJcbiAgICAgICAgICAgICAgICAgICAgbWluWUluZGV4ID0gaTtcclxuICAgICAgICAgICAgICAgICAgICBtYXhYID0gbm9kZXNbaV0uUG9zaXRpb24uWDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKG5vZGVzW2ldLlBvc2l0aW9uLlkgPT0gbWluWSAmJiBub2Rlc1tpXS5Qb3NpdGlvbi5YID4gbWF4WCAmJiBub2Rlc1tpXS5OQ29ubmVjdGVkID4gMSlcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBtaW5ZSW5kZXggPSBpO1xyXG4gICAgICAgICAgICAgICAgICAgIG1heFggPSBub2Rlc1tpXS5Qb3NpdGlvbi5YO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBWZWN0b3IyIG9yaWdEaXIgPSBuZXcgVmVjdG9yMigxLjBmLCAwLjBmKTtcclxuICAgICAgICAgICAgVmVjdG9yMltdIHJlc3VsdFZlY3MgPSBuZXcgVmVjdG9yMls0ICogbk5vZGVzXTtcclxuICAgICAgICAgICAgLy8gbm9kZXMgbWF5IGJlIHZpc2l0ZWQgbW9yZSB0aGFuIG9uY2UsIHVuZm9ydHVuYXRlbHkgLSBjaGFuZ2UgdG8gZ3Jvd2FibGUgYXJyYXkhXHJcbiAgICAgICAgICAgIGludCBuUmVzdWx0VmVjcyA9IDA7XHJcbiAgICAgICAgICAgIFBvbHlOb2RlIGN1cnJlbnROb2RlID0gbm9kZXNbbWluWUluZGV4XTtcclxuICAgICAgICAgICAgUG9seU5vZGUgc3RhcnROb2RlID0gY3VycmVudE5vZGU7XHJcbiAgICAgICAgICAgIERlYnVnLkFzc2VydChjdXJyZW50Tm9kZS5OQ29ubmVjdGVkID4gMCk7XHJcbiAgICAgICAgICAgIFBvbHlOb2RlIG5leHROb2RlID0gY3VycmVudE5vZGUuR2V0UmlnaHRlc3RDb25uZWN0aW9uKG9yaWdEaXIpO1xyXG4gICAgICAgICAgICBpZiAobmV4dE5vZGUgPT0gbnVsbClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgVmVydGljZXMgdmVydGljZXMgPSBuZXcgVmVydGljZXMoblJlc3VsdFZlY3MpO1xyXG5cclxuICAgICAgICAgICAgICAgIGZvciAoaW50IGkgPSAwOyBpIDwgblJlc3VsdFZlY3M7ICsraSlcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICB2ZXJ0aWNlcy5BZGQocmVzdWx0VmVjc1tpXSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHZlcnRpY2VzO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBCb3JrZWQsIGNsZWFuIHVwIG91ciBtZXNzIGFuZCByZXR1cm5cclxuICAgICAgICAgICAgcmVzdWx0VmVjc1swXSA9IHN0YXJ0Tm9kZS5Qb3NpdGlvbjtcclxuICAgICAgICAgICAgKytuUmVzdWx0VmVjcztcclxuICAgICAgICAgICAgd2hpbGUgKG5leHROb2RlICE9IHN0YXJ0Tm9kZSlcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgaWYgKG5SZXN1bHRWZWNzID4gNCAqIG5Ob2RlcylcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBEZWJ1Zy5Bc3NlcnQoZmFsc2UpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmVzdWx0VmVjc1tuUmVzdWx0VmVjcysrXSA9IG5leHROb2RlLlBvc2l0aW9uO1xyXG4gICAgICAgICAgICAgICAgUG9seU5vZGUgb2xkTm9kZSA9IGN1cnJlbnROb2RlO1xyXG4gICAgICAgICAgICAgICAgY3VycmVudE5vZGUgPSBuZXh0Tm9kZTtcclxuICAgICAgICAgICAgICAgIG5leHROb2RlID0gY3VycmVudE5vZGUuR2V0UmlnaHRlc3RDb25uZWN0aW9uKG9sZE5vZGUpO1xyXG4gICAgICAgICAgICAgICAgaWYgKG5leHROb2RlID09IG51bGwpXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgVmVydGljZXMgdmVydGljZXMgPSBuZXcgVmVydGljZXMoblJlc3VsdFZlY3MpO1xyXG4gICAgICAgICAgICAgICAgICAgIGZvciAoaW50IGkgPSAwOyBpIDwgblJlc3VsdFZlY3M7ICsraSlcclxuICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZlcnRpY2VzLkFkZChyZXN1bHRWZWNzW2ldKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZlcnRpY2VzO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLy8gVGhlcmUgd2FzIGEgcHJvYmxlbSwgc28ganVtcCBvdXQgb2YgdGhlIGxvb3AgYW5kIHVzZSB3aGF0ZXZlciBnYXJiYWdlIHdlJ3ZlIGdlbmVyYXRlZCBzbyBmYXJcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBWZXJ0aWNlcygpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHJpdmF0ZSBjbGFzcyBQb2x5Tm9kZVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcHJpdmF0ZSBjb25zdCBpbnQgTWF4Q29ubmVjdGVkID0gMzI7XHJcblxyXG4gICAgICAgICAgICAvKlxyXG4gICAgICAgICAgICAgKiBHaXZlbiBzaW5lcyBhbmQgY29zaW5lcywgdGVsbHMgaWYgQSdzIGFuZ2xlIGlzIGxlc3MgdGhhbiBCJ3Mgb24gLVBpLCBQaVxyXG4gICAgICAgICAgICAgKiAoaW4gb3RoZXIgd29yZHMsIGlzIEEgXCJyaWdodGVyXCIgdGhhbiBCKVxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgcHVibGljIFBvbHlOb2RlW10gQ29ubmVjdGVkID0gbmV3IFBvbHlOb2RlW01heENvbm5lY3RlZF07XHJcbiAgICAgICAgICAgIHB1YmxpYyBpbnQgTkNvbm5lY3RlZDtcclxuICAgICAgICAgICAgcHVibGljIFZlY3RvcjIgUG9zaXRpb247XHJcblxyXG4gICAgICAgICAgICBwdWJsaWMgUG9seU5vZGUoVmVjdG9yMiBwb3MpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIFBvc2l0aW9uID0gcG9zO1xyXG4gICAgICAgICAgICAgICAgTkNvbm5lY3RlZCA9IDA7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHByaXZhdGUgYm9vbCBJc1JpZ2h0ZXIoZmxvYXQgc2luQSwgZmxvYXQgY29zQSwgZmxvYXQgc2luQiwgZmxvYXQgY29zQilcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgaWYgKHNpbkEgPCAwKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChzaW5CID4gMCB8fCBjb3NBIDw9IGNvc0IpIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIGVsc2UgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChzaW5CIDwgMCB8fCBjb3NBIDw9IGNvc0IpIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBwdWJsaWMgdm9pZCBBZGRDb25uZWN0aW9uKFBvbHlOb2RlIHRvTWUpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIERlYnVnLkFzc2VydChOQ29ubmVjdGVkIDwgTWF4Q29ubmVjdGVkKTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBJZ25vcmUgZHVwbGljYXRlIGFkZGl0aW9uc1xyXG4gICAgICAgICAgICAgICAgZm9yIChpbnQgaSA9IDA7IGkgPCBOQ29ubmVjdGVkOyArK2kpXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKENvbm5lY3RlZFtpXSA9PSB0b01lKSByZXR1cm47XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBDb25uZWN0ZWRbTkNvbm5lY3RlZF0gPSB0b01lO1xyXG4gICAgICAgICAgICAgICAgKytOQ29ubmVjdGVkO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBwdWJsaWMgdm9pZCBSZW1vdmVDb25uZWN0aW9uKFBvbHlOb2RlIGZyb21NZSlcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgYm9vbCBpc0ZvdW5kID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICBpbnQgZm91bmRJbmRleCA9IC0xO1xyXG4gICAgICAgICAgICAgICAgZm9yIChpbnQgaSA9IDA7IGkgPCBOQ29ubmVjdGVkOyArK2kpXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGZyb21NZSA9PSBDb25uZWN0ZWRbaV0pXHJcbiAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLy5wb3NpdGlvbiA9PSBjb25uZWN0ZWRbaV0ucG9zaXRpb24pe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpc0ZvdW5kID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZm91bmRJbmRleCA9IGk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIERlYnVnLkFzc2VydChpc0ZvdW5kKTtcclxuICAgICAgICAgICAgICAgIC0tTkNvbm5lY3RlZDtcclxuICAgICAgICAgICAgICAgIGZvciAoaW50IGkgPSBmb3VuZEluZGV4OyBpIDwgTkNvbm5lY3RlZDsgKytpKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIENvbm5lY3RlZFtpXSA9IENvbm5lY3RlZFtpICsgMV07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHB1YmxpYyBQb2x5Tm9kZSBHZXRSaWdodGVzdENvbm5lY3Rpb24oUG9seU5vZGUgaW5jb21pbmcpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGlmIChOQ29ubmVjdGVkID09IDApIERlYnVnLkFzc2VydChmYWxzZSk7IC8vIFRoaXMgbWVhbnMgdGhlIGNvbm5lY3Rpb24gZ3JhcGggaXMgaW5jb25zaXN0ZW50XHJcbiAgICAgICAgICAgICAgICBpZiAoTkNvbm5lY3RlZCA9PSAxKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vYjJBc3NlcnQoZmFsc2UpO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIEJlY2F1c2Ugb2YgdGhlIHBvc3NpYmlsaXR5IG9mIGNvbGxhcHNpbmcgbmVhcmJ5IHBvaW50cyxcclxuICAgICAgICAgICAgICAgICAgICAvLyB3ZSBtYXkgZW5kIHVwIHdpdGggXCJzcGlkZXIgbGVnc1wiIGRhbmdsaW5nIG9mZiBvZiBhIHJlZ2lvbi5cclxuICAgICAgICAgICAgICAgICAgICAvLyBUaGUgY29ycmVjdCBiZWhhdmlvciBoZXJlIGlzIHRvIHR1cm4gYXJvdW5kLlxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpbmNvbWluZztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIFZlY3RvcjIgaW5EaXIgPSBQb3NpdGlvbiAtIGluY29taW5nLlBvc2l0aW9uO1xyXG5cclxuICAgICAgICAgICAgICAgIGZsb2F0IGluTGVuZ3RoID0gaW5EaXIuTGVuZ3RoKCk7XHJcbiAgICAgICAgICAgICAgICBpbkRpci5Ob3JtYWxpemUoKTtcclxuXHJcbiAgICAgICAgICAgICAgICBEZWJ1Zy5Bc3NlcnQoaW5MZW5ndGggPiBTZXR0aW5ncy5FcHNpbG9uKTtcclxuXHJcbiAgICAgICAgICAgICAgICBQb2x5Tm9kZSByZXN1bHQgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgZm9yIChpbnQgaSA9IDA7IGkgPCBOQ29ubmVjdGVkOyArK2kpXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKENvbm5lY3RlZFtpXSA9PSBpbmNvbWluZykgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICAgICAgVmVjdG9yMiB0ZXN0RGlyID0gQ29ubmVjdGVkW2ldLlBvc2l0aW9uIC0gUG9zaXRpb247XHJcbiAgICAgICAgICAgICAgICAgICAgZmxvYXQgdGVzdExlbmd0aFNxciA9IHRlc3REaXIuTGVuZ3RoU3F1YXJlZCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRlc3REaXIuTm9ybWFsaXplKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgRGVidWcuQXNzZXJ0KHRlc3RMZW5ndGhTcXIgPj0gU2V0dGluZ3MuRXBzaWxvbiAqIFNldHRpbmdzLkVwc2lsb24pO1xyXG4gICAgICAgICAgICAgICAgICAgIGZsb2F0IG15Q29zID0gVmVjdG9yMi5Eb3QoaW5EaXIsIHRlc3REaXIpO1xyXG4gICAgICAgICAgICAgICAgICAgIGZsb2F0IG15U2luID0gTWF0aFV0aWxzLkNyb3NzKGluRGlyLCB0ZXN0RGlyKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAocmVzdWx0ICE9IG51bGwpXHJcbiAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBWZWN0b3IyIHJlc3VsdERpciA9IHJlc3VsdC5Qb3NpdGlvbiAtIFBvc2l0aW9uO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHREaXIuTm9ybWFsaXplKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZsb2F0IHJlc0NvcyA9IFZlY3RvcjIuRG90KGluRGlyLCByZXN1bHREaXIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBmbG9hdCByZXNTaW4gPSBNYXRoVXRpbHMuQ3Jvc3MoaW5EaXIsIHJlc3VsdERpcik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChJc1JpZ2h0ZXIobXlTaW4sIG15Q29zLCByZXNTaW4sIHJlc0NvcykpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IENvbm5lY3RlZFtpXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBDb25uZWN0ZWRbaV07XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIERlYnVnLkFzc2VydChyZXN1bHQgIT0gbnVsbCk7XHJcblxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcHVibGljIFBvbHlOb2RlIEdldFJpZ2h0ZXN0Q29ubmVjdGlvbihWZWN0b3IyIGluY29taW5nRGlyKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBWZWN0b3IyIGRpZmYgPSBQb3NpdGlvbiAtIGluY29taW5nRGlyO1xyXG4gICAgICAgICAgICAgICAgUG9seU5vZGUgdGVtcCA9IG5ldyBQb2x5Tm9kZShkaWZmKTtcclxuICAgICAgICAgICAgICAgIFBvbHlOb2RlIHJlcyA9IEdldFJpZ2h0ZXN0Q29ubmVjdGlvbih0ZW1wKTtcclxuICAgICAgICAgICAgICAgIERlYnVnLkFzc2VydChyZXMgIT0gbnVsbCk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwdWJsaWMgb3ZlcnJpZGUgc3RyaW5nIFRvU3RyaW5nKClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIFN0cmluZ0J1aWxkZXIgYnVpbGRlciA9IG5ldyBTdHJpbmdCdWlsZGVyKCk7XHJcbiAgICAgICAgICAgIGZvciAoaW50IGkgPSAwOyBpIDwgQ291bnQ7IGkrKylcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgYnVpbGRlci5BcHBlbmQodGhpc1tpXS5Ub1N0cmluZygpKTtcclxuICAgICAgICAgICAgICAgIGlmIChpIDwgQ291bnQgLSAxKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIGJ1aWxkZXIuQXBwZW5kKFwiIFwiKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gYnVpbGRlci5Ub1N0cmluZygpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBQcm9qZWN0cyB0byBheGlzLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwiYXhpc1wiPlRoZSBheGlzLjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwibWluXCI+VGhlIG1pbi48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cIm1heFwiPlRoZSBtYXguPC9wYXJhbT5cclxuICAgICAgICBwdWJsaWMgdm9pZCBQcm9qZWN0VG9BeGlzKHJlZiBWZWN0b3IyIGF4aXMsIG91dCBmbG9hdCBtaW4sIG91dCBmbG9hdCBtYXgpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICAvLyBUbyBwcm9qZWN0IGEgcG9pbnQgb24gYW4gYXhpcyB1c2UgdGhlIGRvdCBwcm9kdWN0XHJcbiAgICAgICAgICAgIGZsb2F0IGRvdFByb2R1Y3QgPSBWZWN0b3IyLkRvdChheGlzLCB0aGlzWzBdKTtcclxuICAgICAgICAgICAgbWluID0gZG90UHJvZHVjdDtcclxuICAgICAgICAgICAgbWF4ID0gZG90UHJvZHVjdDtcclxuXHJcbiAgICAgICAgICAgIGZvciAoaW50IGkgPSAwOyBpIDwgQ291bnQ7IGkrKylcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgZG90UHJvZHVjdCA9IFZlY3RvcjIuRG90KHRoaXNbaV0sIGF4aXMpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGRvdFByb2R1Y3QgPCBtaW4pXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgbWluID0gZG90UHJvZHVjdDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoZG90UHJvZHVjdCA+IG1heClcclxuICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1heCA9IGRvdFByb2R1Y3Q7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIFdpbmRpbmcgbnVtYmVyIHRlc3QgZm9yIGEgcG9pbnQgaW4gYSBwb2x5Z29uLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIFNlZSBtb3JlIGluZm8gYWJvdXQgdGhlIGFsZ29yaXRobSBoZXJlOiBodHRwOi8vc29mdHN1cmZlci5jb20vQXJjaGl2ZS9hbGdvcml0aG1fMDEwMy9hbGdvcml0aG1fMDEwMy5odG1cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJwb2ludFwiPlRoZSBwb2ludCB0byBiZSB0ZXN0ZWQuPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHJldHVybnM+LTEgaWYgdGhlIHdpbmRpbmcgbnVtYmVyIGlzIHplcm8gYW5kIHRoZSBwb2ludCBpcyBvdXRzaWRlXHJcbiAgICAgICAgLy8vIHRoZSBwb2x5Z29uLCAxIGlmIHRoZSBwb2ludCBpcyBpbnNpZGUgdGhlIHBvbHlnb24sIGFuZCAwIGlmIHRoZSBwb2ludFxyXG4gICAgICAgIC8vLyBpcyBvbiB0aGUgcG9seWdvbnMgZWRnZS48L3JldHVybnM+XHJcbiAgICAgICAgcHVibGljIGludCBQb2ludEluUG9seWdvbihyZWYgVmVjdG9yMiBwb2ludClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIC8vIFdpbmRpbmcgbnVtYmVyXHJcbiAgICAgICAgICAgIGludCB3biA9IDA7XHJcblxyXG4gICAgICAgICAgICAvLyBJdGVyYXRlIHRocm91Z2ggcG9seWdvbidzIGVkZ2VzXHJcbiAgICAgICAgICAgIGZvciAoaW50IGkgPSAwOyBpIDwgQ291bnQ7IGkrKylcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgLy8gR2V0IHBvaW50c1xyXG4gICAgICAgICAgICAgICAgVmVjdG9yMiBwMSA9IHRoaXNbaV07XHJcbiAgICAgICAgICAgICAgICBWZWN0b3IyIHAyID0gdGhpc1tOZXh0SW5kZXgoaSldO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIFRlc3QgaWYgYSBwb2ludCBpcyBkaXJlY3RseSBvbiB0aGUgZWRnZVxyXG4gICAgICAgICAgICAgICAgVmVjdG9yMiBlZGdlID0gcDIgLSBwMTtcclxuICAgICAgICAgICAgICAgIGZsb2F0IGFyZWEgPSBNYXRoVXRpbHMuQXJlYShyZWYgcDEsIHJlZiBwMiwgcmVmIHBvaW50KTtcclxuICAgICAgICAgICAgICAgIGlmIChhcmVhID09IDBmICYmIFZlY3RvcjIuRG90KHBvaW50IC0gcDEsIGVkZ2UpID49IDBmICYmIFZlY3RvcjIuRG90KHBvaW50IC0gcDIsIGVkZ2UpIDw9IDBmKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAwO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLy8gVGVzdCBlZGdlIGZvciBpbnRlcnNlY3Rpb24gd2l0aCByYXkgZnJvbSBwb2ludFxyXG4gICAgICAgICAgICAgICAgaWYgKHAxLlkgPD0gcG9pbnQuWSlcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAocDIuWSA+IHBvaW50LlkgJiYgYXJlYSA+IDBmKVxyXG4gICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgKyt3bjtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHAyLlkgPD0gcG9pbnQuWSAmJiBhcmVhIDwgMGYpXHJcbiAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAtLXduO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gKHduID09IDAgPyAtMSA6IDEpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBDb21wdXRlIHRoZSBzdW0gb2YgdGhlIGFuZ2xlcyBtYWRlIGJldHdlZW4gdGhlIHRlc3QgcG9pbnQgYW5kIGVhY2ggcGFpciBvZiBwb2ludHMgbWFraW5nIHVwIHRoZSBwb2x5Z29uLiBcclxuICAgICAgICAvLy8gSWYgdGhpcyBzdW0gaXMgMnBpIHRoZW4gdGhlIHBvaW50IGlzIGFuIGludGVyaW9yIHBvaW50LCBpZiAwIHRoZW4gdGhlIHBvaW50IGlzIGFuIGV4dGVyaW9yIHBvaW50LiBcclxuICAgICAgICAvLy8gcmVmOiBodHRwOi8vb3p2aXoud2FzcC51d2EuZWR1LmF1L35wYm91cmtlL2dlb21ldHJ5L2luc2lkZXBvbHkvICAtIFNvbHV0aW9uIDIgXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICBwdWJsaWMgYm9vbCBQb2ludEluUG9seWdvbkFuZ2xlKHJlZiBWZWN0b3IyIHBvaW50KVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgZG91YmxlIGFuZ2xlID0gMDtcclxuXHJcbiAgICAgICAgICAgIC8vIEl0ZXJhdGUgdGhyb3VnaCBwb2x5Z29uJ3MgZWRnZXNcclxuICAgICAgICAgICAgZm9yIChpbnQgaSA9IDA7IGkgPCBDb3VudDsgaSsrKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAvLyBHZXQgcG9pbnRzXHJcbiAgICAgICAgICAgICAgICBWZWN0b3IyIHAxID0gdGhpc1tpXSAtIHBvaW50O1xyXG4gICAgICAgICAgICAgICAgVmVjdG9yMiBwMiA9IHRoaXNbTmV4dEluZGV4KGkpXSAtIHBvaW50O1xyXG5cclxuICAgICAgICAgICAgICAgIGFuZ2xlICs9IE1hdGhVdGlscy5WZWN0b3JBbmdsZShyZWYgcDEsIHJlZiBwMik7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmIChNYXRoLkFicyhhbmdsZSkgPCBNYXRoLlBJKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufSIsIi8qXHJcbiogRmFyc2VlciBQaHlzaWNzIEVuZ2luZSBiYXNlZCBvbiBCb3gyRC5YTkEgcG9ydDpcclxuKiBDb3B5cmlnaHQgKGMpIDIwMTAgSWFuIFF2aXN0XHJcbiogXHJcbiogQm94MkQuWE5BIHBvcnQgb2YgQm94MkQ6XHJcbiogQ29weXJpZ2h0IChjKSAyMDA5IEJyYW5kb24gRnVydHdhbmdsZXIsIE5hdGhhbiBGdXJ0d2FuZ2xlclxyXG4qXHJcbiogT3JpZ2luYWwgc291cmNlIEJveDJEOlxyXG4qIENvcHlyaWdodCAoYykgMjAwNi0yMDA5IEVyaW4gQ2F0dG8gaHR0cDovL3d3dy5ncGh5c2ljcy5jb20gXHJcbiogXHJcbiogVGhpcyBzb2Z0d2FyZSBpcyBwcm92aWRlZCAnYXMtaXMnLCB3aXRob3V0IGFueSBleHByZXNzIG9yIGltcGxpZWQgXHJcbiogd2FycmFudHkuICBJbiBubyBldmVudCB3aWxsIHRoZSBhdXRob3JzIGJlIGhlbGQgbGlhYmxlIGZvciBhbnkgZGFtYWdlcyBcclxuKiBhcmlzaW5nIGZyb20gdGhlIHVzZSBvZiB0aGlzIHNvZnR3YXJlLiBcclxuKiBQZXJtaXNzaW9uIGlzIGdyYW50ZWQgdG8gYW55b25lIHRvIHVzZSB0aGlzIHNvZnR3YXJlIGZvciBhbnkgcHVycG9zZSwgXHJcbiogaW5jbHVkaW5nIGNvbW1lcmNpYWwgYXBwbGljYXRpb25zLCBhbmQgdG8gYWx0ZXIgaXQgYW5kIHJlZGlzdHJpYnV0ZSBpdCBcclxuKiBmcmVlbHksIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyByZXN0cmljdGlvbnM6IFxyXG4qIDEuIFRoZSBvcmlnaW4gb2YgdGhpcyBzb2Z0d2FyZSBtdXN0IG5vdCBiZSBtaXNyZXByZXNlbnRlZDsgeW91IG11c3Qgbm90IFxyXG4qIGNsYWltIHRoYXQgeW91IHdyb3RlIHRoZSBvcmlnaW5hbCBzb2Z0d2FyZS4gSWYgeW91IHVzZSB0aGlzIHNvZnR3YXJlIFxyXG4qIGluIGEgcHJvZHVjdCwgYW4gYWNrbm93bGVkZ21lbnQgaW4gdGhlIHByb2R1Y3QgZG9jdW1lbnRhdGlvbiB3b3VsZCBiZSBcclxuKiBhcHByZWNpYXRlZCBidXQgaXMgbm90IHJlcXVpcmVkLiBcclxuKiAyLiBBbHRlcmVkIHNvdXJjZSB2ZXJzaW9ucyBtdXN0IGJlIHBsYWlubHkgbWFya2VkIGFzIHN1Y2gsIGFuZCBtdXN0IG5vdCBiZSBcclxuKiBtaXNyZXByZXNlbnRlZCBhcyBiZWluZyB0aGUgb3JpZ2luYWwgc29mdHdhcmUuIFxyXG4qIDMuIFRoaXMgbm90aWNlIG1heSBub3QgYmUgcmVtb3ZlZCBvciBhbHRlcmVkIGZyb20gYW55IHNvdXJjZSBkaXN0cmlidXRpb24uIFxyXG4qL1xyXG5cclxudXNpbmcgU3lzdGVtO1xyXG5cclxubmFtZXNwYWNlIEZhcnNlZXJQaHlzaWNzLkNvbW1vblxyXG57XHJcbiAgICBwdWJsaWMgc3RydWN0IEZpeGVkQXJyYXkyPFQ+XHJcbiAgICB7XHJcbiAgICAgICAgcHJpdmF0ZSBUIF92YWx1ZTA7XHJcbiAgICAgICAgcHJpdmF0ZSBUIF92YWx1ZTE7XHJcblxyXG4gICAgICAgIHB1YmxpYyBUIHRoaXNbaW50IGluZGV4XVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgZ2V0XHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHN3aXRjaCAoaW5kZXgpXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3ZhbHVlMDtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfdmFsdWUxO1xyXG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBJbmRleE91dE9mUmFuZ2VFeGNlcHRpb24oKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBzZXRcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgc3dpdGNoIChpbmRleClcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF92YWx1ZTAgPSB2YWx1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBfdmFsdWUxID0gdmFsdWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBJbmRleE91dE9mUmFuZ2VFeGNlcHRpb24oKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgc3RydWN0IEZpeGVkQXJyYXkzPFQ+XHJcbiAgICB7XHJcbiAgICAgICAgcHJpdmF0ZSBUIF92YWx1ZTA7XHJcbiAgICAgICAgcHJpdmF0ZSBUIF92YWx1ZTE7XHJcbiAgICAgICAgcHJpdmF0ZSBUIF92YWx1ZTI7XHJcblxyXG4gICAgICAgIHB1YmxpYyBUIHRoaXNbaW50IGluZGV4XVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgZ2V0XHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHN3aXRjaCAoaW5kZXgpXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3ZhbHVlMDtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfdmFsdWUxO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMjpcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF92YWx1ZTI7XHJcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEluZGV4T3V0T2ZSYW5nZUV4Y2VwdGlvbigpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHNldFxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKGluZGV4KVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgX3ZhbHVlMCA9IHZhbHVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF92YWx1ZTEgPSB2YWx1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAyOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBfdmFsdWUyID0gdmFsdWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBJbmRleE91dE9mUmFuZ2VFeGNlcHRpb24oKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgc3RydWN0IEZpeGVkQXJyYXk0PFQ+XHJcbiAgICB7XHJcbiAgICAgICAgcHJpdmF0ZSBUIF92YWx1ZTA7XHJcbiAgICAgICAgcHJpdmF0ZSBUIF92YWx1ZTE7XHJcbiAgICAgICAgcHJpdmF0ZSBUIF92YWx1ZTI7XHJcbiAgICAgICAgcHJpdmF0ZSBUIF92YWx1ZTM7XHJcblxyXG4gICAgICAgIHB1YmxpYyBUIHRoaXNbaW50IGluZGV4XVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgZ2V0XHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHN3aXRjaCAoaW5kZXgpXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3ZhbHVlMDtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfdmFsdWUxO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMjpcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF92YWx1ZTI7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAzOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3ZhbHVlMztcclxuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgSW5kZXhPdXRPZlJhbmdlRXhjZXB0aW9uKCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgc2V0XHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHN3aXRjaCAoaW5kZXgpXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBfdmFsdWUwID0gdmFsdWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcclxuICAgICAgICAgICAgICAgICAgICAgICAgX3ZhbHVlMSA9IHZhbHVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDI6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF92YWx1ZTIgPSB2YWx1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAzOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBfdmFsdWUzID0gdmFsdWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBJbmRleE91dE9mUmFuZ2VFeGNlcHRpb24oKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgc3RydWN0IEZpeGVkQXJyYXk4PFQ+XHJcbiAgICB7XHJcbiAgICAgICAgcHJpdmF0ZSBUIF92YWx1ZTA7XHJcbiAgICAgICAgcHJpdmF0ZSBUIF92YWx1ZTE7XHJcbiAgICAgICAgcHJpdmF0ZSBUIF92YWx1ZTI7XHJcbiAgICAgICAgcHJpdmF0ZSBUIF92YWx1ZTM7XHJcbiAgICAgICAgcHJpdmF0ZSBUIF92YWx1ZTQ7XHJcbiAgICAgICAgcHJpdmF0ZSBUIF92YWx1ZTU7XHJcbiAgICAgICAgcHJpdmF0ZSBUIF92YWx1ZTY7XHJcbiAgICAgICAgcHJpdmF0ZSBUIF92YWx1ZTc7XHJcblxyXG4gICAgICAgIHB1YmxpYyBUIHRoaXNbaW50IGluZGV4XVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgZ2V0XHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHN3aXRjaCAoaW5kZXgpXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3ZhbHVlMDtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfdmFsdWUxO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMjpcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF92YWx1ZTI7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAzOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3ZhbHVlMztcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDQ6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfdmFsdWU0O1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgNTpcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF92YWx1ZTU7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSA2OlxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3ZhbHVlNjtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDc6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfdmFsdWU3O1xyXG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBJbmRleE91dE9mUmFuZ2VFeGNlcHRpb24oKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBzZXRcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgc3dpdGNoIChpbmRleClcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF92YWx1ZTAgPSB2YWx1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBfdmFsdWUxID0gdmFsdWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMjpcclxuICAgICAgICAgICAgICAgICAgICAgICAgX3ZhbHVlMiA9IHZhbHVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDM6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF92YWx1ZTMgPSB2YWx1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSA0OlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBfdmFsdWU0ID0gdmFsdWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgNTpcclxuICAgICAgICAgICAgICAgICAgICAgICAgX3ZhbHVlNSA9IHZhbHVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDY6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF92YWx1ZTYgPSB2YWx1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSA3OlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBfdmFsdWU3ID0gdmFsdWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBJbmRleE91dE9mUmFuZ2VFeGNlcHRpb24oKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxufSIsInVzaW5nIFN5c3RlbTtcclxudXNpbmcgU3lzdGVtLkNvbGxlY3Rpb25zLkdlbmVyaWM7XHJcbnVzaW5nIEZhcnNlZXJQaHlzaWNzLkNvbGxpc2lvbjtcclxudXNpbmcgTWljcm9zb2Z0LlhuYS5GcmFtZXdvcms7XHJcblxyXG5uYW1lc3BhY2UgRmFyc2VlclBoeXNpY3MuQ29tbW9uXHJcbntcclxuICAgIC8vLyA8c3VtbWFyeT5cclxuICAgIC8vLyBDb2xsZWN0aW9uIG9mIGhlbHBlciBtZXRob2RzIGZvciBtaXNjIGNvbGxpc2lvbnMuXHJcbiAgICAvLy8gRG9lcyBmbG9hdCB0b2xlcmFuY2UgYW5kIGxpbmUgY29sbGlzaW9ucyB3aXRoIGxpbmVzIGFuZCBBQUJCcy5cclxuICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICBwdWJsaWMgc3RhdGljIGNsYXNzIExpbmVUb29sc1xyXG4gICAge1xyXG4gICAgICAgIHB1YmxpYyBzdGF0aWMgZmxvYXQgRGlzdGFuY2VCZXR3ZWVuUG9pbnRBbmRQb2ludChyZWYgVmVjdG9yMiBwb2ludDEsIHJlZiBWZWN0b3IyIHBvaW50MilcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIFZlY3RvcjIgdjtcclxuICAgICAgICAgICAgVmVjdG9yMi5TdWJ0cmFjdChyZWYgcG9pbnQxLCByZWYgcG9pbnQyLCBvdXQgdik7XHJcbiAgICAgICAgICAgIHJldHVybiB2Lkxlbmd0aCgpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHVibGljIHN0YXRpYyBmbG9hdCBEaXN0YW5jZUJldHdlZW5Qb2ludEFuZExpbmVTZWdtZW50KHJlZiBWZWN0b3IyIHBvaW50LCByZWYgVmVjdG9yMiBsaW5lRW5kUG9pbnQxLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWYgVmVjdG9yMiBsaW5lRW5kUG9pbnQyKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgVmVjdG9yMiB2ID0gVmVjdG9yMi5TdWJ0cmFjdChsaW5lRW5kUG9pbnQyLCBsaW5lRW5kUG9pbnQxKTtcclxuICAgICAgICAgICAgVmVjdG9yMiB3ID0gVmVjdG9yMi5TdWJ0cmFjdChwb2ludCwgbGluZUVuZFBvaW50MSk7XHJcblxyXG4gICAgICAgICAgICBmbG9hdCBjMSA9IFZlY3RvcjIuRG90KHcsIHYpO1xyXG4gICAgICAgICAgICBpZiAoYzEgPD0gMCkgcmV0dXJuIERpc3RhbmNlQmV0d2VlblBvaW50QW5kUG9pbnQocmVmIHBvaW50LCByZWYgbGluZUVuZFBvaW50MSk7XHJcblxyXG4gICAgICAgICAgICBmbG9hdCBjMiA9IFZlY3RvcjIuRG90KHYsIHYpO1xyXG4gICAgICAgICAgICBpZiAoYzIgPD0gYzEpIHJldHVybiBEaXN0YW5jZUJldHdlZW5Qb2ludEFuZFBvaW50KHJlZiBwb2ludCwgcmVmIGxpbmVFbmRQb2ludDIpO1xyXG5cclxuICAgICAgICAgICAgZmxvYXQgYiA9IGMxIC8gYzI7XHJcbiAgICAgICAgICAgIFZlY3RvcjIgcG9pbnRPbkxpbmUgPSBWZWN0b3IyLkFkZChsaW5lRW5kUG9pbnQxLCBWZWN0b3IyLk11bHRpcGx5KHYsIGIpKTtcclxuICAgICAgICAgICAgcmV0dXJuIERpc3RhbmNlQmV0d2VlblBvaW50QW5kUG9pbnQocmVmIHBvaW50LCByZWYgcG9pbnRPbkxpbmUpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gRnJvbSBFcmljIEpvcmRhbidzIGNvbnZleCBkZWNvbXBvc2l0aW9uIGxpYnJhcnlcclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vQ2hlY2sgaWYgdGhlIGxpbmVzIGEwLT5hMSBhbmQgYjAtPmIxIGNyb3NzLlxyXG4gICAgICAgIC8vL0lmIHRoZXkgZG8sIGludGVyc2VjdGlvblBvaW50IHdpbGwgYmUgZmlsbGVkXHJcbiAgICAgICAgLy8vd2l0aCB0aGUgcG9pbnQgb2YgY3Jvc3NpbmcuXHJcbiAgICAgICAgLy8vXHJcbiAgICAgICAgLy8vR3JhemluZyBsaW5lcyBzaG91bGQgbm90IHJldHVybiB0cnVlLlxyXG4gICAgICAgIC8vLyBcclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cImEwXCI+PC9wYXJhbT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJhMVwiPjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwiYjBcIj48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cImIxXCI+PC9wYXJhbT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJpbnRlcnNlY3Rpb25Qb2ludFwiPjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxyZXR1cm5zPjwvcmV0dXJucz5cclxuICAgICAgICBwdWJsaWMgc3RhdGljIGJvb2wgTGluZUludGVyc2VjdDIoVmVjdG9yMiBhMCwgVmVjdG9yMiBhMSwgVmVjdG9yMiBiMCwgVmVjdG9yMiBiMSwgb3V0IFZlY3RvcjIgaW50ZXJzZWN0aW9uUG9pbnQpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBpbnRlcnNlY3Rpb25Qb2ludCA9IFZlY3RvcjIuWmVybztcclxuXHJcbiAgICAgICAgICAgIGlmIChhMCA9PSBiMCB8fCBhMCA9PSBiMSB8fCBhMSA9PSBiMCB8fCBhMSA9PSBiMSlcclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuXHJcbiAgICAgICAgICAgIGZsb2F0IHgxID0gYTAuWDtcclxuICAgICAgICAgICAgZmxvYXQgeTEgPSBhMC5ZO1xyXG4gICAgICAgICAgICBmbG9hdCB4MiA9IGExLlg7XHJcbiAgICAgICAgICAgIGZsb2F0IHkyID0gYTEuWTtcclxuICAgICAgICAgICAgZmxvYXQgeDMgPSBiMC5YO1xyXG4gICAgICAgICAgICBmbG9hdCB5MyA9IGIwLlk7XHJcbiAgICAgICAgICAgIGZsb2F0IHg0ID0gYjEuWDtcclxuICAgICAgICAgICAgZmxvYXQgeTQgPSBiMS5ZO1xyXG5cclxuICAgICAgICAgICAgLy9BQUJCIGVhcmx5IGV4aXRcclxuICAgICAgICAgICAgaWYgKE1hdGguTWF4KHgxLCB4MikgPCBNYXRoLk1pbih4MywgeDQpIHx8IE1hdGguTWF4KHgzLCB4NCkgPCBNYXRoLk1pbih4MSwgeDIpKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG5cclxuICAgICAgICAgICAgaWYgKE1hdGguTWF4KHkxLCB5MikgPCBNYXRoLk1pbih5MywgeTQpIHx8IE1hdGguTWF4KHkzLCB5NCkgPCBNYXRoLk1pbih5MSwgeTIpKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG5cclxuICAgICAgICAgICAgZmxvYXQgdWEgPSAoKHg0IC0geDMpICogKHkxIC0geTMpIC0gKHk0IC0geTMpICogKHgxIC0geDMpKTtcclxuICAgICAgICAgICAgZmxvYXQgdWIgPSAoKHgyIC0geDEpICogKHkxIC0geTMpIC0gKHkyIC0geTEpICogKHgxIC0geDMpKTtcclxuICAgICAgICAgICAgZmxvYXQgZGVub20gPSAoeTQgLSB5MykgKiAoeDIgLSB4MSkgLSAoeDQgLSB4MykgKiAoeTIgLSB5MSk7XHJcbiAgICAgICAgICAgIGlmIChNYXRoLkFicyhkZW5vbSkgPCBTZXR0aW5ncy5FcHNpbG9uKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAvL0xpbmVzIGFyZSB0b28gY2xvc2UgdG8gcGFyYWxsZWwgdG8gY2FsbFxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHVhIC89IGRlbm9tO1xyXG4gICAgICAgICAgICB1YiAvPSBkZW5vbTtcclxuXHJcbiAgICAgICAgICAgIGlmICgoMCA8IHVhKSAmJiAodWEgPCAxKSAmJiAoMCA8IHViKSAmJiAodWIgPCAxKSlcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgaW50ZXJzZWN0aW9uUG9pbnQuWCA9ICh4MSArIHVhICogKHgyIC0geDEpKTtcclxuICAgICAgICAgICAgICAgIGludGVyc2VjdGlvblBvaW50LlkgPSAoeTEgKyB1YSAqICh5MiAtIHkxKSk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy9Gcm9tIE1hcmsgQmF5YXppdCdzIGNvbnZleCBkZWNvbXBvc2l0aW9uIGFsZ29yaXRobVxyXG4gICAgICAgIHB1YmxpYyBzdGF0aWMgVmVjdG9yMiBMaW5lSW50ZXJzZWN0KFZlY3RvcjIgcDEsIFZlY3RvcjIgcDIsIFZlY3RvcjIgcTEsIFZlY3RvcjIgcTIpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBWZWN0b3IyIGkgPSBWZWN0b3IyLlplcm87XHJcbiAgICAgICAgICAgIGZsb2F0IGExID0gcDIuWSAtIHAxLlk7XHJcbiAgICAgICAgICAgIGZsb2F0IGIxID0gcDEuWCAtIHAyLlg7XHJcbiAgICAgICAgICAgIGZsb2F0IGMxID0gYTEgKiBwMS5YICsgYjEgKiBwMS5ZO1xyXG4gICAgICAgICAgICBmbG9hdCBhMiA9IHEyLlkgLSBxMS5ZO1xyXG4gICAgICAgICAgICBmbG9hdCBiMiA9IHExLlggLSBxMi5YO1xyXG4gICAgICAgICAgICBmbG9hdCBjMiA9IGEyICogcTEuWCArIGIyICogcTEuWTtcclxuICAgICAgICAgICAgZmxvYXQgZGV0ID0gYTEgKiBiMiAtIGEyICogYjE7XHJcblxyXG4gICAgICAgICAgICBpZiAoIU1hdGhVdGlscy5GbG9hdEVxdWFscyhkZXQsIDApKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAvLyBsaW5lcyBhcmUgbm90IHBhcmFsbGVsXHJcbiAgICAgICAgICAgICAgICBpLlggPSAoYjIgKiBjMSAtIGIxICogYzIpIC8gZGV0O1xyXG4gICAgICAgICAgICAgICAgaS5ZID0gKGExICogYzIgLSBhMiAqIGMxKSAvIGRldDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gaTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gVGhpcyBtZXRob2QgZGV0ZWN0cyBpZiB0d28gbGluZSBzZWdtZW50cyAob3IgbGluZXMpIGludGVyc2VjdCxcclxuICAgICAgICAvLy8gYW5kLCBpZiBzbywgdGhlIHBvaW50IG9mIGludGVyc2VjdGlvbi4gVXNlIHRoZSA8cGFyYW1yZWYgbmFtZT1cImZpcnN0SXNTZWdtZW50XCIvPiBhbmRcclxuICAgICAgICAvLy8gPHBhcmFtcmVmIG5hbWU9XCJzZWNvbmRJc1NlZ21lbnRcIi8+IHBhcmFtZXRlcnMgdG8gc2V0IHdoZXRoZXIgdGhlIGludGVyc2VjdGlvbiBwb2ludFxyXG4gICAgICAgIC8vLyBtdXN0IGJlIG9uIHRoZSBmaXJzdCBhbmQgc2Vjb25kIGxpbmUgc2VnbWVudHMuIFNldHRpbmcgdGhlc2VcclxuICAgICAgICAvLy8gYm90aCB0byB0cnVlIG1lYW5zIHlvdSBhcmUgZG9pbmcgYSBsaW5lLXNlZ21lbnQgdG8gbGluZS1zZWdtZW50XHJcbiAgICAgICAgLy8vIGludGVyc2VjdGlvbi4gU2V0dGluZyBvbmUgb2YgdGhlbSB0byB0cnVlIG1lYW5zIHlvdSBhcmUgZG9pbmcgYVxyXG4gICAgICAgIC8vLyBsaW5lIHRvIGxpbmUtc2VnbWVudCBpbnRlcnNlY3Rpb24gdGVzdCwgYW5kIHNvIG9uLlxyXG4gICAgICAgIC8vLyBOb3RlOiBJZiB0d28gbGluZSBzZWdtZW50cyBhcmUgY29pbmNpZGVudCwgdGhlbiBcclxuICAgICAgICAvLy8gbm8gaW50ZXJzZWN0aW9uIGlzIGRldGVjdGVkICh0aGVyZSBhcmUgYWN0dWFsbHlcclxuICAgICAgICAvLy8gaW5maW5pdGUgaW50ZXJzZWN0aW9uIHBvaW50cykuXHJcbiAgICAgICAgLy8vIEF1dGhvcjogSmVyZW15IEJlbGxcclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cInBvaW50MVwiPlRoZSBmaXJzdCBwb2ludCBvZiB0aGUgZmlyc3QgbGluZSBzZWdtZW50LjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwicG9pbnQyXCI+VGhlIHNlY29uZCBwb2ludCBvZiB0aGUgZmlyc3QgbGluZSBzZWdtZW50LjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwicG9pbnQzXCI+VGhlIGZpcnN0IHBvaW50IG9mIHRoZSBzZWNvbmQgbGluZSBzZWdtZW50LjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwicG9pbnQ0XCI+VGhlIHNlY29uZCBwb2ludCBvZiB0aGUgc2Vjb25kIGxpbmUgc2VnbWVudC48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cInBvaW50XCI+VGhpcyBpcyBzZXQgdG8gdGhlIGludGVyc2VjdGlvblxyXG4gICAgICAgIC8vLyBwb2ludCBpZiBhbiBpbnRlcnNlY3Rpb24gaXMgZGV0ZWN0ZWQuPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJmaXJzdElzU2VnbWVudFwiPlNldCB0aGlzIHRvIHRydWUgdG8gcmVxdWlyZSB0aGF0IHRoZSBcclxuICAgICAgICAvLy8gaW50ZXJzZWN0aW9uIHBvaW50IGJlIG9uIHRoZSBmaXJzdCBsaW5lIHNlZ21lbnQuPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJzZWNvbmRJc1NlZ21lbnRcIj5TZXQgdGhpcyB0byB0cnVlIHRvIHJlcXVpcmUgdGhhdCB0aGVcclxuICAgICAgICAvLy8gaW50ZXJzZWN0aW9uIHBvaW50IGJlIG9uIHRoZSBzZWNvbmQgbGluZSBzZWdtZW50LjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxyZXR1cm5zPlRydWUgaWYgYW4gaW50ZXJzZWN0aW9uIGlzIGRldGVjdGVkLCBmYWxzZSBvdGhlcndpc2UuPC9yZXR1cm5zPlxyXG4gICAgICAgIHB1YmxpYyBzdGF0aWMgYm9vbCBMaW5lSW50ZXJzZWN0KHJlZiBWZWN0b3IyIHBvaW50MSwgcmVmIFZlY3RvcjIgcG9pbnQyLCByZWYgVmVjdG9yMiBwb2ludDMsIHJlZiBWZWN0b3IyIHBvaW50NCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBib29sIGZpcnN0SXNTZWdtZW50LCBib29sIHNlY29uZElzU2VnbWVudCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdXQgVmVjdG9yMiBwb2ludClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHBvaW50ID0gbmV3IFZlY3RvcjIoKTtcclxuXHJcbiAgICAgICAgICAgIC8vIHRoZXNlIGFyZSByZXVzZWQgbGF0ZXIuXHJcbiAgICAgICAgICAgIC8vIGVhY2ggbGV0dGVyZWQgc3ViLWNhbGN1bGF0aW9uIGlzIHVzZWQgdHdpY2UsIGV4Y2VwdFxyXG4gICAgICAgICAgICAvLyBmb3IgYiBhbmQgZCwgd2hpY2ggYXJlIHVzZWQgMyB0aW1lc1xyXG4gICAgICAgICAgICBmbG9hdCBhID0gcG9pbnQ0LlkgLSBwb2ludDMuWTtcclxuICAgICAgICAgICAgZmxvYXQgYiA9IHBvaW50Mi5YIC0gcG9pbnQxLlg7XHJcbiAgICAgICAgICAgIGZsb2F0IGMgPSBwb2ludDQuWCAtIHBvaW50My5YO1xyXG4gICAgICAgICAgICBmbG9hdCBkID0gcG9pbnQyLlkgLSBwb2ludDEuWTtcclxuXHJcbiAgICAgICAgICAgIC8vIGRlbm9taW5hdG9yIHRvIHNvbHV0aW9uIG9mIGxpbmVhciBzeXN0ZW1cclxuICAgICAgICAgICAgZmxvYXQgZGVub20gPSAoYSAqIGIpIC0gKGMgKiBkKTtcclxuXHJcbiAgICAgICAgICAgIC8vIGlmIGRlbm9taW5hdG9yIGlzIDAsIHRoZW4gbGluZXMgYXJlIHBhcmFsbGVsXHJcbiAgICAgICAgICAgIGlmICghKGRlbm9tID49IC1TZXR0aW5ncy5FcHNpbG9uICYmIGRlbm9tIDw9IFNldHRpbmdzLkVwc2lsb24pKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBmbG9hdCBlID0gcG9pbnQxLlkgLSBwb2ludDMuWTtcclxuICAgICAgICAgICAgICAgIGZsb2F0IGYgPSBwb2ludDEuWCAtIHBvaW50My5YO1xyXG4gICAgICAgICAgICAgICAgZmxvYXQgb25lT3ZlckRlbm9tID0gMS4wZiAvIGRlbm9tO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIG51bWVyYXRvciBvZiBmaXJzdCBlcXVhdGlvblxyXG4gICAgICAgICAgICAgICAgZmxvYXQgdWEgPSAoYyAqIGUpIC0gKGEgKiBmKTtcclxuICAgICAgICAgICAgICAgIHVhICo9IG9uZU92ZXJEZW5vbTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBjaGVjayBpZiBpbnRlcnNlY3Rpb24gcG9pbnQgb2YgdGhlIHR3byBsaW5lcyBpcyBvbiBsaW5lIHNlZ21lbnQgMVxyXG4gICAgICAgICAgICAgICAgaWYgKCFmaXJzdElzU2VnbWVudCB8fCB1YSA+PSAwLjBmICYmIHVhIDw9IDEuMGYpXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gbnVtZXJhdG9yIG9mIHNlY29uZCBlcXVhdGlvblxyXG4gICAgICAgICAgICAgICAgICAgIGZsb2F0IHViID0gKGIgKiBlKSAtIChkICogZik7XHJcbiAgICAgICAgICAgICAgICAgICAgdWIgKj0gb25lT3ZlckRlbm9tO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBjaGVjayBpZiBpbnRlcnNlY3Rpb24gcG9pbnQgb2YgdGhlIHR3byBsaW5lcyBpcyBvbiBsaW5lIHNlZ21lbnQgMlxyXG4gICAgICAgICAgICAgICAgICAgIC8vIG1lYW5zIHRoZSBsaW5lIHNlZ21lbnRzIGludGVyc2VjdCwgc2luY2Ugd2Uga25vdyBpdCBpcyBvblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIHNlZ21lbnQgMSBhcyB3ZWxsLlxyXG4gICAgICAgICAgICAgICAgICAgIGlmICghc2Vjb25kSXNTZWdtZW50IHx8IHViID49IDAuMGYgJiYgdWIgPD0gMS4wZilcclxuICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNoZWNrIGlmIHRoZXkgYXJlIGNvaW5jaWRlbnQgKG5vIGNvbGxpc2lvbiBpbiB0aGlzIGNhc2UpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh1YSAhPSAwZiB8fCB1YiAhPSAwZilcclxuICAgICAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9UaGVyZSBpcyBhbiBpbnRlcnNlY3Rpb25cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvaW50LlggPSBwb2ludDEuWCArIHVhICogYjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvaW50LlkgPSBwb2ludDEuWSArIHVhICogZDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIFRoaXMgbWV0aG9kIGRldGVjdHMgaWYgdHdvIGxpbmUgc2VnbWVudHMgKG9yIGxpbmVzKSBpbnRlcnNlY3QsXHJcbiAgICAgICAgLy8vIGFuZCwgaWYgc28sIHRoZSBwb2ludCBvZiBpbnRlcnNlY3Rpb24uIFVzZSB0aGUgPHBhcmFtcmVmIG5hbWU9XCJmaXJzdElzU2VnbWVudFwiLz4gYW5kXHJcbiAgICAgICAgLy8vIDxwYXJhbXJlZiBuYW1lPVwic2Vjb25kSXNTZWdtZW50XCIvPiBwYXJhbWV0ZXJzIHRvIHNldCB3aGV0aGVyIHRoZSBpbnRlcnNlY3Rpb24gcG9pbnRcclxuICAgICAgICAvLy8gbXVzdCBiZSBvbiB0aGUgZmlyc3QgYW5kIHNlY29uZCBsaW5lIHNlZ21lbnRzLiBTZXR0aW5nIHRoZXNlXHJcbiAgICAgICAgLy8vIGJvdGggdG8gdHJ1ZSBtZWFucyB5b3UgYXJlIGRvaW5nIGEgbGluZS1zZWdtZW50IHRvIGxpbmUtc2VnbWVudFxyXG4gICAgICAgIC8vLyBpbnRlcnNlY3Rpb24uIFNldHRpbmcgb25lIG9mIHRoZW0gdG8gdHJ1ZSBtZWFucyB5b3UgYXJlIGRvaW5nIGFcclxuICAgICAgICAvLy8gbGluZSB0byBsaW5lLXNlZ21lbnQgaW50ZXJzZWN0aW9uIHRlc3QsIGFuZCBzbyBvbi5cclxuICAgICAgICAvLy8gTm90ZTogSWYgdHdvIGxpbmUgc2VnbWVudHMgYXJlIGNvaW5jaWRlbnQsIHRoZW4gXHJcbiAgICAgICAgLy8vIG5vIGludGVyc2VjdGlvbiBpcyBkZXRlY3RlZCAodGhlcmUgYXJlIGFjdHVhbGx5XHJcbiAgICAgICAgLy8vIGluZmluaXRlIGludGVyc2VjdGlvbiBwb2ludHMpLlxyXG4gICAgICAgIC8vLyBBdXRob3I6IEplcmVteSBCZWxsXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJwb2ludDFcIj5UaGUgZmlyc3QgcG9pbnQgb2YgdGhlIGZpcnN0IGxpbmUgc2VnbWVudC48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cInBvaW50MlwiPlRoZSBzZWNvbmQgcG9pbnQgb2YgdGhlIGZpcnN0IGxpbmUgc2VnbWVudC48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cInBvaW50M1wiPlRoZSBmaXJzdCBwb2ludCBvZiB0aGUgc2Vjb25kIGxpbmUgc2VnbWVudC48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cInBvaW50NFwiPlRoZSBzZWNvbmQgcG9pbnQgb2YgdGhlIHNlY29uZCBsaW5lIHNlZ21lbnQuPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJpbnRlcnNlY3Rpb25Qb2ludFwiPlRoaXMgaXMgc2V0IHRvIHRoZSBpbnRlcnNlY3Rpb25cclxuICAgICAgICAvLy8gcG9pbnQgaWYgYW4gaW50ZXJzZWN0aW9uIGlzIGRldGVjdGVkLjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwiZmlyc3RJc1NlZ21lbnRcIj5TZXQgdGhpcyB0byB0cnVlIHRvIHJlcXVpcmUgdGhhdCB0aGUgXHJcbiAgICAgICAgLy8vIGludGVyc2VjdGlvbiBwb2ludCBiZSBvbiB0aGUgZmlyc3QgbGluZSBzZWdtZW50LjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwic2Vjb25kSXNTZWdtZW50XCI+U2V0IHRoaXMgdG8gdHJ1ZSB0byByZXF1aXJlIHRoYXQgdGhlXHJcbiAgICAgICAgLy8vIGludGVyc2VjdGlvbiBwb2ludCBiZSBvbiB0aGUgc2Vjb25kIGxpbmUgc2VnbWVudC48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cmV0dXJucz5UcnVlIGlmIGFuIGludGVyc2VjdGlvbiBpcyBkZXRlY3RlZCwgZmFsc2Ugb3RoZXJ3aXNlLjwvcmV0dXJucz5cclxuICAgICAgICBwdWJsaWMgc3RhdGljIGJvb2wgTGluZUludGVyc2VjdChWZWN0b3IyIHBvaW50MSwgVmVjdG9yMiBwb2ludDIsIFZlY3RvcjIgcG9pbnQzLCBWZWN0b3IyIHBvaW50NCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBib29sIGZpcnN0SXNTZWdtZW50LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJvb2wgc2Vjb25kSXNTZWdtZW50LCBvdXQgVmVjdG9yMiBpbnRlcnNlY3Rpb25Qb2ludClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiBMaW5lSW50ZXJzZWN0KHJlZiBwb2ludDEsIHJlZiBwb2ludDIsIHJlZiBwb2ludDMsIHJlZiBwb2ludDQsIGZpcnN0SXNTZWdtZW50LCBzZWNvbmRJc1NlZ21lbnQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG91dCBpbnRlcnNlY3Rpb25Qb2ludCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIFRoaXMgbWV0aG9kIGRldGVjdHMgaWYgdHdvIGxpbmUgc2VnbWVudHMgaW50ZXJzZWN0LFxyXG4gICAgICAgIC8vLyBhbmQsIGlmIHNvLCB0aGUgcG9pbnQgb2YgaW50ZXJzZWN0aW9uLiBcclxuICAgICAgICAvLy8gTm90ZTogSWYgdHdvIGxpbmUgc2VnbWVudHMgYXJlIGNvaW5jaWRlbnQsIHRoZW4gXHJcbiAgICAgICAgLy8vIG5vIGludGVyc2VjdGlvbiBpcyBkZXRlY3RlZCAodGhlcmUgYXJlIGFjdHVhbGx5XHJcbiAgICAgICAgLy8vIGluZmluaXRlIGludGVyc2VjdGlvbiBwb2ludHMpLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwicG9pbnQxXCI+VGhlIGZpcnN0IHBvaW50IG9mIHRoZSBmaXJzdCBsaW5lIHNlZ21lbnQuPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJwb2ludDJcIj5UaGUgc2Vjb25kIHBvaW50IG9mIHRoZSBmaXJzdCBsaW5lIHNlZ21lbnQuPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJwb2ludDNcIj5UaGUgZmlyc3QgcG9pbnQgb2YgdGhlIHNlY29uZCBsaW5lIHNlZ21lbnQuPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJwb2ludDRcIj5UaGUgc2Vjb25kIHBvaW50IG9mIHRoZSBzZWNvbmQgbGluZSBzZWdtZW50LjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwiaW50ZXJzZWN0aW9uUG9pbnRcIj5UaGlzIGlzIHNldCB0byB0aGUgaW50ZXJzZWN0aW9uXHJcbiAgICAgICAgLy8vIHBvaW50IGlmIGFuIGludGVyc2VjdGlvbiBpcyBkZXRlY3RlZC48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cmV0dXJucz5UcnVlIGlmIGFuIGludGVyc2VjdGlvbiBpcyBkZXRlY3RlZCwgZmFsc2Ugb3RoZXJ3aXNlLjwvcmV0dXJucz5cclxuICAgICAgICBwdWJsaWMgc3RhdGljIGJvb2wgTGluZUludGVyc2VjdChyZWYgVmVjdG9yMiBwb2ludDEsIHJlZiBWZWN0b3IyIHBvaW50MiwgcmVmIFZlY3RvcjIgcG9pbnQzLCByZWYgVmVjdG9yMiBwb2ludDQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3V0IFZlY3RvcjIgaW50ZXJzZWN0aW9uUG9pbnQpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gTGluZUludGVyc2VjdChyZWYgcG9pbnQxLCByZWYgcG9pbnQyLCByZWYgcG9pbnQzLCByZWYgcG9pbnQ0LCB0cnVlLCB0cnVlLCBvdXQgaW50ZXJzZWN0aW9uUG9pbnQpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBUaGlzIG1ldGhvZCBkZXRlY3RzIGlmIHR3byBsaW5lIHNlZ21lbnRzIGludGVyc2VjdCxcclxuICAgICAgICAvLy8gYW5kLCBpZiBzbywgdGhlIHBvaW50IG9mIGludGVyc2VjdGlvbi4gXHJcbiAgICAgICAgLy8vIE5vdGU6IElmIHR3byBsaW5lIHNlZ21lbnRzIGFyZSBjb2luY2lkZW50LCB0aGVuIFxyXG4gICAgICAgIC8vLyBubyBpbnRlcnNlY3Rpb24gaXMgZGV0ZWN0ZWQgKHRoZXJlIGFyZSBhY3R1YWxseVxyXG4gICAgICAgIC8vLyBpbmZpbml0ZSBpbnRlcnNlY3Rpb24gcG9pbnRzKS5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cInBvaW50MVwiPlRoZSBmaXJzdCBwb2ludCBvZiB0aGUgZmlyc3QgbGluZSBzZWdtZW50LjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwicG9pbnQyXCI+VGhlIHNlY29uZCBwb2ludCBvZiB0aGUgZmlyc3QgbGluZSBzZWdtZW50LjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwicG9pbnQzXCI+VGhlIGZpcnN0IHBvaW50IG9mIHRoZSBzZWNvbmQgbGluZSBzZWdtZW50LjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwicG9pbnQ0XCI+VGhlIHNlY29uZCBwb2ludCBvZiB0aGUgc2Vjb25kIGxpbmUgc2VnbWVudC48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cImludGVyc2VjdGlvblBvaW50XCI+VGhpcyBpcyBzZXQgdG8gdGhlIGludGVyc2VjdGlvblxyXG4gICAgICAgIC8vLyBwb2ludCBpZiBhbiBpbnRlcnNlY3Rpb24gaXMgZGV0ZWN0ZWQuPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHJldHVybnM+VHJ1ZSBpZiBhbiBpbnRlcnNlY3Rpb24gaXMgZGV0ZWN0ZWQsIGZhbHNlIG90aGVyd2lzZS48L3JldHVybnM+XHJcbiAgICAgICAgcHVibGljIHN0YXRpYyBib29sIExpbmVJbnRlcnNlY3QoVmVjdG9yMiBwb2ludDEsIFZlY3RvcjIgcG9pbnQyLCBWZWN0b3IyIHBvaW50MywgVmVjdG9yMiBwb2ludDQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3V0IFZlY3RvcjIgaW50ZXJzZWN0aW9uUG9pbnQpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gTGluZUludGVyc2VjdChyZWYgcG9pbnQxLCByZWYgcG9pbnQyLCByZWYgcG9pbnQzLCByZWYgcG9pbnQ0LCB0cnVlLCB0cnVlLCBvdXQgaW50ZXJzZWN0aW9uUG9pbnQpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBHZXQgYWxsIGludGVyc2VjdGlvbnMgYmV0d2VlbiBhIGxpbmUgc2VnbWVudCBhbmQgYSBsaXN0IG9mIHZlcnRpY2VzXHJcbiAgICAgICAgLy8vIHJlcHJlc2VudGluZyBhIHBvbHlnb24uIFRoZSB2ZXJ0aWNlcyByZXVzZSBhZGphY2VudCBwb2ludHMsIHNvIGZvciBleGFtcGxlXHJcbiAgICAgICAgLy8vIGVkZ2VzIG9uZSBhbmQgdHdvIGFyZSBiZXR3ZWVuIHRoZSBmaXJzdCBhbmQgc2Vjb25kIHZlcnRpY2VzIGFuZCBiZXR3ZWVuIHRoZVxyXG4gICAgICAgIC8vLyBzZWNvbmQgYW5kIHRoaXJkIHZlcnRpY2VzLiBUaGUgbGFzdCBlZGdlIGlzIGJldHdlZW4gdmVydGV4IHZlcnRpY2VzLkNvdW50IC0gMVxyXG4gICAgICAgIC8vLyBhbmQgdmVydHMwLiAoaWUsIHZlcnRpY2VzIGZyb20gYSBHZW9tZXRyeSBvciBBQUJCKVxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwicG9pbnQxXCI+VGhlIGZpcnN0IHBvaW50IG9mIHRoZSBsaW5lIHNlZ21lbnQgdG8gdGVzdDwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwicG9pbnQyXCI+VGhlIHNlY29uZCBwb2ludCBvZiB0aGUgbGluZSBzZWdtZW50IHRvIHRlc3QuPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJ2ZXJ0aWNlc1wiPlRoZSB2ZXJ0aWNlcywgYXMgZGVzY3JpYmVkIGFib3ZlPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJpbnRlcnNlY3Rpb25Qb2ludHNcIj5BbiBsaXN0IG9mIGludGVyc2VjdGlvbiBwb2ludHMuIEFueSBpbnRlcnNlY3Rpb24gcG9pbnRzXHJcbiAgICAgICAgLy8vIGZvdW5kIHdpbGwgYmUgYWRkZWQgdG8gdGhpcyBsaXN0LjwvcGFyYW0+XHJcbiAgICAgICAgcHVibGljIHN0YXRpYyB2b2lkIExpbmVTZWdtZW50VmVydGljZXNJbnRlcnNlY3QocmVmIFZlY3RvcjIgcG9pbnQxLCByZWYgVmVjdG9yMiBwb2ludDIsIFZlcnRpY2VzIHZlcnRpY2VzLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlZiBMaXN0PFZlY3RvcjI+IGludGVyc2VjdGlvblBvaW50cylcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGZvciAoaW50IGkgPSAwOyBpIDwgdmVydGljZXMuQ291bnQ7IGkrKylcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgVmVjdG9yMiBwb2ludDtcclxuICAgICAgICAgICAgICAgIGlmIChMaW5lSW50ZXJzZWN0KHZlcnRpY2VzW2ldLCB2ZXJ0aWNlc1t2ZXJ0aWNlcy5OZXh0SW5kZXgoaSldLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9pbnQxLCBwb2ludDIsIHRydWUsIHRydWUsIG91dCBwb2ludCkpXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgaW50ZXJzZWN0aW9uUG9pbnRzLkFkZChwb2ludCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gR2V0IGFsbCBpbnRlcnNlY3Rpb25zIGJldHdlZW4gYSBsaW5lIHNlZ21lbnQgYW5kIGFuIEFBQkIuIFxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwicG9pbnQxXCI+VGhlIGZpcnN0IHBvaW50IG9mIHRoZSBsaW5lIHNlZ21lbnQgdG8gdGVzdDwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwicG9pbnQyXCI+VGhlIHNlY29uZCBwb2ludCBvZiB0aGUgbGluZSBzZWdtZW50IHRvIHRlc3QuPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJhYWJiXCI+VGhlIEFBQkIgdGhhdCBpcyB1c2VkIGZvciB0ZXN0aW5nIGludGVyc2VjdGlvbi48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cImludGVyc2VjdGlvblBvaW50c1wiPkFuIGxpc3Qgb2YgaW50ZXJzZWN0aW9uIHBvaW50cy4gQW55IGludGVyc2VjdGlvbiBwb2ludHMgZm91bmQgd2lsbCBiZSBhZGRlZCB0byB0aGlzIGxpc3QuPC9wYXJhbT5cclxuICAgICAgICBwdWJsaWMgc3RhdGljIHZvaWQgTGluZVNlZ21lbnRBQUJCSW50ZXJzZWN0KHJlZiBWZWN0b3IyIHBvaW50MSwgcmVmIFZlY3RvcjIgcG9pbnQyLCBBQUJCIGFhYmIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWYgTGlzdDxWZWN0b3IyPiBpbnRlcnNlY3Rpb25Qb2ludHMpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBMaW5lU2VnbWVudFZlcnRpY2VzSW50ZXJzZWN0KHJlZiBwb2ludDEsIHJlZiBwb2ludDIsIGFhYmIuVmVydGljZXMsIHJlZiBpbnRlcnNlY3Rpb25Qb2ludHMpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufSIsInVzaW5nIFN5c3RlbS5Db2xsZWN0aW9ucy5HZW5lcmljO1xyXG51c2luZyBGYXJzZWVyUGh5c2ljcy5Db2xsaXNpb247XHJcbnVzaW5nIE1pY3Jvc29mdC5YbmEuRnJhbWV3b3JrO1xyXG5cclxubmFtZXNwYWNlIEZhcnNlZXJQaHlzaWNzLkNvbW1vblxyXG57XHJcbiAgICAvLyBQb3J0ZWQgYnkgTWF0dGhldyBCZXR0Y2hlciAtIEZlYiAyMDExXHJcblxyXG4gICAgLypcclxuICAgIENvcHlyaWdodCAoYykgMjAxMCwgTHVjYSBEZWx0b2Rlc2NvXHJcbiAgICBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG5cclxuICAgIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGggb3Igd2l0aG91dCBtb2RpZmljYXRpb24sIGFyZSBwZXJtaXR0ZWRcclxuICAgIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBjb25kaXRpb25zIGFyZSBtZXQ6XHJcblxyXG4gICAgICAgICogUmVkaXN0cmlidXRpb25zIG9mIHNvdXJjZSBjb2RlIG11c3QgcmV0YWluIHRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlLCB0aGlzIGxpc3Qgb2YgY29uZGl0aW9uc1xyXG5cdCAgICAgIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIuXHJcbiAgICAgICAgKiBSZWRpc3RyaWJ1dGlvbnMgaW4gYmluYXJ5IGZvcm0gbXVzdCByZXByb2R1Y2UgdGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UsIHRoaXMgbGlzdCBvZlxyXG5cdCAgICAgIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lciBpbiB0aGUgZG9jdW1lbnRhdGlvbiBhbmQvb3Igb3RoZXIgbWF0ZXJpYWxzIHByb3ZpZGVkXHJcblx0ICAgICAgd2l0aCB0aGUgZGlzdHJpYnV0aW9uLlxyXG4gICAgICAgICogTmVpdGhlciB0aGUgbmFtZSBvZiB0aGUgbmFwZSBwcm9qZWN0IG5vciB0aGUgbmFtZXMgb2YgaXRzIGNvbnRyaWJ1dG9ycyBtYXkgYmUgdXNlZCB0byBlbmRvcnNlXHJcblx0ICAgICBvciBwcm9tb3RlIHByb2R1Y3RzIGRlcml2ZWQgZnJvbSB0aGlzIHNvZnR3YXJlIHdpdGhvdXQgc3BlY2lmaWMgcHJpb3Igd3JpdHRlbiBwZXJtaXNzaW9uLlxyXG5cclxuICAgIFRISVMgU09GVFdBUkUgSVMgUFJPVklERUQgQlkgVEhFIENPUFlSSUdIVCBIT0xERVJTIEFORCBDT05UUklCVVRPUlMgXCJBUyBJU1wiIEFORCBBTlkgRVhQUkVTUyBPUlxyXG4gICAgSU1QTElFRCBXQVJSQU5USUVTLCBJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRCBUTywgVEhFIElNUExJRUQgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFkgQU5EXHJcbiAgICBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBUkUgRElTQ0xBSU1FRC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIENPUFlSSUdIVCBIT0xERVIgT1JcclxuICAgIENPTlRSSUJVVE9SUyBCRSBMSUFCTEUgRk9SIEFOWSBESVJFQ1QsIElORElSRUNULCBJTkNJREVOVEFMLCBTUEVDSUFMLCBFWEVNUExBUlksIE9SIENPTlNFUVVFTlRJQUxcclxuICAgIERBTUFHRVMgKElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLCBQUk9DVVJFTUVOVCBPRiBTVUJTVElUVVRFIEdPT0RTIE9SIFNFUlZJQ0VTOyBMT1NTIE9GIFVTRSxcclxuICAgIERBVEEsIE9SIFBST0ZJVFM7IE9SIEJVU0lORVNTIElOVEVSUlVQVElPTikgSE9XRVZFUiBDQVVTRUQgQU5EIE9OIEFOWSBUSEVPUlkgT0YgTElBQklMSVRZLCBXSEVUSEVSXHJcbiAgICBJTiBDT05UUkFDVCwgU1RSSUNUIExJQUJJTElUWSwgT1IgVE9SVCAoSU5DTFVESU5HIE5FR0xJR0VOQ0UgT1IgT1RIRVJXSVNFKSBBUklTSU5HIElOIEFOWSBXQVkgT1VUXHJcbiAgICBPRiBUSEUgVVNFIE9GIFRISVMgU09GVFdBUkUsIEVWRU4gSUYgQURWSVNFRCBPRiBUSEUgUE9TU0lCSUxJVFkgT0YgU1VDSCBEQU1BR0UuXHJcbiAgICAqL1xyXG5cclxuICAgIHB1YmxpYyBzdGF0aWMgY2xhc3MgTWFyY2hpbmdTcXVhcmVzXHJcbiAgICB7XHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBNYXJjaGluZyBzcXVhcmVzIG92ZXIgdGhlIGdpdmVuIGRvbWFpbiB1c2luZyB0aGUgbWVzaCBkZWZpbmVkIHZpYSB0aGUgZGltZW5zaW9uc1xyXG4gICAgICAgIC8vLyAgICAod2lkLGhlaSkgdG8gYnVpbGQgYSBzZXQgb2YgcG9seWdvbnMgc3VjaCB0aGF0IGYoeCx5KSBsZXNzIHRoYW4gMCwgdXNpbmcgdGhlIGdpdmVuIG51bWJlclxyXG4gICAgICAgIC8vLyAgICAnYmluJyBmb3IgcmVjdXJzaXZlIGxpbmVhciBpbnRlcHJvbGF0aW9uIGFsb25nIGNlbGwgYm91bmRhcmllcy5cclxuICAgICAgICAvLy9cclxuICAgICAgICAvLy8gICAgaWYgJ2NvbWInIGlzIHRydWUsIHRoZW4gdGhlIHBvbHlnb25zIHdpbGwgYWxzbyBiZSBjb21wb3NpdGVkIGludG8gbGFyZ2VyIHBvc3NpYmxlIGNvbmNhdmVcclxuICAgICAgICAvLy8gICAgcG9seWdvbnMuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJkb21haW5cIj48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cImNlbGxXaWR0aFwiPjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwiY2VsbEhlaWdodFwiPjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwiZlwiPjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwibGVycENvdW50XCI+PC9wYXJhbT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJjb21iaW5lXCI+PC9wYXJhbT5cclxuICAgICAgICAvLy8gPHJldHVybnM+PC9yZXR1cm5zPlxyXG4gICAgICAgIHB1YmxpYyBzdGF0aWMgTGlzdDxWZXJ0aWNlcz4gRGV0ZWN0U3F1YXJlcyhBQUJCIGRvbWFpbiwgZmxvYXQgY2VsbFdpZHRoLCBmbG9hdCBjZWxsSGVpZ2h0LCBzYnl0ZVssXSBmLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnQgbGVycENvdW50LCBib29sIGNvbWJpbmUpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBDeEZhc3RMaXN0PEdlb21Qb2x5PiByZXQgPSBuZXcgQ3hGYXN0TGlzdDxHZW9tUG9seT4oKTtcclxuXHJcbiAgICAgICAgICAgIExpc3Q8VmVydGljZXM+IHZlcnRpY2VzTGlzdCA9IG5ldyBMaXN0PFZlcnRpY2VzPigpO1xyXG5cclxuICAgICAgICAgICAgLy9OT1RFOiByZW1vdmVkIGFzc2lnbm1lbnRzIGFzIHRoZXkgd2VyZSBub3QgdXNlZC5cclxuICAgICAgICAgICAgTGlzdDxHZW9tUG9seT4gcG9seUxpc3Q7XHJcbiAgICAgICAgICAgIEdlb21Qb2x5IGdwO1xyXG5cclxuICAgICAgICAgICAgaW50IHhuID0gKGludCkoZG9tYWluLkV4dGVudHMuWCAqIDIgLyBjZWxsV2lkdGgpO1xyXG4gICAgICAgICAgICBib29sIHhwID0geG4gPT0gKGRvbWFpbi5FeHRlbnRzLlggKiAyIC8gY2VsbFdpZHRoKTtcclxuICAgICAgICAgICAgaW50IHluID0gKGludCkoZG9tYWluLkV4dGVudHMuWSAqIDIgLyBjZWxsSGVpZ2h0KTtcclxuICAgICAgICAgICAgYm9vbCB5cCA9IHluID09IChkb21haW4uRXh0ZW50cy5ZICogMiAvIGNlbGxIZWlnaHQpO1xyXG4gICAgICAgICAgICBpZiAoIXhwKSB4bisrO1xyXG4gICAgICAgICAgICBpZiAoIXlwKSB5bisrO1xyXG5cclxuICAgICAgICAgICAgc2J5dGVbLF0gZnMgPSBuZXcgc2J5dGVbeG4gKyAxLCB5biArIDFdO1xyXG4gICAgICAgICAgICBHZW9tUG9seVZhbFssXSBwcyA9IG5ldyBHZW9tUG9seVZhbFt4biArIDEsIHluICsgMV07XHJcblxyXG4gICAgICAgICAgICAvL3BvcHVsYXRlIHNoYXJlZCBmdW5jdGlvbiBsb29rdXBzLlxyXG4gICAgICAgICAgICBmb3IgKGludCB4ID0gMDsgeCA8IHhuICsgMTsgeCsrKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBpbnQgeDA7XHJcbiAgICAgICAgICAgICAgICBpZiAoeCA9PSB4bikgeDAgPSAoaW50KWRvbWFpbi5VcHBlckJvdW5kLlg7XHJcbiAgICAgICAgICAgICAgICBlbHNlIHgwID0gKGludCkoeCAqIGNlbGxXaWR0aCArIGRvbWFpbi5Mb3dlckJvdW5kLlgpO1xyXG4gICAgICAgICAgICAgICAgZm9yIChpbnQgeSA9IDA7IHkgPCB5biArIDE7IHkrKylcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBpbnQgeTA7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHkgPT0geW4pIHkwID0gKGludClkb21haW4uVXBwZXJCb3VuZC5ZO1xyXG4gICAgICAgICAgICAgICAgICAgIGVsc2UgeTAgPSAoaW50KSh5ICogY2VsbEhlaWdodCArIGRvbWFpbi5Mb3dlckJvdW5kLlkpO1xyXG4gICAgICAgICAgICAgICAgICAgIGZzW3gsIHldID0gZlt4MCwgeTBdO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvL2dlbmVyYXRlIHN1Yi1wb2x5cyBhbmQgY29tYmluZSB0byBzY2FuIGxpbmVzXHJcbiAgICAgICAgICAgIGZvciAoaW50IHkgPSAwOyB5IDwgeW47IHkrKylcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgZmxvYXQgeTAgPSB5ICogY2VsbEhlaWdodCArIGRvbWFpbi5Mb3dlckJvdW5kLlk7XHJcbiAgICAgICAgICAgICAgICBmbG9hdCB5MTtcclxuICAgICAgICAgICAgICAgIGlmICh5ID09IHluIC0gMSkgeTEgPSBkb21haW4uVXBwZXJCb3VuZC5ZO1xyXG4gICAgICAgICAgICAgICAgZWxzZSB5MSA9IHkwICsgY2VsbEhlaWdodDtcclxuICAgICAgICAgICAgICAgIEdlb21Qb2x5IHByZSA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICBmb3IgKGludCB4ID0gMDsgeCA8IHhuOyB4KyspXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgZmxvYXQgeDAgPSB4ICogY2VsbFdpZHRoICsgZG9tYWluLkxvd2VyQm91bmQuWDtcclxuICAgICAgICAgICAgICAgICAgICBmbG9hdCB4MTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoeCA9PSB4biAtIDEpIHgxID0gZG9tYWluLlVwcGVyQm91bmQuWDtcclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHgxID0geDAgKyBjZWxsV2lkdGg7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGdwID0gbmV3IEdlb21Qb2x5KCk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGludCBrZXkgPSBNYXJjaFNxdWFyZShmLCBmcywgcmVmIGdwLCB4LCB5LCB4MCwgeTAsIHgxLCB5MSwgbGVycENvdW50KTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoZ3AuTGVuZ3RoICE9IDApXHJcbiAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29tYmluZSAmJiBwcmUgIT0gbnVsbCAmJiAoa2V5ICYgOSkgIT0gMClcclxuICAgICAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29tYkxlZnQocmVmIHByZSwgcmVmIGdwKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdwID0gcHJlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldC5BZGQoZ3ApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBwc1t4LCB5XSA9IG5ldyBHZW9tUG9seVZhbChncCwga2V5KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBncCA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICAgICAgcHJlID0gZ3A7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKCFjb21iaW5lKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBwb2x5TGlzdCA9IHJldC5HZXRMaXN0T2ZFbGVtZW50cygpO1xyXG5cclxuICAgICAgICAgICAgICAgIGZvcmVhY2ggKEdlb21Qb2x5IHBvbHkgaW4gcG9seUxpc3QpXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmVydGljZXNMaXN0LkFkZChuZXcgVmVydGljZXMocG9seS5Qb2ludHMuR2V0TGlzdE9mRWxlbWVudHMoKSkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIHJldHVybiB2ZXJ0aWNlc0xpc3Q7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vY29tYmluZSBzY2FuIGxpbmVzIHRvZ2V0aGVyXHJcbiAgICAgICAgICAgIGZvciAoaW50IHkgPSAxOyB5IDwgeW47IHkrKylcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgaW50IHggPSAwO1xyXG4gICAgICAgICAgICAgICAgd2hpbGUgKHggPCB4bilcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBHZW9tUG9seVZhbCBwID0gcHNbeCwgeV07XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vc2tpcCBhbG9uZyBzY2FuIGxpbmUgaWYgbm8gcG9seWdvbiBleGlzdHMgYXQgdGhpcyBwb2ludFxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChwID09IG51bGwpXHJcbiAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB4Kys7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy9za2lwIGFsb25nIGlmIGN1cnJlbnQgcG9seWdvbiBjYW5ub3QgYmUgY29tYmluZWQgYWJvdmUuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKChwLktleSAmIDEyKSA9PSAwKVxyXG4gICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgeCsrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vc2tpcCBhbG9uZyBpZiBubyBwb2x5Z29uIGV4aXN0cyBhYm92ZS5cclxuICAgICAgICAgICAgICAgICAgICBHZW9tUG9seVZhbCB1ID0gcHNbeCwgeSAtIDFdO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh1ID09IG51bGwpXHJcbiAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB4Kys7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy9za2lwIGFsb25nIGlmIHBvbHlnb24gYWJvdmUgY2Fubm90IGJlIGNvbWJpbmVkIHdpdGguXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCh1LktleSAmIDMpID09IDApXHJcbiAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB4Kys7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgZmxvYXQgYXggPSB4ICogY2VsbFdpZHRoICsgZG9tYWluLkxvd2VyQm91bmQuWDtcclxuICAgICAgICAgICAgICAgICAgICBmbG9hdCBheSA9IHkgKiBjZWxsSGVpZ2h0ICsgZG9tYWluLkxvd2VyQm91bmQuWTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgQ3hGYXN0TGlzdDxWZWN0b3IyPiBicCA9IHAuR2VvbVAuUG9pbnRzO1xyXG4gICAgICAgICAgICAgICAgICAgIEN4RmFzdExpc3Q8VmVjdG9yMj4gYXAgPSB1Lkdlb21QLlBvaW50cztcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy9za2lwIGlmIGl0J3MgYWxyZWFkeSBiZWVuIGNvbWJpbmVkIHdpdGggYWJvdmUgcG9seWdvblxyXG4gICAgICAgICAgICAgICAgICAgIGlmICh1Lkdlb21QID09IHAuR2VvbVApXHJcbiAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB4Kys7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy9jb21iaW5lIGFib3ZlIChidXQgZGlzYWxsb3cgdGhlIGhvbGUgdGhpbmdpZXNcclxuICAgICAgICAgICAgICAgICAgICBDeEZhc3RMaXN0Tm9kZTxWZWN0b3IyPiBiaSA9IGJwLkJlZ2luKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKFNxdWFyZShiaS5FbGVtKCkuWSAtIGF5KSA+IFNldHRpbmdzLkVwc2lsb24gfHwgYmkuRWxlbSgpLlggPCBheCkgYmkgPSBiaS5OZXh0KCk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vTk9URTogVW51c2VkXHJcbiAgICAgICAgICAgICAgICAgICAgLy9WZWN0b3IyIGIwID0gYmkuZWxlbSgpO1xyXG4gICAgICAgICAgICAgICAgICAgIFZlY3RvcjIgYjEgPSBiaS5OZXh0KCkuRWxlbSgpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChTcXVhcmUoYjEuWSAtIGF5KSA+IFNldHRpbmdzLkVwc2lsb24pXHJcbiAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB4Kys7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgYm9vbCBicmsgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIEN4RmFzdExpc3ROb2RlPFZlY3RvcjI+IGFpID0gYXAuQmVnaW4oKTtcclxuICAgICAgICAgICAgICAgICAgICB3aGlsZSAoYWkgIT0gYXAuRW5kKCkpXHJcbiAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoVmVjRHNxKGFpLkVsZW0oKSwgYjEpIDwgU2V0dGluZ3MuRXBzaWxvbilcclxuICAgICAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJrID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBhaSA9IGFpLk5leHQoKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGJyaylcclxuICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHgrKztcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICBDeEZhc3RMaXN0Tm9kZTxWZWN0b3IyPiBiaiA9IGJpLk5leHQoKS5OZXh0KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGJqID09IGJwLkVuZCgpKSBiaiA9IGJwLkJlZ2luKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKGJqICE9IGJpKVxyXG4gICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYWkgPSBhcC5JbnNlcnQoYWksIGJqLkVsZW0oKSk7IC8vIC5jbG9uZSgpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJqID0gYmouTmV4dCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYmogPT0gYnAuRW5kKCkpIGJqID0gYnAuQmVnaW4oKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdS5HZW9tUC5MZW5ndGgrKztcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgLy91LnAuc2ltcGxpZnkoZmxvYXQuRXBzaWxvbixmbG9hdC5FcHNpbG9uKTtcclxuICAgICAgICAgICAgICAgICAgICAvL1xyXG4gICAgICAgICAgICAgICAgICAgIGF4ID0geCArIDE7XHJcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKGF4IDwgeG4pXHJcbiAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBHZW9tUG9seVZhbCBwMiA9IHBzWyhpbnQpYXgsIHldO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocDIgPT0gbnVsbCB8fCBwMi5HZW9tUCAhPSBwLkdlb21QKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBheCsrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgcDIuR2VvbVAgPSB1Lkdlb21QO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBheCsrO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBheCA9IHggLSAxO1xyXG4gICAgICAgICAgICAgICAgICAgIHdoaWxlIChheCA+PSAwKVxyXG4gICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgR2VvbVBvbHlWYWwgcDIgPSBwc1soaW50KWF4LCB5XTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHAyID09IG51bGwgfHwgcDIuR2VvbVAgIT0gcC5HZW9tUClcclxuICAgICAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXgtLTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHAyLkdlb21QID0gdS5HZW9tUDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYXgtLTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0LlJlbW92ZShwLkdlb21QKTtcclxuICAgICAgICAgICAgICAgICAgICBwLkdlb21QID0gdS5HZW9tUDtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgeCA9IChpbnQpKChiaS5OZXh0KCkuRWxlbSgpLlggLSBkb21haW4uTG93ZXJCb3VuZC5YKSAvIGNlbGxXaWR0aCkgKyAxO1xyXG4gICAgICAgICAgICAgICAgICAgIC8veCsrOyB0aGlzIHdhcyBhbHJlYWR5IGNvbW1lbnRlZCBvdXQhXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHBvbHlMaXN0ID0gcmV0LkdldExpc3RPZkVsZW1lbnRzKCk7XHJcblxyXG4gICAgICAgICAgICBmb3JlYWNoIChHZW9tUG9seSBwb2x5IGluIHBvbHlMaXN0KVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB2ZXJ0aWNlc0xpc3QuQWRkKG5ldyBWZXJ0aWNlcyhwb2x5LlBvaW50cy5HZXRMaXN0T2ZFbGVtZW50cygpKSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHJldHVybiB2ZXJ0aWNlc0xpc3Q7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAjcmVnaW9uIFByaXZhdGUgTWV0aG9kc1xyXG5cclxuICAgICAgICAvLy0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSBcclxuXHJcbiAgICAgICAgLyoqIExpbmVhcmx5IGludGVycG9sYXRlIGJldHdlZW4gKHgwIHRvIHgxKSBnaXZlbiBhIHZhbHVlIGF0IHRoZXNlIGNvb3JkaW5hdGVzICh2MCBhbmQgdjEpXHJcbiAgICAgICAgICAgIHN1Y2ggYXMgdG8gYXBwcm94aW1hdGUgdmFsdWUocmV0dXJuKSA9IDBcclxuICAgICAgICAqKi9cclxuXHJcbiAgICAgICAgcHJpdmF0ZSBzdGF0aWMgaW50W10gX2xvb2tNYXJjaCA9IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDB4MDAsIDB4RTAsIDB4MzgsIDB4RDgsIDB4MEUsIDB4RUUsIDB4MzYsIDB4RDYsIDB4ODMsIDB4NjMsIDE4NywgOTEsIDB4OEQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAweDZELCAxODEsIDB4NTVcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgcHJpdmF0ZSBzdGF0aWMgZmxvYXQgTGVycChmbG9hdCB4MCwgZmxvYXQgeDEsIGZsb2F0IHYwLCBmbG9hdCB2MSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGZsb2F0IGR2ID0gdjAgLSB2MTtcclxuICAgICAgICAgICAgZmxvYXQgdDtcclxuICAgICAgICAgICAgaWYgKGR2ICogZHYgPCBTZXR0aW5ncy5FcHNpbG9uKVxyXG4gICAgICAgICAgICAgICAgdCA9IDAuNWY7XHJcbiAgICAgICAgICAgIGVsc2UgdCA9IHYwIC8gZHY7XHJcbiAgICAgICAgICAgIHJldHVybiB4MCArIHQgKiAoeDEgLSB4MCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSAtIC0gLSBcclxuXHJcbiAgICAgICAgLyoqIFJlY3Vyc2l2ZSBsaW5lYXIgaW50ZXJwb2xhdGlvbiBmb3IgdXNlIGluIG1hcmNoaW5nIHNxdWFyZXMgKiovXHJcblxyXG4gICAgICAgIHByaXZhdGUgc3RhdGljIGZsb2F0IFhsZXJwKGZsb2F0IHgwLCBmbG9hdCB4MSwgZmxvYXQgeSwgZmxvYXQgdjAsIGZsb2F0IHYxLCBzYnl0ZVssXSBmLCBpbnQgYylcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGZsb2F0IHhtID0gTGVycCh4MCwgeDEsIHYwLCB2MSk7XHJcbiAgICAgICAgICAgIGlmIChjID09IDApXHJcbiAgICAgICAgICAgICAgICByZXR1cm4geG07XHJcblxyXG4gICAgICAgICAgICBzYnl0ZSB2bSA9IGZbKGludCl4bSwgKGludCl5XTtcclxuXHJcbiAgICAgICAgICAgIGlmICh2MCAqIHZtIDwgMClcclxuICAgICAgICAgICAgICAgIHJldHVybiBYbGVycCh4MCwgeG0sIHksIHYwLCB2bSwgZiwgYyAtIDEpO1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIFhsZXJwKHhtLCB4MSwgeSwgdm0sIHYxLCBmLCBjIC0gMSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvKiogUmVjdXJzaXZlIGxpbmVhciBpbnRlcnBvbGF0aW9uIGZvciB1c2UgaW4gbWFyY2hpbmcgc3F1YXJlcyAqKi9cclxuXHJcbiAgICAgICAgcHJpdmF0ZSBzdGF0aWMgZmxvYXQgWWxlcnAoZmxvYXQgeTAsIGZsb2F0IHkxLCBmbG9hdCB4LCBmbG9hdCB2MCwgZmxvYXQgdjEsIHNieXRlWyxdIGYsIGludCBjKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgZmxvYXQgeW0gPSBMZXJwKHkwLCB5MSwgdjAsIHYxKTtcclxuICAgICAgICAgICAgaWYgKGMgPT0gMClcclxuICAgICAgICAgICAgICAgIHJldHVybiB5bTtcclxuXHJcbiAgICAgICAgICAgIHNieXRlIHZtID0gZlsoaW50KXgsIChpbnQpeW1dO1xyXG5cclxuICAgICAgICAgICAgaWYgKHYwICogdm0gPCAwKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFlsZXJwKHkwLCB5bSwgeCwgdjAsIHZtLCBmLCBjIC0gMSk7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gWWxlcnAoeW0sIHkxLCB4LCB2bSwgdjEsIGYsIGMgLSAxKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8qKiBTcXVhcmUgdmFsdWUgZm9yIHVzZSBpbiBtYXJjaGluZyBzcXVhcmVzICoqL1xyXG5cclxuICAgICAgICBwcml2YXRlIHN0YXRpYyBmbG9hdCBTcXVhcmUoZmxvYXQgeClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiB4ICogeDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHByaXZhdGUgc3RhdGljIGZsb2F0IFZlY0RzcShWZWN0b3IyIGEsIFZlY3RvcjIgYilcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIFZlY3RvcjIgZCA9IGEgLSBiO1xyXG4gICAgICAgICAgICByZXR1cm4gZC5YICogZC5YICsgZC5ZICogZC5ZO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHJpdmF0ZSBzdGF0aWMgZmxvYXQgVmVjQ3Jvc3MoVmVjdG9yMiBhLCBWZWN0b3IyIGIpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gYS5YICogYi5ZIC0gYS5ZICogYi5YO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLyoqIExvb2stdXAgdGFibGUgdG8gcmVsYXRlIHBvbHlnb24ga2V5IHdpdGggdGhlIHZlcnRpY2VzIHRoYXQgc2hvdWxkIGJlIHVzZWQgZm9yXHJcbiAgICAgICAgICAgIHRoZSBzdWIgcG9seWdvbiBpbiBtYXJjaGluZyBzcXVhcmVzXHJcbiAgICAgICAgKiovXHJcblxyXG4gICAgICAgIC8qKiBQZXJmb3JtIGEgc2luZ2xlIGNlbGxlZCBtYXJjaGluZyBzcXVhcmUgZm9yIGZvciB0aGUgZ2l2ZW4gY2VsbCBkZWZpbmVkIGJ5ICh4MCx5MCkgKHgxLHkxKVxyXG4gICAgICAgICAgICB1c2luZyB0aGUgZnVuY3Rpb24gZiBmb3IgcmVjdXJzaXZlIGludGVycG9sYXRpb24sIGdpdmVuIHRoZSBsb29rLXVwIHRhYmxlICdmcycgb2ZcclxuICAgICAgICAgICAgdGhlIHZhbHVlcyBvZiAnZicgYXQgY2VsbCB2ZXJ0aWNlcyB3aXRoIHRoZSByZXN1bHQgdG8gYmUgc3RvcmVkIGluICdwb2x5JyBnaXZlbiB0aGUgYWN0dWFsXHJcbiAgICAgICAgICAgIGNvb3JkaW5hdGVzIG9mICdheCcgJ2F5JyBpbiB0aGUgbWFyY2hpbmcgc3F1YXJlcyBtZXNoLlxyXG4gICAgICAgICoqL1xyXG5cclxuICAgICAgICBwcml2YXRlIHN0YXRpYyBpbnQgTWFyY2hTcXVhcmUoc2J5dGVbLF0gZiwgc2J5dGVbLF0gZnMsIHJlZiBHZW9tUG9seSBwb2x5LCBpbnQgYXgsIGludCBheSwgZmxvYXQgeDAsIGZsb2F0IHkwLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmbG9hdCB4MSwgZmxvYXQgeTEsIGludCBiaW4pXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICAvL2tleSBsb29rdXBcclxuICAgICAgICAgICAgaW50IGtleSA9IDA7XHJcbiAgICAgICAgICAgIHNieXRlIHYwID0gZnNbYXgsIGF5XTtcclxuICAgICAgICAgICAgaWYgKHYwIDwgMCkga2V5IHw9IDg7XHJcbiAgICAgICAgICAgIHNieXRlIHYxID0gZnNbYXggKyAxLCBheV07XHJcbiAgICAgICAgICAgIGlmICh2MSA8IDApIGtleSB8PSA0O1xyXG4gICAgICAgICAgICBzYnl0ZSB2MiA9IGZzW2F4ICsgMSwgYXkgKyAxXTtcclxuICAgICAgICAgICAgaWYgKHYyIDwgMCkga2V5IHw9IDI7XHJcbiAgICAgICAgICAgIHNieXRlIHYzID0gZnNbYXgsIGF5ICsgMV07XHJcbiAgICAgICAgICAgIGlmICh2MyA8IDApIGtleSB8PSAxO1xyXG5cclxuICAgICAgICAgICAgaW50IHZhbCA9IF9sb29rTWFyY2hba2V5XTtcclxuICAgICAgICAgICAgaWYgKHZhbCAhPSAwKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBDeEZhc3RMaXN0Tm9kZTxWZWN0b3IyPiBwaSA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICBmb3IgKGludCBpID0gMDsgaSA8IDg7IGkrKylcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBWZWN0b3IyIHA7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCh2YWwgJiAoMSA8PCBpKSkgIT0gMClcclxuICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpID09IDcgJiYgKHZhbCAmIDEpID09IDApXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb2x5LlBvaW50cy5BZGQocCA9IG5ldyBWZWN0b3IyKHgwLCBZbGVycCh5MCwgeTEsIHgwLCB2MCwgdjMsIGYsIGJpbikpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaSA9PSAwKSBwID0gbmV3IFZlY3RvcjIoeDAsIHkwKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGkgPT0gMikgcCA9IG5ldyBWZWN0b3IyKHgxLCB5MCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChpID09IDQpIHAgPSBuZXcgVmVjdG9yMih4MSwgeTEpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoaSA9PSA2KSBwID0gbmV3IFZlY3RvcjIoeDAsIHkxKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChpID09IDEpIHAgPSBuZXcgVmVjdG9yMihYbGVycCh4MCwgeDEsIHkwLCB2MCwgdjEsIGYsIGJpbiksIHkwKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGkgPT0gNSkgcCA9IG5ldyBWZWN0b3IyKFhsZXJwKHgwLCB4MSwgeTEsIHYzLCB2MiwgZiwgYmluKSwgeTEpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGkgPT0gMykgcCA9IG5ldyBWZWN0b3IyKHgxLCBZbGVycCh5MCwgeTEsIHgxLCB2MSwgdjIsIGYsIGJpbikpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBwID0gbmV3IFZlY3RvcjIoeDAsIFlsZXJwKHkwLCB5MSwgeDAsIHYwLCB2MywgZiwgYmluKSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGkgPSBwb2x5LlBvaW50cy5JbnNlcnQocGksIHApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvbHkuTGVuZ3RoKys7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLy9wb2x5LnNpbXBsaWZ5KGZsb2F0LkVwc2lsb24sZmxvYXQuRXBzaWxvbik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIGtleTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8qKiBVc2VkIGluIHBvbHlnb24gY29tcG9zaXRpb24gdG8gY29tcG9zaXQgcG9seWdvbnMgaW50byBzY2FuIGxpbmVzXHJcbiAgICAgICAgICAgIENvbWJpbmluZyBwb2x5YSBhbmQgcG9seWIgaW50byBvbmUgc3VwZXItcG9seWdvbiBzdG9yZWQgaW4gcG9seWEuXHJcbiAgICAgICAgKiovXHJcblxyXG4gICAgICAgIHByaXZhdGUgc3RhdGljIHZvaWQgY29tYkxlZnQocmVmIEdlb21Qb2x5IHBvbHlhLCByZWYgR2VvbVBvbHkgcG9seWIpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBDeEZhc3RMaXN0PFZlY3RvcjI+IGFwID0gcG9seWEuUG9pbnRzO1xyXG4gICAgICAgICAgICBDeEZhc3RMaXN0PFZlY3RvcjI+IGJwID0gcG9seWIuUG9pbnRzO1xyXG4gICAgICAgICAgICBDeEZhc3RMaXN0Tm9kZTxWZWN0b3IyPiBhaSA9IGFwLkJlZ2luKCk7XHJcbiAgICAgICAgICAgIEN4RmFzdExpc3ROb2RlPFZlY3RvcjI+IGJpID0gYnAuQmVnaW4oKTtcclxuXHJcbiAgICAgICAgICAgIFZlY3RvcjIgYiA9IGJpLkVsZW0oKTtcclxuICAgICAgICAgICAgQ3hGYXN0TGlzdE5vZGU8VmVjdG9yMj4gcHJlYSA9IG51bGw7XHJcbiAgICAgICAgICAgIHdoaWxlIChhaSAhPSBhcC5FbmQoKSlcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgVmVjdG9yMiBhID0gYWkuRWxlbSgpO1xyXG4gICAgICAgICAgICAgICAgaWYgKFZlY0RzcShhLCBiKSA8IFNldHRpbmdzLkVwc2lsb24pXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy9pZ25vcmUgc2hhcmVkIHZlcnRleCBpZiBwYXJhbGxlbFxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChwcmVhICE9IG51bGwpXHJcbiAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBWZWN0b3IyIGEwID0gcHJlYS5FbGVtKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGIgPSBiaS5OZXh0KCkuRWxlbSgpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgVmVjdG9yMiB1ID0gYSAtIGEwO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvL3ZlY19uZXcodSk7IHZlY19zdWIoYS5wLnAsIGEwLnAucCwgdSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIFZlY3RvcjIgdiA9IGIgLSBhO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvL3ZlY19uZXcodik7IHZlY19zdWIoYi5wLnAsIGEucC5wLCB2KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZmxvYXQgZG90ID0gVmVjQ3Jvc3ModSwgdik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkb3QgKiBkb3QgPCBTZXR0aW5ncy5FcHNpbG9uKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcC5FcmFzZShwcmVhLCBhaSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb2x5YS5MZW5ndGgtLTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFpID0gcHJlYTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy9pbnNlcnQgcG9seWIgaW50byBwb2x5YVxyXG4gICAgICAgICAgICAgICAgICAgIGJvb2wgZnN0ID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICBDeEZhc3RMaXN0Tm9kZTxWZWN0b3IyPiBwcmViID0gbnVsbDtcclxuICAgICAgICAgICAgICAgICAgICB3aGlsZSAoIWJwLkVtcHR5KCkpXHJcbiAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBWZWN0b3IyIGJiID0gYnAuRnJvbnQoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnAuUG9wKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghZnN0ICYmICFicC5FbXB0eSgpKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhaSA9IGFwLkluc2VydChhaSwgYmIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9seWEuTGVuZ3RoKys7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcmViID0gYWk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZnN0ID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAvL2lnbm9yZSBzaGFyZWQgdmVydGV4IGlmIHBhcmFsbGVsXHJcbiAgICAgICAgICAgICAgICAgICAgYWkgPSBhaS5OZXh0KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgVmVjdG9yMiBhMSA9IGFpLkVsZW0oKTtcclxuICAgICAgICAgICAgICAgICAgICBhaSA9IGFpLk5leHQoKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoYWkgPT0gYXAuRW5kKCkpIGFpID0gYXAuQmVnaW4oKTtcclxuICAgICAgICAgICAgICAgICAgICBWZWN0b3IyIGEyID0gYWkuRWxlbSgpO1xyXG4gICAgICAgICAgICAgICAgICAgIFZlY3RvcjIgYTAwID0gcHJlYi5FbGVtKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgVmVjdG9yMiB1dSA9IGExIC0gYTAwO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vdmVjX25ldyh1KTsgdmVjX3N1YihhMS5wLCBhMC5wLCB1KTtcclxuICAgICAgICAgICAgICAgICAgICBWZWN0b3IyIHZ2ID0gYTIgLSBhMTtcclxuICAgICAgICAgICAgICAgICAgICAvL3ZlY19uZXcodik7IHZlY19zdWIoYTIucCwgYTEucCwgdik7XHJcbiAgICAgICAgICAgICAgICAgICAgZmxvYXQgZG90MSA9IFZlY0Nyb3NzKHV1LCB2dik7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRvdDEgKiBkb3QxIDwgU2V0dGluZ3MuRXBzaWxvbilcclxuICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGFwLkVyYXNlKHByZWIsIHByZWIuTmV4dCgpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcG9seWEuTGVuZ3RoLS07XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBwcmVhID0gYWk7XHJcbiAgICAgICAgICAgICAgICBhaSA9IGFpLk5leHQoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgI2VuZHJlZ2lvblxyXG5cclxuICAgICAgICAjcmVnaW9uIEN4RmFzdExpc3QgZnJvbSBuYXBlIHBoeXNpY3NcclxuXHJcbiAgICAgICAgI3JlZ2lvbiBOZXN0ZWQgdHlwZTogQ3hGYXN0TGlzdFxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIERlc2lnbmVkIGFzIGEgY29tcGxldGUgcG9ydCBvZiBDeEZhc3RMaXN0IGZyb20gQ3hTdGQuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICBpbnRlcm5hbCBjbGFzcyBDeEZhc3RMaXN0PFQ+XHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICAvLyBmaXJzdCBub2RlIGluIHRoZSBsaXN0XHJcbiAgICAgICAgICAgIHByaXZhdGUgQ3hGYXN0TGlzdE5vZGU8VD4gX2hlYWQ7XHJcbiAgICAgICAgICAgIHByaXZhdGUgaW50IF9jb3VudDtcclxuXHJcbiAgICAgICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAgICAgLy8vIEl0ZXJhdG9yIHRvIHN0YXJ0IG9mIGxpc3QgKE8oMSkpXHJcbiAgICAgICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgICAgIHB1YmxpYyBDeEZhc3RMaXN0Tm9kZTxUPiBCZWdpbigpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBfaGVhZDtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgICAgICAvLy8gSXRlcmF0b3IgdG8gZW5kIG9mIGxpc3QgKE8oMSkpXHJcbiAgICAgICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgICAgIHB1YmxpYyBDeEZhc3RMaXN0Tm9kZTxUPiBFbmQoKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgICAgICAvLy8gUmV0dXJucyBmaXJzdCBlbGVtZW50IG9mIGxpc3QgKE8oMSkpXHJcbiAgICAgICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgICAgIHB1YmxpYyBUIEZyb250KClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIF9oZWFkLkVsZW0oKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgICAgICAvLy8gYWRkIG9iamVjdCB0byBsaXN0IChPKDEpKVxyXG4gICAgICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgICAgICBwdWJsaWMgQ3hGYXN0TGlzdE5vZGU8VD4gQWRkKFQgdmFsdWUpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIEN4RmFzdExpc3ROb2RlPFQ+IG5ld05vZGUgPSBuZXcgQ3hGYXN0TGlzdE5vZGU8VD4odmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgaWYgKF9oZWFkID09IG51bGwpXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgbmV3Tm9kZS5fbmV4dCA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICAgICAgX2hlYWQgPSBuZXdOb2RlO1xyXG4gICAgICAgICAgICAgICAgICAgIF9jb3VudCsrO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXdOb2RlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgbmV3Tm9kZS5fbmV4dCA9IF9oZWFkO1xyXG4gICAgICAgICAgICAgICAgX2hlYWQgPSBuZXdOb2RlO1xyXG5cclxuICAgICAgICAgICAgICAgIF9jb3VudCsrO1xyXG5cclxuICAgICAgICAgICAgICAgIHJldHVybiBuZXdOb2RlO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgICAgIC8vLyByZW1vdmUgb2JqZWN0IGZyb20gbGlzdCwgcmV0dXJucyB0cnVlIGlmIGFuIGVsZW1lbnQgd2FzIHJlbW92ZWQgKE8obikpXHJcbiAgICAgICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgICAgIHB1YmxpYyBib29sIFJlbW92ZShUIHZhbHVlKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBDeEZhc3RMaXN0Tm9kZTxUPiBoZWFkID0gX2hlYWQ7XHJcbiAgICAgICAgICAgICAgICBDeEZhc3RMaXN0Tm9kZTxUPiBwcmV2ID0gX2hlYWQ7XHJcblxyXG4gICAgICAgICAgICAgICAgRXF1YWxpdHlDb21wYXJlcjxUPiBjb21wYXJlciA9IEVxdWFsaXR5Q29tcGFyZXI8VD4uRGVmYXVsdDtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoaGVhZCAhPSBudWxsKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZSAhPSBudWxsKVxyXG4gICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZG9cclxuICAgICAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gaWYgd2UgYXJlIG9uIHRoZSB2YWx1ZSB0byBiZSByZW1vdmVkXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29tcGFyZXIuRXF1YWxzKGhlYWQuX2VsdCwgdmFsdWUpKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRoZW4gd2UgbmVlZCB0byBwYXRjaCB0aGUgbGlzdFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNoZWNrIHRvIHNlZSBpZiB3ZSBhcmUgcmVtb3ZpbmcgdGhlIF9oZWFkXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGhlYWQgPT0gX2hlYWQpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfaGVhZCA9IGhlYWQuX25leHQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9jb3VudC0tO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gd2VyZSBub3QgYXQgdGhlIGhlYWRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJldi5fbmV4dCA9IGhlYWQuX25leHQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9jb3VudC0tO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBjYWNoZSB0aGUgY3VycmVudCBhcyB0aGUgcHJldmlvdXMgZm9yIHRoZSBuZXh0IGdvIGFyb3VuZFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJldiA9IGhlYWQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBoZWFkID0gaGVhZC5fbmV4dDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSB3aGlsZSAoaGVhZCAhPSBudWxsKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAgICAgLy8vIHBvcCBlbGVtZW50IGZyb20gaGVhZCBvZiBsaXN0IChPKDEpKSBOb3RlOiB0aGlzIGRvZXMgbm90IHJldHVybiB0aGUgb2JqZWN0IHBvcHBlZCEgXHJcbiAgICAgICAgICAgIC8vLyBUaGVyZSBpcyBnb29kIHJlYXNvbiB0byB0aGlzLCBhbmQgaXQgcmVnYXJkcyB0aGUgQWxsb2MgbGlzdCB2YXJpYW50cyB3aGljaCBndWFyYW50ZWUgXHJcbiAgICAgICAgICAgIC8vLyBvYmplY3RzIGFyZSByZWxlYXNlZCB0byB0aGUgb2JqZWN0IHBvb2wuIFlvdSBkbyBub3Qgd2FudCB0byByZXRyaWV2ZSBhbiBlbGVtZW50IFxyXG4gICAgICAgICAgICAvLy8gdGhyb3VnaCBwb3Agb3IgZWxzZSB0aGF0IG9iamVjdCBtYXkgc3VkZGVubHkgYmUgdXNlZCBieSBhbm90aGVyIHBpZWNlIG9mIGNvZGUgd2hpY2ggXHJcbiAgICAgICAgICAgIC8vLyByZXRyaWV2ZXMgaXQgZnJvbSB0aGUgb2JqZWN0IHBvb2wuXHJcbiAgICAgICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgICAgIHB1YmxpYyBDeEZhc3RMaXN0Tm9kZTxUPiBQb3AoKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gRXJhc2UobnVsbCwgX2hlYWQpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgICAgIC8vLyBpbnNlcnQgb2JqZWN0IGFmdGVyICdub2RlJyByZXR1cm5pbmcgYW4gaXRlcmF0b3IgdG8gdGhlIGluc2VydGVkIG9iamVjdC5cclxuICAgICAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAgICAgcHVibGljIEN4RmFzdExpc3ROb2RlPFQ+IEluc2VydChDeEZhc3RMaXN0Tm9kZTxUPiBub2RlLCBUIHZhbHVlKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBpZiAobm9kZSA9PSBudWxsKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBBZGQodmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgQ3hGYXN0TGlzdE5vZGU8VD4gbmV3Tm9kZSA9IG5ldyBDeEZhc3RMaXN0Tm9kZTxUPih2YWx1ZSk7XHJcbiAgICAgICAgICAgICAgICBDeEZhc3RMaXN0Tm9kZTxUPiBuZXh0Tm9kZSA9IG5vZGUuX25leHQ7XHJcbiAgICAgICAgICAgICAgICBuZXdOb2RlLl9uZXh0ID0gbmV4dE5vZGU7XHJcbiAgICAgICAgICAgICAgICBub2RlLl9uZXh0ID0gbmV3Tm9kZTtcclxuXHJcbiAgICAgICAgICAgICAgICBfY291bnQrKztcclxuXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3Tm9kZTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgICAgICAvLy8gcmVtb3ZlcyB0aGUgZWxlbWVudCBwb2ludGVkIHRvIGJ5ICdub2RlJyB3aXRoICdwcmV2JyBiZWluZyB0aGUgcHJldmlvdXMgaXRlcmF0b3IsIFxyXG4gICAgICAgICAgICAvLy8gcmV0dXJuaW5nIGFuIGl0ZXJhdG9yIHRvIHRoZSBlbGVtZW50IGZvbGxvd2luZyB0aGF0IG9mICdub2RlJyAoTygxKSlcclxuICAgICAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAgICAgcHVibGljIEN4RmFzdExpc3ROb2RlPFQ+IEVyYXNlKEN4RmFzdExpc3ROb2RlPFQ+IHByZXYsIEN4RmFzdExpc3ROb2RlPFQ+IG5vZGUpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIC8vIGNhY2hlIHRoZSBub2RlIGFmdGVyIHRoZSBub2RlIHRvIGJlIHJlbW92ZWRcclxuICAgICAgICAgICAgICAgIEN4RmFzdExpc3ROb2RlPFQ+IG5leHROb2RlID0gbm9kZS5fbmV4dDtcclxuICAgICAgICAgICAgICAgIGlmIChwcmV2ICE9IG51bGwpXHJcbiAgICAgICAgICAgICAgICAgICAgcHJldi5fbmV4dCA9IG5leHROb2RlO1xyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoX2hlYWQgIT0gbnVsbClcclxuICAgICAgICAgICAgICAgICAgICBfaGVhZCA9IF9oZWFkLl9uZXh0O1xyXG4gICAgICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG5cclxuICAgICAgICAgICAgICAgIF9jb3VudC0tO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5leHROb2RlO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgICAgIC8vLyB3aGV0aGVyIHRoZSBsaXN0IGlzIGVtcHR5IChPKDEpKVxyXG4gICAgICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgICAgICBwdWJsaWMgYm9vbCBFbXB0eSgpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGlmIChfaGVhZCA9PSBudWxsKVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgICAgIC8vLyBjb21wdXRlcyBzaXplIG9mIGxpc3QgKE8obikpXHJcbiAgICAgICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgICAgIHB1YmxpYyBpbnQgU2l6ZSgpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIEN4RmFzdExpc3ROb2RlPFQ+IGkgPSBCZWdpbigpO1xyXG4gICAgICAgICAgICAgICAgaW50IGNvdW50ID0gMDtcclxuXHJcbiAgICAgICAgICAgICAgICBkb1xyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvdW50Kys7XHJcbiAgICAgICAgICAgICAgICB9IHdoaWxlIChpLk5leHQoKSAhPSBudWxsKTtcclxuXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gY291bnQ7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAgICAgLy8vIGVtcHR5IHRoZSBsaXN0IChPKDEpIGlmIEN4TWl4TGlzdCwgTyhuKSBvdGhlcndpc2UpXHJcbiAgICAgICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgICAgIHB1YmxpYyB2b2lkIENsZWFyKClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgQ3hGYXN0TGlzdE5vZGU8VD4gaGVhZCA9IF9oZWFkO1xyXG4gICAgICAgICAgICAgICAgd2hpbGUgKGhlYWQgIT0gbnVsbClcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBDeEZhc3RMaXN0Tm9kZTxUPiBub2RlMiA9IGhlYWQ7XHJcbiAgICAgICAgICAgICAgICAgICAgaGVhZCA9IGhlYWQuX25leHQ7XHJcbiAgICAgICAgICAgICAgICAgICAgbm9kZTIuX25leHQgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgX2hlYWQgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgX2NvdW50ID0gMDtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgICAgICAvLy8gcmV0dXJucyB0cnVlIGlmICd2YWx1ZScgaXMgYW4gZWxlbWVudCBvZiB0aGUgbGlzdCAoTyhuKSlcclxuICAgICAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAgICAgcHVibGljIGJvb2wgSGFzKFQgdmFsdWUpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiAoRmluZCh2YWx1ZSkgIT0gbnVsbCk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIE5vbiBDeEZhc3RMaXN0IE1ldGhvZHMgXHJcbiAgICAgICAgICAgIHB1YmxpYyBDeEZhc3RMaXN0Tm9kZTxUPiBGaW5kKFQgdmFsdWUpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIC8vIHN0YXJ0IGF0IGhlYWRcclxuICAgICAgICAgICAgICAgIEN4RmFzdExpc3ROb2RlPFQ+IGhlYWQgPSBfaGVhZDtcclxuICAgICAgICAgICAgICAgIEVxdWFsaXR5Q29tcGFyZXI8VD4gY29tcGFyZXIgPSBFcXVhbGl0eUNvbXBhcmVyPFQ+LkRlZmF1bHQ7XHJcbiAgICAgICAgICAgICAgICBpZiAoaGVhZCAhPSBudWxsKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZSAhPSBudWxsKVxyXG4gICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZG9cclxuICAgICAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvbXBhcmVyLkVxdWFscyhoZWFkLl9lbHQsIHZhbHVlKSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gaGVhZDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhlYWQgPSBoZWFkLl9uZXh0O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9IHdoaWxlIChoZWFkICE9IF9oZWFkKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZG9cclxuICAgICAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGhlYWQuX2VsdCA9PSBudWxsKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBoZWFkO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaGVhZCA9IGhlYWQuX25leHQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gd2hpbGUgKGhlYWQgIT0gX2hlYWQpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBwdWJsaWMgTGlzdDxUPiBHZXRMaXN0T2ZFbGVtZW50cygpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIExpc3Q8VD4gbGlzdCA9IG5ldyBMaXN0PFQ+KCk7XHJcblxyXG4gICAgICAgICAgICAgICAgQ3hGYXN0TGlzdE5vZGU8VD4gaXRlciA9IEJlZ2luKCk7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKGl0ZXIgIT0gbnVsbClcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBkb1xyXG4gICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGlzdC5BZGQoaXRlci5fZWx0KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaXRlciA9IGl0ZXIuX25leHQ7XHJcbiAgICAgICAgICAgICAgICAgICAgfSB3aGlsZSAoaXRlciAhPSBudWxsKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiBsaXN0O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAjZW5kcmVnaW9uXHJcblxyXG4gICAgICAgICNyZWdpb24gTmVzdGVkIHR5cGU6IEN4RmFzdExpc3ROb2RlXHJcblxyXG4gICAgICAgIGludGVybmFsIGNsYXNzIEN4RmFzdExpc3ROb2RlPFQ+XHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBpbnRlcm5hbCBUIF9lbHQ7XHJcbiAgICAgICAgICAgIGludGVybmFsIEN4RmFzdExpc3ROb2RlPFQ+IF9uZXh0O1xyXG5cclxuICAgICAgICAgICAgcHVibGljIEN4RmFzdExpc3ROb2RlKFQgb2JqKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBfZWx0ID0gb2JqO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBwdWJsaWMgVCBFbGVtKClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIF9lbHQ7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHB1YmxpYyBDeEZhc3RMaXN0Tm9kZTxUPiBOZXh0KClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIF9uZXh0O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAjZW5kcmVnaW9uXHJcblxyXG4gICAgICAgICNlbmRyZWdpb25cclxuXHJcbiAgICAgICAgI3JlZ2lvbiBJbnRlcm5hbCBTdHVmZlxyXG5cclxuICAgICAgICAjcmVnaW9uIE5lc3RlZCB0eXBlOiBHZW9tUG9seVxyXG5cclxuICAgICAgICBpbnRlcm5hbCBjbGFzcyBHZW9tUG9seVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcHVibGljIGludCBMZW5ndGg7XHJcbiAgICAgICAgICAgIHB1YmxpYyBDeEZhc3RMaXN0PFZlY3RvcjI+IFBvaW50cztcclxuXHJcbiAgICAgICAgICAgIHB1YmxpYyBHZW9tUG9seSgpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIFBvaW50cyA9IG5ldyBDeEZhc3RMaXN0PFZlY3RvcjI+KCk7XHJcbiAgICAgICAgICAgICAgICBMZW5ndGggPSAwO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAjZW5kcmVnaW9uXHJcblxyXG4gICAgICAgICNyZWdpb24gTmVzdGVkIHR5cGU6IEdlb21Qb2x5VmFsXHJcblxyXG4gICAgICAgIHByaXZhdGUgY2xhc3MgR2VvbVBvbHlWYWxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIC8qKiBBc3NvY2lhdGVkIHBvbHlnb24gYXQgY29vcmRpbmF0ZSAqKi9cclxuICAgICAgICAgICAgLyoqIEtleSBvZiBvcmlnaW5hbCBzdWItcG9seWdvbiAqKi9cclxuICAgICAgICAgICAgcHVibGljIGludCBLZXk7XHJcbiAgICAgICAgICAgIHB1YmxpYyBHZW9tUG9seSBHZW9tUDtcclxuXHJcbiAgICAgICAgICAgIHB1YmxpYyBHZW9tUG9seVZhbChHZW9tUG9seSBnZW9tUCwgaW50IEspXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIEdlb21QID0gZ2VvbVA7XHJcbiAgICAgICAgICAgICAgICBLZXkgPSBLO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAjZW5kcmVnaW9uXHJcblxyXG4gICAgICAgICNlbmRyZWdpb25cclxuICAgIH1cclxufSIsIi8qXHJcbiogRmFyc2VlciBQaHlzaWNzIEVuZ2luZSBiYXNlZCBvbiBCb3gyRC5YTkEgcG9ydDpcclxuKiBDb3B5cmlnaHQgKGMpIDIwMTAgSWFuIFF2aXN0XHJcbiogXHJcbiogQm94MkQuWE5BIHBvcnQgb2YgQm94MkQ6XHJcbiogQ29weXJpZ2h0IChjKSAyMDA5IEJyYW5kb24gRnVydHdhbmdsZXIsIE5hdGhhbiBGdXJ0d2FuZ2xlclxyXG4qXHJcbiogT3JpZ2luYWwgc291cmNlIEJveDJEOlxyXG4qIENvcHlyaWdodCAoYykgMjAwNi0yMDA5IEVyaW4gQ2F0dG8gaHR0cDovL3d3dy5ncGh5c2ljcy5jb20gXHJcbiogXHJcbiogVGhpcyBzb2Z0d2FyZSBpcyBwcm92aWRlZCAnYXMtaXMnLCB3aXRob3V0IGFueSBleHByZXNzIG9yIGltcGxpZWQgXHJcbiogd2FycmFudHkuICBJbiBubyBldmVudCB3aWxsIHRoZSBhdXRob3JzIGJlIGhlbGQgbGlhYmxlIGZvciBhbnkgZGFtYWdlcyBcclxuKiBhcmlzaW5nIGZyb20gdGhlIHVzZSBvZiB0aGlzIHNvZnR3YXJlLiBcclxuKiBQZXJtaXNzaW9uIGlzIGdyYW50ZWQgdG8gYW55b25lIHRvIHVzZSB0aGlzIHNvZnR3YXJlIGZvciBhbnkgcHVycG9zZSwgXHJcbiogaW5jbHVkaW5nIGNvbW1lcmNpYWwgYXBwbGljYXRpb25zLCBhbmQgdG8gYWx0ZXIgaXQgYW5kIHJlZGlzdHJpYnV0ZSBpdCBcclxuKiBmcmVlbHksIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyByZXN0cmljdGlvbnM6IFxyXG4qIDEuIFRoZSBvcmlnaW4gb2YgdGhpcyBzb2Z0d2FyZSBtdXN0IG5vdCBiZSBtaXNyZXByZXNlbnRlZDsgeW91IG11c3Qgbm90IFxyXG4qIGNsYWltIHRoYXQgeW91IHdyb3RlIHRoZSBvcmlnaW5hbCBzb2Z0d2FyZS4gSWYgeW91IHVzZSB0aGlzIHNvZnR3YXJlIFxyXG4qIGluIGEgcHJvZHVjdCwgYW4gYWNrbm93bGVkZ21lbnQgaW4gdGhlIHByb2R1Y3QgZG9jdW1lbnRhdGlvbiB3b3VsZCBiZSBcclxuKiBhcHByZWNpYXRlZCBidXQgaXMgbm90IHJlcXVpcmVkLiBcclxuKiAyLiBBbHRlcmVkIHNvdXJjZSB2ZXJzaW9ucyBtdXN0IGJlIHBsYWlubHkgbWFya2VkIGFzIHN1Y2gsIGFuZCBtdXN0IG5vdCBiZSBcclxuKiBtaXNyZXByZXNlbnRlZCBhcyBiZWluZyB0aGUgb3JpZ2luYWwgc29mdHdhcmUuIFxyXG4qIDMuIFRoaXMgbm90aWNlIG1heSBub3QgYmUgcmVtb3ZlZCBvciBhbHRlcmVkIGZyb20gYW55IHNvdXJjZSBkaXN0cmlidXRpb24uIFxyXG4qL1xyXG5cclxudXNpbmcgU3lzdGVtO1xyXG51c2luZyBTeXN0ZW0uRGlhZ25vc3RpY3M7XHJcbnVzaW5nIFN5c3RlbS5SdW50aW1lLkludGVyb3BTZXJ2aWNlcztcclxudXNpbmcgTWljcm9zb2Z0LlhuYS5GcmFtZXdvcms7XHJcblxyXG5uYW1lc3BhY2UgRmFyc2VlclBoeXNpY3MuQ29tbW9uXHJcbntcclxuICAgIHB1YmxpYyBzdGF0aWMgY2xhc3MgTWF0aFV0aWxzXHJcbiAgICB7XHJcblx0XHRwdWJsaWMgc3RhdGljIGJvb2wgSXNDbG9zZShWZWN0b3IyIHYxLCBWZWN0b3IyIHYyLCBmbG9hdCB0b2xlcmVuY2UpXHJcblx0XHR7XHJcblx0XHRcdHJldHVybiAoVmVjdG9yMi5EaXN0YW5jZSh2MSwgdjIpIDwgdG9sZXJlbmNlKTtcclxuXHRcdH1cclxuXHRcdFxyXG4gICAgICAgIHB1YmxpYyBzdGF0aWMgYm9vbCBJc0VxdWFsKFZlY3RvcjIgdjEsIFZlY3RvcjIgdjIpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gKHYxLlggPT0gdjIuWCAmJiB2MS5ZID09IHYyLlkpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHVibGljIHN0YXRpYyBWZWN0b3IyIENsb25lVmVjdG9yKFZlY3RvcjIgdmVjdG9yKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBWZWN0b3IyKHZlY3Rvci5YLCB2ZWN0b3IuWSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwdWJsaWMgc3RhdGljIGZsb2F0IFZlY3RvckFuZ2xlKFZlY3RvcjIgdmVjdG9yKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIChmbG9hdClNYXRoLkF0YW4yKHZlY3Rvci5ZLCB2ZWN0b3IuWCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gSW5pdGlhbGl6ZSBhIFZlY3RvciB1c2luZyBwb2xhciBjb29yZGluYXRlXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJyYWRpdXNcIj48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cImFuZ2xlXCI+PC9wYXJhbT5cclxuICAgICAgICAvLy8gPHJldHVybnM+PC9yZXR1cm5zPlxyXG4gICAgICAgIHB1YmxpYyBzdGF0aWMgVmVjdG9yMiBWZWN0b3JQb2xhcihmbG9hdCByYWRpdXMsIGZsb2F0IGFuZ2xlKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBWZWN0b3IyKHJhZGl1cyAqIChmbG9hdClNYXRoLkNvcygoZG91YmxlKWFuZ2xlKSwgcmFkaXVzICogKGZsb2F0KU1hdGguU2luKChkb3VibGUpYW5nbGUpKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHB1YmxpYyBzdGF0aWMgZmxvYXQgQ3Jvc3MoVmVjdG9yMiBhLCBWZWN0b3IyIGIpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gYS5YICogYi5ZIC0gYS5ZICogYi5YO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHVibGljIHN0YXRpYyBWZWN0b3IyIENyb3NzKFZlY3RvcjIgYSwgZmxvYXQgcylcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgVmVjdG9yMihzICogYS5ZLCAtcyAqIGEuWCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwdWJsaWMgc3RhdGljIFZlY3RvcjIgQ3Jvc3MoZmxvYXQgcywgVmVjdG9yMiBhKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBWZWN0b3IyKC1zICogYS5ZLCBzICogYS5YKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHB1YmxpYyBzdGF0aWMgVmVjdG9yMiBBYnMoVmVjdG9yMiB2KVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBWZWN0b3IyKChmbG9hdClNYXRoLkFicyh2LlgpLCAoZmxvYXQpTWF0aC5BYnModi5ZKSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwdWJsaWMgc3RhdGljIFZlY3RvcjIgTXVsdGlwbHkocmVmIE1hdDIyIEEsIFZlY3RvcjIgdilcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiBNdWx0aXBseShyZWYgQSwgcmVmIHYpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHVibGljIHN0YXRpYyBWZWN0b3IyIE11bHRpcGx5KHJlZiBNYXQyMiBBLCByZWYgVmVjdG9yMiB2KVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBWZWN0b3IyKEEuQ29sMS5YICogdi5YICsgQS5Db2wyLlggKiB2LlksIEEuQ29sMS5ZICogdi5YICsgQS5Db2wyLlkgKiB2LlkpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHVibGljIHN0YXRpYyBWZWN0b3IyIE11bHRpcGx5VChyZWYgTWF0MjIgQSwgVmVjdG9yMiB2KVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIE11bHRpcGx5VChyZWYgQSwgcmVmIHYpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHVibGljIHN0YXRpYyBWZWN0b3IyIE11bHRpcGx5VChyZWYgTWF0MjIgQSwgcmVmIFZlY3RvcjIgdilcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgVmVjdG9yMih2LlggKiBBLkNvbDEuWCArIHYuWSAqIEEuQ29sMS5ZLCB2LlggKiBBLkNvbDIuWCArIHYuWSAqIEEuQ29sMi5ZKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHB1YmxpYyBzdGF0aWMgVmVjdG9yMiBNdWx0aXBseShyZWYgVHJhbnNmb3JtIFQsIFZlY3RvcjIgdilcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiBNdWx0aXBseShyZWYgVCwgcmVmIHYpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHVibGljIHN0YXRpYyBWZWN0b3IyIE11bHRpcGx5KHJlZiBUcmFuc2Zvcm0gVCwgcmVmIFZlY3RvcjIgdilcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgVmVjdG9yMihULlBvc2l0aW9uLlggKyBULlIuQ29sMS5YICogdi5YICsgVC5SLkNvbDIuWCAqIHYuWSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFQuUG9zaXRpb24uWSArIFQuUi5Db2wxLlkgKiB2LlggKyBULlIuQ29sMi5ZICogdi5ZKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHB1YmxpYyBzdGF0aWMgVmVjdG9yMiBNdWx0aXBseVQocmVmIFRyYW5zZm9ybSBULCBWZWN0b3IyIHYpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gTXVsdGlwbHlUKHJlZiBULCByZWYgdik7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwdWJsaWMgc3RhdGljIFZlY3RvcjIgTXVsdGlwbHlUKHJlZiBUcmFuc2Zvcm0gVCwgcmVmIFZlY3RvcjIgdilcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIFZlY3RvcjIgdG1wID0gVmVjdG9yMi5aZXJvO1xyXG4gICAgICAgICAgICB0bXAuWCA9IHYuWCAtIFQuUG9zaXRpb24uWDtcclxuICAgICAgICAgICAgdG1wLlkgPSB2LlkgLSBULlBvc2l0aW9uLlk7XHJcbiAgICAgICAgICAgIHJldHVybiBNdWx0aXBseVQocmVmIFQuUiwgcmVmIHRtcCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBBXlQgKiBCXHJcbiAgICAgICAgcHVibGljIHN0YXRpYyB2b2lkIE11bHRpcGx5VChyZWYgTWF0MjIgQSwgcmVmIE1hdDIyIEIsIG91dCBNYXQyMiBDKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgQyA9IG5ldyBNYXQyMigpO1xyXG4gICAgICAgICAgICBDLkNvbDEuWCA9IEEuQ29sMS5YICogQi5Db2wxLlggKyBBLkNvbDEuWSAqIEIuQ29sMS5ZO1xyXG4gICAgICAgICAgICBDLkNvbDEuWSA9IEEuQ29sMi5YICogQi5Db2wxLlggKyBBLkNvbDIuWSAqIEIuQ29sMS5ZO1xyXG4gICAgICAgICAgICBDLkNvbDIuWCA9IEEuQ29sMS5YICogQi5Db2wyLlggKyBBLkNvbDEuWSAqIEIuQ29sMi5ZO1xyXG4gICAgICAgICAgICBDLkNvbDIuWSA9IEEuQ29sMi5YICogQi5Db2wyLlggKyBBLkNvbDIuWSAqIEIuQ29sMi5ZO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gdjIgPSBBLlInICogKEIuUiAqIHYxICsgQi5wIC0gQS5wKSA9IChBLlInICogQi5SKSAqIHYxICsgKEIucCAtIEEucClcclxuICAgICAgICBwdWJsaWMgc3RhdGljIHZvaWQgTXVsdGlwbHlUKHJlZiBUcmFuc2Zvcm0gQSwgcmVmIFRyYW5zZm9ybSBCLCBvdXQgVHJhbnNmb3JtIEMpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBDID0gbmV3IFRyYW5zZm9ybSgpO1xyXG4gICAgICAgICAgICBNdWx0aXBseVQocmVmIEEuUiwgcmVmIEIuUiwgb3V0IEMuUik7XHJcbiAgICAgICAgICAgIEMuUG9zaXRpb24uWCA9IEIuUG9zaXRpb24uWCAtIEEuUG9zaXRpb24uWDtcclxuICAgICAgICAgICAgQy5Qb3NpdGlvbi5ZID0gQi5Qb3NpdGlvbi5ZIC0gQS5Qb3NpdGlvbi5ZO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHVibGljIHN0YXRpYyB2b2lkIFN3YXA8VD4ocmVmIFQgYSwgcmVmIFQgYilcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIFQgdG1wID0gYTtcclxuICAgICAgICAgICAgYSA9IGI7XHJcbiAgICAgICAgICAgIGIgPSB0bXA7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIFRoaXMgZnVuY3Rpb24gaXMgdXNlZCB0byBlbnN1cmUgdGhhdCBhIGZsb2F0aW5nIHBvaW50IG51bWJlciBpc1xyXG4gICAgICAgIC8vLyBub3QgYSBOYU4gb3IgaW5maW5pdHkuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJ4XCI+VGhlIHguPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHJldHVybnM+XHJcbiAgICAgICAgLy8vIFx0PGM+dHJ1ZTwvYz4gaWYgdGhlIHNwZWNpZmllZCB4IGlzIHZhbGlkOyBvdGhlcndpc2UsIDxjPmZhbHNlPC9jPi5cclxuICAgICAgICAvLy8gPC9yZXR1cm5zPlxyXG4gICAgICAgIHB1YmxpYyBzdGF0aWMgYm9vbCBJc1ZhbGlkKGZsb2F0IHgpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBpZiAoZmxvYXQuSXNOYU4oeCkpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIC8vIE5hTi5cclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuICFmbG9hdC5Jc0luZmluaXR5KHgpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHVibGljIHN0YXRpYyBib29sIElzVmFsaWQodGhpcyBWZWN0b3IyIHgpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gSXNWYWxpZCh4LlgpICYmIElzVmFsaWQoeC5ZKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gVGhpcyBpcyBhIGFwcHJveGltYXRlIHlldCBmYXN0IGludmVyc2Ugc3F1YXJlLXJvb3QuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJ4XCI+VGhlIHguPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHJldHVybnM+PC9yZXR1cm5zPlxyXG4gICAgICAgIHB1YmxpYyBzdGF0aWMgZmxvYXQgSW52U3FydChmbG9hdCB4KVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgRmxvYXRDb252ZXJ0ZXIgY29udmVydCA9IG5ldyBGbG9hdENvbnZlcnRlcigpO1xyXG4gICAgICAgICAgICBjb252ZXJ0LnggPSB4O1xyXG4gICAgICAgICAgICBmbG9hdCB4aGFsZiA9IDAuNWYgKiB4O1xyXG4gICAgICAgICAgICBjb252ZXJ0LmkgPSAweDVmMzc1OWRmIC0gKGNvbnZlcnQuaSA+PiAxKTtcclxuICAgICAgICAgICAgeCA9IGNvbnZlcnQueDtcclxuICAgICAgICAgICAgeCA9IHggKiAoMS41ZiAtIHhoYWxmICogeCAqIHgpO1xyXG4gICAgICAgICAgICByZXR1cm4geDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHB1YmxpYyBzdGF0aWMgaW50IENsYW1wKGludCBhLCBpbnQgbG93LCBpbnQgaGlnaClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiBNYXRoLk1heChsb3csIE1hdGguTWluKGEsIGhpZ2gpKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHB1YmxpYyBzdGF0aWMgZmxvYXQgQ2xhbXAoZmxvYXQgYSwgZmxvYXQgbG93LCBmbG9hdCBoaWdoKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIE1hdGguTWF4KGxvdywgTWF0aC5NaW4oYSwgaGlnaCkpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHVibGljIHN0YXRpYyBWZWN0b3IyIENsYW1wKFZlY3RvcjIgYSwgVmVjdG9yMiBsb3csIFZlY3RvcjIgaGlnaClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiBWZWN0b3IyLk1heChsb3csIFZlY3RvcjIuTWluKGEsIGhpZ2gpKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHB1YmxpYyBzdGF0aWMgdm9pZCBDcm9zcyhyZWYgVmVjdG9yMiBhLCByZWYgVmVjdG9yMiBiLCBvdXQgZmxvYXQgYylcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGMgPSBhLlggKiBiLlkgLSBhLlkgKiBiLlg7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIFJldHVybiB0aGUgYW5nbGUgYmV0d2VlbiB0d28gdmVjdG9ycyBvbiBhIHBsYW5lXHJcbiAgICAgICAgLy8vIFRoZSBhbmdsZSBpcyBmcm9tIHZlY3RvciAxIHRvIHZlY3RvciAyLCBwb3NpdGl2ZSBhbnRpY2xvY2t3aXNlXHJcbiAgICAgICAgLy8vIFRoZSByZXN1bHQgaXMgYmV0d2VlbiAtcGkgLT4gcGlcclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIHB1YmxpYyBzdGF0aWMgZG91YmxlIFZlY3RvckFuZ2xlKHJlZiBWZWN0b3IyIHAxLCByZWYgVmVjdG9yMiBwMilcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGRvdWJsZSB0aGV0YTEgPSBNYXRoLkF0YW4yKHAxLlksIHAxLlgpO1xyXG4gICAgICAgICAgICBkb3VibGUgdGhldGEyID0gTWF0aC5BdGFuMihwMi5ZLCBwMi5YKTtcclxuICAgICAgICAgICAgZG91YmxlIGR0aGV0YSA9IHRoZXRhMiAtIHRoZXRhMTtcclxuICAgICAgICAgICAgd2hpbGUgKGR0aGV0YSA+IE1hdGguUEkpXHJcbiAgICAgICAgICAgICAgICBkdGhldGEgLT0gKDIgKiBNYXRoLlBJKTtcclxuICAgICAgICAgICAgd2hpbGUgKGR0aGV0YSA8IC1NYXRoLlBJKVxyXG4gICAgICAgICAgICAgICAgZHRoZXRhICs9ICgyICogTWF0aC5QSSk7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gKGR0aGV0YSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwdWJsaWMgc3RhdGljIGRvdWJsZSBWZWN0b3JBbmdsZShWZWN0b3IyIHAxLCBWZWN0b3IyIHAyKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIFZlY3RvckFuZ2xlKHJlZiBwMSwgcmVmIHAyKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gUmV0dXJucyBhIHBvc2l0aXZlIG51bWJlciBpZiBjIGlzIHRvIHRoZSBsZWZ0IG9mIHRoZSBsaW5lIGdvaW5nIGZyb20gYSB0byBiLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDxyZXR1cm5zPlBvc2l0aXZlIG51bWJlciBpZiBwb2ludCBpcyBsZWZ0LCBuZWdhdGl2ZSBpZiBwb2ludCBpcyByaWdodCwgXHJcbiAgICAgICAgLy8vIGFuZCAwIGlmIHBvaW50cyBhcmUgY29sbGluZWFyLjwvcmV0dXJucz5cclxuICAgICAgICBwdWJsaWMgc3RhdGljIGZsb2F0IEFyZWEoVmVjdG9yMiBhLCBWZWN0b3IyIGIsIFZlY3RvcjIgYylcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiBBcmVhKHJlZiBhLCByZWYgYiwgcmVmIGMpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBSZXR1cm5zIGEgcG9zaXRpdmUgbnVtYmVyIGlmIGMgaXMgdG8gdGhlIGxlZnQgb2YgdGhlIGxpbmUgZ29pbmcgZnJvbSBhIHRvIGIuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHJldHVybnM+UG9zaXRpdmUgbnVtYmVyIGlmIHBvaW50IGlzIGxlZnQsIG5lZ2F0aXZlIGlmIHBvaW50IGlzIHJpZ2h0LCBcclxuICAgICAgICAvLy8gYW5kIDAgaWYgcG9pbnRzIGFyZSBjb2xsaW5lYXIuPC9yZXR1cm5zPlxyXG4gICAgICAgIHB1YmxpYyBzdGF0aWMgZmxvYXQgQXJlYShyZWYgVmVjdG9yMiBhLCByZWYgVmVjdG9yMiBiLCByZWYgVmVjdG9yMiBjKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIGEuWCAqIChiLlkgLSBjLlkpICsgYi5YICogKGMuWSAtIGEuWSkgKyBjLlggKiAoYS5ZIC0gYi5ZKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gRGV0ZXJtaW5lcyBpZiB0aHJlZSB2ZXJ0aWNlcyBhcmUgY29sbGluZWFyIChpZS4gb24gYSBzdHJhaWdodCBsaW5lKVxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwiYVwiPkZpcnN0IHZlcnRleDwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwiYlwiPlNlY29uZCB2ZXJ0ZXg8L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cImNcIj5UaGlyZCB2ZXJ0ZXg8L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cmV0dXJucz48L3JldHVybnM+XHJcbiAgICAgICAgcHVibGljIHN0YXRpYyBib29sIENvbGxpbmVhcihyZWYgVmVjdG9yMiBhLCByZWYgVmVjdG9yMiBiLCByZWYgVmVjdG9yMiBjKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIENvbGxpbmVhcihyZWYgYSwgcmVmIGIsIHJlZiBjLCAwKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHB1YmxpYyBzdGF0aWMgYm9vbCBDb2xsaW5lYXIocmVmIFZlY3RvcjIgYSwgcmVmIFZlY3RvcjIgYiwgcmVmIFZlY3RvcjIgYywgZmxvYXQgdG9sZXJhbmNlKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIEZsb2F0SW5SYW5nZShBcmVhKHJlZiBhLCByZWYgYiwgcmVmIGMpLCAtdG9sZXJhbmNlLCB0b2xlcmFuY2UpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHVibGljIHN0YXRpYyB2b2lkIENyb3NzKGZsb2F0IHMsIHJlZiBWZWN0b3IyIGEsIG91dCBWZWN0b3IyIGIpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBiID0gbmV3IFZlY3RvcjIoLXMgKiBhLlksIHMgKiBhLlgpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHVibGljIHN0YXRpYyBib29sIEZsb2F0RXF1YWxzKGZsb2F0IHZhbHVlMSwgZmxvYXQgdmFsdWUyKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIE1hdGguQWJzKHZhbHVlMSAtIHZhbHVlMikgPD0gU2V0dGluZ3MuRXBzaWxvbjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gQ2hlY2tzIGlmIGEgZmxvYXRpbmcgcG9pbnQgVmFsdWUgaXMgZXF1YWwgdG8gYW5vdGhlcixcclxuICAgICAgICAvLy8gd2l0aGluIGEgY2VydGFpbiB0b2xlcmFuY2UuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJ2YWx1ZTFcIj5UaGUgZmlyc3QgZmxvYXRpbmcgcG9pbnQgVmFsdWUuPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJ2YWx1ZTJcIj5UaGUgc2Vjb25kIGZsb2F0aW5nIHBvaW50IFZhbHVlLjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwiZGVsdGFcIj5UaGUgZmxvYXRpbmcgcG9pbnQgdG9sZXJhbmNlLjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxyZXR1cm5zPlRydWUgaWYgdGhlIHZhbHVlcyBhcmUgXCJlcXVhbFwiLCBmYWxzZSBvdGhlcndpc2UuPC9yZXR1cm5zPlxyXG4gICAgICAgIHB1YmxpYyBzdGF0aWMgYm9vbCBGbG9hdEVxdWFscyhmbG9hdCB2YWx1ZTEsIGZsb2F0IHZhbHVlMiwgZmxvYXQgZGVsdGEpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gRmxvYXRJblJhbmdlKHZhbHVlMSwgdmFsdWUyIC0gZGVsdGEsIHZhbHVlMiArIGRlbHRhKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gQ2hlY2tzIGlmIGEgZmxvYXRpbmcgcG9pbnQgVmFsdWUgaXMgd2l0aGluIGEgc3BlY2lmaWVkXHJcbiAgICAgICAgLy8vIHJhbmdlIG9mIHZhbHVlcyAoaW5jbHVzaXZlKS5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cInZhbHVlXCI+VGhlIFZhbHVlIHRvIGNoZWNrLjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwibWluXCI+VGhlIG1pbmltdW0gVmFsdWUuPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJtYXhcIj5UaGUgbWF4aW11bSBWYWx1ZS48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cmV0dXJucz5UcnVlIGlmIHRoZSBWYWx1ZSBpcyB3aXRoaW4gdGhlIHJhbmdlIHNwZWNpZmllZCxcclxuICAgICAgICAvLy8gZmFsc2Ugb3RoZXJ3aXNlLjwvcmV0dXJucz5cclxuICAgICAgICBwdWJsaWMgc3RhdGljIGJvb2wgRmxvYXRJblJhbmdlKGZsb2F0IHZhbHVlLCBmbG9hdCBtaW4sIGZsb2F0IG1heClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiAodmFsdWUgPj0gbWluICYmIHZhbHVlIDw9IG1heCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAjcmVnaW9uIE5lc3RlZCB0eXBlOiBGbG9hdENvbnZlcnRlclxyXG5cclxuICAgICAgICBbU3RydWN0TGF5b3V0KExheW91dEtpbmQuRXhwbGljaXQpXVxyXG4gICAgICAgIHByaXZhdGUgc3RydWN0IEZsb2F0Q29udmVydGVyXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBbRmllbGRPZmZzZXQoMCldXHJcbiAgICAgICAgICAgIHB1YmxpYyBmbG9hdCB4O1xyXG4gICAgICAgICAgICBbRmllbGRPZmZzZXQoMCldXHJcbiAgICAgICAgICAgIHB1YmxpYyBpbnQgaTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgICNlbmRyZWdpb25cclxuICAgIH1cclxuXHJcbiAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAvLy8gQSAyLWJ5LTIgbWF0cml4LiBTdG9yZWQgaW4gY29sdW1uLW1ham9yIG9yZGVyLlxyXG4gICAgLy8vIDwvc3VtbWFyeT5cclxuICAgIHB1YmxpYyBzdHJ1Y3QgTWF0MjJcclxuICAgIHtcclxuICAgICAgICBwdWJsaWMgVmVjdG9yMiBDb2wxLCBDb2wyO1xyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIENvbnN0cnVjdCB0aGlzIG1hdHJpeCB1c2luZyBjb2x1bW5zLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwiYzFcIj5UaGUgYzEuPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJjMlwiPlRoZSBjMi48L3BhcmFtPlxyXG4gICAgICAgIHB1YmxpYyBNYXQyMihWZWN0b3IyIGMxLCBWZWN0b3IyIGMyKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgQ29sMSA9IGMxO1xyXG4gICAgICAgICAgICBDb2wyID0gYzI7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIENvbnN0cnVjdCB0aGlzIG1hdHJpeCB1c2luZyBzY2FsYXJzLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwiYTExXCI+VGhlIGExMS48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cImExMlwiPlRoZSBhMTIuPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJhMjFcIj5UaGUgYTIxLjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwiYTIyXCI+VGhlIGEyMi48L3BhcmFtPlxyXG4gICAgICAgIHB1YmxpYyBNYXQyMihmbG9hdCBhMTEsIGZsb2F0IGExMiwgZmxvYXQgYTIxLCBmbG9hdCBhMjIpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBDb2wxID0gbmV3IFZlY3RvcjIoYTExLCBhMjEpO1xyXG4gICAgICAgICAgICBDb2wyID0gbmV3IFZlY3RvcjIoYTEyLCBhMjIpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBDb25zdHJ1Y3QgdGhpcyBtYXRyaXggdXNpbmcgYW4gYW5nbGUuIFRoaXMgbWF0cml4IGJlY29tZXNcclxuICAgICAgICAvLy8gYW4gb3J0aG9ub3JtYWwgcm90YXRpb24gbWF0cml4LlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwiYW5nbGVcIj5UaGUgYW5nbGUuPC9wYXJhbT5cclxuICAgICAgICBwdWJsaWMgTWF0MjIoZmxvYXQgYW5nbGUpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICAvLyBUT0RPX0VSSU4gY29tcHV0ZSBzaW4rY29zIHRvZ2V0aGVyLlxyXG4gICAgICAgICAgICBmbG9hdCBjID0gKGZsb2F0KU1hdGguQ29zKGFuZ2xlKSwgcyA9IChmbG9hdClNYXRoLlNpbihhbmdsZSk7XHJcbiAgICAgICAgICAgIENvbDEgPSBuZXcgVmVjdG9yMihjLCBzKTtcclxuICAgICAgICAgICAgQ29sMiA9IG5ldyBWZWN0b3IyKC1zLCBjKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gRXh0cmFjdCB0aGUgYW5nbGUgZnJvbSB0aGlzIG1hdHJpeCAoYXNzdW1lZCB0byBiZVxyXG4gICAgICAgIC8vLyBhIHJvdGF0aW9uIG1hdHJpeCkuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHZhbHVlPjwvdmFsdWU+XHJcbiAgICAgICAgcHVibGljIGZsb2F0IEFuZ2xlXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBnZXQgeyByZXR1cm4gKGZsb2F0KU1hdGguQXRhbjIoQ29sMS5ZLCBDb2wxLlgpOyB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwdWJsaWMgTWF0MjIgSW52ZXJzZVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgZ2V0XHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGZsb2F0IGEgPSBDb2wxLlgsIGIgPSBDb2wyLlgsIGMgPSBDb2wxLlksIGQgPSBDb2wyLlk7XHJcbiAgICAgICAgICAgICAgICBmbG9hdCBkZXQgPSBhICogZCAtIGIgKiBjO1xyXG4gICAgICAgICAgICAgICAgaWYgKGRldCAhPSAwLjBmKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIGRldCA9IDEuMGYgLyBkZXQ7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgTWF0MjIgcmVzdWx0ID0gbmV3IE1hdDIyKCk7XHJcbiAgICAgICAgICAgICAgICByZXN1bHQuQ29sMS5YID0gZGV0ICogZDtcclxuICAgICAgICAgICAgICAgIHJlc3VsdC5Db2wxLlkgPSAtZGV0ICogYztcclxuXHJcbiAgICAgICAgICAgICAgICByZXN1bHQuQ29sMi5YID0gLWRldCAqIGI7XHJcbiAgICAgICAgICAgICAgICByZXN1bHQuQ29sMi5ZID0gZGV0ICogYTtcclxuXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIEluaXRpYWxpemUgdGhpcyBtYXRyaXggdXNpbmcgY29sdW1ucy5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cImMxXCI+VGhlIGMxLjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwiYzJcIj5UaGUgYzIuPC9wYXJhbT5cclxuICAgICAgICBwdWJsaWMgdm9pZCBTZXQoVmVjdG9yMiBjMSwgVmVjdG9yMiBjMilcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIENvbDEgPSBjMTtcclxuICAgICAgICAgICAgQ29sMiA9IGMyO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBJbml0aWFsaXplIHRoaXMgbWF0cml4IHVzaW5nIGFuIGFuZ2xlLiBUaGlzIG1hdHJpeCBiZWNvbWVzXHJcbiAgICAgICAgLy8vIGFuIG9ydGhvbm9ybWFsIHJvdGF0aW9uIG1hdHJpeC5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cImFuZ2xlXCI+VGhlIGFuZ2xlLjwvcGFyYW0+XHJcbiAgICAgICAgcHVibGljIHZvaWQgU2V0KGZsb2F0IGFuZ2xlKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgZmxvYXQgYyA9IChmbG9hdClNYXRoLkNvcyhhbmdsZSksIHMgPSAoZmxvYXQpTWF0aC5TaW4oYW5nbGUpO1xyXG4gICAgICAgICAgICBDb2wxLlggPSBjO1xyXG4gICAgICAgICAgICBDb2wyLlggPSAtcztcclxuICAgICAgICAgICAgQ29sMS5ZID0gcztcclxuICAgICAgICAgICAgQ29sMi5ZID0gYztcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gU2V0IHRoaXMgdG8gdGhlIGlkZW50aXR5IG1hdHJpeC5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIHB1YmxpYyB2b2lkIFNldElkZW50aXR5KClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIENvbDEuWCA9IDEuMGY7XHJcbiAgICAgICAgICAgIENvbDIuWCA9IDAuMGY7XHJcbiAgICAgICAgICAgIENvbDEuWSA9IDAuMGY7XHJcbiAgICAgICAgICAgIENvbDIuWSA9IDEuMGY7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIFNldCB0aGlzIG1hdHJpeCB0byBhbGwgemVyb3MuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICBwdWJsaWMgdm9pZCBTZXRaZXJvKClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIENvbDEuWCA9IDAuMGY7XHJcbiAgICAgICAgICAgIENvbDIuWCA9IDAuMGY7XHJcbiAgICAgICAgICAgIENvbDEuWSA9IDAuMGY7XHJcbiAgICAgICAgICAgIENvbDIuWSA9IDAuMGY7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIFNvbHZlIEEgKiB4ID0gYiwgd2hlcmUgYiBpcyBhIGNvbHVtbiB2ZWN0b3IuIFRoaXMgaXMgbW9yZSBlZmZpY2llbnRcclxuICAgICAgICAvLy8gdGhhbiBjb21wdXRpbmcgdGhlIGludmVyc2UgaW4gb25lLXNob3QgY2FzZXMuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJiXCI+VGhlIGIuPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHJldHVybnM+PC9yZXR1cm5zPlxyXG4gICAgICAgIHB1YmxpYyBWZWN0b3IyIFNvbHZlKFZlY3RvcjIgYilcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGZsb2F0IGExMSA9IENvbDEuWCwgYTEyID0gQ29sMi5YLCBhMjEgPSBDb2wxLlksIGEyMiA9IENvbDIuWTtcclxuICAgICAgICAgICAgZmxvYXQgZGV0ID0gYTExICogYTIyIC0gYTEyICogYTIxO1xyXG4gICAgICAgICAgICBpZiAoZGV0ICE9IDAuMGYpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGRldCA9IDEuMGYgLyBkZXQ7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgVmVjdG9yMihkZXQgKiAoYTIyICogYi5YIC0gYTEyICogYi5ZKSwgZGV0ICogKGExMSAqIGIuWSAtIGEyMSAqIGIuWCkpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHVibGljIHN0YXRpYyB2b2lkIEFkZChyZWYgTWF0MjIgQSwgcmVmIE1hdDIyIEIsIG91dCBNYXQyMiBSKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgUi5Db2wxID0gQS5Db2wxICsgQi5Db2wxO1xyXG4gICAgICAgICAgICBSLkNvbDIgPSBBLkNvbDIgKyBCLkNvbDI7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8vLyA8c3VtbWFyeT5cclxuICAgIC8vLyBBIDMtYnktMyBtYXRyaXguIFN0b3JlZCBpbiBjb2x1bW4tbWFqb3Igb3JkZXIuXHJcbiAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgcHVibGljIHN0cnVjdCBNYXQzM1xyXG4gICAge1xyXG4gICAgICAgIHB1YmxpYyBWZWN0b3IzIENvbDEsIENvbDIsIENvbDM7XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gQ29uc3RydWN0IHRoaXMgbWF0cml4IHVzaW5nIGNvbHVtbnMuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJjMVwiPlRoZSBjMS48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cImMyXCI+VGhlIGMyLjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwiYzNcIj5UaGUgYzMuPC9wYXJhbT5cclxuICAgICAgICBwdWJsaWMgTWF0MzMoVmVjdG9yMyBjMSwgVmVjdG9yMyBjMiwgVmVjdG9yMyBjMylcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIENvbDEgPSBjMTtcclxuICAgICAgICAgICAgQ29sMiA9IGMyO1xyXG4gICAgICAgICAgICBDb2wzID0gYzM7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIFNldCB0aGlzIG1hdHJpeCB0byBhbGwgemVyb3MuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICBwdWJsaWMgdm9pZCBTZXRaZXJvKClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIENvbDEgPSBWZWN0b3IzLlplcm87XHJcbiAgICAgICAgICAgIENvbDIgPSBWZWN0b3IzLlplcm87XHJcbiAgICAgICAgICAgIENvbDMgPSBWZWN0b3IzLlplcm87XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIFNvbHZlIEEgKiB4ID0gYiwgd2hlcmUgYiBpcyBhIGNvbHVtbiB2ZWN0b3IuIFRoaXMgaXMgbW9yZSBlZmZpY2llbnRcclxuICAgICAgICAvLy8gdGhhbiBjb21wdXRpbmcgdGhlIGludmVyc2UgaW4gb25lLXNob3QgY2FzZXMuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJiXCI+VGhlIGIuPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHJldHVybnM+PC9yZXR1cm5zPlxyXG4gICAgICAgIHB1YmxpYyBWZWN0b3IzIFNvbHZlMzMoVmVjdG9yMyBiKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgZmxvYXQgZGV0ID0gVmVjdG9yMy5Eb3QoQ29sMSwgVmVjdG9yMy5Dcm9zcyhDb2wyLCBDb2wzKSk7XHJcbiAgICAgICAgICAgIGlmIChkZXQgIT0gMC4wZilcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgZGV0ID0gMS4wZiAvIGRldDtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBWZWN0b3IzKGRldCAqIFZlY3RvcjMuRG90KGIsIFZlY3RvcjMuQ3Jvc3MoQ29sMiwgQ29sMykpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGV0ICogVmVjdG9yMy5Eb3QoQ29sMSwgVmVjdG9yMy5Dcm9zcyhiLCBDb2wzKSksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZXQgKiBWZWN0b3IzLkRvdChDb2wxLCBWZWN0b3IzLkNyb3NzKENvbDIsIGIpKSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIFNvbHZlIEEgKiB4ID0gYiwgd2hlcmUgYiBpcyBhIGNvbHVtbiB2ZWN0b3IuIFRoaXMgaXMgbW9yZSBlZmZpY2llbnRcclxuICAgICAgICAvLy8gdGhhbiBjb21wdXRpbmcgdGhlIGludmVyc2UgaW4gb25lLXNob3QgY2FzZXMuIFNvbHZlIG9ubHkgdGhlIHVwcGVyXHJcbiAgICAgICAgLy8vIDItYnktMiBtYXRyaXggZXF1YXRpb24uXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJiXCI+VGhlIGIuPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHJldHVybnM+PC9yZXR1cm5zPlxyXG4gICAgICAgIHB1YmxpYyBWZWN0b3IyIFNvbHZlMjIoVmVjdG9yMiBiKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgZmxvYXQgYTExID0gQ29sMS5YLCBhMTIgPSBDb2wyLlgsIGEyMSA9IENvbDEuWSwgYTIyID0gQ29sMi5ZO1xyXG4gICAgICAgICAgICBmbG9hdCBkZXQgPSBhMTEgKiBhMjIgLSBhMTIgKiBhMjE7XHJcblxyXG4gICAgICAgICAgICBpZiAoZGV0ICE9IDAuMGYpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGRldCA9IDEuMGYgLyBkZXQ7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgVmVjdG9yMihkZXQgKiAoYTIyICogYi5YIC0gYTEyICogYi5ZKSwgZGV0ICogKGExMSAqIGIuWSAtIGEyMSAqIGIuWCkpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAvLy8gQSB0cmFuc2Zvcm0gY29udGFpbnMgdHJhbnNsYXRpb24gYW5kIHJvdGF0aW9uLiBJdCBpcyB1c2VkIHRvIHJlcHJlc2VudFxyXG4gICAgLy8vIHRoZSBwb3NpdGlvbiBhbmQgb3JpZW50YXRpb24gb2YgcmlnaWQgZnJhbWVzLlxyXG4gICAgLy8vIDwvc3VtbWFyeT5cclxuICAgIHB1YmxpYyBzdHJ1Y3QgVHJhbnNmb3JtXHJcbiAgICB7XHJcbiAgICAgICAgcHVibGljIFZlY3RvcjIgUG9zaXRpb247XHJcbiAgICAgICAgcHVibGljIE1hdDIyIFI7XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gSW5pdGlhbGl6ZSB1c2luZyBhIHBvc2l0aW9uIHZlY3RvciBhbmQgYSByb3RhdGlvbiBtYXRyaXguXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJwb3NpdGlvblwiPlRoZSBwb3NpdGlvbi48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cInJcIj5UaGUgci48L3BhcmFtPlxyXG4gICAgICAgIHB1YmxpYyBUcmFuc2Zvcm0ocmVmIFZlY3RvcjIgcG9zaXRpb24sIHJlZiBNYXQyMiByKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgUG9zaXRpb24gPSBwb3NpdGlvbjtcclxuICAgICAgICAgICAgUiA9IHI7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIENhbGN1bGF0ZSB0aGUgYW5nbGUgdGhhdCB0aGUgcm90YXRpb24gbWF0cml4IHJlcHJlc2VudHMuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHZhbHVlPjwvdmFsdWU+XHJcbiAgICAgICAgcHVibGljIGZsb2F0IEFuZ2xlXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBnZXQgeyByZXR1cm4gKGZsb2F0KU1hdGguQXRhbjIoUi5Db2wxLlksIFIuQ29sMS5YKTsgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBTZXQgdGhpcyB0byB0aGUgaWRlbnRpdHkgdHJhbnNmb3JtLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgcHVibGljIHZvaWQgU2V0SWRlbnRpdHkoKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgUG9zaXRpb24gPSBWZWN0b3IyLlplcm87XHJcbiAgICAgICAgICAgIFIuU2V0SWRlbnRpdHkoKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gU2V0IHRoaXMgYmFzZWQgb24gdGhlIHBvc2l0aW9uIGFuZCBhbmdsZS5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cInBvc2l0aW9uXCI+VGhlIHBvc2l0aW9uLjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwiYW5nbGVcIj5UaGUgYW5nbGUuPC9wYXJhbT5cclxuICAgICAgICBwdWJsaWMgdm9pZCBTZXQoVmVjdG9yMiBwb3NpdGlvbiwgZmxvYXQgYW5nbGUpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBQb3NpdGlvbiA9IHBvc2l0aW9uO1xyXG4gICAgICAgICAgICBSLlNldChhbmdsZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8vLyA8c3VtbWFyeT5cclxuICAgIC8vLyBUaGlzIGRlc2NyaWJlcyB0aGUgbW90aW9uIG9mIGEgYm9keS9zaGFwZSBmb3IgVE9JIGNvbXB1dGF0aW9uLlxyXG4gICAgLy8vIFNoYXBlcyBhcmUgZGVmaW5lZCB3aXRoIHJlc3BlY3QgdG8gdGhlIGJvZHkgb3JpZ2luLCB3aGljaCBtYXlcclxuICAgIC8vLyBubyBjb2luY2lkZSB3aXRoIHRoZSBjZW50ZXIgb2YgbWFzcy4gSG93ZXZlciwgdG8gc3VwcG9ydCBkeW5hbWljc1xyXG4gICAgLy8vIHdlIG11c3QgaW50ZXJwb2xhdGUgdGhlIGNlbnRlciBvZiBtYXNzIHBvc2l0aW9uLlxyXG4gICAgLy8vIDwvc3VtbWFyeT5cclxuICAgIHB1YmxpYyBzdHJ1Y3QgU3dlZXBcclxuICAgIHtcclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIFdvcmxkIGFuZ2xlc1xyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgcHVibGljIGZsb2F0IEE7XHJcblxyXG4gICAgICAgIHB1YmxpYyBmbG9hdCBBMDtcclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBGcmFjdGlvbiBvZiB0aGUgY3VycmVudCB0aW1lIHN0ZXAgaW4gdGhlIHJhbmdlIFswLDFdXHJcbiAgICAgICAgLy8vIGMwIGFuZCBhMCBhcmUgdGhlIHBvc2l0aW9ucyBhdCBhbHBoYTAuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICBwdWJsaWMgZmxvYXQgQWxwaGEwO1xyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIENlbnRlciB3b3JsZCBwb3NpdGlvbnNcclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIHB1YmxpYyBWZWN0b3IyIEM7XHJcblxyXG4gICAgICAgIHB1YmxpYyBWZWN0b3IyIEMwO1xyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIExvY2FsIGNlbnRlciBvZiBtYXNzIHBvc2l0aW9uXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICBwdWJsaWMgVmVjdG9yMiBMb2NhbENlbnRlcjtcclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBHZXQgdGhlIGludGVycG9sYXRlZCB0cmFuc2Zvcm0gYXQgYSBzcGVjaWZpYyB0aW1lLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwieGZcIj5UaGUgdHJhbnNmb3JtLjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwiYmV0YVwiPmJldGEgaXMgYSBmYWN0b3IgaW4gWzAsMV0sIHdoZXJlIDAgaW5kaWNhdGVzIGFscGhhMC48L3BhcmFtPlxyXG4gICAgICAgIHB1YmxpYyB2b2lkIEdldFRyYW5zZm9ybShvdXQgVHJhbnNmb3JtIHhmLCBmbG9hdCBiZXRhKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgeGYgPSBuZXcgVHJhbnNmb3JtKCk7XHJcbiAgICAgICAgICAgIHhmLlBvc2l0aW9uLlggPSAoMS4wZiAtIGJldGEpICogQzAuWCArIGJldGEgKiBDLlg7XHJcbiAgICAgICAgICAgIHhmLlBvc2l0aW9uLlkgPSAoMS4wZiAtIGJldGEpICogQzAuWSArIGJldGEgKiBDLlk7XHJcbiAgICAgICAgICAgIGZsb2F0IGFuZ2xlID0gKDEuMGYgLSBiZXRhKSAqIEEwICsgYmV0YSAqIEE7XHJcbiAgICAgICAgICAgIHhmLlIuU2V0KGFuZ2xlKTtcclxuXHJcbiAgICAgICAgICAgIC8vIFNoaWZ0IHRvIG9yaWdpblxyXG4gICAgICAgICAgICB4Zi5Qb3NpdGlvbiAtPSBNYXRoVXRpbHMuTXVsdGlwbHkocmVmIHhmLlIsIHJlZiBMb2NhbENlbnRlcik7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIEFkdmFuY2UgdGhlIHN3ZWVwIGZvcndhcmQsIHlpZWxkaW5nIGEgbmV3IGluaXRpYWwgc3RhdGUuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJhbHBoYVwiPm5ldyBpbml0aWFsIHRpbWUuLjwvcGFyYW0+XHJcbiAgICAgICAgcHVibGljIHZvaWQgQWR2YW5jZShmbG9hdCBhbHBoYSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIERlYnVnLkFzc2VydChBbHBoYTAgPCAxLjBmKTtcclxuICAgICAgICAgICAgZmxvYXQgYmV0YSA9IChhbHBoYSAtIEFscGhhMCkgLyAoMS4wZiAtIEFscGhhMCk7XHJcbiAgICAgICAgICAgIEMwLlggPSAoMS4wZiAtIGJldGEpICogQzAuWCArIGJldGEgKiBDLlg7XHJcbiAgICAgICAgICAgIEMwLlkgPSAoMS4wZiAtIGJldGEpICogQzAuWSArIGJldGEgKiBDLlk7XHJcbiAgICAgICAgICAgIEEwID0gKDEuMGYgLSBiZXRhKSAqIEEwICsgYmV0YSAqIEE7XHJcbiAgICAgICAgICAgIEFscGhhMCA9IGFscGhhO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBOb3JtYWxpemUgdGhlIGFuZ2xlcy5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIHB1YmxpYyB2b2lkIE5vcm1hbGl6ZSgpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBmbG9hdCBkID0gTWF0aEhlbHBlci5Ud29QaSAqIChmbG9hdClNYXRoLkZsb29yKEEwIC8gTWF0aEhlbHBlci5Ud29QaSk7XHJcbiAgICAgICAgICAgIEEwIC09IGQ7XHJcbiAgICAgICAgICAgIEEgLT0gZDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn0iLCJ1c2luZyBTeXN0ZW0uQ29sbGVjdGlvbnMuR2VuZXJpYztcclxudXNpbmcgTWljcm9zb2Z0LlhuYS5GcmFtZXdvcms7XHJcbnVzaW5nIE1pY3Jvc29mdC5YbmEuRnJhbWV3b3JrLkdyYXBoaWNzO1xyXG51c2luZyBGYXJzZWVyUGh5c2ljcy5EeW5hbWljcztcclxudXNpbmcgRmFyc2VlclBoeXNpY3MuQ29sbGlzaW9uO1xyXG51c2luZyBGYXJzZWVyUGh5c2ljcy5GYWN0b3JpZXM7XHJcblxyXG5uYW1lc3BhY2UgRmFyc2VlclBoeXNpY3MuQ29tbW9uXHJcbntcclxuICAgIHB1YmxpYyBlbnVtIERlY29tcG9zZXJcclxuICAgIHtcclxuICAgICAgICBCYXlheml0LFxyXG4gICAgICAgIENEVCxcclxuICAgICAgICBFYXJjbGlwLFxyXG4gICAgICAgIEZsaXBjb2RlLFxyXG4gICAgICAgIFNlaWRlbCxcclxuICAgIH1cclxuXHJcbiAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAvLy8gUmV0dXJuIHRydWUgaWYgdGhlIHNwZWNpZmllZCBjb2xvciBpcyBpbnNpZGUgdGhlIHRlcnJhaW4uXHJcbiAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgcHVibGljIGRlbGVnYXRlIGJvb2wgVGVycmFpblRlc3RlcihDb2xvciBDb2xvcik7XHJcblxyXG4gICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgLy8vIFNpbXBsZSBjbGFzcyB0byBtYWludGFpbiBhIHRlcnJhaW4uXHJcbiAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgcHVibGljIGNsYXNzIE1TVGVycmFpblxyXG4gICAge1xyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gV29ybGQgdG8gbWFuYWdlIHRlcnJhaW4gaW4uXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICBwdWJsaWMgV29ybGQgV29ybGQ7XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gQ2VudGVyIG9mIHRlcnJhaW4gaW4gd29ybGQgdW5pdHMuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICBwdWJsaWMgVmVjdG9yMiBDZW50ZXI7XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gV2lkdGggb2YgdGVycmFpbiBpbiB3b3JsZCB1bml0cy5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIHB1YmxpYyBmbG9hdCBXaWR0aDtcclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBIZWlnaHQgb2YgdGVycmFpbiBpbiB3b3JsZCB1bml0cy5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIHB1YmxpYyBmbG9hdCBIZWlnaHQ7XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gUG9pbnRzIHBlciBlYWNoIHdvcmxkIHVuaXQgdXNlZCB0byBkZWZpbmUgdGhlIHRlcnJhaW4gaW4gdGhlIHBvaW50IGNsb3VkLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgcHVibGljIGludCBQb2ludHNQZXJVbml0O1xyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIFBvaW50cyBwZXIgY2VsbC5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIHB1YmxpYyBpbnQgQ2VsbFNpemU7XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gUG9pbnRzIHBlciBzdWIgY2VsbC5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIHB1YmxpYyBpbnQgU3ViQ2VsbFNpemU7XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gTnVtYmVyIG9mIGl0ZXJhdGlvbnMgdG8gcGVyZm9ybSBpbiB0aGUgTWFyY2hpbmcgU3F1YXJlcyBhbGdvcml0aG0uXHJcbiAgICAgICAgLy8vIE5vdGU6IE1vcmUgdGhlbiAzIGhhcyBhbG1vc3Qgbm8gZWZmZWN0IG9uIHF1YWxpdHkuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICBwdWJsaWMgaW50IEl0ZXJhdGlvbnMgPSAyO1xyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIERlY29tcG9zZXIgdG8gdXNlIHdoZW4gcmVnZW5lcmF0aW5nIHRlcnJhaW4uIENhbiBiZSBjaGFuZ2VkIG9uIHRoZSBmbHkgd2l0aG91dCBjb25zZXF1ZW5jZS5cclxuICAgICAgICAvLy8gTm90ZTogU29tZSBkZWNvbXBvc2VyZXJzIGFyZSB1bnN0YWJsZS5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIHB1YmxpYyBEZWNvbXBvc2VyIERlY29tcG9zZXI7XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gUG9pbnQgY2xvdWQgZGVmaW5pbmcgdGhlIHRlcnJhaW4uXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICBwcml2YXRlIHNieXRlWyxdIF90ZXJyYWluTWFwO1xyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIEdlbmVyYXRlZCBib2RpZXMuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICBwcml2YXRlIExpc3Q8Qm9keT5bLF0gX2JvZHlNYXA7XHJcblxyXG4gICAgICAgIHByaXZhdGUgZmxvYXQgX2xvY2FsV2lkdGg7XHJcbiAgICAgICAgcHJpdmF0ZSBmbG9hdCBfbG9jYWxIZWlnaHQ7XHJcbiAgICAgICAgcHJpdmF0ZSBpbnQgX3hudW07XHJcbiAgICAgICAgcHJpdmF0ZSBpbnQgX3ludW07XHJcbiAgICAgICAgcHJpdmF0ZSBBQUJCIF9kaXJ0eUFyZWE7XHJcbiAgICAgICAgcHJpdmF0ZSBWZWN0b3IyIF90b3BMZWZ0O1xyXG5cclxuICAgICAgICBwdWJsaWMgTVNUZXJyYWluKFdvcmxkIHdvcmxkLCBBQUJCIGFyZWEpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBXb3JsZCA9IHdvcmxkO1xyXG4gICAgICAgICAgICBXaWR0aCA9IGFyZWEuRXh0ZW50cy5YICogMjtcclxuICAgICAgICAgICAgSGVpZ2h0ID0gYXJlYS5FeHRlbnRzLlkgKiAyO1xyXG4gICAgICAgICAgICBDZW50ZXIgPSBhcmVhLkNlbnRlcjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gSW5pdGlhbGl6ZSB0aGUgdGVycmFpbiBmb3IgdXNlLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgcHVibGljIHZvaWQgSW5pdGlhbGl6ZSgpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICAvLyBmaW5kIHRvcCBsZWZ0IG9mIHRlcnJhaW4gaW4gd29ybGQgc3BhY2VcclxuICAgICAgICAgICAgX3RvcExlZnQgPSBuZXcgVmVjdG9yMihDZW50ZXIuWCAtIChXaWR0aCAqIDAuNWYpLCBDZW50ZXIuWSAtICgtSGVpZ2h0ICogMC41ZikpO1xyXG5cclxuICAgICAgICAgICAgLy8gY29udmVydCB0aGUgdGVycmFpbnMgc2l6ZSB0byBhIHBvaW50IGNsb3VkIHNpemVcclxuICAgICAgICAgICAgX2xvY2FsV2lkdGggPSBXaWR0aCAqIFBvaW50c1BlclVuaXQ7XHJcbiAgICAgICAgICAgIF9sb2NhbEhlaWdodCA9IEhlaWdodCAqIFBvaW50c1BlclVuaXQ7XHJcblxyXG4gICAgICAgICAgICBfdGVycmFpbk1hcCA9IG5ldyBzYnl0ZVsoaW50KV9sb2NhbFdpZHRoICsgMSwgKGludClfbG9jYWxIZWlnaHQgKyAxXTtcclxuXHJcbiAgICAgICAgICAgIGZvciAoaW50IHggPSAwOyB4IDwgX2xvY2FsV2lkdGg7IHgrKylcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgZm9yIChpbnQgeSA9IDA7IHkgPCBfbG9jYWxIZWlnaHQ7IHkrKylcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBfdGVycmFpbk1hcFt4LCB5XSA9IDE7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIF94bnVtID0gKGludCkoX2xvY2FsV2lkdGggLyBDZWxsU2l6ZSk7XHJcbiAgICAgICAgICAgIF95bnVtID0gKGludCkoX2xvY2FsSGVpZ2h0IC8gQ2VsbFNpemUpO1xyXG4gICAgICAgICAgICBfYm9keU1hcCA9IG5ldyBMaXN0PEJvZHk+W194bnVtLCBfeW51bV07XHJcblxyXG4gICAgICAgICAgICAvLyBtYWtlIHN1cmUgdG8gbWFyayB0aGUgZGlydHkgYXJlYSB0byBhbiBpbmZpbml0ZWx5IHNtYWxsIGJveFxyXG4gICAgICAgICAgICBfZGlydHlBcmVhID0gbmV3IEFBQkIobmV3IFZlY3RvcjIoZmxvYXQuTWF4VmFsdWUsIGZsb2F0Lk1heFZhbHVlKSwgbmV3IFZlY3RvcjIoZmxvYXQuTWluVmFsdWUsIGZsb2F0Lk1pblZhbHVlKSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIEFwcGx5IGEgdGV4dHVyZSB0byB0aGUgdGVycmFpbiB1c2luZyB0aGUgc3BlY2lmaWVkIFRlcnJhaW5UZXN0ZXIuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJ0ZXh0dXJlXCI+VGV4dHVyZSB0byBhcHBseS48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cInBvc2l0aW9uXCI+VG9wIGxlZnQgcG9zaXRpb24gb2YgdGhlIHRleHR1cmUgcmVsYXRpdmUgdG8gdGhlIHRlcnJhaW4uPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJ0ZXN0ZXJcIj5EZWxlZ2F0ZSBtZXRob2QgdXNlZCB0byBkZXRlcm1pbmUgd2hhdCBjb2xvcnMgc2hvdWxkIGJlIGluY2x1ZGVkIGluIHRoZSB0ZXJyYWluLjwvcGFyYW0+XHJcbiAgICAgICAgcHVibGljIHZvaWQgQXBwbHlUZXh0dXJlKFRleHR1cmUyRCB0ZXh0dXJlLCBWZWN0b3IyIHBvc2l0aW9uLCBUZXJyYWluVGVzdGVyIHRlc3RlcilcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIENvbG9yW10gY29sb3JEYXRhID0gbmV3IENvbG9yW3RleHR1cmUuV2lkdGggKiB0ZXh0dXJlLkhlaWdodF07XHJcblxyXG4gICAgICAgICAgICB0ZXh0dXJlLkdldERhdGE8Z2xvYmFsOjpNaWNyb3NvZnQuWG5hLkZyYW1ld29yay5Db2xvcj4oY29sb3JEYXRhKTtcclxuXHJcbiAgICAgICAgICAgIGZvciAoaW50IHkgPSAoaW50KXBvc2l0aW9uLlk7IHkgPCB0ZXh0dXJlLkhlaWdodCArIChpbnQpcG9zaXRpb24uWTsgeSsrKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBmb3IgKGludCB4ID0gKGludClwb3NpdGlvbi5YOyB4IDwgdGV4dHVyZS5XaWR0aCArIChpbnQpcG9zaXRpb24uWDsgeCsrKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh4ID49IDAgJiYgeCA8IF9sb2NhbFdpZHRoICYmIHkgPj0gMCAmJiB5IDwgX2xvY2FsSGVpZ2h0KVxyXG4gICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYm9vbCBpbnNpZGUgPSB0ZXN0ZXIoY29sb3JEYXRhWygoeSAtIChpbnQpcG9zaXRpb24uWSkgKiB0ZXh0dXJlLldpZHRoKSArICh4IC0gKGludClwb3NpdGlvbi5YKV0pO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFpbnNpZGUpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGVycmFpbk1hcFt4LCB5XSA9IDE7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90ZXJyYWluTWFwW3gsIHldID0gLTE7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBnZW5lcmF0ZSB0ZXJyYWluXHJcbiAgICAgICAgICAgIGZvciAoaW50IGd5ID0gMDsgZ3kgPCBfeW51bTsgZ3krKylcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgZm9yIChpbnQgZ3ggPSAwOyBneCA8IF94bnVtOyBneCsrKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vcmVtb3ZlIG9sZCB0ZXJyYWluIG9iamVjdCBhdCBncmlkIGNlbGxcclxuICAgICAgICAgICAgICAgICAgICBpZiAoX2JvZHlNYXBbZ3gsIGd5XSAhPSBudWxsKVxyXG4gICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChpbnQgaSA9IDA7IGkgPCBfYm9keU1hcFtneCwgZ3ldLkNvdW50OyBpKyspXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFdvcmxkLlJlbW92ZUJvZHkoX2JvZHlNYXBbZ3gsIGd5XVtpXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIF9ib2R5TWFwW2d4LCBneV0gPSBudWxsO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvL2dlbmVyYXRlIG5ldyBvbmVcclxuICAgICAgICAgICAgICAgICAgICBHZW5lcmF0ZVRlcnJhaW4oZ3gsIGd5KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBBcHBseSBhIHRleHR1cmUgdG8gdGhlIHRlcnJhaW4gdXNpbmcgdGhlIHNwZWNpZmllZCBUZXJyYWluVGVzdGVyLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwicG9zaXRpb25cIj5Ub3AgbGVmdCBwb3NpdGlvbiBvZiB0aGUgdGV4dHVyZSByZWxhdGl2ZSB0byB0aGUgdGVycmFpbi48L3BhcmFtPlxyXG4gICAgICAgIHB1YmxpYyB2b2lkIEFwcGx5RGF0YShzYnl0ZVssXSBkYXRhLCBWZWN0b3IyIHBvc2l0aW9uKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgZm9yIChpbnQgeSA9IChpbnQpcG9zaXRpb24uWTsgeSA8IGRhdGEuR2V0VXBwZXJCb3VuZCgxKSArIChpbnQpcG9zaXRpb24uWTsgeSsrKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBmb3IgKGludCB4ID0gKGludClwb3NpdGlvbi5YOyB4IDwgZGF0YS5HZXRVcHBlckJvdW5kKDApICsgKGludClwb3NpdGlvbi5YOyB4KyspXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHggPj0gMCAmJiB4IDwgX2xvY2FsV2lkdGggJiYgeSA+PSAwICYmIHkgPCBfbG9jYWxIZWlnaHQpXHJcbiAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBfdGVycmFpbk1hcFt4LCB5XSA9IGRhdGFbeCwgeV07XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBnZW5lcmF0ZSB0ZXJyYWluXHJcbiAgICAgICAgICAgIGZvciAoaW50IGd5ID0gMDsgZ3kgPCBfeW51bTsgZ3krKylcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgZm9yIChpbnQgZ3ggPSAwOyBneCA8IF94bnVtOyBneCsrKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vcmVtb3ZlIG9sZCB0ZXJyYWluIG9iamVjdCBhdCBncmlkIGNlbGxcclxuICAgICAgICAgICAgICAgICAgICBpZiAoX2JvZHlNYXBbZ3gsIGd5XSAhPSBudWxsKVxyXG4gICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChpbnQgaSA9IDA7IGkgPCBfYm9keU1hcFtneCwgZ3ldLkNvdW50OyBpKyspXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFdvcmxkLlJlbW92ZUJvZHkoX2JvZHlNYXBbZ3gsIGd5XVtpXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIF9ib2R5TWFwW2d4LCBneV0gPSBudWxsO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvL2dlbmVyYXRlIG5ldyBvbmVcclxuICAgICAgICAgICAgICAgICAgICBHZW5lcmF0ZVRlcnJhaW4oZ3gsIGd5KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBDb252ZXJ0IGEgdGV4dHVyZSB0byBhbiBzYnR5ZSBhcnJheSBjb21wYXRpYmxlIHdpdGggQXBwbHlEYXRhKCkuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJ0ZXh0dXJlXCI+VGV4dHVyZSB0byBjb252ZXJ0LjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwidGVzdGVyXCI+PC9wYXJhbT5cclxuICAgICAgICAvLy8gPHJldHVybnM+PC9yZXR1cm5zPlxyXG4gICAgICAgIHB1YmxpYyBzdGF0aWMgc2J5dGVbLF0gQ29udmVydFRleHR1cmVUb0RhdGEoVGV4dHVyZTJEIHRleHR1cmUsIFRlcnJhaW5UZXN0ZXIgdGVzdGVyKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgc2J5dGVbLF0gZGF0YSA9IG5ldyBzYnl0ZVt0ZXh0dXJlLldpZHRoLCB0ZXh0dXJlLkhlaWdodF07XHJcbiAgICAgICAgICAgIENvbG9yW10gY29sb3JEYXRhID0gbmV3IENvbG9yW3RleHR1cmUuV2lkdGggKiB0ZXh0dXJlLkhlaWdodF07XHJcblxyXG4gICAgICAgICAgICB0ZXh0dXJlLkdldERhdGE8Z2xvYmFsOjpNaWNyb3NvZnQuWG5hLkZyYW1ld29yay5Db2xvcj4oY29sb3JEYXRhKTtcclxuXHJcbiAgICAgICAgICAgIGZvciAoaW50IHkgPSAwOyB5IDwgdGV4dHVyZS5IZWlnaHQ7IHkrKylcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgZm9yIChpbnQgeCA9IDA7IHggPCB0ZXh0dXJlLldpZHRoOyB4KyspXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgYm9vbCBpbnNpZGUgPSB0ZXN0ZXIoY29sb3JEYXRhWyh5ICogdGV4dHVyZS5XaWR0aCkgKyB4XSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmICghaW5zaWRlKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhW3gsIHldID0gMTtcclxuICAgICAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGFbeCwgeV0gPSAtMTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuIGRhdGE7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIE1vZGlmeSBhIHNpbmdsZSBwb2ludCBpbiB0aGUgdGVycmFpbi5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cImxvY2F0aW9uXCI+V29ybGQgbG9jYXRpb24gdG8gbW9kaWZ5LiBBdXRvbWF0aWNhbGx5IGNsaXBwZWQuPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJ2YWx1ZVwiPi0xID0gaW5zaWRlIHRlcnJhaW4sIDEgPSBvdXRzaWRlIHRlcnJhaW48L3BhcmFtPlxyXG4gICAgICAgIHB1YmxpYyB2b2lkIE1vZGlmeVRlcnJhaW4oVmVjdG9yMiBsb2NhdGlvbiwgc2J5dGUgdmFsdWUpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICAvLyBmaW5kIGxvY2FsIHBvc2l0aW9uXHJcbiAgICAgICAgICAgIC8vIG1ha2UgcG9zaXRpb24gbG9jYWwgdG8gbWFwIHNwYWNlXHJcbiAgICAgICAgICAgIFZlY3RvcjIgcCA9IGxvY2F0aW9uIC0gX3RvcExlZnQ7XHJcblxyXG4gICAgICAgICAgICAvLyBmaW5kIG1hcCBwb3NpdGlvbiBmb3IgZWFjaCBheGlzXHJcbiAgICAgICAgICAgIHAuWCA9IHAuWCAqIF9sb2NhbFdpZHRoIC8gV2lkdGg7XHJcbiAgICAgICAgICAgIHAuWSA9IHAuWSAqIC1fbG9jYWxIZWlnaHQgLyBIZWlnaHQ7XHJcblxyXG4gICAgICAgICAgICBpZiAocC5YID49IDAgJiYgcC5YIDwgX2xvY2FsV2lkdGggJiYgcC5ZID49IDAgJiYgcC5ZIDwgX2xvY2FsSGVpZ2h0KVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBfdGVycmFpbk1hcFsoaW50KXAuWCwgKGludClwLlldID0gdmFsdWU7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gZXhwYW5kIGRpcnR5IGFyZWFcclxuICAgICAgICAgICAgICAgIGlmIChwLlggPCBfZGlydHlBcmVhLkxvd2VyQm91bmQuWCkgX2RpcnR5QXJlYS5Mb3dlckJvdW5kLlggPSBwLlg7XHJcbiAgICAgICAgICAgICAgICBpZiAocC5YID4gX2RpcnR5QXJlYS5VcHBlckJvdW5kLlgpIF9kaXJ0eUFyZWEuVXBwZXJCb3VuZC5YID0gcC5YO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmIChwLlkgPCBfZGlydHlBcmVhLkxvd2VyQm91bmQuWSkgX2RpcnR5QXJlYS5Mb3dlckJvdW5kLlkgPSBwLlk7XHJcbiAgICAgICAgICAgICAgICBpZiAocC5ZID4gX2RpcnR5QXJlYS5VcHBlckJvdW5kLlkpIF9kaXJ0eUFyZWEuVXBwZXJCb3VuZC5ZID0gcC5ZO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIFJlZ2VuZXJhdGUgdGhlIHRlcnJhaW4uXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICBwdWJsaWMgdm9pZCBSZWdlbmVyYXRlVGVycmFpbigpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICAvL2l0ZXJhdGUgZWZmZWN0ZWQgY2VsbHNcclxuICAgICAgICAgICAgdmFyIGd4MCA9IChpbnQpKF9kaXJ0eUFyZWEuTG93ZXJCb3VuZC5YIC8gQ2VsbFNpemUpO1xyXG4gICAgICAgICAgICB2YXIgZ3gxID0gKGludCkoX2RpcnR5QXJlYS5VcHBlckJvdW5kLlggLyBDZWxsU2l6ZSkgKyAxO1xyXG4gICAgICAgICAgICBpZiAoZ3gwIDwgMCkgZ3gwID0gMDtcclxuICAgICAgICAgICAgaWYgKGd4MSA+IF94bnVtKSBneDEgPSBfeG51bTtcclxuICAgICAgICAgICAgdmFyIGd5MCA9IChpbnQpKF9kaXJ0eUFyZWEuTG93ZXJCb3VuZC5ZIC8gQ2VsbFNpemUpO1xyXG4gICAgICAgICAgICB2YXIgZ3kxID0gKGludCkoX2RpcnR5QXJlYS5VcHBlckJvdW5kLlkgLyBDZWxsU2l6ZSkgKyAxO1xyXG4gICAgICAgICAgICBpZiAoZ3kwIDwgMCkgZ3kwID0gMDtcclxuICAgICAgICAgICAgaWYgKGd5MSA+IF95bnVtKSBneTEgPSBfeW51bTtcclxuXHJcbiAgICAgICAgICAgIGZvciAoaW50IGd4ID0gZ3gwOyBneCA8IGd4MTsgZ3grKylcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgZm9yIChpbnQgZ3kgPSBneTA7IGd5IDwgZ3kxOyBneSsrKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vcmVtb3ZlIG9sZCB0ZXJyYWluIG9iamVjdCBhdCBncmlkIGNlbGxcclxuICAgICAgICAgICAgICAgICAgICBpZiAoX2JvZHlNYXBbZ3gsIGd5XSAhPSBudWxsKVxyXG4gICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChpbnQgaSA9IDA7IGkgPCBfYm9keU1hcFtneCwgZ3ldLkNvdW50OyBpKyspXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFdvcmxkLlJlbW92ZUJvZHkoX2JvZHlNYXBbZ3gsIGd5XVtpXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIF9ib2R5TWFwW2d4LCBneV0gPSBudWxsO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvL2dlbmVyYXRlIG5ldyBvbmVcclxuICAgICAgICAgICAgICAgICAgICBHZW5lcmF0ZVRlcnJhaW4oZ3gsIGd5KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgX2RpcnR5QXJlYSA9IG5ldyBBQUJCKG5ldyBWZWN0b3IyKGZsb2F0Lk1heFZhbHVlLCBmbG9hdC5NYXhWYWx1ZSksIG5ldyBWZWN0b3IyKGZsb2F0Lk1pblZhbHVlLCBmbG9hdC5NaW5WYWx1ZSkpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHJpdmF0ZSB2b2lkIEdlbmVyYXRlVGVycmFpbihpbnQgZ3gsIGludCBneSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGZsb2F0IGF4ID0gZ3ggKiBDZWxsU2l6ZTtcclxuICAgICAgICAgICAgZmxvYXQgYXkgPSBneSAqIENlbGxTaXplO1xyXG5cclxuICAgICAgICAgICAgTGlzdDxWZXJ0aWNlcz4gcG9seXMgPSBNYXJjaGluZ1NxdWFyZXMuRGV0ZWN0U3F1YXJlcyhuZXcgQUFCQihuZXcgVmVjdG9yMihheCwgYXkpLCBuZXcgVmVjdG9yMihheCArIENlbGxTaXplLCBheSArIENlbGxTaXplKSksIFN1YkNlbGxTaXplLCBTdWJDZWxsU2l6ZSwgX3RlcnJhaW5NYXAsIEl0ZXJhdGlvbnMsIHRydWUpO1xyXG4gICAgICAgICAgICBpZiAocG9seXMuQ291bnQgPT0gMCkgcmV0dXJuO1xyXG5cclxuICAgICAgICAgICAgX2JvZHlNYXBbZ3gsIGd5XSA9IG5ldyBMaXN0PEJvZHk+KCk7XHJcblxyXG4gICAgICAgICAgICAvLyBjcmVhdGUgdGhlIHNjYWxlIHZlY3RvclxyXG4gICAgICAgICAgICBWZWN0b3IyIHNjYWxlID0gbmV3IFZlY3RvcjIoMWYgLyBQb2ludHNQZXJVbml0LCAxZiAvIC1Qb2ludHNQZXJVbml0KTtcclxuXHJcbiAgICAgICAgICAgIC8vIGNyZWF0ZSBwaHlzaWNzIG9iamVjdCBmb3IgdGhpcyBncmlkIGNlbGxcclxuICAgICAgICAgICAgZm9yZWFjaCAodmFyIGl0ZW0gaW4gcG9seXMpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIC8vIGRvZXMgdGhpcyBuZWVkIHRvIGJlIG5lZ2F0aXZlP1xyXG4gICAgICAgICAgICAgICAgaXRlbS5TY2FsZShyZWYgc2NhbGUpO1xyXG4gICAgICAgICAgICAgICAgaXRlbS5UcmFuc2xhdGUocmVmIF90b3BMZWZ0KTtcclxuICAgICAgICAgICAgICAgIGl0ZW0uRm9yY2VDb3VudGVyQ2xvY2tXaXNlKCk7XHJcbiAgICAgICAgICAgICAgICBWZXJ0aWNlcyBwID0gRmFyc2VlclBoeXNpY3MuQ29tbW9uLlBvbHlnb25NYW5pcHVsYXRpb24uU2ltcGxpZnlUb29scy5Db2xsaW5lYXJTaW1wbGlmeShpdGVtKTtcclxuICAgICAgICAgICAgICAgIExpc3Q8VmVydGljZXM+IGRlY29tcFBvbHlzID0gbmV3IExpc3Q8VmVydGljZXM+KCk7XHJcblxyXG4gICAgICAgICAgICAgICAgc3dpdGNoIChEZWNvbXBvc2VyKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgRGVjb21wb3Nlci5CYXlheml0OlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBkZWNvbXBQb2x5cyA9IERlY29tcG9zaXRpb24uQmF5YXppdERlY29tcG9zZXIuQ29udmV4UGFydGl0aW9uKHApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIERlY29tcG9zZXIuQ0RUOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBkZWNvbXBQb2x5cyA9IERlY29tcG9zaXRpb24uQ0RURGVjb21wb3Nlci5Db252ZXhQYXJ0aXRpb24ocCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgRGVjb21wb3Nlci5FYXJjbGlwOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBkZWNvbXBQb2x5cyA9IERlY29tcG9zaXRpb24uRWFyY2xpcERlY29tcG9zZXIuQ29udmV4UGFydGl0aW9uKHApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIERlY29tcG9zZXIuRmxpcGNvZGU6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlY29tcFBvbHlzID0gRGVjb21wb3NpdGlvbi5GbGlwY29kZURlY29tcG9zZXIuQ29udmV4UGFydGl0aW9uKHApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIERlY29tcG9zZXIuU2VpZGVsOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBkZWNvbXBQb2x5cyA9IERlY29tcG9zaXRpb24uU2VpZGVsRGVjb21wb3Nlci5Db252ZXhQYXJ0aXRpb24ocCwgMC4wMDFmKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgZm9yZWFjaCAoVmVydGljZXMgcG9seSBpbiBkZWNvbXBQb2x5cylcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAocG9seS5Db3VudCA+IDIpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF9ib2R5TWFwW2d4LCBneV0uQWRkKEJvZHlGYWN0b3J5LkNyZWF0ZVBvbHlnb24oV29ybGQsIHBvbHksIDEpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG4iLCIvKlxyXG4qIEZhcnNlZXIgUGh5c2ljcyBFbmdpbmUgYmFzZWQgb24gQm94MkQuWE5BIHBvcnQ6XHJcbiogQ29weXJpZ2h0IChjKSAyMDEwIElhbiBRdmlzdFxyXG4qIFxyXG4qIEJveDJELlhOQSBwb3J0IG9mIEJveDJEOlxyXG4qIENvcHlyaWdodCAoYykgMjAwOSBCcmFuZG9uIEZ1cnR3YW5nbGVyLCBOYXRoYW4gRnVydHdhbmdsZXJcclxuKlxyXG4qIE9yaWdpbmFsIHNvdXJjZSBCb3gyRDpcclxuKiBDb3B5cmlnaHQgKGMpIDIwMDYtMjAwOSBFcmluIENhdHRvIGh0dHA6Ly93d3cuZ3BoeXNpY3MuY29tIFxyXG4qIFxyXG4qIFRoaXMgc29mdHdhcmUgaXMgcHJvdmlkZWQgJ2FzLWlzJywgd2l0aG91dCBhbnkgZXhwcmVzcyBvciBpbXBsaWVkIFxyXG4qIHdhcnJhbnR5LiAgSW4gbm8gZXZlbnQgd2lsbCB0aGUgYXV0aG9ycyBiZSBoZWxkIGxpYWJsZSBmb3IgYW55IGRhbWFnZXMgXHJcbiogYXJpc2luZyBmcm9tIHRoZSB1c2Ugb2YgdGhpcyBzb2Z0d2FyZS4gXHJcbiogUGVybWlzc2lvbiBpcyBncmFudGVkIHRvIGFueW9uZSB0byB1c2UgdGhpcyBzb2Z0d2FyZSBmb3IgYW55IHB1cnBvc2UsIFxyXG4qIGluY2x1ZGluZyBjb21tZXJjaWFsIGFwcGxpY2F0aW9ucywgYW5kIHRvIGFsdGVyIGl0IGFuZCByZWRpc3RyaWJ1dGUgaXQgXHJcbiogZnJlZWx5LCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgcmVzdHJpY3Rpb25zOiBcclxuKiAxLiBUaGUgb3JpZ2luIG9mIHRoaXMgc29mdHdhcmUgbXVzdCBub3QgYmUgbWlzcmVwcmVzZW50ZWQ7IHlvdSBtdXN0IG5vdCBcclxuKiBjbGFpbSB0aGF0IHlvdSB3cm90ZSB0aGUgb3JpZ2luYWwgc29mdHdhcmUuIElmIHlvdSB1c2UgdGhpcyBzb2Z0d2FyZSBcclxuKiBpbiBhIHByb2R1Y3QsIGFuIGFja25vd2xlZGdtZW50IGluIHRoZSBwcm9kdWN0IGRvY3VtZW50YXRpb24gd291bGQgYmUgXHJcbiogYXBwcmVjaWF0ZWQgYnV0IGlzIG5vdCByZXF1aXJlZC4gXHJcbiogMi4gQWx0ZXJlZCBzb3VyY2UgdmVyc2lvbnMgbXVzdCBiZSBwbGFpbmx5IG1hcmtlZCBhcyBzdWNoLCBhbmQgbXVzdCBub3QgYmUgXHJcbiogbWlzcmVwcmVzZW50ZWQgYXMgYmVpbmcgdGhlIG9yaWdpbmFsIHNvZnR3YXJlLiBcclxuKiAzLiBUaGlzIG5vdGljZSBtYXkgbm90IGJlIHJlbW92ZWQgb3IgYWx0ZXJlZCBmcm9tIGFueSBzb3VyY2UgZGlzdHJpYnV0aW9uLiBcclxuKi9cclxuXHJcbnVzaW5nIFN5c3RlbTtcclxudXNpbmcgU3lzdGVtLkNvbGxlY3Rpb25zLkdlbmVyaWM7XHJcbnVzaW5nIFN5c3RlbS5EaWFnbm9zdGljcztcclxudXNpbmcgRmFyc2VlclBoeXNpY3MuQ29sbGlzaW9uO1xyXG51c2luZyBGYXJzZWVyUGh5c2ljcy5Db21tb247XHJcbnVzaW5nIEZhcnNlZXJQaHlzaWNzLkNvbnRyb2xsZXJzO1xyXG51c2luZyBGYXJzZWVyUGh5c2ljcy5EeW5hbWljcy5Db250YWN0cztcclxudXNpbmcgRmFyc2VlclBoeXNpY3MuRHluYW1pY3MuSm9pbnRzO1xyXG51c2luZyBNaWNyb3NvZnQuWG5hLkZyYW1ld29yaztcclxuXHJcbm5hbWVzcGFjZSBGYXJzZWVyUGh5c2ljcy5EeW5hbWljc1xyXG57XHJcbiAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAvLy8gQ29udGFpbnMgZmlsdGVyIGRhdGEgdGhhdCBjYW4gZGV0ZXJtaW5lIHdoZXRoZXIgYW4gb2JqZWN0IHNob3VsZCBiZSBwcm9jZXNzZWQgb3Igbm90LlxyXG4gICAgLy8vIDwvc3VtbWFyeT5cclxuICAgIHB1YmxpYyBhYnN0cmFjdCBjbGFzcyBGaWx0ZXJEYXRhXHJcbiAgICB7XHJcbiAgICAgICAgcHVibGljIENhdGVnb3J5IERpc2FibGVkT25DYXRlZ29yaWVzID0gQ2F0ZWdvcnkuTm9uZTtcclxuXHJcbiAgICAgICAgcHVibGljIGludCBEaXNhYmxlZE9uR3JvdXA7XHJcbiAgICAgICAgcHVibGljIENhdGVnb3J5IEVuYWJsZWRPbkNhdGVnb3JpZXMgPSBDYXRlZ29yeS5BbGw7XHJcbiAgICAgICAgcHVibGljIGludCBFbmFibGVkT25Hcm91cDtcclxuXHJcbiAgICAgICAgcHVibGljIHZpcnR1YWwgYm9vbCBJc0FjdGl2ZU9uKEJvZHkgYm9keSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGlmIChib2R5ID09IG51bGwgfHwgIWJvZHkuRW5hYmxlZCB8fCBib2R5LklzU3RhdGljKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG5cclxuICAgICAgICAgICAgaWYgKGJvZHkuRml4dHVyZUxpc3QgPT0gbnVsbClcclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuXHJcbiAgICAgICAgICAgIGZvcmVhY2ggKEZpeHR1cmUgZml4dHVyZSBpbiBib2R5LkZpeHR1cmVMaXN0KVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAvL0Rpc2FibGVcclxuICAgICAgICAgICAgICAgIGlmICgoZml4dHVyZS5Db2xsaXNpb25Hcm91cCA9PSBEaXNhYmxlZE9uR3JvdXApICYmXHJcbiAgICAgICAgICAgICAgICAgICAgZml4dHVyZS5Db2xsaXNpb25Hcm91cCAhPSAwICYmIERpc2FibGVkT25Hcm91cCAhPSAwKVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoKGZpeHR1cmUuQ29sbGlzaW9uQ2F0ZWdvcmllcyAmIERpc2FibGVkT25DYXRlZ29yaWVzKSAhPSBDYXRlZ29yeS5Ob25lKVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoRW5hYmxlZE9uR3JvdXAgIT0gMCB8fCBFbmFibGVkT25DYXRlZ29yaWVzICE9IENhdGVnb3J5LkFsbClcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAvL0VuYWJsZVxyXG4gICAgICAgICAgICAgICAgICAgIGlmICgoZml4dHVyZS5Db2xsaXNpb25Hcm91cCA9PSBFbmFibGVkT25Hcm91cCkgJiZcclxuICAgICAgICAgICAgICAgICAgICAgICAgZml4dHVyZS5Db2xsaXNpb25Hcm91cCAhPSAwICYmIEVuYWJsZWRPbkdyb3VwICE9IDApXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZiAoKGZpeHR1cmUuQ29sbGlzaW9uQ2F0ZWdvcmllcyAmIEVuYWJsZWRPbkNhdGVnb3JpZXMpICE9IENhdGVnb3J5Lk5vbmUgJiZcclxuICAgICAgICAgICAgICAgICAgICAgICAgRW5hYmxlZE9uQ2F0ZWdvcmllcyAhPSBDYXRlZ29yeS5BbGwpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIEFkZHMgdGhlIGNhdGVnb3J5LlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwiY2F0ZWdvcnlcIj5UaGUgY2F0ZWdvcnkuPC9wYXJhbT5cclxuICAgICAgICBwdWJsaWMgdm9pZCBBZGREaXNhYmxlZENhdGVnb3J5KENhdGVnb3J5IGNhdGVnb3J5KVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgRGlzYWJsZWRPbkNhdGVnb3JpZXMgfD0gY2F0ZWdvcnk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIFJlbW92ZXMgdGhlIGNhdGVnb3J5LlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwiY2F0ZWdvcnlcIj5UaGUgY2F0ZWdvcnkuPC9wYXJhbT5cclxuICAgICAgICBwdWJsaWMgdm9pZCBSZW1vdmVEaXNhYmxlZENhdGVnb3J5KENhdGVnb3J5IGNhdGVnb3J5KVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgRGlzYWJsZWRPbkNhdGVnb3JpZXMgJj0gfmNhdGVnb3J5O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBEZXRlcm1pbmVzIHdoZXRoZXIgdGhpcyBib2R5IGlnbm9yZXMgdGhlIHRoZSBzcGVjaWZpZWQgY29udHJvbGxlci5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cImNhdGVnb3J5XCI+VGhlIGNhdGVnb3J5LjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxyZXR1cm5zPlxyXG4gICAgICAgIC8vLyBcdDxjPnRydWU8L2M+IGlmIHRoZSBvYmplY3QgaGFzIHRoZSBzcGVjaWZpZWQgY2F0ZWdvcnk7IG90aGVyd2lzZSwgPGM+ZmFsc2U8L2M+LlxyXG4gICAgICAgIC8vLyA8L3JldHVybnM+XHJcbiAgICAgICAgcHVibGljIGJvb2wgSXNJbkRpc2FibGVkQ2F0ZWdvcnkoQ2F0ZWdvcnkgY2F0ZWdvcnkpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gKERpc2FibGVkT25DYXRlZ29yaWVzICYgY2F0ZWdvcnkpID09IGNhdGVnb3J5O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBBZGRzIHRoZSBjYXRlZ29yeS5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cImNhdGVnb3J5XCI+VGhlIGNhdGVnb3J5LjwvcGFyYW0+XHJcbiAgICAgICAgcHVibGljIHZvaWQgQWRkRW5hYmxlZENhdGVnb3J5KENhdGVnb3J5IGNhdGVnb3J5KVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgRW5hYmxlZE9uQ2F0ZWdvcmllcyB8PSBjYXRlZ29yeTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gUmVtb3ZlcyB0aGUgY2F0ZWdvcnkuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJjYXRlZ29yeVwiPlRoZSBjYXRlZ29yeS48L3BhcmFtPlxyXG4gICAgICAgIHB1YmxpYyB2b2lkIFJlbW92ZUVuYWJsZWRDYXRlZ29yeShDYXRlZ29yeSBjYXRlZ29yeSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIEVuYWJsZWRPbkNhdGVnb3JpZXMgJj0gfmNhdGVnb3J5O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBEZXRlcm1pbmVzIHdoZXRoZXIgdGhpcyBib2R5IGlnbm9yZXMgdGhlIHRoZSBzcGVjaWZpZWQgY29udHJvbGxlci5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cImNhdGVnb3J5XCI+VGhlIGNhdGVnb3J5LjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxyZXR1cm5zPlxyXG4gICAgICAgIC8vLyBcdDxjPnRydWU8L2M+IGlmIHRoZSBvYmplY3QgaGFzIHRoZSBzcGVjaWZpZWQgY2F0ZWdvcnk7IG90aGVyd2lzZSwgPGM+ZmFsc2U8L2M+LlxyXG4gICAgICAgIC8vLyA8L3JldHVybnM+XHJcbiAgICAgICAgcHVibGljIGJvb2wgSXNJbkVuYWJsZWRDYXRlZ29yeShDYXRlZ29yeSBjYXRlZ29yeSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiAoRW5hYmxlZE9uQ2F0ZWdvcmllcyAmIGNhdGVnb3J5KSA9PSBjYXRlZ29yeTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgW0ZsYWdzXVxyXG4gICAgcHVibGljIGVudW0gV29ybGRGbGFnc1xyXG4gICAge1xyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gRmxhZyB0aGF0IGluZGljYXRlcyBhIG5ldyBmaXh0dXJlIGhhcyBiZWVuIGFkZGVkIHRvIHRoZSB3b3JsZC5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIE5ld0ZpeHR1cmUgPSAoMSA8PCAwKSxcclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBGbGFnIHRoYXQgY2xlYXIgdGhlIGZvcmNlcyBhZnRlciBlYWNoIHRpbWUgc3RlcC5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIENsZWFyRm9yY2VzID0gKDEgPDwgMiksXHJcblxyXG4gICAgICAgIFN1YlN0ZXBwaW5nID0gKDEgPDwgNCksXHJcbiAgICB9XHJcblxyXG4gICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgLy8vIFRoZSB3b3JsZCBjbGFzcyBtYW5hZ2VzIGFsbCBwaHlzaWNzIGVudGl0aWVzLCBkeW5hbWljIHNpbXVsYXRpb24sXHJcbiAgICAvLy8gYW5kIGFzeW5jaHJvbm91cyBxdWVyaWVzLlxyXG4gICAgLy8vIDwvc3VtbWFyeT5cclxuICAgIHB1YmxpYyBjbGFzcyBXb3JsZFxyXG4gICAge1xyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gRmlyZXMgd2hlbmV2ZXIgYSBib2R5IGhhcyBiZWVuIGFkZGVkXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICBwdWJsaWMgQm9keURlbGVnYXRlIEJvZHlBZGRlZDtcclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBGaXJlcyB3aGVuZXZlciBhIGJvZHkgaGFzIGJlZW4gcmVtb3ZlZFxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgcHVibGljIEJvZHlEZWxlZ2F0ZSBCb2R5UmVtb3ZlZDtcclxuXHJcbiAgICAgICAgaW50ZXJuYWwgUXVldWU8Q29udGFjdD4gQ29udGFjdFBvb2wgPSBuZXcgUXVldWU8Q29udGFjdD4oMjU2KTtcclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBGaXJlcyB3aGVuZXZlciBhIGZpeHR1cmUgaGFzIGJlZW4gYWRkZWRcclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIHB1YmxpYyBGaXh0dXJlRGVsZWdhdGUgRml4dHVyZUFkZGVkO1xyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIEZpcmVzIHdoZW5ldmVyIGEgZml4dHVyZSBoYXMgYmVlbiByZW1vdmVkXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICBwdWJsaWMgRml4dHVyZURlbGVnYXRlIEZpeHR1cmVSZW1vdmVkO1xyXG5cclxuICAgICAgICBpbnRlcm5hbCBXb3JsZEZsYWdzIEZsYWdzO1xyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIEZpcmVzIHdoZW5ldmVyIGEgam9pbnQgaGFzIGJlZW4gYWRkZWRcclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIHB1YmxpYyBKb2ludERlbGVnYXRlIEpvaW50QWRkZWQ7XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gRmlyZXMgd2hlbmV2ZXIgYSBqb2ludCBoYXMgYmVlbiByZW1vdmVkXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICBwdWJsaWMgSm9pbnREZWxlZ2F0ZSBKb2ludFJlbW92ZWQ7XHJcblxyXG4gICAgICAgIHB1YmxpYyBDb250cm9sbGVyRGVsZWdhdGUgQ29udHJvbGxlckFkZGVkO1xyXG5cclxuICAgICAgICBwdWJsaWMgQ29udHJvbGxlckRlbGVnYXRlIENvbnRyb2xsZXJSZW1vdmVkO1xyXG5cclxuICAgICAgICBwcml2YXRlIGZsb2F0IF9pbnZEdDA7XHJcbiAgICAgICAgcHVibGljIElzbGFuZCBJc2xhbmQgPSBuZXcgSXNsYW5kKCk7XHJcbiAgICAgICAgcHJpdmF0ZSBCb2R5W10gX3N0YWNrID0gbmV3IEJvZHlbNjRdO1xyXG4gICAgICAgIHByaXZhdGUgYm9vbCBfc3RlcENvbXBsZXRlO1xyXG4gICAgICAgIHByaXZhdGUgSGFzaFNldDxCb2R5PiBfYm9keUFkZExpc3QgPSBuZXcgSGFzaFNldDxCb2R5PigpO1xyXG4gICAgICAgIHByaXZhdGUgSGFzaFNldDxCb2R5PiBfYm9keVJlbW92ZUxpc3QgPSBuZXcgSGFzaFNldDxCb2R5PigpO1xyXG4gICAgICAgIHByaXZhdGUgSGFzaFNldDxKb2ludD4gX2pvaW50QWRkTGlzdCA9IG5ldyBIYXNoU2V0PEpvaW50PigpO1xyXG4gICAgICAgIHByaXZhdGUgSGFzaFNldDxKb2ludD4gX2pvaW50UmVtb3ZlTGlzdCA9IG5ldyBIYXNoU2V0PEpvaW50PigpO1xyXG4gICAgICAgIHByaXZhdGUgVE9JSW5wdXQgX2lucHV0ID0gbmV3IFRPSUlucHV0KCk7XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gSWYgZmFsc2UsIHRoZSB3aG9sZSBzaW11bGF0aW9uIHN0b3BzLiBJdCBzdGlsbCBwcm9jZXNzZXMgYWRkZWQgYW5kIHJlbW92ZWQgZ2VvbWV0cmllcy5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIHB1YmxpYyBib29sIEVuYWJsZWQgPSB0cnVlO1xyXG5cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBJbml0aWFsaXplcyBhIG5ldyBpbnN0YW5jZSBvZiB0aGUgPHNlZSBjcmVmPVwiV29ybGRcIi8+IGNsYXNzLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgcHJpdmF0ZSBXb3JsZCgpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBGbGFncyA9IFdvcmxkRmxhZ3MuQ2xlYXJGb3JjZXM7XHJcblxyXG4gICAgICAgICAgICBDb250cm9sbGVyTGlzdCA9IG5ldyBMaXN0PENvbnRyb2xsZXI+KCk7XHJcbiAgICAgICAgICAgIEJyZWFrYWJsZUJvZHlMaXN0ID0gbmV3IExpc3Q8QnJlYWthYmxlQm9keT4oKTtcclxuICAgICAgICAgICAgQm9keUxpc3QgPSBuZXcgTGlzdDxCb2R5PigzMik7XHJcbiAgICAgICAgICAgIEpvaW50TGlzdCA9IG5ldyBMaXN0PEpvaW50PigzMik7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwdWJsaWMgV29ybGQoVmVjdG9yMiBncmF2aXR5LCBBQUJCIHNwYW4pXHJcbiAgICAgICAgICAgIDogdGhpcygpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBHcmF2aXR5ID0gZ3Jhdml0eTtcclxuICAgICAgICAgICAgQ29udGFjdE1hbmFnZXIgPSBuZXcgQ29udGFjdE1hbmFnZXIobmV3IFF1YWRUcmVlQnJvYWRQaGFzZShzcGFuKSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIEluaXRpYWxpemVzIGEgbmV3IGluc3RhbmNlIG9mIHRoZSA8c2VlIGNyZWY9XCJXb3JsZFwiLz4gY2xhc3MuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJncmF2aXR5XCI+VGhlIGdyYXZpdHkuPC9wYXJhbT5cclxuICAgICAgICBwdWJsaWMgV29ybGQoVmVjdG9yMiBncmF2aXR5KVxyXG4gICAgICAgICAgICA6IHRoaXMoKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgQ29udGFjdE1hbmFnZXIgPSBuZXcgQ29udGFjdE1hbmFnZXIobmV3IER5bmFtaWNUcmVlQnJvYWRQaGFzZSgpKTtcclxuICAgICAgICAgICAgR3Jhdml0eSA9IGdyYXZpdHk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwdWJsaWMgTGlzdDxDb250cm9sbGVyPiBDb250cm9sbGVyTGlzdCB7IGdldDsgcHJpdmF0ZSBzZXQ7IH1cclxuXHJcbiAgICAgICAgcHVibGljIExpc3Q8QnJlYWthYmxlQm9keT4gQnJlYWthYmxlQm9keUxpc3QgeyBnZXQ7IHByaXZhdGUgc2V0OyB9XHJcblxyXG4gICAgICAgIHB1YmxpYyBmbG9hdCBVcGRhdGVUaW1lIHsgZ2V0OyBwcml2YXRlIHNldDsgfVxyXG5cclxuICAgICAgICBwdWJsaWMgZmxvYXQgQ29udGludW91c1BoeXNpY3NUaW1lIHsgZ2V0OyBwcml2YXRlIHNldDsgfVxyXG5cclxuICAgICAgICBwdWJsaWMgZmxvYXQgQ29udHJvbGxlcnNVcGRhdGVUaW1lIHsgZ2V0OyBwcml2YXRlIHNldDsgfVxyXG5cclxuICAgICAgICBwdWJsaWMgZmxvYXQgQWRkUmVtb3ZlVGltZSB7IGdldDsgcHJpdmF0ZSBzZXQ7IH1cclxuXHJcbiAgICAgICAgcHVibGljIGZsb2F0IENvbnRhY3RzVXBkYXRlVGltZSB7IGdldDsgcHJpdmF0ZSBzZXQ7IH1cclxuXHJcbiAgICAgICAgcHVibGljIGZsb2F0IFNvbHZlVXBkYXRlVGltZSB7IGdldDsgcHJpdmF0ZSBzZXQ7IH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBHZXQgdGhlIG51bWJlciBvZiBicm9hZC1waGFzZSBwcm94aWVzLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDx2YWx1ZT5UaGUgcHJveHkgY291bnQuPC92YWx1ZT5cclxuICAgICAgICBwdWJsaWMgaW50IFByb3h5Q291bnRcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGdldCB7IHJldHVybiBDb250YWN0TWFuYWdlci5Ccm9hZFBoYXNlLlByb3h5Q291bnQ7IH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gQ2hhbmdlIHRoZSBnbG9iYWwgZ3Jhdml0eSB2ZWN0b3IuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHZhbHVlPlRoZSBncmF2aXR5LjwvdmFsdWU+XHJcbiAgICAgICAgcHVibGljIFZlY3RvcjIgR3Jhdml0eTtcclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBTZXQgZmxhZyB0byBjb250cm9sIGF1dG9tYXRpYyBjbGVhcmluZyBvZiBmb3JjZXMgYWZ0ZXIgZWFjaCB0aW1lIHN0ZXAuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHZhbHVlPjxjPnRydWU8L2M+IGlmIGl0IHNob3VsZCBhdXRvIGNsZWFyIGZvcmNlczsgb3RoZXJ3aXNlLCA8Yz5mYWxzZTwvYz4uPC92YWx1ZT5cclxuICAgICAgICBwdWJsaWMgYm9vbCBBdXRvQ2xlYXJGb3JjZXNcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHNldFxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUpXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgRmxhZ3MgfD0gV29ybGRGbGFncy5DbGVhckZvcmNlcztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBGbGFncyAmPSB+V29ybGRGbGFncy5DbGVhckZvcmNlcztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBnZXQgeyByZXR1cm4gKEZsYWdzICYgV29ybGRGbGFncy5DbGVhckZvcmNlcykgPT0gV29ybGRGbGFncy5DbGVhckZvcmNlczsgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBHZXQgdGhlIGNvbnRhY3QgbWFuYWdlciBmb3IgdGVzdGluZy5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8dmFsdWU+VGhlIGNvbnRhY3QgbWFuYWdlci48L3ZhbHVlPlxyXG4gICAgICAgIHB1YmxpYyBDb250YWN0TWFuYWdlciBDb250YWN0TWFuYWdlciB7IGdldDsgcHJpdmF0ZSBzZXQ7IH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBHZXQgdGhlIHdvcmxkIGJvZHkgbGlzdC5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8dmFsdWU+VGhlaGVhZCBvZiB0aGUgd29ybGQgYm9keSBsaXN0LjwvdmFsdWU+XHJcbiAgICAgICAgcHVibGljIExpc3Q8Qm9keT4gQm9keUxpc3QgeyBnZXQ7IHByaXZhdGUgc2V0OyB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gR2V0IHRoZSB3b3JsZCBqb2ludCBsaXN0LiBcclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8dmFsdWU+VGhlIGpvaW50IGxpc3QuPC92YWx1ZT5cclxuICAgICAgICBwdWJsaWMgTGlzdDxKb2ludD4gSm9pbnRMaXN0IHsgZ2V0OyBwcml2YXRlIHNldDsgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIEdldCB0aGUgd29ybGQgY29udGFjdCBsaXN0LiBXaXRoIHRoZSByZXR1cm5lZCBjb250YWN0LCB1c2UgQ29udGFjdC5HZXROZXh0IHRvIGdldFxyXG4gICAgICAgIC8vLyB0aGUgbmV4dCBjb250YWN0IGluIHRoZSB3b3JsZCBsaXN0LiBBIG51bGwgY29udGFjdCBpbmRpY2F0ZXMgdGhlIGVuZCBvZiB0aGUgbGlzdC5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8dmFsdWU+VGhlIGhlYWQgb2YgdGhlIHdvcmxkIGNvbnRhY3QgbGlzdC48L3ZhbHVlPlxyXG4gICAgICAgIHB1YmxpYyBMaXN0PENvbnRhY3Q+IENvbnRhY3RMaXN0XHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBnZXQgeyByZXR1cm4gQ29udGFjdE1hbmFnZXIuQ29udGFjdExpc3Q7IH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gRW5hYmxlL2Rpc2FibGUgc2luZ2xlIHN0ZXBwZWQgY29udGludW91cyBwaHlzaWNzLiBGb3IgdGVzdGluZy5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIHB1YmxpYyBib29sIEVuYWJsZVN1YlN0ZXBwaW5nXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBzZXRcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIEZsYWdzIHw9IFdvcmxkRmxhZ3MuU3ViU3RlcHBpbmc7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgRmxhZ3MgJj0gfldvcmxkRmxhZ3MuU3ViU3RlcHBpbmc7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZ2V0IHsgcmV0dXJuIChGbGFncyAmIFdvcmxkRmxhZ3MuU3ViU3RlcHBpbmcpID09IFdvcmxkRmxhZ3MuU3ViU3RlcHBpbmc7IH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gQWRkIGEgcmlnaWQgYm9keS5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8cmV0dXJucz48L3JldHVybnM+XHJcbiAgICAgICAgaW50ZXJuYWwgdm9pZCBBZGRCb2R5KEJvZHkgYm9keSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIERlYnVnLkFzc2VydCghX2JvZHlBZGRMaXN0LkNvbnRhaW5zKGJvZHkpLCBcIllvdSBhcmUgYWRkaW5nIHRoZSBzYW1lIGJvZHkgbW9yZSB0aGFuIG9uY2UuXCIpO1xyXG5cclxuICAgICAgICAgICAgaWYgKCFfYm9keUFkZExpc3QuQ29udGFpbnMoYm9keSkpXHJcbiAgICAgICAgICAgICAgICBfYm9keUFkZExpc3QuQWRkKGJvZHkpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBEZXN0cm95IGEgcmlnaWQgYm9keS5cclxuICAgICAgICAvLy8gV2FybmluZzogVGhpcyBhdXRvbWF0aWNhbGx5IGRlbGV0ZXMgYWxsIGFzc29jaWF0ZWQgc2hhcGVzIGFuZCBqb2ludHMuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJib2R5XCI+VGhlIGJvZHkuPC9wYXJhbT5cclxuICAgICAgICBwdWJsaWMgdm9pZCBSZW1vdmVCb2R5KEJvZHkgYm9keSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIERlYnVnLkFzc2VydCghX2JvZHlSZW1vdmVMaXN0LkNvbnRhaW5zKGJvZHkpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgXCJUaGUgYm9keSBpcyBhbHJlYWR5IG1hcmtlZCBmb3IgcmVtb3ZhbC4gWW91IGFyZSByZW1vdmluZyB0aGUgYm9keSBtb3JlIHRoYW4gb25jZS5cIik7XHJcblxyXG4gICAgICAgICAgICBpZiAoIV9ib2R5UmVtb3ZlTGlzdC5Db250YWlucyhib2R5KSlcclxuICAgICAgICAgICAgICAgIF9ib2R5UmVtb3ZlTGlzdC5BZGQoYm9keSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIENyZWF0ZSBhIGpvaW50IHRvIGNvbnN0cmFpbiBib2RpZXMgdG9nZXRoZXIuIFRoaXMgbWF5IGNhdXNlIHRoZSBjb25uZWN0ZWQgYm9kaWVzIHRvIGNlYXNlIGNvbGxpZGluZy5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cImpvaW50XCI+VGhlIGpvaW50LjwvcGFyYW0+XHJcbiAgICAgICAgcHVibGljIHZvaWQgQWRkSm9pbnQoSm9pbnQgam9pbnQpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBEZWJ1Zy5Bc3NlcnQoIV9qb2ludEFkZExpc3QuQ29udGFpbnMoam9pbnQpLCBcIllvdSBhcmUgYWRkaW5nIHRoZSBzYW1lIGpvaW50IG1vcmUgdGhhbiBvbmNlLlwiKTtcclxuXHJcbiAgICAgICAgICAgIGlmICghX2pvaW50QWRkTGlzdC5Db250YWlucyhqb2ludCkpXHJcbiAgICAgICAgICAgICAgICBfam9pbnRBZGRMaXN0LkFkZChqb2ludCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwcml2YXRlIHZvaWQgUmVtb3ZlSm9pbnQoSm9pbnQgam9pbnQsIGJvb2wgZG9DaGVjaylcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGlmIChkb0NoZWNrKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBEZWJ1Zy5Bc3NlcnQoIV9qb2ludFJlbW92ZUxpc3QuQ29udGFpbnMoam9pbnQpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiVGhlIGpvaW50IGlzIGFscmVhZHkgbWFya2VkIGZvciByZW1vdmFsLiBZb3UgYXJlIHJlbW92aW5nIHRoZSBqb2ludCBtb3JlIHRoYW4gb25jZS5cIik7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmICghX2pvaW50UmVtb3ZlTGlzdC5Db250YWlucyhqb2ludCkpXHJcbiAgICAgICAgICAgICAgICBfam9pbnRSZW1vdmVMaXN0LkFkZChqb2ludCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIERlc3Ryb3kgYSBqb2ludC4gVGhpcyBtYXkgY2F1c2UgdGhlIGNvbm5lY3RlZCBib2RpZXMgdG8gYmVnaW4gY29sbGlkaW5nLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwiam9pbnRcIj5UaGUgam9pbnQuPC9wYXJhbT5cclxuICAgICAgICBwdWJsaWMgdm9pZCBSZW1vdmVKb2ludChKb2ludCBqb2ludClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIFJlbW92ZUpvaW50KGpvaW50LCB0cnVlKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gQWxsIGFkZHMgYW5kIHJlbW92ZXMgYXJlIGNhY2hlZCBieSB0aGUgV29ybGQgZHVpbmcgYSBXb3JsZCBzdGVwLlxyXG4gICAgICAgIC8vLyBUbyBwcm9jZXNzIHRoZSBjaGFuZ2VzIGJlZm9yZSB0aGUgd29ybGQgdXBkYXRlcyBhZ2FpbiwgY2FsbCB0aGlzIG1ldGhvZC5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIHB1YmxpYyB2b2lkIFByb2Nlc3NDaGFuZ2VzKClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIFByb2Nlc3NBZGRlZEJvZGllcygpO1xyXG4gICAgICAgICAgICBQcm9jZXNzQWRkZWRKb2ludHMoKTtcclxuXHJcbiAgICAgICAgICAgIFByb2Nlc3NSZW1vdmVkQm9kaWVzKCk7XHJcbiAgICAgICAgICAgIFByb2Nlc3NSZW1vdmVkSm9pbnRzKCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwcml2YXRlIHZvaWQgUHJvY2Vzc1JlbW92ZWRKb2ludHMoKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgaWYgKF9qb2ludFJlbW92ZUxpc3QuQ291bnQgPiAwKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBmb3JlYWNoIChKb2ludCBqb2ludCBpbiBfam9pbnRSZW1vdmVMaXN0KVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIGJvb2wgY29sbGlkZUNvbm5lY3RlZCA9IGpvaW50LkNvbGxpZGVDb25uZWN0ZWQ7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIFJlbW92ZSBmcm9tIHRoZSB3b3JsZCBsaXN0LlxyXG4gICAgICAgICAgICAgICAgICAgIEpvaW50TGlzdC5SZW1vdmUoam9pbnQpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBEaXNjb25uZWN0IGZyb20gaXNsYW5kIGdyYXBoLlxyXG4gICAgICAgICAgICAgICAgICAgIEJvZHkgYm9keUEgPSBqb2ludC5Cb2R5QTtcclxuICAgICAgICAgICAgICAgICAgICBCb2R5IGJvZHlCID0gam9pbnQuQm9keUI7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIFdha2UgdXAgY29ubmVjdGVkIGJvZGllcy5cclxuICAgICAgICAgICAgICAgICAgICBib2R5QS5Bd2FrZSA9IHRydWU7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIFdJUCBEYXZpZFxyXG4gICAgICAgICAgICAgICAgICAgIGlmICgham9pbnQuSXNGaXhlZFR5cGUoKSlcclxuICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJvZHlCLkF3YWtlID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIFJlbW92ZSBmcm9tIGJvZHkgMS5cclxuICAgICAgICAgICAgICAgICAgICBpZiAoam9pbnQuRWRnZUEuUHJldiAhPSBudWxsKVxyXG4gICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgam9pbnQuRWRnZUEuUHJldi5OZXh0ID0gam9pbnQuRWRnZUEuTmV4dDtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChqb2ludC5FZGdlQS5OZXh0ICE9IG51bGwpXHJcbiAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBqb2ludC5FZGdlQS5OZXh0LlByZXYgPSBqb2ludC5FZGdlQS5QcmV2O1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGpvaW50LkVkZ2VBID09IGJvZHlBLkpvaW50TGlzdClcclxuICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJvZHlBLkpvaW50TGlzdCA9IGpvaW50LkVkZ2VBLk5leHQ7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICBqb2ludC5FZGdlQS5QcmV2ID0gbnVsbDtcclxuICAgICAgICAgICAgICAgICAgICBqb2ludC5FZGdlQS5OZXh0ID0gbnVsbDtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gV0lQIERhdmlkXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFqb2ludC5Jc0ZpeGVkVHlwZSgpKVxyXG4gICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gUmVtb3ZlIGZyb20gYm9keSAyXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChqb2ludC5FZGdlQi5QcmV2ICE9IG51bGwpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGpvaW50LkVkZ2VCLlByZXYuTmV4dCA9IGpvaW50LkVkZ2VCLk5leHQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChqb2ludC5FZGdlQi5OZXh0ICE9IG51bGwpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGpvaW50LkVkZ2VCLk5leHQuUHJldiA9IGpvaW50LkVkZ2VCLlByZXY7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChqb2ludC5FZGdlQiA9PSBib2R5Qi5Kb2ludExpc3QpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJvZHlCLkpvaW50TGlzdCA9IGpvaW50LkVkZ2VCLk5leHQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGpvaW50LkVkZ2VCLlByZXYgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBqb2ludC5FZGdlQi5OZXh0ID0gbnVsbDtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIFdJUCBEYXZpZFxyXG4gICAgICAgICAgICAgICAgICAgIGlmICgham9pbnQuSXNGaXhlZFR5cGUoKSlcclxuICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIElmIHRoZSBqb2ludCBwcmV2ZW50cyBjb2xsaXNpb25zLCB0aGVuIGZsYWcgYW55IGNvbnRhY3RzIGZvciBmaWx0ZXJpbmcuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjb2xsaWRlQ29ubmVjdGVkID09IGZhbHNlKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBDb250YWN0RWRnZSBlZGdlID0gYm9keUIuQ29udGFjdExpc3Q7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAoZWRnZSAhPSBudWxsKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlZGdlLk90aGVyID09IGJvZHlBKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gRmxhZyB0aGUgY29udGFjdCBmb3IgZmlsdGVyaW5nIGF0IHRoZSBuZXh0IHRpbWUgc3RlcCAod2hlcmUgZWl0aGVyXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGJvZHkgaXMgYXdha2UpLlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlZGdlLkNvbnRhY3QuRmxhZ0ZvckZpbHRlcmluZygpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWRnZSA9IGVkZ2UuTmV4dDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKEpvaW50UmVtb3ZlZCAhPSBudWxsKVxyXG4gICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgSm9pbnRSZW1vdmVkKGpvaW50KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgX2pvaW50UmVtb3ZlTGlzdC5DbGVhcigpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwcml2YXRlIHZvaWQgUHJvY2Vzc0FkZGVkSm9pbnRzKClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGlmIChfam9pbnRBZGRMaXN0LkNvdW50ID4gMClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgZm9yZWFjaCAoSm9pbnQgam9pbnQgaW4gX2pvaW50QWRkTGlzdClcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBDb25uZWN0IHRvIHRoZSB3b3JsZCBsaXN0LlxyXG4gICAgICAgICAgICAgICAgICAgIEpvaW50TGlzdC5BZGQoam9pbnQpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBDb25uZWN0IHRvIHRoZSBib2RpZXMnIGRvdWJseSBsaW5rZWQgbGlzdHMuXHJcbiAgICAgICAgICAgICAgICAgICAgam9pbnQuRWRnZUEuSm9pbnQgPSBqb2ludDtcclxuICAgICAgICAgICAgICAgICAgICBqb2ludC5FZGdlQS5PdGhlciA9IGpvaW50LkJvZHlCO1xyXG4gICAgICAgICAgICAgICAgICAgIGpvaW50LkVkZ2VBLlByZXYgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgICAgIGpvaW50LkVkZ2VBLk5leHQgPSBqb2ludC5Cb2R5QS5Kb2ludExpc3Q7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChqb2ludC5Cb2R5QS5Kb2ludExpc3QgIT0gbnVsbClcclxuICAgICAgICAgICAgICAgICAgICAgICAgam9pbnQuQm9keUEuSm9pbnRMaXN0LlByZXYgPSBqb2ludC5FZGdlQTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgam9pbnQuQm9keUEuSm9pbnRMaXN0ID0gam9pbnQuRWRnZUE7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIFdJUCBEYXZpZFxyXG4gICAgICAgICAgICAgICAgICAgIGlmICgham9pbnQuSXNGaXhlZFR5cGUoKSlcclxuICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGpvaW50LkVkZ2VCLkpvaW50ID0gam9pbnQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGpvaW50LkVkZ2VCLk90aGVyID0gam9pbnQuQm9keUE7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGpvaW50LkVkZ2VCLlByZXYgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBqb2ludC5FZGdlQi5OZXh0ID0gam9pbnQuQm9keUIuSm9pbnRMaXN0O1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGpvaW50LkJvZHlCLkpvaW50TGlzdCAhPSBudWxsKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgam9pbnQuQm9keUIuSm9pbnRMaXN0LlByZXYgPSBqb2ludC5FZGdlQjtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGpvaW50LkJvZHlCLkpvaW50TGlzdCA9IGpvaW50LkVkZ2VCO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgQm9keSBib2R5QSA9IGpvaW50LkJvZHlBO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBCb2R5IGJvZHlCID0gam9pbnQuQm9keUI7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBJZiB0aGUgam9pbnQgcHJldmVudHMgY29sbGlzaW9ucywgdGhlbiBmbGFnIGFueSBjb250YWN0cyBmb3IgZmlsdGVyaW5nLlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoam9pbnQuQ29sbGlkZUNvbm5lY3RlZCA9PSBmYWxzZSlcclxuICAgICAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgQ29udGFjdEVkZ2UgZWRnZSA9IGJvZHlCLkNvbnRhY3RMaXN0O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKGVkZ2UgIT0gbnVsbClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZWRnZS5PdGhlciA9PSBib2R5QSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEZsYWcgdGhlIGNvbnRhY3QgZm9yIGZpbHRlcmluZyBhdCB0aGUgbmV4dCB0aW1lIHN0ZXAgKHdoZXJlIGVpdGhlclxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBib2R5IGlzIGF3YWtlKS5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWRnZS5Db250YWN0LkZsYWdGb3JGaWx0ZXJpbmcoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVkZ2UgPSBlZGdlLk5leHQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChKb2ludEFkZGVkICE9IG51bGwpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIEpvaW50QWRkZWQoam9pbnQpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBOb3RlOiBjcmVhdGluZyBhIGpvaW50IGRvZXNuJ3Qgd2FrZSB0aGUgYm9kaWVzLlxyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIF9qb2ludEFkZExpc3QuQ2xlYXIoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHJpdmF0ZSB2b2lkIFByb2Nlc3NBZGRlZEJvZGllcygpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBpZiAoX2JvZHlBZGRMaXN0LkNvdW50ID4gMClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgZm9yZWFjaCAoQm9keSBib2R5IGluIF9ib2R5QWRkTGlzdClcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBBZGQgdG8gd29ybGQgbGlzdC5cclxuICAgICAgICAgICAgICAgICAgICBCb2R5TGlzdC5BZGQoYm9keSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChCb2R5QWRkZWQgIT0gbnVsbClcclxuICAgICAgICAgICAgICAgICAgICAgICAgQm9keUFkZGVkKGJvZHkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIF9ib2R5QWRkTGlzdC5DbGVhcigpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwcml2YXRlIHZvaWQgUHJvY2Vzc1JlbW92ZWRCb2RpZXMoKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgaWYgKF9ib2R5UmVtb3ZlTGlzdC5Db3VudCA+IDApXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGZvcmVhY2ggKEJvZHkgYm9keSBpbiBfYm9keVJlbW92ZUxpc3QpXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgRGVidWcuQXNzZXJ0KEJvZHlMaXN0LkNvdW50ID4gMCk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIFlvdSB0cmllZCB0byByZW1vdmUgYSBib2R5IHRoYXQgaXMgbm90IGNvbnRhaW5lZCBpbiB0aGUgQm9keUxpc3QuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gQXJlIHlvdSByZW1vdmluZyB0aGUgYm9keSBtb3JlIHRoYW4gb25jZT9cclxuICAgICAgICAgICAgICAgICAgICBEZWJ1Zy5Bc3NlcnQoQm9keUxpc3QuQ29udGFpbnMoYm9keSkpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBEZWxldGUgdGhlIGF0dGFjaGVkIGpvaW50cy5cclxuICAgICAgICAgICAgICAgICAgICBKb2ludEVkZ2UgamUgPSBib2R5LkpvaW50TGlzdDtcclxuICAgICAgICAgICAgICAgICAgICB3aGlsZSAoamUgIT0gbnVsbClcclxuICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIEpvaW50RWRnZSBqZTAgPSBqZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgamUgPSBqZS5OZXh0O1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgUmVtb3ZlSm9pbnQoamUwLkpvaW50LCBmYWxzZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGJvZHkuSm9pbnRMaXN0ID0gbnVsbDtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gRGVsZXRlIHRoZSBhdHRhY2hlZCBjb250YWN0cy5cclxuICAgICAgICAgICAgICAgICAgICBDb250YWN0RWRnZSBjZSA9IGJvZHkuQ29udGFjdExpc3Q7XHJcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKGNlICE9IG51bGwpXHJcbiAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBDb250YWN0RWRnZSBjZTAgPSBjZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2UgPSBjZS5OZXh0O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBDb250YWN0TWFuYWdlci5EZXN0cm95KGNlMC5Db250YWN0KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgYm9keS5Db250YWN0TGlzdCA9IG51bGw7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIERlbGV0ZSB0aGUgYXR0YWNoZWQgZml4dHVyZXMuIFRoaXMgZGVzdHJveXMgYnJvYWQtcGhhc2UgcHJveGllcy5cclxuICAgICAgICAgICAgICAgICAgICBmb3IgKGludCBpID0gMDsgaSA8IGJvZHkuRml4dHVyZUxpc3QuQ291bnQ7IGkrKylcclxuICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJvZHkuRml4dHVyZUxpc3RbaV0uRGVzdHJveVByb3hpZXMoQ29udGFjdE1hbmFnZXIuQnJvYWRQaGFzZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJvZHkuRml4dHVyZUxpc3RbaV0uRGVzdHJveSgpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgYm9keS5GaXh0dXJlTGlzdCA9IG51bGw7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIFJlbW92ZSB3b3JsZCBib2R5IGxpc3QuXHJcbiAgICAgICAgICAgICAgICAgICAgQm9keUxpc3QuUmVtb3ZlKGJvZHkpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZiAoQm9keVJlbW92ZWQgIT0gbnVsbClcclxuICAgICAgICAgICAgICAgICAgICAgICAgQm9keVJlbW92ZWQoYm9keSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgX2JvZHlSZW1vdmVMaXN0LkNsZWFyKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gVGFrZSBhIHRpbWUgc3RlcC4gVGhpcyBwZXJmb3JtcyBjb2xsaXNpb24gZGV0ZWN0aW9uLCBpbnRlZ3JhdGlvbixcclxuICAgICAgICAvLy8gYW5kIGNvbnNyYWludCBzb2x1dGlvbi5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cImR0XCI+VGhlIGFtb3VudCBvZiB0aW1lIHRvIHNpbXVsYXRlLCB0aGlzIHNob3VsZCBub3QgdmFyeS48L3BhcmFtPlxyXG4gICAgICAgIHB1YmxpYyB2b2lkIFN0ZXAoZmxvYXQgZHQpXHJcbiAgICAgICAge1xyXG5cclxuICAgICAgICAgICAgUHJvY2Vzc0NoYW5nZXMoKTtcclxuXHJcbiAgICAgICAgICAgIC8vSWYgdGhlcmUgaXMgbm8gY2hhbmdlIGluIHRpbWUsIG5vIG5lZWQgdG8gY2FsY3VsYXRlIGFueXRoaW5nLlxyXG4gICAgICAgICAgICBpZiAoZHQgPT0gMCB8fCAhRW5hYmxlZClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBJZiBuZXcgZml4dHVyZXMgd2VyZSBhZGRlZCwgd2UgbmVlZCB0byBmaW5kIHRoZSBuZXcgY29udGFjdHMuXHJcbiAgICAgICAgICAgIGlmICgoRmxhZ3MgJiBXb3JsZEZsYWdzLk5ld0ZpeHR1cmUpID09IFdvcmxkRmxhZ3MuTmV3Rml4dHVyZSlcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgQ29udGFjdE1hbmFnZXIuRmluZE5ld0NvbnRhY3RzKCk7XHJcbiAgICAgICAgICAgICAgICBGbGFncyAmPSB+V29ybGRGbGFncy5OZXdGaXh0dXJlO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBUaW1lU3RlcCBzdGVwO1xyXG4gICAgICAgICAgICBzdGVwLmludl9kdCA9IDEuMGYgLyBkdDtcclxuICAgICAgICAgICAgc3RlcC5kdCA9IGR0O1xyXG4gICAgICAgICAgICBzdGVwLmR0UmF0aW8gPSBfaW52RHQwICogZHQ7XHJcblxyXG4gICAgICAgICAgICAvL1VwZGF0ZSBjb250cm9sbGVyc1xyXG4gICAgICAgICAgICBmb3IgKGludCBpID0gMDsgaSA8IENvbnRyb2xsZXJMaXN0LkNvdW50OyBpKyspXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIENvbnRyb2xsZXJMaXN0W2ldLlVwZGF0ZShkdCk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcblxyXG4gICAgICAgICAgICAvLyBVcGRhdGUgY29udGFjdHMuIFRoaXMgaXMgd2hlcmUgc29tZSBjb250YWN0cyBhcmUgZGVzdHJveWVkLlxyXG4gICAgICAgICAgICBDb250YWN0TWFuYWdlci5Db2xsaWRlKCk7XHJcblxyXG4gICAgICAgICAgICAvLyBJbnRlZ3JhdGUgdmVsb2NpdGllcywgc29sdmUgdmVsb2NpdHkgcmFpbnRzLCBhbmQgaW50ZWdyYXRlIHBvc2l0aW9ucy5cclxuICAgICAgICAgICAgU29sdmUocmVmIHN0ZXApO1xyXG5cclxuXHJcbiAgICAgICAgICAgIC8vIEhhbmRsZSBUT0kgZXZlbnRzLlxyXG4gICAgICAgICAgICBpZiAoU2V0dGluZ3MuQ29udGludW91c1BoeXNpY3MpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIFNvbHZlVE9JKHJlZiBzdGVwKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgX2ludkR0MCA9IHN0ZXAuaW52X2R0O1xyXG5cclxuICAgICAgICAgICAgaWYgKChGbGFncyAmIFdvcmxkRmxhZ3MuQ2xlYXJGb3JjZXMpICE9IDApXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIENsZWFyRm9yY2VzKCk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGZvciAoaW50IGkgPSAwOyBpIDwgQnJlYWthYmxlQm9keUxpc3QuQ291bnQ7IGkrKylcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgQnJlYWthYmxlQm9keUxpc3RbaV0uVXBkYXRlKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gQ2FsbCB0aGlzIGFmdGVyIHlvdSBhcmUgZG9uZSB3aXRoIHRpbWUgc3RlcHMgdG8gY2xlYXIgdGhlIGZvcmNlcy4gWW91IG5vcm1hbGx5XHJcbiAgICAgICAgLy8vIGNhbGwgdGhpcyBhZnRlciBlYWNoIGNhbGwgdG8gU3RlcCwgdW5sZXNzIHlvdSBhcmUgcGVyZm9ybWluZyBzdWItc3RlcHMuIEJ5IGRlZmF1bHQsXHJcbiAgICAgICAgLy8vIGZvcmNlcyB3aWxsIGJlIGF1dG9tYXRpY2FsbHkgY2xlYXJlZCwgc28geW91IGRvbid0IG5lZWQgdG8gY2FsbCB0aGlzIGZ1bmN0aW9uLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgcHVibGljIHZvaWQgQ2xlYXJGb3JjZXMoKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgZm9yIChpbnQgaSA9IDA7IGkgPCBCb2R5TGlzdC5Db3VudDsgaSsrKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBCb2R5IGJvZHkgPSBCb2R5TGlzdFtpXTtcclxuICAgICAgICAgICAgICAgIGJvZHkuRm9yY2UgPSBWZWN0b3IyLlplcm87XHJcbiAgICAgICAgICAgICAgICBib2R5LlRvcnF1ZSA9IDAuMGY7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gUXVlcnkgdGhlIHdvcmxkIGZvciBhbGwgZml4dHVyZXMgdGhhdCBwb3RlbnRpYWxseSBvdmVybGFwIHRoZVxyXG4gICAgICAgIC8vLyBwcm92aWRlZCBBQUJCLlxyXG4gICAgICAgIC8vLyBcclxuICAgICAgICAvLy8gSW5zaWRlIHRoZSBjYWxsYmFjazpcclxuICAgICAgICAvLy8gUmV0dXJuIHRydWU6IENvbnRpbnVlcyB0aGUgcXVlcnlcclxuICAgICAgICAvLy8gUmV0dXJuIGZhbHNlOiBUZXJtaW5hdGUgdGhlIHF1ZXJ5XHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJjYWxsYmFja1wiPkEgdXNlciBpbXBsZW1lbnRlZCBjYWxsYmFjayBjbGFzcy48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cImFhYmJcIj5UaGUgYWFiYiBxdWVyeSBib3guPC9wYXJhbT5cclxuICAgICAgICBwdWJsaWMgdm9pZCBRdWVyeUFBQkIoRnVuYzxGaXh0dXJlLCBib29sPiBjYWxsYmFjaywgcmVmIEFBQkIgYWFiYilcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIENvbnRhY3RNYW5hZ2VyLkJyb2FkUGhhc2UuUXVlcnkoKGdsb2JhbDo6U3lzdGVtLkZ1bmM8aW50LCBib29sPikocHJveHlJZCA9PlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBGaXh0dXJlUHJveHkgcHJveHkgPSBDb250YWN0TWFuYWdlci5Ccm9hZFBoYXNlLkdldFByb3h5KHByb3h5SWQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKHByb3h5LkZpeHR1cmUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KSwgcmVmIGFhYmIpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBSYXktY2FzdCB0aGUgd29ybGQgZm9yIGFsbCBmaXh0dXJlcyBpbiB0aGUgcGF0aCBvZiB0aGUgcmF5LiBZb3VyIGNhbGxiYWNrXHJcbiAgICAgICAgLy8vIGNvbnRyb2xzIHdoZXRoZXIgeW91IGdldCB0aGUgY2xvc2VzdCBwb2ludCwgYW55IHBvaW50LCBvciBuLXBvaW50cy5cclxuICAgICAgICAvLy8gVGhlIHJheS1jYXN0IGlnbm9yZXMgc2hhcGVzIHRoYXQgY29udGFpbiB0aGUgc3RhcnRpbmcgcG9pbnQuXHJcbiAgICAgICAgLy8vIFxyXG4gICAgICAgIC8vLyBJbnNpZGUgdGhlIGNhbGxiYWNrOlxyXG4gICAgICAgIC8vLyByZXR1cm4gLTE6IGlnbm9yZSB0aGlzIGZpeHR1cmUgYW5kIGNvbnRpbnVlXHJcbiAgICAgICAgLy8vIHJldHVybiAwOiB0ZXJtaW5hdGUgdGhlIHJheSBjYXN0XHJcbiAgICAgICAgLy8vIHJldHVybiBmcmFjdGlvbjogY2xpcCB0aGUgcmF5IHRvIHRoaXMgcG9pbnRcclxuICAgICAgICAvLy8gcmV0dXJuIDE6IGRvbid0IGNsaXAgdGhlIHJheSBhbmQgY29udGludWVcclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cImNhbGxiYWNrXCI+QSB1c2VyIGltcGxlbWVudGVkIGNhbGxiYWNrIGNsYXNzLjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwicG9pbnQxXCI+VGhlIHJheSBzdGFydGluZyBwb2ludC48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cInBvaW50MlwiPlRoZSByYXkgZW5kaW5nIHBvaW50LjwvcGFyYW0+XHJcbiAgICAgICAgcHVibGljIHZvaWQgUmF5Q2FzdChSYXlDYXN0Q2FsbGJhY2sgY2FsbGJhY2ssIFZlY3RvcjIgcG9pbnQxLCBWZWN0b3IyIHBvaW50MilcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIFJheUNhc3RJbnB1dCBpbnB1dCA9IG5ldyBSYXlDYXN0SW5wdXQoKTtcclxuICAgICAgICAgICAgaW5wdXQuTWF4RnJhY3Rpb24gPSAxLjBmO1xyXG4gICAgICAgICAgICBpbnB1dC5Qb2ludDEgPSBwb2ludDE7XHJcbiAgICAgICAgICAgIGlucHV0LlBvaW50MiA9IHBvaW50MjtcclxuXHJcbiAgICAgICAgICAgIENvbnRhY3RNYW5hZ2VyLkJyb2FkUGhhc2UuUmF5Q2FzdCgoZ2xvYmFsOjpTeXN0ZW0uRnVuYzxnbG9iYWw6OkZhcnNlZXJQaHlzaWNzLkNvbGxpc2lvbi5SYXlDYXN0SW5wdXQsIGludCwgZmxvYXQ+KSgocmF5Q2FzdElucHV0LCBwcm94eUlkKSA9PlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgRml4dHVyZVByb3h5IHByb3h5ID0gQ29udGFjdE1hbmFnZXIuQnJvYWRQaGFzZS5HZXRQcm94eShwcm94eUlkKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgRml4dHVyZSBmaXh0dXJlID0gcHJveHkuRml4dHVyZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW50IGluZGV4ID0gcHJveHkuQ2hpbGRJbmRleDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgUmF5Q2FzdE91dHB1dCBvdXRwdXQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJvb2wgaGl0ID0gZml4dHVyZS5SYXlDYXN0KG91dCBvdXRwdXQsIHJlZiByYXlDYXN0SW5wdXQsIGluZGV4KTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChoaXQpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZsb2F0IGZyYWN0aW9uID0gb3V0cHV0LkZyYWN0aW9uO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgVmVjdG9yMiBwb2ludCA9ICgxLjBmIC0gZnJhY3Rpb24pICogaW5wdXQuUG9pbnQxICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmcmFjdGlvbiAqIGlucHV0LlBvaW50MjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhmaXh0dXJlLCBwb2ludCwgb3V0cHV0Lk5vcm1hbCwgZnJhY3Rpb24pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gaW5wdXQuTWF4RnJhY3Rpb247XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSksIHJlZiBpbnB1dCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwcml2YXRlIHZvaWQgU29sdmUocmVmIFRpbWVTdGVwIHN0ZXApXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICAvLyBTaXplIHRoZSBpc2xhbmQgZm9yIHRoZSB3b3JzdCBjYXNlLlxyXG4gICAgICAgICAgICBJc2xhbmQuUmVzZXQoQm9keUxpc3QuQ291bnQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICBDb250YWN0TWFuYWdlci5Db250YWN0TGlzdC5Db3VudCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgIEpvaW50TGlzdC5Db3VudCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgIENvbnRhY3RNYW5hZ2VyKTtcclxuXHJcbiAgICAgICAgICAgIC8vIENsZWFyIGFsbCB0aGUgaXNsYW5kIGZsYWdzLlxyXG4gICAgICAgICAgICBmb3JlYWNoIChCb2R5IGIgaW4gQm9keUxpc3QpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGIuRmxhZ3MgJj0gfkJvZHlGbGFncy5Jc2xhbmQ7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGZvciAoaW50IGkgPSAwOyBpIDwgQ29udGFjdE1hbmFnZXIuQ29udGFjdExpc3QuQ291bnQ7IGkrKylcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgQ29udGFjdCBjID0gQ29udGFjdE1hbmFnZXIuQ29udGFjdExpc3RbaV07XHJcbiAgICAgICAgICAgICAgICBjLkZsYWdzICY9IH5Db250YWN0RmxhZ3MuSXNsYW5kO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGZvcmVhY2ggKEpvaW50IGogaW4gSm9pbnRMaXN0KVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBqLklzbGFuZEZsYWcgPSBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gQnVpbGQgYW5kIHNpbXVsYXRlIGFsbCBhd2FrZSBpc2xhbmRzLlxyXG4gICAgICAgICAgICBpbnQgc3RhY2tTaXplID0gQm9keUxpc3QuQ291bnQ7XHJcbiAgICAgICAgICAgIGlmIChzdGFja1NpemUgPiBfc3RhY2suTGVuZ3RoKVxyXG4gICAgICAgICAgICAgICAgX3N0YWNrID0gbmV3IEJvZHlbTWF0aC5NYXgoX3N0YWNrLkxlbmd0aCAqIDIsIHN0YWNrU2l6ZSldO1xyXG5cclxuICAgICAgICAgICAgZm9yIChpbnQgaW5kZXggPSBCb2R5TGlzdC5Db3VudCAtIDE7IGluZGV4ID49IDA7IGluZGV4LS0pXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIEJvZHkgc2VlZCA9IEJvZHlMaXN0W2luZGV4XTtcclxuICAgICAgICAgICAgICAgIGlmICgoc2VlZC5GbGFncyAmIChCb2R5RmxhZ3MuSXNsYW5kKSkgIT0gQm9keUZsYWdzLk5vbmUpXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKHNlZWQuQXdha2UgPT0gZmFsc2UgfHwgc2VlZC5FbmFibGVkID09IGZhbHNlKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIC8vIFRoZSBzZWVkIGNhbiBiZSBkeW5hbWljIG9yIGtpbmVtYXRpYy5cclxuICAgICAgICAgICAgICAgIGlmIChzZWVkLkJvZHlUeXBlID09IEJvZHlUeXBlLlN0YXRpYylcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAvLyBSZXNldCBpc2xhbmQgYW5kIHN0YWNrLlxyXG4gICAgICAgICAgICAgICAgSXNsYW5kLkNsZWFyKCk7XHJcbiAgICAgICAgICAgICAgICBpbnQgc3RhY2tDb3VudCA9IDA7XHJcbiAgICAgICAgICAgICAgICBfc3RhY2tbc3RhY2tDb3VudCsrXSA9IHNlZWQ7XHJcbiAgICAgICAgICAgICAgICBzZWVkLkZsYWdzIHw9IEJvZHlGbGFncy5Jc2xhbmQ7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gUGVyZm9ybSBhIGRlcHRoIGZpcnN0IHNlYXJjaCAoREZTKSBvbiB0aGUgY29uc3RyYWludCBncmFwaC5cclxuICAgICAgICAgICAgICAgIHdoaWxlIChzdGFja0NvdW50ID4gMClcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBHcmFiIHRoZSBuZXh0IGJvZHkgb2ZmIHRoZSBzdGFjayBhbmQgYWRkIGl0IHRvIHRoZSBpc2xhbmQuXHJcbiAgICAgICAgICAgICAgICAgICAgQm9keSBiID0gX3N0YWNrWy0tc3RhY2tDb3VudF07XHJcbiAgICAgICAgICAgICAgICAgICAgRGVidWcuQXNzZXJ0KGIuRW5hYmxlZCk7XHJcbiAgICAgICAgICAgICAgICAgICAgSXNsYW5kLkFkZChiKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gTWFrZSBzdXJlIHRoZSBib2R5IGlzIGF3YWtlLlxyXG4gICAgICAgICAgICAgICAgICAgIGIuQXdha2UgPSB0cnVlO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBUbyBrZWVwIGlzbGFuZHMgYXMgc21hbGwgYXMgcG9zc2libGUsIHdlIGRvbid0XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gcHJvcGFnYXRlIGlzbGFuZHMgYWNyb3NzIHN0YXRpYyBib2RpZXMuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGIuQm9keVR5cGUgPT0gQm9keVR5cGUuU3RhdGljKVxyXG4gICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBTZWFyY2ggYWxsIGNvbnRhY3RzIGNvbm5lY3RlZCB0byB0aGlzIGJvZHkuXHJcbiAgICAgICAgICAgICAgICAgICAgZm9yIChDb250YWN0RWRnZSBjZSA9IGIuQ29udGFjdExpc3Q7IGNlICE9IG51bGw7IGNlID0gY2UuTmV4dClcclxuICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIENvbnRhY3QgY29udGFjdCA9IGNlLkNvbnRhY3Q7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBIYXMgdGhpcyBjb250YWN0IGFscmVhZHkgYmVlbiBhZGRlZCB0byBhbiBpc2xhbmQ/XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgoY29udGFjdC5GbGFncyAmIENvbnRhY3RGbGFncy5Jc2xhbmQpICE9IENvbnRhY3RGbGFncy5Ob25lKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSXMgdGhpcyBjb250YWN0IHNvbGlkIGFuZCB0b3VjaGluZz9cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFjZS5Db250YWN0LkVuYWJsZWQgfHwgIWNlLkNvbnRhY3QuSXNUb3VjaGluZygpKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gU2tpcCBzZW5zb3JzLlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBib29sIHNlbnNvckEgPSBjb250YWN0LkZpeHR1cmVBLklzU2Vuc29yO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBib29sIHNlbnNvckIgPSBjb250YWN0LkZpeHR1cmVCLklzU2Vuc29yO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2Vuc29yQSB8fCBzZW5zb3JCKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgSXNsYW5kLkFkZChjb250YWN0KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGFjdC5GbGFncyB8PSBDb250YWN0RmxhZ3MuSXNsYW5kO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgQm9keSBvdGhlciA9IGNlLk90aGVyO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gV2FzIHRoZSBvdGhlciBib2R5IGFscmVhZHkgYWRkZWQgdG8gdGhpcyBpc2xhbmQ/XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgob3RoZXIuRmxhZ3MgJiBCb2R5RmxhZ3MuSXNsYW5kKSAhPSBCb2R5RmxhZ3MuTm9uZSlcclxuICAgICAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIERlYnVnLkFzc2VydChzdGFja0NvdW50IDwgc3RhY2tTaXplKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgX3N0YWNrW3N0YWNrQ291bnQrK10gPSBvdGhlcjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgb3RoZXIuRmxhZ3MgfD0gQm9keUZsYWdzLklzbGFuZDtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIFNlYXJjaCBhbGwgam9pbnRzIGNvbm5lY3QgdG8gdGhpcyBib2R5LlxyXG4gICAgICAgICAgICAgICAgICAgIGZvciAoSm9pbnRFZGdlIGplID0gYi5Kb2ludExpc3Q7IGplICE9IG51bGw7IGplID0gamUuTmV4dClcclxuICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChqZS5Kb2ludC5Jc2xhbmRGbGFnKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgQm9keSBvdGhlciA9IGplLk90aGVyO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gV0lQIERhdmlkXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vRW50ZXIgaGVyZSB3aGVuIGl0J3MgYSBub24tZml4ZWQgam9pbnQuIE5vbi1maXhlZCBqb2ludHMgaGF2ZSBhIG90aGVyIGJvZHkuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvdGhlciAhPSBudWxsKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBEb24ndCBzaW11bGF0ZSBqb2ludHMgY29ubmVjdGVkIHRvIGluYWN0aXZlIGJvZGllcy5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvdGhlci5FbmFibGVkID09IGZhbHNlKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIElzbGFuZC5BZGQoamUuSm9pbnQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgamUuSm9pbnQuSXNsYW5kRmxhZyA9IHRydWU7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKChvdGhlci5GbGFncyAmIEJvZHlGbGFncy5Jc2xhbmQpICE9IEJvZHlGbGFncy5Ob25lKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIERlYnVnLkFzc2VydChzdGFja0NvdW50IDwgc3RhY2tTaXplKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9zdGFja1tzdGFja0NvdW50KytdID0gb3RoZXI7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdGhlci5GbGFncyB8PSBCb2R5RmxhZ3MuSXNsYW5kO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgSXNsYW5kLkFkZChqZS5Kb2ludCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBqZS5Kb2ludC5Jc2xhbmRGbGFnID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBJc2xhbmQuU29sdmUocmVmIHN0ZXAsIHJlZiBHcmF2aXR5KTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBQb3N0IHNvbHZlIGNsZWFudXAuXHJcbiAgICAgICAgICAgICAgICBmb3IgKGludCBpID0gMDsgaSA8IElzbGFuZC5Cb2R5Q291bnQ7ICsraSlcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBBbGxvdyBzdGF0aWMgYm9kaWVzIHRvIHBhcnRpY2lwYXRlIGluIG90aGVyIGlzbGFuZHMuXHJcbiAgICAgICAgICAgICAgICAgICAgQm9keSBiID0gSXNsYW5kLkJvZGllc1tpXTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoYi5Cb2R5VHlwZSA9PSBCb2R5VHlwZS5TdGF0aWMpXHJcbiAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBiLkZsYWdzICY9IH5Cb2R5RmxhZ3MuSXNsYW5kO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gU3luY2hyb25pemUgZml4dHVyZXMsIGNoZWNrIGZvciBvdXQgb2YgcmFuZ2UgYm9kaWVzLlxyXG4gICAgICAgICAgICBmb3JlYWNoIChCb2R5IGIgaW4gQm9keUxpc3QpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIC8vIElmIGEgYm9keSB3YXMgbm90IGluIGFuIGlzbGFuZCB0aGVuIGl0IGRpZCBub3QgbW92ZS5cclxuICAgICAgICAgICAgICAgIGlmICgoYi5GbGFncyAmIEJvZHlGbGFncy5Jc2xhbmQpICE9IEJvZHlGbGFncy5Jc2xhbmQpXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKGIuQm9keVR5cGUgPT0gQm9keVR5cGUuU3RhdGljKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIC8vIFVwZGF0ZSBmaXh0dXJlcyAoZm9yIGJyb2FkLXBoYXNlKS5cclxuICAgICAgICAgICAgICAgIGIuU3luY2hyb25pemVGaXh0dXJlcygpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBMb29rIGZvciBuZXcgY29udGFjdHMuXHJcbiAgICAgICAgICAgIENvbnRhY3RNYW5hZ2VyLkZpbmROZXdDb250YWN0cygpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBGaW5kIFRPSSBjb250YWN0cyBhbmQgc29sdmUgdGhlbS5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cInN0ZXBcIj5UaGUgc3RlcC48L3BhcmFtPlxyXG4gICAgICAgIHByaXZhdGUgdm9pZCBTb2x2ZVRPSShyZWYgVGltZVN0ZXAgc3RlcClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIElzbGFuZC5SZXNldCgyICogU2V0dGluZ3MuTWF4VE9JQ29udGFjdHMsIFNldHRpbmdzLk1heFRPSUNvbnRhY3RzLCAwLCBDb250YWN0TWFuYWdlcik7XHJcblxyXG4gICAgICAgICAgICBpZiAoX3N0ZXBDb21wbGV0ZSlcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgZm9yIChpbnQgaSA9IDA7IGkgPCBCb2R5TGlzdC5Db3VudDsgaSsrKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIEJvZHlMaXN0W2ldLkZsYWdzICY9IH5Cb2R5RmxhZ3MuSXNsYW5kO1xyXG4gICAgICAgICAgICAgICAgICAgIEJvZHlMaXN0W2ldLlN3ZWVwLkFscGhhMCA9IDAuMGY7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgZm9yIChpbnQgaSA9IDA7IGkgPCBDb250YWN0TWFuYWdlci5Db250YWN0TGlzdC5Db3VudDsgaSsrKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIENvbnRhY3QgYyA9IENvbnRhY3RNYW5hZ2VyLkNvbnRhY3RMaXN0W2ldO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBJbnZhbGlkYXRlIFRPSVxyXG4gICAgICAgICAgICAgICAgICAgIGMuRmxhZ3MgJj0gfihDb250YWN0RmxhZ3MuVE9JIHwgQ29udGFjdEZsYWdzLklzbGFuZCk7XHJcbiAgICAgICAgICAgICAgICAgICAgYy5UT0lDb3VudCA9IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgYy5UT0kgPSAxLjBmO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBGaW5kIFRPSSBldmVudHMgYW5kIHNvbHZlIHRoZW0uXHJcbiAgICAgICAgICAgIGZvciAoOyA7IClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgLy8gRmluZCB0aGUgZmlyc3QgVE9JLlxyXG4gICAgICAgICAgICAgICAgQ29udGFjdCBtaW5Db250YWN0ID0gbnVsbDtcclxuICAgICAgICAgICAgICAgIGZsb2F0IG1pbkFscGhhID0gMS4wZjtcclxuXHJcbiAgICAgICAgICAgICAgICBmb3IgKGludCBpID0gMDsgaSA8IENvbnRhY3RNYW5hZ2VyLkNvbnRhY3RMaXN0LkNvdW50OyBpKyspXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgQ29udGFjdCBjID0gQ29udGFjdE1hbmFnZXIuQ29udGFjdExpc3RbaV07XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIElzIHRoaXMgY29udGFjdCBkaXNhYmxlZD9cclxuICAgICAgICAgICAgICAgICAgICBpZiAoYy5FbmFibGVkID09IGZhbHNlKVxyXG4gICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBQcmV2ZW50IGV4Y2Vzc2l2ZSBzdWItc3RlcHBpbmcuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGMuVE9JQ291bnQgPiBTZXR0aW5ncy5NYXhTdWJTdGVwcylcclxuICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgZmxvYXQgYWxwaGE7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKChjLkZsYWdzICYgQ29udGFjdEZsYWdzLlRPSSkgPT0gQ29udGFjdEZsYWdzLlRPSSlcclxuICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoaXMgY29udGFjdCBoYXMgYSB2YWxpZCBjYWNoZWQgVE9JLlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBhbHBoYSA9IGMuVE9JO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBGaXh0dXJlIGZBID0gYy5GaXh0dXJlQTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgRml4dHVyZSBmQiA9IGMuRml4dHVyZUI7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBJcyB0aGVyZSBhIHNlbnNvcj9cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGZBLklzU2Vuc29yIHx8IGZCLklzU2Vuc29yKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgQm9keSBiQSA9IGZBLkJvZHk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIEJvZHkgYkIgPSBmQi5Cb2R5O1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgQm9keVR5cGUgdHlwZUEgPSBiQS5Cb2R5VHlwZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgQm9keVR5cGUgdHlwZUIgPSBiQi5Cb2R5VHlwZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgRGVidWcuQXNzZXJ0KHR5cGVBID09IEJvZHlUeXBlLkR5bmFtaWMgfHwgdHlwZUIgPT0gQm9keVR5cGUuRHluYW1pYyk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBib29sIGF3YWtlQSA9IGJBLkF3YWtlICYmIHR5cGVBICE9IEJvZHlUeXBlLlN0YXRpYztcclxuICAgICAgICAgICAgICAgICAgICAgICAgYm9vbCBhd2FrZUIgPSBiQi5Bd2FrZSAmJiB0eXBlQiAhPSBCb2R5VHlwZS5TdGF0aWM7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBJcyBhdCBsZWFzdCBvbmUgYm9keSBhd2FrZT9cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGF3YWtlQSA9PSBmYWxzZSAmJiBhd2FrZUIgPT0gZmFsc2UpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBib29sIGNvbGxpZGVBID0gKGJBLklzQnVsbGV0IHx8IHR5cGVBICE9IEJvZHlUeXBlLkR5bmFtaWMpICYmICFiQS5JZ25vcmVDQ0Q7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJvb2wgY29sbGlkZUIgPSAoYkIuSXNCdWxsZXQgfHwgdHlwZUIgIT0gQm9keVR5cGUuRHluYW1pYykgJiYgIWJCLklnbm9yZUNDRDtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEFyZSB0aGVzZSB0d28gbm9uLWJ1bGxldCBkeW5hbWljIGJvZGllcz9cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvbGxpZGVBID09IGZhbHNlICYmIGNvbGxpZGVCID09IGZhbHNlKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ29tcHV0ZSB0aGUgVE9JIGZvciB0aGlzIGNvbnRhY3QuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFB1dCB0aGUgc3dlZXBzIG9udG8gdGhlIHNhbWUgdGltZSBpbnRlcnZhbC5cclxuICAgICAgICAgICAgICAgICAgICAgICAgZmxvYXQgYWxwaGEwID0gYkEuU3dlZXAuQWxwaGEwO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGJBLlN3ZWVwLkFscGhhMCA8IGJCLlN3ZWVwLkFscGhhMClcclxuICAgICAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWxwaGEwID0gYkIuU3dlZXAuQWxwaGEwO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYkEuU3dlZXAuQWR2YW5jZShhbHBoYTApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGJCLlN3ZWVwLkFscGhhMCA8IGJBLlN3ZWVwLkFscGhhMClcclxuICAgICAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWxwaGEwID0gYkEuU3dlZXAuQWxwaGEwO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYkIuU3dlZXAuQWR2YW5jZShhbHBoYTApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBEZWJ1Zy5Bc3NlcnQoYWxwaGEwIDwgMS4wZik7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBDb21wdXRlIHRoZSB0aW1lIG9mIGltcGFjdCBpbiBpbnRlcnZhbCBbMCwgbWluVE9JXVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBfaW5wdXQuUHJveHlBLlNldChmQS5TaGFwZSwgYy5DaGlsZEluZGV4QSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF9pbnB1dC5Qcm94eUIuU2V0KGZCLlNoYXBlLCBjLkNoaWxkSW5kZXhCKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgX2lucHV0LlN3ZWVwQSA9IGJBLlN3ZWVwO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBfaW5wdXQuU3dlZXBCID0gYkIuU3dlZXA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF9pbnB1dC5UTWF4ID0gMS4wZjtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIFRPSU91dHB1dCBvdXRwdXQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIFRpbWVPZkltcGFjdC5DYWxjdWxhdGVUaW1lT2ZJbXBhY3Qob3V0IG91dHB1dCwgX2lucHV0KTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEJldGEgaXMgdGhlIGZyYWN0aW9uIG9mIHRoZSByZW1haW5pbmcgcG9ydGlvbiBvZiB0aGUgLlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBmbG9hdCBiZXRhID0gb3V0cHV0LlQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvdXRwdXQuU3RhdGUgPT0gVE9JT3V0cHV0U3RhdGUuVG91Y2hpbmcpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFscGhhID0gTWF0aC5NaW4oYWxwaGEwICsgKDEuMGYgLSBhbHBoYTApICogYmV0YSwgMS4wZik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbHBoYSA9IDEuMGY7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGMuVE9JID0gYWxwaGE7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGMuRmxhZ3MgfD0gQ29udGFjdEZsYWdzLlRPSTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChhbHBoYSA8IG1pbkFscGhhKVxyXG4gICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGhpcyBpcyB0aGUgbWluaW11bSBUT0kgZm91bmQgc28gZmFyLlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBtaW5Db250YWN0ID0gYztcclxuICAgICAgICAgICAgICAgICAgICAgICAgbWluQWxwaGEgPSBhbHBoYTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKG1pbkNvbnRhY3QgPT0gbnVsbCB8fCAxLjBmIC0gMTAuMGYgKiBTZXR0aW5ncy5FcHNpbG9uIDwgbWluQWxwaGEpXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gTm8gbW9yZSBUT0kgZXZlbnRzLiBEb25lIVxyXG4gICAgICAgICAgICAgICAgICAgIF9zdGVwQ29tcGxldGUgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIC8vIEFkdmFuY2UgdGhlIGJvZGllcyB0byB0aGUgVE9JLlxyXG4gICAgICAgICAgICAgICAgRml4dHVyZSBmQTEgPSBtaW5Db250YWN0LkZpeHR1cmVBO1xyXG4gICAgICAgICAgICAgICAgRml4dHVyZSBmQjEgPSBtaW5Db250YWN0LkZpeHR1cmVCO1xyXG4gICAgICAgICAgICAgICAgQm9keSBiQTEgPSBmQTEuQm9keTtcclxuICAgICAgICAgICAgICAgIEJvZHkgYkIxID0gZkIxLkJvZHk7XHJcblxyXG4gICAgICAgICAgICAgICAgU3dlZXAgYmFja3VwMSA9IGJBMS5Td2VlcDtcclxuICAgICAgICAgICAgICAgIFN3ZWVwIGJhY2t1cDIgPSBiQjEuU3dlZXA7XHJcblxyXG4gICAgICAgICAgICAgICAgYkExLkFkdmFuY2UobWluQWxwaGEpO1xyXG4gICAgICAgICAgICAgICAgYkIxLkFkdmFuY2UobWluQWxwaGEpO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIFRoZSBUT0kgY29udGFjdCBsaWtlbHkgaGFzIHNvbWUgbmV3IGNvbnRhY3QgcG9pbnRzLlxyXG4gICAgICAgICAgICAgICAgbWluQ29udGFjdC5VcGRhdGUoQ29udGFjdE1hbmFnZXIpO1xyXG4gICAgICAgICAgICAgICAgbWluQ29udGFjdC5GbGFncyAmPSB+Q29udGFjdEZsYWdzLlRPSTtcclxuICAgICAgICAgICAgICAgICsrbWluQ29udGFjdC5UT0lDb3VudDtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBJcyB0aGUgY29udGFjdCBzb2xpZD9cclxuICAgICAgICAgICAgICAgIGlmIChtaW5Db250YWN0LkVuYWJsZWQgPT0gZmFsc2UgfHwgbWluQ29udGFjdC5Jc1RvdWNoaW5nKCkgPT0gZmFsc2UpXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gUmVzdG9yZSB0aGUgc3dlZXBzLlxyXG4gICAgICAgICAgICAgICAgICAgIG1pbkNvbnRhY3QuRW5hYmxlZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgIGJBMS5Td2VlcCA9IGJhY2t1cDE7XHJcbiAgICAgICAgICAgICAgICAgICAgYkIxLlN3ZWVwID0gYmFja3VwMjtcclxuICAgICAgICAgICAgICAgICAgICBiQTEuU3luY2hyb25pemVUcmFuc2Zvcm0oKTtcclxuICAgICAgICAgICAgICAgICAgICBiQjEuU3luY2hyb25pemVUcmFuc2Zvcm0oKTtcclxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBiQTEuQXdha2UgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgYkIxLkF3YWtlID0gdHJ1ZTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBCdWlsZCB0aGUgaXNsYW5kXHJcbiAgICAgICAgICAgICAgICBJc2xhbmQuQ2xlYXIoKTtcclxuICAgICAgICAgICAgICAgIElzbGFuZC5BZGQoYkExKTtcclxuICAgICAgICAgICAgICAgIElzbGFuZC5BZGQoYkIxKTtcclxuICAgICAgICAgICAgICAgIElzbGFuZC5BZGQobWluQ29udGFjdCk7XHJcblxyXG4gICAgICAgICAgICAgICAgYkExLkZsYWdzIHw9IEJvZHlGbGFncy5Jc2xhbmQ7XHJcbiAgICAgICAgICAgICAgICBiQjEuRmxhZ3MgfD0gQm9keUZsYWdzLklzbGFuZDtcclxuICAgICAgICAgICAgICAgIG1pbkNvbnRhY3QuRmxhZ3MgfD0gQ29udGFjdEZsYWdzLklzbGFuZDtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBHZXQgY29udGFjdHMgb24gYm9keUEgYW5kIGJvZHlCLlxyXG4gICAgICAgICAgICAgICAgQm9keVtdIGJvZGllcyA9IHsgYkExLCBiQjEgfTtcclxuICAgICAgICAgICAgICAgIGZvciAoaW50IGkgPSAwOyBpIDwgMjsgKytpKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIEJvZHkgYm9keSA9IGJvZGllc1tpXTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoYm9keS5Cb2R5VHlwZSA9PSBCb2R5VHlwZS5EeW5hbWljKVxyXG4gICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gZm9yIChDb250YWN0RWRnZSBjZSA9IGJvZHkuQ29udGFjdExpc3Q7IGNlICYmIElzbGFuZC5Cb2R5Q291bnQgPCBTZXR0aW5ncy5NYXhUT0lDb250YWN0czsgY2UgPSBjZS5OZXh0KVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKENvbnRhY3RFZGdlIGNlID0gYm9keS5Db250YWN0TGlzdDsgY2UgIT0gbnVsbDsgY2UgPSBjZS5OZXh0KVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBDb250YWN0IGNvbnRhY3QgPSBjZS5Db250YWN0O1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEhhcyB0aGlzIGNvbnRhY3QgYWxyZWFkeSBiZWVuIGFkZGVkIHRvIHRoZSBpc2xhbmQ/XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoKGNvbnRhY3QuRmxhZ3MgJiBDb250YWN0RmxhZ3MuSXNsYW5kKSA9PSBDb250YWN0RmxhZ3MuSXNsYW5kKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIE9ubHkgYWRkIHN0YXRpYywga2luZW1hdGljLCBvciBidWxsZXQgYm9kaWVzLlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgQm9keSBvdGhlciA9IGNlLk90aGVyO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG90aGVyLkJvZHlUeXBlID09IEJvZHlUeXBlLkR5bmFtaWMgJiZcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBib2R5LklzQnVsbGV0ID09IGZhbHNlICYmIG90aGVyLklzQnVsbGV0ID09IGZhbHNlKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFNraXAgc2Vuc29ycy5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjb250YWN0LkZpeHR1cmVBLklzU2Vuc29yIHx8IGNvbnRhY3QuRml4dHVyZUIuSXNTZW5zb3IpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGVudGF0aXZlbHkgYWR2YW5jZSB0aGUgYm9keSB0byB0aGUgVE9JLlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgU3dlZXAgYmFja3VwID0gb3RoZXIuU3dlZXA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoKG90aGVyLkZsYWdzICYgQm9keUZsYWdzLklzbGFuZCkgPT0gMClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdGhlci5BZHZhbmNlKG1pbkFscGhhKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBVcGRhdGUgdGhlIGNvbnRhY3QgcG9pbnRzXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250YWN0LlVwZGF0ZShDb250YWN0TWFuYWdlcik7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gV2FzIHRoZSBjb250YWN0IGRpc2FibGVkIGJ5IHRoZSB1c2VyP1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvbnRhY3QuRW5hYmxlZCA9PSBmYWxzZSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdGhlci5Td2VlcCA9IGJhY2t1cDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdGhlci5TeW5jaHJvbml6ZVRyYW5zZm9ybSgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEFyZSB0aGVyZSBjb250YWN0IHBvaW50cz9cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjb250YWN0LklzVG91Y2hpbmcoKSA9PSBmYWxzZSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdGhlci5Td2VlcCA9IGJhY2t1cDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdGhlci5TeW5jaHJvbml6ZVRyYW5zZm9ybSgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEFkZCB0aGUgY29udGFjdCB0byB0aGUgaXNsYW5kXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250YWN0LkZsYWdzIHw9IENvbnRhY3RGbGFncy5Jc2xhbmQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBJc2xhbmQuQWRkKGNvbnRhY3QpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEhhcyB0aGUgb3RoZXIgYm9keSBhbHJlYWR5IGJlZW4gYWRkZWQgdG8gdGhlIGlzbGFuZD9cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICgob3RoZXIuRmxhZ3MgJiBCb2R5RmxhZ3MuSXNsYW5kKSA9PSBCb2R5RmxhZ3MuSXNsYW5kKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEFkZCB0aGUgb3RoZXIgYm9keSB0byB0aGUgaXNsYW5kLlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3RoZXIuRmxhZ3MgfD0gQm9keUZsYWdzLklzbGFuZDtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAob3RoZXIuQm9keVR5cGUgIT0gQm9keVR5cGUuU3RhdGljKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG90aGVyLkF3YWtlID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBJc2xhbmQuQWRkKG90aGVyKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBUaW1lU3RlcCBzdWJTdGVwO1xyXG4gICAgICAgICAgICAgICAgc3ViU3RlcC5kdCA9ICgxLjBmIC0gbWluQWxwaGEpICogc3RlcC5kdDtcclxuICAgICAgICAgICAgICAgIHN1YlN0ZXAuaW52X2R0ID0gMS4wZiAvIHN1YlN0ZXAuZHQ7XHJcbiAgICAgICAgICAgICAgICBzdWJTdGVwLmR0UmF0aW8gPSAxLjBmO1xyXG4gICAgICAgICAgICAgICAgLy9zdWJTdGVwLnBvc2l0aW9uSXRlcmF0aW9ucyA9IDIwO1xyXG4gICAgICAgICAgICAgICAgLy9zdWJTdGVwLnZlbG9jaXR5SXRlcmF0aW9ucyA9IHN0ZXAudmVsb2NpdHlJdGVyYXRpb25zO1xyXG4gICAgICAgICAgICAgICAgLy9zdWJTdGVwLndhcm1TdGFydGluZyA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgSXNsYW5kLlNvbHZlVE9JKHJlZiBzdWJTdGVwKTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBSZXNldCBpc2xhbmQgZmxhZ3MgYW5kIHN5bmNocm9uaXplIGJyb2FkLXBoYXNlIHByb3hpZXMuXHJcbiAgICAgICAgICAgICAgICBmb3IgKGludCBpID0gMDsgaSA8IElzbGFuZC5Cb2R5Q291bnQ7ICsraSlcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBCb2R5IGJvZHkgPSBJc2xhbmQuQm9kaWVzW2ldO1xyXG4gICAgICAgICAgICAgICAgICAgIGJvZHkuRmxhZ3MgJj0gfkJvZHlGbGFncy5Jc2xhbmQ7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChib2R5LkJvZHlUeXBlICE9IEJvZHlUeXBlLkR5bmFtaWMpXHJcbiAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGJvZHkuU3luY2hyb25pemVGaXh0dXJlcygpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBJbnZhbGlkYXRlIGFsbCBjb250YWN0IFRPSXMgb24gdGhpcyBkaXNwbGFjZWQgYm9keS5cclxuICAgICAgICAgICAgICAgICAgICBmb3IgKENvbnRhY3RFZGdlIGNlID0gYm9keS5Db250YWN0TGlzdDsgY2UgIT0gbnVsbDsgY2UgPSBjZS5OZXh0KVxyXG4gICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2UuQ29udGFjdC5GbGFncyAmPSB+KENvbnRhY3RGbGFncy5UT0kgfCBDb250YWN0RmxhZ3MuSXNsYW5kKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gQ29tbWl0IGZpeHR1cmUgcHJveHkgbW92ZW1lbnRzIHRvIHRoZSBicm9hZC1waGFzZSBzbyB0aGF0IG5ldyBjb250YWN0cyBhcmUgY3JlYXRlZC5cclxuICAgICAgICAgICAgICAgIC8vIEFsc28sIHNvbWUgY29udGFjdHMgY2FuIGJlIGRlc3Ryb3llZC5cclxuICAgICAgICAgICAgICAgIENvbnRhY3RNYW5hZ2VyLkZpbmROZXdDb250YWN0cygpO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmIChFbmFibGVTdWJTdGVwcGluZylcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBfc3RlcENvbXBsZXRlID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHB1YmxpYyB2b2lkIEFkZENvbnRyb2xsZXIoQ29udHJvbGxlciBjb250cm9sbGVyKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgRGVidWcuQXNzZXJ0KCFDb250cm9sbGVyTGlzdC5Db250YWlucyhjb250cm9sbGVyKSwgXCJZb3UgYXJlIGFkZGluZyB0aGUgc2FtZSBjb250cm9sbGVyIG1vcmUgdGhhbiBvbmNlLlwiKTtcclxuXHJcbiAgICAgICAgICAgIGNvbnRyb2xsZXIuV29ybGQgPSB0aGlzO1xyXG4gICAgICAgICAgICBDb250cm9sbGVyTGlzdC5BZGQoY29udHJvbGxlcik7XHJcblxyXG4gICAgICAgICAgICBpZiAoQ29udHJvbGxlckFkZGVkICE9IG51bGwpXHJcbiAgICAgICAgICAgICAgICBDb250cm9sbGVyQWRkZWQoY29udHJvbGxlcik7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwdWJsaWMgdm9pZCBSZW1vdmVDb250cm9sbGVyKENvbnRyb2xsZXIgY29udHJvbGxlcilcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIERlYnVnLkFzc2VydChDb250cm9sbGVyTGlzdC5Db250YWlucyhjb250cm9sbGVyKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgIFwiWW91IGFyZSByZW1vdmluZyBhIGNvbnRyb2xsZXIgdGhhdCBpcyBub3QgaW4gdGhlIHNpbXVsYXRpb24uXCIpO1xyXG5cclxuICAgICAgICAgICAgaWYgKENvbnRyb2xsZXJMaXN0LkNvbnRhaW5zKGNvbnRyb2xsZXIpKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBDb250cm9sbGVyTGlzdC5SZW1vdmUoY29udHJvbGxlcik7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKENvbnRyb2xsZXJSZW1vdmVkICE9IG51bGwpXHJcbiAgICAgICAgICAgICAgICAgICAgQ29udHJvbGxlclJlbW92ZWQoY29udHJvbGxlcik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHB1YmxpYyB2b2lkIEFkZEJyZWFrYWJsZUJvZHkoQnJlYWthYmxlQm9keSBicmVha2FibGVCb2R5KVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgQnJlYWthYmxlQm9keUxpc3QuQWRkKGJyZWFrYWJsZUJvZHkpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHVibGljIHZvaWQgUmVtb3ZlQnJlYWthYmxlQm9keShCcmVha2FibGVCb2R5IGJyZWFrYWJsZUJvZHkpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICAvL1RoZSBicmVha2FibGUgYm9keSBsaXN0IGRvZXMgbm90IGNvbnRhaW4gdGhlIGJvZHkgeW91IHRyaWVkIHRvIHJlbW92ZS5cclxuICAgICAgICAgICAgRGVidWcuQXNzZXJ0KEJyZWFrYWJsZUJvZHlMaXN0LkNvbnRhaW5zKGJyZWFrYWJsZUJvZHkpKTtcclxuXHJcbiAgICAgICAgICAgIEJyZWFrYWJsZUJvZHlMaXN0LlJlbW92ZShicmVha2FibGVCb2R5KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHB1YmxpYyBGaXh0dXJlIFRlc3RQb2ludChWZWN0b3IyIHBvaW50KVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgQUFCQiBhYWJiO1xyXG4gICAgICAgICAgICBWZWN0b3IyIGQgPSBuZXcgVmVjdG9yMihTZXR0aW5ncy5FcHNpbG9uLCBTZXR0aW5ncy5FcHNpbG9uKTtcclxuICAgICAgICAgICAgYWFiYi5Mb3dlckJvdW5kID0gcG9pbnQgLSBkO1xyXG4gICAgICAgICAgICBhYWJiLlVwcGVyQm91bmQgPSBwb2ludCArIGQ7XHJcblxyXG4gICAgICAgICAgICBGaXh0dXJlIG15Rml4dHVyZSA9IG51bGw7XHJcblxyXG4gICAgICAgICAgICAvLyBRdWVyeSB0aGUgd29ybGQgZm9yIG92ZXJsYXBwaW5nIHNoYXBlcy5cclxuICAgICAgICAgICAgUXVlcnlBQUJCKFxyXG4oZ2xvYmFsOjpTeXN0ZW0uRnVuYzxnbG9iYWw6OkZhcnNlZXJQaHlzaWNzLkR5bmFtaWNzLkZpeHR1cmUsIGJvb2w+KSggICAgICAgICAgICAgICAgZml4dHVyZSA9PlxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIGJvb2wgaW5zaWRlID0gZml4dHVyZS5UZXN0UG9pbnQocmVmIHBvaW50KTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoaW5zaWRlKVxyXG4gICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbXlGaXh0dXJlID0gZml4dHVyZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gQ29udGludWUgdGhlIHF1ZXJ5LlxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICAgICAgfSksIHJlZiBhYWJiKTtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiBteUZpeHR1cmU7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIFJldHVybnMgYSBsaXN0IG9mIGZpeHR1cmVzIHRoYXQgYXJlIGF0IHRoZSBzcGVjaWZpZWQgcG9pbnQuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJwb2ludFwiPlRoZSBwb2ludC48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cmV0dXJucz48L3JldHVybnM+XHJcbiAgICAgICAgcHVibGljIExpc3Q8Rml4dHVyZT4gVGVzdFBvaW50QWxsKFZlY3RvcjIgcG9pbnQpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBBQUJCIGFhYmI7XHJcbiAgICAgICAgICAgIFZlY3RvcjIgZCA9IG5ldyBWZWN0b3IyKFNldHRpbmdzLkVwc2lsb24sIFNldHRpbmdzLkVwc2lsb24pO1xyXG4gICAgICAgICAgICBhYWJiLkxvd2VyQm91bmQgPSBwb2ludCAtIGQ7XHJcbiAgICAgICAgICAgIGFhYmIuVXBwZXJCb3VuZCA9IHBvaW50ICsgZDtcclxuXHJcbiAgICAgICAgICAgIExpc3Q8Rml4dHVyZT4gZml4dHVyZXMgPSBuZXcgTGlzdDxGaXh0dXJlPigpO1xyXG5cclxuICAgICAgICAgICAgLy8gUXVlcnkgdGhlIHdvcmxkIGZvciBvdmVybGFwcGluZyBzaGFwZXMuXHJcbiAgICAgICAgICAgIFF1ZXJ5QUFCQihcclxuKGdsb2JhbDo6U3lzdGVtLkZ1bmM8Z2xvYmFsOjpGYXJzZWVyUGh5c2ljcy5EeW5hbWljcy5GaXh0dXJlLCBib29sPikoICAgICAgICAgICAgICAgIGZpeHR1cmUgPT5cclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBib29sIGluc2lkZSA9IGZpeHR1cmUuVGVzdFBvaW50KHJlZiBwb2ludCk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGluc2lkZSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgZml4dHVyZXMuQWRkKGZpeHR1cmUpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBDb250aW51ZSB0aGUgcXVlcnkuXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgICAgICB9KSwgcmVmIGFhYmIpO1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIGZpeHR1cmVzO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHVibGljIHZvaWQgQ2xlYXIoKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgUHJvY2Vzc0NoYW5nZXMoKTtcclxuXHJcbiAgICAgICAgICAgIGZvciAoaW50IGkgPSBCb2R5TGlzdC5Db3VudCAtIDE7IGkgPj0gMDsgaS0tKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBSZW1vdmVCb2R5KEJvZHlMaXN0W2ldKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgZm9yIChpbnQgaSA9IENvbnRyb2xsZXJMaXN0LkNvdW50IC0gMTsgaSA+PSAwOyBpLS0pXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIFJlbW92ZUNvbnRyb2xsZXIoQ29udHJvbGxlckxpc3RbaV0pO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBmb3IgKGludCBpID0gQnJlYWthYmxlQm9keUxpc3QuQ291bnQgLSAxOyBpID49IDA7IGktLSlcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgUmVtb3ZlQnJlYWthYmxlQm9keShCcmVha2FibGVCb2R5TGlzdFtpXSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIFByb2Nlc3NDaGFuZ2VzKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59IiwidXNpbmcgU3lzdGVtO1xyXG51c2luZyBGYXJzZWVyUGh5c2ljcy5EeW5hbWljcztcclxuXHJcbm5hbWVzcGFjZSBGYXJzZWVyUGh5c2ljcy5Db21tb24uUGh5c2ljc0xvZ2ljXHJcbntcclxuICAgIFtGbGFnc11cclxuICAgIHB1YmxpYyBlbnVtIFBoeXNpY3NMb2dpY1R5cGVcclxuICAgIHtcclxuICAgICAgICBFeHBsb3Npb24gPSAoMSA8PCAwKVxyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBzdHJ1Y3QgUGh5c2ljc0xvZ2ljRmlsdGVyXHJcbiAgICB7XHJcbiAgICAgICAgcHVibGljIFBoeXNpY3NMb2dpY1R5cGUgQ29udHJvbGxlcklnbm9yZXM7XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gSWdub3JlcyB0aGUgY29udHJvbGxlci4gVGhlIGNvbnRyb2xsZXIgaGFzIG5vIGVmZmVjdCBvbiB0aGlzIGJvZHkuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJ0eXBlXCI+VGhlIGxvZ2ljIHR5cGUuPC9wYXJhbT5cclxuICAgICAgICBwdWJsaWMgdm9pZCBJZ25vcmVQaHlzaWNzTG9naWMoUGh5c2ljc0xvZ2ljVHlwZSB0eXBlKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgQ29udHJvbGxlcklnbm9yZXMgfD0gdHlwZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gUmVzdG9yZSB0aGUgY29udHJvbGxlci4gVGhlIGNvbnRyb2xsZXIgYWZmZWN0cyB0aGlzIGJvZHkuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJ0eXBlXCI+VGhlIGxvZ2ljIHR5cGUuPC9wYXJhbT5cclxuICAgICAgICBwdWJsaWMgdm9pZCBSZXN0b3JlUGh5c2ljc0xvZ2ljKFBoeXNpY3NMb2dpY1R5cGUgdHlwZSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIENvbnRyb2xsZXJJZ25vcmVzICY9IH50eXBlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBEZXRlcm1pbmVzIHdoZXRoZXIgdGhpcyBib2R5IGlnbm9yZXMgdGhlIHRoZSBzcGVjaWZpZWQgY29udHJvbGxlci5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cInR5cGVcIj5UaGUgbG9naWMgdHlwZS48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cmV0dXJucz5cclxuICAgICAgICAvLy8gXHQ8Yz50cnVlPC9jPiBpZiB0aGUgYm9keSBoYXMgdGhlIHNwZWNpZmllZCBmbGFnOyBvdGhlcndpc2UsIDxjPmZhbHNlPC9jPi5cclxuICAgICAgICAvLy8gPC9yZXR1cm5zPlxyXG4gICAgICAgIHB1YmxpYyBib29sIElzUGh5c2ljc0xvZ2ljSWdub3JlZChQaHlzaWNzTG9naWNUeXBlIHR5cGUpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gKENvbnRyb2xsZXJJZ25vcmVzICYgdHlwZSkgPT0gdHlwZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGFic3RyYWN0IGNsYXNzIFBoeXNpY3NMb2dpYyA6IEZpbHRlckRhdGFcclxuICAgIHtcclxuICAgICAgICBwcml2YXRlIFBoeXNpY3NMb2dpY1R5cGUgX3R5cGU7XHJcbiAgICAgICAgcHVibGljIFdvcmxkIFdvcmxkO1xyXG5cclxuICAgICAgICBwdWJsaWMgb3ZlcnJpZGUgYm9vbCBJc0FjdGl2ZU9uKEJvZHkgYm9keSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGlmIChib2R5LlBoeXNpY3NMb2dpY0ZpbHRlci5Jc1BoeXNpY3NMb2dpY0lnbm9yZWQoX3R5cGUpKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIGJhc2UuSXNBY3RpdmVPbihib2R5KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHB1YmxpYyBQaHlzaWNzTG9naWMoV29ybGQgd29ybGQsIFBoeXNpY3NMb2dpY1R5cGUgdHlwZSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIF90eXBlID0gdHlwZTtcclxuICAgICAgICAgICAgV29ybGQgPSB3b3JsZDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn0iLCJ1c2luZyBTeXN0ZW07XHJcbnVzaW5nIFN5c3RlbS5Db2xsZWN0aW9ucy5HZW5lcmljO1xyXG51c2luZyBTeXN0ZW0uTGlucTtcclxudXNpbmcgRmFyc2VlclBoeXNpY3MuQ29sbGlzaW9uO1xyXG51c2luZyBGYXJzZWVyUGh5c2ljcy5Db2xsaXNpb24uU2hhcGVzO1xyXG51c2luZyBGYXJzZWVyUGh5c2ljcy5EeW5hbWljcztcclxudXNpbmcgTWljcm9zb2Z0LlhuYS5GcmFtZXdvcms7XHJcblxyXG5uYW1lc3BhY2UgRmFyc2VlclBoeXNpY3MuQ29tbW9uLlBoeXNpY3NMb2dpY1xyXG57XHJcbiAgICBpbnRlcm5hbCBzdHJ1Y3QgU2hhcGVEYXRhXHJcbiAgICB7XHJcbiAgICAgICAgcHVibGljIEJvZHkgQm9keTtcclxuICAgICAgICBwdWJsaWMgZmxvYXQgTWF4O1xyXG4gICAgICAgIHB1YmxpYyBmbG9hdCBNaW47IC8vIGFic29sdXRlIGFuZ2xlc1xyXG4gICAgfVxyXG5cclxuICAgIC8vLyA8c3VtbWFyeT5cclxuICAgIC8vLyBUaGlzIGlzIGEgY29tcHJhcmVyIHVzZWQgZm9yIFxyXG4gICAgLy8vIGRldGVjdGluZyBhbmdsZSBkaWZmZXJlbmNlIGJldHdlZW4gcmF5c1xyXG4gICAgLy8vIDwvc3VtbWFyeT5cclxuICAgIGludGVybmFsIGNsYXNzIFJheURhdGFDb21wYXJlciA6IElDb21wYXJlcjxmbG9hdD5cclxuICAgIHtcclxuICAgICAgICAjcmVnaW9uIElDb21wYXJlcjxmbG9hdD4gTWVtYmVyc1xyXG5cclxuICAgICAgICBpbnQgSUNvbXBhcmVyPGZsb2F0Pi5Db21wYXJlKGZsb2F0IGEsIGZsb2F0IGIpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBmbG9hdCBkaWZmID0gKGEgLSBiKTtcclxuICAgICAgICAgICAgaWYgKGRpZmYgPiAwKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIDE7XHJcbiAgICAgICAgICAgIGlmIChkaWZmIDwgMClcclxuICAgICAgICAgICAgICAgIHJldHVybiAtMTtcclxuICAgICAgICAgICAgcmV0dXJuIDA7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAjZW5kcmVnaW9uXHJcbiAgICB9XHJcblxyXG4gICAgLyogTWV0aG9kb2xvZ3k6XHJcbiAgICAgKiBGb3JjZSBhcHBsaWVkIGF0IGEgcmF5IGlzIGludmVyc2VseSBwcm9wb3J0aW9uYWwgdG8gdGhlIHNxdWFyZSBvZiBkaXN0YW5jZSBmcm9tIHNvdXJjZVxyXG4gICAgICogQUFCQiBpcyB1c2VkIHRvIHF1ZXJ5IGZvciBzaGFwZXMgdGhhdCBtYXkgYmUgYWZmZWN0ZWRcclxuICAgICAqIEZvciBlYWNoIFJJR0lEIEJPRFkgKG5vdCBzaGFwZSAtLSB0aGlzIGlzIGFuIG9wdGltaXphdGlvbikgdGhhdCBpcyBtYXRjaGVkLCBsb29wIHRocm91Z2ggaXRzIHZlcnRpY2VzIHRvIGRldGVybWluZVxyXG4gICAgICpcdFx0dGhlIGV4dHJlbWUgcG9pbnRzIC0tIGlmIHRoZXJlIGlzIHN0cnVjdHVyZSB0aGF0IGNvbnRhaW5zIG91dGxpbmluZyBwb2x5Z29uLCB1c2UgdGhhdCBhcyBhbiBhZGRpdGlvbmFsIG9wdGltaXphdGlvblxyXG4gICAgICogRXZlbmx5IGNhc3QgYSBudW1iZXIgb2YgcmF5cyBhZ2FpbnN0IHRoZSBzaGFwZSAtIG51bWJlciByb3VnaGx5IHByb3BvcnRpb25hbCB0byB0aGUgYXJjIGNvdmVyYWdlXHJcbiAgICAgKlx0XHQtU29tZXRoaW5nIGxpa2UgZXZlcnkgMyBkZWdyZWVzIHNob3VsZCBkbyB0aGUgdHJpY2sgYWx0aG91Z2ggdGhpcyBjYW4gYmUgYWx0ZXJlZCBkZXBlbmRpbmcgb24gdGhlIGRpc3RhbmNlIChpZiByZWFsbHkgY2xvc2UgZG9uJ3QgbmVlZCBzdWNoIGEgaGlnaCBkZW5zaXR5IG9mIHJheXMpXHJcbiAgICAgKlx0XHQtVGhlcmUgc2hvdWxkIGJlIGEgbWluaW11bSBudW1iZXIgb2YgcmF5cyAoMy01PykgYXBwbGllZCB0byBlYWNoIGJvZHkgc28gdGhhdCBzbWFsbCBib2RpZXMgZmFyIGF3YXkgYXJlIHN0aWxsIGFjY3VyYXRlbHkgbW9kZWxlZFxyXG4gICAgICpcdFx0LUJlIHN1cmUgdG8gaGF2ZSB0aGUgZm9yY2VzIG9mIGVhY2ggcmF5IGJlIHByb3BvcnRpb25hbCB0byB0aGUgYXZlcmFnZSBhcmMgbGVuZ3RoIGNvdmVyZWQgYnkgZWFjaC5cclxuICAgICAqIEZvciBlYWNoIHJheSB0aGF0IGFjdHVhbGx5IGludGVyc2VjdHMgd2l0aCB0aGUgc2hhcGUgKG5vbiBpbnRlcnNlY3Rpb25zIGluZGljYXRlIHNvbWV0aGluZyBibG9ja2luZyB0aGUgcGF0aCBvZiBleHBsb3Npb24pOlxyXG4gICAgICpcdFx0PiBhcHBseSB0aGUgYXBwcm9wcmlhdGUgZm9yY2UgZG90dGVkIHdpdGggdGhlIG5lZ2F0aXZlIG9mIHRoZSBjb2xsaXNpb24gbm9ybWFsIGF0IHRoZSBjb2xsaXNpb24gcG9pbnRcclxuICAgICAqXHRcdD4gb3B0aW9uYWxseSBhcHBseSBsaW5lYXIgaW50ZXJwb2xhdGlvbiBiZXR3ZWVuIGFmb3JlbWVudGlvbmVkIE5vcm1hbCBmb3JjZSBhbmQgdGhlIG9yaWdpbmFsIGV4cGxvc2lvbiBmb3JjZSBpbiB0aGUgZGlyZWN0aW9uIG9mIHJheSB0byBzaW11bGF0ZSBcInN1cmZhY2UgZnJpY3Rpb25cIiBvZiBzb3J0c1xyXG4gICAgICovXHJcblxyXG4gICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgLy8vIFRoaXMgaXMgYW4gZXhwbG9zaXZlLi4uIGl0IGV4cGxvZGVzLlxyXG4gICAgLy8vIDwvc3VtbWFyeT5cclxuICAgIC8vLyA8cmVtYXJrcz5cclxuICAgIC8vLyBPcmlnaW5hbCBDb2RlIGJ5IFN0ZXZlbiBMdSAtIHNlZSBodHRwOi8vd3d3LmJveDJkLm9yZy9mb3J1bS92aWV3dG9waWMucGhwP2Y9MyZ0PTE2ODhcclxuICAgIC8vLyBQb3J0ZWQgdG8gRmFyc2VlciAzLjAgYnkgTmljb2zvv71zIEhvcm1heu+/vWJhbFxyXG4gICAgLy8vIDwvcmVtYXJrcz5cclxuICAgIHB1YmxpYyBzZWFsZWQgY2xhc3MgRXhwbG9zaW9uIDogUGh5c2ljc0xvZ2ljXHJcbiAgICB7XHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBUd28gZGVncmVlczogbWF4aW11bSBhbmdsZSBmcm9tIGVkZ2VzIHRvIGZpcnN0IHJheSB0ZXN0ZWRcclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIHByaXZhdGUgY29uc3QgZmxvYXQgTWF4RWRnZU9mZnNldCA9IE1hdGhIZWxwZXIuUGkgLyA5MDtcclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBSYXRpbyBvZiBhcmMgbGVuZ3RoIHRvIGFuZ2xlIGZyb20gZWRnZXMgdG8gZmlyc3QgcmF5IHRlc3RlZC5cclxuICAgICAgICAvLy8gRGVmYXVsdHMgdG8gMS80MC5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIHB1YmxpYyBmbG9hdCBFZGdlUmF0aW8gPSAxLjBmIC8gNDAuMGY7XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gSWdub3JlIEV4cGxvc2lvbiBpZiBpdCBoYXBwZW5zIGluc2lkZSBhIHNoYXBlLlxyXG4gICAgICAgIC8vLyBEZWZhdWx0IHZhbHVlIGlzIGZhbHNlLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgcHVibGljIGJvb2wgSWdub3JlV2hlbkluc2lkZVNoYXBlID0gZmFsc2U7XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gTWF4IGFuZ2xlIGJldHdlZW4gcmF5cyAodXNlZCB3aGVuIHNlZ21lbnQgaXMgbGFyZ2UpLlxyXG4gICAgICAgIC8vLyBEZWZhdWx0cyB0byAxNSBkZWdyZWVzXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICBwdWJsaWMgZmxvYXQgTWF4QW5nbGUgPSBNYXRoSGVscGVyLlBpIC8gMTU7XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gTWF4aW11bSBudW1iZXIgb2Ygc2hhcGVzIGludm9sdmVkIGluIHRoZSBleHBsb3Npb24uXHJcbiAgICAgICAgLy8vIERlZmF1bHRzIHRvIDEwMFxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgcHVibGljIGludCBNYXhTaGFwZXMgPSAxMDA7XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gSG93IG1hbnkgcmF5cyBwZXIgc2hhcGUvYm9keS9zZWdtZW50LlxyXG4gICAgICAgIC8vLyBEZWZhdWx0cyB0byA1XHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICBwdWJsaWMgaW50IE1pblJheXMgPSA1O1xyXG5cclxuICAgICAgICBwcml2YXRlIExpc3Q8U2hhcGVEYXRhPiBfZGF0YSA9IG5ldyBMaXN0PFNoYXBlRGF0YT4oKTtcclxuICAgICAgICBwcml2YXRlIERpY3Rpb25hcnk8Rml4dHVyZSwgTGlzdDxWZWN0b3IyPj4gX2V4cGxvZGVkO1xyXG4gICAgICAgIHByaXZhdGUgUmF5RGF0YUNvbXBhcmVyIF9yZGM7XHJcblxyXG4gICAgICAgIHB1YmxpYyBFeHBsb3Npb24oV29ybGQgd29ybGQpXHJcbiAgICAgICAgICAgIDogYmFzZSh3b3JsZCwgUGh5c2ljc0xvZ2ljVHlwZS5FeHBsb3Npb24pXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBfZXhwbG9kZWQgPSBuZXcgRGljdGlvbmFyeTxGaXh0dXJlLCBMaXN0PFZlY3RvcjI+PigpO1xyXG4gICAgICAgICAgICBfcmRjID0gbmV3IFJheURhdGFDb21wYXJlcigpO1xyXG4gICAgICAgICAgICBfZGF0YSA9IG5ldyBMaXN0PFNoYXBlRGF0YT4oKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gVGhpcyBtYWtlcyB0aGUgZXhwbG9zaXZlIGV4cGxvZGVcclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cInBvc1wiPlxyXG4gICAgICAgIC8vLyBUaGUgcG9zaXRpb24gd2hlcmUgdGhlIGV4cGxvc2lvbiBoYXBwZW5zXHJcbiAgICAgICAgLy8vIDwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwicmFkaXVzXCI+XHJcbiAgICAgICAgLy8vIFRoZSBleHBsb3Npb24gcmFkaXVzXHJcbiAgICAgICAgLy8vIDwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwibWF4Rm9yY2VcIj5cclxuICAgICAgICAvLy8gVGhlIGV4cGxvc2lvbiBmb3JjZSBhdCB0aGUgZXhwbG9zaW9uIHBvaW50XHJcbiAgICAgICAgLy8vICh0aGVuIGlzIGludmVyc2VseSBwcm9wb3J0aW9uYWwgdG8gdGhlIHNxdWFyZSBvZiB0aGUgZGlzdGFuY2UpXHJcbiAgICAgICAgLy8vIDwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxyZXR1cm5zPlxyXG4gICAgICAgIC8vLyBBIGRpY3Rpb25uYXJ5IGNvbnRhaW5pbmcgYWxsIHRoZSBcImV4cGxvZGVkXCIgZml4dHVyZXNcclxuICAgICAgICAvLy8gd2l0aCBhIGxpc3Qgb2YgdGhlIGFwcGxpZWQgaW1wdWxzZXNcclxuICAgICAgICAvLy8gPC9yZXR1cm5zPlxyXG4gICAgICAgIHB1YmxpYyBEaWN0aW9uYXJ5PEZpeHR1cmUsIExpc3Q8VmVjdG9yMj4+IEFjdGl2YXRlKFZlY3RvcjIgcG9zLCBmbG9hdCByYWRpdXMsIGZsb2F0IG1heEZvcmNlKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgX2V4cGxvZGVkLkNsZWFyKCk7XHJcblxyXG4gICAgICAgICAgICBBQUJCIGFhYmI7XHJcbiAgICAgICAgICAgIGFhYmIuTG93ZXJCb3VuZCA9IHBvcyArIG5ldyBWZWN0b3IyKC1yYWRpdXMsIC1yYWRpdXMpO1xyXG4gICAgICAgICAgICBhYWJiLlVwcGVyQm91bmQgPSBwb3MgKyBuZXcgVmVjdG9yMihyYWRpdXMsIHJhZGl1cyk7XHJcbiAgICAgICAgICAgIEZpeHR1cmVbXSBzaGFwZXMgPSBuZXcgRml4dHVyZVtNYXhTaGFwZXNdO1xyXG5cclxuICAgICAgICAgICAgLy8gTW9yZSB0aGFuIDUgc2hhcGVzIGluIGFuIGV4cGxvc2lvbiBjb3VsZCBiZSBwb3NzaWJsZSwgYnV0IHN0aWxsIHN0cmFuZ2UuXHJcbiAgICAgICAgICAgIEZpeHR1cmVbXSBjb250YWluZWRTaGFwZXMgPSBuZXcgRml4dHVyZVs1XTtcclxuICAgICAgICAgICAgYm9vbCBleGl0ID0gZmFsc2U7XHJcblxyXG4gICAgICAgICAgICBpbnQgc2hhcGVDb3VudCA9IDA7XHJcbiAgICAgICAgICAgIGludCBjb250YWluZWRTaGFwZUNvdW50ID0gMDtcclxuXHJcbiAgICAgICAgICAgIC8vIFF1ZXJ5IHRoZSB3b3JsZCBmb3Igb3ZlcmxhcHBpbmcgc2hhcGVzLlxyXG4gICAgICAgICAgICBXb3JsZC5RdWVyeUFBQkIoXHJcbihnbG9iYWw6OlN5c3RlbS5GdW5jPGdsb2JhbDo6RmFyc2VlclBoeXNpY3MuRHluYW1pY3MuRml4dHVyZSwgYm9vbD4pKCAgICAgICAgICAgICAgICBmaXh0dXJlID0+XHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGZpeHR1cmUuVGVzdFBvaW50KHJlZiBwb3MpKVxyXG4gICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKElnbm9yZVdoZW5JbnNpZGVTaGFwZSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4aXQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250YWluZWRTaGFwZXNbY29udGFpbmVkU2hhcGVDb3VudCsrXSA9IGZpeHR1cmU7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNoYXBlc1tzaGFwZUNvdW50KytdID0gZml4dHVyZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIENvbnRpbnVlIHRoZSBxdWVyeS5cclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIH0pLCByZWYgYWFiYik7XHJcblxyXG4gICAgICAgICAgICBpZiAoZXhpdClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIF9leHBsb2RlZDtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gUGVyIHNoYXBlIG1heC9taW4gYW5nbGVzIGZvciBub3cuXHJcbiAgICAgICAgICAgIGZsb2F0W10gdmFscyA9IG5ldyBmbG9hdFtzaGFwZUNvdW50ICogMl07XHJcbiAgICAgICAgICAgIGludCB2YWxJbmRleCA9IDA7XHJcbiAgICAgICAgICAgIGZvciAoaW50IGkgPSAwOyBpIDwgc2hhcGVDb3VudDsgKytpKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBQb2x5Z29uU2hhcGUgcHM7XHJcbiAgICAgICAgICAgICAgICBDaXJjbGVTaGFwZSBjcyA9IHNoYXBlc1tpXS5TaGFwZSBhcyBDaXJjbGVTaGFwZTtcclxuICAgICAgICAgICAgICAgIGlmIChjcyAhPSBudWxsKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIFdlIGNyZWF0ZSBhIFwiZGlhbW9uZFwiIGFwcHJveGltYXRpb24gb2YgdGhlIGNpcmNsZVxyXG4gICAgICAgICAgICAgICAgICAgIFZlcnRpY2VzIHYgPSBuZXcgVmVydGljZXMoKTtcclxuICAgICAgICAgICAgICAgICAgICBWZWN0b3IyIHZlYyA9IFZlY3RvcjIuWmVybyArIG5ldyBWZWN0b3IyKGNzLlJhZGl1cywgMCk7XHJcbiAgICAgICAgICAgICAgICAgICAgdi5BZGQodmVjKTtcclxuICAgICAgICAgICAgICAgICAgICB2ZWMgPSBWZWN0b3IyLlplcm8gKyBuZXcgVmVjdG9yMigwLCBjcy5SYWRpdXMpO1xyXG4gICAgICAgICAgICAgICAgICAgIHYuQWRkKHZlYyk7XHJcbiAgICAgICAgICAgICAgICAgICAgdmVjID0gVmVjdG9yMi5aZXJvICsgbmV3IFZlY3RvcjIoLWNzLlJhZGl1cywgY3MuUmFkaXVzKTtcclxuICAgICAgICAgICAgICAgICAgICB2LkFkZCh2ZWMpO1xyXG4gICAgICAgICAgICAgICAgICAgIHZlYyA9IFZlY3RvcjIuWmVybyArIG5ldyBWZWN0b3IyKDAsIC1jcy5SYWRpdXMpO1xyXG4gICAgICAgICAgICAgICAgICAgIHYuQWRkKHZlYyk7XHJcbiAgICAgICAgICAgICAgICAgICAgcHMgPSBuZXcgUG9seWdvblNoYXBlKHYsIDApO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgICAgIHBzID0gc2hhcGVzW2ldLlNoYXBlIGFzIFBvbHlnb25TaGFwZTtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoKHNoYXBlc1tpXS5Cb2R5LkJvZHlUeXBlID09IEJvZHlUeXBlLkR5bmFtaWMpICYmIHBzICE9IG51bGwpXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgVmVjdG9yMiB0b0NlbnRyb2lkID0gc2hhcGVzW2ldLkJvZHkuR2V0V29ybGRQb2ludChwcy5NYXNzRGF0YS5DZW50cm9pZCkgLSBwb3M7XHJcbiAgICAgICAgICAgICAgICAgICAgZmxvYXQgYW5nbGVUb0NlbnRyb2lkID0gKGZsb2F0KU1hdGguQXRhbjIodG9DZW50cm9pZC5ZLCB0b0NlbnRyb2lkLlgpO1xyXG4gICAgICAgICAgICAgICAgICAgIGZsb2F0IG1pbiA9IGZsb2F0Lk1heFZhbHVlO1xyXG4gICAgICAgICAgICAgICAgICAgIGZsb2F0IG1heCA9IGZsb2F0Lk1pblZhbHVlO1xyXG4gICAgICAgICAgICAgICAgICAgIGZsb2F0IG1pbkFic29sdXRlID0gMC4wZjtcclxuICAgICAgICAgICAgICAgICAgICBmbG9hdCBtYXhBYnNvbHV0ZSA9IDAuMGY7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGZvciAoaW50IGogPSAwOyBqIDwgKFN5c3RlbS5MaW5xLkVudW1lcmFibGUuQ291bnQ8Z2xvYmFsOjpNaWNyb3NvZnQuWG5hLkZyYW1ld29yay5WZWN0b3IyPihwcy5WZXJ0aWNlcykpOyArK2opXHJcbiAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBWZWN0b3IyIHRvVmVydGV4ID0gKHNoYXBlc1tpXS5Cb2R5LkdldFdvcmxkUG9pbnQocHMuVmVydGljZXNbal0pIC0gcG9zKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZmxvYXQgbmV3QW5nbGUgPSAoZmxvYXQpTWF0aC5BdGFuMih0b1ZlcnRleC5ZLCB0b1ZlcnRleC5YKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZmxvYXQgZGlmZiA9IChuZXdBbmdsZSAtIGFuZ2xlVG9DZW50cm9pZCk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBkaWZmID0gKGRpZmYgLSBNYXRoSGVscGVyLlBpKSAlICgyICogTWF0aEhlbHBlci5QaSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRoZSBtaW51cyBwaSBpcyBpbXBvcnRhbnQuIEl0IG1lYW5zIGN1dG9mZiBmb3IgZ29pbmcgb3RoZXIgZGlyZWN0aW9uIGlzIGF0IDE4MCBkZWcgd2hlcmUgaXQgbmVlZHMgdG8gYmVcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkaWZmIDwgMC4wZilcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRpZmYgKz0gMiAqIE1hdGhIZWxwZXIuUGk7IC8vIGNvcnJlY3Rpb24gZm9yIG5vdCBoYW5kbGluZyBuZWdzXHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBkaWZmIC09IE1hdGhIZWxwZXIuUGk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoTWF0aC5BYnMoZGlmZikgPiBNYXRoSGVscGVyLlBpKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEFyZ3VtZW50RXhjZXB0aW9uKFwiT01HIVwiKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gU29tZXRoaW5nJ3Mgd3JvbmcsIHBvaW50IG5vdCBpbiBzaGFwZSBidXQgZXhpc3RzIGFuZ2xlIGRpZmYgPiAxODBcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkaWZmID4gbWF4KVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXggPSBkaWZmO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWF4QWJzb2x1dGUgPSBuZXdBbmdsZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZGlmZiA8IG1pbilcclxuICAgICAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWluID0gZGlmZjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1pbkFic29sdXRlID0gbmV3QW5nbGU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHZhbHNbdmFsSW5kZXhdID0gbWluQWJzb2x1dGU7XHJcbiAgICAgICAgICAgICAgICAgICAgKyt2YWxJbmRleDtcclxuICAgICAgICAgICAgICAgICAgICB2YWxzW3ZhbEluZGV4XSA9IG1heEFic29sdXRlO1xyXG4gICAgICAgICAgICAgICAgICAgICsrdmFsSW5kZXg7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIEFycmF5LlNvcnQ8ZmxvYXQ+KHZhbHMsIDAsIHZhbEluZGV4LCBfcmRjKTtcclxuICAgICAgICAgICAgX2RhdGEuQ2xlYXIoKTtcclxuICAgICAgICAgICAgYm9vbCByYXlNaXNzZWQgPSB0cnVlO1xyXG5cclxuICAgICAgICAgICAgZm9yIChpbnQgaSA9IDA7IGkgPCB2YWxJbmRleDsgKytpKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBGaXh0dXJlIHNoYXBlID0gbnVsbDtcclxuICAgICAgICAgICAgICAgIGZsb2F0IG1pZHB0O1xyXG5cclxuICAgICAgICAgICAgICAgIGludCBpcGx1cyA9IChpID09IHZhbEluZGV4IC0gMSA/IDAgOiBpICsgMSk7XHJcbiAgICAgICAgICAgICAgICBpZiAodmFsc1tpXSA9PSB2YWxzW2lwbHVzXSlcclxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoaSA9PSB2YWxJbmRleCAtIDEpXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gdGhlIHNpbmdsZSBlZGdlY2FzZVxyXG4gICAgICAgICAgICAgICAgICAgIG1pZHB0ID0gKHZhbHNbMF0gKyBNYXRoSGVscGVyLlBpICogMiArIHZhbHNbaV0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIG1pZHB0ID0gKHZhbHNbaSArIDFdICsgdmFsc1tpXSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgbWlkcHQgPSBtaWRwdCAvIDI7XHJcblxyXG4gICAgICAgICAgICAgICAgVmVjdG9yMiBwMSA9IHBvcztcclxuICAgICAgICAgICAgICAgIFZlY3RvcjIgcDIgPSByYWRpdXMgKiBuZXcgVmVjdG9yMigoZmxvYXQpTWF0aC5Db3MobWlkcHQpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoZmxvYXQpTWF0aC5TaW4obWlkcHQpKSArIHBvcztcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBSYXljYXN0T25lXHJcbiAgICAgICAgICAgICAgICBib29sIGhpdENsb3Nlc3QgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgIFdvcmxkLlJheUNhc3QoKGdsb2JhbDo6RmFyc2VlclBoeXNpY3MuRHluYW1pY3MuUmF5Q2FzdENhbGxiYWNrKSgoZiwgcCwgbiwgZnIpID0+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgQm9keSBib2R5ID0gZi5Cb2R5O1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIUlzQWN0aXZlT24oYm9keSkpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAwO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoYm9keS5Vc2VyRGF0YSAhPSBudWxsKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW50IGluZGV4ID0gKGludClib2R5LlVzZXJEYXRhO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaW5kZXggPT0gMClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZmlsdGVyXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gLTEuMGY7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhpdENsb3Nlc3QgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNoYXBlID0gZjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZnI7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KSwgcDEsIHAyKTtcclxuXHJcbiAgICAgICAgICAgICAgICAvL2RyYXdzIHJhZGl1cyBwb2ludHNcclxuICAgICAgICAgICAgICAgIGlmICgoaGl0Q2xvc2VzdCkgJiYgKHNoYXBlLkJvZHkuQm9keVR5cGUgPT0gQm9keVR5cGUuRHluYW1pYykpXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKChTeXN0ZW0uTGlucS5FbnVtZXJhYmxlLkNvdW50PGdsb2JhbDo6RmFyc2VlclBoeXNpY3MuQ29tbW9uLlBoeXNpY3NMb2dpYy5TaGFwZURhdGE+KF9kYXRhKSA+IDApICYmIChTeXN0ZW0uTGlucS5FbnVtZXJhYmxlLkxhc3Q8Z2xvYmFsOjpGYXJzZWVyUGh5c2ljcy5Db21tb24uUGh5c2ljc0xvZ2ljLlNoYXBlRGF0YT4oX2RhdGEpLkJvZHkgPT0gc2hhcGUuQm9keSkgJiYgKCFyYXlNaXNzZWQpKVxyXG4gICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaW50IGxhUG9zID0gX2RhdGEuQ291bnQgLSAxO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBTaGFwZURhdGEgbGEgPSBfZGF0YVtsYVBvc107XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxhLk1heCA9IHZhbHNbaXBsdXNdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBfZGF0YVtsYVBvc10gPSBsYTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gbWFrZSBuZXdcclxuICAgICAgICAgICAgICAgICAgICAgICAgU2hhcGVEYXRhIGQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGQuQm9keSA9IHNoYXBlLkJvZHk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGQuTWluID0gdmFsc1tpXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZC5NYXggPSB2YWxzW2lwbHVzXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgX2RhdGEuQWRkKGQpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKChTeXN0ZW0uTGlucS5FbnVtZXJhYmxlLkNvdW50PGdsb2JhbDo6RmFyc2VlclBoeXNpY3MuQ29tbW9uLlBoeXNpY3NMb2dpYy5TaGFwZURhdGE+KF9kYXRhKSA+IDEpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICYmIChpID09IHZhbEluZGV4IC0gMSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgJiYgKFN5c3RlbS5MaW5xLkVudW1lcmFibGUuTGFzdDxnbG9iYWw6OkZhcnNlZXJQaHlzaWNzLkNvbW1vbi5QaHlzaWNzTG9naWMuU2hhcGVEYXRhPihfZGF0YSkuQm9keSA9PSBTeXN0ZW0uTGlucS5FbnVtZXJhYmxlLkZpcnN0PGdsb2JhbDo6RmFyc2VlclBoeXNpY3MuQ29tbW9uLlBoeXNpY3NMb2dpYy5TaGFwZURhdGE+KF9kYXRhKS5Cb2R5KVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAmJiAoU3lzdGVtLkxpbnEuRW51bWVyYWJsZS5MYXN0PGdsb2JhbDo6RmFyc2VlclBoeXNpY3MuQ29tbW9uLlBoeXNpY3NMb2dpYy5TaGFwZURhdGE+KF9kYXRhKS5NYXggPT0gU3lzdGVtLkxpbnEuRW51bWVyYWJsZS5GaXJzdDxnbG9iYWw6OkZhcnNlZXJQaHlzaWNzLkNvbW1vbi5QaHlzaWNzTG9naWMuU2hhcGVEYXRhPihfZGF0YSkuTWluKSlcclxuICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIFNoYXBlRGF0YSBmaSA9IF9kYXRhWzBdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBmaS5NaW4gPSBTeXN0ZW0uTGlucS5FbnVtZXJhYmxlLkxhc3Q8Z2xvYmFsOjpGYXJzZWVyUGh5c2ljcy5Db21tb24uUGh5c2ljc0xvZ2ljLlNoYXBlRGF0YT4oX2RhdGEpLk1pbjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgX2RhdGEuUmVtb3ZlQXQoU3lzdGVtLkxpbnEuRW51bWVyYWJsZS5Db3VudDxnbG9iYWw6OkZhcnNlZXJQaHlzaWNzLkNvbW1vbi5QaHlzaWNzTG9naWMuU2hhcGVEYXRhPihfZGF0YSkgLSAxKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgX2RhdGFbMF0gPSBmaTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKFN5c3RlbS5MaW5xLkVudW1lcmFibGUuRmlyc3Q8Z2xvYmFsOjpGYXJzZWVyUGh5c2ljcy5Db21tb24uUGh5c2ljc0xvZ2ljLlNoYXBlRGF0YT4oX2RhdGEpLk1pbiA+PSBTeXN0ZW0uTGlucS5FbnVtZXJhYmxlLkZpcnN0PGdsb2JhbDo6RmFyc2VlclBoeXNpY3MuQ29tbW9uLlBoeXNpY3NMb2dpYy5TaGFwZURhdGE+KF9kYXRhKS5NYXgpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpLk1pbiAtPSBNYXRoSGVscGVyLlBpICogMjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9kYXRhWzBdID0gZmk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGludCBsYXN0UG9zID0gX2RhdGEuQ291bnQgLSAxO1xyXG4gICAgICAgICAgICAgICAgICAgIFNoYXBlRGF0YSBsYXN0ID0gX2RhdGFbbGFzdFBvc107XHJcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKChTeXN0ZW0uTGlucS5FbnVtZXJhYmxlLkNvdW50PGdsb2JhbDo6RmFyc2VlclBoeXNpY3MuQ29tbW9uLlBoeXNpY3NMb2dpYy5TaGFwZURhdGE+KF9kYXRhKSA+IDApXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICYmIChTeXN0ZW0uTGlucS5FbnVtZXJhYmxlLkxhc3Q8Z2xvYmFsOjpGYXJzZWVyUGh5c2ljcy5Db21tb24uUGh5c2ljc0xvZ2ljLlNoYXBlRGF0YT4oX2RhdGEpLk1pbiA+PSBTeXN0ZW0uTGlucS5FbnVtZXJhYmxlLkxhc3Q8Z2xvYmFsOjpGYXJzZWVyUGh5c2ljcy5Db21tb24uUGh5c2ljc0xvZ2ljLlNoYXBlRGF0YT4oX2RhdGEpLk1heCkpIC8vIGp1c3QgbWFraW5nIHN1cmUgbWluPG1heFxyXG4gICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGFzdC5NaW4gPSBTeXN0ZW0uTGlucS5FbnVtZXJhYmxlLkxhc3Q8Z2xvYmFsOjpGYXJzZWVyUGh5c2ljcy5Db21tb24uUGh5c2ljc0xvZ2ljLlNoYXBlRGF0YT4oX2RhdGEpLk1pbiAtIDIgKiBNYXRoSGVscGVyLlBpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBfZGF0YVtsYXN0UG9zXSA9IGxhc3Q7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHJheU1pc3NlZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIHJheU1pc3NlZCA9IHRydWU7IC8vIHJheWNhc3QgZGlkIG5vdCBmaW5kIGEgc2hhcGVcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgZm9yIChpbnQgaSA9IDA7IGkgPCBTeXN0ZW0uTGlucS5FbnVtZXJhYmxlLkNvdW50PGdsb2JhbDo6RmFyc2VlclBoeXNpY3MuQ29tbW9uLlBoeXNpY3NMb2dpYy5TaGFwZURhdGE+KF9kYXRhKTsgKytpKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIUlzQWN0aXZlT24oX2RhdGFbaV0uQm9keSkpXHJcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcblxyXG4gICAgICAgICAgICAgICAgZmxvYXQgYXJjbGVuID0gX2RhdGFbaV0uTWF4IC0gX2RhdGFbaV0uTWluO1xyXG5cclxuICAgICAgICAgICAgICAgIGZsb2F0IGZpcnN0ID0gTWF0aEhlbHBlci5NaW4oTWF4RWRnZU9mZnNldCwgRWRnZVJhdGlvICogYXJjbGVuKTtcclxuICAgICAgICAgICAgICAgIGludCBpbnNlcnRlZFJheXMgPSAoaW50KU1hdGguQ2VpbGluZygoKGFyY2xlbiAtIDIuMGYgKiBmaXJzdCkgLSAoTWluUmF5cyAtIDEpICogTWF4QW5nbGUpIC8gTWF4QW5nbGUpO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmIChpbnNlcnRlZFJheXMgPCAwKVxyXG4gICAgICAgICAgICAgICAgICAgIGluc2VydGVkUmF5cyA9IDA7XHJcblxyXG4gICAgICAgICAgICAgICAgZmxvYXQgb2Zmc2V0ID0gKGFyY2xlbiAtIGZpcnN0ICogMi4wZikgLyAoKGZsb2F0KU1pblJheXMgKyBpbnNlcnRlZFJheXMgLSAxKTtcclxuXHJcbiAgICAgICAgICAgICAgICAvL05vdGU6IFRoaXMgbG9vcCBjYW4gZ28gaW50byBpbmZpbml0ZSBhcyBpdCBvcGVyYXRlcyBvbiBmbG9hdHMuXHJcbiAgICAgICAgICAgICAgICAvL0FkZGVkIEZsb2F0RXF1YWxzIHdpdGggYSBsYXJnZSBlcHNpbG9uLlxyXG4gICAgICAgICAgICAgICAgZm9yIChmbG9hdCBqID0gX2RhdGFbaV0uTWluICsgZmlyc3Q7XHJcbiAgICAgICAgICAgICAgICAgICAgIGogPCBfZGF0YVtpXS5NYXggfHwgTWF0aFV0aWxzLkZsb2F0RXF1YWxzKGosIF9kYXRhW2ldLk1heCwgMC4wMDAxZik7XHJcbiAgICAgICAgICAgICAgICAgICAgIGogKz0gb2Zmc2V0KVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIFZlY3RvcjIgcDEgPSBwb3M7XHJcbiAgICAgICAgICAgICAgICAgICAgVmVjdG9yMiBwMiA9IHBvcyArIHJhZGl1cyAqIG5ldyBWZWN0b3IyKChmbG9hdClNYXRoLkNvcyhqKSwgKGZsb2F0KU1hdGguU2luKGopKTtcclxuICAgICAgICAgICAgICAgICAgICBWZWN0b3IyIGhpdHBvaW50ID0gVmVjdG9yMi5aZXJvO1xyXG4gICAgICAgICAgICAgICAgICAgIGZsb2F0IG1pbmxhbWJkYSA9IGZsb2F0Lk1heFZhbHVlO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBMaXN0PEZpeHR1cmU+IGZsID0gX2RhdGFbaV0uQm9keS5GaXh0dXJlTGlzdDtcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKGludCB4ID0gMDsgeCA8IGZsLkNvdW50OyB4KyspXHJcbiAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBGaXh0dXJlIGYgPSBmbFt4XTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgUmF5Q2FzdElucHV0IHJpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByaS5Qb2ludDEgPSBwMTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmkuUG9pbnQyID0gcDI7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJpLk1heEZyYWN0aW9uID0gNTBmO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgUmF5Q2FzdE91dHB1dCBybztcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGYuUmF5Q2FzdChvdXQgcm8sIHJlZiByaSwgMCkpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtaW5sYW1iZGEgPiByby5GcmFjdGlvbilcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtaW5sYW1iZGEgPSByby5GcmFjdGlvbjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBoaXRwb2ludCA9IHJvLkZyYWN0aW9uICogcDIgKyAoMSAtIHJvLkZyYWN0aW9uKSAqIHAxO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB0aGUgZm9yY2UgdGhhdCBpcyB0byBiZSBhcHBsaWVkIGZvciB0aGlzIHBhcnRpY3VsYXIgcmF5LlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBvZmZzZXQgaXMgYW5ndWxhciBjb3ZlcmFnZS4gbGFtYmRhKmxlbmd0aCBvZiBzZWdtZW50IGlzIGRpc3RhbmNlLlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBmbG9hdCBpbXB1bHNlID0gKGFyY2xlbiAvIChNaW5SYXlzICsgaW5zZXJ0ZWRSYXlzKSkgKiBtYXhGb3JjZSAqIDE4MC4wZiAvIE1hdGhIZWxwZXIuUGkgKlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKDEuMGYgLSBNYXRoLk1pbigxLjBmLCBtaW5sYW1iZGEpKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFdlIEFwcGx5IHRoZSBpbXB1bHNlISEhXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIFZlY3RvcjIgdmVjdEltcCA9IFZlY3RvcjIuRG90KGltcHVsc2UgKiBuZXcgVmVjdG9yMigoZmxvYXQpTWF0aC5Db3MoaiksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKGZsb2F0KU1hdGguU2luKGopKSwgLXJvLk5vcm1hbCkgKlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXcgVmVjdG9yMigoZmxvYXQpTWF0aC5Db3MoaiksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChmbG9hdClNYXRoLlNpbihqKSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBfZGF0YVtpXS5Cb2R5LkFwcGx5TGluZWFySW1wdWxzZShyZWYgdmVjdEltcCwgcmVmIGhpdHBvaW50KTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFdlIGdhdGhlciB0aGUgZml4dHVyZXMgZm9yIHJldHVybmluZyB0aGVtXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIFZlY3RvcjIgdmFsID0gVmVjdG9yMi5aZXJvO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBMaXN0PFZlY3RvcjI+IHZlY3Rvckxpc3Q7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChfZXhwbG9kZWQuVHJ5R2V0VmFsdWUoZiwgb3V0IHZlY3Rvckxpc3QpKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWwuWCArPSAoZmxvYXQpTWF0aC5BYnModmVjdEltcC5YKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbC5ZICs9IChmbG9hdClNYXRoLkFicyh2ZWN0SW1wLlkpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZlY3Rvckxpc3QuQWRkKHZhbCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2ZWN0b3JMaXN0ID0gbmV3IExpc3Q8VmVjdG9yMj4oKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbC5YID0gKGZsb2F0KU1hdGguQWJzKHZlY3RJbXAuWCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWwuWSA9IChmbG9hdClNYXRoLkFicyh2ZWN0SW1wLlkpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZlY3Rvckxpc3QuQWRkKHZhbCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfZXhwbG9kZWQuQWRkKGYsIHZlY3Rvckxpc3QpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobWlubGFtYmRhID4gMS4wZilcclxuICAgICAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaGl0cG9pbnQgPSBwMjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gV2UgY2hlY2sgY29udGFpbmVkIHNoYXBlc1xyXG4gICAgICAgICAgICBmb3IgKGludCBpID0gMDsgaSA8IGNvbnRhaW5lZFNoYXBlQ291bnQ7ICsraSlcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgRml4dHVyZSBmaXggPSBjb250YWluZWRTaGFwZXNbaV07XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKCFJc0FjdGl2ZU9uKGZpeC5Cb2R5KSlcclxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuXHJcbiAgICAgICAgICAgICAgICBmbG9hdCBpbXB1bHNlID0gTWluUmF5cyAqIG1heEZvcmNlICogMTgwLjBmIC8gTWF0aEhlbHBlci5QaTtcclxuICAgICAgICAgICAgICAgIFZlY3RvcjIgaGl0UG9pbnQ7XHJcblxyXG4gICAgICAgICAgICAgICAgQ2lyY2xlU2hhcGUgY2lyY1NoYXBlID0gZml4LlNoYXBlIGFzIENpcmNsZVNoYXBlO1xyXG4gICAgICAgICAgICAgICAgaWYgKGNpcmNTaGFwZSAhPSBudWxsKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIGhpdFBvaW50ID0gZml4LkJvZHkuR2V0V29ybGRQb2ludChjaXJjU2hhcGUuUG9zaXRpb24pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIFBvbHlnb25TaGFwZSBzaGFwZSA9IGZpeC5TaGFwZSBhcyBQb2x5Z29uU2hhcGU7XHJcbiAgICAgICAgICAgICAgICAgICAgaGl0UG9pbnQgPSBmaXguQm9keS5HZXRXb3JsZFBvaW50KHNoYXBlLk1hc3NEYXRhLkNlbnRyb2lkKTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBWZWN0b3IyIHZlY3RJbXAgPSBpbXB1bHNlICogKGhpdFBvaW50IC0gcG9zKTtcclxuXHJcbiAgICAgICAgICAgICAgICBMaXN0PFZlY3RvcjI+IHZlY3Rvckxpc3QgPSBuZXcgTGlzdDxWZWN0b3IyPigpO1xyXG4gICAgICAgICAgICAgICAgdmVjdG9yTGlzdC5BZGQodmVjdEltcCk7XHJcblxyXG4gICAgICAgICAgICAgICAgZml4LkJvZHkuQXBwbHlMaW5lYXJJbXB1bHNlKHJlZiB2ZWN0SW1wLCByZWYgaGl0UG9pbnQpO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmICghX2V4cGxvZGVkLkNvbnRhaW5zS2V5KGZpeCkpXHJcbiAgICAgICAgICAgICAgICAgICAgX2V4cGxvZGVkLkFkZChmaXgsIHZlY3Rvckxpc3QpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gX2V4cGxvZGVkO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufSIsInVzaW5nIFN5c3RlbS5Db2xsZWN0aW9ucy5HZW5lcmljO1xyXG51c2luZyBTeXN0ZW0uRGlhZ25vc3RpY3M7XHJcbnVzaW5nIEZhcnNlZXJQaHlzaWNzLkNvbGxpc2lvbi5TaGFwZXM7XHJcbnVzaW5nIEZhcnNlZXJQaHlzaWNzLkR5bmFtaWNzO1xyXG51c2luZyBGYXJzZWVyUGh5c2ljcy5GYWN0b3JpZXM7XHJcbnVzaW5nIE1pY3Jvc29mdC5YbmEuRnJhbWV3b3JrO1xyXG5cclxubmFtZXNwYWNlIEZhcnNlZXJQaHlzaWNzLkNvbW1vbi5Qb2x5Z29uTWFuaXB1bGF0aW9uXHJcbntcclxuICAgIHB1YmxpYyBzdGF0aWMgY2xhc3MgQ3V0dGluZ1Rvb2xzXHJcbiAgICB7XHJcbiAgICAgICAgLy9DdXR0aW5nIGEgc2hhcGUgaW50byB0d28gaXMgYmFzZWQgb24gdGhlIHdvcmsgb2YgRGFpZCBhbmQgaGlzIHByb3RvdHlwZSBCb3hDdXR0ZXI6IGh0dHA6Ly93d3cuYm94MmQub3JnL2ZvcnVtL3ZpZXd0b3BpYy5waHA/Zj0zJnQ9MTQ3M1xyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIFNwbGl0IGEgZml4dHVyZSBpbnRvIDIgdmVydGljZSBjb2xsZWN0aW9ucyB1c2luZyB0aGUgZ2l2ZW4gZW50cnkgYW5kIGV4aXQtcG9pbnQuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJmaXh0dXJlXCI+VGhlIEZpeHR1cmUgdG8gc3BsaXQ8L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cImVudHJ5UG9pbnRcIj5UaGUgZW50cnkgcG9pbnQgLSBUaGUgc3RhcnQgcG9pbnQ8L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cImV4aXRQb2ludFwiPlRoZSBleGl0IHBvaW50IC0gVGhlIGVuZCBwb2ludDwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwic3BsaXRTaXplXCI+VGhlIHNpemUgb2YgdGhlIHNwbGl0LiBUaGluayBvZiB0aGlzIGFzIHRoZSBsYXNlci13aWR0aDwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwiZmlyc3RcIj5UaGUgZmlyc3QgY29sbGVjdGlvbiBvZiB2ZXJ0ZXhlczwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwic2Vjb25kXCI+VGhlIHNlY29uZCBjb2xsZWN0aW9uIG9mIHZlcnRleGVzPC9wYXJhbT5cclxuICAgICAgICBwdWJsaWMgc3RhdGljIHZvaWQgU3BsaXRTaGFwZShGaXh0dXJlIGZpeHR1cmUsIFZlY3RvcjIgZW50cnlQb2ludCwgVmVjdG9yMiBleGl0UG9pbnQsIGZsb2F0IHNwbGl0U2l6ZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdXQgVmVydGljZXMgZmlyc3QsIG91dCBWZXJ0aWNlcyBzZWNvbmQpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBWZWN0b3IyIGxvY2FsRW50cnlQb2ludCA9IGZpeHR1cmUuQm9keS5HZXRMb2NhbFBvaW50KHJlZiBlbnRyeVBvaW50KTtcclxuICAgICAgICAgICAgVmVjdG9yMiBsb2NhbEV4aXRQb2ludCA9IGZpeHR1cmUuQm9keS5HZXRMb2NhbFBvaW50KHJlZiBleGl0UG9pbnQpO1xyXG5cclxuICAgICAgICAgICAgUG9seWdvblNoYXBlIHNoYXBlID0gZml4dHVyZS5TaGFwZSBhcyBQb2x5Z29uU2hhcGU7XHJcblxyXG4gICAgICAgICAgICBpZiAoc2hhcGUgPT0gbnVsbClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgZmlyc3QgPSBuZXcgVmVydGljZXMoKTtcclxuICAgICAgICAgICAgICAgIHNlY29uZCA9IG5ldyBWZXJ0aWNlcygpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBWZXJ0aWNlcyB2ZXJ0aWNlcyA9IG5ldyBWZXJ0aWNlcyhzaGFwZS5WZXJ0aWNlcyk7XHJcbiAgICAgICAgICAgIFZlcnRpY2VzW10gbmV3UG9seWdvbiA9IG5ldyBWZXJ0aWNlc1syXTtcclxuXHJcbiAgICAgICAgICAgIGZvciAoaW50IGkgPSAwOyBpIDwgbmV3UG9seWdvbi5MZW5ndGg7IGkrKylcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgbmV3UG9seWdvbltpXSA9IG5ldyBWZXJ0aWNlcyh2ZXJ0aWNlcy5Db3VudCk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGludFtdIGN1dEFkZGVkID0geyAtMSwgLTEgfTtcclxuICAgICAgICAgICAgaW50IGxhc3QgPSAtMTtcclxuICAgICAgICAgICAgZm9yIChpbnQgaSA9IDA7IGkgPCB2ZXJ0aWNlcy5Db3VudDsgaSsrKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBpbnQgbjtcclxuICAgICAgICAgICAgICAgIC8vRmluZCBvdXQgaWYgdGhpcyB2ZXJ0ZXggaXMgb24gdGhlIG9sZCBvciBuZXcgc2hhcGUuXHJcbiAgICAgICAgICAgICAgICBpZiAoVmVjdG9yMi5Eb3QoTWF0aFV0aWxzLkNyb3NzKGxvY2FsRXhpdFBvaW50IC0gbG9jYWxFbnRyeVBvaW50LCAxKSwgdmVydGljZXNbaV0gLSBsb2NhbEVudHJ5UG9pbnQpID4gU2V0dGluZ3MuRXBzaWxvbilcclxuICAgICAgICAgICAgICAgICAgICBuID0gMDtcclxuICAgICAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgICAgICBuID0gMTtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAobGFzdCAhPSBuKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vSWYgd2Ugc3dpdGNoIGZyb20gb25lIHNoYXBlIHRvIHRoZSBvdGhlciBhZGQgdGhlIGN1dCB2ZXJ0aWNlcy5cclxuICAgICAgICAgICAgICAgICAgICBpZiAobGFzdCA9PSAwKVxyXG4gICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgRGVidWcuQXNzZXJ0KGN1dEFkZGVkWzBdID09IC0xKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY3V0QWRkZWRbMF0gPSBuZXdQb2x5Z29uW2xhc3RdLkNvdW50O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdQb2x5Z29uW2xhc3RdLkFkZChsb2NhbEV4aXRQb2ludCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ld1BvbHlnb25bbGFzdF0uQWRkKGxvY2FsRW50cnlQb2ludCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChsYXN0ID09IDEpXHJcbiAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBEZWJ1Zy5Bc3NlcnQoY3V0QWRkZWRbbGFzdF0gPT0gLTEpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjdXRBZGRlZFtsYXN0XSA9IG5ld1BvbHlnb25bbGFzdF0uQ291bnQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ld1BvbHlnb25bbGFzdF0uQWRkKGxvY2FsRW50cnlQb2ludCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ld1BvbHlnb25bbGFzdF0uQWRkKGxvY2FsRXhpdFBvaW50KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgbmV3UG9seWdvbltuXS5BZGQodmVydGljZXNbaV0pO1xyXG4gICAgICAgICAgICAgICAgbGFzdCA9IG47XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vQWRkIHRoZSBjdXQgaW4gY2FzZSBpdCBoYXMgbm90IGJlZW4gYWRkZWQgeWV0LlxyXG4gICAgICAgICAgICBpZiAoY3V0QWRkZWRbMF0gPT0gLTEpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGN1dEFkZGVkWzBdID0gbmV3UG9seWdvblswXS5Db3VudDtcclxuICAgICAgICAgICAgICAgIG5ld1BvbHlnb25bMF0uQWRkKGxvY2FsRXhpdFBvaW50KTtcclxuICAgICAgICAgICAgICAgIG5ld1BvbHlnb25bMF0uQWRkKGxvY2FsRW50cnlQb2ludCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGN1dEFkZGVkWzFdID09IC0xKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBjdXRBZGRlZFsxXSA9IG5ld1BvbHlnb25bMV0uQ291bnQ7XHJcbiAgICAgICAgICAgICAgICBuZXdQb2x5Z29uWzFdLkFkZChsb2NhbEVudHJ5UG9pbnQpO1xyXG4gICAgICAgICAgICAgICAgbmV3UG9seWdvblsxXS5BZGQobG9jYWxFeGl0UG9pbnQpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBmb3IgKGludCBuID0gMDsgbiA8IDI7IG4rKylcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgVmVjdG9yMiBvZmZzZXQ7XHJcbiAgICAgICAgICAgICAgICBpZiAoY3V0QWRkZWRbbl0gPiAwKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIG9mZnNldCA9IChuZXdQb2x5Z29uW25dW2N1dEFkZGVkW25dIC0gMV0gLSBuZXdQb2x5Z29uW25dW2N1dEFkZGVkW25dXSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgb2Zmc2V0ID0gKG5ld1BvbHlnb25bbl1bbmV3UG9seWdvbltuXS5Db3VudCAtIDFdIC0gbmV3UG9seWdvbltuXVswXSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBvZmZzZXQuTm9ybWFsaXplKCk7XHJcblxyXG4gICAgICAgICAgICAgICAgbmV3UG9seWdvbltuXVtjdXRBZGRlZFtuXV0gKz0gc3BsaXRTaXplICogb2Zmc2V0O1xyXG5cclxuICAgICAgICAgICAgICAgIGlmIChjdXRBZGRlZFtuXSA8IG5ld1BvbHlnb25bbl0uQ291bnQgLSAyKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIG9mZnNldCA9IChuZXdQb2x5Z29uW25dW2N1dEFkZGVkW25dICsgMl0gLSBuZXdQb2x5Z29uW25dW2N1dEFkZGVkW25dICsgMV0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIG9mZnNldCA9IChuZXdQb2x5Z29uW25dWzBdIC0gbmV3UG9seWdvbltuXVtuZXdQb2x5Z29uW25dLkNvdW50IC0gMV0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgb2Zmc2V0Lk5vcm1hbGl6ZSgpO1xyXG5cclxuICAgICAgICAgICAgICAgIG5ld1BvbHlnb25bbl1bY3V0QWRkZWRbbl0gKyAxXSArPSBzcGxpdFNpemUgKiBvZmZzZXQ7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGZpcnN0ID0gbmV3UG9seWdvblswXTtcclxuICAgICAgICAgICAgc2Vjb25kID0gbmV3UG9seWdvblsxXTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gVGhpcyBpcyBhIGhpZ2gtbGV2ZWwgZnVuY3Rpb24gdG8gY3V0cyBmaXh0dXJlcyBpbnNpZGUgdGhlIGdpdmVuIHdvcmxkLCB1c2luZyB0aGUgc3RhcnQgYW5kIGVuZCBwb2ludHMuXHJcbiAgICAgICAgLy8vIE5vdGU6IFdlIGRvbid0IHN1cHBvcnQgY3V0dGluZyB3aGVuIHRoZSBzdGFydCBvciBlbmQgaXMgaW5zaWRlIGEgc2hhcGUuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJ3b3JsZFwiPlRoZSB3b3JsZC48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cInN0YXJ0XCI+VGhlIHN0YXJ0cG9pbnQuPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJlbmRcIj5UaGUgZW5kcG9pbnQuPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJ0aGlja25lc3NcIj5UaGUgdGhpY2tuZXNzIG9mIHRoZSBjdXQ8L3BhcmFtPlxyXG4gICAgICAgIHB1YmxpYyBzdGF0aWMgdm9pZCBDdXQoV29ybGQgd29ybGQsIFZlY3RvcjIgc3RhcnQsIFZlY3RvcjIgZW5kLCBmbG9hdCB0aGlja25lc3MpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBMaXN0PEZpeHR1cmU+IGZpeHR1cmVzID0gbmV3IExpc3Q8Rml4dHVyZT4oKTtcclxuICAgICAgICAgICAgTGlzdDxWZWN0b3IyPiBlbnRyeVBvaW50cyA9IG5ldyBMaXN0PFZlY3RvcjI+KCk7XHJcbiAgICAgICAgICAgIExpc3Q8VmVjdG9yMj4gZXhpdFBvaW50cyA9IG5ldyBMaXN0PFZlY3RvcjI+KCk7XHJcblxyXG4gICAgICAgICAgICAvL1dlIGRvbid0IHN1cHBvcnQgY3V0dGluZyB3aGVuIHRoZSBzdGFydCBvciBlbmQgaXMgaW5zaWRlIGEgc2hhcGUuXHJcbiAgICAgICAgICAgIGlmICh3b3JsZC5UZXN0UG9pbnQoc3RhcnQpICE9IG51bGwgfHwgd29ybGQuVGVzdFBvaW50KGVuZCkgIT0gbnVsbClcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuXHJcbiAgICAgICAgICAgIC8vR2V0IHRoZSBlbnRyeSBwb2ludHNcclxuICAgICAgICAgICAgd29ybGQuUmF5Q2FzdCgoZ2xvYmFsOjpGYXJzZWVyUGh5c2ljcy5EeW5hbWljcy5SYXlDYXN0Q2FsbGJhY2spKChmLCBwLCBuLCBmcikgPT5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZml4dHVyZXMuQWRkKGYpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZW50cnlQb2ludHMuQWRkKHApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDE7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pLCBzdGFydCwgZW5kKTtcclxuXHJcbiAgICAgICAgICAgIC8vUmV2ZXJzZSB0aGUgcmF5IHRvIGdldCB0aGUgZXhpdHBvaW50c1xyXG4gICAgICAgICAgICB3b3JsZC5SYXlDYXN0KChnbG9iYWw6OkZhcnNlZXJQaHlzaWNzLkR5bmFtaWNzLlJheUNhc3RDYWxsYmFjaykoKGYsIHAsIG4sIGZyKSA9PlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBleGl0UG9pbnRzLkFkZChwKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAxO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KSwgZW5kLCBzdGFydCk7XHJcblxyXG4gICAgICAgICAgICAvL1dlIG9ubHkgaGF2ZSBhIHNpbmdsZSBwb2ludC4gV2UgbmVlZCBhdCBsZWFzdCAyXHJcbiAgICAgICAgICAgIGlmIChlbnRyeVBvaW50cy5Db3VudCArIGV4aXRQb2ludHMuQ291bnQgPCAyKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG5cclxuICAgICAgICAgICAgZm9yIChpbnQgaSA9IDA7IGkgPCBmaXh0dXJlcy5Db3VudDsgaSsrKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAvLyBjYW4ndCBjdXQgY2lyY2xlcyB5ZXQgIVxyXG4gICAgICAgICAgICAgICAgaWYgKGZpeHR1cmVzW2ldLlNoYXBlLlNoYXBlVHlwZSAhPSBTaGFwZVR5cGUuUG9seWdvbilcclxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoZml4dHVyZXNbaV0uQm9keS5Cb2R5VHlwZSAhPSBCb2R5VHlwZS5TdGF0aWMpXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy9TcGxpdCB0aGUgc2hhcGUgdXAgaW50byB0d28gc2hhcGVzXHJcbiAgICAgICAgICAgICAgICAgICAgVmVydGljZXMgZmlyc3Q7XHJcbiAgICAgICAgICAgICAgICAgICAgVmVydGljZXMgc2Vjb25kO1xyXG4gICAgICAgICAgICAgICAgICAgIFNwbGl0U2hhcGUoZml4dHVyZXNbaV0sIGVudHJ5UG9pbnRzW2ldLCBleGl0UG9pbnRzW2ldLCB0aGlja25lc3MsIG91dCBmaXJzdCwgb3V0IHNlY29uZCk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vRGVsZXRlIHRoZSBvcmlnaW5hbCBzaGFwZSBhbmQgY3JlYXRlIHR3byBuZXcuIFJldGFpbiB0aGUgcHJvcGVydGllcyBvZiB0aGUgYm9keS5cclxuICAgICAgICAgICAgICAgICAgICBpZiAoU2FuaXR5Q2hlY2soZmlyc3QpKVxyXG4gICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgQm9keSBmaXJzdEZpeHR1cmUgPSBCb2R5RmFjdG9yeS5DcmVhdGVQb2x5Z29uKHdvcmxkLCBmaXJzdCwgZml4dHVyZXNbaV0uU2hhcGUuRGVuc2l0eSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpeHR1cmVzW2ldLkJvZHkuUG9zaXRpb24pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBmaXJzdEZpeHR1cmUuUm90YXRpb24gPSBmaXh0dXJlc1tpXS5Cb2R5LlJvdGF0aW9uO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBmaXJzdEZpeHR1cmUuTGluZWFyVmVsb2NpdHkgPSBmaXh0dXJlc1tpXS5Cb2R5LkxpbmVhclZlbG9jaXR5O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBmaXJzdEZpeHR1cmUuQW5ndWxhclZlbG9jaXR5ID0gZml4dHVyZXNbaV0uQm9keS5Bbmd1bGFyVmVsb2NpdHk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpcnN0Rml4dHVyZS5Cb2R5VHlwZSA9IEJvZHlUeXBlLkR5bmFtaWM7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZiAoU2FuaXR5Q2hlY2soc2Vjb25kKSlcclxuICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIEJvZHkgc2Vjb25kRml4dHVyZSA9IEJvZHlGYWN0b3J5LkNyZWF0ZVBvbHlnb24od29ybGQsIHNlY29uZCwgZml4dHVyZXNbaV0uU2hhcGUuRGVuc2l0eSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaXh0dXJlc1tpXS5Cb2R5LlBvc2l0aW9uKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2Vjb25kRml4dHVyZS5Sb3RhdGlvbiA9IGZpeHR1cmVzW2ldLkJvZHkuUm90YXRpb247XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlY29uZEZpeHR1cmUuTGluZWFyVmVsb2NpdHkgPSBmaXh0dXJlc1tpXS5Cb2R5LkxpbmVhclZlbG9jaXR5O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzZWNvbmRGaXh0dXJlLkFuZ3VsYXJWZWxvY2l0eSA9IGZpeHR1cmVzW2ldLkJvZHkuQW5ndWxhclZlbG9jaXR5O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzZWNvbmRGaXh0dXJlLkJvZHlUeXBlID0gQm9keVR5cGUuRHluYW1pYztcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgd29ybGQuUmVtb3ZlQm9keShmaXh0dXJlc1tpXS5Cb2R5KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHJpdmF0ZSBzdGF0aWMgYm9vbCBTYW5pdHlDaGVjayhWZXJ0aWNlcyB2ZXJ0aWNlcylcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGlmICh2ZXJ0aWNlcy5Db3VudCA8IDMpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcblxyXG4gICAgICAgICAgICBpZiAodmVydGljZXMuR2V0QXJlYSgpIDwgMC4wMDAwMWYpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcblxyXG4gICAgICAgICAgICBmb3IgKGludCBpID0gMDsgaSA8IHZlcnRpY2VzLkNvdW50OyArK2kpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGludCBpMSA9IGk7XHJcbiAgICAgICAgICAgICAgICBpbnQgaTIgPSBpICsgMSA8IHZlcnRpY2VzLkNvdW50ID8gaSArIDEgOiAwO1xyXG4gICAgICAgICAgICAgICAgVmVjdG9yMiBlZGdlID0gdmVydGljZXNbaTJdIC0gdmVydGljZXNbaTFdO1xyXG4gICAgICAgICAgICAgICAgaWYgKGVkZ2UuTGVuZ3RoU3F1YXJlZCgpIDwgU2V0dGluZ3MuRXBzaWxvbiAqIFNldHRpbmdzLkVwc2lsb24pXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBmb3IgKGludCBpID0gMDsgaSA8IHZlcnRpY2VzLkNvdW50OyArK2kpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGludCBpMSA9IGk7XHJcbiAgICAgICAgICAgICAgICBpbnQgaTIgPSBpICsgMSA8IHZlcnRpY2VzLkNvdW50ID8gaSArIDEgOiAwO1xyXG4gICAgICAgICAgICAgICAgVmVjdG9yMiBlZGdlID0gdmVydGljZXNbaTJdIC0gdmVydGljZXNbaTFdO1xyXG5cclxuICAgICAgICAgICAgICAgIGZvciAoaW50IGogPSAwOyBqIDwgdmVydGljZXMuQ291bnQ7ICsrailcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBEb24ndCBjaGVjayB2ZXJ0aWNlcyBvbiB0aGUgY3VycmVudCBlZGdlLlxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChqID09IGkxIHx8IGogPT0gaTIpXHJcbiAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIFZlY3RvcjIgciA9IHZlcnRpY2VzW2pdIC0gdmVydGljZXNbaTFdO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBZb3VyIHBvbHlnb24gaXMgbm9uLWNvbnZleCAoaXQgaGFzIGFuIGluZGVudGF0aW9uKSBvclxyXG4gICAgICAgICAgICAgICAgICAgIC8vIGhhcyBjb2xpbmVhciBlZGdlcy5cclxuICAgICAgICAgICAgICAgICAgICBmbG9hdCBzID0gZWRnZS5YICogci5ZIC0gZWRnZS5ZICogci5YO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZiAocyA8IDAuMGYpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59IiwidXNpbmcgU3lzdGVtO1xyXG51c2luZyBTeXN0ZW0uQ29sbGVjdGlvbnMuR2VuZXJpYztcclxudXNpbmcgU3lzdGVtLkRpYWdub3N0aWNzO1xyXG51c2luZyBNaWNyb3NvZnQuWG5hLkZyYW1ld29yaztcclxuXHJcbm5hbWVzcGFjZSBGYXJzZWVyUGh5c2ljcy5Db21tb24uUG9seWdvbk1hbmlwdWxhdGlvblxyXG57XHJcbiAgICBwdWJsaWMgc3RhdGljIGNsYXNzIFNpbXBsaWZ5VG9vbHNcclxuICAgIHtcclxuICAgICAgICBwcml2YXRlIHN0YXRpYyBib29sW10gX3VzZVB0O1xyXG4gICAgICAgIHByaXZhdGUgc3RhdGljIGRvdWJsZSBfZGlzdGFuY2VUb2xlcmFuY2U7XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gUmVtb3ZlcyBhbGwgY29sbGluZWFyIHBvaW50cyBvbiB0aGUgcG9seWdvbi5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cInZlcnRpY2VzXCI+VGhlIHBvbHlnb24gdGhhdCBuZWVkcyBzaW1wbGlmaWNhdGlvbi48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cImNvbGxpbmVhcml0eVRvbGVyYW5jZVwiPlRoZSBjb2xsaW5lYXJpdHkgdG9sZXJhbmNlLjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxyZXR1cm5zPkEgc2ltcGxpZmllZCBwb2x5Z29uLjwvcmV0dXJucz5cclxuICAgICAgICBwdWJsaWMgc3RhdGljIFZlcnRpY2VzIENvbGxpbmVhclNpbXBsaWZ5KFZlcnRpY2VzIHZlcnRpY2VzLCBmbG9hdCBjb2xsaW5lYXJpdHlUb2xlcmFuY2UpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICAvL1dlIGNhbid0IHNpbXBsaWZ5IHBvbHlnb25zIHVuZGVyIDMgdmVydGljZXNcclxuICAgICAgICAgICAgaWYgKHZlcnRpY2VzLkNvdW50IDwgMylcclxuICAgICAgICAgICAgICAgIHJldHVybiB2ZXJ0aWNlcztcclxuXHJcbiAgICAgICAgICAgIFZlcnRpY2VzIHNpbXBsaWZpZWQgPSBuZXcgVmVydGljZXMoKTtcclxuXHJcbiAgICAgICAgICAgIGZvciAoaW50IGkgPSAwOyBpIDwgdmVydGljZXMuQ291bnQ7IGkrKylcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgaW50IHByZXZJZCA9IHZlcnRpY2VzLlByZXZpb3VzSW5kZXgoaSk7XHJcbiAgICAgICAgICAgICAgICBpbnQgbmV4dElkID0gdmVydGljZXMuTmV4dEluZGV4KGkpO1xyXG5cclxuICAgICAgICAgICAgICAgIFZlY3RvcjIgcHJldiA9IHZlcnRpY2VzW3ByZXZJZF07XHJcbiAgICAgICAgICAgICAgICBWZWN0b3IyIGN1cnJlbnQgPSB2ZXJ0aWNlc1tpXTtcclxuICAgICAgICAgICAgICAgIFZlY3RvcjIgbmV4dCA9IHZlcnRpY2VzW25leHRJZF07XHJcblxyXG4gICAgICAgICAgICAgICAgLy9JZiB0aGV5IGNvbGxpbmVhciwgY29udGludWVcclxuICAgICAgICAgICAgICAgIGlmIChNYXRoVXRpbHMuQ29sbGluZWFyKHJlZiBwcmV2LCByZWYgY3VycmVudCwgcmVmIG5leHQsIGNvbGxpbmVhcml0eVRvbGVyYW5jZSkpXHJcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcblxyXG4gICAgICAgICAgICAgICAgc2ltcGxpZmllZC5BZGQoY3VycmVudCk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHJldHVybiBzaW1wbGlmaWVkO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBSZW1vdmVzIGFsbCBjb2xsaW5lYXIgcG9pbnRzIG9uIHRoZSBwb2x5Z29uLlxyXG4gICAgICAgIC8vLyBIYXMgYSBkZWZhdWx0IGJpYXMgb2YgMFxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwidmVydGljZXNcIj5UaGUgcG9seWdvbiB0aGF0IG5lZWRzIHNpbXBsaWZpY2F0aW9uLjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxyZXR1cm5zPkEgc2ltcGxpZmllZCBwb2x5Z29uLjwvcmV0dXJucz5cclxuICAgICAgICBwdWJsaWMgc3RhdGljIFZlcnRpY2VzIENvbGxpbmVhclNpbXBsaWZ5KFZlcnRpY2VzIHZlcnRpY2VzKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIENvbGxpbmVhclNpbXBsaWZ5KHZlcnRpY2VzLCAwKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gUmFtZXItRG91Z2xhcy1QZXVja2VyIHBvbHlnb24gc2ltcGxpZmljYXRpb24gYWxnb3JpdGhtLiBUaGlzIGlzIHRoZSBnZW5lcmFsIHJlY3Vyc2l2ZSB2ZXJzaW9uIHRoYXQgZG9lcyBub3QgdXNlIHRoZVxyXG4gICAgICAgIC8vLyBzcGVlZC11cCB0ZWNobmlxdWUgYnkgdXNpbmcgdGhlIE1lbGttYW4gY29udmV4IGh1bGwuXHJcbiAgICAgICAgLy8vIFxyXG4gICAgICAgIC8vLyBJZiB5b3UgcGFzcyBpbiAwLCBpdCB3aWxsIHJlbW92ZSBhbGwgY29sbGluZWFyIHBvaW50c1xyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDxyZXR1cm5zPlRoZSBzaW1wbGlmaWVkIHBvbHlnb248L3JldHVybnM+XHJcbiAgICAgICAgcHVibGljIHN0YXRpYyBWZXJ0aWNlcyBEb3VnbGFzUGV1Y2tlclNpbXBsaWZ5KFZlcnRpY2VzIHZlcnRpY2VzLCBmbG9hdCBkaXN0YW5jZVRvbGVyYW5jZSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIF9kaXN0YW5jZVRvbGVyYW5jZSA9IGRpc3RhbmNlVG9sZXJhbmNlO1xyXG5cclxuICAgICAgICAgICAgX3VzZVB0ID0gbmV3IGJvb2xbdmVydGljZXMuQ291bnRdO1xyXG4gICAgICAgICAgICBmb3IgKGludCBpID0gMDsgaSA8IHZlcnRpY2VzLkNvdW50OyBpKyspXHJcbiAgICAgICAgICAgICAgICBfdXNlUHRbaV0gPSB0cnVlO1xyXG5cclxuICAgICAgICAgICAgU2ltcGxpZnlTZWN0aW9uKHZlcnRpY2VzLCAwLCB2ZXJ0aWNlcy5Db3VudCAtIDEpO1xyXG4gICAgICAgICAgICBWZXJ0aWNlcyByZXN1bHQgPSBuZXcgVmVydGljZXMoKTtcclxuXHJcbiAgICAgICAgICAgIGZvciAoaW50IGkgPSAwOyBpIDwgdmVydGljZXMuQ291bnQ7IGkrKylcclxuICAgICAgICAgICAgICAgIGlmIChfdXNlUHRbaV0pXHJcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LkFkZCh2ZXJ0aWNlc1tpXSk7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHJpdmF0ZSBzdGF0aWMgdm9pZCBTaW1wbGlmeVNlY3Rpb24oVmVydGljZXMgdmVydGljZXMsIGludCBpLCBpbnQgailcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGlmICgoaSArIDEpID09IGopXHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcblxyXG4gICAgICAgICAgICBWZWN0b3IyIEEgPSB2ZXJ0aWNlc1tpXTtcclxuICAgICAgICAgICAgVmVjdG9yMiBCID0gdmVydGljZXNbal07XHJcbiAgICAgICAgICAgIGRvdWJsZSBtYXhEaXN0YW5jZSA9IC0xLjA7XHJcbiAgICAgICAgICAgIGludCBtYXhJbmRleCA9IGk7XHJcbiAgICAgICAgICAgIGZvciAoaW50IGsgPSBpICsgMTsgayA8IGo7IGsrKylcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgZG91YmxlIGRpc3RhbmNlID0gRGlzdGFuY2VQb2ludExpbmUodmVydGljZXNba10sIEEsIEIpO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmIChkaXN0YW5jZSA+IG1heERpc3RhbmNlKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIG1heERpc3RhbmNlID0gZGlzdGFuY2U7XHJcbiAgICAgICAgICAgICAgICAgICAgbWF4SW5kZXggPSBrO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChtYXhEaXN0YW5jZSA8PSBfZGlzdGFuY2VUb2xlcmFuY2UpXHJcbiAgICAgICAgICAgICAgICBmb3IgKGludCBrID0gaSArIDE7IGsgPCBqOyBrKyspXHJcbiAgICAgICAgICAgICAgICAgICAgX3VzZVB0W2tdID0gZmFsc2U7XHJcbiAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgU2ltcGxpZnlTZWN0aW9uKHZlcnRpY2VzLCBpLCBtYXhJbmRleCk7XHJcbiAgICAgICAgICAgICAgICBTaW1wbGlmeVNlY3Rpb24odmVydGljZXMsIG1heEluZGV4LCBqKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHJpdmF0ZSBzdGF0aWMgZG91YmxlIERpc3RhbmNlUG9pbnRQb2ludChWZWN0b3IyIHAsIFZlY3RvcjIgcDIpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBkb3VibGUgZHggPSBwLlggLSBwMi5YO1xyXG4gICAgICAgICAgICBkb3VibGUgZHkgPSBwLlkgLSBwMi5YO1xyXG4gICAgICAgICAgICByZXR1cm4gTWF0aC5TcXJ0KGR4ICogZHggKyBkeSAqIGR5KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHByaXZhdGUgc3RhdGljIGRvdWJsZSBEaXN0YW5jZVBvaW50TGluZShWZWN0b3IyIHAsIFZlY3RvcjIgQSwgVmVjdG9yMiBCKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgLy8gaWYgc3RhcnQgPT0gZW5kLCB0aGVuIHVzZSBwb2ludC10by1wb2ludCBkaXN0YW5jZVxyXG4gICAgICAgICAgICBpZiAoQS5YID09IEIuWCAmJiBBLlkgPT0gQi5ZKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIERpc3RhbmNlUG9pbnRQb2ludChwLCBBKTtcclxuXHJcbiAgICAgICAgICAgIC8vIG90aGVyd2lzZSB1c2UgY29tcC5ncmFwaGljcy5hbGdvcml0aG1zIEZyZXF1ZW50bHkgQXNrZWQgUXVlc3Rpb25zIG1ldGhvZFxyXG4gICAgICAgICAgICAvKigxKSAgICAgXHQgICAgICBBQyBkb3QgQUJcclxuICAgICAgICAgICAgICAgICAgICAgICAgciA9ICAgLS0tLS0tLS0tXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHx8QUJ8fF4yXHJcbiAgICAgICAgICAgICBcclxuXHRcdCAgICAgICAgICAgICAgICByIGhhcyB0aGUgZm9sbG93aW5nIG1lYW5pbmc6XHJcblx0XHQgICAgICAgICAgICAgICAgcj0wIFBvaW50ID0gQVxyXG5cdFx0ICAgICAgICAgICAgICAgIHI9MSBQb2ludCA9IEJcclxuXHRcdCAgICAgICAgICAgICAgICByPDAgUG9pbnQgaXMgb24gdGhlIGJhY2t3YXJkIGV4dGVuc2lvbiBvZiBBQlxyXG5cdFx0ICAgICAgICAgICAgICAgIHI+MSBQb2ludCBpcyBvbiB0aGUgZm9yd2FyZCBleHRlbnNpb24gb2YgQUJcclxuXHRcdCAgICAgICAgICAgICAgICAwPHI8MSBQb2ludCBpcyBpbnRlcmlvciB0byBBQlxyXG5cdCAgICAgICAgKi9cclxuXHJcbiAgICAgICAgICAgIGRvdWJsZSByID0gKChwLlggLSBBLlgpICogKEIuWCAtIEEuWCkgKyAocC5ZIC0gQS5ZKSAqIChCLlkgLSBBLlkpKVxyXG4gICAgICAgICAgICAgICAgICAgICAgIC9cclxuICAgICAgICAgICAgICAgICAgICAgICAoKEIuWCAtIEEuWCkgKiAoQi5YIC0gQS5YKSArIChCLlkgLSBBLlkpICogKEIuWSAtIEEuWSkpO1xyXG5cclxuICAgICAgICAgICAgaWYgKHIgPD0gMC4wKSByZXR1cm4gRGlzdGFuY2VQb2ludFBvaW50KHAsIEEpO1xyXG4gICAgICAgICAgICBpZiAociA+PSAxLjApIHJldHVybiBEaXN0YW5jZVBvaW50UG9pbnQocCwgQik7XHJcblxyXG5cclxuICAgICAgICAgICAgLyooMilcclxuXHRcdCAgICAgICAgICAgICAgICAgICAgKEF5LUN5KShCeC1BeCktKEF4LUN4KShCeS1BeSlcclxuXHRcdCAgICAgICAgICAgICAgICBzID0gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuXHRcdCAgICAgICAgICAgICBcdCAgICAgICAgICAgICAgICBDdXJ2ZV4yXHJcblxyXG5cdFx0ICAgICAgICAgICAgICAgIFRoZW4gdGhlIGRpc3RhbmNlIGZyb20gQyB0byBQb2ludCA9IHxzfCpDdXJ2ZS5cclxuXHQgICAgICAgICovXHJcblxyXG4gICAgICAgICAgICBkb3VibGUgcyA9ICgoQS5ZIC0gcC5ZKSAqIChCLlggLSBBLlgpIC0gKEEuWCAtIHAuWCkgKiAoQi5ZIC0gQS5ZKSlcclxuICAgICAgICAgICAgICAgICAgICAgICAvXHJcbiAgICAgICAgICAgICAgICAgICAgICAgKChCLlggLSBBLlgpICogKEIuWCAtIEEuWCkgKyAoQi5ZIC0gQS5ZKSAqIChCLlkgLSBBLlkpKTtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiBNYXRoLkFicyhzKSAqIE1hdGguU3FydCgoKEIuWCAtIEEuWCkgKiAoQi5YIC0gQS5YKSArIChCLlkgLSBBLlkpICogKEIuWSAtIEEuWSkpKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vRnJvbSBwaHlzaWNzMmQubmV0XHJcbiAgICAgICAgcHVibGljIHN0YXRpYyBWZXJ0aWNlcyBSZWR1Y2VCeUFyZWEoVmVydGljZXMgdmVydGljZXMsIGZsb2F0IGFyZWFUb2xlcmFuY2UpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBpZiAodmVydGljZXMuQ291bnQgPD0gMylcclxuICAgICAgICAgICAgICAgIHJldHVybiB2ZXJ0aWNlcztcclxuXHJcbiAgICAgICAgICAgIGlmIChhcmVhVG9sZXJhbmNlIDwgMClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEFyZ3VtZW50T3V0T2ZSYW5nZUV4Y2VwdGlvbihcImFyZWFUb2xlcmFuY2VcIiwgXCJtdXN0IGJlIGVxdWFsIHRvIG9yIGdyZWF0ZXIgdGhlbiB6ZXJvLlwiKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgVmVydGljZXMgcmVzdWx0ID0gbmV3IFZlcnRpY2VzKCk7XHJcbiAgICAgICAgICAgIFZlY3RvcjIgdjEsIHYyLCB2MztcclxuICAgICAgICAgICAgZmxvYXQgb2xkMSwgb2xkMiwgbmV3MTtcclxuICAgICAgICAgICAgdjEgPSB2ZXJ0aWNlc1t2ZXJ0aWNlcy5Db3VudCAtIDJdO1xyXG4gICAgICAgICAgICB2MiA9IHZlcnRpY2VzW3ZlcnRpY2VzLkNvdW50IC0gMV07XHJcbiAgICAgICAgICAgIGFyZWFUb2xlcmFuY2UgKj0gMjtcclxuICAgICAgICAgICAgZm9yIChpbnQgaW5kZXggPSAwOyBpbmRleCA8IHZlcnRpY2VzLkNvdW50OyArK2luZGV4LCB2MiA9IHYzKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBpZiAoaW5kZXggPT0gdmVydGljZXMuQ291bnQgLSAxKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXN1bHQuQ291bnQgPT0gMClcclxuICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBBcmd1bWVudE91dE9mUmFuZ2VFeGNlcHRpb24oXCJhcmVhVG9sZXJhbmNlXCIsIFwiVGhlIHRvbGVyYW5jZSBpcyB0b28gaGlnaCFcIik7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHYzID0gcmVzdWx0WzBdO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIHYzID0gdmVydGljZXNbaW5kZXhdO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgTWF0aFV0aWxzLkNyb3NzKHJlZiB2MSwgcmVmIHYyLCBvdXQgb2xkMSk7XHJcbiAgICAgICAgICAgICAgICBNYXRoVXRpbHMuQ3Jvc3MocmVmIHYyLCByZWYgdjMsIG91dCBvbGQyKTtcclxuICAgICAgICAgICAgICAgIE1hdGhVdGlscy5Dcm9zcyhyZWYgdjEsIHJlZiB2Mywgb3V0IG5ldzEpO1xyXG4gICAgICAgICAgICAgICAgaWYgKE1hdGguQWJzKG5ldzEgLSAob2xkMSArIG9sZDIpKSA+IGFyZWFUb2xlcmFuY2UpXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LkFkZCh2Mik7XHJcbiAgICAgICAgICAgICAgICAgICAgdjEgPSB2MjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy9Gcm9tIEVyaWMgSm9yZGFuJ3MgY29udmV4IGRlY29tcG9zaXRpb24gbGlicmFyeVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIE1lcmdlcyBhbGwgcGFyYWxsZWwgZWRnZXMgaW4gdGhlIGxpc3Qgb2YgdmVydGljZXNcclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cInZlcnRpY2VzXCI+VGhlIHZlcnRpY2VzLjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwidG9sZXJhbmNlXCI+VGhlIHRvbGVyYW5jZS48L3BhcmFtPlxyXG4gICAgICAgIHB1YmxpYyBzdGF0aWMgdm9pZCBNZXJnZVBhcmFsbGVsRWRnZXMoVmVydGljZXMgdmVydGljZXMsIGZsb2F0IHRvbGVyYW5jZSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGlmICh2ZXJ0aWNlcy5Db3VudCA8PSAzKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuOyAvL0Nhbid0IGRvIGFueXRoaW5nIHVzZWZ1bCBoZXJlIHRvIGEgdHJpYW5nbGVcclxuXHJcbiAgICAgICAgICAgIGJvb2xbXSBtZXJnZU1lID0gbmV3IGJvb2xbdmVydGljZXMuQ291bnRdO1xyXG4gICAgICAgICAgICBpbnQgbmV3TlZlcnRpY2VzID0gdmVydGljZXMuQ291bnQ7XHJcblxyXG4gICAgICAgICAgICAvL0dhdGhlciBwb2ludHMgdG8gcHJvY2Vzc1xyXG4gICAgICAgICAgICBmb3IgKGludCBpID0gMDsgaSA8IHZlcnRpY2VzLkNvdW50OyArK2kpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGludCBsb3dlciA9IChpID09IDApID8gKHZlcnRpY2VzLkNvdW50IC0gMSkgOiAoaSAtIDEpO1xyXG4gICAgICAgICAgICAgICAgaW50IG1pZGRsZSA9IGk7XHJcbiAgICAgICAgICAgICAgICBpbnQgdXBwZXIgPSAoaSA9PSB2ZXJ0aWNlcy5Db3VudCAtIDEpID8gKDApIDogKGkgKyAxKTtcclxuXHJcbiAgICAgICAgICAgICAgICBmbG9hdCBkeDAgPSB2ZXJ0aWNlc1ttaWRkbGVdLlggLSB2ZXJ0aWNlc1tsb3dlcl0uWDtcclxuICAgICAgICAgICAgICAgIGZsb2F0IGR5MCA9IHZlcnRpY2VzW21pZGRsZV0uWSAtIHZlcnRpY2VzW2xvd2VyXS5ZO1xyXG4gICAgICAgICAgICAgICAgZmxvYXQgZHgxID0gdmVydGljZXNbdXBwZXJdLlkgLSB2ZXJ0aWNlc1ttaWRkbGVdLlg7XHJcbiAgICAgICAgICAgICAgICBmbG9hdCBkeTEgPSB2ZXJ0aWNlc1t1cHBlcl0uWSAtIHZlcnRpY2VzW21pZGRsZV0uWTtcclxuICAgICAgICAgICAgICAgIGZsb2F0IG5vcm0wID0gKGZsb2F0KU1hdGguU3FydChkeDAgKiBkeDAgKyBkeTAgKiBkeTApO1xyXG4gICAgICAgICAgICAgICAgZmxvYXQgbm9ybTEgPSAoZmxvYXQpTWF0aC5TcXJ0KGR4MSAqIGR4MSArIGR5MSAqIGR5MSk7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKCEobm9ybTAgPiAwLjBmICYmIG5vcm0xID4gMC4wZikgJiYgbmV3TlZlcnRpY2VzID4gMylcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAvL01lcmdlIGlkZW50aWNhbCBwb2ludHNcclxuICAgICAgICAgICAgICAgICAgICBtZXJnZU1lW2ldID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAtLW5ld05WZXJ0aWNlcztcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBkeDAgLz0gbm9ybTA7XHJcbiAgICAgICAgICAgICAgICBkeTAgLz0gbm9ybTA7XHJcbiAgICAgICAgICAgICAgICBkeDEgLz0gbm9ybTE7XHJcbiAgICAgICAgICAgICAgICBkeTEgLz0gbm9ybTE7XHJcbiAgICAgICAgICAgICAgICBmbG9hdCBjcm9zcyA9IGR4MCAqIGR5MSAtIGR4MSAqIGR5MDtcclxuICAgICAgICAgICAgICAgIGZsb2F0IGRvdCA9IGR4MCAqIGR4MSArIGR5MCAqIGR5MTtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoTWF0aC5BYnMoY3Jvc3MpIDwgdG9sZXJhbmNlICYmIGRvdCA+IDAgJiYgbmV3TlZlcnRpY2VzID4gMylcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBtZXJnZU1lW2ldID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAtLW5ld05WZXJ0aWNlcztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgICAgICBtZXJnZU1lW2ldID0gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmIChuZXdOVmVydGljZXMgPT0gdmVydGljZXMuQ291bnQgfHwgbmV3TlZlcnRpY2VzID09IDApXHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcblxyXG4gICAgICAgICAgICBpbnQgY3VyckluZGV4ID0gMDtcclxuXHJcbiAgICAgICAgICAgIC8vQ29weSB0aGUgdmVydGljZXMgdG8gYSBuZXcgbGlzdCBhbmQgY2xlYXIgdGhlIG9sZFxyXG4gICAgICAgICAgICBWZXJ0aWNlcyBvbGRWZXJ0aWNlcyA9IG5ldyBWZXJ0aWNlcyh2ZXJ0aWNlcyk7XHJcbiAgICAgICAgICAgIHZlcnRpY2VzLkNsZWFyKCk7XHJcblxyXG4gICAgICAgICAgICBmb3IgKGludCBpID0gMDsgaSA8IG9sZFZlcnRpY2VzLkNvdW50OyArK2kpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGlmIChtZXJnZU1lW2ldIHx8IG5ld05WZXJ0aWNlcyA9PSAwIHx8IGN1cnJJbmRleCA9PSBuZXdOVmVydGljZXMpXHJcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcblxyXG4gICAgICAgICAgICAgICAgRGVidWcuQXNzZXJ0KGN1cnJJbmRleCA8IG5ld05WZXJ0aWNlcyk7XHJcblxyXG4gICAgICAgICAgICAgICAgdmVydGljZXMuQWRkKG9sZFZlcnRpY2VzW2ldKTtcclxuICAgICAgICAgICAgICAgICsrY3VyckluZGV4O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvL01pc2NcclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBNZXJnZXMgdGhlIGlkZW50aWNhbCBwb2ludHMgaW4gdGhlIHBvbHlnb24uXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJ2ZXJ0aWNlc1wiPlRoZSB2ZXJ0aWNlcy48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cmV0dXJucz48L3JldHVybnM+XHJcbiAgICAgICAgcHVibGljIHN0YXRpYyBWZXJ0aWNlcyBNZXJnZUlkZW50aWNhbFBvaW50cyhWZXJ0aWNlcyB2ZXJ0aWNlcylcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIC8vV2UgdXNlIGEgZGljdG9uYXJ5IGhlcmUgYmVjYXVzZSBIYXNoU2V0IGlzIG5vdCBhdmFsaWFibGUgb24gYWxsIHBsYXRmb3Jtcy5cclxuICAgICAgICAgICAgSGFzaFNldDxWZWN0b3IyPiByZXN1bHRzID0gbmV3IEhhc2hTZXQ8VmVjdG9yMj4oKTtcclxuXHJcbiAgICAgICAgICAgIGZvciAoaW50IGkgPSAwOyBpIDwgdmVydGljZXMuQ291bnQ7IGkrKylcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0cy5BZGQodmVydGljZXNbaV0pO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBWZXJ0aWNlcyByZXR1cm5SZXN1bHRzID0gbmV3IFZlcnRpY2VzKCk7XHJcbiAgICAgICAgICAgIGZvcmVhY2ggKFZlY3RvcjIgdiBpbiByZXN1bHRzKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm5SZXN1bHRzLkFkZCh2KTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuIHJldHVyblJlc3VsdHM7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIFJlZHVjZXMgdGhlIHBvbHlnb24gYnkgZGlzdGFuY2UuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJ2ZXJ0aWNlc1wiPlRoZSB2ZXJ0aWNlcy48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cImRpc3RhbmNlXCI+VGhlIGRpc3RhbmNlIGJldHdlZW4gcG9pbnRzLiBQb2ludHMgY2xvc2VyIHRoYW4gdGhpcyB3aWxsIGJlICdqb2luZWQnLjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxyZXR1cm5zPjwvcmV0dXJucz5cclxuICAgICAgICBwdWJsaWMgc3RhdGljIFZlcnRpY2VzIFJlZHVjZUJ5RGlzdGFuY2UoVmVydGljZXMgdmVydGljZXMsIGZsb2F0IGRpc3RhbmNlKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgLy9XZSBjYW4ndCBzaW1wbGlmeSBwb2x5Z29ucyB1bmRlciAzIHZlcnRpY2VzXHJcbiAgICAgICAgICAgIGlmICh2ZXJ0aWNlcy5Db3VudCA8IDMpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdmVydGljZXM7XHJcblxyXG4gICAgICAgICAgICBWZXJ0aWNlcyBzaW1wbGlmaWVkID0gbmV3IFZlcnRpY2VzKCk7XHJcblxyXG4gICAgICAgICAgICBmb3IgKGludCBpID0gMDsgaSA8IHZlcnRpY2VzLkNvdW50OyBpKyspXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIFZlY3RvcjIgY3VycmVudCA9IHZlcnRpY2VzW2ldO1xyXG4gICAgICAgICAgICAgICAgVmVjdG9yMiBuZXh0ID0gdmVydGljZXMuTmV4dFZlcnRleChpKTtcclxuXHJcbiAgICAgICAgICAgICAgICAvL0lmIHRoZXkgYXJlIGNsb3NlciB0aGFuIHRoZSBkaXN0YW5jZSwgY29udGludWVcclxuICAgICAgICAgICAgICAgIGlmICgobmV4dCAtIGN1cnJlbnQpLkxlbmd0aFNxdWFyZWQoKSA8PSBkaXN0YW5jZSlcclxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuXHJcbiAgICAgICAgICAgICAgICBzaW1wbGlmaWVkLkFkZChjdXJyZW50KTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuIHNpbXBsaWZpZWQ7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIFJlZHVjZXMgdGhlIHBvbHlnb24gYnkgcmVtb3ZpbmcgdGhlIE50aCB2ZXJ0ZXggaW4gdGhlIHZlcnRpY2VzIGxpc3QuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJ2ZXJ0aWNlc1wiPlRoZSB2ZXJ0aWNlcy48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cIm50aFwiPlRoZSBOdGggcG9pbnQgdG8gcmVtb3ZlLiBFeGFtcGxlOiA1LjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxyZXR1cm5zPjwvcmV0dXJucz5cclxuICAgICAgICBwdWJsaWMgc3RhdGljIFZlcnRpY2VzIFJlZHVjZUJ5TnRoKFZlcnRpY2VzIHZlcnRpY2VzLCBpbnQgbnRoKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgLy9XZSBjYW4ndCBzaW1wbGlmeSBwb2x5Z29ucyB1bmRlciAzIHZlcnRpY2VzXHJcbiAgICAgICAgICAgIGlmICh2ZXJ0aWNlcy5Db3VudCA8IDMpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdmVydGljZXM7XHJcblxyXG4gICAgICAgICAgICBpZiAobnRoID09IDApXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdmVydGljZXM7XHJcblxyXG4gICAgICAgICAgICBWZXJ0aWNlcyByZXN1bHQgPSBuZXcgVmVydGljZXModmVydGljZXMuQ291bnQpO1xyXG5cclxuICAgICAgICAgICAgZm9yIChpbnQgaSA9IDA7IGkgPCB2ZXJ0aWNlcy5Db3VudDsgaSsrKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBpZiAoaSAlIG50aCA9PSAwKVxyXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG5cclxuICAgICAgICAgICAgICAgIHJlc3VsdC5BZGQodmVydGljZXNbaV0pO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufSIsInVzaW5nIFN5c3RlbTtcclxudXNpbmcgU3lzdGVtLkNvbGxlY3Rpb25zLkdlbmVyaWM7XHJcbnVzaW5nIFN5c3RlbS5EaWFnbm9zdGljcztcclxudXNpbmcgRmFyc2VlclBoeXNpY3MuQ29sbGlzaW9uLlNoYXBlcztcclxudXNpbmcgTWljcm9zb2Z0LlhuYS5GcmFtZXdvcms7XHJcblxyXG5uYW1lc3BhY2UgRmFyc2VlclBoeXNpY3MuQ29tbW9uLlBvbHlnb25NYW5pcHVsYXRpb25cclxue1xyXG4gICAgaW50ZXJuYWwgZW51bSBQb2x5Q2xpcFR5cGVcclxuICAgIHtcclxuICAgICAgICBJbnRlcnNlY3QsXHJcbiAgICAgICAgVW5pb24sXHJcbiAgICAgICAgRGlmZmVyZW5jZVxyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBlbnVtIFBvbHlDbGlwRXJyb3JcclxuICAgIHtcclxuICAgICAgICBOb25lLFxyXG4gICAgICAgIERlZ2VuZXJhdGVkT3V0cHV0LFxyXG4gICAgICAgIE5vblNpbXBsZUlucHV0LFxyXG4gICAgICAgIEJyb2tlblJlc3VsdFxyXG4gICAgfVxyXG5cclxuICAgIC8vQ2xpcHBlciBjb250cmlidXRlZCBieSBIZWxnZSBCYWNraGF1c1xyXG5cclxuICAgIHB1YmxpYyBzdGF0aWMgY2xhc3MgWXVQZW5nQ2xpcHBlclxyXG4gICAge1xyXG4gICAgICAgIHByaXZhdGUgY29uc3QgZmxvYXQgQ2xpcHBlckVwc2lsb25TcXVhcmVkID0gMS4xOTIwOTI4OTZlLTA3ZjtcclxuXHJcbiAgICAgICAgcHVibGljIHN0YXRpYyBMaXN0PFZlcnRpY2VzPiBVbmlvbihWZXJ0aWNlcyBwb2x5Z29uMSwgVmVydGljZXMgcG9seWdvbjIsIG91dCBQb2x5Q2xpcEVycm9yIGVycm9yKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIEV4ZWN1dGUocG9seWdvbjEsIHBvbHlnb24yLCBQb2x5Q2xpcFR5cGUuVW5pb24sIG91dCBlcnJvcik7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwdWJsaWMgc3RhdGljIExpc3Q8VmVydGljZXM+IERpZmZlcmVuY2UoVmVydGljZXMgcG9seWdvbjEsIFZlcnRpY2VzIHBvbHlnb24yLCBvdXQgUG9seUNsaXBFcnJvciBlcnJvcilcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiBFeGVjdXRlKHBvbHlnb24xLCBwb2x5Z29uMiwgUG9seUNsaXBUeXBlLkRpZmZlcmVuY2UsIG91dCBlcnJvcik7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwdWJsaWMgc3RhdGljIExpc3Q8VmVydGljZXM+IEludGVyc2VjdChWZXJ0aWNlcyBwb2x5Z29uMSwgVmVydGljZXMgcG9seWdvbjIsIG91dCBQb2x5Q2xpcEVycm9yIGVycm9yKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIEV4ZWN1dGUocG9seWdvbjEsIHBvbHlnb24yLCBQb2x5Q2xpcFR5cGUuSW50ZXJzZWN0LCBvdXQgZXJyb3IpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBJbXBsZW1lbnRzIFwiQSBuZXcgYWxnb3JpdGhtIGZvciBCb29sZWFuIG9wZXJhdGlvbnMgb24gZ2VuZXJhbCBwb2x5Z29uc1wiIFxyXG4gICAgICAgIC8vLyBhdmFpbGFibGUgaGVyZTogaHR0cDovL2xpYW1hLmlhLmFjLmNuL3dpa2kvX21lZGlhL3VzZXI6ZG9uZzpkb25nX2NnXzA1LnBkZlxyXG4gICAgICAgIC8vLyBNZXJnZXMgdHdvIHBvbHlnb25zLCBhIHN1YmplY3QgYW5kIGEgY2xpcCB3aXRoIHRoZSBzcGVjaWZpZWQgb3BlcmF0aW9uLiBQb2x5Z29ucyBtYXkgbm90IGJlIFxyXG4gICAgICAgIC8vLyBzZWxmLWludGVyc2VjdGluZy5cclxuICAgICAgICAvLy8gXHJcbiAgICAgICAgLy8vIFdhcm5pbmc6IE1heSB5aWVsZCBpbmNvcnJlY3QgcmVzdWx0cyBvciBldmVuIGNyYXNoIGlmIHBvbHlnb25zIGNvbnRhaW4gY29sbGluZWFyIHBvaW50cy5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cInN1YmplY3RcIj5UaGUgc3ViamVjdCBwb2x5Z29uLjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwiY2xpcFwiPlRoZSBjbGlwIHBvbHlnb24sIHdoaWNoIGlzIGFkZGVkLCBcclxuICAgICAgICAvLy8gc3Vic3RyYWN0ZWQgb3IgaW50ZXJzZWN0ZWQgd2l0aCB0aGUgc3ViamVjdDwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwiY2xpcFR5cGVcIj5UaGUgb3BlcmF0aW9uIHRvIGJlIHBlcmZvcm1lZC4gRWl0aGVyXHJcbiAgICAgICAgLy8vIFVuaW9uLCBEaWZmZXJlbmNlIG9yIEludGVyc2VjdGlvbi48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cImVycm9yXCI+VGhlIGVycm9yIGdlbmVyYXRlZCAoaWYgYW55KTwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxyZXR1cm5zPkEgbGlzdCBvZiBjbG9zZWQgcG9seWdvbnMsIHdoaWNoIG1ha2UgdXAgdGhlIHJlc3VsdCBvZiB0aGUgY2xpcHBpbmcgb3BlcmF0aW9uLlxyXG4gICAgICAgIC8vLyBPdXRlciBjb250b3VycyBhcmUgb3JkZXJlZCBjb3VudGVyIGNsb2Nrd2lzZSwgaG9sZXMgYXJlIG9yZGVyZWQgY2xvY2t3aXNlLjwvcmV0dXJucz5cclxuICAgICAgICBwcml2YXRlIHN0YXRpYyBMaXN0PFZlcnRpY2VzPiBFeGVjdXRlKFZlcnRpY2VzIHN1YmplY3QsIFZlcnRpY2VzIGNsaXAsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBQb2x5Q2xpcFR5cGUgY2xpcFR5cGUsIG91dCBQb2x5Q2xpcEVycm9yIGVycm9yKVxyXG4gICAgICAgIHtcclxuI2lmICFORVRGWF9DT1JFXHJcbiAgICAgICAgICAgIERlYnVnLkFzc2VydChzdWJqZWN0LklzU2ltcGxlKCkgJiYgY2xpcC5Jc1NpbXBsZSgpLCBcIk5vbiBzaW1wbGUgaW5wdXQhXCIsIFwiSW5wdXQgcG9seWdvbnMgbXVzdCBiZSBzaW1wbGUgKGNhbm5vdCBpbnRlcnNlY3QgdGhlbXNlbHZlcykuXCIpO1xyXG4jZW5kaWZcclxuXHJcbiAgICAgICAgICAgIC8vIENvcHkgcG9seWdvbnNcclxuICAgICAgICAgICAgVmVydGljZXMgc2xpY2VkU3ViamVjdDtcclxuICAgICAgICAgICAgVmVydGljZXMgc2xpY2VkQ2xpcDtcclxuICAgICAgICAgICAgLy8gQ2FsY3VsYXRlIHRoZSBpbnRlcnNlY3Rpb24gYW5kIHRvdWNoIHBvaW50cyBiZXR3ZWVuXHJcbiAgICAgICAgICAgIC8vIHN1YmplY3QgYW5kIGNsaXAgYW5kIGFkZCB0aGVtIHRvIGJvdGhcclxuICAgICAgICAgICAgQ2FsY3VsYXRlSW50ZXJzZWN0aW9ucyhzdWJqZWN0LCBjbGlwLCBvdXQgc2xpY2VkU3ViamVjdCwgb3V0IHNsaWNlZENsaXApO1xyXG5cclxuICAgICAgICAgICAgLy8gVHJhbnNsYXRlIHBvbHlnb25zIGludG8gdXBwZXIgcmlnaHQgcXVhZHJhbnRcclxuICAgICAgICAgICAgLy8gYXMgdGhlIGFsZ29yaXRobSBkZXBlbmRzIG9uIGl0XHJcbiAgICAgICAgICAgIFZlY3RvcjIgbGJTdWJqZWN0ID0gc3ViamVjdC5HZXRDb2xsaXNpb25Cb3goKS5Mb3dlckJvdW5kO1xyXG4gICAgICAgICAgICBWZWN0b3IyIGxiQ2xpcCA9IGNsaXAuR2V0Q29sbGlzaW9uQm94KCkuTG93ZXJCb3VuZDtcclxuICAgICAgICAgICAgVmVjdG9yMiB0cmFuc2xhdGU7XHJcbiAgICAgICAgICAgIFZlY3RvcjIuTWluKHJlZiBsYlN1YmplY3QsIHJlZiBsYkNsaXAsIG91dCB0cmFuc2xhdGUpO1xyXG4gICAgICAgICAgICB0cmFuc2xhdGUgPSBWZWN0b3IyLk9uZSAtIHRyYW5zbGF0ZTtcclxuICAgICAgICAgICAgaWYgKHRyYW5zbGF0ZSAhPSBWZWN0b3IyLlplcm8pXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHNsaWNlZFN1YmplY3QuVHJhbnNsYXRlKHJlZiB0cmFuc2xhdGUpO1xyXG4gICAgICAgICAgICAgICAgc2xpY2VkQ2xpcC5UcmFuc2xhdGUocmVmIHRyYW5zbGF0ZSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIEVuZm9yY2UgY291bnRlcmNsb2Nrd2lzZSBjb250b3Vyc1xyXG4gICAgICAgICAgICBzbGljZWRTdWJqZWN0LkZvcmNlQ291bnRlckNsb2NrV2lzZSgpO1xyXG4gICAgICAgICAgICBzbGljZWRDbGlwLkZvcmNlQ291bnRlckNsb2NrV2lzZSgpO1xyXG5cclxuICAgICAgICAgICAgTGlzdDxFZGdlPiBzdWJqZWN0U2ltcGxpY2VzO1xyXG4gICAgICAgICAgICBMaXN0PGZsb2F0PiBzdWJqZWN0Q29lZmY7XHJcbiAgICAgICAgICAgIExpc3Q8RWRnZT4gY2xpcFNpbXBsaWNlcztcclxuICAgICAgICAgICAgTGlzdDxmbG9hdD4gY2xpcENvZWZmO1xyXG4gICAgICAgICAgICAvLyBCdWlsZCBzaW1wbGljYWwgY2hhaW5zIGZyb20gdGhlIHBvbHlnb25zIGFuZCBjYWxjdWxhdGUgdGhlXHJcbiAgICAgICAgICAgIC8vIHRoZSBjb3JyZXNwb25kaW5nIGNvZWZmaWNpZW50c1xyXG4gICAgICAgICAgICBDYWxjdWxhdGVTaW1wbGljYWxDaGFpbihzbGljZWRTdWJqZWN0LCBvdXQgc3ViamVjdENvZWZmLCBvdXQgc3ViamVjdFNpbXBsaWNlcyk7XHJcbiAgICAgICAgICAgIENhbGN1bGF0ZVNpbXBsaWNhbENoYWluKHNsaWNlZENsaXAsIG91dCBjbGlwQ29lZmYsIG91dCBjbGlwU2ltcGxpY2VzKTtcclxuXHJcbiAgICAgICAgICAgIExpc3Q8RWRnZT4gcmVzdWx0U2ltcGxpY2VzO1xyXG5cclxuICAgICAgICAgICAgLy8gRGV0ZXJtaW5lIHRoZSBjaGFyYWN0ZXJpc3RpY3MgZnVuY3Rpb24gZm9yIGFsbCBub24tb3JpZ2luYWwgZWRnZXNcclxuICAgICAgICAgICAgLy8gaW4gc3ViamVjdCBhbmQgY2xpcCBzaW1wbGljYWwgY2hhaW4gYW5kIGNvbWJpbmUgdGhlIGVkZ2VzIGNvbnRyaWJ1dGluZ1xyXG4gICAgICAgICAgICAvLyB0byB0aGUgcmVzdWx0LCBkZXBlbmRpbmcgb24gdGhlIGNsaXBUeXBlXHJcbiAgICAgICAgICAgIENhbGN1bGF0ZVJlc3VsdENoYWluKHN1YmplY3RDb2VmZiwgc3ViamVjdFNpbXBsaWNlcywgY2xpcENvZWZmLCBjbGlwU2ltcGxpY2VzLCBjbGlwVHlwZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3V0IHJlc3VsdFNpbXBsaWNlcyk7XHJcblxyXG4gICAgICAgICAgICBMaXN0PFZlcnRpY2VzPiByZXN1bHQ7XHJcbiAgICAgICAgICAgIC8vIENvbnZlcnQgcmVzdWx0IGNoYWluIGJhY2sgdG8gcG9seWdvbihzKVxyXG4gICAgICAgICAgICBlcnJvciA9IEJ1aWxkUG9seWdvbnNGcm9tQ2hhaW4ocmVzdWx0U2ltcGxpY2VzLCBvdXQgcmVzdWx0KTtcclxuXHJcbiAgICAgICAgICAgIC8vIFJldmVyc2UgdGhlIHBvbHlnb24gdHJhbnNsYXRpb24gZnJvbSB0aGUgYmVnaW5uaW5nXHJcbiAgICAgICAgICAgIC8vIGFuZCByZW1vdmUgY29sbGluZWFyIHBvaW50cyBmcm9tIG91dHB1dFxyXG4gICAgICAgICAgICB0cmFuc2xhdGUgKj0gLTFmO1xyXG4gICAgICAgICAgICBmb3IgKGludCBpID0gMDsgaSA8IHJlc3VsdC5Db3VudDsgKytpKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICByZXN1bHRbaV0uVHJhbnNsYXRlKHJlZiB0cmFuc2xhdGUpO1xyXG4gICAgICAgICAgICAgICAgU2ltcGxpZnlUb29scy5Db2xsaW5lYXJTaW1wbGlmeShyZXN1bHRbaV0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIENhbGN1bGF0ZXMgYWxsIGludGVyc2VjdGlvbnMgYmV0d2VlbiB0d28gcG9seWdvbnMuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJwb2x5Z29uMVwiPlRoZSBmaXJzdCBwb2x5Z29uLjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwicG9seWdvbjJcIj5UaGUgc2Vjb25kIHBvbHlnb24uPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJzbGljZWRQb2x5MVwiPlJldHVybnMgdGhlIGZpcnN0IHBvbHlnb24gd2l0aCBhZGRlZCBpbnRlcnNlY3Rpb24gcG9pbnRzLjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwic2xpY2VkUG9seTJcIj5SZXR1cm5zIHRoZSBzZWNvbmQgcG9seWdvbiB3aXRoIGFkZGVkIGludGVyc2VjdGlvbiBwb2ludHMuPC9wYXJhbT5cclxuICAgICAgICBwcml2YXRlIHN0YXRpYyB2b2lkIENhbGN1bGF0ZUludGVyc2VjdGlvbnMoVmVydGljZXMgcG9seWdvbjEsIFZlcnRpY2VzIHBvbHlnb24yLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdXQgVmVydGljZXMgc2xpY2VkUG9seTEsIG91dCBWZXJ0aWNlcyBzbGljZWRQb2x5MilcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHNsaWNlZFBvbHkxID0gbmV3IFZlcnRpY2VzKHBvbHlnb24xKTtcclxuICAgICAgICAgICAgc2xpY2VkUG9seTIgPSBuZXcgVmVydGljZXMocG9seWdvbjIpO1xyXG5cclxuICAgICAgICAgICAgLy8gSXRlcmF0ZSB0aHJvdWdoIHBvbHlnb24xJ3MgZWRnZXNcclxuICAgICAgICAgICAgZm9yIChpbnQgaSA9IDA7IGkgPCBwb2x5Z29uMS5Db3VudDsgaSsrKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAvLyBHZXQgZWRnZSB2ZXJ0aWNlc1xyXG4gICAgICAgICAgICAgICAgVmVjdG9yMiBhID0gcG9seWdvbjFbaV07XHJcbiAgICAgICAgICAgICAgICBWZWN0b3IyIGIgPSBwb2x5Z29uMVtwb2x5Z29uMS5OZXh0SW5kZXgoaSldO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIEdldCBpbnRlcnNlY3Rpb25zIGJldHdlZW4gdGhpcyBlZGdlIGFuZCBwb2x5Z29uMlxyXG4gICAgICAgICAgICAgICAgZm9yIChpbnQgaiA9IDA7IGogPCBwb2x5Z29uMi5Db3VudDsgaisrKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIFZlY3RvcjIgYyA9IHBvbHlnb24yW2pdO1xyXG4gICAgICAgICAgICAgICAgICAgIFZlY3RvcjIgZCA9IHBvbHlnb24yW3BvbHlnb24yLk5leHRJbmRleChqKV07XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIFZlY3RvcjIgaW50ZXJzZWN0aW9uUG9pbnQ7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gQ2hlY2sgaWYgdGhlIGVkZ2VzIGludGVyc2VjdFxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChMaW5lVG9vbHMuTGluZUludGVyc2VjdChhLCBiLCBjLCBkLCBvdXQgaW50ZXJzZWN0aW9uUG9pbnQpKVxyXG4gICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gY2FsY3VsYXRlIGFscGhhIHZhbHVlcyBmb3Igc29ydGluZyBtdWx0aXBsZSBpbnRlcnNlY3Rpb25zIHBvaW50cyBvbiBhIGVkZ2VcclxuICAgICAgICAgICAgICAgICAgICAgICAgZmxvYXQgYWxwaGE7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEluc2VydCBpbnRlcnNlY3Rpb24gcG9pbnQgaW50byBmaXJzdCBwb2x5Z29uXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGFscGhhID0gR2V0QWxwaGEoYSwgYiwgaW50ZXJzZWN0aW9uUG9pbnQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYWxwaGEgPiAwZiAmJiBhbHBoYSA8IDFmKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnQgaW5kZXggPSBzbGljZWRQb2x5MS5JbmRleE9mKGEpICsgMTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlIChpbmRleCA8IHNsaWNlZFBvbHkxLkNvdW50ICYmXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgR2V0QWxwaGEoYSwgYiwgc2xpY2VkUG9seTFbaW5kZXhdKSA8PSBhbHBoYSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICArK2luZGV4O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2xpY2VkUG9seTEuSW5zZXJ0KGluZGV4LCBpbnRlcnNlY3Rpb25Qb2ludCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSW5zZXJ0IGludGVyc2VjdGlvbiBwb2ludCBpbnRvIHNlY29uZCBwb2x5Z29uXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGFscGhhID0gR2V0QWxwaGEoYywgZCwgaW50ZXJzZWN0aW9uUG9pbnQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYWxwaGEgPiAwZiAmJiBhbHBoYSA8IDFmKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnQgaW5kZXggPSBzbGljZWRQb2x5Mi5JbmRleE9mKGMpICsgMTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlIChpbmRleCA8IHNsaWNlZFBvbHkyLkNvdW50ICYmXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgR2V0QWxwaGEoYywgZCwgc2xpY2VkUG9seTJbaW5kZXhdKSA8PSBhbHBoYSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICArK2luZGV4O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2xpY2VkUG9seTIuSW5zZXJ0KGluZGV4LCBpbnRlcnNlY3Rpb25Qb2ludCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gQ2hlY2sgZm9yIHZlcnkgc21hbGwgZWRnZXNcclxuICAgICAgICAgICAgZm9yIChpbnQgaSA9IDA7IGkgPCBzbGljZWRQb2x5MS5Db3VudDsgKytpKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBpbnQgaU5leHQgPSBzbGljZWRQb2x5MS5OZXh0SW5kZXgoaSk7XHJcbiAgICAgICAgICAgICAgICAvL0lmIHRoZXkgYXJlIGNsb3NlciB0aGFuIHRoZSBkaXN0YW5jZSByZW1vdmUgdmVydGV4XHJcbiAgICAgICAgICAgICAgICBpZiAoKHNsaWNlZFBvbHkxW2lOZXh0XSAtIHNsaWNlZFBvbHkxW2ldKS5MZW5ndGhTcXVhcmVkKCkgPD0gQ2xpcHBlckVwc2lsb25TcXVhcmVkKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIHNsaWNlZFBvbHkxLlJlbW92ZUF0KGkpO1xyXG4gICAgICAgICAgICAgICAgICAgIC0taTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBmb3IgKGludCBpID0gMDsgaSA8IHNsaWNlZFBvbHkyLkNvdW50OyArK2kpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGludCBpTmV4dCA9IHNsaWNlZFBvbHkyLk5leHRJbmRleChpKTtcclxuICAgICAgICAgICAgICAgIC8vSWYgdGhleSBhcmUgY2xvc2VyIHRoYW4gdGhlIGRpc3RhbmNlIHJlbW92ZSB2ZXJ0ZXhcclxuICAgICAgICAgICAgICAgIGlmICgoc2xpY2VkUG9seTJbaU5leHRdIC0gc2xpY2VkUG9seTJbaV0pLkxlbmd0aFNxdWFyZWQoKSA8PSBDbGlwcGVyRXBzaWxvblNxdWFyZWQpXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgc2xpY2VkUG9seTIuUmVtb3ZlQXQoaSk7XHJcbiAgICAgICAgICAgICAgICAgICAgLS1pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIENhbGN1bGF0ZXMgdGhlIHNpbXBsaWNhbCBjaGFpbiBjb3JyZXNwb25kaW5nIHRvIHRoZSBpbnB1dCBwb2x5Z29uLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDxyZW1hcmtzPlVzZWQgYnkgbWV0aG9kIDxjPkV4ZWN1dGUoKTwvYz4uPC9yZW1hcmtzPlxyXG4gICAgICAgIHByaXZhdGUgc3RhdGljIHZvaWQgQ2FsY3VsYXRlU2ltcGxpY2FsQ2hhaW4oVmVydGljZXMgcG9seSwgb3V0IExpc3Q8ZmxvYXQ+IGNvZWZmLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3V0IExpc3Q8RWRnZT4gc2ltcGxpY2llcylcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHNpbXBsaWNpZXMgPSBuZXcgTGlzdDxFZGdlPigpO1xyXG4gICAgICAgICAgICBjb2VmZiA9IG5ldyBMaXN0PGZsb2F0PigpO1xyXG4gICAgICAgICAgICBmb3IgKGludCBpID0gMDsgaSA8IHBvbHkuQ291bnQ7ICsraSlcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgc2ltcGxpY2llcy5BZGQobmV3IEVkZ2UocG9seVtpXSwgcG9seVtwb2x5Lk5leHRJbmRleChpKV0pKTtcclxuICAgICAgICAgICAgICAgIGNvZWZmLkFkZChDYWxjdWxhdGVTaW1wbGV4Q29lZmZpY2llbnQoVmVjdG9yMi5aZXJvLCBwb2x5W2ldLCBwb2x5W3BvbHkuTmV4dEluZGV4KGkpXSkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIENhbGN1bGF0ZXMgdGhlIGNoYXJhY3RlcmlzdGljcyBmdW5jdGlvbiBmb3IgYWxsIGVkZ2VzIG9mXHJcbiAgICAgICAgLy8vIHRoZSBnaXZlbiBzaW1wbGljYWwgY2hhaW5zIGFuZCBidWlsZHMgdGhlIHJlc3VsdCBjaGFpbi5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8cmVtYXJrcz5Vc2VkIGJ5IG1ldGhvZCA8Yz5FeGVjdXRlKCk8L2M+LjwvcmVtYXJrcz5cclxuICAgICAgICBwcml2YXRlIHN0YXRpYyB2b2lkIENhbGN1bGF0ZVJlc3VsdENoYWluKExpc3Q8ZmxvYXQ+IHBvbHkxQ29lZmYsIExpc3Q8RWRnZT4gcG9seTFTaW1wbGljaWVzLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBMaXN0PGZsb2F0PiBwb2x5MkNvZWZmLCBMaXN0PEVkZ2U+IHBvbHkyU2ltcGxpY2llcyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgUG9seUNsaXBUeXBlIGNsaXBUeXBlLCBvdXQgTGlzdDxFZGdlPiByZXN1bHRTaW1wbGljZXMpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXN1bHRTaW1wbGljZXMgPSBuZXcgTGlzdDxFZGdlPigpO1xyXG5cclxuICAgICAgICAgICAgZm9yIChpbnQgaSA9IDA7IGkgPCBwb2x5MVNpbXBsaWNpZXMuQ291bnQ7ICsraSlcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgZmxvYXQgZWRnZUNoYXJhY3RlciA9IDBmO1xyXG4gICAgICAgICAgICAgICAgaWYgKHBvbHkyU2ltcGxpY2llcy5Db250YWlucyhwb2x5MVNpbXBsaWNpZXNbaV0pIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgKHBvbHkyU2ltcGxpY2llcy5Db250YWlucygtcG9seTFTaW1wbGljaWVzW2ldKSAmJiBjbGlwVHlwZSA9PSBQb2x5Q2xpcFR5cGUuVW5pb24pKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIGVkZ2VDaGFyYWN0ZXIgPSAxZjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKGludCBqID0gMDsgaiA8IHBvbHkyU2ltcGxpY2llcy5Db3VudDsgKytqKVxyXG4gICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFwb2x5MlNpbXBsaWNpZXMuQ29udGFpbnMoLXBvbHkxU2ltcGxpY2llc1tpXSkpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVkZ2VDaGFyYWN0ZXIgKz0gQ2FsY3VsYXRlQmV0YShwb2x5MVNpbXBsaWNpZXNbaV0uR2V0Q2VudGVyKCksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9seTJTaW1wbGljaWVzW2pdLCBwb2x5MkNvZWZmW2pdKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChjbGlwVHlwZSA9PSBQb2x5Q2xpcFR5cGUuSW50ZXJzZWN0KVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChlZGdlQ2hhcmFjdGVyID09IDFmKVxyXG4gICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0U2ltcGxpY2VzLkFkZChwb2x5MVNpbXBsaWNpZXNbaV0pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoZWRnZUNoYXJhY3RlciA9PSAwZilcclxuICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdFNpbXBsaWNlcy5BZGQocG9seTFTaW1wbGljaWVzW2ldKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZm9yIChpbnQgaSA9IDA7IGkgPCBwb2x5MlNpbXBsaWNpZXMuQ291bnQ7ICsraSlcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgaWYgKCFyZXN1bHRTaW1wbGljZXMuQ29udGFpbnMocG9seTJTaW1wbGljaWVzW2ldKSAmJlxyXG4gICAgICAgICAgICAgICAgICAgICFyZXN1bHRTaW1wbGljZXMuQ29udGFpbnMoLXBvbHkyU2ltcGxpY2llc1tpXSkpXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgZmxvYXQgZWRnZUNoYXJhY3RlciA9IDBmO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChwb2x5MVNpbXBsaWNpZXMuQ29udGFpbnMocG9seTJTaW1wbGljaWVzW2ldKSB8fFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAocG9seTFTaW1wbGljaWVzLkNvbnRhaW5zKC1wb2x5MlNpbXBsaWNpZXNbaV0pICYmIGNsaXBUeXBlID09IFBvbHlDbGlwVHlwZS5VbmlvbikpXHJcbiAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBlZGdlQ2hhcmFjdGVyID0gMWY7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoaW50IGogPSAwOyBqIDwgcG9seTFTaW1wbGljaWVzLkNvdW50OyArK2opXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghcG9seTFTaW1wbGljaWVzLkNvbnRhaW5zKC1wb2x5MlNpbXBsaWNpZXNbaV0pKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVkZ2VDaGFyYWN0ZXIgKz0gQ2FsY3VsYXRlQmV0YShwb2x5MlNpbXBsaWNpZXNbaV0uR2V0Q2VudGVyKCksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvbHkxU2ltcGxpY2llc1tqXSwgcG9seTFDb2VmZltqXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNsaXBUeXBlID09IFBvbHlDbGlwVHlwZS5JbnRlcnNlY3QgfHwgY2xpcFR5cGUgPT0gUG9seUNsaXBUeXBlLkRpZmZlcmVuY2UpXHJcbiAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZWRnZUNoYXJhY3RlciA9PSAxZilcclxuICAgICAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0U2ltcGxpY2VzLkFkZCgtcG9seTJTaW1wbGljaWVzW2ldKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZWRnZUNoYXJhY3RlciA9PSAwZilcclxuICAgICAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0U2ltcGxpY2VzLkFkZChwb2x5MlNpbXBsaWNpZXNbaV0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIENhbGN1bGF0ZXMgdGhlIHBvbHlnb24ocykgZnJvbSB0aGUgcmVzdWx0IHNpbXBsaWNhbCBjaGFpbi5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8cmVtYXJrcz5Vc2VkIGJ5IG1ldGhvZCA8Yz5FeGVjdXRlKCk8L2M+LjwvcmVtYXJrcz5cclxuICAgICAgICBwcml2YXRlIHN0YXRpYyBQb2x5Q2xpcEVycm9yIEJ1aWxkUG9seWdvbnNGcm9tQ2hhaW4oTGlzdDxFZGdlPiBzaW1wbGljaWVzLCBvdXQgTGlzdDxWZXJ0aWNlcz4gcmVzdWx0KVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmVzdWx0ID0gbmV3IExpc3Q8VmVydGljZXM+KCk7XHJcbiAgICAgICAgICAgIFBvbHlDbGlwRXJyb3IgZXJyVmFsID0gUG9seUNsaXBFcnJvci5Ob25lO1xyXG5cclxuICAgICAgICAgICAgd2hpbGUgKHNpbXBsaWNpZXMuQ291bnQgPiAwKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBWZXJ0aWNlcyBvdXRwdXQgPSBuZXcgVmVydGljZXMoKTtcclxuICAgICAgICAgICAgICAgIG91dHB1dC5BZGQoc2ltcGxpY2llc1swXS5FZGdlU3RhcnQpO1xyXG4gICAgICAgICAgICAgICAgb3V0cHV0LkFkZChzaW1wbGljaWVzWzBdLkVkZ2VFbmQpO1xyXG4gICAgICAgICAgICAgICAgc2ltcGxpY2llcy5SZW1vdmVBdCgwKTtcclxuICAgICAgICAgICAgICAgIGJvb2wgY2xvc2VkID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICBpbnQgaW5kZXggPSAwO1xyXG4gICAgICAgICAgICAgICAgaW50IGNvdW50ID0gc2ltcGxpY2llcy5Db3VudDsgLy8gTmVlZGVkIHRvIGNhdGNoIGluZmluaXRlIGxvb3BzXHJcbiAgICAgICAgICAgICAgICB3aGlsZSAoIWNsb3NlZCAmJiBzaW1wbGljaWVzLkNvdW50ID4gMClcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoVmVjdG9yRXF1YWwob3V0cHV0W291dHB1dC5Db3VudCAtIDFdLCBzaW1wbGljaWVzW2luZGV4XS5FZGdlU3RhcnQpKVxyXG4gICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKFZlY3RvckVxdWFsKHNpbXBsaWNpZXNbaW5kZXhdLkVkZ2VFbmQsIG91dHB1dFswXSkpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsb3NlZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXQuQWRkKHNpbXBsaWNpZXNbaW5kZXhdLkVkZ2VFbmQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNpbXBsaWNpZXMuUmVtb3ZlQXQoaW5kZXgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAtLWluZGV4O1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChWZWN0b3JFcXVhbChvdXRwdXRbb3V0cHV0LkNvdW50IC0gMV0sIHNpbXBsaWNpZXNbaW5kZXhdLkVkZ2VFbmQpKVxyXG4gICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKFZlY3RvckVxdWFsKHNpbXBsaWNpZXNbaW5kZXhdLkVkZ2VTdGFydCwgb3V0cHV0WzBdKSlcclxuICAgICAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xvc2VkID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dC5BZGQoc2ltcGxpY2llc1tpbmRleF0uRWRnZVN0YXJ0KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBzaW1wbGljaWVzLlJlbW92ZUF0KGluZGV4KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLS1pbmRleDtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFjbG9zZWQpXHJcbiAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoKytpbmRleCA9PSBzaW1wbGljaWVzLkNvdW50KVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY291bnQgPT0gc2ltcGxpY2llcy5Db3VudClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBuZXcgTGlzdDxWZXJ0aWNlcz4oKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBEZWJ1Zy5Xcml0ZUxpbmUoXCJVbmRlZmluZWQgZXJyb3Igd2hpbGUgYnVpbGRpbmcgcmVzdWx0IHBvbHlnb24ocykuXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBQb2x5Q2xpcEVycm9yLkJyb2tlblJlc3VsdDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4ID0gMDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvdW50ID0gc2ltcGxpY2llcy5Db3VudDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChvdXRwdXQuQ291bnQgPCAzKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIGVyclZhbCA9IFBvbHlDbGlwRXJyb3IuRGVnZW5lcmF0ZWRPdXRwdXQ7XHJcbiAgICAgICAgICAgICAgICAgICAgRGVidWcuV3JpdGVMaW5lKFwiRGVnZW5lcmF0ZWQgb3V0cHV0IHBvbHlnb24gcHJvZHVjZWQgKHZlcnRpY2VzIDwgMykuXCIpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmVzdWx0LkFkZChvdXRwdXQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBlcnJWYWw7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIE5lZWRlZCB0byBjYWxjdWxhdGUgdGhlIGNoYXJhY3RlcmlzdGljcyBmdW5jdGlvbiBvZiBhIHNpbXBsZXguXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHJlbWFya3M+VXNlZCBieSBtZXRob2QgPGM+Q2FsY3VsYXRlRWRnZUNoYXJhY3RlcigpPC9jPi48L3JlbWFya3M+XHJcbiAgICAgICAgcHJpdmF0ZSBzdGF0aWMgZmxvYXQgQ2FsY3VsYXRlQmV0YShWZWN0b3IyIHBvaW50LCBFZGdlIGUsIGZsb2F0IGNvZWZmaWNpZW50KVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgZmxvYXQgcmVzdWx0ID0gMGY7XHJcbiAgICAgICAgICAgIGlmIChQb2ludEluU2ltcGxleChwb2ludCwgZSkpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHJlc3VsdCA9IGNvZWZmaWNpZW50O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChQb2ludE9uTGluZVNlZ21lbnQoVmVjdG9yMi5aZXJvLCBlLkVkZ2VTdGFydCwgcG9pbnQpIHx8XHJcbiAgICAgICAgICAgICAgICBQb2ludE9uTGluZVNlZ21lbnQoVmVjdG9yMi5aZXJvLCBlLkVkZ2VFbmQsIHBvaW50KSlcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gLjVmICogY29lZmZpY2llbnQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gTmVlZGVkIGZvciBzb3J0aW5nIG11bHRpcGxlIGludGVyc2VjdGlvbnMgcG9pbnRzIG9uIHRoZSBzYW1lIGVkZ2UuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHJlbWFya3M+VXNlZCBieSBtZXRob2QgPGM+Q2FsY3VsYXRlSW50ZXJzZWN0aW9ucygpPC9jPi48L3JlbWFya3M+XHJcbiAgICAgICAgcHJpdmF0ZSBzdGF0aWMgZmxvYXQgR2V0QWxwaGEoVmVjdG9yMiBzdGFydCwgVmVjdG9yMiBlbmQsIFZlY3RvcjIgcG9pbnQpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gKHBvaW50IC0gc3RhcnQpLkxlbmd0aFNxdWFyZWQoKSAvIChlbmQgLSBzdGFydCkuTGVuZ3RoU3F1YXJlZCgpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBSZXR1cm5zIHRoZSBjb2VmZmljaWVudCBvZiBhIHNpbXBsZXguXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHJlbWFya3M+VXNlZCBieSBtZXRob2QgPGM+Q2FsY3VsYXRlU2ltcGxpY2FsQ2hhaW4oKTwvYz4uPC9yZW1hcmtzPlxyXG4gICAgICAgIHByaXZhdGUgc3RhdGljIGZsb2F0IENhbGN1bGF0ZVNpbXBsZXhDb2VmZmljaWVudChWZWN0b3IyIGEsIFZlY3RvcjIgYiwgVmVjdG9yMiBjKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgZmxvYXQgaXNMZWZ0ID0gTWF0aFV0aWxzLkFyZWEocmVmIGEsIHJlZiBiLCByZWYgYyk7XHJcbiAgICAgICAgICAgIGlmIChpc0xlZnQgPCAwZilcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIC0xZjtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKGlzTGVmdCA+IDBmKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gMWY7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHJldHVybiAwZjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gV2luZGluZyBudW1iZXIgdGVzdCBmb3IgYSBwb2ludCBpbiBhIHNpbXBsZXguXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJwb2ludFwiPlRoZSBwb2ludCB0byBiZSB0ZXN0ZWQuPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJlZGdlXCI+VGhlIGVkZ2UgdGhhdCB0aGUgcG9pbnQgaXMgdGVzdGVkIGFnYWluc3QuPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHJldHVybnM+RmFsc2UgaWYgdGhlIHdpbmRpbmcgbnVtYmVyIGlzIGV2ZW4gYW5kIHRoZSBwb2ludCBpcyBvdXRzaWRlXHJcbiAgICAgICAgLy8vIHRoZSBzaW1wbGV4IGFuZCBUcnVlIG90aGVyd2lzZS48L3JldHVybnM+XHJcbiAgICAgICAgcHJpdmF0ZSBzdGF0aWMgYm9vbCBQb2ludEluU2ltcGxleChWZWN0b3IyIHBvaW50LCBFZGdlIGVkZ2UpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBWZXJ0aWNlcyBwb2x5Z29uID0gbmV3IFZlcnRpY2VzKCk7XHJcbiAgICAgICAgICAgIHBvbHlnb24uQWRkKFZlY3RvcjIuWmVybyk7XHJcbiAgICAgICAgICAgIHBvbHlnb24uQWRkKGVkZ2UuRWRnZVN0YXJ0KTtcclxuICAgICAgICAgICAgcG9seWdvbi5BZGQoZWRnZS5FZGdlRW5kKTtcclxuICAgICAgICAgICAgcmV0dXJuIChwb2x5Z29uLlBvaW50SW5Qb2x5Z29uKHJlZiBwb2ludCkgPT0gMSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIFRlc3RzIGlmIGEgcG9pbnQgbGllcyBvbiBhIGxpbmUgc2VnbWVudC5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8cmVtYXJrcz5Vc2VkIGJ5IG1ldGhvZCA8Yz5DYWxjdWxhdGVCZXRhKCk8L2M+LjwvcmVtYXJrcz5cclxuICAgICAgICBwcml2YXRlIHN0YXRpYyBib29sIFBvaW50T25MaW5lU2VnbWVudChWZWN0b3IyIHN0YXJ0LCBWZWN0b3IyIGVuZCwgVmVjdG9yMiBwb2ludClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIFZlY3RvcjIgc2VnbWVudCA9IGVuZCAtIHN0YXJ0O1xyXG4gICAgICAgICAgICByZXR1cm4gTWF0aFV0aWxzLkFyZWEocmVmIHN0YXJ0LCByZWYgZW5kLCByZWYgcG9pbnQpID09IDBmICYmXHJcbiAgICAgICAgICAgICAgICAgICBWZWN0b3IyLkRvdChwb2ludCAtIHN0YXJ0LCBzZWdtZW50KSA+PSAwZiAmJlxyXG4gICAgICAgICAgICAgICAgICAgVmVjdG9yMi5Eb3QocG9pbnQgLSBlbmQsIHNlZ21lbnQpIDw9IDBmO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHJpdmF0ZSBzdGF0aWMgYm9vbCBWZWN0b3JFcXVhbChWZWN0b3IyIHZlYzEsIFZlY3RvcjIgdmVjMilcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiAodmVjMiAtIHZlYzEpLkxlbmd0aFNxdWFyZWQoKSA8PSBDbGlwcGVyRXBzaWxvblNxdWFyZWQ7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAjcmVnaW9uIE5lc3RlZCB0eXBlOiBFZGdlXHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5TcGVjaWZpZXMgYW4gRWRnZS4gRWRnZXMgYXJlIHVzZWQgdG8gcmVwcmVzZW50IHNpbXBsaWNpZXMgaW4gc2ltcGxpY2FsIGNoYWluczwvc3VtbWFyeT5cclxuICAgICAgICBwcml2YXRlIHNlYWxlZCBjbGFzcyBFZGdlXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBwdWJsaWMgRWRnZShWZWN0b3IyIGVkZ2VTdGFydCwgVmVjdG9yMiBlZGdlRW5kKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBFZGdlU3RhcnQgPSBlZGdlU3RhcnQ7XHJcbiAgICAgICAgICAgICAgICBFZGdlRW5kID0gZWRnZUVuZDtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcHVibGljIFZlY3RvcjIgRWRnZVN0YXJ0IHsgZ2V0OyBwcml2YXRlIHNldDsgfVxyXG4gICAgICAgICAgICBwdWJsaWMgVmVjdG9yMiBFZGdlRW5kIHsgZ2V0OyBwcml2YXRlIHNldDsgfVxyXG5cclxuICAgICAgICAgICAgcHVibGljIFZlY3RvcjIgR2V0Q2VudGVyKClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIChFZGdlU3RhcnQgKyBFZGdlRW5kKSAvIDJmO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBwdWJsaWMgc3RhdGljIEVkZ2Ugb3BlcmF0b3IgLShFZGdlIGUpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgRWRnZShlLkVkZ2VFbmQsIGUuRWRnZVN0YXJ0KTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcHVibGljIG92ZXJyaWRlIGJvb2wgRXF1YWxzKE9iamVjdCBvYmopXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIC8vIElmIHBhcmFtZXRlciBpcyBudWxsIHJldHVybiBmYWxzZS5cclxuICAgICAgICAgICAgICAgIGlmIChvYmogPT0gbnVsbClcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gSWYgcGFyYW1ldGVyIGNhbm5vdCBiZSBjYXN0IHRvIFBvaW50IHJldHVybiBmYWxzZS5cclxuICAgICAgICAgICAgICAgIHJldHVybiBFcXVhbHMob2JqIGFzIEVkZ2UpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBwdWJsaWMgYm9vbCBFcXVhbHMoRWRnZSBlKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAvLyBJZiBwYXJhbWV0ZXIgaXMgbnVsbCByZXR1cm4gZmFsc2U6XHJcbiAgICAgICAgICAgICAgICBpZiAoZSA9PSBudWxsKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAvLyBSZXR1cm4gdHJ1ZSBpZiB0aGUgZmllbGRzIG1hdGNoXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gVmVjdG9yRXF1YWwoRWRnZVN0YXJ0LCBlLkVkZ2VTdGFydCkgJiYgVmVjdG9yRXF1YWwoRWRnZUVuZCwgZS5FZGdlRW5kKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcHVibGljIG92ZXJyaWRlIGludCBHZXRIYXNoQ29kZSgpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBFZGdlU3RhcnQuR2V0SGFzaENvZGUoKSBeIEVkZ2VFbmQuR2V0SGFzaENvZGUoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgI2VuZHJlZ2lvblxyXG4gICAgfVxyXG59IiwidXNpbmcgU3lzdGVtO1xyXG51c2luZyBTeXN0ZW0uQ29sbGVjdGlvbnMuR2VuZXJpYztcclxudXNpbmcgU3lzdGVtLkRpYWdub3N0aWNzO1xyXG51c2luZyBNaWNyb3NvZnQuWG5hLkZyYW1ld29yaztcclxuXHJcbm5hbWVzcGFjZSBGYXJzZWVyUGh5c2ljcy5Db21tb25cclxue1xyXG4gICAgcHVibGljIHN0YXRpYyBjbGFzcyBQb2x5Z29uVG9vbHNcclxuICAgIHtcclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIEJ1aWxkIHZlcnRpY2VzIHRvIHJlcHJlc2VudCBhbiBheGlzLWFsaWduZWQgYm94LlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwiaHhcIj50aGUgaGFsZi13aWR0aC48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cImh5XCI+dGhlIGhhbGYtaGVpZ2h0LjwvcGFyYW0+XHJcbiAgICAgICAgcHVibGljIHN0YXRpYyBWZXJ0aWNlcyBDcmVhdGVSZWN0YW5nbGUoZmxvYXQgaHgsIGZsb2F0IGh5KVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgVmVydGljZXMgdmVydGljZXMgPSBuZXcgVmVydGljZXMoNCk7XHJcbiAgICAgICAgICAgIHZlcnRpY2VzLkFkZChuZXcgVmVjdG9yMigtaHgsIC1oeSkpO1xyXG4gICAgICAgICAgICB2ZXJ0aWNlcy5BZGQobmV3IFZlY3RvcjIoaHgsIC1oeSkpO1xyXG4gICAgICAgICAgICB2ZXJ0aWNlcy5BZGQobmV3IFZlY3RvcjIoaHgsIGh5KSk7XHJcbiAgICAgICAgICAgIHZlcnRpY2VzLkFkZChuZXcgVmVjdG9yMigtaHgsIGh5KSk7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gdmVydGljZXM7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIEJ1aWxkIHZlcnRpY2VzIHRvIHJlcHJlc2VudCBhbiBvcmllbnRlZCBib3guXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJoeFwiPnRoZSBoYWxmLXdpZHRoLjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwiaHlcIj50aGUgaGFsZi1oZWlnaHQuPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJjZW50ZXJcIj50aGUgY2VudGVyIG9mIHRoZSBib3ggaW4gbG9jYWwgY29vcmRpbmF0ZXMuPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJhbmdsZVwiPnRoZSByb3RhdGlvbiBvZiB0aGUgYm94IGluIGxvY2FsIGNvb3JkaW5hdGVzLjwvcGFyYW0+XHJcbiAgICAgICAgcHVibGljIHN0YXRpYyBWZXJ0aWNlcyBDcmVhdGVSZWN0YW5nbGUoZmxvYXQgaHgsIGZsb2F0IGh5LCBWZWN0b3IyIGNlbnRlciwgZmxvYXQgYW5nbGUpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBWZXJ0aWNlcyB2ZXJ0aWNlcyA9IENyZWF0ZVJlY3RhbmdsZShoeCwgaHkpO1xyXG5cclxuICAgICAgICAgICAgVHJhbnNmb3JtIHhmID0gbmV3IFRyYW5zZm9ybSgpO1xyXG4gICAgICAgICAgICB4Zi5Qb3NpdGlvbiA9IGNlbnRlcjtcclxuICAgICAgICAgICAgeGYuUi5TZXQoYW5nbGUpO1xyXG5cclxuICAgICAgICAgICAgLy8gVHJhbnNmb3JtIHZlcnRpY2VzXHJcbiAgICAgICAgICAgIGZvciAoaW50IGkgPSAwOyBpIDwgNDsgKytpKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB2ZXJ0aWNlc1tpXSA9IE1hdGhVdGlscy5NdWx0aXBseShyZWYgeGYsIHZlcnRpY2VzW2ldKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuIHZlcnRpY2VzO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy9Sb3VuZGVkIHJlY3RhbmdsZSBjb250cmlidXRlZCBieSBKb25hdGhhbiBTbWFycyAtIGpzbWFyc0BnbWFpbC5jb21cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBDcmVhdGVzIGEgcm91bmRlZCByZWN0YW5nbGUgd2l0aCB0aGUgc3BlY2lmaWVkIHdpZHRoIGFuZCBoZWlnaHQuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJ3aWR0aFwiPlRoZSB3aWR0aC48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cImhlaWdodFwiPlRoZSBoZWlnaHQuPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJ4UmFkaXVzXCI+VGhlIHJvdW5kaW5nIFggcmFkaXVzLjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwieVJhZGl1c1wiPlRoZSByb3VuZGluZyBZIHJhZGl1cy48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cInNlZ21lbnRzXCI+VGhlIG51bWJlciBvZiBzZWdtZW50cyB0byBzdWJkaXZpZGUgdGhlIGVkZ2VzLjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxyZXR1cm5zPjwvcmV0dXJucz5cclxuICAgICAgICBwdWJsaWMgc3RhdGljIFZlcnRpY2VzIENyZWF0ZVJvdW5kZWRSZWN0YW5nbGUoZmxvYXQgd2lkdGgsIGZsb2F0IGhlaWdodCwgZmxvYXQgeFJhZGl1cywgZmxvYXQgeVJhZGl1cyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW50IHNlZ21lbnRzKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgaWYgKHlSYWRpdXMgPiBoZWlnaHQgLyAyIHx8IHhSYWRpdXMgPiB3aWR0aCAvIDIpXHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXhjZXB0aW9uKFwiUm91bmRpbmcgYW1vdW50IGNhbid0IGJlIG1vcmUgdGhhbiBoYWxmIHRoZSBoZWlnaHQgYW5kIHdpZHRoIHJlc3BlY3RpdmVseS5cIik7XHJcbiAgICAgICAgICAgIGlmIChzZWdtZW50cyA8IDApXHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXhjZXB0aW9uKFwiU2VnbWVudHMgbXVzdCBiZSB6ZXJvIG9yIG1vcmUuXCIpO1xyXG5cclxuICAgICAgICAgICAgLy9XZSBuZWVkIGF0IGxlYXN0IDggdmVydGljZXMgdG8gY3JlYXRlIGEgcm91bmRlZCByZWN0YW5nbGVcclxuICAgICAgICAgICAgRGVidWcuQXNzZXJ0KFNldHRpbmdzLk1heFBvbHlnb25WZXJ0aWNlcyA+PSA4KTtcclxuXHJcbiAgICAgICAgICAgIFZlcnRpY2VzIHZlcnRpY2VzID0gbmV3IFZlcnRpY2VzKCk7XHJcbiAgICAgICAgICAgIGlmIChzZWdtZW50cyA9PSAwKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB2ZXJ0aWNlcy5BZGQobmV3IFZlY3RvcjIod2lkdGggKiAuNWYgLSB4UmFkaXVzLCAtaGVpZ2h0ICogLjVmKSk7XHJcbiAgICAgICAgICAgICAgICB2ZXJ0aWNlcy5BZGQobmV3IFZlY3RvcjIod2lkdGggKiAuNWYsIC1oZWlnaHQgKiAuNWYgKyB5UmFkaXVzKSk7XHJcblxyXG4gICAgICAgICAgICAgICAgdmVydGljZXMuQWRkKG5ldyBWZWN0b3IyKHdpZHRoICogLjVmLCBoZWlnaHQgKiAuNWYgLSB5UmFkaXVzKSk7XHJcbiAgICAgICAgICAgICAgICB2ZXJ0aWNlcy5BZGQobmV3IFZlY3RvcjIod2lkdGggKiAuNWYgLSB4UmFkaXVzLCBoZWlnaHQgKiAuNWYpKTtcclxuXHJcbiAgICAgICAgICAgICAgICB2ZXJ0aWNlcy5BZGQobmV3IFZlY3RvcjIoLXdpZHRoICogLjVmICsgeFJhZGl1cywgaGVpZ2h0ICogLjVmKSk7XHJcbiAgICAgICAgICAgICAgICB2ZXJ0aWNlcy5BZGQobmV3IFZlY3RvcjIoLXdpZHRoICogLjVmLCBoZWlnaHQgKiAuNWYgLSB5UmFkaXVzKSk7XHJcblxyXG4gICAgICAgICAgICAgICAgdmVydGljZXMuQWRkKG5ldyBWZWN0b3IyKC13aWR0aCAqIC41ZiwgLWhlaWdodCAqIC41ZiArIHlSYWRpdXMpKTtcclxuICAgICAgICAgICAgICAgIHZlcnRpY2VzLkFkZChuZXcgVmVjdG9yMigtd2lkdGggKiAuNWYgKyB4UmFkaXVzLCAtaGVpZ2h0ICogLjVmKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBpbnQgbnVtYmVyT2ZFZGdlcyA9IChzZWdtZW50cyAqIDQgKyA4KTtcclxuXHJcbiAgICAgICAgICAgICAgICBmbG9hdCBzdGVwU2l6ZSA9IE1hdGhIZWxwZXIuVHdvUGkgLyAobnVtYmVyT2ZFZGdlcyAtIDQpO1xyXG4gICAgICAgICAgICAgICAgaW50IHBlclBoYXNlID0gbnVtYmVyT2ZFZGdlcyAvIDQ7XHJcblxyXG4gICAgICAgICAgICAgICAgVmVjdG9yMiBwb3NPZmZzZXQgPSBuZXcgVmVjdG9yMih3aWR0aCAvIDIgLSB4UmFkaXVzLCBoZWlnaHQgLyAyIC0geVJhZGl1cyk7XHJcbiAgICAgICAgICAgICAgICB2ZXJ0aWNlcy5BZGQocG9zT2Zmc2V0ICsgbmV3IFZlY3RvcjIoeFJhZGl1cywgLXlSYWRpdXMgKyB5UmFkaXVzKSk7XHJcbiAgICAgICAgICAgICAgICBzaG9ydCBwaGFzZSA9IDA7XHJcbiAgICAgICAgICAgICAgICBmb3IgKGludCBpID0gMTsgaSA8IG51bWJlck9mRWRnZXM7IGkrKylcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoaSAtIHBlclBoYXNlID09IDAgfHwgaSAtIHBlclBoYXNlICogMyA9PSAwKVxyXG4gICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcG9zT2Zmc2V0LlggKj0gLTE7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBoYXNlLS07XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGkgLSBwZXJQaGFzZSAqIDIgPT0gMClcclxuICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvc09mZnNldC5ZICo9IC0xO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBwaGFzZS0tO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgdmVydGljZXMuQWRkKHBvc09mZnNldCArIG5ldyBWZWN0b3IyKHhSYWRpdXMgKiAoZmxvYXQpTWF0aC5Db3Moc3RlcFNpemUgKiAtKGkgKyBwaGFzZSkpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAteVJhZGl1cyAqIChmbG9hdClNYXRoLlNpbihzdGVwU2l6ZSAqIC0oaSArIHBoYXNlKSkpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuIHZlcnRpY2VzO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBTZXQgdGhpcyBhcyBhIHNpbmdsZSBlZGdlLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwic3RhcnRcIj5UaGUgZmlyc3QgcG9pbnQuPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJlbmRcIj5UaGUgc2Vjb25kIHBvaW50LjwvcGFyYW0+XHJcbiAgICAgICAgcHVibGljIHN0YXRpYyBWZXJ0aWNlcyBDcmVhdGVMaW5lKFZlY3RvcjIgc3RhcnQsIFZlY3RvcjIgZW5kKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgVmVydGljZXMgdmVydGljZXMgPSBuZXcgVmVydGljZXMoMik7XHJcbiAgICAgICAgICAgIHZlcnRpY2VzLkFkZChzdGFydCk7XHJcbiAgICAgICAgICAgIHZlcnRpY2VzLkFkZChlbmQpO1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIHZlcnRpY2VzO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBDcmVhdGVzIGEgY2lyY2xlIHdpdGggdGhlIHNwZWNpZmllZCByYWRpdXMgYW5kIG51bWJlciBvZiBlZGdlcy5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cInJhZGl1c1wiPlRoZSByYWRpdXMuPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJudW1iZXJPZkVkZ2VzXCI+VGhlIG51bWJlciBvZiBlZGdlcy4gVGhlIG1vcmUgZWRnZXMsIHRoZSBtb3JlIGl0IHJlc2VtYmxlcyBhIGNpcmNsZTwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxyZXR1cm5zPjwvcmV0dXJucz5cclxuICAgICAgICBwdWJsaWMgc3RhdGljIFZlcnRpY2VzIENyZWF0ZUNpcmNsZShmbG9hdCByYWRpdXMsIGludCBudW1iZXJPZkVkZ2VzKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIENyZWF0ZUVsbGlwc2UocmFkaXVzLCByYWRpdXMsIG51bWJlck9mRWRnZXMpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBDcmVhdGVzIGEgZWxsaXBzZSB3aXRoIHRoZSBzcGVjaWZpZWQgd2lkdGgsIGhlaWdodCBhbmQgbnVtYmVyIG9mIGVkZ2VzLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwieFJhZGl1c1wiPldpZHRoIG9mIHRoZSBlbGxpcHNlLjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwieVJhZGl1c1wiPkhlaWdodCBvZiB0aGUgZWxsaXBzZS48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cIm51bWJlck9mRWRnZXNcIj5UaGUgbnVtYmVyIG9mIGVkZ2VzLiBUaGUgbW9yZSBlZGdlcywgdGhlIG1vcmUgaXQgcmVzZW1ibGVzIGFuIGVsbGlwc2U8L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cmV0dXJucz48L3JldHVybnM+XHJcbiAgICAgICAgcHVibGljIHN0YXRpYyBWZXJ0aWNlcyBDcmVhdGVFbGxpcHNlKGZsb2F0IHhSYWRpdXMsIGZsb2F0IHlSYWRpdXMsIGludCBudW1iZXJPZkVkZ2VzKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgVmVydGljZXMgdmVydGljZXMgPSBuZXcgVmVydGljZXMoKTtcclxuXHJcbiAgICAgICAgICAgIGZsb2F0IHN0ZXBTaXplID0gTWF0aEhlbHBlci5Ud29QaSAvIG51bWJlck9mRWRnZXM7XHJcblxyXG4gICAgICAgICAgICB2ZXJ0aWNlcy5BZGQobmV3IFZlY3RvcjIoeFJhZGl1cywgMCkpO1xyXG4gICAgICAgICAgICBmb3IgKGludCBpID0gbnVtYmVyT2ZFZGdlcyAtIDE7IGkgPiAwOyAtLWkpXHJcbiAgICAgICAgICAgICAgICB2ZXJ0aWNlcy5BZGQobmV3IFZlY3RvcjIoeFJhZGl1cyAqIChmbG9hdClNYXRoLkNvcyhzdGVwU2l6ZSAqIGkpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC15UmFkaXVzICogKGZsb2F0KU1hdGguU2luKHN0ZXBTaXplICogaSkpKTtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiB2ZXJ0aWNlcztcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHB1YmxpYyBzdGF0aWMgVmVydGljZXMgQ3JlYXRlQXJjKGZsb2F0IHJhZGlhbnMsIGludCBzaWRlcywgZmxvYXQgcmFkaXVzKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgRGVidWcuQXNzZXJ0KHJhZGlhbnMgPiAwLCBcIlRoZSBhcmMgbmVlZHMgdG8gYmUgbGFyZ2VyIHRoYW4gMFwiKTtcclxuICAgICAgICAgICAgRGVidWcuQXNzZXJ0KHNpZGVzID4gMSwgXCJUaGUgYXJjIG5lZWRzIHRvIGhhdmUgbW9yZSB0aGFuIDEgc2lkZXNcIik7XHJcbiAgICAgICAgICAgIERlYnVnLkFzc2VydChyYWRpdXMgPiAwLCBcIlRoZSBhcmMgbmVlZHMgdG8gaGF2ZSBhIHJhZGl1cyBsYXJnZXIgdGhhbiAwXCIpO1xyXG5cclxuICAgICAgICAgICAgVmVydGljZXMgdmVydGljZXMgPSBuZXcgVmVydGljZXMoKTtcclxuXHJcbiAgICAgICAgICAgIGZsb2F0IHN0ZXBTaXplID0gcmFkaWFucyAvIHNpZGVzO1xyXG4gICAgICAgICAgICBmb3IgKGludCBpID0gc2lkZXMgLSAxOyBpID4gMDsgaS0tKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB2ZXJ0aWNlcy5BZGQobmV3IFZlY3RvcjIocmFkaXVzICogKGZsb2F0KU1hdGguQ29zKHN0ZXBTaXplICogaSksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmFkaXVzICogKGZsb2F0KU1hdGguU2luKHN0ZXBTaXplICogaSkpKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuIHZlcnRpY2VzO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy9DYXBzdWxlIGNvbnRyaWJ1dGVkIGJ5IFlvYml2XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gQ3JlYXRlcyBhbiBjYXBzdWxlIHdpdGggdGhlIHNwZWNpZmllZCBoZWlnaHQsIHJhZGl1cyBhbmQgbnVtYmVyIG9mIGVkZ2VzLlxyXG4gICAgICAgIC8vLyBBIGNhcHN1bGUgaGFzIHRoZSBzYW1lIGZvcm0gYXMgYSBwaWxsIGNhcHN1bGUuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJoZWlnaHRcIj5IZWlnaHQgKGlubmVyIGhlaWdodCArIDIgKiByYWRpdXMpIG9mIHRoZSBjYXBzdWxlLjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwiZW5kUmFkaXVzXCI+UmFkaXVzIG9mIHRoZSBjYXBzdWxlIGVuZHMuPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJlZGdlc1wiPlRoZSBudW1iZXIgb2YgZWRnZXMgb2YgdGhlIGNhcHN1bGUgZW5kcy4gVGhlIG1vcmUgZWRnZXMsIHRoZSBtb3JlIGl0IHJlc2VtYmxlcyBhbiBjYXBzdWxlPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHJldHVybnM+PC9yZXR1cm5zPlxyXG4gICAgICAgIHB1YmxpYyBzdGF0aWMgVmVydGljZXMgQ3JlYXRlQ2Fwc3VsZShmbG9hdCBoZWlnaHQsIGZsb2F0IGVuZFJhZGl1cywgaW50IGVkZ2VzKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgaWYgKGVuZFJhZGl1cyA+PSBoZWlnaHQgLyAyKVxyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEFyZ3VtZW50RXhjZXB0aW9uKFxyXG4gICAgICAgICAgICAgICAgICAgIFwiVGhlIHJhZGl1cyBtdXN0IGJlIGxvd2VyIHRoYW4gaGVpZ2h0IC8gMi4gSGlnaGVyIHZhbHVlcyBvZiByYWRpdXMgd291bGQgY3JlYXRlIGEgY2lyY2xlLCBhbmQgbm90IGEgaGFsZiBjaXJjbGUuXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgXCJlbmRSYWRpdXNcIik7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gQ3JlYXRlQ2Fwc3VsZShoZWlnaHQsIGVuZFJhZGl1cywgZWRnZXMsIGVuZFJhZGl1cywgZWRnZXMpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBDcmVhdGVzIGFuIGNhcHN1bGUgd2l0aCB0aGUgc3BlY2lmaWVkICBoZWlnaHQsIHJhZGl1cyBhbmQgbnVtYmVyIG9mIGVkZ2VzLlxyXG4gICAgICAgIC8vLyBBIGNhcHN1bGUgaGFzIHRoZSBzYW1lIGZvcm0gYXMgYSBwaWxsIGNhcHN1bGUuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJoZWlnaHRcIj5IZWlnaHQgKGlubmVyIGhlaWdodCArIHJhZGlpKSBvZiB0aGUgY2Fwc3VsZS48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cInRvcFJhZGl1c1wiPlJhZGl1cyBvZiB0aGUgdG9wLjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwidG9wRWRnZXNcIj5UaGUgbnVtYmVyIG9mIGVkZ2VzIG9mIHRoZSB0b3AuIFRoZSBtb3JlIGVkZ2VzLCB0aGUgbW9yZSBpdCByZXNlbWJsZXMgYW4gY2Fwc3VsZTwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwiYm90dG9tUmFkaXVzXCI+UmFkaXVzIG9mIGJvdHRvbS48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cImJvdHRvbUVkZ2VzXCI+VGhlIG51bWJlciBvZiBlZGdlcyBvZiB0aGUgYm90dG9tLiBUaGUgbW9yZSBlZGdlcywgdGhlIG1vcmUgaXQgcmVzZW1ibGVzIGFuIGNhcHN1bGU8L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cmV0dXJucz48L3JldHVybnM+XHJcbiAgICAgICAgcHVibGljIHN0YXRpYyBWZXJ0aWNlcyBDcmVhdGVDYXBzdWxlKGZsb2F0IGhlaWdodCwgZmxvYXQgdG9wUmFkaXVzLCBpbnQgdG9wRWRnZXMsIGZsb2F0IGJvdHRvbVJhZGl1cyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW50IGJvdHRvbUVkZ2VzKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgaWYgKGhlaWdodCA8PSAwKVxyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEFyZ3VtZW50RXhjZXB0aW9uKFwiSGVpZ2h0IG11c3QgYmUgbG9uZ2VyIHRoYW4gMFwiLCBcImhlaWdodFwiKTtcclxuXHJcbiAgICAgICAgICAgIGlmICh0b3BSYWRpdXMgPD0gMClcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBBcmd1bWVudEV4Y2VwdGlvbihcIlRoZSB0b3AgcmFkaXVzIG11c3QgYmUgbW9yZSB0aGFuIDBcIiwgXCJ0b3BSYWRpdXNcIik7XHJcblxyXG4gICAgICAgICAgICBpZiAodG9wRWRnZXMgPD0gMClcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBBcmd1bWVudEV4Y2VwdGlvbihcIlRvcCBlZGdlcyBtdXN0IGJlIG1vcmUgdGhhbiAwXCIsIFwidG9wRWRnZXNcIik7XHJcblxyXG4gICAgICAgICAgICBpZiAoYm90dG9tUmFkaXVzIDw9IDApXHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQXJndW1lbnRFeGNlcHRpb24oXCJUaGUgYm90dG9tIHJhZGl1cyBtdXN0IGJlIG1vcmUgdGhhbiAwXCIsIFwiYm90dG9tUmFkaXVzXCIpO1xyXG5cclxuICAgICAgICAgICAgaWYgKGJvdHRvbUVkZ2VzIDw9IDApXHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQXJndW1lbnRFeGNlcHRpb24oXCJCb3R0b20gZWRnZXMgbXVzdCBiZSBtb3JlIHRoYW4gMFwiLCBcImJvdHRvbUVkZ2VzXCIpO1xyXG5cclxuICAgICAgICAgICAgaWYgKHRvcFJhZGl1cyA+PSBoZWlnaHQgLyAyKVxyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEFyZ3VtZW50RXhjZXB0aW9uKFxyXG4gICAgICAgICAgICAgICAgICAgIFwiVGhlIHRvcCByYWRpdXMgbXVzdCBiZSBsb3dlciB0aGFuIGhlaWdodCAvIDIuIEhpZ2hlciB2YWx1ZXMgb2YgdG9wIHJhZGl1cyB3b3VsZCBjcmVhdGUgYSBjaXJjbGUsIGFuZCBub3QgYSBoYWxmIGNpcmNsZS5cIixcclxuICAgICAgICAgICAgICAgICAgICBcInRvcFJhZGl1c1wiKTtcclxuXHJcbiAgICAgICAgICAgIGlmIChib3R0b21SYWRpdXMgPj0gaGVpZ2h0IC8gMilcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBBcmd1bWVudEV4Y2VwdGlvbihcclxuICAgICAgICAgICAgICAgICAgICBcIlRoZSBib3R0b20gcmFkaXVzIG11c3QgYmUgbG93ZXIgdGhhbiBoZWlnaHQgLyAyLiBIaWdoZXIgdmFsdWVzIG9mIGJvdHRvbSByYWRpdXMgd291bGQgY3JlYXRlIGEgY2lyY2xlLCBhbmQgbm90IGEgaGFsZiBjaXJjbGUuXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgXCJib3R0b21SYWRpdXNcIik7XHJcblxyXG4gICAgICAgICAgICBWZXJ0aWNlcyB2ZXJ0aWNlcyA9IG5ldyBWZXJ0aWNlcygpO1xyXG5cclxuICAgICAgICAgICAgZmxvYXQgbmV3SGVpZ2h0ID0gKGhlaWdodCAtIHRvcFJhZGl1cyAtIGJvdHRvbVJhZGl1cykgKiAwLjVmO1xyXG5cclxuICAgICAgICAgICAgLy8gdG9wXHJcbiAgICAgICAgICAgIHZlcnRpY2VzLkFkZChuZXcgVmVjdG9yMih0b3BSYWRpdXMsIG5ld0hlaWdodCkpO1xyXG5cclxuICAgICAgICAgICAgZmxvYXQgc3RlcFNpemUgPSBNYXRoSGVscGVyLlBpIC8gdG9wRWRnZXM7XHJcbiAgICAgICAgICAgIGZvciAoaW50IGkgPSAxOyBpIDwgdG9wRWRnZXM7IGkrKylcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdmVydGljZXMuQWRkKG5ldyBWZWN0b3IyKHRvcFJhZGl1cyAqIChmbG9hdClNYXRoLkNvcyhzdGVwU2l6ZSAqIGkpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvcFJhZGl1cyAqIChmbG9hdClNYXRoLlNpbihzdGVwU2l6ZSAqIGkpICsgbmV3SGVpZ2h0KSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHZlcnRpY2VzLkFkZChuZXcgVmVjdG9yMigtdG9wUmFkaXVzLCBuZXdIZWlnaHQpKTtcclxuXHJcbiAgICAgICAgICAgIC8vIGJvdHRvbVxyXG4gICAgICAgICAgICB2ZXJ0aWNlcy5BZGQobmV3IFZlY3RvcjIoLWJvdHRvbVJhZGl1cywgLW5ld0hlaWdodCkpO1xyXG5cclxuICAgICAgICAgICAgc3RlcFNpemUgPSBNYXRoSGVscGVyLlBpIC8gYm90dG9tRWRnZXM7XHJcbiAgICAgICAgICAgIGZvciAoaW50IGkgPSAxOyBpIDwgYm90dG9tRWRnZXM7IGkrKylcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdmVydGljZXMuQWRkKG5ldyBWZWN0b3IyKC1ib3R0b21SYWRpdXMgKiAoZmxvYXQpTWF0aC5Db3Moc3RlcFNpemUgKiBpKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAtYm90dG9tUmFkaXVzICogKGZsb2F0KU1hdGguU2luKHN0ZXBTaXplICogaSkgLSBuZXdIZWlnaHQpKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdmVydGljZXMuQWRkKG5ldyBWZWN0b3IyKGJvdHRvbVJhZGl1cywgLW5ld0hlaWdodCkpO1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIHZlcnRpY2VzO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBDcmVhdGVzIGEgZ2VhciBzaGFwZSB3aXRoIHRoZSBzcGVjaWZpZWQgcmFkaXVzIGFuZCBudW1iZXIgb2YgdGVldGguXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJyYWRpdXNcIj5UaGUgcmFkaXVzLjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwibnVtYmVyT2ZUZWV0aFwiPlRoZSBudW1iZXIgb2YgdGVldGguPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJ0aXBQZXJjZW50YWdlXCI+VGhlIHRpcCBwZXJjZW50YWdlLjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwidG9vdGhIZWlnaHRcIj5IZWlnaHQgb2YgdGhlIHRvb3RoLjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxyZXR1cm5zPjwvcmV0dXJucz5cclxuICAgICAgICBwdWJsaWMgc3RhdGljIFZlcnRpY2VzIENyZWF0ZUdlYXIoZmxvYXQgcmFkaXVzLCBpbnQgbnVtYmVyT2ZUZWV0aCwgZmxvYXQgdGlwUGVyY2VudGFnZSwgZmxvYXQgdG9vdGhIZWlnaHQpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBWZXJ0aWNlcyB2ZXJ0aWNlcyA9IG5ldyBWZXJ0aWNlcygpO1xyXG5cclxuICAgICAgICAgICAgZmxvYXQgc3RlcFNpemUgPSBNYXRoSGVscGVyLlR3b1BpIC8gbnVtYmVyT2ZUZWV0aDtcclxuICAgICAgICAgICAgdGlwUGVyY2VudGFnZSAvPSAxMDBmO1xyXG4gICAgICAgICAgICBNYXRoSGVscGVyLkNsYW1wKHRpcFBlcmNlbnRhZ2UsIDBmLCAxZik7XHJcbiAgICAgICAgICAgIGZsb2F0IHRvb3RoVGlwU3RlcFNpemUgPSAoc3RlcFNpemUgLyAyZikgKiB0aXBQZXJjZW50YWdlO1xyXG5cclxuICAgICAgICAgICAgZmxvYXQgdG9vdGhBbmdsZVN0ZXBTaXplID0gKHN0ZXBTaXplIC0gKHRvb3RoVGlwU3RlcFNpemUgKiAyZikpIC8gMmY7XHJcblxyXG4gICAgICAgICAgICBmb3IgKGludCBpID0gbnVtYmVyT2ZUZWV0aCAtIDE7IGkgPj0gMDsgLS1pKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBpZiAodG9vdGhUaXBTdGVwU2l6ZSA+IDBmKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIHZlcnRpY2VzLkFkZChcclxuICAgICAgICAgICAgICAgICAgICAgICAgbmV3IFZlY3RvcjIocmFkaXVzICpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKGZsb2F0KU1hdGguQ29zKHN0ZXBTaXplICogaSArIHRvb3RoQW5nbGVTdGVwU2l6ZSAqIDJmICsgdG9vdGhUaXBTdGVwU2l6ZSksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC1yYWRpdXMgKlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoZmxvYXQpTWF0aC5TaW4oc3RlcFNpemUgKiBpICsgdG9vdGhBbmdsZVN0ZXBTaXplICogMmYgKyB0b290aFRpcFN0ZXBTaXplKSkpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICB2ZXJ0aWNlcy5BZGQoXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ldyBWZWN0b3IyKChyYWRpdXMgKyB0b290aEhlaWdodCkgKlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoZmxvYXQpTWF0aC5Db3Moc3RlcFNpemUgKiBpICsgdG9vdGhBbmdsZVN0ZXBTaXplICsgdG9vdGhUaXBTdGVwU2l6ZSksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC0ocmFkaXVzICsgdG9vdGhIZWlnaHQpICpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKGZsb2F0KU1hdGguU2luKHN0ZXBTaXplICogaSArIHRvb3RoQW5nbGVTdGVwU2l6ZSArIHRvb3RoVGlwU3RlcFNpemUpKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgdmVydGljZXMuQWRkKG5ldyBWZWN0b3IyKChyYWRpdXMgKyB0b290aEhlaWdodCkgKlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChmbG9hdClNYXRoLkNvcyhzdGVwU2l6ZSAqIGkgKyB0b290aEFuZ2xlU3RlcFNpemUpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC0ocmFkaXVzICsgdG9vdGhIZWlnaHQpICpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoZmxvYXQpTWF0aC5TaW4oc3RlcFNpemUgKiBpICsgdG9vdGhBbmdsZVN0ZXBTaXplKSkpO1xyXG5cclxuICAgICAgICAgICAgICAgIHZlcnRpY2VzLkFkZChuZXcgVmVjdG9yMihyYWRpdXMgKiAoZmxvYXQpTWF0aC5Db3Moc3RlcFNpemUgKiBpKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAtcmFkaXVzICogKGZsb2F0KU1hdGguU2luKHN0ZXBTaXplICogaSkpKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuIHZlcnRpY2VzO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBEZXRlY3RzIHRoZSB2ZXJ0aWNlcyBieSBhbmFseXppbmcgdGhlIHRleHR1cmUgZGF0YS5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cImRhdGFcIj5UaGUgdGV4dHVyZSBkYXRhLjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwid2lkdGhcIj5UaGUgdGV4dHVyZSB3aWR0aC48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cmV0dXJucz48L3JldHVybnM+XHJcbiAgICAgICAgcHVibGljIHN0YXRpYyBWZXJ0aWNlcyBDcmVhdGVQb2x5Z29uKHVpbnRbXSBkYXRhLCBpbnQgd2lkdGgpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gVGV4dHVyZUNvbnZlcnRlci5EZXRlY3RWZXJ0aWNlcyhkYXRhLCB3aWR0aCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIERldGVjdHMgdGhlIHZlcnRpY2VzIGJ5IGFuYWx5emluZyB0aGUgdGV4dHVyZSBkYXRhLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwiZGF0YVwiPlRoZSB0ZXh0dXJlIGRhdGEuPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJ3aWR0aFwiPlRoZSB0ZXh0dXJlIHdpZHRoLjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwiaG9sZURldGVjdGlvblwiPmlmIHNldCB0byA8Yz50cnVlPC9jPiBpdCB3aWxsIHBlcmZvcm0gaG9sZSBkZXRlY3Rpb24uPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHJldHVybnM+PC9yZXR1cm5zPlxyXG4gICAgICAgIHB1YmxpYyBzdGF0aWMgVmVydGljZXMgQ3JlYXRlUG9seWdvbih1aW50W10gZGF0YSwgaW50IHdpZHRoLCBib29sIGhvbGVEZXRlY3Rpb24pXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gVGV4dHVyZUNvbnZlcnRlci5EZXRlY3RWZXJ0aWNlcyhkYXRhLCB3aWR0aCwgaG9sZURldGVjdGlvbik7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIERldGVjdHMgdGhlIHZlcnRpY2VzIGJ5IGFuYWx5emluZyB0aGUgdGV4dHVyZSBkYXRhLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwiZGF0YVwiPlRoZSB0ZXh0dXJlIGRhdGEuPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJ3aWR0aFwiPlRoZSB0ZXh0dXJlIHdpZHRoLjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwiaHVsbFRvbGVyYW5jZVwiPlRoZSBodWxsIHRvbGVyYW5jZS48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cImFscGhhVG9sZXJhbmNlXCI+VGhlIGFscGhhIHRvbGVyYW5jZS48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cIm11bHRpUGFydERldGVjdGlvblwiPmlmIHNldCB0byA8Yz50cnVlPC9jPiBpdCB3aWxsIHBlcmZvcm0gbXVsdGkgcGFydCBkZXRlY3Rpb24uPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJob2xlRGV0ZWN0aW9uXCI+aWYgc2V0IHRvIDxjPnRydWU8L2M+IGl0IHdpbGwgcGVyZm9ybSBob2xlIGRldGVjdGlvbi48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cmV0dXJucz48L3JldHVybnM+XHJcbiAgICAgICAgcHVibGljIHN0YXRpYyBMaXN0PFZlcnRpY2VzPiBDcmVhdGVQb2x5Z29uKHVpbnRbXSBkYXRhLCBpbnQgd2lkdGgsIGZsb2F0IGh1bGxUb2xlcmFuY2UsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJ5dGUgYWxwaGFUb2xlcmFuY2UsIGJvb2wgbXVsdGlQYXJ0RGV0ZWN0aW9uLCBib29sIGhvbGVEZXRlY3Rpb24pXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gVGV4dHVyZUNvbnZlcnRlci5EZXRlY3RWZXJ0aWNlcyhkYXRhLCB3aWR0aCwgaHVsbFRvbGVyYW5jZSwgYWxwaGFUb2xlcmFuY2UsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG11bHRpUGFydERldGVjdGlvbiwgaG9sZURldGVjdGlvbik7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59IiwidXNpbmcgU3lzdGVtO1xyXG51c2luZyBTeXN0ZW0uQ29sbGVjdGlvbnMuR2VuZXJpYztcclxudXNpbmcgU3lzdGVtLkRpYWdub3N0aWNzO1xyXG51c2luZyBNaWNyb3NvZnQuWG5hLkZyYW1ld29yaztcclxuXHJcbm5hbWVzcGFjZSBGYXJzZWVyUGh5c2ljcy5Db21tb25cclxue1xyXG4gICAgLy8gVXNlciBjb250cmlidXRpb24gZnJvbSBTaWNrYmF0dGVyeSBha2EgRGF2aWQgUmVzY2hrZSA6KS5cclxuXHJcbiAgICAjcmVnaW9uIFRvRG86IENyZWF0ZSBhIG5ldyBmaWxlIGZvciBlYWNoIC4uLlxyXG4gICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgLy8vIFRoZSBkZXRlY3Rpb24gdHlwZSBhZmZlY3RzIHRoZSByZXN1bHRpbmcgcG9seWdvbiBkYXRhLlxyXG4gICAgLy8vIDwvc3VtbWFyeT5cclxuICAgIHB1YmxpYyBlbnVtIFZlcnRpY2VzRGV0ZWN0aW9uVHlwZVxyXG4gICAge1xyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gSG9sZXMgYXJlIGludGVncmF0ZWQgaW50byB0aGUgbWFpbiBwb2x5Z29uLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgSW50ZWdyYXRlZCA9IDAsXHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gVGhlIGRhdGEgb2YgdGhlIG1haW4gcG9seWdvbiBhbmQgaG9sZSBwb2x5Z29ucyBpcyByZXR1cm5lZCBzZXBhcmF0ZWx5LlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgU2VwYXJhdGVkID0gMVxyXG4gICAgfVxyXG5cclxuICAgIC8vLyA8c3VtbWFyeT5cclxuICAgIC8vLyBEZXRlY3RlZCB2ZXJ0aWNlcyBvZiBhIHNpbmdsZSBwb2x5Z29uLlxyXG4gICAgLy8vIDwvc3VtbWFyeT5cclxuICAgIHB1YmxpYyBjbGFzcyBEZXRlY3RlZFZlcnRpY2VzIDogVmVydGljZXNcclxuICAgIHtcclxuICAgICAgICBwcml2YXRlIExpc3Q8VmVydGljZXM+IF9ob2xlcztcclxuXHJcbiAgICAgICAgcHVibGljIExpc3Q8VmVydGljZXM+IEhvbGVzXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBnZXQgeyByZXR1cm4gX2hvbGVzOyB9XHJcbiAgICAgICAgICAgIHNldCB7IF9ob2xlcyA9IHZhbHVlOyB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwdWJsaWMgRGV0ZWN0ZWRWZXJ0aWNlcygpXHJcbiAgICAgICAgICAgIDogYmFzZSgpXHJcbiAgICAgICAge1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHVibGljIERldGVjdGVkVmVydGljZXMoVmVydGljZXMgdmVydGljZXMpXHJcbiAgICAgICAgICAgIDogYmFzZSh2ZXJ0aWNlcylcclxuICAgICAgICB7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwdWJsaWMgdm9pZCBUcmFuc2Zvcm0oTWF0cml4IHRyYW5zZm9ybSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIC8vIFRyYW5zZm9ybSBtYWluIHBvbHlnb25cclxuICAgICAgICAgICAgZm9yIChpbnQgaSA9IDA7IGkgPCB0aGlzLkNvdW50OyBpKyspXHJcbiAgICAgICAgICAgICAgICB0aGlzW2ldID0gVmVjdG9yMi5UcmFuc2Zvcm0odGhpc1tpXSwgdHJhbnNmb3JtKTtcclxuXHJcbiAgICAgICAgICAgIC8vIFRyYW5zZm9ybSBob2xlc1xyXG4gICAgICAgICAgICBWZWN0b3IyW10gdGVtcCA9IG51bGw7XHJcbiAgICAgICAgICAgIGlmIChfaG9sZXMgIT0gbnVsbCAmJiBfaG9sZXMuQ291bnQgPiAwKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBmb3IgKGludCBpID0gMDsgaSA8IF9ob2xlcy5Db3VudDsgaSsrKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIHRlbXAgPSBfaG9sZXNbaV0uVG9BcnJheSgpO1xyXG4gICAgICAgICAgICAgICAgICAgIFZlY3RvcjIuVHJhbnNmb3JtKHRlbXAsIHJlZiB0cmFuc2Zvcm0sIHRlbXApO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBfaG9sZXNbaV0gPSBuZXcgVmVydGljZXModGVtcCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAjZW5kcmVnaW9uXHJcblxyXG4gICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgLy8vIFxyXG4gICAgLy8vIDwvc3VtbWFyeT5cclxuICAgIHB1YmxpYyBzZWFsZWQgY2xhc3MgVGV4dHVyZUNvbnZlcnRlclxyXG4gICAge1xyXG4gICAgICAgIHByaXZhdGUgY29uc3QgaW50IF9DTE9TRVBJWEVMU19MRU5HVEggPSA4O1xyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIFRoaXMgYXJyYXkgaXMgbWVudCB0byBiZSByZWFkb25seS5cclxuICAgICAgICAvLy8gSXQncyBub3QgYmVjYXVzZSBpdCBpcyBhY2Nlc3NlZCB2ZXJ5IGZyZXF1ZW50bHkuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICBwcml2YXRlIHN0YXRpYyAvKnJlYWRvbmx5Ki8gaW50WyxdIENsb3NlUGl4ZWxzID1cclxuICAgICAgICAgICAgbmV3IGludFtfQ0xPU0VQSVhFTFNfTEVOR1RILCAyXSB7IHsgLTEsIC0xIH0sIHsgMCwgLTEgfSwgeyAxLCAtMSB9LCB7IDEsIDAgfSwgeyAxLCAxIH0sIHsgMCwgMSB9LCB7IC0xLCAxIH0sIHsgLTEsIDAgfSB9O1xyXG5cclxuICAgICAgICBwcml2YXRlIHVpbnRbXSBfZGF0YTtcclxuICAgICAgICBwcml2YXRlIGludCBfZGF0YUxlbmd0aDtcclxuICAgICAgICBwcml2YXRlIGludCBfd2lkdGg7XHJcbiAgICAgICAgcHJpdmF0ZSBpbnQgX2hlaWdodDtcclxuXHJcbiAgICAgICAgcHJpdmF0ZSBWZXJ0aWNlc0RldGVjdGlvblR5cGUgX3BvbHlnb25EZXRlY3Rpb25UeXBlO1xyXG5cclxuICAgICAgICBwcml2YXRlIHVpbnQgX2FscGhhVG9sZXJhbmNlO1xyXG4gICAgICAgIHByaXZhdGUgZmxvYXQgX2h1bGxUb2xlcmFuY2U7XHJcblxyXG4gICAgICAgIHByaXZhdGUgYm9vbCBfaG9sZURldGVjdGlvbjtcclxuICAgICAgICBwcml2YXRlIGJvb2wgX211bHRpcGFydERldGVjdGlvbjtcclxuICAgICAgICBwcml2YXRlIGJvb2wgX3BpeGVsT2Zmc2V0T3B0aW1pemF0aW9uO1xyXG5cclxuICAgICAgICBwcml2YXRlIE1hdHJpeCBfdHJhbnNmb3JtID0gTWF0cml4LklkZW50aXR5O1xyXG5cclxuICAgICAgICAjcmVnaW9uIFByb3BlcnRpZXNcclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIEdldCBvciBzZXQgdGhlIHBvbHlnb24gZGV0ZWN0aW9uIHR5cGUuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICBwdWJsaWMgVmVydGljZXNEZXRlY3Rpb25UeXBlIFBvbHlnb25EZXRlY3Rpb25UeXBlXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBnZXQgeyByZXR1cm4gX3BvbHlnb25EZXRlY3Rpb25UeXBlOyB9XHJcbiAgICAgICAgICAgIHNldCB7IF9wb2x5Z29uRGV0ZWN0aW9uVHlwZSA9IHZhbHVlOyB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIFdpbGwgZGV0ZWN0IHRleHR1cmUgJ2hvbGVzJyBpZiBzZXQgdG8gdHJ1ZS4gU2xvd3MgZG93biB0aGUgZGV0ZWN0aW9uLiBEZWZhdWx0IGlzIGZhbHNlLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgcHVibGljIGJvb2wgSG9sZURldGVjdGlvblxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgZ2V0IHsgcmV0dXJuIF9ob2xlRGV0ZWN0aW9uOyB9XHJcbiAgICAgICAgICAgIHNldCB7IF9ob2xlRGV0ZWN0aW9uID0gdmFsdWU7IH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gV2lsbCBkZXRlY3QgdGV4dHVyZSBtdWx0aXBsZSAnc29saWQnIGlzbGVzIGlmIHNldCB0byB0cnVlLiBTbG93cyBkb3duIHRoZSBkZXRlY3Rpb24uIERlZmF1bHQgaXMgZmFsc2UuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICBwdWJsaWMgYm9vbCBNdWx0aXBhcnREZXRlY3Rpb25cclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGdldCB7IHJldHVybiBfbXVsdGlwYXJ0RGV0ZWN0aW9uOyB9XHJcbiAgICAgICAgICAgIHNldCB7IF9tdWx0aXBhcnREZXRlY3Rpb24gPSB2YWx1ZTsgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBXaWxsIG9wdGltaXplIHRoZSB2ZXJ0ZXggcG9zaXRpb25zIGFsb25nIHRoZSBpbnRlcnBvbGF0ZWQgbm9ybWFsIGJldHdlZW4gdHdvIGVkZ2VzIGFib3V0IGEgaGFsZiBwaXhlbCAocG9zdCBwcm9jZXNzaW5nKS4gRGVmYXVsdCBpcyBmYWxzZS5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIHB1YmxpYyBib29sIFBpeGVsT2Zmc2V0T3B0aW1pemF0aW9uXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBnZXQgeyByZXR1cm4gX3BpeGVsT2Zmc2V0T3B0aW1pemF0aW9uOyB9XHJcbiAgICAgICAgICAgIHNldCB7IF9waXhlbE9mZnNldE9wdGltaXphdGlvbiA9IHZhbHVlOyB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIENhbiBiZSB1c2VkIGZvciBzY2FsaW5nLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgcHVibGljIE1hdHJpeCBUcmFuc2Zvcm1cclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGdldCB7IHJldHVybiBfdHJhbnNmb3JtOyB9XHJcbiAgICAgICAgICAgIHNldCB7IF90cmFuc2Zvcm0gPSB2YWx1ZTsgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBBbHBoYSAoY292ZXJhZ2UpIHRvbGVyYW5jZS4gRGVmYXVsdCBpcyAyMDogRXZlcnkgcGl4ZWwgd2l0aCBhIGNvdmVyYWdlIHZhbHVlIGVxdWFsIG9yIGdyZWF0ZXIgdG8gMjAgd2lsbCBiZSBjb3VudHMgYXMgc29saWQuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICBwdWJsaWMgYnl0ZSBBbHBoYVRvbGVyYW5jZVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgZ2V0IHsgcmV0dXJuIChieXRlKShfYWxwaGFUb2xlcmFuY2UgPj4gMjQpOyB9XHJcbiAgICAgICAgICAgIHNldCB7IF9hbHBoYVRvbGVyYW5jZSA9ICh1aW50KXZhbHVlIDw8IDI0OyB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIERlZmF1bHQgaXMgMS41Zi5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIHB1YmxpYyBmbG9hdCBIdWxsVG9sZXJhbmNlXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBnZXQgeyByZXR1cm4gX2h1bGxUb2xlcmFuY2U7IH1cclxuICAgICAgICAgICAgc2V0XHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA+IDRmKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIF9odWxsVG9sZXJhbmNlID0gNGY7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmICh2YWx1ZSA8IDAuOWYpXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgX2h1bGxUb2xlcmFuY2UgPSAwLjlmO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIF9odWxsVG9sZXJhbmNlID0gdmFsdWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgI2VuZHJlZ2lvblxyXG5cclxuICAgICAgICAjcmVnaW9uIENvbnN0cnVjdG9yc1xyXG4gICAgICAgIHB1YmxpYyBUZXh0dXJlQ29udmVydGVyKClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIEluaXRpYWxpemUobnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwdWJsaWMgVGV4dHVyZUNvbnZlcnRlcihieXRlPyBhbHBoYVRvbGVyYW5jZSwgZmxvYXQ/IGh1bGxUb2xlcmFuY2UsXHJcbiAgICAgICAgICAgIGJvb2w/IGhvbGVEZXRlY3Rpb24sIGJvb2w/IG11bHRpcGFydERldGVjdGlvbiwgYm9vbD8gcGl4ZWxPZmZzZXRPcHRpbWl6YXRpb24sIE1hdHJpeD8gdHJhbnNmb3JtKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgSW5pdGlhbGl6ZShudWxsLCBudWxsLCBhbHBoYVRvbGVyYW5jZSwgaHVsbFRvbGVyYW5jZSwgaG9sZURldGVjdGlvbixcclxuICAgICAgICAgICAgICAgIG11bHRpcGFydERldGVjdGlvbiwgcGl4ZWxPZmZzZXRPcHRpbWl6YXRpb24sIHRyYW5zZm9ybSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwdWJsaWMgVGV4dHVyZUNvbnZlcnRlcih1aW50W10gZGF0YSwgaW50IHdpZHRoKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgSW5pdGlhbGl6ZShkYXRhLCB3aWR0aCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwdWJsaWMgVGV4dHVyZUNvbnZlcnRlcih1aW50W10gZGF0YSwgaW50IHdpZHRoLCBieXRlPyBhbHBoYVRvbGVyYW5jZSxcclxuICAgICAgICAgICAgZmxvYXQ/IGh1bGxUb2xlcmFuY2UsIGJvb2w/IGhvbGVEZXRlY3Rpb24sIGJvb2w/IG11bHRpcGFydERldGVjdGlvbixcclxuICAgICAgICAgICAgYm9vbD8gcGl4ZWxPZmZzZXRPcHRpbWl6YXRpb24sIE1hdHJpeD8gdHJhbnNmb3JtKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgSW5pdGlhbGl6ZShkYXRhLCB3aWR0aCwgYWxwaGFUb2xlcmFuY2UsIGh1bGxUb2xlcmFuY2UsIGhvbGVEZXRlY3Rpb24sXHJcbiAgICAgICAgICAgICAgICBtdWx0aXBhcnREZXRlY3Rpb24sIHBpeGVsT2Zmc2V0T3B0aW1pemF0aW9uLCB0cmFuc2Zvcm0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICAjZW5kcmVnaW9uXHJcblxyXG4gICAgICAgICNyZWdpb24gSW5pdGlhbGl6YXRpb25cclxuICAgICAgICBwcml2YXRlIHZvaWQgSW5pdGlhbGl6ZSh1aW50W10gZGF0YSwgaW50PyB3aWR0aCwgYnl0ZT8gYWxwaGFUb2xlcmFuY2UsXHJcbiAgICAgICAgICAgIGZsb2F0PyBodWxsVG9sZXJhbmNlLCBib29sPyBob2xlRGV0ZWN0aW9uLCBib29sPyBtdWx0aXBhcnREZXRlY3Rpb24sXHJcbiAgICAgICAgICAgIGJvb2w/IHBpeGVsT2Zmc2V0T3B0aW1pemF0aW9uLCBNYXRyaXg/IHRyYW5zZm9ybSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGlmIChkYXRhICE9IG51bGwgJiYgIXdpZHRoLkhhc1ZhbHVlKVxyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEFyZ3VtZW50TnVsbEV4Y2VwdGlvbihcIndpZHRoXCIsIFwiJ3dpZHRoJyBjYW4ndCBiZSBudWxsIGlmICdkYXRhJyBpcyBzZXQuXCIpO1xyXG5cclxuICAgICAgICAgICAgaWYgKGRhdGEgPT0gbnVsbCAmJiB3aWR0aC5IYXNWYWx1ZSlcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBBcmd1bWVudE51bGxFeGNlcHRpb24oXCJkYXRhXCIsIFwiJ2RhdGEnIGNhbid0IGJlIG51bGwgaWYgJ3dpZHRoJyBpcyBzZXQuXCIpO1xyXG5cclxuICAgICAgICAgICAgaWYgKGRhdGEgIT0gbnVsbCAmJiB3aWR0aC5IYXNWYWx1ZSlcclxuICAgICAgICAgICAgICAgIFNldFRleHR1cmVEYXRhKGRhdGEsIHdpZHRoLlZhbHVlKTtcclxuXHJcbiAgICAgICAgICAgIGlmIChhbHBoYVRvbGVyYW5jZS5IYXNWYWx1ZSlcclxuICAgICAgICAgICAgICAgIEFscGhhVG9sZXJhbmNlID0gYWxwaGFUb2xlcmFuY2UuVmFsdWU7XHJcbiAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgIEFscGhhVG9sZXJhbmNlID0gMjA7XHJcblxyXG4gICAgICAgICAgICBpZiAoaHVsbFRvbGVyYW5jZS5IYXNWYWx1ZSlcclxuICAgICAgICAgICAgICAgIEh1bGxUb2xlcmFuY2UgPSBodWxsVG9sZXJhbmNlLlZhbHVlO1xyXG4gICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICBIdWxsVG9sZXJhbmNlID0gMS41ZjtcclxuXHJcbiAgICAgICAgICAgIGlmIChob2xlRGV0ZWN0aW9uLkhhc1ZhbHVlKVxyXG4gICAgICAgICAgICAgICAgSG9sZURldGVjdGlvbiA9IGhvbGVEZXRlY3Rpb24uVmFsdWU7XHJcbiAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgIEhvbGVEZXRlY3Rpb24gPSBmYWxzZTtcclxuXHJcbiAgICAgICAgICAgIGlmIChtdWx0aXBhcnREZXRlY3Rpb24uSGFzVmFsdWUpXHJcbiAgICAgICAgICAgICAgICBNdWx0aXBhcnREZXRlY3Rpb24gPSBtdWx0aXBhcnREZXRlY3Rpb24uVmFsdWU7XHJcbiAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgIE11bHRpcGFydERldGVjdGlvbiA9IGZhbHNlO1xyXG5cclxuICAgICAgICAgICAgaWYgKHBpeGVsT2Zmc2V0T3B0aW1pemF0aW9uLkhhc1ZhbHVlKVxyXG4gICAgICAgICAgICAgICAgUGl4ZWxPZmZzZXRPcHRpbWl6YXRpb24gPSBwaXhlbE9mZnNldE9wdGltaXphdGlvbi5WYWx1ZTtcclxuICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgUGl4ZWxPZmZzZXRPcHRpbWl6YXRpb24gPSBmYWxzZTtcclxuXHJcbiAgICAgICAgICAgIGlmICh0cmFuc2Zvcm0uSGFzVmFsdWUpXHJcbiAgICAgICAgICAgICAgICBUcmFuc2Zvcm0gPSB0cmFuc2Zvcm0uVmFsdWU7XHJcbiAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgIFRyYW5zZm9ybSA9IE1hdHJpeC5JZGVudGl0eTtcclxuICAgICAgICB9XHJcbiAgICAgICAgI2VuZHJlZ2lvblxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIFxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwiZGF0YVwiPjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwid2lkdGhcIj48L3BhcmFtPlxyXG4gICAgICAgIHByaXZhdGUgdm9pZCBTZXRUZXh0dXJlRGF0YSh1aW50W10gZGF0YSwgaW50IHdpZHRoKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgaWYgKGRhdGEgPT0gbnVsbClcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBBcmd1bWVudE51bGxFeGNlcHRpb24oXCJkYXRhXCIsIFwiJ2RhdGEnIGNhbid0IGJlIG51bGwuXCIpO1xyXG5cclxuICAgICAgICAgICAgaWYgKGRhdGEuTGVuZ3RoIDwgNClcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBBcmd1bWVudE91dE9mUmFuZ2VFeGNlcHRpb24oXCJkYXRhXCIsIFwiJ2RhdGEnIGxlbmd0aCBjYW4ndCBiZSBsZXNzIHRoZW4gNC4gWW91ciB0ZXh0dXJlIG11c3QgYmUgYXQgbGVhc3QgMiB4IDIgcGl4ZWxzIGluIHNpemUuXCIpO1xyXG5cclxuICAgICAgICAgICAgaWYgKHdpZHRoIDwgMilcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBBcmd1bWVudE91dE9mUmFuZ2VFeGNlcHRpb24oXCJ3aWR0aFwiLCBcIid3aWR0aCcgY2FuJ3QgYmUgbGVzcyB0aGVuIDIuIFlvdXIgdGV4dHVyZSBtdXN0IGJlIGF0IGxlYXN0IDIgeCAyIHBpeGVscyBpbiBzaXplLlwiKTtcclxuXHJcbiAgICAgICAgICAgIGlmIChkYXRhLkxlbmd0aCAlIHdpZHRoICE9IDApXHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQXJndW1lbnRFeGNlcHRpb24oXCInd2lkdGgnIGhhcyBhbiBpbnZhbGlkIHZhbHVlLlwiKTtcclxuXHJcbiAgICAgICAgICAgIF9kYXRhID0gZGF0YTtcclxuICAgICAgICAgICAgX2RhdGFMZW5ndGggPSBfZGF0YS5MZW5ndGg7XHJcbiAgICAgICAgICAgIF93aWR0aCA9IHdpZHRoO1xyXG4gICAgICAgICAgICBfaGVpZ2h0ID0gX2RhdGFMZW5ndGggLyB3aWR0aDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gRGV0ZWN0cyB0aGUgdmVydGljZXMgb2YgdGhlIHN1cHBsaWVkIHRleHR1cmUgZGF0YS4gKFBvbHlnb25EZXRlY3Rpb25UeXBlLkludGVncmF0ZWQpXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJkYXRhXCI+VGhlIHRleHR1cmUgZGF0YS48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cIndpZHRoXCI+VGhlIHRleHR1cmUgd2lkdGguPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHJldHVybnM+PC9yZXR1cm5zPlxyXG4gICAgICAgIHB1YmxpYyBzdGF0aWMgVmVydGljZXMgRGV0ZWN0VmVydGljZXModWludFtdIGRhdGEsIGludCB3aWR0aClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIFRleHR1cmVDb252ZXJ0ZXIgdGMgPSBuZXcgVGV4dHVyZUNvbnZlcnRlcihkYXRhLCB3aWR0aCk7XHJcblxyXG4gICAgICAgICAgICBMaXN0PERldGVjdGVkVmVydGljZXM+IGRldGVjdGVkVmVydGljZXNMaXN0ID0gdGMuRGV0ZWN0VmVydGljZXMoKTtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiBkZXRlY3RlZFZlcnRpY2VzTGlzdFswXTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gRGV0ZWN0cyB0aGUgdmVydGljZXMgb2YgdGhlIHN1cHBsaWVkIHRleHR1cmUgZGF0YS5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cImRhdGFcIj5UaGUgdGV4dHVyZSBkYXRhLjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwid2lkdGhcIj5UaGUgdGV4dHVyZSB3aWR0aC48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cImhvbGVEZXRlY3Rpb25cIj5pZiBzZXQgdG8gPGM+dHJ1ZTwvYz4gaXQgd2lsbCBwZXJmb3JtIGhvbGUgZGV0ZWN0aW9uLjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxyZXR1cm5zPjwvcmV0dXJucz5cclxuICAgICAgICBwdWJsaWMgc3RhdGljIFZlcnRpY2VzIERldGVjdFZlcnRpY2VzKHVpbnRbXSBkYXRhLCBpbnQgd2lkdGgsIGJvb2wgaG9sZURldGVjdGlvbilcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIFRleHR1cmVDb252ZXJ0ZXIgdGMgPVxyXG4gICAgICAgICAgICAgICAgbmV3IFRleHR1cmVDb252ZXJ0ZXIoZGF0YSwgd2lkdGgpXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgSG9sZURldGVjdGlvbiA9IGhvbGVEZXRlY3Rpb25cclxuICAgICAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICBMaXN0PERldGVjdGVkVmVydGljZXM+IGRldGVjdGVkVmVydGljZXNMaXN0ID0gdGMuRGV0ZWN0VmVydGljZXMoKTtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiBkZXRlY3RlZFZlcnRpY2VzTGlzdFswXTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gRGV0ZWN0cyB0aGUgdmVydGljZXMgb2YgdGhlIHN1cHBsaWVkIHRleHR1cmUgZGF0YS5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cImRhdGFcIj5UaGUgdGV4dHVyZSBkYXRhLjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwid2lkdGhcIj5UaGUgdGV4dHVyZSB3aWR0aC48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cImhvbGVEZXRlY3Rpb25cIj5pZiBzZXQgdG8gPGM+dHJ1ZTwvYz4gaXQgd2lsbCBwZXJmb3JtIGhvbGUgZGV0ZWN0aW9uLjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwiaHVsbFRvbGVyYW5jZVwiPlRoZSBodWxsIHRvbGVyYW5jZS48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cImFscGhhVG9sZXJhbmNlXCI+VGhlIGFscGhhIHRvbGVyYW5jZS48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cIm11bHRpUGFydERldGVjdGlvblwiPmlmIHNldCB0byA8Yz50cnVlPC9jPiBpdCB3aWxsIHBlcmZvcm0gbXVsdGkgcGFydCBkZXRlY3Rpb24uPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHJldHVybnM+PC9yZXR1cm5zPlxyXG4gICAgICAgIHB1YmxpYyBzdGF0aWMgTGlzdDxWZXJ0aWNlcz4gRGV0ZWN0VmVydGljZXModWludFtdIGRhdGEsIGludCB3aWR0aCwgZmxvYXQgaHVsbFRvbGVyYW5jZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJ5dGUgYWxwaGFUb2xlcmFuY2UsIGJvb2wgbXVsdGlQYXJ0RGV0ZWN0aW9uLCBib29sIGhvbGVEZXRlY3Rpb24pXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBUZXh0dXJlQ29udmVydGVyIHRjID1cclxuICAgICAgICAgICAgICAgIG5ldyBUZXh0dXJlQ29udmVydGVyKGRhdGEsIHdpZHRoKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIEh1bGxUb2xlcmFuY2UgPSBodWxsVG9sZXJhbmNlLFxyXG4gICAgICAgICAgICAgICAgICAgIEFscGhhVG9sZXJhbmNlID0gYWxwaGFUb2xlcmFuY2UsXHJcbiAgICAgICAgICAgICAgICAgICAgTXVsdGlwYXJ0RGV0ZWN0aW9uID0gbXVsdGlQYXJ0RGV0ZWN0aW9uLFxyXG4gICAgICAgICAgICAgICAgICAgIEhvbGVEZXRlY3Rpb24gPSBob2xlRGV0ZWN0aW9uXHJcbiAgICAgICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgTGlzdDxEZXRlY3RlZFZlcnRpY2VzPiBkZXRlY3RlZFZlcnRpY2VzTGlzdCA9IHRjLkRldGVjdFZlcnRpY2VzKCk7XHJcbiAgICAgICAgICAgIExpc3Q8VmVydGljZXM+IHJlc3VsdCA9IG5ldyBMaXN0PFZlcnRpY2VzPigpO1xyXG5cclxuICAgICAgICAgICAgZm9yIChpbnQgaSA9IDA7IGkgPCBkZXRlY3RlZFZlcnRpY2VzTGlzdC5Db3VudDsgaSsrKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICByZXN1bHQuQWRkKGRldGVjdGVkVmVydGljZXNMaXN0W2ldKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHB1YmxpYyBMaXN0PERldGVjdGVkVmVydGljZXM+IERldGVjdFZlcnRpY2VzKClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgICNyZWdpb24gQ2hlY2sgVGV4dHVyZUNvbnZlcnRlciBzZXR1cC5cclxuXHJcbiAgICAgICAgICAgIGlmIChfZGF0YSA9PSBudWxsKVxyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEV4Y2VwdGlvbihcclxuICAgICAgICAgICAgICAgICAgICBcIidfZGF0YScgY2FuJ3QgYmUgbnVsbC4gWW91IGhhdmUgdG8gdXNlIFNldFRleHR1cmVEYXRhKHVpbnRbXSBkYXRhLCBpbnQgd2lkdGgpIGJlZm9yZSBjYWxsaW5nIHRoaXMgbWV0aG9kLlwiKTtcclxuXHJcbiAgICAgICAgICAgIGlmIChfZGF0YS5MZW5ndGggPCA0KVxyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEV4Y2VwdGlvbihcclxuICAgICAgICAgICAgICAgICAgICBcIidfZGF0YScgbGVuZ3RoIGNhbid0IGJlIGxlc3MgdGhlbiA0LiBZb3VyIHRleHR1cmUgbXVzdCBiZSBhdCBsZWFzdCAyIHggMiBwaXhlbHMgaW4gc2l6ZS4gXCIgK1xyXG4gICAgICAgICAgICAgICAgICAgIFwiWW91IGhhdmUgdG8gdXNlIFNldFRleHR1cmVEYXRhKHVpbnRbXSBkYXRhLCBpbnQgd2lkdGgpIGJlZm9yZSBjYWxsaW5nIHRoaXMgbWV0aG9kLlwiKTtcclxuXHJcbiAgICAgICAgICAgIGlmIChfd2lkdGggPCAyKVxyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEV4Y2VwdGlvbihcclxuICAgICAgICAgICAgICAgICAgICBcIidfd2lkdGgnIGNhbid0IGJlIGxlc3MgdGhlbiAyLiBZb3VyIHRleHR1cmUgbXVzdCBiZSBhdCBsZWFzdCAyIHggMiBwaXhlbHMgaW4gc2l6ZS4gXCIgK1xyXG4gICAgICAgICAgICAgICAgICAgIFwiWW91IGhhdmUgdG8gdXNlIFNldFRleHR1cmVEYXRhKHVpbnRbXSBkYXRhLCBpbnQgd2lkdGgpIGJlZm9yZSBjYWxsaW5nIHRoaXMgbWV0aG9kLlwiKTtcclxuXHJcbiAgICAgICAgICAgIGlmIChfZGF0YS5MZW5ndGggJSBfd2lkdGggIT0gMClcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFeGNlcHRpb24oXHJcbiAgICAgICAgICAgICAgICAgICAgXCInX3dpZHRoJyBoYXMgYW4gaW52YWxpZCB2YWx1ZS4gWW91IGhhdmUgdG8gdXNlIFNldFRleHR1cmVEYXRhKHVpbnRbXSBkYXRhLCBpbnQgd2lkdGgpIGJlZm9yZSBjYWxsaW5nIHRoaXMgbWV0aG9kLlwiKTtcclxuXHJcbiAgICAgICAgICAgICNlbmRyZWdpb25cclxuXHJcblxyXG4gICAgICAgICAgICBMaXN0PERldGVjdGVkVmVydGljZXM+IGRldGVjdGVkUG9seWdvbnMgPSBuZXcgTGlzdDxEZXRlY3RlZFZlcnRpY2VzPigpO1xyXG5cclxuICAgICAgICAgICAgRGV0ZWN0ZWRWZXJ0aWNlcyBwb2x5Z29uO1xyXG4gICAgICAgICAgICBWZXJ0aWNlcyBob2xlUG9seWdvbjtcclxuXHJcbiAgICAgICAgICAgIFZlY3RvcjI/IGhvbGVFbnRyYW5jZSA9IG51bGw7XHJcbiAgICAgICAgICAgIFZlY3RvcjI/IHBvbHlnb25FbnRyYW5jZSA9IG51bGw7XHJcblxyXG4gICAgICAgICAgICBMaXN0PFZlY3RvcjI+IGJsYWNrTGlzdCA9IG5ldyBMaXN0PFZlY3RvcjI+KCk7XHJcblxyXG4gICAgICAgICAgICBib29sIHNlYXJjaE9uO1xyXG4gICAgICAgICAgICBkb1xyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBpZiAoZGV0ZWN0ZWRQb2x5Z29ucy5Db3VudCA9PSAwKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIEZpcnN0IHBhc3MgLyBzaW5nbGUgcG9seWdvblxyXG4gICAgICAgICAgICAgICAgICAgIHBvbHlnb24gPSBuZXcgRGV0ZWN0ZWRWZXJ0aWNlcyhDcmVhdGVTaW1wbGVQb2x5Z29uKFZlY3RvcjIuWmVybywgVmVjdG9yMi5aZXJvKSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChwb2x5Z29uLkNvdW50ID4gMilcclxuICAgICAgICAgICAgICAgICAgICAgICAgcG9seWdvbkVudHJhbmNlID0gR2V0VG9wTW9zdFZlcnRleChwb2x5Z29uKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHBvbHlnb25FbnRyYW5jZS5IYXNWYWx1ZSlcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBNdWx0aSBwYXNzIC8gbXVsdGlwbGUgcG9seWdvbnNcclxuICAgICAgICAgICAgICAgICAgICBwb2x5Z29uID0gbmV3IERldGVjdGVkVmVydGljZXMoQ3JlYXRlU2ltcGxlUG9seWdvbihcclxuICAgICAgICAgICAgICAgICAgICAgICAgcG9seWdvbkVudHJhbmNlLlZhbHVlLCBuZXcgVmVjdG9yMihwb2x5Z29uRW50cmFuY2UuVmFsdWUuWCAtIDFmLCBwb2x5Z29uRW50cmFuY2UuVmFsdWUuWSkpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgICAgICAgICBzZWFyY2hPbiA9IGZhbHNlO1xyXG5cclxuXHJcbiAgICAgICAgICAgICAgICBpZiAocG9seWdvbi5Db3VudCA+IDIpXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKF9ob2xlRGV0ZWN0aW9uKVxyXG4gICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZG9cclxuICAgICAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaG9sZUVudHJhbmNlID0gU2VhcmNoSG9sZUVudHJhbmNlKHBvbHlnb24sIGhvbGVFbnRyYW5jZSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGhvbGVFbnRyYW5jZS5IYXNWYWx1ZSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWJsYWNrTGlzdC5Db250YWlucyhob2xlRW50cmFuY2UuVmFsdWUpKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYmxhY2tMaXN0LkFkZChob2xlRW50cmFuY2UuVmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBob2xlUG9seWdvbiA9IENyZWF0ZVNpbXBsZVBvbHlnb24oaG9sZUVudHJhbmNlLlZhbHVlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3IFZlY3RvcjIoaG9sZUVudHJhbmNlLlZhbHVlLlggKyAxLCBob2xlRW50cmFuY2UuVmFsdWUuWSkpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGhvbGVQb2x5Z29uICE9IG51bGwgJiYgaG9sZVBvbHlnb24uQ291bnQgPiAyKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKF9wb2x5Z29uRGV0ZWN0aW9uVHlwZSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFZlcnRpY2VzRGV0ZWN0aW9uVHlwZS5JbnRlZ3JhdGVkOlxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQWRkIGZpcnN0IGhvbGUgcG9seWdvbiB2ZXJ0ZXggdG8gY2xvc2UgdGhlIGhvbGUgcG9seWdvbi5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaG9sZVBvbHlnb24uQWRkKGhvbGVQb2x5Z29uWzBdKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGludCB2ZXJ0ZXgxSW5kZXgsIHZlcnRleDJJbmRleDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKFNwbGl0UG9seWdvbkVkZ2UocG9seWdvbiwgaG9sZUVudHJhbmNlLlZhbHVlLCBvdXQgdmVydGV4MUluZGV4LCBvdXQgdmVydGV4MkluZGV4KSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvbHlnb24uSW5zZXJ0UmFuZ2UodmVydGV4MkluZGV4LCBob2xlUG9seWdvbik7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBWZXJ0aWNlc0RldGVjdGlvblR5cGUuU2VwYXJhdGVkOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocG9seWdvbi5Ib2xlcyA9PSBudWxsKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9seWdvbi5Ib2xlcyA9IG5ldyBMaXN0PFZlcnRpY2VzPigpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9seWdvbi5Ib2xlcy5BZGQoaG9sZVBvbHlnb24pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlICh0cnVlKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGRldGVjdGVkUG9seWdvbnMuQWRkKHBvbHlnb24pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGlmIChfbXVsdGlwYXJ0RGV0ZWN0aW9uIHx8IHBvbHlnb24uQ291bnQgPD0gMilcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoU2VhcmNoTmV4dEh1bGxFbnRyYW5jZShkZXRlY3RlZFBvbHlnb25zLCBwb2x5Z29uRW50cmFuY2UuVmFsdWUsIG91dCBwb2x5Z29uRW50cmFuY2UpKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBzZWFyY2hPbiA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgd2hpbGUgKHNlYXJjaE9uKTtcclxuXHJcbiAgICAgICAgICAgIGlmIChkZXRlY3RlZFBvbHlnb25zID09IG51bGwgfHwgKGRldGVjdGVkUG9seWdvbnMgIT0gbnVsbCAmJiBkZXRlY3RlZFBvbHlnb25zLkNvdW50ID09IDApKVxyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEV4Y2VwdGlvbihcIkNvdWxkbid0IGRldGVjdCBhbnkgdmVydGljZXMuXCIpO1xyXG5cclxuXHJcbiAgICAgICAgICAgIC8vIFBvc3QgcHJvY2Vzc2luZy5cclxuICAgICAgICAgICAgaWYgKFBvbHlnb25EZXRlY3Rpb25UeXBlID09IFZlcnRpY2VzRGV0ZWN0aW9uVHlwZS5TZXBhcmF0ZWQpIC8vIE9ubHkgd2hlbiBWZXJ0aWNlc0RldGVjdGlvblR5cGUuU2VwYXJhdGVkPyAtPiBSZWNoZWNrLlxyXG4gICAgICAgICAgICAgICAgQXBwbHlUcmlhbmd1bGF0aW9uQ29tcGF0aWJsZVdpbmRpbmcocmVmIGRldGVjdGVkUG9seWdvbnMpO1xyXG5cclxuICAgICAgICAgICAgaWYgKF9waXhlbE9mZnNldE9wdGltaXphdGlvbilcclxuICAgICAgICAgICAgICAgIEFwcGx5UGl4ZWxPZmZzZXRPcHRpbWl6YXRpb24ocmVmIGRldGVjdGVkUG9seWdvbnMpO1xyXG5cclxuICAgICAgICAgICAgaWYgKF90cmFuc2Zvcm0gIT0gTWF0cml4LklkZW50aXR5KVxyXG4gICAgICAgICAgICAgICAgQXBwbHlUcmFuc2Zvcm0ocmVmIGRldGVjdGVkUG9seWdvbnMpO1xyXG5cclxuXHJcbiAgICAgICAgICAgIHJldHVybiBkZXRlY3RlZFBvbHlnb25zO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHJpdmF0ZSB2b2lkIEFwcGx5VHJpYW5ndWxhdGlvbkNvbXBhdGlibGVXaW5kaW5nKHJlZiBMaXN0PERldGVjdGVkVmVydGljZXM+IGRldGVjdGVkUG9seWdvbnMpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBmb3IgKGludCBpID0gMDsgaSA8IGRldGVjdGVkUG9seWdvbnMuQ291bnQ7IGkrKylcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgZGV0ZWN0ZWRQb2x5Z29uc1tpXS5SZXZlcnNlKCk7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKGRldGVjdGVkUG9seWdvbnNbaV0uSG9sZXMgIT0gbnVsbCAmJiBkZXRlY3RlZFBvbHlnb25zW2ldLkhvbGVzLkNvdW50ID4gMClcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKGludCBqID0gMDsgaiA8IGRldGVjdGVkUG9seWdvbnNbaV0uSG9sZXMuQ291bnQ7IGorKylcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGV0ZWN0ZWRQb2x5Z29uc1tpXS5Ib2xlc1tqXS5SZXZlcnNlKCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHByaXZhdGUgdm9pZCBBcHBseVBpeGVsT2Zmc2V0T3B0aW1pemF0aW9uKHJlZiBMaXN0PERldGVjdGVkVmVydGljZXM+IGRldGVjdGVkUG9seWdvbnMpXHJcbiAgICAgICAge1xyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHByaXZhdGUgdm9pZCBBcHBseVRyYW5zZm9ybShyZWYgTGlzdDxEZXRlY3RlZFZlcnRpY2VzPiBkZXRlY3RlZFBvbHlnb25zKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgZm9yIChpbnQgaSA9IDA7IGkgPCBkZXRlY3RlZFBvbHlnb25zLkNvdW50OyBpKyspXHJcbiAgICAgICAgICAgICAgICBkZXRlY3RlZFBvbHlnb25zW2ldLlRyYW5zZm9ybShfdHJhbnNmb3JtKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgICNyZWdpb24gRGF0YVtdIGZ1bmN0aW9uc1xyXG4gICAgICAgIHByaXZhdGUgaW50IF90ZW1wSXNTb2xpZFg7XHJcbiAgICAgICAgcHJpdmF0ZSBpbnQgX3RlbXBJc1NvbGlkWTtcclxuICAgICAgICBwdWJsaWMgYm9vbCBJc1NvbGlkKHJlZiBWZWN0b3IyIHYpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBfdGVtcElzU29saWRYID0gKGludCl2Llg7XHJcbiAgICAgICAgICAgIF90ZW1wSXNTb2xpZFkgPSAoaW50KXYuWTtcclxuXHJcbiAgICAgICAgICAgIGlmIChfdGVtcElzU29saWRYID49IDAgJiYgX3RlbXBJc1NvbGlkWCA8IF93aWR0aCAmJiBfdGVtcElzU29saWRZID49IDAgJiYgX3RlbXBJc1NvbGlkWSA8IF9oZWlnaHQpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gKF9kYXRhW190ZW1wSXNTb2xpZFggKyBfdGVtcElzU29saWRZICogX3dpZHRoXSA+PSBfYWxwaGFUb2xlcmFuY2UpO1xyXG4gICAgICAgICAgICAvL3JldHVybiAoKF9kYXRhW190ZW1wSXNTb2xpZFggKyBfdGVtcElzU29saWRZICogX3dpZHRoXSAmIDB4RkYwMDAwMDApID49IF9hbHBoYVRvbGVyYW5jZSk7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwdWJsaWMgYm9vbCBJc1NvbGlkKHJlZiBpbnQgeCwgcmVmIGludCB5KVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgaWYgKHggPj0gMCAmJiB4IDwgX3dpZHRoICYmIHkgPj0gMCAmJiB5IDwgX2hlaWdodClcclxuICAgICAgICAgICAgICAgIHJldHVybiAoX2RhdGFbeCArIHkgKiBfd2lkdGhdID49IF9hbHBoYVRvbGVyYW5jZSk7XHJcbiAgICAgICAgICAgIC8vcmV0dXJuICgoX2RhdGFbeCArIHkgKiBfd2lkdGhdICYgMHhGRjAwMDAwMCkgPj0gX2FscGhhVG9sZXJhbmNlKTtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHB1YmxpYyBib29sIElzU29saWQocmVmIGludCBpbmRleClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGlmIChpbmRleCA+PSAwICYmIGluZGV4IDwgX2RhdGFMZW5ndGgpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gKF9kYXRhW2luZGV4XSA+PSBfYWxwaGFUb2xlcmFuY2UpO1xyXG4gICAgICAgICAgICAvL3JldHVybiAoKF9kYXRhW2luZGV4XSAmIDB4RkYwMDAwMDApID49IF9hbHBoYVRvbGVyYW5jZSk7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwdWJsaWMgYm9vbCBJbkJvdW5kcyhyZWYgVmVjdG9yMiBjb29yZClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiAoY29vcmQuWCA+PSAwZiAmJiBjb29yZC5YIDwgX3dpZHRoICYmIGNvb3JkLlkgPj0gMGYgJiYgY29vcmQuWSA8IF9oZWlnaHQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAjZW5kcmVnaW9uXHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gRnVuY3Rpb24gdG8gc2VhcmNoIGZvciBhbiBlbnRyYW5jZSBwb2ludCBvZiBhIGhvbGUgaW4gYSBwb2x5Z29uLiBJdCBzZWFyY2hlcyB0aGUgcG9seWdvbiBmcm9tIHRvcCB0byBib3R0b20gYmV0d2VlbiB0aGUgcG9seWdvbiBlZGdlcy5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cInBvbHlnb25cIj5UaGUgcG9seWdvbiB0byBzZWFyY2ggaW4uPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJsYXN0SG9sZUVudHJhbmNlXCI+VGhlIGxhc3QgZW50cmFuY2UgcG9pbnQuPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHJldHVybnM+VGhlIG5leHQgaG9sZXMgZW50cmFuY2UgcG9pbnQuIE51bGwgaWYgdGhlciBhcmUgbm8gaG9sZXMuPC9yZXR1cm5zPlxyXG4gICAgICAgIHByaXZhdGUgVmVjdG9yMj8gU2VhcmNoSG9sZUVudHJhbmNlKFZlcnRpY2VzIHBvbHlnb24sIFZlY3RvcjI/IGxhc3RIb2xlRW50cmFuY2UpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBpZiAocG9seWdvbiA9PSBudWxsKVxyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEFyZ3VtZW50TnVsbEV4Y2VwdGlvbihcIidwb2x5Z29uJyBjYW4ndCBiZSBudWxsLlwiKTtcclxuXHJcbiAgICAgICAgICAgIGlmIChwb2x5Z29uLkNvdW50IDwgMylcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBBcmd1bWVudEV4Y2VwdGlvbihcIidwb2x5Z29uLk1haW5Qb2x5Z29uLkNvdW50JyBjYW4ndCBiZSBsZXNzIHRoZW4gMy5cIik7XHJcblxyXG5cclxuICAgICAgICAgICAgTGlzdDxmbG9hdD4geENvb3JkcztcclxuICAgICAgICAgICAgVmVjdG9yMj8gZW50cmFuY2U7XHJcblxyXG4gICAgICAgICAgICBpbnQgc3RhcnRZO1xyXG4gICAgICAgICAgICBpbnQgZW5kWTtcclxuXHJcbiAgICAgICAgICAgIGludCBsYXN0U29saWQgPSAwO1xyXG4gICAgICAgICAgICBib29sIGZvdW5kU29saWQ7XHJcbiAgICAgICAgICAgIGJvb2wgZm91bmRUcmFuc3BhcmVudDtcclxuXHJcbiAgICAgICAgICAgIC8vIFNldCBzdGFydCB5IGNvb3JkaW5hdGUuXHJcbiAgICAgICAgICAgIGlmIChsYXN0SG9sZUVudHJhbmNlLkhhc1ZhbHVlKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAvLyBXZSBuZWVkIHRoZSB5IGNvb3JkaW5hdGUgb25seS5cclxuICAgICAgICAgICAgICAgIHN0YXJ0WSA9IChpbnQpbGFzdEhvbGVFbnRyYW5jZS5WYWx1ZS5ZO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgLy8gU3RhcnQgZnJvbSB0aGUgdG9wIG9mIHRoZSBwb2x5Z29uIGlmIGxhc3QgZW50cmFuY2UgPT0gbnVsbC5cclxuICAgICAgICAgICAgICAgIHN0YXJ0WSA9IChpbnQpR2V0VG9wTW9zdENvb3JkKHBvbHlnb24pO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBTZXQgdGhlIGVuZCB5IGNvb3JkaW5hdGUuXHJcbiAgICAgICAgICAgIGVuZFkgPSAoaW50KUdldEJvdHRvbU1vc3RDb29yZChwb2x5Z29uKTtcclxuXHJcbiAgICAgICAgICAgIGlmIChzdGFydFkgPiAwICYmIHN0YXJ0WSA8IF9oZWlnaHQgJiYgZW5kWSA+IDAgJiYgZW5kWSA8IF9oZWlnaHQpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIC8vIGdvIGZyb20gdG9wIHRvIGJvdHRvbSBvZiB0aGUgcG9seWdvblxyXG4gICAgICAgICAgICAgICAgZm9yIChpbnQgeSA9IHN0YXJ0WTsgeSA8PSBlbmRZOyB5KyspXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gZ2V0IHgtY29vcmQgb2YgZXZlcnkgcG9seWdvbiBlZGdlIHdoaWNoIGNyb3NzZXMgeVxyXG4gICAgICAgICAgICAgICAgICAgIHhDb29yZHMgPSBTZWFyY2hDcm9zc2luZ0VkZ2VzKHBvbHlnb24sIHkpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBXZSBuZWVkIGFuIGV2ZW4gbnVtYmVyIG9mIGNyb3NzaW5nIGVkZ2VzLiBcclxuICAgICAgICAgICAgICAgICAgICAvLyBJdCdzIGFsd2F5cyBhIHBhaXIgb2Ygc3RhcnQgYW5kIGVuZCBlZGdlOiBub3RoaW5nIHwgcG9seWdvbiB8IGhvbGUgfCBwb2x5Z29uIHwgbm90aGluZyAuLi5cclxuICAgICAgICAgICAgICAgICAgICAvLyBJZiBpdCdzIG5vdCB0aGVuIGRvbid0IGJvdGhlciwgaXQncyBwcm9iYWJseSBhIHBlYWsgLi4uXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gLi4ud2hpY2ggc2hvdWxkIGJlIGZpbHRlcmVkIG91dCBieSBTZWFyY2hDcm9zc2luZ0VkZ2VzKCkgYW55d2F5LlxyXG4gICAgICAgICAgICAgICAgICAgIGlmICh4Q29vcmRzLkNvdW50ID4gMSAmJiB4Q29vcmRzLkNvdW50ICUgMiA9PSAwKVxyXG4gICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gT2ssIHRoaXMgaXMgc2hvcnQsIGJ1dCBwcm9iYWJseSBhIGxpdHRsZSBiaXQgY29uZnVzaW5nLlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGlzIHBhcnQgc2VhcmNoZXMgZnJvbSBsZWZ0IHRvIHJpZ2h0IGJldHdlZW4gdGhlIGVkZ2VzIGluc2lkZSB0aGUgcG9seWdvbi5cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGhlIHByb2JsZW06IFdlIGFyZSB1c2luZyB0aGUgcG9seWdvbiBkYXRhIHRvIHNlYXJjaCBpbiB0aGUgdGV4dHVyZSBkYXRhLlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGF0J3Mgc2ltcGx5IG5vdCBhY2N1cmF0ZSwgYnV0IG5lY2Vzc2FyeSBiZWNhdXNlIG9mIHBlcmZvcm1hbmNlLlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGludCBpID0gMDsgaSA8IHhDb29yZHMuQ291bnQ7IGkgKz0gMilcclxuICAgICAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm91bmRTb2xpZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm91bmRUcmFuc3BhcmVudCA9IGZhbHNlO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFdlIHNlYXJjaCBiZXR3ZWVuIHRoZSBlZGdlcyBpbnNpZGUgdGhlIHBvbHlnb24uXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGludCB4ID0gKGludCl4Q29vcmRzW2ldOyB4IDw9IChpbnQpeENvb3Jkc1tpICsgMV07IHgrKylcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBGaXJzdCBwYXNzOiBJc1NvbGlkIG1pZ2h0IHJldHVybiBmYWxzZS5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBJbiB0aGF0IGNhc2UgdGhlIHBvbHlnb24gZWRnZSBkb2Vzbid0IGxpZSBvbiB0aGUgdGV4dHVyZSdzIHNvbGlkIHBpeGVsLCBiZWNhdXNlIG9mIHRoZSBodWxsIHRvbGVhcmFuY2UuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWYgdGhlIGVkZ2UgbGllcyBiZWZvcmUgdGhlIGZpcnN0IHNvbGlkIHBpeGVsIHRoZW4gd2UgbmVlZCB0byBza2lwIG91ciB0cmFuc3BhcmVudCBwaXhlbCBmaW5kcy5cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGhlIGFsZ29yaXRobSBzdGFydHMgdG8gc2VhcmNoIGZvciBhIHJlbGV2YW50IHRyYW5zcGFyZW50IHBpeGVsICh3aGljaCBpbmRpY2F0ZXMgYSBwb3NzaWJsZSBob2xlKSBcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBhZnRlciBpdCBoYXMgZm91bmQgYSBzb2xpZCBwaXhlbC5cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQWZ0ZXIgd2UndmUgZm91bmQgYSBzb2xpZCBhbmQgYSB0cmFuc3BhcmVudCBwaXhlbCAoYSBob2xlJ3MgbGVmdCBlZGdlKSBcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB3ZSBzZWFyY2ggZm9yIGEgc29saWQgcGl4ZWwgYWdhaW4gKGEgaG9sZSdzIHJpZ2h0IGVkZ2UpLlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFdoZW4gZm91bmQgdGhlIGRpc3RhbmNlIG9mIHRoYXQgY29vZHJpbmF0ZSBoYXMgdG8gYmUgZ3JlYXRlciB0aGVuIHRoZSBodWxsIHRvbGVyYW5jZS5cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKElzU29saWQocmVmIHgsIHJlZiB5KSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghZm91bmRUcmFuc3BhcmVudClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm91bmRTb2xpZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYXN0U29saWQgPSB4O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZm91bmRTb2xpZCAmJiBmb3VuZFRyYW5zcGFyZW50KVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbnRyYW5jZSA9IG5ldyBWZWN0b3IyKGxhc3RTb2xpZCwgeSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKERpc3RhbmNlVG9IdWxsQWNjZXB0YWJsZShwb2x5Z29uLCBlbnRyYW5jZS5WYWx1ZSwgdHJ1ZSkpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGVudHJhbmNlO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVudHJhbmNlID0gbnVsbDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChmb3VuZFNvbGlkKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm91bmRUcmFuc3BhcmVudCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh4Q29vcmRzLkNvdW50ICUgMiA9PSAwKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgRGVidWcuV3JpdGVMaW5lKFwiU2VhcmNoQ3Jvc3NpbmdFZGdlcygpICUgMiAhPSAwXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwcml2YXRlIGJvb2wgRGlzdGFuY2VUb0h1bGxBY2NlcHRhYmxlKERldGVjdGVkVmVydGljZXMgcG9seWdvbiwgVmVjdG9yMiBwb2ludCwgYm9vbCBoaWdoZXJEZXRhaWwpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBpZiAocG9seWdvbiA9PSBudWxsKVxyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEFyZ3VtZW50TnVsbEV4Y2VwdGlvbihcInBvbHlnb25cIiwgXCIncG9seWdvbicgY2FuJ3QgYmUgbnVsbC5cIik7XHJcblxyXG4gICAgICAgICAgICBpZiAocG9seWdvbi5Db3VudCA8IDMpXHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQXJndW1lbnRFeGNlcHRpb24oXCIncG9seWdvbi5NYWluUG9seWdvbi5Db3VudCcgY2FuJ3QgYmUgbGVzcyB0aGVuIDMuXCIpO1xyXG5cclxuICAgICAgICAgICAgLy8gQ2hlY2sgdGhlIGRpc3RhbmNlIHRvIG1haW4gcG9seWdvbi5cclxuICAgICAgICAgICAgaWYgKERpc3RhbmNlVG9IdWxsQWNjZXB0YWJsZSgoVmVydGljZXMpcG9seWdvbiwgcG9pbnQsIGhpZ2hlckRldGFpbCkpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGlmIChwb2x5Z29uLkhvbGVzICE9IG51bGwpXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yIChpbnQgaSA9IDA7IGkgPCBwb2x5Z29uLkhvbGVzLkNvdW50OyBpKyspXHJcbiAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBJZiB0aGVyZSBpcyBvbmUgZGlzdGFuY2Ugbm90IGFjY2VwdGFibGUgdGhlbiByZXR1cm4gZmFsc2UuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghRGlzdGFuY2VUb0h1bGxBY2NlcHRhYmxlKHBvbHlnb24uSG9sZXNbaV0sIHBvaW50LCBoaWdoZXJEZXRhaWwpKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAvLyBBbGwgZGlzdGFuY2VzIGFyZSBsYXJnZXIgdGhlbiBfaHVsbFRvbGVyYW5jZS5cclxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBEZWZhdWx0IHRvIGZhbHNlLlxyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwcml2YXRlIGJvb2wgRGlzdGFuY2VUb0h1bGxBY2NlcHRhYmxlKFZlcnRpY2VzIHBvbHlnb24sIFZlY3RvcjIgcG9pbnQsIGJvb2wgaGlnaGVyRGV0YWlsKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgaWYgKHBvbHlnb24gPT0gbnVsbClcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBBcmd1bWVudE51bGxFeGNlcHRpb24oXCJwb2x5Z29uXCIsIFwiJ3BvbHlnb24nIGNhbid0IGJlIG51bGwuXCIpO1xyXG5cclxuICAgICAgICAgICAgaWYgKHBvbHlnb24uQ291bnQgPCAzKVxyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEFyZ3VtZW50RXhjZXB0aW9uKFwiJ3BvbHlnb24uQ291bnQnIGNhbid0IGJlIGxlc3MgdGhlbiAzLlwiKTtcclxuXHJcblxyXG4gICAgICAgICAgICBWZWN0b3IyIGVkZ2VWZXJ0ZXgyID0gcG9seWdvbltwb2x5Z29uLkNvdW50IC0gMV07XHJcbiAgICAgICAgICAgIFZlY3RvcjIgZWRnZVZlcnRleDE7XHJcblxyXG4gICAgICAgICAgICBpZiAoaGlnaGVyRGV0YWlsKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBmb3IgKGludCBpID0gMDsgaSA8IHBvbHlnb24uQ291bnQ7IGkrKylcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBlZGdlVmVydGV4MSA9IHBvbHlnb25baV07XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChMaW5lVG9vbHMuRGlzdGFuY2VCZXR3ZWVuUG9pbnRBbmRMaW5lU2VnbWVudChyZWYgcG9pbnQsIHJlZiBlZGdlVmVydGV4MSwgcmVmIGVkZ2VWZXJ0ZXgyKSA8PSBfaHVsbFRvbGVyYW5jZSB8fFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBMaW5lVG9vbHMuRGlzdGFuY2VCZXR3ZWVuUG9pbnRBbmRQb2ludChyZWYgcG9pbnQsIHJlZiBlZGdlVmVydGV4MSkgPD0gX2h1bGxUb2xlcmFuY2UpXHJcbiAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICBlZGdlVmVydGV4MiA9IHBvbHlnb25baV07XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBmb3IgKGludCBpID0gMDsgaSA8IHBvbHlnb24uQ291bnQ7IGkrKylcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBlZGdlVmVydGV4MSA9IHBvbHlnb25baV07XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChMaW5lVG9vbHMuRGlzdGFuY2VCZXR3ZWVuUG9pbnRBbmRMaW5lU2VnbWVudChyZWYgcG9pbnQsIHJlZiBlZGdlVmVydGV4MSwgcmVmIGVkZ2VWZXJ0ZXgyKSA8PSBfaHVsbFRvbGVyYW5jZSlcclxuICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGVkZ2VWZXJ0ZXgyID0gcG9seWdvbltpXTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHJpdmF0ZSBib29sIEluUG9seWdvbihEZXRlY3RlZFZlcnRpY2VzIHBvbHlnb24sIFZlY3RvcjIgcG9pbnQpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBib29sIGluUG9seWdvbiA9ICFEaXN0YW5jZVRvSHVsbEFjY2VwdGFibGUocG9seWdvbiwgcG9pbnQsIHRydWUpO1xyXG5cclxuICAgICAgICAgICAgaWYgKCFpblBvbHlnb24pXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIExpc3Q8ZmxvYXQ+IHhDb29yZHMgPSBTZWFyY2hDcm9zc2luZ0VkZ2VzKHBvbHlnb24sIChpbnQpcG9pbnQuWSk7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKHhDb29yZHMuQ291bnQgPiAwICYmIHhDb29yZHMuQ291bnQgJSAyID09IDApXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yIChpbnQgaSA9IDA7IGkgPCB4Q29vcmRzLkNvdW50OyBpICs9IDIpXHJcbiAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoeENvb3Jkc1tpXSA8PSBwb2ludC5YICYmIHhDb29yZHNbaSArIDFdID49IHBvaW50LlgpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHByaXZhdGUgVmVjdG9yMj8gR2V0VG9wTW9zdFZlcnRleChWZXJ0aWNlcyB2ZXJ0aWNlcylcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGZsb2F0IHRvcE1vc3RWYWx1ZSA9IGZsb2F0Lk1heFZhbHVlO1xyXG4gICAgICAgICAgICBWZWN0b3IyPyB0b3BNb3N0ID0gbnVsbDtcclxuXHJcbiAgICAgICAgICAgIGZvciAoaW50IGkgPSAwOyBpIDwgdmVydGljZXMuQ291bnQ7IGkrKylcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgaWYgKHRvcE1vc3RWYWx1ZSA+IHZlcnRpY2VzW2ldLlkpXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgdG9wTW9zdFZhbHVlID0gdmVydGljZXNbaV0uWTtcclxuICAgICAgICAgICAgICAgICAgICB0b3BNb3N0ID0gdmVydGljZXNbaV07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHJldHVybiB0b3BNb3N0O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHJpdmF0ZSBmbG9hdCBHZXRUb3BNb3N0Q29vcmQoVmVydGljZXMgdmVydGljZXMpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBmbG9hdCByZXR1cm5WYWx1ZSA9IGZsb2F0Lk1heFZhbHVlO1xyXG5cclxuICAgICAgICAgICAgZm9yIChpbnQgaSA9IDA7IGkgPCB2ZXJ0aWNlcy5Db3VudDsgaSsrKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBpZiAocmV0dXJuVmFsdWUgPiB2ZXJ0aWNlc1tpXS5ZKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVyblZhbHVlID0gdmVydGljZXNbaV0uWTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuIHJldHVyblZhbHVlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHJpdmF0ZSBmbG9hdCBHZXRCb3R0b21Nb3N0Q29vcmQoVmVydGljZXMgdmVydGljZXMpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBmbG9hdCByZXR1cm5WYWx1ZSA9IGZsb2F0Lk1pblZhbHVlO1xyXG5cclxuICAgICAgICAgICAgZm9yIChpbnQgaSA9IDA7IGkgPCB2ZXJ0aWNlcy5Db3VudDsgaSsrKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBpZiAocmV0dXJuVmFsdWUgPCB2ZXJ0aWNlc1tpXS5ZKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVyblZhbHVlID0gdmVydGljZXNbaV0uWTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuIHJldHVyblZhbHVlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHJpdmF0ZSBMaXN0PGZsb2F0PiBTZWFyY2hDcm9zc2luZ0VkZ2VzKERldGVjdGVkVmVydGljZXMgcG9seWdvbiwgaW50IHkpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBpZiAocG9seWdvbiA9PSBudWxsKVxyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEFyZ3VtZW50TnVsbEV4Y2VwdGlvbihcInBvbHlnb25cIiwgXCIncG9seWdvbicgY2FuJ3QgYmUgbnVsbC5cIik7XHJcblxyXG4gICAgICAgICAgICBpZiAocG9seWdvbi5Db3VudCA8IDMpXHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQXJndW1lbnRFeGNlcHRpb24oXCIncG9seWdvbi5NYWluUG9seWdvbi5Db3VudCcgY2FuJ3QgYmUgbGVzcyB0aGVuIDMuXCIpO1xyXG5cclxuICAgICAgICAgICAgTGlzdDxmbG9hdD4gcmVzdWx0ID0gU2VhcmNoQ3Jvc3NpbmdFZGdlcygoVmVydGljZXMpcG9seWdvbiwgeSk7XHJcblxyXG4gICAgICAgICAgICBpZiAocG9seWdvbi5Ib2xlcyAhPSBudWxsKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBmb3IgKGludCBpID0gMDsgaSA8IHBvbHlnb24uSG9sZXMuQ291bnQ7IGkrKylcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICByZXN1bHQuQWRkUmFuZ2UoU2VhcmNoQ3Jvc3NpbmdFZGdlcyhwb2x5Z29uLkhvbGVzW2ldLCB5KSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHJlc3VsdC5Tb3J0KCk7XHJcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIFNlYXJjaGVzIHRoZSBwb2x5Z29uIGZvciB0aGUgeCBjb29yZGluYXRlcyBvZiB0aGUgZWRnZXMgdGhhdCBjcm9zcyB0aGUgc3BlY2lmaWVkIHkgY29vcmRpbmF0ZS5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cInBvbHlnb25cIj5Qb2x5Z29uIHRvIHNlYXJjaCBpbi48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cInlcIj5ZIGNvb3JkaW5hdGUgdG8gY2hlY2sgZm9yIGVkZ2VzLjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxyZXR1cm5zPkRlc2NlbmRpbmcgc29ydGVkIGxpc3Qgb2YgeCBjb29yZGluYXRlcyBvZiBlZGdlcyB0aGF0IGNyb3NzIHRoZSBzcGVjaWZpZWQgeSBjb29yZGluYXRlLjwvcmV0dXJucz5cclxuICAgICAgICBwcml2YXRlIExpc3Q8ZmxvYXQ+IFNlYXJjaENyb3NzaW5nRWRnZXMoVmVydGljZXMgcG9seWdvbiwgaW50IHkpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICAvLyBzaWNrLW8tbm90ZTpcclxuICAgICAgICAgICAgLy8gVXNlZCB0byBzZWFyY2ggdGhlIHggY29vcmRpbmF0ZXMgb2YgZWRnZXMgaW4gdGhlIHBvbHlnb24gZm9yIGEgc3BlY2lmaWMgeSBjb29yZGluYXRlLlxyXG4gICAgICAgICAgICAvLyAoVXN1YWx5IGNvbW1pbmcgZnJvbSB0aGUgdGV4dHVyZSBkYXRhLCB0aGF0J3Mgd2h5IGl0J3MgYW4gaW50IGFuZCBub3QgYSBmbG9hdC4pXHJcblxyXG4gICAgICAgICAgICBMaXN0PGZsb2F0PiBlZGdlcyA9IG5ldyBMaXN0PGZsb2F0PigpO1xyXG5cclxuICAgICAgICAgICAgLy8gY3VycmVudCBlZGdlXHJcbiAgICAgICAgICAgIFZlY3RvcjIgc2xvcGU7XHJcbiAgICAgICAgICAgIFZlY3RvcjIgdmVydGV4MTsgICAgLy8gaVxyXG4gICAgICAgICAgICBWZWN0b3IyIHZlcnRleDI7ICAgIC8vIGkgLSAxXHJcblxyXG4gICAgICAgICAgICAvLyBuZXh0IGVkZ2VcclxuICAgICAgICAgICAgVmVjdG9yMiBuZXh0U2xvcGU7XHJcbiAgICAgICAgICAgIFZlY3RvcjIgbmV4dFZlcnRleDsgLy8gaSArIDFcclxuXHJcbiAgICAgICAgICAgIGJvb2wgYWRkRmluZDtcclxuXHJcbiAgICAgICAgICAgIGlmIChwb2x5Z29uLkNvdW50ID4gMilcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgLy8gVGhlcmUgaXMgYSBnYXAgYmV0d2VlbiB0aGUgbGFzdCBhbmQgdGhlIGZpcnN0IHZlcnRleCBpbiB0aGUgdmVydGV4IGxpc3QuXHJcbiAgICAgICAgICAgICAgICAvLyBXZSB3aWxsIGJyaWRnZSB0aGF0IGJ5IHNldHRpbmcgdGhlIGxhc3QgdmVydGV4ICh2ZXJ0ZXgyKSB0byB0aGUgbGFzdCBcclxuICAgICAgICAgICAgICAgIC8vIHZlcnRleCBpbiB0aGUgbGlzdC5cclxuICAgICAgICAgICAgICAgIHZlcnRleDIgPSBwb2x5Z29uW3BvbHlnb24uQ291bnQgLSAxXTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBXZSBhcmUgbW92aW5nIGFsb25nIHRoZSBwb2x5Z29uIGVkZ2VzLlxyXG4gICAgICAgICAgICAgICAgZm9yIChpbnQgaSA9IDA7IGkgPCBwb2x5Z29uLkNvdW50OyBpKyspXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmVydGV4MSA9IHBvbHlnb25baV07XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIEFwcHJveC4gY2hlY2sgaWYgdGhlIGVkZ2UgY3Jvc3NlcyBvdXIgeSBjb29yZC5cclxuICAgICAgICAgICAgICAgICAgICBpZiAoKHZlcnRleDEuWSA+PSB5ICYmIHZlcnRleDIuWSA8PSB5KSB8fFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAodmVydGV4MS5ZIDw9IHkgJiYgdmVydGV4Mi5ZID49IHkpKVxyXG4gICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWdub3JlIGVkZ2VzIHRoYXQgYXJlIHBhcmFsbGVsIHRvIHkuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2ZXJ0ZXgxLlkgIT0gdmVydGV4Mi5ZKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhZGRGaW5kID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNsb3BlID0gdmVydGV4MiAtIHZlcnRleDE7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gU3BlY2lhbCB0aHJlYXRtZW50IGZvciBlZGdlcyB0aGF0IGVuZCBhdCB0aGUgeSBjb29yZC5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2ZXJ0ZXgxLlkgPT0geSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBDcmVhdGUgcHJldmlldyBvZiB0aGUgbmV4dCBlZGdlLlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5leHRWZXJ0ZXggPSBwb2x5Z29uWyhpICsgMSkgJSBwb2x5Z29uLkNvdW50XTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXh0U2xvcGUgPSB2ZXJ0ZXgxIC0gbmV4dFZlcnRleDtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWdub3JlIHBlYWtzLiBcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBJZiB0aHdvIGVkZ2VzIGFyZSBhbGlnbmVkIGxpa2UgdGhpczogL1xcIGFuZCB0aGUgeSBjb29yZGluYXRlIGxpZXMgb24gdGhlIHRvcCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB0aGVuIHdlIGdldCB0aGUgc2FtZSB4IGNvb3JkIHR3aWNlIGFuZCB3ZSBkb24ndCBuZWVkIHRoYXQuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNsb3BlLlkgPiAwKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhZGRGaW5kID0gKG5leHRTbG9wZS5ZIDw9IDApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWRkRmluZCA9IChuZXh0U2xvcGUuWSA+PSAwKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoYWRkRmluZClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlZGdlcy5BZGQoKHkgLSB2ZXJ0ZXgxLlkpIC8gc2xvcGUuWSAqIHNsb3BlLlggKyB2ZXJ0ZXgxLlgpOyAvLyBDYWxjdWxhdGUgYW5kIGFkZCB0aGUgeCBjb29yZC5cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gdmVydGV4MSBiZWNvbWVzIHZlcnRleDIgOikuXHJcbiAgICAgICAgICAgICAgICAgICAgdmVydGV4MiA9IHZlcnRleDE7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGVkZ2VzLlNvcnQoKTtcclxuICAgICAgICAgICAgcmV0dXJuIGVkZ2VzO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHJpdmF0ZSBib29sIFNwbGl0UG9seWdvbkVkZ2UoVmVydGljZXMgcG9seWdvbiwgVmVjdG9yMiBjb29yZEluc2lkZVRoZVBvbHlnb24sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG91dCBpbnQgdmVydGV4MUluZGV4LCBvdXQgaW50IHZlcnRleDJJbmRleClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIFZlY3RvcjIgc2xvcGU7XHJcbiAgICAgICAgICAgIGludCBuZWFyZXN0RWRnZVZlcnRleDFJbmRleCA9IDA7XHJcbiAgICAgICAgICAgIGludCBuZWFyZXN0RWRnZVZlcnRleDJJbmRleCA9IDA7XHJcbiAgICAgICAgICAgIGJvb2wgZWRnZUZvdW5kID0gZmFsc2U7XHJcblxyXG4gICAgICAgICAgICBmbG9hdCBzaG9ydGVzdERpc3RhbmNlID0gZmxvYXQuTWF4VmFsdWU7XHJcblxyXG4gICAgICAgICAgICBib29sIGVkZ2VDb29yZEZvdW5kID0gZmFsc2U7XHJcbiAgICAgICAgICAgIFZlY3RvcjIgZm91bmRFZGdlQ29vcmQgPSBWZWN0b3IyLlplcm87XHJcblxyXG4gICAgICAgICAgICBMaXN0PGZsb2F0PiB4Q29vcmRzID0gU2VhcmNoQ3Jvc3NpbmdFZGdlcyhwb2x5Z29uLCAoaW50KWNvb3JkSW5zaWRlVGhlUG9seWdvbi5ZKTtcclxuXHJcbiAgICAgICAgICAgIHZlcnRleDFJbmRleCA9IDA7XHJcbiAgICAgICAgICAgIHZlcnRleDJJbmRleCA9IDA7XHJcblxyXG4gICAgICAgICAgICBmb3VuZEVkZ2VDb29yZC5ZID0gY29vcmRJbnNpZGVUaGVQb2x5Z29uLlk7XHJcblxyXG4gICAgICAgICAgICBpZiAoeENvb3JkcyAhPSBudWxsICYmIHhDb29yZHMuQ291bnQgPiAxICYmIHhDb29yZHMuQ291bnQgJSAyID09IDApXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGZsb2F0IGRpc3RhbmNlO1xyXG4gICAgICAgICAgICAgICAgZm9yIChpbnQgaSA9IDA7IGkgPCB4Q29vcmRzLkNvdW50OyBpKyspXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHhDb29yZHNbaV0gPCBjb29yZEluc2lkZVRoZVBvbHlnb24uWClcclxuICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRpc3RhbmNlID0gY29vcmRJbnNpZGVUaGVQb2x5Z29uLlggLSB4Q29vcmRzW2ldO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRpc3RhbmNlIDwgc2hvcnRlc3REaXN0YW5jZSlcclxuICAgICAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2hvcnRlc3REaXN0YW5jZSA9IGRpc3RhbmNlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm91bmRFZGdlQ29vcmQuWCA9IHhDb29yZHNbaV07XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWRnZUNvb3JkRm91bmQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGlmIChlZGdlQ29vcmRGb3VuZClcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBzaG9ydGVzdERpc3RhbmNlID0gZmxvYXQuTWF4VmFsdWU7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGludCBlZGdlVmVydGV4MkluZGV4ID0gcG9seWdvbi5Db3VudCAtIDE7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGludCBlZGdlVmVydGV4MUluZGV4O1xyXG4gICAgICAgICAgICAgICAgICAgIGZvciAoZWRnZVZlcnRleDFJbmRleCA9IDA7IGVkZ2VWZXJ0ZXgxSW5kZXggPCBwb2x5Z29uLkNvdW50OyBlZGdlVmVydGV4MUluZGV4KyspXHJcbiAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBWZWN0b3IyIHRlbXBWZWN0b3IxID0gcG9seWdvbltlZGdlVmVydGV4MUluZGV4XTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgVmVjdG9yMiB0ZW1wVmVjdG9yMiA9IHBvbHlnb25bZWRnZVZlcnRleDJJbmRleF07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRpc3RhbmNlID0gTGluZVRvb2xzLkRpc3RhbmNlQmV0d2VlblBvaW50QW5kTGluZVNlZ21lbnQocmVmIGZvdW5kRWRnZUNvb3JkLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlZiB0ZW1wVmVjdG9yMSwgcmVmIHRlbXBWZWN0b3IyKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRpc3RhbmNlIDwgc2hvcnRlc3REaXN0YW5jZSlcclxuICAgICAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2hvcnRlc3REaXN0YW5jZSA9IGRpc3RhbmNlO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5lYXJlc3RFZGdlVmVydGV4MUluZGV4ID0gZWRnZVZlcnRleDFJbmRleDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5lYXJlc3RFZGdlVmVydGV4MkluZGV4ID0gZWRnZVZlcnRleDJJbmRleDtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlZGdlRm91bmQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlZGdlVmVydGV4MkluZGV4ID0gZWRnZVZlcnRleDFJbmRleDtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChlZGdlRm91bmQpXHJcbiAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzbG9wZSA9IHBvbHlnb25bbmVhcmVzdEVkZ2VWZXJ0ZXgySW5kZXhdIC0gcG9seWdvbltuZWFyZXN0RWRnZVZlcnRleDFJbmRleF07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNsb3BlLk5vcm1hbGl6ZSgpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgVmVjdG9yMiB0ZW1wVmVjdG9yID0gcG9seWdvbltuZWFyZXN0RWRnZVZlcnRleDFJbmRleF07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRpc3RhbmNlID0gTGluZVRvb2xzLkRpc3RhbmNlQmV0d2VlblBvaW50QW5kUG9pbnQocmVmIHRlbXBWZWN0b3IsIHJlZiBmb3VuZEVkZ2VDb29yZCk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICB2ZXJ0ZXgxSW5kZXggPSBuZWFyZXN0RWRnZVZlcnRleDFJbmRleDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmVydGV4MkluZGV4ID0gbmVhcmVzdEVkZ2VWZXJ0ZXgxSW5kZXggKyAxO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgcG9seWdvbi5JbnNlcnQobmVhcmVzdEVkZ2VWZXJ0ZXgxSW5kZXgsIGRpc3RhbmNlICogc2xvcGUgKyBwb2x5Z29uW3ZlcnRleDFJbmRleF0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBwb2x5Z29uLkluc2VydChuZWFyZXN0RWRnZVZlcnRleDFJbmRleCwgZGlzdGFuY2UgKiBzbG9wZSArIHBvbHlnb25bdmVydGV4MkluZGV4XSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJlbnRyYW5jZVwiPjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwibGFzdFwiPjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxyZXR1cm5zPjwvcmV0dXJucz5cclxuICAgICAgICBwcml2YXRlIFZlcnRpY2VzIENyZWF0ZVNpbXBsZVBvbHlnb24oVmVjdG9yMiBlbnRyYW5jZSwgVmVjdG9yMiBsYXN0KVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgYm9vbCBlbnRyYW5jZUZvdW5kID0gZmFsc2U7XHJcbiAgICAgICAgICAgIGJvb2wgZW5kT2ZIdWxsID0gZmFsc2U7XHJcblxyXG4gICAgICAgICAgICBWZXJ0aWNlcyBwb2x5Z29uID0gbmV3IFZlcnRpY2VzKDMyKTtcclxuICAgICAgICAgICAgVmVydGljZXMgaHVsbEFyZWEgPSBuZXcgVmVydGljZXMoMzIpO1xyXG4gICAgICAgICAgICBWZXJ0aWNlcyBlbmRPZkh1bGxBcmVhID0gbmV3IFZlcnRpY2VzKDMyKTtcclxuXHJcbiAgICAgICAgICAgIFZlY3RvcjIgY3VycmVudCA9IFZlY3RvcjIuWmVybztcclxuXHJcbiAgICAgICAgICAgICNyZWdpb24gRW50cmFuY2UgY2hlY2tcclxuXHJcbiAgICAgICAgICAgIC8vIEdldCB0aGUgZW50cmFuY2UgcG9pbnQuIC8vdG9kbzogYWxsZSBtw7ZnbGljaGtlaXRlbiB0ZXN0ZW5cclxuICAgICAgICAgICAgaWYgKGVudHJhbmNlID09IFZlY3RvcjIuWmVybyB8fCAhSW5Cb3VuZHMocmVmIGVudHJhbmNlKSlcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgZW50cmFuY2VGb3VuZCA9IFNlYXJjaEh1bGxFbnRyYW5jZShvdXQgZW50cmFuY2UpO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmIChlbnRyYW5jZUZvdW5kKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnQgPSBuZXcgVmVjdG9yMihlbnRyYW5jZS5YIC0gMWYsIGVudHJhbmNlLlkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgaWYgKElzU29saWQocmVmIGVudHJhbmNlKSlcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoSXNOZWFyUGl4ZWwocmVmIGVudHJhbmNlLCByZWYgbGFzdCkpXHJcbiAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50ID0gbGFzdDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZW50cmFuY2VGb3VuZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIFZlY3RvcjIgdGVtcDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKFNlYXJjaE5lYXJQaXhlbHMoZmFsc2UsIHJlZiBlbnRyYW5jZSwgb3V0IHRlbXApKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50ID0gdGVtcDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVudHJhbmNlRm91bmQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZW50cmFuY2VGb3VuZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAjZW5kcmVnaW9uXHJcblxyXG4gICAgICAgICAgICBpZiAoZW50cmFuY2VGb3VuZClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgcG9seWdvbi5BZGQoZW50cmFuY2UpO1xyXG4gICAgICAgICAgICAgICAgaHVsbEFyZWEuQWRkKGVudHJhbmNlKTtcclxuXHJcbiAgICAgICAgICAgICAgICBWZWN0b3IyIG5leHQgPSBlbnRyYW5jZTtcclxuXHJcbiAgICAgICAgICAgICAgICBkb1xyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIFNlYXJjaCBpbiB0aGUgcHJlIHZpc2lvbiBsaXN0IGZvciBhbiBvdXRzdGFuZGluZyBwb2ludC5cclxuICAgICAgICAgICAgICAgICAgICBWZWN0b3IyIG91dHN0YW5kaW5nO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChTZWFyY2hGb3JPdXRzdGFuZGluZ1ZlcnRleChodWxsQXJlYSwgb3V0IG91dHN0YW5kaW5nKSlcclxuICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlbmRPZkh1bGwpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFdlIGhhdmUgZm91bmQgdGhlIG5leHQgcGl4ZWwsIGJ1dCBpcyBpdCBvbiB0aGUgbGFzdCBiaXQgb2YgdGhlIGh1bGw/XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZW5kT2ZIdWxsQXJlYS5Db250YWlucyhvdXRzdGFuZGluZykpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gSW5kZWVkLlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvbHlnb24uQWRkKG91dHN0YW5kaW5nKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGF0J3MgZW5vdWdoLCBxdWl0LlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEFkZCBpdCBhbmQgcmVtb3ZlIGFsbCB2ZXJ0aWNlcyB0aGF0IGRvbid0IG1hdHRlciBhbnltb3JlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIChhbGwgdGhlIHZlcnRpY2VzIGJlZm9yZSB0aGUgb3V0c3RhbmRpbmcpLlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBwb2x5Z29uLkFkZChvdXRzdGFuZGluZyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGh1bGxBcmVhLlJlbW92ZVJhbmdlKDAsIGh1bGxBcmVhLkluZGV4T2Yob3V0c3RhbmRpbmcpKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIExhc3QgcG9pbnQgZ2V0cyBjdXJyZW50IGFuZCBjdXJyZW50IGdldHMgbmV4dC4gT3VyIGxpdHRsZSBzcGlkZXIgaXMgbW92aW5nIGZvcndhcmQgb24gdGhlIGh1bGwgOykuXHJcbiAgICAgICAgICAgICAgICAgICAgbGFzdCA9IGN1cnJlbnQ7XHJcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudCA9IG5leHQ7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIEdldCB0aGUgbmV4dCBwb2ludCBvbiBodWxsLlxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChHZXROZXh0SHVsbFBvaW50KHJlZiBsYXN0LCByZWYgY3VycmVudCwgb3V0IG5leHQpKVxyXG4gICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQWRkIHRoZSB2ZXJ0ZXggdG8gYSBodWxsIHByZSB2aXNpb24gbGlzdC5cclxuICAgICAgICAgICAgICAgICAgICAgICAgaHVsbEFyZWEuQWRkKG5leHQpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBRdWl0XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5leHQgPT0gZW50cmFuY2UgJiYgIWVuZE9mSHVsbClcclxuICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEl0J3MgdGhlIGxhc3QgYml0IG9mIHRoZSBodWxsLCBzZWFyY2ggb24gYW5kIGV4aXQgYXQgbmV4dCBmb3VuZCB2ZXJ0ZXguXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVuZE9mSHVsbCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVuZE9mSHVsbEFyZWEuQWRkUmFuZ2UoaHVsbEFyZWEpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gV2UgZG9uJ3Qgd2FudCB0aGUgbGFzdCB2ZXJ0ZXggdG8gYmUgdGhlIHNhbWUgYXMgdGhlIGZpcnN0IG9uZSwgYmVjYXVzZSBpdCBjYXVzZXMgdGhlIHRyaWFuZ3VsYXRpb24gY29kZSB0byBjcmFzaC5cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVuZE9mSHVsbEFyZWEuQ29udGFpbnMoZW50cmFuY2UpKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZW5kT2ZIdWxsQXJlYS5SZW1vdmUoZW50cmFuY2UpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICB9IHdoaWxlICh0cnVlKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuIHBvbHlnb247XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwcml2YXRlIGJvb2wgU2VhcmNoTmVhclBpeGVscyhib29sIHNlYXJjaGluZ0ZvclNvbGlkUGl4ZWwsIHJlZiBWZWN0b3IyIGN1cnJlbnQsIG91dCBWZWN0b3IyIGZvdW5kUGl4ZWwpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBmb3IgKGludCBpID0gMDsgaSA8IF9DTE9TRVBJWEVMU19MRU5HVEg7IGkrKylcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgaW50IHggPSAoaW50KWN1cnJlbnQuWCArIENsb3NlUGl4ZWxzW2ksIDBdO1xyXG4gICAgICAgICAgICAgICAgaW50IHkgPSAoaW50KWN1cnJlbnQuWSArIENsb3NlUGl4ZWxzW2ksIDFdO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmICghc2VhcmNoaW5nRm9yU29saWRQaXhlbCBeIElzU29saWQocmVmIHgsIHJlZiB5KSlcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBmb3VuZFBpeGVsID0gbmV3IFZlY3RvcjIoeCwgeSk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIE5vdGhpbmcgZm91bmQuXHJcbiAgICAgICAgICAgIGZvdW5kUGl4ZWwgPSBWZWN0b3IyLlplcm87XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHByaXZhdGUgYm9vbCBJc05lYXJQaXhlbChyZWYgVmVjdG9yMiBjdXJyZW50LCByZWYgVmVjdG9yMiBuZWFyKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgZm9yIChpbnQgaSA9IDA7IGkgPCBfQ0xPU0VQSVhFTFNfTEVOR1RIOyBpKyspXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGludCB4ID0gKGludCljdXJyZW50LlggKyBDbG9zZVBpeGVsc1tpLCAwXTtcclxuICAgICAgICAgICAgICAgIGludCB5ID0gKGludCljdXJyZW50LlkgKyBDbG9zZVBpeGVsc1tpLCAxXTtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoeCA+PSAwICYmIHggPD0gX3dpZHRoICYmIHkgPj0gMCAmJiB5IDw9IF9oZWlnaHQpXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHggPT0gKGludCluZWFyLlggJiYgeSA9PSAoaW50KW5lYXIuWSlcclxuICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHJpdmF0ZSBib29sIFNlYXJjaEh1bGxFbnRyYW5jZShvdXQgVmVjdG9yMiBlbnRyYW5jZSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIC8vIFNlYXJjaCBmb3IgZmlyc3Qgc29saWQgcGl4ZWwuXHJcbiAgICAgICAgICAgIGZvciAoaW50IHkgPSAwOyB5IDw9IF9oZWlnaHQ7IHkrKylcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgZm9yIChpbnQgeCA9IDA7IHggPD0gX3dpZHRoOyB4KyspXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKElzU29saWQocmVmIHgsIHJlZiB5KSlcclxuICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVudHJhbmNlID0gbmV3IFZlY3RvcjIoeCwgeSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gSWYgdGhlcmUgYXJlIG5vIHNvbGlkIHBpeGVscy5cclxuICAgICAgICAgICAgZW50cmFuY2UgPSBWZWN0b3IyLlplcm87XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gU2VhcmNoZXMgZm9yIHRoZSBuZXh0IHNoYXBlLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwiZGV0ZWN0ZWRQb2x5Z29uc1wiPkFscmVhZHkgZGV0ZWN0ZWQgcG9seWdvbnMuPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJzdGFydFwiPlNlYXJjaCBzdGFydCBjb29yZGluYXRlLjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwiZW50cmFuY2VcIj5SZXR1cm5zIHRoZSBmb3VuZCBlbnRyYW5jZSBjb29yZGluYXRlLiBOdWxsIGlmIG5vIG90aGVyIHNoYXBlcyBmb3VuZC48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cmV0dXJucz5UcnVlIGlmIGEgbmV3IHNoYXBlIHdhcyBmb3VuZC48L3JldHVybnM+XHJcbiAgICAgICAgcHJpdmF0ZSBib29sIFNlYXJjaE5leHRIdWxsRW50cmFuY2UoTGlzdDxEZXRlY3RlZFZlcnRpY2VzPiBkZXRlY3RlZFBvbHlnb25zLCBWZWN0b3IyIHN0YXJ0LCBvdXQgVmVjdG9yMj8gZW50cmFuY2UpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBpbnQgeDtcclxuXHJcbiAgICAgICAgICAgIGJvb2wgZm91bmRUcmFuc3BhcmVudCA9IGZhbHNlO1xyXG4gICAgICAgICAgICBib29sIGluUG9seWdvbiA9IGZhbHNlO1xyXG5cclxuICAgICAgICAgICAgZm9yIChpbnQgaSA9IChpbnQpc3RhcnQuWCArIChpbnQpc3RhcnQuWSAqIF93aWR0aDsgaSA8PSBfZGF0YUxlbmd0aDsgaSsrKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBpZiAoSXNTb2xpZChyZWYgaSkpXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGZvdW5kVHJhbnNwYXJlbnQpXHJcbiAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB4ID0gaSAlIF93aWR0aDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZW50cmFuY2UgPSBuZXcgVmVjdG9yMih4LCAoaSAtIHgpIC8gKGZsb2F0KV93aWR0aCk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpblBvbHlnb24gPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChpbnQgcG9seWdvbklkeCA9IDA7IHBvbHlnb25JZHggPCBkZXRlY3RlZFBvbHlnb25zLkNvdW50OyBwb2x5Z29uSWR4KyspXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChJblBvbHlnb24oZGV0ZWN0ZWRQb2x5Z29uc1twb2x5Z29uSWR4XSwgZW50cmFuY2UuVmFsdWUpKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluUG9seWdvbiA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpblBvbHlnb24pXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3VuZFRyYW5zcGFyZW50ID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgICAgICBmb3VuZFRyYW5zcGFyZW50ID0gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgZW50cmFuY2UgPSBudWxsO1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwcml2YXRlIGJvb2wgR2V0TmV4dEh1bGxQb2ludChyZWYgVmVjdG9yMiBsYXN0LCByZWYgVmVjdG9yMiBjdXJyZW50LCBvdXQgVmVjdG9yMiBuZXh0KVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgaW50IHg7XHJcbiAgICAgICAgICAgIGludCB5O1xyXG5cclxuICAgICAgICAgICAgaW50IGluZGV4T2ZGaXJzdFBpeGVsVG9DaGVjayA9IEdldEluZGV4T2ZGaXJzdFBpeGVsVG9DaGVjayhyZWYgbGFzdCwgcmVmIGN1cnJlbnQpO1xyXG4gICAgICAgICAgICBpbnQgaW5kZXhPZlBpeGVsVG9DaGVjaztcclxuXHJcbiAgICAgICAgICAgIGZvciAoaW50IGkgPSAwOyBpIDwgX0NMT1NFUElYRUxTX0xFTkdUSDsgaSsrKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBpbmRleE9mUGl4ZWxUb0NoZWNrID0gKGluZGV4T2ZGaXJzdFBpeGVsVG9DaGVjayArIGkpICUgX0NMT1NFUElYRUxTX0xFTkdUSDtcclxuXHJcbiAgICAgICAgICAgICAgICB4ID0gKGludCljdXJyZW50LlggKyBDbG9zZVBpeGVsc1tpbmRleE9mUGl4ZWxUb0NoZWNrLCAwXTtcclxuICAgICAgICAgICAgICAgIHkgPSAoaW50KWN1cnJlbnQuWSArIENsb3NlUGl4ZWxzW2luZGV4T2ZQaXhlbFRvQ2hlY2ssIDFdO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmICh4ID49IDAgJiYgeCA8IF93aWR0aCAmJiB5ID49IDAgJiYgeSA8PSBfaGVpZ2h0KVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChJc1NvbGlkKHJlZiB4LCByZWYgeSkpXHJcbiAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXh0ID0gbmV3IFZlY3RvcjIoeCwgeSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgbmV4dCA9IFZlY3RvcjIuWmVybztcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHJpdmF0ZSBib29sIFNlYXJjaEZvck91dHN0YW5kaW5nVmVydGV4KFZlcnRpY2VzIGh1bGxBcmVhLCBvdXQgVmVjdG9yMiBvdXRzdGFuZGluZylcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIFZlY3RvcjIgb3V0c3RhbmRpbmdSZXN1bHQgPSBWZWN0b3IyLlplcm87XHJcbiAgICAgICAgICAgIGJvb2wgZm91bmQgPSBmYWxzZTtcclxuXHJcbiAgICAgICAgICAgIGlmIChodWxsQXJlYS5Db3VudCA+IDIpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGludCBodWxsQXJlYUxhc3RQb2ludCA9IGh1bGxBcmVhLkNvdW50IC0gMTtcclxuXHJcbiAgICAgICAgICAgICAgICBWZWN0b3IyIHRlbXBWZWN0b3IxO1xyXG4gICAgICAgICAgICAgICAgVmVjdG9yMiB0ZW1wVmVjdG9yMiA9IGh1bGxBcmVhWzBdO1xyXG4gICAgICAgICAgICAgICAgVmVjdG9yMiB0ZW1wVmVjdG9yMyA9IGh1bGxBcmVhW2h1bGxBcmVhTGFzdFBvaW50XTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBTZWFyY2ggYmV0d2VlbiB0aGUgZmlyc3QgYW5kIGxhc3QgaHVsbCBwb2ludC5cclxuICAgICAgICAgICAgICAgIGZvciAoaW50IGkgPSAxOyBpIDwgaHVsbEFyZWFMYXN0UG9pbnQ7IGkrKylcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICB0ZW1wVmVjdG9yMSA9IGh1bGxBcmVhW2ldO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBDaGVjayBpZiB0aGUgZGlzdGFuY2UgaXMgb3ZlciB0aGUgb25lIHRoYXQncyB0b2xlcmFibGUuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKExpbmVUb29scy5EaXN0YW5jZUJldHdlZW5Qb2ludEFuZExpbmVTZWdtZW50KHJlZiB0ZW1wVmVjdG9yMSwgcmVmIHRlbXBWZWN0b3IyLCByZWYgdGVtcFZlY3RvcjMpID49IF9odWxsVG9sZXJhbmNlKVxyXG4gICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgb3V0c3RhbmRpbmdSZXN1bHQgPSBodWxsQXJlYVtpXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZm91bmQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIG91dHN0YW5kaW5nID0gb3V0c3RhbmRpbmdSZXN1bHQ7XHJcbiAgICAgICAgICAgIHJldHVybiBmb3VuZDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHByaXZhdGUgaW50IEdldEluZGV4T2ZGaXJzdFBpeGVsVG9DaGVjayhyZWYgVmVjdG9yMiBsYXN0LCByZWYgVmVjdG9yMiBjdXJyZW50KVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgLy8gLjogcGl4ZWxcclxuICAgICAgICAgICAgLy8gbDogbGFzdCBwb3NpdGlvblxyXG4gICAgICAgICAgICAvLyBjOiBjdXJyZW50IHBvc2l0aW9uXHJcbiAgICAgICAgICAgIC8vIGY6IGZpcnN0IHBpeGVsIGZvciBuZXh0IHNlYXJjaFxyXG5cclxuICAgICAgICAgICAgLy8gZiAuIC5cclxuICAgICAgICAgICAgLy8gbCBjIC5cclxuICAgICAgICAgICAgLy8gLiAuIC5cclxuXHJcbiAgICAgICAgICAgIC8vQ2FsY3VsYXRlIGluIHdoaWNoIGRpcmVjdGlvbiB0aGUgbGFzdCBtb3ZlIHdlbnQgYW5kIGRlY2lkZSBvdmVyIHRoZSBuZXh0IHBpeGVsIHRvIGNoZWNrLlxyXG4gICAgICAgICAgICBzd2l0Y2ggKChpbnQpKGN1cnJlbnQuWCAtIGxhc3QuWCkpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGNhc2UgMTpcclxuICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKChpbnQpKGN1cnJlbnQuWSAtIGxhc3QuWSkpXHJcbiAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gMTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAwO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAtMTpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiA3O1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgICAgICAgICBjYXNlIDA6XHJcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoICgoaW50KShjdXJyZW50LlkgLSBsYXN0LlkpKVxyXG4gICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDI7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIC0xOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDY7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICAgICAgICAgIGNhc2UgLTE6XHJcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoICgoaW50KShjdXJyZW50LlkgLSBsYXN0LlkpKVxyXG4gICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDM7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gNDtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgLTE6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gNTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHJldHVybiAwO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufSIsInVzaW5nIFN5c3RlbTtcclxudXNpbmcgRmFyc2VlclBoeXNpY3MuRHluYW1pY3M7XHJcblxyXG5uYW1lc3BhY2UgRmFyc2VlclBoeXNpY3MuQ29udHJvbGxlcnNcclxue1xyXG4gICAgW0ZsYWdzXVxyXG4gICAgcHVibGljIGVudW0gQ29udHJvbGxlclR5cGVcclxuICAgIHtcclxuICAgICAgICBHcmF2aXR5Q29udHJvbGxlciA9ICgxIDw8IDApLFxyXG4gICAgICAgIFZlbG9jaXR5TGltaXRDb250cm9sbGVyID0gKDEgPDwgMSksXHJcbiAgICAgICAgQWJzdHJhY3RGb3JjZUNvbnRyb2xsZXIgPSAoMSA8PCAyKSxcclxuICAgICAgICBCdW95YW5jeUNvbnRyb2xsZXIgPSAoMSA8PCAzKSxcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgc3RydWN0IENvbnRyb2xsZXJGaWx0ZXJcclxuICAgIHtcclxuICAgICAgICBwdWJsaWMgQ29udHJvbGxlclR5cGUgQ29udHJvbGxlckZsYWdzO1xyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIElnbm9yZXMgdGhlIGNvbnRyb2xsZXIuIFRoZSBjb250cm9sbGVyIGhhcyBubyBlZmZlY3Qgb24gdGhpcyBib2R5LlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwiY29udHJvbGxlclwiPlRoZSBjb250cm9sbGVyIHR5cGUuPC9wYXJhbT5cclxuICAgICAgICBwdWJsaWMgdm9pZCBJZ25vcmVDb250cm9sbGVyKENvbnRyb2xsZXJUeXBlIGNvbnRyb2xsZXIpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBDb250cm9sbGVyRmxhZ3MgfD0gY29udHJvbGxlcjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gUmVzdG9yZSB0aGUgY29udHJvbGxlci4gVGhlIGNvbnRyb2xsZXIgYWZmZWN0cyB0aGlzIGJvZHkuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJjb250cm9sbGVyXCI+VGhlIGNvbnRyb2xsZXIgdHlwZS48L3BhcmFtPlxyXG4gICAgICAgIHB1YmxpYyB2b2lkIFJlc3RvcmVDb250cm9sbGVyKENvbnRyb2xsZXJUeXBlIGNvbnRyb2xsZXIpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBDb250cm9sbGVyRmxhZ3MgJj0gfmNvbnRyb2xsZXI7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIERldGVybWluZXMgd2hldGhlciB0aGlzIGJvZHkgaWdub3JlcyB0aGUgdGhlIHNwZWNpZmllZCBjb250cm9sbGVyLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwiY29udHJvbGxlclwiPlRoZSBjb250cm9sbGVyIHR5cGUuPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHJldHVybnM+XHJcbiAgICAgICAgLy8vIFx0PGM+dHJ1ZTwvYz4gaWYgdGhlIGJvZHkgaGFzIHRoZSBzcGVjaWZpZWQgZmxhZzsgb3RoZXJ3aXNlLCA8Yz5mYWxzZTwvYz4uXHJcbiAgICAgICAgLy8vIDwvcmV0dXJucz5cclxuICAgICAgICBwdWJsaWMgYm9vbCBJc0NvbnRyb2xsZXJJZ25vcmVkKENvbnRyb2xsZXJUeXBlIGNvbnRyb2xsZXIpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gKENvbnRyb2xsZXJGbGFncyAmIGNvbnRyb2xsZXIpID09IGNvbnRyb2xsZXI7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBhYnN0cmFjdCBjbGFzcyBDb250cm9sbGVyIDogRmlsdGVyRGF0YVxyXG4gICAge1xyXG4gICAgICAgIHB1YmxpYyBib29sIEVuYWJsZWQ7XHJcbiAgICAgICAgcHVibGljIFdvcmxkIFdvcmxkO1xyXG4gICAgICAgIHByaXZhdGUgQ29udHJvbGxlclR5cGUgX3R5cGU7XHJcblxyXG4gICAgICAgIHB1YmxpYyBDb250cm9sbGVyKENvbnRyb2xsZXJUeXBlIGNvbnRyb2xsZXJUeXBlKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgX3R5cGUgPSBjb250cm9sbGVyVHlwZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHB1YmxpYyBvdmVycmlkZSBib29sIElzQWN0aXZlT24oQm9keSBib2R5KVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgaWYgKGJvZHkuQ29udHJvbGxlckZpbHRlci5Jc0NvbnRyb2xsZXJJZ25vcmVkKF90eXBlKSlcclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiBiYXNlLklzQWN0aXZlT24oYm9keSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwdWJsaWMgYWJzdHJhY3Qgdm9pZCBVcGRhdGUoZmxvYXQgZHQpO1xyXG4gICAgfVxyXG59IiwiLypcclxuKiBGYXJzZWVyIFBoeXNpY3MgRW5naW5lIGJhc2VkIG9uIEJveDJELlhOQSBwb3J0OlxyXG4qIENvcHlyaWdodCAoYykgMjAxMCBJYW4gUXZpc3RcclxuKiBcclxuKiBCb3gyRC5YTkEgcG9ydCBvZiBCb3gyRDpcclxuKiBDb3B5cmlnaHQgKGMpIDIwMDkgQnJhbmRvbiBGdXJ0d2FuZ2xlciwgTmF0aGFuIEZ1cnR3YW5nbGVyXHJcbipcclxuKiBPcmlnaW5hbCBzb3VyY2UgQm94MkQ6XHJcbiogQ29weXJpZ2h0IChjKSAyMDA2LTIwMDkgRXJpbiBDYXR0byBodHRwOi8vd3d3LmdwaHlzaWNzLmNvbSBcclxuKiBcclxuKiBUaGlzIHNvZnR3YXJlIGlzIHByb3ZpZGVkICdhcy1pcycsIHdpdGhvdXQgYW55IGV4cHJlc3Mgb3IgaW1wbGllZCBcclxuKiB3YXJyYW50eS4gIEluIG5vIGV2ZW50IHdpbGwgdGhlIGF1dGhvcnMgYmUgaGVsZCBsaWFibGUgZm9yIGFueSBkYW1hZ2VzIFxyXG4qIGFyaXNpbmcgZnJvbSB0aGUgdXNlIG9mIHRoaXMgc29mdHdhcmUuIFxyXG4qIFBlcm1pc3Npb24gaXMgZ3JhbnRlZCB0byBhbnlvbmUgdG8gdXNlIHRoaXMgc29mdHdhcmUgZm9yIGFueSBwdXJwb3NlLCBcclxuKiBpbmNsdWRpbmcgY29tbWVyY2lhbCBhcHBsaWNhdGlvbnMsIGFuZCB0byBhbHRlciBpdCBhbmQgcmVkaXN0cmlidXRlIGl0IFxyXG4qIGZyZWVseSwgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIHJlc3RyaWN0aW9uczogXHJcbiogMS4gVGhlIG9yaWdpbiBvZiB0aGlzIHNvZnR3YXJlIG11c3Qgbm90IGJlIG1pc3JlcHJlc2VudGVkOyB5b3UgbXVzdCBub3QgXHJcbiogY2xhaW0gdGhhdCB5b3Ugd3JvdGUgdGhlIG9yaWdpbmFsIHNvZnR3YXJlLiBJZiB5b3UgdXNlIHRoaXMgc29mdHdhcmUgXHJcbiogaW4gYSBwcm9kdWN0LCBhbiBhY2tub3dsZWRnbWVudCBpbiB0aGUgcHJvZHVjdCBkb2N1bWVudGF0aW9uIHdvdWxkIGJlIFxyXG4qIGFwcHJlY2lhdGVkIGJ1dCBpcyBub3QgcmVxdWlyZWQuIFxyXG4qIDIuIEFsdGVyZWQgc291cmNlIHZlcnNpb25zIG11c3QgYmUgcGxhaW5seSBtYXJrZWQgYXMgc3VjaCwgYW5kIG11c3Qgbm90IGJlIFxyXG4qIG1pc3JlcHJlc2VudGVkIGFzIGJlaW5nIHRoZSBvcmlnaW5hbCBzb2Z0d2FyZS4gXHJcbiogMy4gVGhpcyBub3RpY2UgbWF5IG5vdCBiZSByZW1vdmVkIG9yIGFsdGVyZWQgZnJvbSBhbnkgc291cmNlIGRpc3RyaWJ1dGlvbi4gXHJcbiovXHJcblxyXG51c2luZyBTeXN0ZW07XHJcbnVzaW5nIEZhcnNlZXJQaHlzaWNzLkNvbW1vbjtcclxudXNpbmcgRmFyc2VlclBoeXNpY3MuRHluYW1pY3M7XHJcbnVzaW5nIE1pY3Jvc29mdC5YbmEuRnJhbWV3b3JrO1xyXG5cclxubmFtZXNwYWNlIEZhcnNlZXJQaHlzaWNzXHJcbntcclxuICAgIFtGbGFnc11cclxuICAgIHB1YmxpYyBlbnVtIERlYnVnVmlld0ZsYWdzXHJcbiAgICB7XHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBEcmF3IHNoYXBlcy5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIFNoYXBlID0gKDEgPDwgMCksXHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gRHJhdyBqb2ludCBjb25uZWN0aW9ucy5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIEpvaW50ID0gKDEgPDwgMSksXHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gRHJhdyBheGlzIGFsaWduZWQgYm91bmRpbmcgYm94ZXMuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICBBQUJCID0gKDEgPDwgMiksXHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gRHJhdyBicm9hZC1waGFzZSBwYWlycy5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIFBhaXIgPSAoMSA8PCAzKSxcclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBEcmF3IGNlbnRlciBvZiBtYXNzIGZyYW1lLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgQ2VudGVyT2ZNYXNzID0gKDEgPDwgNCksXHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gRHJhdyB1c2VmdWwgZGVidWcgZGF0YSBzdWNoIGFzIHRpbWluZ3MgYW5kIG51bWJlciBvZiBib2RpZXMsIGpvaW50cywgY29udGFjdHMgYW5kIG1vcmUuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICBEZWJ1Z1BhbmVsID0gKDEgPDwgNSksXHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gRHJhdyBjb250YWN0IHBvaW50cyBiZXR3ZWVuIGNvbGxpZGluZyBib2RpZXMuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICBDb250YWN0UG9pbnRzID0gKDEgPDwgNiksXHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gRHJhdyBjb250YWN0IG5vcm1hbHMuIE5lZWQgQ29udGFjdFBvaW50cyB0byBiZSBlbmFibGVkIGZpcnN0LlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgQ29udGFjdE5vcm1hbHMgPSAoMSA8PCA3KSxcclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBEcmF3cyB0aGUgdmVydGljZXMgb2YgcG9seWdvbnMuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICBQb2x5Z29uUG9pbnRzID0gKDEgPDwgOCksXHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gRHJhd3MgdGhlIHBlcmZvcm1hbmNlIGdyYXBoLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgUGVyZm9ybWFuY2VHcmFwaCA9ICgxIDw8IDkpLFxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIERyYXdzIGNvbnRyb2xsZXJzLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgQ29udHJvbGxlcnMgPSAoMSA8PCAxMClcclxuICAgIH1cclxuXHJcbiAgICAvLy8gSW1wbGVtZW50IGFuZCByZWdpc3RlciB0aGlzIGNsYXNzIHdpdGggYSBXb3JsZCB0byBwcm92aWRlIGRlYnVnIGRyYXdpbmcgb2YgcGh5c2ljc1xyXG4gICAgLy8vIGVudGl0aWVzIGluIHlvdXIgZ2FtZS5cclxuICAgIHB1YmxpYyBhYnN0cmFjdCBjbGFzcyBEZWJ1Z1ZpZXdcclxuICAgIHtcclxuICAgICAgICBwcm90ZWN0ZWQgRGVidWdWaWV3KFdvcmxkIHdvcmxkKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgV29ybGQgPSB3b3JsZDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHByb3RlY3RlZCBXb3JsZCBXb3JsZCB7IGdldDsgcHJpdmF0ZSBzZXQ7IH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBHZXRzIG9yIHNldHMgdGhlIGRlYnVnIHZpZXcgZmxhZ3MuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHZhbHVlPlRoZSBmbGFncy48L3ZhbHVlPlxyXG4gICAgICAgIHB1YmxpYyBEZWJ1Z1ZpZXdGbGFncyBGbGFncyB7IGdldDsgc2V0OyB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gQXBwZW5kIGZsYWdzIHRvIHRoZSBjdXJyZW50IGZsYWdzLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwiZmxhZ3NcIj5UaGUgZmxhZ3MuPC9wYXJhbT5cclxuICAgICAgICBwdWJsaWMgdm9pZCBBcHBlbmRGbGFncyhEZWJ1Z1ZpZXdGbGFncyBmbGFncylcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIEZsYWdzIHw9IGZsYWdzO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBSZW1vdmUgZmxhZ3MgZnJvbSB0aGUgY3VycmVudCBmbGFncy5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cImZsYWdzXCI+VGhlIGZsYWdzLjwvcGFyYW0+XHJcbiAgICAgICAgcHVibGljIHZvaWQgUmVtb3ZlRmxhZ3MoRGVidWdWaWV3RmxhZ3MgZmxhZ3MpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBGbGFncyAmPSB+ZmxhZ3M7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIERyYXcgYSBjbG9zZWQgcG9seWdvbiBwcm92aWRlZCBpbiBDQ1cgb3JkZXIuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJ2ZXJ0aWNlc1wiPlRoZSB2ZXJ0aWNlcy48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cImNvdW50XCI+VGhlIHZlcnRleCBjb3VudC48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cInJlZFwiPlRoZSByZWQgdmFsdWUuPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJibHVlXCI+VGhlIGJsdWUgdmFsdWUuPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJncmVlblwiPlRoZSBncmVlbiB2YWx1ZS48L3BhcmFtPlxyXG4gICAgICAgIHB1YmxpYyBhYnN0cmFjdCB2b2lkIERyYXdQb2x5Z29uKFZlY3RvcjJbXSB2ZXJ0aWNlcywgaW50IGNvdW50LCBmbG9hdCByZWQsIGZsb2F0IGJsdWUsIGZsb2F0IGdyZWVuKTtcclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBEcmF3IGEgc29saWQgY2xvc2VkIHBvbHlnb24gcHJvdmlkZWQgaW4gQ0NXIG9yZGVyLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwidmVydGljZXNcIj5UaGUgdmVydGljZXMuPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJjb3VudFwiPlRoZSB2ZXJ0ZXggY291bnQuPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJyZWRcIj5UaGUgcmVkIHZhbHVlLjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwiYmx1ZVwiPlRoZSBibHVlIHZhbHVlLjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwiZ3JlZW5cIj5UaGUgZ3JlZW4gdmFsdWUuPC9wYXJhbT5cclxuICAgICAgICBwdWJsaWMgYWJzdHJhY3Qgdm9pZCBEcmF3U29saWRQb2x5Z29uKFZlY3RvcjJbXSB2ZXJ0aWNlcywgaW50IGNvdW50LCBmbG9hdCByZWQsIGZsb2F0IGJsdWUsIGZsb2F0IGdyZWVuKTtcclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBEcmF3IGEgY2lyY2xlLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwiY2VudGVyXCI+VGhlIGNlbnRlci48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cInJhZGl1c1wiPlRoZSByYWRpdXMuPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJyZWRcIj5UaGUgcmVkIHZhbHVlLjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwiYmx1ZVwiPlRoZSBibHVlIHZhbHVlLjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwiZ3JlZW5cIj5UaGUgZ3JlZW4gdmFsdWUuPC9wYXJhbT5cclxuICAgICAgICBwdWJsaWMgYWJzdHJhY3Qgdm9pZCBEcmF3Q2lyY2xlKFZlY3RvcjIgY2VudGVyLCBmbG9hdCByYWRpdXMsIGZsb2F0IHJlZCwgZmxvYXQgYmx1ZSwgZmxvYXQgZ3JlZW4pO1xyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIERyYXcgYSBzb2xpZCBjaXJjbGUuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJjZW50ZXJcIj5UaGUgY2VudGVyLjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwicmFkaXVzXCI+VGhlIHJhZGl1cy48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cImF4aXNcIj5UaGUgYXhpcy48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cInJlZFwiPlRoZSByZWQgdmFsdWUuPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJibHVlXCI+VGhlIGJsdWUgdmFsdWUuPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJncmVlblwiPlRoZSBncmVlbiB2YWx1ZS48L3BhcmFtPlxyXG4gICAgICAgIHB1YmxpYyBhYnN0cmFjdCB2b2lkIERyYXdTb2xpZENpcmNsZShWZWN0b3IyIGNlbnRlciwgZmxvYXQgcmFkaXVzLCBWZWN0b3IyIGF4aXMsIGZsb2F0IHJlZCwgZmxvYXQgYmx1ZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmxvYXQgZ3JlZW4pO1xyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIERyYXcgYSBsaW5lIHNlZ21lbnQuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJzdGFydFwiPlRoZSBzdGFydC48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cImVuZFwiPlRoZSBlbmQuPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJyZWRcIj5UaGUgcmVkIHZhbHVlLjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwiYmx1ZVwiPlRoZSBibHVlIHZhbHVlLjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwiZ3JlZW5cIj5UaGUgZ3JlZW4gdmFsdWUuPC9wYXJhbT5cclxuICAgICAgICBwdWJsaWMgYWJzdHJhY3Qgdm9pZCBEcmF3U2VnbWVudChWZWN0b3IyIHN0YXJ0LCBWZWN0b3IyIGVuZCwgZmxvYXQgcmVkLCBmbG9hdCBibHVlLCBmbG9hdCBncmVlbik7XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gRHJhdyBhIHRyYW5zZm9ybS4gQ2hvb3NlIHlvdXIgb3duIGxlbmd0aCBzY2FsZS5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cInRyYW5zZm9ybVwiPlRoZSB0cmFuc2Zvcm0uPC9wYXJhbT5cclxuICAgICAgICBwdWJsaWMgYWJzdHJhY3Qgdm9pZCBEcmF3VHJhbnNmb3JtKHJlZiBUcmFuc2Zvcm0gdHJhbnNmb3JtKTtcclxuICAgIH1cclxufSIsIi8qXHJcbiogRmFyc2VlciBQaHlzaWNzIEVuZ2luZSBiYXNlZCBvbiBCb3gyRC5YTkEgcG9ydDpcclxuKiBDb3B5cmlnaHQgKGMpIDIwMTAgSWFuIFF2aXN0XHJcbiogXHJcbiogQm94MkQuWE5BIHBvcnQgb2YgQm94MkQ6XHJcbiogQ29weXJpZ2h0IChjKSAyMDA5IEJyYW5kb24gRnVydHdhbmdsZXIsIE5hdGhhbiBGdXJ0d2FuZ2xlclxyXG4qXHJcbiogT3JpZ2luYWwgc291cmNlIEJveDJEOlxyXG4qIENvcHlyaWdodCAoYykgMjAwNi0yMDA5IEVyaW4gQ2F0dG8gaHR0cDovL3d3dy5ncGh5c2ljcy5jb20gXHJcbiogXHJcbiogVGhpcyBzb2Z0d2FyZSBpcyBwcm92aWRlZCAnYXMtaXMnLCB3aXRob3V0IGFueSBleHByZXNzIG9yIGltcGxpZWQgXHJcbiogd2FycmFudHkuICBJbiBubyBldmVudCB3aWxsIHRoZSBhdXRob3JzIGJlIGhlbGQgbGlhYmxlIGZvciBhbnkgZGFtYWdlcyBcclxuKiBhcmlzaW5nIGZyb20gdGhlIHVzZSBvZiB0aGlzIHNvZnR3YXJlLiBcclxuKiBQZXJtaXNzaW9uIGlzIGdyYW50ZWQgdG8gYW55b25lIHRvIHVzZSB0aGlzIHNvZnR3YXJlIGZvciBhbnkgcHVycG9zZSwgXHJcbiogaW5jbHVkaW5nIGNvbW1lcmNpYWwgYXBwbGljYXRpb25zLCBhbmQgdG8gYWx0ZXIgaXQgYW5kIHJlZGlzdHJpYnV0ZSBpdCBcclxuKiBmcmVlbHksIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyByZXN0cmljdGlvbnM6IFxyXG4qIDEuIFRoZSBvcmlnaW4gb2YgdGhpcyBzb2Z0d2FyZSBtdXN0IG5vdCBiZSBtaXNyZXByZXNlbnRlZDsgeW91IG11c3Qgbm90IFxyXG4qIGNsYWltIHRoYXQgeW91IHdyb3RlIHRoZSBvcmlnaW5hbCBzb2Z0d2FyZS4gSWYgeW91IHVzZSB0aGlzIHNvZnR3YXJlIFxyXG4qIGluIGEgcHJvZHVjdCwgYW4gYWNrbm93bGVkZ21lbnQgaW4gdGhlIHByb2R1Y3QgZG9jdW1lbnRhdGlvbiB3b3VsZCBiZSBcclxuKiBhcHByZWNpYXRlZCBidXQgaXMgbm90IHJlcXVpcmVkLiBcclxuKiAyLiBBbHRlcmVkIHNvdXJjZSB2ZXJzaW9ucyBtdXN0IGJlIHBsYWlubHkgbWFya2VkIGFzIHN1Y2gsIGFuZCBtdXN0IG5vdCBiZSBcclxuKiBtaXNyZXByZXNlbnRlZCBhcyBiZWluZyB0aGUgb3JpZ2luYWwgc29mdHdhcmUuIFxyXG4qIDMuIFRoaXMgbm90aWNlIG1heSBub3QgYmUgcmVtb3ZlZCBvciBhbHRlcmVkIGZyb20gYW55IHNvdXJjZSBkaXN0cmlidXRpb24uIFxyXG4qL1xyXG5cclxudXNpbmcgU3lzdGVtO1xyXG51c2luZyBTeXN0ZW0uQ29sbGVjdGlvbnMuR2VuZXJpYztcclxudXNpbmcgU3lzdGVtLkRpYWdub3N0aWNzO1xyXG51c2luZyBGYXJzZWVyUGh5c2ljcy5Db2xsaXNpb247XHJcbnVzaW5nIEZhcnNlZXJQaHlzaWNzLkNvbGxpc2lvbi5TaGFwZXM7XHJcbnVzaW5nIEZhcnNlZXJQaHlzaWNzLkNvbW1vbjtcclxudXNpbmcgRmFyc2VlclBoeXNpY3MuQ29tbW9uLlBoeXNpY3NMb2dpYztcclxudXNpbmcgRmFyc2VlclBoeXNpY3MuQ29udHJvbGxlcnM7XHJcbnVzaW5nIEZhcnNlZXJQaHlzaWNzLkR5bmFtaWNzLkNvbnRhY3RzO1xyXG51c2luZyBGYXJzZWVyUGh5c2ljcy5EeW5hbWljcy5Kb2ludHM7XHJcbnVzaW5nIE1pY3Jvc29mdC5YbmEuRnJhbWV3b3JrO1xyXG5cclxubmFtZXNwYWNlIEZhcnNlZXJQaHlzaWNzLkR5bmFtaWNzXHJcbntcclxuICAgIC8vLyA8c3VtbWFyeT5cclxuICAgIC8vLyBUaGUgYm9keSB0eXBlLlxyXG4gICAgLy8vIDwvc3VtbWFyeT5cclxuICAgIHB1YmxpYyBlbnVtIEJvZHlUeXBlXHJcbiAgICB7XHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBaZXJvIHZlbG9jaXR5LCBtYXkgYmUgbWFudWFsbHkgbW92ZWQuIE5vdGU6IGV2ZW4gc3RhdGljIGJvZGllcyBoYXZlIG1hc3MuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICBTdGF0aWMsXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBaZXJvIG1hc3MsIG5vbi16ZXJvIHZlbG9jaXR5IHNldCBieSB1c2VyLCBtb3ZlZCBieSBzb2x2ZXJcclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIEtpbmVtYXRpYyxcclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIFBvc2l0aXZlIG1hc3MsIG5vbi16ZXJvIHZlbG9jaXR5IGRldGVybWluZWQgYnkgZm9yY2VzLCBtb3ZlZCBieSBzb2x2ZXJcclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIER5bmFtaWMsXHJcbiAgICB9XHJcblxyXG4gICAgW0ZsYWdzXVxyXG4gICAgcHVibGljIGVudW0gQm9keUZsYWdzXHJcbiAgICB7XHJcbiAgICAgICAgTm9uZSA9IDAsXHJcbiAgICAgICAgSXNsYW5kID0gKDEgPDwgMCksXHJcbiAgICAgICAgQXdha2UgPSAoMSA8PCAxKSxcclxuICAgICAgICBBdXRvU2xlZXAgPSAoMSA8PCAyKSxcclxuICAgICAgICBCdWxsZXQgPSAoMSA8PCAzKSxcclxuICAgICAgICBGaXhlZFJvdGF0aW9uID0gKDEgPDwgNCksXHJcbiAgICAgICAgRW5hYmxlZCA9ICgxIDw8IDUpLFxyXG4gICAgICAgIElnbm9yZUdyYXZpdHkgPSAoMSA8PCA2KSxcclxuICAgICAgICBJZ25vcmVDQ0QgPSAoMSA8PCA3KSxcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgY2xhc3MgQm9keSA6IElEaXNwb3NhYmxlXHJcbiAgICB7XHJcbiAgICAgICAgcHJpdmF0ZSBzdGF0aWMgaW50IF9ib2R5SWRDb3VudGVyO1xyXG4gICAgICAgIGludGVybmFsIGZsb2F0IEFuZ3VsYXJWZWxvY2l0eUludGVybmFsO1xyXG4gICAgICAgIHB1YmxpYyBpbnQgQm9keUlkO1xyXG4gICAgICAgIHB1YmxpYyBDb250cm9sbGVyRmlsdGVyIENvbnRyb2xsZXJGaWx0ZXI7XHJcbiAgICAgICAgaW50ZXJuYWwgQm9keUZsYWdzIEZsYWdzO1xyXG4gICAgICAgIGludGVybmFsIFZlY3RvcjIgRm9yY2U7XHJcbiAgICAgICAgaW50ZXJuYWwgZmxvYXQgSW52STtcclxuICAgICAgICBpbnRlcm5hbCBmbG9hdCBJbnZNYXNzO1xyXG4gICAgICAgIGludGVybmFsIFZlY3RvcjIgTGluZWFyVmVsb2NpdHlJbnRlcm5hbDtcclxuICAgICAgICBwdWJsaWMgUGh5c2ljc0xvZ2ljRmlsdGVyIFBoeXNpY3NMb2dpY0ZpbHRlcjtcclxuICAgICAgICBpbnRlcm5hbCBmbG9hdCBTbGVlcFRpbWU7XHJcbiAgICAgICAgaW50ZXJuYWwgU3dlZXAgU3dlZXA7IC8vIHRoZSBzd2VwdCBtb3Rpb24gZm9yIENDRFxyXG4gICAgICAgIGludGVybmFsIGZsb2F0IFRvcnF1ZTtcclxuICAgICAgICBpbnRlcm5hbCBXb3JsZCBXb3JsZDtcclxuICAgICAgICBpbnRlcm5hbCBUcmFuc2Zvcm0gWGY7IC8vIHRoZSBib2R5IG9yaWdpbiB0cmFuc2Zvcm1cclxuICAgICAgICBwcml2YXRlIGZsb2F0IF9hbmd1bGFyRGFtcGluZztcclxuICAgICAgICBwcml2YXRlIEJvZHlUeXBlIF9ib2R5VHlwZTtcclxuICAgICAgICBwcml2YXRlIGZsb2F0IF9pbmVydGlhO1xyXG4gICAgICAgIHByaXZhdGUgZmxvYXQgX2xpbmVhckRhbXBpbmc7XHJcbiAgICAgICAgcHJpdmF0ZSBmbG9hdCBfbWFzcztcclxuXHJcbiAgICAgICAgaW50ZXJuYWwgQm9keSgpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBGaXh0dXJlTGlzdCA9IG5ldyBMaXN0PEZpeHR1cmU+KDMyKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHB1YmxpYyBCb2R5KFdvcmxkIHdvcmxkKVxyXG4gICAgICAgICAgICA6IHRoaXMod29ybGQsIG51bGwpXHJcbiAgICAgICAge1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHVibGljIEJvZHkoV29ybGQgd29ybGQsIG9iamVjdCB1c2VyRGF0YSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIEZpeHR1cmVMaXN0ID0gbmV3IExpc3Q8Rml4dHVyZT4oMzIpO1xyXG4gICAgICAgICAgICBCb2R5SWQgPSBfYm9keUlkQ291bnRlcisrO1xyXG5cclxuICAgICAgICAgICAgV29ybGQgPSB3b3JsZDtcclxuICAgICAgICAgICAgVXNlckRhdGEgPSB1c2VyRGF0YTtcclxuXHJcbiAgICAgICAgICAgIEZpeGVkUm90YXRpb24gPSBmYWxzZTtcclxuICAgICAgICAgICAgSXNCdWxsZXQgPSBmYWxzZTtcclxuICAgICAgICAgICAgU2xlZXBpbmdBbGxvd2VkID0gdHJ1ZTtcclxuICAgICAgICAgICAgQXdha2UgPSB0cnVlO1xyXG4gICAgICAgICAgICBCb2R5VHlwZSA9IEJvZHlUeXBlLlN0YXRpYztcclxuICAgICAgICAgICAgRW5hYmxlZCA9IHRydWU7XHJcblxyXG4gICAgICAgICAgICBYZi5SLlNldCgwKTtcclxuXHJcbiAgICAgICAgICAgIHdvcmxkLkFkZEJvZHkodGhpcyk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIEdldCBvciBzZXQgdGhpcyBib2R5IGlzIHBlbmV0cmFibGVcclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIHB1YmxpYyBib29sIFBlbmV0cmFibGUgeyBnZXQ7IHNldDsgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIEdldHMgdGhlIHRvdGFsIG51bWJlciByZXZvbHV0aW9ucyB0aGUgYm9keSBoYXMgbWFkZS5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8dmFsdWU+VGhlIHJldm9sdXRpb25zLjwvdmFsdWU+XHJcbiAgICAgICAgcHVibGljIGZsb2F0IFJldm9sdXRpb25zXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBnZXQgeyByZXR1cm4gUm90YXRpb24gLyAoZmxvYXQpTWF0aC5QSTsgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBHZXRzIG9yIHNldHMgdGhlIGJvZHkgdHlwZS5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8dmFsdWU+VGhlIHR5cGUgb2YgYm9keS48L3ZhbHVlPlxyXG4gICAgICAgIHB1YmxpYyBCb2R5VHlwZSBCb2R5VHlwZVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgZ2V0IHsgcmV0dXJuIF9ib2R5VHlwZTsgfVxyXG4gICAgICAgICAgICBzZXRcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgaWYgKF9ib2R5VHlwZSA9PSB2YWx1ZSlcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgX2JvZHlUeXBlID0gdmFsdWU7XHJcblxyXG4gICAgICAgICAgICAgICAgUmVzZXRNYXNzRGF0YSgpO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmIChfYm9keVR5cGUgPT0gQm9keVR5cGUuU3RhdGljKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIExpbmVhclZlbG9jaXR5SW50ZXJuYWwgPSBWZWN0b3IyLlplcm87XHJcbiAgICAgICAgICAgICAgICAgICAgQW5ndWxhclZlbG9jaXR5SW50ZXJuYWwgPSAwLjBmO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIEF3YWtlID0gdHJ1ZTtcclxuXHJcbiAgICAgICAgICAgICAgICBGb3JjZSA9IFZlY3RvcjIuWmVybztcclxuICAgICAgICAgICAgICAgIFRvcnF1ZSA9IDAuMGY7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gU2luY2UgdGhlIGJvZHkgdHlwZSBjaGFuZ2VkLCB3ZSBuZWVkIHRvIGZsYWcgY29udGFjdHMgZm9yIGZpbHRlcmluZy5cclxuICAgICAgICAgICAgICAgIGZvciAoaW50IGkgPSAwOyBpIDwgRml4dHVyZUxpc3QuQ291bnQ7IGkrKylcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBGaXh0dXJlIGYgPSBGaXh0dXJlTGlzdFtpXTtcclxuICAgICAgICAgICAgICAgICAgICBmLlJlZmlsdGVyKCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gR2V0IG9yIHNldHMgdGhlIGxpbmVhciB2ZWxvY2l0eSBvZiB0aGUgY2VudGVyIG9mIG1hc3MuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHZhbHVlPlRoZSBsaW5lYXIgdmVsb2NpdHkuPC92YWx1ZT5cclxuICAgICAgICBwdWJsaWMgVmVjdG9yMiBMaW5lYXJWZWxvY2l0eVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgc2V0XHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIERlYnVnLkFzc2VydCghZmxvYXQuSXNOYU4odmFsdWUuWCkgJiYgIWZsb2F0LklzTmFOKHZhbHVlLlkpKTtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoX2JvZHlUeXBlID09IEJvZHlUeXBlLlN0YXRpYylcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKFZlY3RvcjIuRG90KHZhbHVlLCB2YWx1ZSkgPiAwLjBmKVxyXG4gICAgICAgICAgICAgICAgICAgIEF3YWtlID0gdHJ1ZTtcclxuXHJcbiAgICAgICAgICAgICAgICBMaW5lYXJWZWxvY2l0eUludGVybmFsID0gdmFsdWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZ2V0IHsgcmV0dXJuIExpbmVhclZlbG9jaXR5SW50ZXJuYWw7IH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gR2V0cyBvciBzZXRzIHRoZSBhbmd1bGFyIHZlbG9jaXR5LiBSYWRpYW5zL3NlY29uZC5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8dmFsdWU+VGhlIGFuZ3VsYXIgdmVsb2NpdHkuPC92YWx1ZT5cclxuICAgICAgICBwdWJsaWMgZmxvYXQgQW5ndWxhclZlbG9jaXR5XHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBzZXRcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgRGVidWcuQXNzZXJ0KCFmbG9hdC5Jc05hTih2YWx1ZSkpO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmIChfYm9keVR5cGUgPT0gQm9keVR5cGUuU3RhdGljKVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgKiB2YWx1ZSA+IDAuMGYpXHJcbiAgICAgICAgICAgICAgICAgICAgQXdha2UgPSB0cnVlO1xyXG5cclxuICAgICAgICAgICAgICAgIEFuZ3VsYXJWZWxvY2l0eUludGVybmFsID0gdmFsdWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZ2V0IHsgcmV0dXJuIEFuZ3VsYXJWZWxvY2l0eUludGVybmFsOyB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIEdldHMgb3Igc2V0cyB0aGUgbGluZWFyIGRhbXBpbmcuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHZhbHVlPlRoZSBsaW5lYXIgZGFtcGluZy48L3ZhbHVlPlxyXG4gICAgICAgIHB1YmxpYyBmbG9hdCBMaW5lYXJEYW1waW5nXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBnZXQgeyByZXR1cm4gX2xpbmVhckRhbXBpbmc7IH1cclxuICAgICAgICAgICAgc2V0XHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIERlYnVnLkFzc2VydCghZmxvYXQuSXNOYU4odmFsdWUpKTtcclxuXHJcbiAgICAgICAgICAgICAgICBfbGluZWFyRGFtcGluZyA9IHZhbHVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIEdldHMgb3Igc2V0cyB0aGUgYW5ndWxhciBkYW1waW5nLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDx2YWx1ZT5UaGUgYW5ndWxhciBkYW1waW5nLjwvdmFsdWU+XHJcbiAgICAgICAgcHVibGljIGZsb2F0IEFuZ3VsYXJEYW1waW5nXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBnZXQgeyByZXR1cm4gX2FuZ3VsYXJEYW1waW5nOyB9XHJcbiAgICAgICAgICAgIHNldFxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBEZWJ1Zy5Bc3NlcnQoIWZsb2F0LklzTmFOKHZhbHVlKSk7XHJcblxyXG4gICAgICAgICAgICAgICAgX2FuZ3VsYXJEYW1waW5nID0gdmFsdWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gR2V0cyBvciBzZXRzIGEgdmFsdWUgaW5kaWNhdGluZyB3aGV0aGVyIHRoaXMgYm9keSBzaG91bGQgYmUgaW5jbHVkZWQgaW4gdGhlIENDRCBzb2x2ZXIuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHZhbHVlPjxjPnRydWU8L2M+IGlmIHRoaXMgaW5zdGFuY2UgaXMgaW5jbHVkZWQgaW4gQ0NEOyBvdGhlcndpc2UsIDxjPmZhbHNlPC9jPi48L3ZhbHVlPlxyXG4gICAgICAgIHB1YmxpYyBib29sIElzQnVsbGV0XHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBzZXRcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIEZsYWdzIHw9IEJvZHlGbGFncy5CdWxsZXQ7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgRmxhZ3MgJj0gfkJvZHlGbGFncy5CdWxsZXQ7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZ2V0IHsgcmV0dXJuIChGbGFncyAmIEJvZHlGbGFncy5CdWxsZXQpID09IEJvZHlGbGFncy5CdWxsZXQ7IH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gWW91IGNhbiBkaXNhYmxlIHNsZWVwaW5nIG9uIHRoaXMgYm9keS4gSWYgeW91IGRpc2FibGUgc2xlZXBpbmcsIHRoZVxyXG4gICAgICAgIC8vLyBib2R5IHdpbGwgYmUgd29rZW4uXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHZhbHVlPjxjPnRydWU8L2M+IGlmIHNsZWVwaW5nIGlzIGFsbG93ZWQ7IG90aGVyd2lzZSwgPGM+ZmFsc2U8L2M+LjwvdmFsdWU+XHJcbiAgICAgICAgcHVibGljIGJvb2wgU2xlZXBpbmdBbGxvd2VkXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBzZXRcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIEZsYWdzIHw9IEJvZHlGbGFncy5BdXRvU2xlZXA7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgRmxhZ3MgJj0gfkJvZHlGbGFncy5BdXRvU2xlZXA7XHJcbiAgICAgICAgICAgICAgICAgICAgQXdha2UgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGdldCB7IHJldHVybiAoRmxhZ3MgJiBCb2R5RmxhZ3MuQXV0b1NsZWVwKSA9PSBCb2R5RmxhZ3MuQXV0b1NsZWVwOyB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIFNldCB0aGUgc2xlZXAgc3RhdGUgb2YgdGhlIGJvZHkuIEEgc2xlZXBpbmcgYm9keSBoYXMgdmVyeVxyXG4gICAgICAgIC8vLyBsb3cgQ1BVIGNvc3QuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHZhbHVlPjxjPnRydWU8L2M+IGlmIGF3YWtlOyBvdGhlcndpc2UsIDxjPmZhbHNlPC9jPi48L3ZhbHVlPlxyXG4gICAgICAgIHB1YmxpYyBib29sIEF3YWtlXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBzZXRcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICgoRmxhZ3MgJiBCb2R5RmxhZ3MuQXdha2UpID09IDApXHJcbiAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBGbGFncyB8PSBCb2R5RmxhZ3MuQXdha2U7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIFNsZWVwVGltZSA9IDAuMGY7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIEZsYWdzICY9IH5Cb2R5RmxhZ3MuQXdha2U7XHJcbiAgICAgICAgICAgICAgICAgICAgU2xlZXBUaW1lID0gMC4wZjtcclxuICAgICAgICAgICAgICAgICAgICBMaW5lYXJWZWxvY2l0eUludGVybmFsID0gVmVjdG9yMi5aZXJvO1xyXG4gICAgICAgICAgICAgICAgICAgIEFuZ3VsYXJWZWxvY2l0eUludGVybmFsID0gMC4wZjtcclxuICAgICAgICAgICAgICAgICAgICBGb3JjZSA9IFZlY3RvcjIuWmVybztcclxuICAgICAgICAgICAgICAgICAgICBUb3JxdWUgPSAwLjBmO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGdldCB7IHJldHVybiAoRmxhZ3MgJiBCb2R5RmxhZ3MuQXdha2UpID09IEJvZHlGbGFncy5Bd2FrZTsgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBTZXQgdGhlIGFjdGl2ZSBzdGF0ZSBvZiB0aGUgYm9keS4gQW4gaW5hY3RpdmUgYm9keSBpcyBub3RcclxuICAgICAgICAvLy8gc2ltdWxhdGVkIGFuZCBjYW5ub3QgYmUgY29sbGlkZWQgd2l0aCBvciB3b2tlbiB1cC5cclxuICAgICAgICAvLy8gSWYgeW91IHBhc3MgYSBmbGFnIG9mIHRydWUsIGFsbCBmaXh0dXJlcyB3aWxsIGJlIGFkZGVkIHRvIHRoZVxyXG4gICAgICAgIC8vLyBicm9hZC1waGFzZS5cclxuICAgICAgICAvLy8gSWYgeW91IHBhc3MgYSBmbGFnIG9mIGZhbHNlLCBhbGwgZml4dHVyZXMgd2lsbCBiZSByZW1vdmVkIGZyb21cclxuICAgICAgICAvLy8gdGhlIGJyb2FkLXBoYXNlIGFuZCBhbGwgY29udGFjdHMgd2lsbCBiZSBkZXN0cm95ZWQuXHJcbiAgICAgICAgLy8vIEZpeHR1cmVzIGFuZCBqb2ludHMgYXJlIG90aGVyd2lzZSB1bmFmZmVjdGVkLiBZb3UgbWF5IGNvbnRpbnVlXHJcbiAgICAgICAgLy8vIHRvIGNyZWF0ZS9kZXN0cm95IGZpeHR1cmVzIGFuZCBqb2ludHMgb24gaW5hY3RpdmUgYm9kaWVzLlxyXG4gICAgICAgIC8vLyBGaXh0dXJlcyBvbiBhbiBpbmFjdGl2ZSBib2R5IGFyZSBpbXBsaWNpdGx5IGluYWN0aXZlIGFuZCB3aWxsXHJcbiAgICAgICAgLy8vIG5vdCBwYXJ0aWNpcGF0ZSBpbiBjb2xsaXNpb25zLCByYXktY2FzdHMsIG9yIHF1ZXJpZXMuXHJcbiAgICAgICAgLy8vIEpvaW50cyBjb25uZWN0ZWQgdG8gYW4gaW5hY3RpdmUgYm9keSBhcmUgaW1wbGljaXRseSBpbmFjdGl2ZS5cclxuICAgICAgICAvLy8gQW4gaW5hY3RpdmUgYm9keSBpcyBzdGlsbCBvd25lZCBieSBhIGIyV29ybGQgb2JqZWN0IGFuZCByZW1haW5zXHJcbiAgICAgICAgLy8vIGluIHRoZSBib2R5IGxpc3QuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHZhbHVlPjxjPnRydWU8L2M+IGlmIGFjdGl2ZTsgb3RoZXJ3aXNlLCA8Yz5mYWxzZTwvYz4uPC92YWx1ZT5cclxuICAgICAgICBwdWJsaWMgYm9vbCBFbmFibGVkXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBzZXRcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlID09IEVuYWJsZWQpXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSlcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBGbGFncyB8PSBCb2R5RmxhZ3MuRW5hYmxlZDtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gQ3JlYXRlIGFsbCBwcm94aWVzLlxyXG4gICAgICAgICAgICAgICAgICAgIElCcm9hZFBoYXNlIGJyb2FkUGhhc2UgPSBXb3JsZC5Db250YWN0TWFuYWdlci5Ccm9hZFBoYXNlO1xyXG4gICAgICAgICAgICAgICAgICAgIGZvciAoaW50IGkgPSAwOyBpIDwgRml4dHVyZUxpc3QuQ291bnQ7IGkrKylcclxuICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIEZpeHR1cmVMaXN0W2ldLkNyZWF0ZVByb3hpZXMoYnJvYWRQaGFzZSwgcmVmIFhmKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIENvbnRhY3RzIGFyZSBjcmVhdGVkIHRoZSBuZXh0IHRpbWUgc3RlcC5cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBGbGFncyAmPSB+Qm9keUZsYWdzLkVuYWJsZWQ7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIERlc3Ryb3kgYWxsIHByb3hpZXMuXHJcbiAgICAgICAgICAgICAgICAgICAgSUJyb2FkUGhhc2UgYnJvYWRQaGFzZSA9IFdvcmxkLkNvbnRhY3RNYW5hZ2VyLkJyb2FkUGhhc2U7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGZvciAoaW50IGkgPSAwOyBpIDwgRml4dHVyZUxpc3QuQ291bnQ7IGkrKylcclxuICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIEZpeHR1cmVMaXN0W2ldLkRlc3Ryb3lQcm94aWVzKGJyb2FkUGhhc2UpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gRGVzdHJveSB0aGUgYXR0YWNoZWQgY29udGFjdHMuXHJcbiAgICAgICAgICAgICAgICAgICAgQ29udGFjdEVkZ2UgY2UgPSBDb250YWN0TGlzdDtcclxuICAgICAgICAgICAgICAgICAgICB3aGlsZSAoY2UgIT0gbnVsbClcclxuICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIENvbnRhY3RFZGdlIGNlMCA9IGNlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjZSA9IGNlLk5leHQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIFdvcmxkLkNvbnRhY3RNYW5hZ2VyLkRlc3Ryb3koY2UwLkNvbnRhY3QpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBDb250YWN0TGlzdCA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZ2V0IHsgcmV0dXJuIChGbGFncyAmIEJvZHlGbGFncy5FbmFibGVkKSA9PSBCb2R5RmxhZ3MuRW5hYmxlZDsgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBTZXQgdGhpcyBib2R5IHRvIGhhdmUgZml4ZWQgcm90YXRpb24uIFRoaXMgY2F1c2VzIHRoZSBtYXNzXHJcbiAgICAgICAgLy8vIHRvIGJlIHJlc2V0LlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDx2YWx1ZT48Yz50cnVlPC9jPiBpZiBpdCBoYXMgZml4ZWQgcm90YXRpb247IG90aGVyd2lzZSwgPGM+ZmFsc2U8L2M+LjwvdmFsdWU+XHJcbiAgICAgICAgcHVibGljIGJvb2wgRml4ZWRSb3RhdGlvblxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgc2V0XHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSlcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBGbGFncyB8PSBCb2R5RmxhZ3MuRml4ZWRSb3RhdGlvbjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBGbGFncyAmPSB+Qm9keUZsYWdzLkZpeGVkUm90YXRpb247XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgUmVzZXRNYXNzRGF0YSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGdldCB7IHJldHVybiAoRmxhZ3MgJiBCb2R5RmxhZ3MuRml4ZWRSb3RhdGlvbikgPT0gQm9keUZsYWdzLkZpeGVkUm90YXRpb247IH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gR2V0cyBhbGwgdGhlIGZpeHR1cmVzIGF0dGFjaGVkIHRvIHRoaXMgYm9keS5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8dmFsdWU+VGhlIGZpeHR1cmUgbGlzdC48L3ZhbHVlPlxyXG4gICAgICAgIHB1YmxpYyBMaXN0PEZpeHR1cmU+IEZpeHR1cmVMaXN0IHsgZ2V0OyBpbnRlcm5hbCBzZXQ7IH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBHZXQgdGhlIGxpc3Qgb2YgYWxsIGpvaW50cyBhdHRhY2hlZCB0byB0aGlzIGJvZHkuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHZhbHVlPlRoZSBqb2ludCBsaXN0LjwvdmFsdWU+XHJcbiAgICAgICAgcHVibGljIEpvaW50RWRnZSBKb2ludExpc3QgeyBnZXQ7IGludGVybmFsIHNldDsgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIEdldCB0aGUgbGlzdCBvZiBhbGwgY29udGFjdHMgYXR0YWNoZWQgdG8gdGhpcyBib2R5LlxyXG4gICAgICAgIC8vLyBXYXJuaW5nOiB0aGlzIGxpc3QgY2hhbmdlcyBkdXJpbmcgdGhlIHRpbWUgc3RlcCBhbmQgeW91IG1heVxyXG4gICAgICAgIC8vLyBtaXNzIHNvbWUgY29sbGlzaW9ucyBpZiB5b3UgZG9uJ3QgdXNlIENvbnRhY3RMaXN0ZW5lci5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8dmFsdWU+VGhlIGNvbnRhY3QgbGlzdC48L3ZhbHVlPlxyXG4gICAgICAgIHB1YmxpYyBDb250YWN0RWRnZSBDb250YWN0TGlzdCB7IGdldDsgaW50ZXJuYWwgc2V0OyB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gU2V0IHRoZSB1c2VyIGRhdGEuIFVzZSB0aGlzIHRvIHN0b3JlIHlvdXIgYXBwbGljYXRpb24gc3BlY2lmaWMgZGF0YS5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8dmFsdWU+VGhlIHVzZXIgZGF0YS48L3ZhbHVlPlxyXG4gICAgICAgIHB1YmxpYyBvYmplY3QgVXNlckRhdGEgeyBnZXQ7IHNldDsgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIEdldCB0aGUgd29ybGQgYm9keSBvcmlnaW4gcG9zaXRpb24uXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHJldHVybnM+UmV0dXJuIHRoZSB3b3JsZCBwb3NpdGlvbiBvZiB0aGUgYm9keSdzIG9yaWdpbi48L3JldHVybnM+XHJcbiAgICAgICAgcHVibGljIFZlY3RvcjIgUG9zaXRpb25cclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGdldCB7IHJldHVybiBYZi5Qb3NpdGlvbjsgfVxyXG4gICAgICAgICAgICBzZXRcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgRGVidWcuQXNzZXJ0KCFmbG9hdC5Jc05hTih2YWx1ZS5YKSAmJiAhZmxvYXQuSXNOYU4odmFsdWUuWSkpO1xyXG5cclxuICAgICAgICAgICAgICAgIFNldFRyYW5zZm9ybShyZWYgdmFsdWUsIFJvdGF0aW9uKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBHZXQgdGhlIGFuZ2xlIGluIHJhZGlhbnMuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHJldHVybnM+UmV0dXJuIHRoZSBjdXJyZW50IHdvcmxkIHJvdGF0aW9uIGFuZ2xlIGluIHJhZGlhbnMuPC9yZXR1cm5zPlxyXG4gICAgICAgIHB1YmxpYyBmbG9hdCBSb3RhdGlvblxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgZ2V0IHsgcmV0dXJuIFN3ZWVwLkE7IH1cclxuICAgICAgICAgICAgc2V0XHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIERlYnVnLkFzc2VydCghZmxvYXQuSXNOYU4odmFsdWUpKTtcclxuXHJcbiAgICAgICAgICAgICAgICBTZXRUcmFuc2Zvcm0ocmVmIFhmLlBvc2l0aW9uLCB2YWx1ZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gR2V0cyBvciBzZXRzIGEgdmFsdWUgaW5kaWNhdGluZyB3aGV0aGVyIHRoaXMgYm9keSBpcyBzdGF0aWMuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHZhbHVlPjxjPnRydWU8L2M+IGlmIHRoaXMgaW5zdGFuY2UgaXMgc3RhdGljOyBvdGhlcndpc2UsIDxjPmZhbHNlPC9jPi48L3ZhbHVlPlxyXG4gICAgICAgIHB1YmxpYyBib29sIElzU3RhdGljXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBnZXQgeyByZXR1cm4gX2JvZHlUeXBlID09IEJvZHlUeXBlLlN0YXRpYzsgfVxyXG4gICAgICAgICAgICBzZXRcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlKVxyXG4gICAgICAgICAgICAgICAgICAgIEJvZHlUeXBlID0gQm9keVR5cGUuU3RhdGljO1xyXG4gICAgICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgICAgIEJvZHlUeXBlID0gQm9keVR5cGUuRHluYW1pYztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBHZXRzIG9yIHNldHMgYSB2YWx1ZSBpbmRpY2F0aW5nIHdoZXRoZXIgdGhpcyBib2R5IGlnbm9yZXMgZ3Jhdml0eS5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8dmFsdWU+PGM+dHJ1ZTwvYz4gaWYgIGl0IGlnbm9yZXMgZ3Jhdml0eTsgb3RoZXJ3aXNlLCA8Yz5mYWxzZTwvYz4uPC92YWx1ZT5cclxuICAgICAgICBwdWJsaWMgYm9vbCBJZ25vcmVHcmF2aXR5XHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBnZXQgeyByZXR1cm4gKEZsYWdzICYgQm9keUZsYWdzLklnbm9yZUdyYXZpdHkpID09IEJvZHlGbGFncy5JZ25vcmVHcmF2aXR5OyB9XHJcbiAgICAgICAgICAgIHNldFxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUpXHJcbiAgICAgICAgICAgICAgICAgICAgRmxhZ3MgfD0gQm9keUZsYWdzLklnbm9yZUdyYXZpdHk7XHJcbiAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICAgICAgRmxhZ3MgJj0gfkJvZHlGbGFncy5JZ25vcmVHcmF2aXR5O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIEdldCB0aGUgd29ybGQgcG9zaXRpb24gb2YgdGhlIGNlbnRlciBvZiBtYXNzLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDx2YWx1ZT5UaGUgd29ybGQgcG9zaXRpb24uPC92YWx1ZT5cclxuICAgICAgICBwdWJsaWMgVmVjdG9yMiBXb3JsZENlbnRlclxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgZ2V0IHsgcmV0dXJuIFN3ZWVwLkM7IH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gR2V0IHRoZSBsb2NhbCBwb3NpdGlvbiBvZiB0aGUgY2VudGVyIG9mIG1hc3MuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHZhbHVlPlRoZSBsb2NhbCBwb3NpdGlvbi48L3ZhbHVlPlxyXG4gICAgICAgIHB1YmxpYyBWZWN0b3IyIExvY2FsQ2VudGVyXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBnZXQgeyByZXR1cm4gU3dlZXAuTG9jYWxDZW50ZXI7IH1cclxuICAgICAgICAgICAgc2V0XHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGlmIChfYm9keVR5cGUgIT0gQm9keVR5cGUuRHluYW1pYylcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gTW92ZSBjZW50ZXIgb2YgbWFzcy5cclxuICAgICAgICAgICAgICAgIFZlY3RvcjIgb2xkQ2VudGVyID0gU3dlZXAuQztcclxuICAgICAgICAgICAgICAgIFN3ZWVwLkxvY2FsQ2VudGVyID0gdmFsdWU7XHJcbiAgICAgICAgICAgICAgICBTd2VlcC5DMCA9IFN3ZWVwLkMgPSBNYXRoVXRpbHMuTXVsdGlwbHkocmVmIFhmLCByZWYgU3dlZXAuTG9jYWxDZW50ZXIpO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIFVwZGF0ZSBjZW50ZXIgb2YgbWFzcyB2ZWxvY2l0eS5cclxuICAgICAgICAgICAgICAgIFZlY3RvcjIgYSA9IFN3ZWVwLkMgLSBvbGRDZW50ZXI7XHJcbiAgICAgICAgICAgICAgICBMaW5lYXJWZWxvY2l0eUludGVybmFsICs9IG5ldyBWZWN0b3IyKC1Bbmd1bGFyVmVsb2NpdHlJbnRlcm5hbCAqIGEuWSwgQW5ndWxhclZlbG9jaXR5SW50ZXJuYWwgKiBhLlgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIEdldHMgb3Igc2V0cyB0aGUgbWFzcy4gVXN1YWxseSBpbiBraWxvZ3JhbXMgKGtnKS5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8dmFsdWU+VGhlIG1hc3MuPC92YWx1ZT5cclxuICAgICAgICBwdWJsaWMgZmxvYXQgTWFzc1xyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgZ2V0IHsgcmV0dXJuIF9tYXNzOyB9XHJcbiAgICAgICAgICAgIHNldFxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBEZWJ1Zy5Bc3NlcnQoIWZsb2F0LklzTmFOKHZhbHVlKSk7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKF9ib2R5VHlwZSAhPSBCb2R5VHlwZS5EeW5hbWljKVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuXHJcbiAgICAgICAgICAgICAgICBfbWFzcyA9IHZhbHVlO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmIChfbWFzcyA8PSAwLjBmKVxyXG4gICAgICAgICAgICAgICAgICAgIF9tYXNzID0gMS4wZjtcclxuXHJcbiAgICAgICAgICAgICAgICBJbnZNYXNzID0gMS4wZiAvIF9tYXNzO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIEdldCBvciBzZXQgdGhlIHJvdGF0aW9uYWwgaW5lcnRpYSBvZiB0aGUgYm9keSBhYm91dCB0aGUgbG9jYWwgb3JpZ2luLiB1c3VhbGx5IGluIGtnLW1eMi5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8dmFsdWU+VGhlIGluZXJ0aWEuPC92YWx1ZT5cclxuICAgICAgICBwdWJsaWMgZmxvYXQgSW5lcnRpYVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgZ2V0IHsgcmV0dXJuIF9pbmVydGlhICsgTWFzcyAqIFZlY3RvcjIuRG90KFN3ZWVwLkxvY2FsQ2VudGVyLCBTd2VlcC5Mb2NhbENlbnRlcik7IH1cclxuICAgICAgICAgICAgc2V0XHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIERlYnVnLkFzc2VydCghZmxvYXQuSXNOYU4odmFsdWUpKTtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoX2JvZHlUeXBlICE9IEJvZHlUeXBlLkR5bmFtaWMpXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA+IDAuMGYgJiYgKEZsYWdzICYgQm9keUZsYWdzLkZpeGVkUm90YXRpb24pID09IDApXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgX2luZXJ0aWEgPSB2YWx1ZSAtIE1hc3MgKiBWZWN0b3IyLkRvdChMb2NhbENlbnRlciwgTG9jYWxDZW50ZXIpO1xyXG4gICAgICAgICAgICAgICAgICAgIERlYnVnLkFzc2VydChfaW5lcnRpYSA+IDAuMGYpO1xyXG4gICAgICAgICAgICAgICAgICAgIEludkkgPSAxLjBmIC8gX2luZXJ0aWE7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHB1YmxpYyBmbG9hdCBSZXN0aXR1dGlvblxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgZ2V0XHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGZsb2F0IHJlcyA9IDA7XHJcblxyXG4gICAgICAgICAgICAgICAgZm9yIChpbnQgaSA9IDA7IGkgPCBGaXh0dXJlTGlzdC5Db3VudDsgaSsrKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIEZpeHR1cmUgZiA9IEZpeHR1cmVMaXN0W2ldO1xyXG4gICAgICAgICAgICAgICAgICAgIHJlcyArPSBmLlJlc3RpdHV0aW9uO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIHJldHVybiByZXMgLyBGaXh0dXJlTGlzdC5Db3VudDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBzZXRcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgZm9yIChpbnQgaSA9IDA7IGkgPCBGaXh0dXJlTGlzdC5Db3VudDsgaSsrKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIEZpeHR1cmUgZiA9IEZpeHR1cmVMaXN0W2ldO1xyXG4gICAgICAgICAgICAgICAgICAgIGYuUmVzdGl0dXRpb24gPSB2YWx1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHVibGljIGZsb2F0IEZyaWN0aW9uXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBnZXRcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgZmxvYXQgcmVzID0gMDtcclxuXHJcbiAgICAgICAgICAgICAgICBmb3IgKGludCBpID0gMDsgaSA8IEZpeHR1cmVMaXN0LkNvdW50OyBpKyspXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgRml4dHVyZSBmID0gRml4dHVyZUxpc3RbaV07XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzICs9IGYuRnJpY3Rpb247XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlcyAvIEZpeHR1cmVMaXN0LkNvdW50O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHNldFxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBmb3IgKGludCBpID0gMDsgaSA8IEZpeHR1cmVMaXN0LkNvdW50OyBpKyspXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgRml4dHVyZSBmID0gRml4dHVyZUxpc3RbaV07XHJcbiAgICAgICAgICAgICAgICAgICAgZi5GcmljdGlvbiA9IHZhbHVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwdWJsaWMgQ2F0ZWdvcnkgQ29sbGlzaW9uQ2F0ZWdvcmllc1xyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgc2V0XHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGZvciAoaW50IGkgPSAwOyBpIDwgRml4dHVyZUxpc3QuQ291bnQ7IGkrKylcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBGaXh0dXJlIGYgPSBGaXh0dXJlTGlzdFtpXTtcclxuICAgICAgICAgICAgICAgICAgICBmLkNvbGxpc2lvbkNhdGVnb3JpZXMgPSB2YWx1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHVibGljIENhdGVnb3J5IENvbGxpZGVzV2l0aFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgc2V0XHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGZvciAoaW50IGkgPSAwOyBpIDwgRml4dHVyZUxpc3QuQ291bnQ7IGkrKylcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBGaXh0dXJlIGYgPSBGaXh0dXJlTGlzdFtpXTtcclxuICAgICAgICAgICAgICAgICAgICBmLkNvbGxpZGVzV2l0aCA9IHZhbHVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwdWJsaWMgc2hvcnQgQ29sbGlzaW9uR3JvdXBcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHNldFxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBmb3IgKGludCBpID0gMDsgaSA8IEZpeHR1cmVMaXN0LkNvdW50OyBpKyspXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgRml4dHVyZSBmID0gRml4dHVyZUxpc3RbaV07XHJcbiAgICAgICAgICAgICAgICAgICAgZi5Db2xsaXNpb25Hcm91cCA9IHZhbHVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwdWJsaWMgYm9vbCBJc1NlbnNvclxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgc2V0XHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGZvciAoaW50IGkgPSAwOyBpIDwgRml4dHVyZUxpc3QuQ291bnQ7IGkrKylcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBGaXh0dXJlIGYgPSBGaXh0dXJlTGlzdFtpXTtcclxuICAgICAgICAgICAgICAgICAgICBmLklzU2Vuc29yID0gdmFsdWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHB1YmxpYyBib29sIElnbm9yZUNDRFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgZ2V0IHsgcmV0dXJuIChGbGFncyAmIEJvZHlGbGFncy5JZ25vcmVDQ0QpID09IEJvZHlGbGFncy5JZ25vcmVDQ0Q7IH1cclxuICAgICAgICAgICAgc2V0XHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSlcclxuICAgICAgICAgICAgICAgICAgICBGbGFncyB8PSBCb2R5RmxhZ3MuSWdub3JlQ0NEO1xyXG4gICAgICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgICAgIEZsYWdzICY9IH5Cb2R5RmxhZ3MuSWdub3JlQ0NEO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAjcmVnaW9uIElEaXNwb3NhYmxlIE1lbWJlcnNcclxuXHJcbiAgICAgICAgcHVibGljIGJvb2wgSXNEaXNwb3NlZCB7IGdldDsgc2V0OyB9XHJcblxyXG4gICAgICAgIHB1YmxpYyB2b2lkIERpc3Bvc2UoKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgaWYgKCFJc0Rpc3Bvc2VkKVxyXG4gICAgICAgICAgICB7XHJcblxyXG4gICAgICAgICAgICAgICAgV29ybGQuUmVtb3ZlQm9keSh0aGlzKTtcclxuICAgICAgICAgICAgICAgIElzRGlzcG9zZWQgPSB0cnVlO1xyXG4jaWYgIUh0bWw1XHJcbiAgICAgICAgICAgICAgICBHQy5TdXBwcmVzc0ZpbmFsaXplKHRoaXMpO1xyXG4jZW5kaWZcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgI2VuZHJlZ2lvblxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIFJlc2V0cyB0aGUgZHluYW1pY3Mgb2YgdGhpcyBib2R5LlxyXG4gICAgICAgIC8vLyBTZXRzIHRvcnF1ZSwgZm9yY2UgYW5kIGxpbmVhci9hbmd1bGFyIHZlbG9jaXR5IHRvIDBcclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIHB1YmxpYyB2b2lkIFJlc2V0RHluYW1pY3MoKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgVG9ycXVlID0gMDtcclxuICAgICAgICAgICAgQW5ndWxhclZlbG9jaXR5SW50ZXJuYWwgPSAwO1xyXG4gICAgICAgICAgICBGb3JjZSA9IFZlY3RvcjIuWmVybztcclxuICAgICAgICAgICAgTGluZWFyVmVsb2NpdHlJbnRlcm5hbCA9IFZlY3RvcjIuWmVybztcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gQ3JlYXRlcyBhIGZpeHR1cmUgYW5kIGF0dGFjaCBpdCB0byB0aGlzIGJvZHkuXHJcbiAgICAgICAgLy8vIElmIHRoZSBkZW5zaXR5IGlzIG5vbi16ZXJvLCB0aGlzIGZ1bmN0aW9uIGF1dG9tYXRpY2FsbHkgdXBkYXRlcyB0aGUgbWFzcyBvZiB0aGUgYm9keS5cclxuICAgICAgICAvLy8gQ29udGFjdHMgYXJlIG5vdCBjcmVhdGVkIHVudGlsIHRoZSBuZXh0IHRpbWUgc3RlcC5cclxuICAgICAgICAvLy8gV2FybmluZzogVGhpcyBmdW5jdGlvbiBpcyBsb2NrZWQgZHVyaW5nIGNhbGxiYWNrcy5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cInNoYXBlXCI+VGhlIHNoYXBlLjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxyZXR1cm5zPjwvcmV0dXJucz5cclxuICAgICAgICBwdWJsaWMgRml4dHVyZSBDcmVhdGVGaXh0dXJlKFNoYXBlIHNoYXBlKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBGaXh0dXJlKHRoaXMsIHNoYXBlKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gQ3JlYXRlcyBhIGZpeHR1cmUgYW5kIGF0dGFjaCBpdCB0byB0aGlzIGJvZHkuXHJcbiAgICAgICAgLy8vIElmIHRoZSBkZW5zaXR5IGlzIG5vbi16ZXJvLCB0aGlzIGZ1bmN0aW9uIGF1dG9tYXRpY2FsbHkgdXBkYXRlcyB0aGUgbWFzcyBvZiB0aGUgYm9keS5cclxuICAgICAgICAvLy8gQ29udGFjdHMgYXJlIG5vdCBjcmVhdGVkIHVudGlsIHRoZSBuZXh0IHRpbWUgc3RlcC5cclxuICAgICAgICAvLy8gV2FybmluZzogVGhpcyBmdW5jdGlvbiBpcyBsb2NrZWQgZHVyaW5nIGNhbGxiYWNrcy5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cInNoYXBlXCI+VGhlIHNoYXBlLjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwidXNlckRhdGFcIj5BcHBsaWNhdGlvbiBzcGVjaWZpYyBkYXRhPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHJldHVybnM+PC9yZXR1cm5zPlxyXG4gICAgICAgIHB1YmxpYyBGaXh0dXJlIENyZWF0ZUZpeHR1cmUoU2hhcGUgc2hhcGUsIG9iamVjdCB1c2VyRGF0YSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgRml4dHVyZSh0aGlzLCBzaGFwZSwgdXNlckRhdGEpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBEZXN0cm95IGEgZml4dHVyZS4gVGhpcyByZW1vdmVzIHRoZSBmaXh0dXJlIGZyb20gdGhlIGJyb2FkLXBoYXNlIGFuZFxyXG4gICAgICAgIC8vLyBkZXN0cm95cyBhbGwgY29udGFjdHMgYXNzb2NpYXRlZCB3aXRoIHRoaXMgZml4dHVyZS4gVGhpcyB3aWxsXHJcbiAgICAgICAgLy8vIGF1dG9tYXRpY2FsbHkgYWRqdXN0IHRoZSBtYXNzIG9mIHRoZSBib2R5IGlmIHRoZSBib2R5IGlzIGR5bmFtaWMgYW5kIHRoZVxyXG4gICAgICAgIC8vLyBmaXh0dXJlIGhhcyBwb3NpdGl2ZSBkZW5zaXR5LlxyXG4gICAgICAgIC8vLyBBbGwgZml4dHVyZXMgYXR0YWNoZWQgdG8gYSBib2R5IGFyZSBpbXBsaWNpdGx5IGRlc3Ryb3llZCB3aGVuIHRoZSBib2R5IGlzIGRlc3Ryb3llZC5cclxuICAgICAgICAvLy8gV2FybmluZzogVGhpcyBmdW5jdGlvbiBpcyBsb2NrZWQgZHVyaW5nIGNhbGxiYWNrcy5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cImZpeHR1cmVcIj5UaGUgZml4dHVyZSB0byBiZSByZW1vdmVkLjwvcGFyYW0+XHJcbiAgICAgICAgcHVibGljIHZvaWQgRGVzdHJveUZpeHR1cmUoRml4dHVyZSBmaXh0dXJlKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgRGVidWcuQXNzZXJ0KGZpeHR1cmUuQm9keSA9PSB0aGlzKTtcclxuXHJcbiAgICAgICAgICAgIC8vIFJlbW92ZSB0aGUgZml4dHVyZSBmcm9tIHRoaXMgYm9keSdzIHNpbmdseSBsaW5rZWQgbGlzdC5cclxuICAgICAgICAgICAgRGVidWcuQXNzZXJ0KEZpeHR1cmVMaXN0LkNvdW50ID4gMCk7XHJcblxyXG4gICAgICAgICAgICAvLyBZb3UgdHJpZWQgdG8gcmVtb3ZlIGEgZml4dHVyZSB0aGF0IG5vdCBwcmVzZW50IGluIHRoZSBmaXh0dXJlbGlzdC5cclxuICAgICAgICAgICAgRGVidWcuQXNzZXJ0KEZpeHR1cmVMaXN0LkNvbnRhaW5zKGZpeHR1cmUpKTtcclxuXHJcbiAgICAgICAgICAgIC8vIERlc3Ryb3kgYW55IGNvbnRhY3RzIGFzc29jaWF0ZWQgd2l0aCB0aGUgZml4dHVyZS5cclxuICAgICAgICAgICAgQ29udGFjdEVkZ2UgZWRnZSA9IENvbnRhY3RMaXN0O1xyXG4gICAgICAgICAgICB3aGlsZSAoZWRnZSAhPSBudWxsKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBDb250YWN0IGMgPSBlZGdlLkNvbnRhY3Q7XHJcbiAgICAgICAgICAgICAgICBlZGdlID0gZWRnZS5OZXh0O1xyXG5cclxuICAgICAgICAgICAgICAgIEZpeHR1cmUgZml4dHVyZUEgPSBjLkZpeHR1cmVBO1xyXG4gICAgICAgICAgICAgICAgRml4dHVyZSBmaXh0dXJlQiA9IGMuRml4dHVyZUI7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKGZpeHR1cmUgPT0gZml4dHVyZUEgfHwgZml4dHVyZSA9PSBmaXh0dXJlQilcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBUaGlzIGRlc3Ryb3lzIHRoZSBjb250YWN0IGFuZCByZW1vdmVzIGl0IGZyb21cclxuICAgICAgICAgICAgICAgICAgICAvLyB0aGlzIGJvZHkncyBjb250YWN0IGxpc3QuXHJcbiAgICAgICAgICAgICAgICAgICAgV29ybGQuQ29udGFjdE1hbmFnZXIuRGVzdHJveShjKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKChGbGFncyAmIEJvZHlGbGFncy5FbmFibGVkKSA9PSBCb2R5RmxhZ3MuRW5hYmxlZClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgSUJyb2FkUGhhc2UgYnJvYWRQaGFzZSA9IFdvcmxkLkNvbnRhY3RNYW5hZ2VyLkJyb2FkUGhhc2U7XHJcbiAgICAgICAgICAgICAgICBmaXh0dXJlLkRlc3Ryb3lQcm94aWVzKGJyb2FkUGhhc2UpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBGaXh0dXJlTGlzdC5SZW1vdmUoZml4dHVyZSk7XHJcbiAgICAgICAgICAgIGZpeHR1cmUuRGVzdHJveSgpO1xyXG4gICAgICAgICAgICBmaXh0dXJlLkJvZHkgPSBudWxsO1xyXG5cclxuICAgICAgICAgICAgUmVzZXRNYXNzRGF0YSgpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBTZXQgdGhlIHBvc2l0aW9uIG9mIHRoZSBib2R5J3Mgb3JpZ2luIGFuZCByb3RhdGlvbi5cclxuICAgICAgICAvLy8gVGhpcyBicmVha3MgYW55IGNvbnRhY3RzIGFuZCB3YWtlcyB0aGUgb3RoZXIgYm9kaWVzLlxyXG4gICAgICAgIC8vLyBNYW5pcHVsYXRpbmcgYSBib2R5J3MgdHJhbnNmb3JtIG1heSBjYXVzZSBub24tcGh5c2ljYWwgYmVoYXZpb3IuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJwb3NpdGlvblwiPlRoZSB3b3JsZCBwb3NpdGlvbiBvZiB0aGUgYm9keSdzIGxvY2FsIG9yaWdpbi48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cInJvdGF0aW9uXCI+VGhlIHdvcmxkIHJvdGF0aW9uIGluIHJhZGlhbnMuPC9wYXJhbT5cclxuICAgICAgICBwdWJsaWMgdm9pZCBTZXRUcmFuc2Zvcm0ocmVmIFZlY3RvcjIgcG9zaXRpb24sIGZsb2F0IHJvdGF0aW9uKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgU2V0VHJhbnNmb3JtSWdub3JlQ29udGFjdHMocmVmIHBvc2l0aW9uLCByb3RhdGlvbik7XHJcblxyXG4gICAgICAgICAgICBXb3JsZC5Db250YWN0TWFuYWdlci5GaW5kTmV3Q29udGFjdHMoKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gU2V0IHRoZSBwb3NpdGlvbiBvZiB0aGUgYm9keSdzIG9yaWdpbiBhbmQgcm90YXRpb24uXHJcbiAgICAgICAgLy8vIFRoaXMgYnJlYWtzIGFueSBjb250YWN0cyBhbmQgd2FrZXMgdGhlIG90aGVyIGJvZGllcy5cclxuICAgICAgICAvLy8gTWFuaXB1bGF0aW5nIGEgYm9keSdzIHRyYW5zZm9ybSBtYXkgY2F1c2Ugbm9uLXBoeXNpY2FsIGJlaGF2aW9yLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwicG9zaXRpb25cIj5UaGUgd29ybGQgcG9zaXRpb24gb2YgdGhlIGJvZHkncyBsb2NhbCBvcmlnaW4uPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJyb3RhdGlvblwiPlRoZSB3b3JsZCByb3RhdGlvbiBpbiByYWRpYW5zLjwvcGFyYW0+XHJcbiAgICAgICAgcHVibGljIHZvaWQgU2V0VHJhbnNmb3JtKFZlY3RvcjIgcG9zaXRpb24sIGZsb2F0IHJvdGF0aW9uKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgU2V0VHJhbnNmb3JtKHJlZiBwb3NpdGlvbiwgcm90YXRpb24pO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBGb3IgdGVsZXBvcnRpbmcgYSBib2R5IHdpdGhvdXQgY29uc2lkZXJpbmcgbmV3IGNvbnRhY3RzIGltbWVkaWF0ZWx5LlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwicG9zaXRpb25cIj5UaGUgcG9zaXRpb24uPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJhbmdsZVwiPlRoZSBhbmdsZS48L3BhcmFtPlxyXG4gICAgICAgIHB1YmxpYyB2b2lkIFNldFRyYW5zZm9ybUlnbm9yZUNvbnRhY3RzKHJlZiBWZWN0b3IyIHBvc2l0aW9uLCBmbG9hdCBhbmdsZSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIFhmLlIuU2V0KGFuZ2xlKTtcclxuICAgICAgICAgICAgWGYuUG9zaXRpb24gPSBwb3NpdGlvbjtcclxuXHJcbiAgICAgICAgICAgIFN3ZWVwLkMwID1cclxuICAgICAgICAgICAgICAgIFN3ZWVwLkMgPVxyXG4gICAgICAgICAgICAgICAgbmV3IFZlY3RvcjIoWGYuUG9zaXRpb24uWCArIFhmLlIuQ29sMS5YICogU3dlZXAuTG9jYWxDZW50ZXIuWCArIFhmLlIuQ29sMi5YICogU3dlZXAuTG9jYWxDZW50ZXIuWSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFhmLlBvc2l0aW9uLlkgKyBYZi5SLkNvbDEuWSAqIFN3ZWVwLkxvY2FsQ2VudGVyLlggKyBYZi5SLkNvbDIuWSAqIFN3ZWVwLkxvY2FsQ2VudGVyLlkpO1xyXG4gICAgICAgICAgICBTd2VlcC5BMCA9IFN3ZWVwLkEgPSBhbmdsZTtcclxuXHJcbiAgICAgICAgICAgIElCcm9hZFBoYXNlIGJyb2FkUGhhc2UgPSBXb3JsZC5Db250YWN0TWFuYWdlci5Ccm9hZFBoYXNlO1xyXG4gICAgICAgICAgICBmb3IgKGludCBpID0gMDsgaSA8IEZpeHR1cmVMaXN0LkNvdW50OyBpKyspXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIEZpeHR1cmVMaXN0W2ldLlN5bmNocm9uaXplKGJyb2FkUGhhc2UsIHJlZiBYZiwgcmVmIFhmKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBHZXQgdGhlIGJvZHkgdHJhbnNmb3JtIGZvciB0aGUgYm9keSdzIG9yaWdpbi5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cInRyYW5zZm9ybVwiPlRoZSB0cmFuc2Zvcm0gb2YgdGhlIGJvZHkncyBvcmlnaW4uPC9wYXJhbT5cclxuICAgICAgICBwdWJsaWMgdm9pZCBHZXRUcmFuc2Zvcm0ob3V0IFRyYW5zZm9ybSB0cmFuc2Zvcm0pXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB0cmFuc2Zvcm0gPSBYZjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gQXBwbHkgYSBmb3JjZSBhdCBhIHdvcmxkIHBvaW50LiBJZiB0aGUgZm9yY2UgaXMgbm90XHJcbiAgICAgICAgLy8vIGFwcGxpZWQgYXQgdGhlIGNlbnRlciBvZiBtYXNzLCBpdCB3aWxsIGdlbmVyYXRlIGEgdG9ycXVlIGFuZFxyXG4gICAgICAgIC8vLyBhZmZlY3QgdGhlIGFuZ3VsYXIgdmVsb2NpdHkuIFRoaXMgd2FrZXMgdXAgdGhlIGJvZHkuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJmb3JjZVwiPlRoZSB3b3JsZCBmb3JjZSB2ZWN0b3IsIHVzdWFsbHkgaW4gTmV3dG9ucyAoTikuPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJwb2ludFwiPlRoZSB3b3JsZCBwb3NpdGlvbiBvZiB0aGUgcG9pbnQgb2YgYXBwbGljYXRpb24uPC9wYXJhbT5cclxuICAgICAgICBwdWJsaWMgdm9pZCBBcHBseUZvcmNlKFZlY3RvcjIgZm9yY2UsIFZlY3RvcjIgcG9pbnQpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBBcHBseUZvcmNlKHJlZiBmb3JjZSwgcmVmIHBvaW50KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gQXBwbGllcyBhIGZvcmNlIGF0IHRoZSBjZW50ZXIgb2YgbWFzcy5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cImZvcmNlXCI+VGhlIGZvcmNlLjwvcGFyYW0+XHJcbiAgICAgICAgcHVibGljIHZvaWQgQXBwbHlGb3JjZShyZWYgVmVjdG9yMiBmb3JjZSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIEFwcGx5Rm9yY2UocmVmIGZvcmNlLCByZWYgWGYuUG9zaXRpb24pO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBBcHBsaWVzIGEgZm9yY2UgYXQgdGhlIGNlbnRlciBvZiBtYXNzLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwiZm9yY2VcIj5UaGUgZm9yY2UuPC9wYXJhbT5cclxuICAgICAgICBwdWJsaWMgdm9pZCBBcHBseUZvcmNlKFZlY3RvcjIgZm9yY2UpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBBcHBseUZvcmNlKHJlZiBmb3JjZSwgcmVmIFhmLlBvc2l0aW9uKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gQXBwbHkgYSBmb3JjZSBhdCBhIHdvcmxkIHBvaW50LiBJZiB0aGUgZm9yY2UgaXMgbm90XHJcbiAgICAgICAgLy8vIGFwcGxpZWQgYXQgdGhlIGNlbnRlciBvZiBtYXNzLCBpdCB3aWxsIGdlbmVyYXRlIGEgdG9ycXVlIGFuZFxyXG4gICAgICAgIC8vLyBhZmZlY3QgdGhlIGFuZ3VsYXIgdmVsb2NpdHkuIFRoaXMgd2FrZXMgdXAgdGhlIGJvZHkuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJmb3JjZVwiPlRoZSB3b3JsZCBmb3JjZSB2ZWN0b3IsIHVzdWFsbHkgaW4gTmV3dG9ucyAoTikuPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJwb2ludFwiPlRoZSB3b3JsZCBwb3NpdGlvbiBvZiB0aGUgcG9pbnQgb2YgYXBwbGljYXRpb24uPC9wYXJhbT5cclxuICAgICAgICBwdWJsaWMgdm9pZCBBcHBseUZvcmNlKHJlZiBWZWN0b3IyIGZvcmNlLCByZWYgVmVjdG9yMiBwb2ludClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIERlYnVnLkFzc2VydCghZmxvYXQuSXNOYU4oZm9yY2UuWCkpO1xyXG4gICAgICAgICAgICBEZWJ1Zy5Bc3NlcnQoIWZsb2F0LklzTmFOKGZvcmNlLlkpKTtcclxuICAgICAgICAgICAgRGVidWcuQXNzZXJ0KCFmbG9hdC5Jc05hTihwb2ludC5YKSk7XHJcbiAgICAgICAgICAgIERlYnVnLkFzc2VydCghZmxvYXQuSXNOYU4ocG9pbnQuWSkpO1xyXG5cclxuICAgICAgICAgICAgaWYgKF9ib2R5VHlwZSA9PSBCb2R5VHlwZS5EeW5hbWljKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBpZiAoQXdha2UgPT0gZmFsc2UpXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgQXdha2UgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIEZvcmNlICs9IGZvcmNlO1xyXG4gICAgICAgICAgICAgICAgVG9ycXVlICs9IChwb2ludC5YIC0gU3dlZXAuQy5YKSAqIGZvcmNlLlkgLSAocG9pbnQuWSAtIFN3ZWVwLkMuWSkgKiBmb3JjZS5YO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIEFwcGx5IGEgdG9ycXVlLiBUaGlzIGFmZmVjdHMgdGhlIGFuZ3VsYXIgdmVsb2NpdHlcclxuICAgICAgICAvLy8gd2l0aG91dCBhZmZlY3RpbmcgdGhlIGxpbmVhciB2ZWxvY2l0eSBvZiB0aGUgY2VudGVyIG9mIG1hc3MuXHJcbiAgICAgICAgLy8vIFRoaXMgd2FrZXMgdXAgdGhlIGJvZHkuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJ0b3JxdWVcIj5UaGUgdG9ycXVlIGFib3V0IHRoZSB6LWF4aXMgKG91dCBvZiB0aGUgc2NyZWVuKSwgdXN1YWxseSBpbiBOLW0uPC9wYXJhbT5cclxuICAgICAgICBwdWJsaWMgdm9pZCBBcHBseVRvcnF1ZShmbG9hdCB0b3JxdWUpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBEZWJ1Zy5Bc3NlcnQoIWZsb2F0LklzTmFOKHRvcnF1ZSkpO1xyXG5cclxuICAgICAgICAgICAgaWYgKF9ib2R5VHlwZSA9PSBCb2R5VHlwZS5EeW5hbWljKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBpZiAoQXdha2UgPT0gZmFsc2UpXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgQXdha2UgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIFRvcnF1ZSArPSB0b3JxdWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gQXBwbHkgYW4gaW1wdWxzZSBhdCBhIHBvaW50LiBUaGlzIGltbWVkaWF0ZWx5IG1vZGlmaWVzIHRoZSB2ZWxvY2l0eS5cclxuICAgICAgICAvLy8gVGhpcyB3YWtlcyB1cCB0aGUgYm9keS5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cImltcHVsc2VcIj5UaGUgd29ybGQgaW1wdWxzZSB2ZWN0b3IsIHVzdWFsbHkgaW4gTi1zZWNvbmRzIG9yIGtnLW0vcy48L3BhcmFtPlxyXG4gICAgICAgIHB1YmxpYyB2b2lkIEFwcGx5TGluZWFySW1wdWxzZShWZWN0b3IyIGltcHVsc2UpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBBcHBseUxpbmVhckltcHVsc2UocmVmIGltcHVsc2UpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBBcHBseSBhbiBpbXB1bHNlIGF0IGEgcG9pbnQuIFRoaXMgaW1tZWRpYXRlbHkgbW9kaWZpZXMgdGhlIHZlbG9jaXR5LlxyXG4gICAgICAgIC8vLyBJdCBhbHNvIG1vZGlmaWVzIHRoZSBhbmd1bGFyIHZlbG9jaXR5IGlmIHRoZSBwb2ludCBvZiBhcHBsaWNhdGlvblxyXG4gICAgICAgIC8vLyBpcyBub3QgYXQgdGhlIGNlbnRlciBvZiBtYXNzLlxyXG4gICAgICAgIC8vLyBUaGlzIHdha2VzIHVwIHRoZSBib2R5LlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwiaW1wdWxzZVwiPlRoZSB3b3JsZCBpbXB1bHNlIHZlY3RvciwgdXN1YWxseSBpbiBOLXNlY29uZHMgb3Iga2ctbS9zLjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwicG9pbnRcIj5UaGUgd29ybGQgcG9zaXRpb24gb2YgdGhlIHBvaW50IG9mIGFwcGxpY2F0aW9uLjwvcGFyYW0+XHJcbiAgICAgICAgcHVibGljIHZvaWQgQXBwbHlMaW5lYXJJbXB1bHNlKFZlY3RvcjIgaW1wdWxzZSwgVmVjdG9yMiBwb2ludClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIEFwcGx5TGluZWFySW1wdWxzZShyZWYgaW1wdWxzZSwgcmVmIHBvaW50KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gQXBwbHkgYW4gaW1wdWxzZSBhdCBhIHBvaW50LiBUaGlzIGltbWVkaWF0ZWx5IG1vZGlmaWVzIHRoZSB2ZWxvY2l0eS5cclxuICAgICAgICAvLy8gVGhpcyB3YWtlcyB1cCB0aGUgYm9keS5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cImltcHVsc2VcIj5UaGUgd29ybGQgaW1wdWxzZSB2ZWN0b3IsIHVzdWFsbHkgaW4gTi1zZWNvbmRzIG9yIGtnLW0vcy48L3BhcmFtPlxyXG4gICAgICAgIHB1YmxpYyB2b2lkIEFwcGx5TGluZWFySW1wdWxzZShyZWYgVmVjdG9yMiBpbXB1bHNlKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgaWYgKF9ib2R5VHlwZSAhPSBCb2R5VHlwZS5EeW5hbWljKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKEF3YWtlID09IGZhbHNlKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBBd2FrZSA9IHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgTGluZWFyVmVsb2NpdHlJbnRlcm5hbCArPSBJbnZNYXNzICogaW1wdWxzZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gQXBwbHkgYW4gaW1wdWxzZSBhdCBhIHBvaW50LiBUaGlzIGltbWVkaWF0ZWx5IG1vZGlmaWVzIHRoZSB2ZWxvY2l0eS5cclxuICAgICAgICAvLy8gSXQgYWxzbyBtb2RpZmllcyB0aGUgYW5ndWxhciB2ZWxvY2l0eSBpZiB0aGUgcG9pbnQgb2YgYXBwbGljYXRpb25cclxuICAgICAgICAvLy8gaXMgbm90IGF0IHRoZSBjZW50ZXIgb2YgbWFzcy5cclxuICAgICAgICAvLy8gVGhpcyB3YWtlcyB1cCB0aGUgYm9keS5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cImltcHVsc2VcIj5UaGUgd29ybGQgaW1wdWxzZSB2ZWN0b3IsIHVzdWFsbHkgaW4gTi1zZWNvbmRzIG9yIGtnLW0vcy48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cInBvaW50XCI+VGhlIHdvcmxkIHBvc2l0aW9uIG9mIHRoZSBwb2ludCBvZiBhcHBsaWNhdGlvbi48L3BhcmFtPlxyXG4gICAgICAgIHB1YmxpYyB2b2lkIEFwcGx5TGluZWFySW1wdWxzZShyZWYgVmVjdG9yMiBpbXB1bHNlLCByZWYgVmVjdG9yMiBwb2ludClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGlmIChfYm9keVR5cGUgIT0gQm9keVR5cGUuRHluYW1pYylcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuXHJcbiAgICAgICAgICAgIGlmIChBd2FrZSA9PSBmYWxzZSlcclxuICAgICAgICAgICAgICAgIEF3YWtlID0gdHJ1ZTtcclxuXHJcbiAgICAgICAgICAgIExpbmVhclZlbG9jaXR5SW50ZXJuYWwgKz0gSW52TWFzcyAqIGltcHVsc2U7XHJcbiAgICAgICAgICAgIEFuZ3VsYXJWZWxvY2l0eUludGVybmFsICs9IEludkkgKiAoKHBvaW50LlggLSBTd2VlcC5DLlgpICogaW1wdWxzZS5ZIC0gKHBvaW50LlkgLSBTd2VlcC5DLlkpICogaW1wdWxzZS5YKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gQXBwbHkgYW4gYW5ndWxhciBpbXB1bHNlLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwiaW1wdWxzZVwiPlRoZSBhbmd1bGFyIGltcHVsc2UgaW4gdW5pdHMgb2Yga2cqbSptL3MuPC9wYXJhbT5cclxuICAgICAgICBwdWJsaWMgdm9pZCBBcHBseUFuZ3VsYXJJbXB1bHNlKGZsb2F0IGltcHVsc2UpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBpZiAoX2JvZHlUeXBlICE9IEJvZHlUeXBlLkR5bmFtaWMpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKEF3YWtlID09IGZhbHNlKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBBd2FrZSA9IHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIEFuZ3VsYXJWZWxvY2l0eUludGVybmFsICs9IEludkkgKiBpbXB1bHNlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBUaGlzIHJlc2V0cyB0aGUgbWFzcyBwcm9wZXJ0aWVzIHRvIHRoZSBzdW0gb2YgdGhlIG1hc3MgcHJvcGVydGllcyBvZiB0aGUgZml4dHVyZXMuXHJcbiAgICAgICAgLy8vIFRoaXMgbm9ybWFsbHkgZG9lcyBub3QgbmVlZCB0byBiZSBjYWxsZWQgdW5sZXNzIHlvdSBjYWxsZWQgU2V0TWFzc0RhdGEgdG8gb3ZlcnJpZGVcclxuICAgICAgICAvLy8gdGhlIG1hc3MgYW5kIHlvdSBsYXRlciB3YW50IHRvIHJlc2V0IHRoZSBtYXNzLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgcHVibGljIHZvaWQgUmVzZXRNYXNzRGF0YSgpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICAvLyBDb21wdXRlIG1hc3MgZGF0YSBmcm9tIHNoYXBlcy4gRWFjaCBzaGFwZSBoYXMgaXRzIG93biBkZW5zaXR5LlxyXG4gICAgICAgICAgICBfbWFzcyA9IDAuMGY7XHJcbiAgICAgICAgICAgIEludk1hc3MgPSAwLjBmO1xyXG4gICAgICAgICAgICBfaW5lcnRpYSA9IDAuMGY7XHJcbiAgICAgICAgICAgIEludkkgPSAwLjBmO1xyXG4gICAgICAgICAgICBTd2VlcC5Mb2NhbENlbnRlciA9IFZlY3RvcjIuWmVybztcclxuXHJcbiAgICAgICAgICAgIC8vIEtpbmVtYXRpYyBib2RpZXMgaGF2ZSB6ZXJvIG1hc3MuXHJcbiAgICAgICAgICAgIGlmIChCb2R5VHlwZSA9PSBCb2R5VHlwZS5LaW5lbWF0aWMpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIFN3ZWVwLkMwID0gU3dlZXAuQyA9IFhmLlBvc2l0aW9uO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBEZWJ1Zy5Bc3NlcnQoQm9keVR5cGUgPT0gQm9keVR5cGUuRHluYW1pYyB8fCBCb2R5VHlwZSA9PSBCb2R5VHlwZS5TdGF0aWMpO1xyXG5cclxuICAgICAgICAgICAgLy8gQWNjdW11bGF0ZSBtYXNzIG92ZXIgYWxsIGZpeHR1cmVzLlxyXG4gICAgICAgICAgICBWZWN0b3IyIGNlbnRlciA9IFZlY3RvcjIuWmVybztcclxuICAgICAgICAgICAgZm9yZWFjaCAoRml4dHVyZSBmIGluIEZpeHR1cmVMaXN0KVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBpZiAoZi5TaGFwZS5fZGVuc2l0eSA9PSAwKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIE1hc3NEYXRhIG1hc3NEYXRhID0gZi5TaGFwZS5NYXNzRGF0YTtcclxuICAgICAgICAgICAgICAgIF9tYXNzICs9IG1hc3NEYXRhLk1hc3M7XHJcbiAgICAgICAgICAgICAgICBjZW50ZXIgKz0gbWFzc0RhdGEuTWFzcyAqIG1hc3NEYXRhLkNlbnRyb2lkO1xyXG4gICAgICAgICAgICAgICAgX2luZXJ0aWEgKz0gbWFzc0RhdGEuSW5lcnRpYTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy9TdGF0aWMgYm9kaWVzIG9ubHkgaGF2ZSBtYXNzLCB0aGV5IGRvbid0IGhhdmUgb3RoZXIgcHJvcGVydGllcy4gQSBsaXR0bGUgaGFja3kgdGhvLi4uXHJcbiAgICAgICAgICAgIGlmIChCb2R5VHlwZSA9PSBCb2R5VHlwZS5TdGF0aWMpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIFN3ZWVwLkMwID0gU3dlZXAuQyA9IFhmLlBvc2l0aW9uO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBDb21wdXRlIGNlbnRlciBvZiBtYXNzLlxyXG4gICAgICAgICAgICBpZiAoX21hc3MgPiAwLjBmKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBJbnZNYXNzID0gMS4wZiAvIF9tYXNzO1xyXG4gICAgICAgICAgICAgICAgY2VudGVyICo9IEludk1hc3M7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAvLyBGb3JjZSBhbGwgZHluYW1pYyBib2RpZXMgdG8gaGF2ZSBhIHBvc2l0aXZlIG1hc3MuXHJcbiAgICAgICAgICAgICAgICBfbWFzcyA9IDEuMGY7XHJcbiAgICAgICAgICAgICAgICBJbnZNYXNzID0gMS4wZjtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKF9pbmVydGlhID4gMC4wZiAmJiAoRmxhZ3MgJiBCb2R5RmxhZ3MuRml4ZWRSb3RhdGlvbikgPT0gMClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgLy8gQ2VudGVyIHRoZSBpbmVydGlhIGFib3V0IHRoZSBjZW50ZXIgb2YgbWFzcy5cclxuICAgICAgICAgICAgICAgIF9pbmVydGlhIC09IF9tYXNzICogVmVjdG9yMi5Eb3QoY2VudGVyLCBjZW50ZXIpO1xyXG5cclxuICAgICAgICAgICAgICAgIERlYnVnLkFzc2VydChfaW5lcnRpYSA+IDAuMGYpO1xyXG4gICAgICAgICAgICAgICAgSW52SSA9IDEuMGYgLyBfaW5lcnRpYTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIF9pbmVydGlhID0gMC4wZjtcclxuICAgICAgICAgICAgICAgIEludkkgPSAwLjBmO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBNb3ZlIGNlbnRlciBvZiBtYXNzLlxyXG4gICAgICAgICAgICBWZWN0b3IyIG9sZENlbnRlciA9IFN3ZWVwLkM7XHJcbiAgICAgICAgICAgIFN3ZWVwLkxvY2FsQ2VudGVyID0gY2VudGVyO1xyXG4gICAgICAgICAgICBTd2VlcC5DMCA9IFN3ZWVwLkMgPSBNYXRoVXRpbHMuTXVsdGlwbHkocmVmIFhmLCByZWYgU3dlZXAuTG9jYWxDZW50ZXIpO1xyXG5cclxuICAgICAgICAgICAgLy8gVXBkYXRlIGNlbnRlciBvZiBtYXNzIHZlbG9jaXR5LlxyXG4gICAgICAgICAgICBWZWN0b3IyIGEgPSBTd2VlcC5DIC0gb2xkQ2VudGVyO1xyXG4gICAgICAgICAgICBMaW5lYXJWZWxvY2l0eUludGVybmFsICs9IG5ldyBWZWN0b3IyKC1Bbmd1bGFyVmVsb2NpdHlJbnRlcm5hbCAqIGEuWSwgQW5ndWxhclZlbG9jaXR5SW50ZXJuYWwgKiBhLlgpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBHZXQgdGhlIHdvcmxkIGNvb3JkaW5hdGVzIG9mIGEgcG9pbnQgZ2l2ZW4gdGhlIGxvY2FsIGNvb3JkaW5hdGVzLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwibG9jYWxQb2ludFwiPkEgcG9pbnQgb24gdGhlIGJvZHkgbWVhc3VyZWQgcmVsYXRpdmUgdGhlIHRoZSBib2R5J3Mgb3JpZ2luLjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxyZXR1cm5zPlRoZSBzYW1lIHBvaW50IGV4cHJlc3NlZCBpbiB3b3JsZCBjb29yZGluYXRlcy48L3JldHVybnM+XHJcbiAgICAgICAgcHVibGljIFZlY3RvcjIgR2V0V29ybGRQb2ludChyZWYgVmVjdG9yMiBsb2NhbFBvaW50KVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBWZWN0b3IyKFhmLlBvc2l0aW9uLlggKyBYZi5SLkNvbDEuWCAqIGxvY2FsUG9pbnQuWCArIFhmLlIuQ29sMi5YICogbG9jYWxQb2ludC5ZLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgWGYuUG9zaXRpb24uWSArIFhmLlIuQ29sMS5ZICogbG9jYWxQb2ludC5YICsgWGYuUi5Db2wyLlkgKiBsb2NhbFBvaW50LlkpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBHZXQgdGhlIHdvcmxkIGNvb3JkaW5hdGVzIG9mIGEgcG9pbnQgZ2l2ZW4gdGhlIGxvY2FsIGNvb3JkaW5hdGVzLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwibG9jYWxQb2ludFwiPkEgcG9pbnQgb24gdGhlIGJvZHkgbWVhc3VyZWQgcmVsYXRpdmUgdGhlIHRoZSBib2R5J3Mgb3JpZ2luLjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxyZXR1cm5zPlRoZSBzYW1lIHBvaW50IGV4cHJlc3NlZCBpbiB3b3JsZCBjb29yZGluYXRlcy48L3JldHVybnM+XHJcbiAgICAgICAgcHVibGljIFZlY3RvcjIgR2V0V29ybGRQb2ludChWZWN0b3IyIGxvY2FsUG9pbnQpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gR2V0V29ybGRQb2ludChyZWYgbG9jYWxQb2ludCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIEdldCB0aGUgd29ybGQgY29vcmRpbmF0ZXMgb2YgYSB2ZWN0b3IgZ2l2ZW4gdGhlIGxvY2FsIGNvb3JkaW5hdGVzLlxyXG4gICAgICAgIC8vLyBOb3RlIHRoYXQgdGhlIHZlY3RvciBvbmx5IHRha2VzIHRoZSByb3RhdGlvbiBpbnRvIGFjY291bnQsIG5vdCB0aGUgcG9zaXRpb24uXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJsb2NhbFZlY3RvclwiPkEgdmVjdG9yIGZpeGVkIGluIHRoZSBib2R5LjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxyZXR1cm5zPlRoZSBzYW1lIHZlY3RvciBleHByZXNzZWQgaW4gd29ybGQgY29vcmRpbmF0ZXMuPC9yZXR1cm5zPlxyXG4gICAgICAgIHB1YmxpYyBWZWN0b3IyIEdldFdvcmxkVmVjdG9yKHJlZiBWZWN0b3IyIGxvY2FsVmVjdG9yKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBWZWN0b3IyKFhmLlIuQ29sMS5YICogbG9jYWxWZWN0b3IuWCArIFhmLlIuQ29sMi5YICogbG9jYWxWZWN0b3IuWSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFhmLlIuQ29sMS5ZICogbG9jYWxWZWN0b3IuWCArIFhmLlIuQ29sMi5ZICogbG9jYWxWZWN0b3IuWSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIEdldCB0aGUgd29ybGQgY29vcmRpbmF0ZXMgb2YgYSB2ZWN0b3IgZ2l2ZW4gdGhlIGxvY2FsIGNvb3JkaW5hdGVzLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwibG9jYWxWZWN0b3JcIj5BIHZlY3RvciBmaXhlZCBpbiB0aGUgYm9keS48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cmV0dXJucz5UaGUgc2FtZSB2ZWN0b3IgZXhwcmVzc2VkIGluIHdvcmxkIGNvb3JkaW5hdGVzLjwvcmV0dXJucz5cclxuICAgICAgICBwdWJsaWMgVmVjdG9yMiBHZXRXb3JsZFZlY3RvcihWZWN0b3IyIGxvY2FsVmVjdG9yKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIEdldFdvcmxkVmVjdG9yKHJlZiBsb2NhbFZlY3Rvcik7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIEdldHMgYSBsb2NhbCBwb2ludCByZWxhdGl2ZSB0byB0aGUgYm9keSdzIG9yaWdpbiBnaXZlbiBhIHdvcmxkIHBvaW50LlxyXG4gICAgICAgIC8vLyBOb3RlIHRoYXQgdGhlIHZlY3RvciBvbmx5IHRha2VzIHRoZSByb3RhdGlvbiBpbnRvIGFjY291bnQsIG5vdCB0aGUgcG9zaXRpb24uXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJ3b3JsZFBvaW50XCI+QSBwb2ludCBpbiB3b3JsZCBjb29yZGluYXRlcy48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cmV0dXJucz5UaGUgY29ycmVzcG9uZGluZyBsb2NhbCBwb2ludCByZWxhdGl2ZSB0byB0aGUgYm9keSdzIG9yaWdpbi48L3JldHVybnM+XHJcbiAgICAgICAgcHVibGljIFZlY3RvcjIgR2V0TG9jYWxQb2ludChyZWYgVmVjdG9yMiB3b3JsZFBvaW50KVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuXHJcbiAgICAgICAgICAgICAgICBuZXcgVmVjdG9yMigod29ybGRQb2ludC5YIC0gWGYuUG9zaXRpb24uWCkgKiBYZi5SLkNvbDEuWCArICh3b3JsZFBvaW50LlkgLSBYZi5Qb3NpdGlvbi5ZKSAqIFhmLlIuQ29sMS5ZLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKHdvcmxkUG9pbnQuWCAtIFhmLlBvc2l0aW9uLlgpICogWGYuUi5Db2wyLlggKyAod29ybGRQb2ludC5ZIC0gWGYuUG9zaXRpb24uWSkgKiBYZi5SLkNvbDIuWSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIEdldHMgYSBsb2NhbCBwb2ludCByZWxhdGl2ZSB0byB0aGUgYm9keSdzIG9yaWdpbiBnaXZlbiBhIHdvcmxkIHBvaW50LlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwid29ybGRQb2ludFwiPkEgcG9pbnQgaW4gd29ybGQgY29vcmRpbmF0ZXMuPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHJldHVybnM+VGhlIGNvcnJlc3BvbmRpbmcgbG9jYWwgcG9pbnQgcmVsYXRpdmUgdG8gdGhlIGJvZHkncyBvcmlnaW4uPC9yZXR1cm5zPlxyXG4gICAgICAgIHB1YmxpYyBWZWN0b3IyIEdldExvY2FsUG9pbnQoVmVjdG9yMiB3b3JsZFBvaW50KVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIEdldExvY2FsUG9pbnQocmVmIHdvcmxkUG9pbnQpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBHZXRzIGEgbG9jYWwgdmVjdG9yIGdpdmVuIGEgd29ybGQgdmVjdG9yLlxyXG4gICAgICAgIC8vLyBOb3RlIHRoYXQgdGhlIHZlY3RvciBvbmx5IHRha2VzIHRoZSByb3RhdGlvbiBpbnRvIGFjY291bnQsIG5vdCB0aGUgcG9zaXRpb24uXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJ3b3JsZFZlY3RvclwiPkEgdmVjdG9yIGluIHdvcmxkIGNvb3JkaW5hdGVzLjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxyZXR1cm5zPlRoZSBjb3JyZXNwb25kaW5nIGxvY2FsIHZlY3Rvci48L3JldHVybnM+XHJcbiAgICAgICAgcHVibGljIFZlY3RvcjIgR2V0TG9jYWxWZWN0b3IocmVmIFZlY3RvcjIgd29ybGRWZWN0b3IpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IFZlY3RvcjIod29ybGRWZWN0b3IuWCAqIFhmLlIuQ29sMS5YICsgd29ybGRWZWN0b3IuWSAqIFhmLlIuQ29sMS5ZLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd29ybGRWZWN0b3IuWCAqIFhmLlIuQ29sMi5YICsgd29ybGRWZWN0b3IuWSAqIFhmLlIuQ29sMi5ZKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gR2V0cyBhIGxvY2FsIHZlY3RvciBnaXZlbiBhIHdvcmxkIHZlY3Rvci5cclxuICAgICAgICAvLy8gTm90ZSB0aGF0IHRoZSB2ZWN0b3Igb25seSB0YWtlcyB0aGUgcm90YXRpb24gaW50byBhY2NvdW50LCBub3QgdGhlIHBvc2l0aW9uLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwid29ybGRWZWN0b3JcIj5BIHZlY3RvciBpbiB3b3JsZCBjb29yZGluYXRlcy48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cmV0dXJucz5UaGUgY29ycmVzcG9uZGluZyBsb2NhbCB2ZWN0b3IuPC9yZXR1cm5zPlxyXG4gICAgICAgIHB1YmxpYyBWZWN0b3IyIEdldExvY2FsVmVjdG9yKFZlY3RvcjIgd29ybGRWZWN0b3IpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gR2V0TG9jYWxWZWN0b3IocmVmIHdvcmxkVmVjdG9yKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gR2V0IHRoZSB3b3JsZCBsaW5lYXIgdmVsb2NpdHkgb2YgYSB3b3JsZCBwb2ludCBhdHRhY2hlZCB0byB0aGlzIGJvZHkuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJ3b3JsZFBvaW50XCI+QSBwb2ludCBpbiB3b3JsZCBjb29yZGluYXRlcy48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cmV0dXJucz5UaGUgd29ybGQgdmVsb2NpdHkgb2YgYSBwb2ludC48L3JldHVybnM+XHJcbiAgICAgICAgcHVibGljIFZlY3RvcjIgR2V0TGluZWFyVmVsb2NpdHlGcm9tV29ybGRQb2ludChWZWN0b3IyIHdvcmxkUG9pbnQpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gR2V0TGluZWFyVmVsb2NpdHlGcm9tV29ybGRQb2ludChyZWYgd29ybGRQb2ludCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIEdldCB0aGUgd29ybGQgbGluZWFyIHZlbG9jaXR5IG9mIGEgd29ybGQgcG9pbnQgYXR0YWNoZWQgdG8gdGhpcyBib2R5LlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwid29ybGRQb2ludFwiPkEgcG9pbnQgaW4gd29ybGQgY29vcmRpbmF0ZXMuPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHJldHVybnM+VGhlIHdvcmxkIHZlbG9jaXR5IG9mIGEgcG9pbnQuPC9yZXR1cm5zPlxyXG4gICAgICAgIHB1YmxpYyBWZWN0b3IyIEdldExpbmVhclZlbG9jaXR5RnJvbVdvcmxkUG9pbnQocmVmIFZlY3RvcjIgd29ybGRQb2ludClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiBMaW5lYXJWZWxvY2l0eUludGVybmFsICtcclxuICAgICAgICAgICAgICAgICAgIG5ldyBWZWN0b3IyKC1Bbmd1bGFyVmVsb2NpdHlJbnRlcm5hbCAqICh3b3JsZFBvaW50LlkgLSBTd2VlcC5DLlkpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgQW5ndWxhclZlbG9jaXR5SW50ZXJuYWwgKiAod29ybGRQb2ludC5YIC0gU3dlZXAuQy5YKSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIEdldCB0aGUgd29ybGQgdmVsb2NpdHkgb2YgYSBsb2NhbCBwb2ludC5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cImxvY2FsUG9pbnRcIj5BIHBvaW50IGluIGxvY2FsIGNvb3JkaW5hdGVzLjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxyZXR1cm5zPlRoZSB3b3JsZCB2ZWxvY2l0eSBvZiBhIHBvaW50LjwvcmV0dXJucz5cclxuICAgICAgICBwdWJsaWMgVmVjdG9yMiBHZXRMaW5lYXJWZWxvY2l0eUZyb21Mb2NhbFBvaW50KFZlY3RvcjIgbG9jYWxQb2ludClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiBHZXRMaW5lYXJWZWxvY2l0eUZyb21Mb2NhbFBvaW50KHJlZiBsb2NhbFBvaW50KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gR2V0IHRoZSB3b3JsZCB2ZWxvY2l0eSBvZiBhIGxvY2FsIHBvaW50LlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwibG9jYWxQb2ludFwiPkEgcG9pbnQgaW4gbG9jYWwgY29vcmRpbmF0ZXMuPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHJldHVybnM+VGhlIHdvcmxkIHZlbG9jaXR5IG9mIGEgcG9pbnQuPC9yZXR1cm5zPlxyXG4gICAgICAgIHB1YmxpYyBWZWN0b3IyIEdldExpbmVhclZlbG9jaXR5RnJvbUxvY2FsUG9pbnQocmVmIFZlY3RvcjIgbG9jYWxQb2ludClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiBHZXRMaW5lYXJWZWxvY2l0eUZyb21Xb3JsZFBvaW50KEdldFdvcmxkUG9pbnQocmVmIGxvY2FsUG9pbnQpKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHB1YmxpYyBCb2R5IERlZXBDbG9uZSgpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBCb2R5IGJvZHkgPSBDbG9uZSgpO1xyXG5cclxuICAgICAgICAgICAgZm9yIChpbnQgaSA9IDA7IGkgPCBGaXh0dXJlTGlzdC5Db3VudDsgaSsrKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBGaXh0dXJlTGlzdFtpXS5DbG9uZShib2R5KTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuIGJvZHk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwdWJsaWMgQm9keSBDbG9uZSgpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBCb2R5IGJvZHkgPSBuZXcgQm9keSgpO1xyXG4gICAgICAgICAgICBib2R5LldvcmxkID0gV29ybGQ7XHJcbiAgICAgICAgICAgIGJvZHkuVXNlckRhdGEgPSBVc2VyRGF0YTtcclxuICAgICAgICAgICAgYm9keS5MaW5lYXJEYW1waW5nID0gTGluZWFyRGFtcGluZztcclxuICAgICAgICAgICAgYm9keS5MaW5lYXJWZWxvY2l0eUludGVybmFsID0gTGluZWFyVmVsb2NpdHlJbnRlcm5hbDtcclxuICAgICAgICAgICAgYm9keS5Bbmd1bGFyRGFtcGluZyA9IEFuZ3VsYXJEYW1waW5nO1xyXG4gICAgICAgICAgICBib2R5LkFuZ3VsYXJWZWxvY2l0eUludGVybmFsID0gQW5ndWxhclZlbG9jaXR5SW50ZXJuYWw7XHJcbiAgICAgICAgICAgIGJvZHkuUG9zaXRpb24gPSBQb3NpdGlvbjtcclxuICAgICAgICAgICAgYm9keS5Sb3RhdGlvbiA9IFJvdGF0aW9uO1xyXG4gICAgICAgICAgICBib2R5Ll9ib2R5VHlwZSA9IF9ib2R5VHlwZTtcclxuICAgICAgICAgICAgYm9keS5GbGFncyA9IEZsYWdzO1xyXG5cclxuICAgICAgICAgICAgV29ybGQuQWRkQm9keShib2R5KTtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiBib2R5O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaW50ZXJuYWwgdm9pZCBTeW5jaHJvbml6ZUZpeHR1cmVzKClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIFRyYW5zZm9ybSB4ZjEgPSBuZXcgVHJhbnNmb3JtKCk7XHJcbiAgICAgICAgICAgIGZsb2F0IGMgPSAoZmxvYXQpTWF0aC5Db3MoU3dlZXAuQTApLCBzID0gKGZsb2F0KU1hdGguU2luKFN3ZWVwLkEwKTtcclxuICAgICAgICAgICAgeGYxLlIuQ29sMS5YID0gYztcclxuICAgICAgICAgICAgeGYxLlIuQ29sMi5YID0gLXM7XHJcbiAgICAgICAgICAgIHhmMS5SLkNvbDEuWSA9IHM7XHJcbiAgICAgICAgICAgIHhmMS5SLkNvbDIuWSA9IGM7XHJcblxyXG4gICAgICAgICAgICB4ZjEuUG9zaXRpb24uWCA9IFN3ZWVwLkMwLlggLSAoeGYxLlIuQ29sMS5YICogU3dlZXAuTG9jYWxDZW50ZXIuWCArIHhmMS5SLkNvbDIuWCAqIFN3ZWVwLkxvY2FsQ2VudGVyLlkpO1xyXG4gICAgICAgICAgICB4ZjEuUG9zaXRpb24uWSA9IFN3ZWVwLkMwLlkgLSAoeGYxLlIuQ29sMS5ZICogU3dlZXAuTG9jYWxDZW50ZXIuWCArIHhmMS5SLkNvbDIuWSAqIFN3ZWVwLkxvY2FsQ2VudGVyLlkpO1xyXG5cclxuICAgICAgICAgICAgSUJyb2FkUGhhc2UgYnJvYWRQaGFzZSA9IFdvcmxkLkNvbnRhY3RNYW5hZ2VyLkJyb2FkUGhhc2U7XHJcbiAgICAgICAgICAgIGZvciAoaW50IGkgPSAwOyBpIDwgRml4dHVyZUxpc3QuQ291bnQ7IGkrKylcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgRml4dHVyZUxpc3RbaV0uU3luY2hyb25pemUoYnJvYWRQaGFzZSwgcmVmIHhmMSwgcmVmIFhmKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaW50ZXJuYWwgdm9pZCBTeW5jaHJvbml6ZVRyYW5zZm9ybSgpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBYZi5SLlNldChTd2VlcC5BKTtcclxuXHJcbiAgICAgICAgICAgIGZsb2F0IHZ4ID0gWGYuUi5Db2wxLlggKiBTd2VlcC5Mb2NhbENlbnRlci5YICsgWGYuUi5Db2wyLlggKiBTd2VlcC5Mb2NhbENlbnRlci5ZO1xyXG4gICAgICAgICAgICBmbG9hdCB2eSA9IFhmLlIuQ29sMS5ZICogU3dlZXAuTG9jYWxDZW50ZXIuWCArIFhmLlIuQ29sMi5ZICogU3dlZXAuTG9jYWxDZW50ZXIuWTtcclxuXHJcbiAgICAgICAgICAgIFhmLlBvc2l0aW9uLlggPSBTd2VlcC5DLlggLSB2eDtcclxuICAgICAgICAgICAgWGYuUG9zaXRpb24uWSA9IFN3ZWVwLkMuWSAtIHZ5O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBUaGlzIGlzIHVzZWQgdG8gcHJldmVudCBjb25uZWN0ZWQgYm9kaWVzIGZyb20gY29sbGlkaW5nLlxyXG4gICAgICAgIC8vLyBJdCBtYXkgbGllLCBkZXBlbmRpbmcgb24gdGhlIGNvbGxpZGVDb25uZWN0ZWQgZmxhZy5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cIm90aGVyXCI+VGhlIG90aGVyIGJvZHkuPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHJldHVybnM+PC9yZXR1cm5zPlxyXG4gICAgICAgIGludGVybmFsIGJvb2wgU2hvdWxkQ29sbGlkZShCb2R5IG90aGVyKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgLy8gQXQgbGVhc3Qgb25lIGJvZHkgc2hvdWxkIGJlIGR5bmFtaWMuXHJcbiAgICAgICAgICAgIGlmIChfYm9keVR5cGUgIT0gQm9keVR5cGUuRHluYW1pYyAmJiBvdGhlci5fYm9keVR5cGUgIT0gQm9keVR5cGUuRHluYW1pYylcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBEb2VzIGEgam9pbnQgcHJldmVudCBjb2xsaXNpb24/XHJcbiAgICAgICAgICAgIGZvciAoSm9pbnRFZGdlIGpuID0gSm9pbnRMaXN0OyBqbiAhPSBudWxsOyBqbiA9IGpuLk5leHQpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGlmIChqbi5PdGhlciA9PSBvdGhlcilcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoam4uSm9pbnQuQ29sbGlkZUNvbm5lY3RlZCA9PSBmYWxzZSlcclxuICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaW50ZXJuYWwgdm9pZCBBZHZhbmNlKGZsb2F0IGFscGhhKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgLy8gQWR2YW5jZSB0byB0aGUgbmV3IHNhZmUgdGltZS5cclxuICAgICAgICAgICAgU3dlZXAuQWR2YW5jZShhbHBoYSk7XHJcbiAgICAgICAgICAgIFN3ZWVwLkMgPSBTd2VlcC5DMDtcclxuICAgICAgICAgICAgU3dlZXAuQSA9IFN3ZWVwLkEwO1xyXG4gICAgICAgICAgICBTeW5jaHJvbml6ZVRyYW5zZm9ybSgpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHVibGljIGV2ZW50IE9uQ29sbGlzaW9uRXZlbnRIYW5kbGVyIE9uQ29sbGlzaW9uXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBhZGRcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgZm9yIChpbnQgaSA9IDA7IGkgPCBGaXh0dXJlTGlzdC5Db3VudDsgaSsrKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIEZpeHR1cmVMaXN0W2ldLk9uQ29sbGlzaW9uICs9IHZhbHVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJlbW92ZVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBmb3IgKGludCBpID0gMDsgaSA8IEZpeHR1cmVMaXN0LkNvdW50OyBpKyspXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgRml4dHVyZUxpc3RbaV0uT25Db2xsaXNpb24gLT0gdmFsdWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHB1YmxpYyBldmVudCBPblNlcGFyYXRpb25FdmVudEhhbmRsZXIgT25TZXBhcmF0aW9uXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBhZGRcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgZm9yIChpbnQgaSA9IDA7IGkgPCBGaXh0dXJlTGlzdC5Db3VudDsgaSsrKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIEZpeHR1cmVMaXN0W2ldLk9uU2VwYXJhdGlvbiArPSB2YWx1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZW1vdmVcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgZm9yIChpbnQgaSA9IDA7IGkgPCBGaXh0dXJlTGlzdC5Db3VudDsgaSsrKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIEZpeHR1cmVMaXN0W2ldLk9uU2VwYXJhdGlvbiAtPSB2YWx1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHVibGljIHZvaWQgSWdub3JlQ29sbGlzaW9uV2l0aChCb2R5IG90aGVyKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgZm9yIChpbnQgaSA9IDA7IGkgPCBGaXh0dXJlTGlzdC5Db3VudDsgaSsrKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBGaXh0dXJlIGYgPSBGaXh0dXJlTGlzdFtpXTtcclxuICAgICAgICAgICAgICAgIGZvciAoaW50IGogPSAwOyBqIDwgb3RoZXIuRml4dHVyZUxpc3QuQ291bnQ7IGorKylcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBGaXh0dXJlIGYyID0gb3RoZXIuRml4dHVyZUxpc3Rbal07XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGYuSWdub3JlQ29sbGlzaW9uV2l0aChmMik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHB1YmxpYyB2b2lkIFJlc3RvcmVDb2xsaXNpb25XaXRoKEJvZHkgb3RoZXIpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBmb3IgKGludCBpID0gMDsgaSA8IEZpeHR1cmVMaXN0LkNvdW50OyBpKyspXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIEZpeHR1cmUgZiA9IEZpeHR1cmVMaXN0W2ldO1xyXG4gICAgICAgICAgICAgICAgZm9yIChpbnQgaiA9IDA7IGogPCBvdGhlci5GaXh0dXJlTGlzdC5Db3VudDsgaisrKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIEZpeHR1cmUgZjIgPSBvdGhlci5GaXh0dXJlTGlzdFtqXTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgZi5SZXN0b3JlQ29sbGlzaW9uV2l0aChmMik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbn0iLCJ1c2luZyBTeXN0ZW07XHJcbnVzaW5nIFN5c3RlbS5Db2xsZWN0aW9ucy5HZW5lcmljO1xyXG51c2luZyBGYXJzZWVyUGh5c2ljcy5Db2xsaXNpb24uU2hhcGVzO1xyXG51c2luZyBGYXJzZWVyUGh5c2ljcy5Db21tb247XHJcbnVzaW5nIEZhcnNlZXJQaHlzaWNzLkR5bmFtaWNzLkNvbnRhY3RzO1xyXG51c2luZyBGYXJzZWVyUGh5c2ljcy5GYWN0b3JpZXM7XHJcbnVzaW5nIE1pY3Jvc29mdC5YbmEuRnJhbWV3b3JrO1xyXG5cclxubmFtZXNwYWNlIEZhcnNlZXJQaHlzaWNzLkR5bmFtaWNzXHJcbntcclxuICAgIC8vLyA8c3VtbWFyeT5cclxuICAgIC8vLyBBIHR5cGUgb2YgYm9keSB0aGF0IHN1cHBvcnRzIG11bHRpcGxlIGZpeHR1cmVzIHRoYXQgY2FuIGJyZWFrIGFwYXJ0LlxyXG4gICAgLy8vIDwvc3VtbWFyeT5cclxuICAgIHB1YmxpYyBjbGFzcyBCcmVha2FibGVCb2R5XHJcbiAgICB7XHJcbiAgICAgICAgcHVibGljIGJvb2wgQnJva2VuO1xyXG4gICAgICAgIHB1YmxpYyBCb2R5IE1haW5Cb2R5O1xyXG4gICAgICAgIHB1YmxpYyBMaXN0PEZpeHR1cmU+IFBhcnRzID0gbmV3IExpc3Q8Rml4dHVyZT4oOCk7XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gVGhlIGZvcmNlIG5lZWRlZCB0byBicmVhayB0aGUgYm9keSBhcGFydC5cclxuICAgICAgICAvLy8gRGVmYXVsdDogNTAwXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICBwdWJsaWMgZmxvYXQgU3RyZW5ndGggPSA1MDAuMGY7XHJcblxyXG4gICAgICAgIHByaXZhdGUgZmxvYXRbXSBfYW5ndWxhclZlbG9jaXRpZXNDYWNoZSA9IG5ldyBmbG9hdFs4XTtcclxuICAgICAgICBwcml2YXRlIGJvb2wgX2JyZWFrO1xyXG4gICAgICAgIHByaXZhdGUgVmVjdG9yMltdIF92ZWxvY2l0aWVzQ2FjaGUgPSBuZXcgVmVjdG9yMls4XTtcclxuICAgICAgICBwcml2YXRlIFdvcmxkIF93b3JsZDtcclxuXHJcbiAgICAgICAgcHVibGljIEJyZWFrYWJsZUJvZHkoSUVudW1lcmFibGU8VmVydGljZXM+IHZlcnRpY2VzLCBXb3JsZCB3b3JsZCwgZmxvYXQgZGVuc2l0eSlcclxuICAgICAgICAgICAgOiB0aGlzKHZlcnRpY2VzLCB3b3JsZCwgZGVuc2l0eSwgbnVsbClcclxuICAgICAgICB7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwdWJsaWMgQnJlYWthYmxlQm9keShJRW51bWVyYWJsZTxWZXJ0aWNlcz4gdmVydGljZXMsIFdvcmxkIHdvcmxkLCBmbG9hdCBkZW5zaXR5LCBvYmplY3QgdXNlckRhdGEpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBfd29ybGQgPSB3b3JsZDtcclxuICAgICAgICAgICAgX3dvcmxkLkNvbnRhY3RNYW5hZ2VyLlBvc3RTb2x2ZSArPSBQb3N0U29sdmU7XHJcbiAgICAgICAgICAgIE1haW5Cb2R5ID0gbmV3IEJvZHkoX3dvcmxkKTtcclxuICAgICAgICAgICAgTWFpbkJvZHkuQm9keVR5cGUgPSBCb2R5VHlwZS5EeW5hbWljO1xyXG5cclxuICAgICAgICAgICAgZm9yZWFjaCAoVmVydGljZXMgcGFydCBpbiB2ZXJ0aWNlcylcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgUG9seWdvblNoYXBlIHBvbHlnb25TaGFwZSA9IG5ldyBQb2x5Z29uU2hhcGUocGFydCwgZGVuc2l0eSk7XHJcbiAgICAgICAgICAgICAgICBGaXh0dXJlIGZpeHR1cmUgPSBNYWluQm9keS5DcmVhdGVGaXh0dXJlKHBvbHlnb25TaGFwZSwgdXNlckRhdGEpO1xyXG4gICAgICAgICAgICAgICAgUGFydHMuQWRkKGZpeHR1cmUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwcml2YXRlIHZvaWQgUG9zdFNvbHZlKENvbnRhY3QgY29udGFjdCwgQ29udGFjdENvbnN0cmFpbnQgaW1wdWxzZSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGlmICghQnJva2VuKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBpZiAoUGFydHMuQ29udGFpbnMoY29udGFjdC5GaXh0dXJlQSkgfHwgUGFydHMuQ29udGFpbnMoY29udGFjdC5GaXh0dXJlQikpXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgZmxvYXQgbWF4SW1wdWxzZSA9IDAuMGY7XHJcbiAgICAgICAgICAgICAgICAgICAgaW50IGNvdW50ID0gY29udGFjdC5NYW5pZm9sZC5Qb2ludENvdW50O1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBmb3IgKGludCBpID0gMDsgaSA8IGNvdW50OyArK2kpXHJcbiAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBtYXhJbXB1bHNlID0gTWF0aC5NYXgobWF4SW1wdWxzZSwgaW1wdWxzZS5Qb2ludHNbaV0uTm9ybWFsSW1wdWxzZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZiAobWF4SW1wdWxzZSA+IFN0cmVuZ3RoKVxyXG4gICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gRmxhZyB0aGUgYm9keSBmb3IgYnJlYWtpbmcuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF9icmVhayA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwdWJsaWMgdm9pZCBVcGRhdGUoKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgaWYgKF9icmVhaylcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgRGVjb21wb3NlKCk7XHJcbiAgICAgICAgICAgICAgICBCcm9rZW4gPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgX2JyZWFrID0gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIENhY2hlIHZlbG9jaXRpZXMgdG8gaW1wcm92ZSBtb3ZlbWVudCBvbiBicmVha2FnZS5cclxuICAgICAgICAgICAgaWYgKEJyb2tlbiA9PSBmYWxzZSlcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgLy9FbmxhcmdlIHRoZSBjYWNoZSBpZiBuZWVkZWRcclxuICAgICAgICAgICAgICAgIGlmIChQYXJ0cy5Db3VudCA+IF9hbmd1bGFyVmVsb2NpdGllc0NhY2hlLkxlbmd0aClcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBfdmVsb2NpdGllc0NhY2hlID0gbmV3IFZlY3RvcjJbUGFydHMuQ291bnRdO1xyXG4gICAgICAgICAgICAgICAgICAgIF9hbmd1bGFyVmVsb2NpdGllc0NhY2hlID0gbmV3IGZsb2F0W1BhcnRzLkNvdW50XTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAvL0NhY2hlIHRoZSBsaW5lYXIgYW5kIGFuZ3VsYXIgdmVsb2NpdGllcy5cclxuICAgICAgICAgICAgICAgIGZvciAoaW50IGkgPSAwOyBpIDwgUGFydHMuQ291bnQ7IGkrKylcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBfdmVsb2NpdGllc0NhY2hlW2ldID0gUGFydHNbaV0uQm9keS5MaW5lYXJWZWxvY2l0eTtcclxuICAgICAgICAgICAgICAgICAgICBfYW5ndWxhclZlbG9jaXRpZXNDYWNoZVtpXSA9IFBhcnRzW2ldLkJvZHkuQW5ndWxhclZlbG9jaXR5O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwcml2YXRlIHZvaWQgRGVjb21wb3NlKClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIC8vVW5zdWJzcmliZSBmcm9tIHRoZSBQb3N0U29sdmUgZGVsZWdhdGVcclxuICAgICAgICAgICAgX3dvcmxkLkNvbnRhY3RNYW5hZ2VyLlBvc3RTb2x2ZSAtPSBQb3N0U29sdmU7XHJcblxyXG4gICAgICAgICAgICBmb3IgKGludCBpID0gMDsgaSA8IFBhcnRzLkNvdW50OyBpKyspXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIEZpeHR1cmUgZml4dHVyZSA9IFBhcnRzW2ldO1xyXG5cclxuICAgICAgICAgICAgICAgIFNoYXBlIHNoYXBlID0gZml4dHVyZS5TaGFwZS5DbG9uZSgpO1xyXG5cclxuICAgICAgICAgICAgICAgIG9iamVjdCB1c2VyZGF0YSA9IGZpeHR1cmUuVXNlckRhdGE7XHJcbiAgICAgICAgICAgICAgICBNYWluQm9keS5EZXN0cm95Rml4dHVyZShmaXh0dXJlKTtcclxuXHJcbiAgICAgICAgICAgICAgICBCb2R5IGJvZHkgPSBCb2R5RmFjdG9yeS5DcmVhdGVCb2R5KF93b3JsZCk7XHJcbiAgICAgICAgICAgICAgICBib2R5LkJvZHlUeXBlID0gQm9keVR5cGUuRHluYW1pYztcclxuICAgICAgICAgICAgICAgIGJvZHkuUG9zaXRpb24gPSBNYWluQm9keS5Qb3NpdGlvbjtcclxuICAgICAgICAgICAgICAgIGJvZHkuUm90YXRpb24gPSBNYWluQm9keS5Sb3RhdGlvbjtcclxuICAgICAgICAgICAgICAgIGJvZHkuVXNlckRhdGEgPSBNYWluQm9keS5Vc2VyRGF0YTtcclxuXHJcbiAgICAgICAgICAgICAgICBib2R5LkNyZWF0ZUZpeHR1cmUoc2hhcGUsIHVzZXJkYXRhKTtcclxuXHJcbiAgICAgICAgICAgICAgICBib2R5LkFuZ3VsYXJWZWxvY2l0eSA9IF9hbmd1bGFyVmVsb2NpdGllc0NhY2hlW2ldO1xyXG4gICAgICAgICAgICAgICAgYm9keS5MaW5lYXJWZWxvY2l0eSA9IF92ZWxvY2l0aWVzQ2FjaGVbaV07XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIF93b3JsZC5SZW1vdmVCb2R5KE1haW5Cb2R5KTtcclxuICAgICAgICAgICAgX3dvcmxkLlJlbW92ZUJyZWFrYWJsZUJvZHkodGhpcyk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwdWJsaWMgdm9pZCBCcmVhaygpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBfYnJlYWsgPSB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufSIsIi8qXHJcbiogRmFyc2VlciBQaHlzaWNzIEVuZ2luZSBiYXNlZCBvbiBCb3gyRC5YTkEgcG9ydDpcclxuKiBDb3B5cmlnaHQgKGMpIDIwMTAgSWFuIFF2aXN0XHJcbiogXHJcbiogQm94MkQuWE5BIHBvcnQgb2YgQm94MkQ6XHJcbiogQ29weXJpZ2h0IChjKSAyMDA5IEJyYW5kb24gRnVydHdhbmdsZXIsIE5hdGhhbiBGdXJ0d2FuZ2xlclxyXG4qXHJcbiogT3JpZ2luYWwgc291cmNlIEJveDJEOlxyXG4qIENvcHlyaWdodCAoYykgMjAwNi0yMDA5IEVyaW4gQ2F0dG8gaHR0cDovL3d3dy5ncGh5c2ljcy5jb20gXHJcbiogXHJcbiogVGhpcyBzb2Z0d2FyZSBpcyBwcm92aWRlZCAnYXMtaXMnLCB3aXRob3V0IGFueSBleHByZXNzIG9yIGltcGxpZWQgXHJcbiogd2FycmFudHkuICBJbiBubyBldmVudCB3aWxsIHRoZSBhdXRob3JzIGJlIGhlbGQgbGlhYmxlIGZvciBhbnkgZGFtYWdlcyBcclxuKiBhcmlzaW5nIGZyb20gdGhlIHVzZSBvZiB0aGlzIHNvZnR3YXJlLiBcclxuKiBQZXJtaXNzaW9uIGlzIGdyYW50ZWQgdG8gYW55b25lIHRvIHVzZSB0aGlzIHNvZnR3YXJlIGZvciBhbnkgcHVycG9zZSwgXHJcbiogaW5jbHVkaW5nIGNvbW1lcmNpYWwgYXBwbGljYXRpb25zLCBhbmQgdG8gYWx0ZXIgaXQgYW5kIHJlZGlzdHJpYnV0ZSBpdCBcclxuKiBmcmVlbHksIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyByZXN0cmljdGlvbnM6IFxyXG4qIDEuIFRoZSBvcmlnaW4gb2YgdGhpcyBzb2Z0d2FyZSBtdXN0IG5vdCBiZSBtaXNyZXByZXNlbnRlZDsgeW91IG11c3Qgbm90IFxyXG4qIGNsYWltIHRoYXQgeW91IHdyb3RlIHRoZSBvcmlnaW5hbCBzb2Z0d2FyZS4gSWYgeW91IHVzZSB0aGlzIHNvZnR3YXJlIFxyXG4qIGluIGEgcHJvZHVjdCwgYW4gYWNrbm93bGVkZ21lbnQgaW4gdGhlIHByb2R1Y3QgZG9jdW1lbnRhdGlvbiB3b3VsZCBiZSBcclxuKiBhcHByZWNpYXRlZCBidXQgaXMgbm90IHJlcXVpcmVkLiBcclxuKiAyLiBBbHRlcmVkIHNvdXJjZSB2ZXJzaW9ucyBtdXN0IGJlIHBsYWlubHkgbWFya2VkIGFzIHN1Y2gsIGFuZCBtdXN0IG5vdCBiZSBcclxuKiBtaXNyZXByZXNlbnRlZCBhcyBiZWluZyB0aGUgb3JpZ2luYWwgc29mdHdhcmUuIFxyXG4qIDMuIFRoaXMgbm90aWNlIG1heSBub3QgYmUgcmVtb3ZlZCBvciBhbHRlcmVkIGZyb20gYW55IHNvdXJjZSBkaXN0cmlidXRpb24uIFxyXG4qL1xyXG5cclxudXNpbmcgU3lzdGVtO1xyXG51c2luZyBTeXN0ZW0uQ29sbGVjdGlvbnMuR2VuZXJpYztcclxudXNpbmcgU3lzdGVtLkRpYWdub3N0aWNzO1xyXG51c2luZyBGYXJzZWVyUGh5c2ljcy5Db2xsaXNpb247XHJcbnVzaW5nIEZhcnNlZXJQaHlzaWNzLkNvbGxpc2lvbi5TaGFwZXM7XHJcbnVzaW5nIEZhcnNlZXJQaHlzaWNzLkNvbW1vbjtcclxudXNpbmcgRmFyc2VlclBoeXNpY3MuRHluYW1pY3MuQ29udGFjdHM7XHJcbnVzaW5nIE1pY3Jvc29mdC5YbmEuRnJhbWV3b3JrO1xyXG5cclxubmFtZXNwYWNlIEZhcnNlZXJQaHlzaWNzLkR5bmFtaWNzXHJcbntcclxuICAgIFtGbGFnc11cclxuICAgIHB1YmxpYyBlbnVtIENhdGVnb3J5XHJcbiAgICB7XHJcbiAgICAgICAgTm9uZSA9IDAsXHJcbiAgICAgICAgQWxsID0gaW50Lk1heFZhbHVlLFxyXG4gICAgICAgIENhdDEgPSAxLFxyXG4gICAgICAgIENhdDIgPSAyLFxyXG4gICAgICAgIENhdDMgPSA0LFxyXG4gICAgICAgIENhdDQgPSA4LFxyXG4gICAgICAgIENhdDUgPSAxNixcclxuICAgICAgICBDYXQ2ID0gMzIsXHJcbiAgICAgICAgQ2F0NyA9IDY0LFxyXG4gICAgICAgIENhdDggPSAxMjgsXHJcbiAgICAgICAgQ2F0OSA9IDI1NixcclxuICAgICAgICBDYXQxMCA9IDUxMixcclxuICAgICAgICBDYXQxMSA9IDEwMjQsXHJcbiAgICAgICAgQ2F0MTIgPSAyMDQ4LFxyXG4gICAgICAgIENhdDEzID0gNDA5NixcclxuICAgICAgICBDYXQxNCA9IDgxOTIsXHJcbiAgICAgICAgQ2F0MTUgPSAxNjM4NCxcclxuICAgICAgICBDYXQxNiA9IDMyNzY4LFxyXG4gICAgICAgIENhdDE3ID0gNjU1MzYsXHJcbiAgICAgICAgQ2F0MTggPSAxMzEwNzIsXHJcbiAgICAgICAgQ2F0MTkgPSAyNjIxNDQsXHJcbiAgICAgICAgQ2F0MjAgPSA1MjQyODgsXHJcbiAgICAgICAgQ2F0MjEgPSAxMDQ4NTc2LFxyXG4gICAgICAgIENhdDIyID0gMjA5NzE1MixcclxuICAgICAgICBDYXQyMyA9IDQxOTQzMDQsXHJcbiAgICAgICAgQ2F0MjQgPSA4Mzg4NjA4LFxyXG4gICAgICAgIENhdDI1ID0gMTY3NzcyMTYsXHJcbiAgICAgICAgQ2F0MjYgPSAzMzU1NDQzMixcclxuICAgICAgICBDYXQyNyA9IDY3MTA4ODY0LFxyXG4gICAgICAgIENhdDI4ID0gMTM0MjE3NzI4LFxyXG4gICAgICAgIENhdDI5ID0gMjY4NDM1NDU2LFxyXG4gICAgICAgIENhdDMwID0gNTM2ODcwOTEyLFxyXG4gICAgICAgIENhdDMxID0gMTA3Mzc0MTgyNFxyXG4gICAgfVxyXG5cclxuICAgIC8vLyA8c3VtbWFyeT5cclxuICAgIC8vLyBUaGlzIHByb3h5IGlzIHVzZWQgaW50ZXJuYWxseSB0byBjb25uZWN0IGZpeHR1cmVzIHRvIHRoZSBicm9hZC1waGFzZS5cclxuICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICBwdWJsaWMgc3RydWN0IEZpeHR1cmVQcm94eVxyXG4gICAge1xyXG4gICAgICAgIHB1YmxpYyBBQUJCIEFBQkI7XHJcbiAgICAgICAgcHVibGljIGludCBDaGlsZEluZGV4O1xyXG4gICAgICAgIHB1YmxpYyBGaXh0dXJlIEZpeHR1cmU7XHJcbiAgICAgICAgcHVibGljIGludCBQcm94eUlkO1xyXG4gICAgfVxyXG5cclxuICAgIC8vLyA8c3VtbWFyeT5cclxuICAgIC8vLyBBIGZpeHR1cmUgaXMgdXNlZCB0byBhdHRhY2ggYSBTaGFwZSB0byBhIGJvZHkgZm9yIGNvbGxpc2lvbiBkZXRlY3Rpb24uIEEgZml4dHVyZVxyXG4gICAgLy8vIGluaGVyaXRzIGl0cyB0cmFuc2Zvcm0gZnJvbSBpdHMgcGFyZW50LiBGaXh0dXJlcyBob2xkIGFkZGl0aW9uYWwgbm9uLWdlb21ldHJpYyBkYXRhXHJcbiAgICAvLy8gc3VjaCBhcyBmcmljdGlvbiwgY29sbGlzaW9uIGZpbHRlcnMsIGV0Yy5cclxuICAgIC8vLyBGaXh0dXJlcyBhcmUgY3JlYXRlZCB2aWEgQm9keS5DcmVhdGVGaXh0dXJlLlxyXG4gICAgLy8vIFdhcm5pbmc6IFlvdSBjYW5ub3QgcmV1c2UgZml4dHVyZXMuXHJcbiAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgcHVibGljIGNsYXNzIEZpeHR1cmUgOiBJRGlzcG9zYWJsZVxyXG4gICAge1xyXG4gICAgICAgIHByaXZhdGUgc3RhdGljIGludCBfZml4dHVyZUlkQ291bnRlcjtcclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBGaXJlcyBhZnRlciB0d28gc2hhcGVzIGhhcyBjb2xsaWRlZCBhbmQgYXJlIHNvbHZlZC4gVGhpcyBnaXZlcyB5b3UgYSBjaGFuY2UgdG8gZ2V0IHRoZSBpbXBhY3QgZm9yY2UuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICBwdWJsaWMgQWZ0ZXJDb2xsaXNpb25FdmVudEhhbmRsZXIgQWZ0ZXJDb2xsaXNpb247XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gRmlyZXMgd2hlbiB0d28gZml4dHVyZXMgYXJlIGNsb3NlIHRvIGVhY2ggb3RoZXIuXHJcbiAgICAgICAgLy8vIER1ZSB0byBob3cgdGhlIGJyb2FkcGhhc2Ugd29ya3MsIHRoaXMgY2FuIGJlIHF1aXRlIGluYWNjdXJhdGUgYXMgc2hhcGVzIGFyZSBhcHByb3hpbWF0ZWQgdXNpbmcgQUFCQnMuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICBwdWJsaWMgQmVmb3JlQ29sbGlzaW9uRXZlbnRIYW5kbGVyIEJlZm9yZUNvbGxpc2lvbjtcclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBGaXJlcyB3aGVuIHR3byBzaGFwZXMgY29sbGlkZSBhbmQgYSBjb250YWN0IGlzIGNyZWF0ZWQgYmV0d2VlbiB0aGVtLlxyXG4gICAgICAgIC8vLyBOb3RlIHRoYXQgdGhlIGZpcnN0IGZpeHR1cmUgYXJndW1lbnQgaXMgYWx3YXlzIHRoZSBmaXh0dXJlIHRoYXQgdGhlIGRlbGVnYXRlIGlzIHN1YnNjcmliZWQgdG8uXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICBwdWJsaWMgT25Db2xsaXNpb25FdmVudEhhbmRsZXIgT25Db2xsaXNpb247XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gRmlyZXMgd2hlbiB0d28gc2hhcGVzIHNlcGFyYXRlIGFuZCBhIGNvbnRhY3QgaXMgcmVtb3ZlZCBiZXR3ZWVuIHRoZW0uXHJcbiAgICAgICAgLy8vIE5vdGUgdGhhdCB0aGUgZmlyc3QgZml4dHVyZSBhcmd1bWVudCBpcyBhbHdheXMgdGhlIGZpeHR1cmUgdGhhdCB0aGUgZGVsZWdhdGUgaXMgc3Vic2NyaWJlZCB0by5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIHB1YmxpYyBPblNlcGFyYXRpb25FdmVudEhhbmRsZXIgT25TZXBhcmF0aW9uO1xyXG5cclxuICAgICAgICBwdWJsaWMgRml4dHVyZVByb3h5W10gUHJveGllcztcclxuICAgICAgICBwdWJsaWMgaW50IFByb3h5Q291bnQ7XHJcbiAgICAgICAgaW50ZXJuYWwgQ2F0ZWdvcnkgX2NvbGxpZGVzV2l0aDtcclxuICAgICAgICBpbnRlcm5hbCBDYXRlZ29yeSBfY29sbGlzaW9uQ2F0ZWdvcmllcztcclxuICAgICAgICBpbnRlcm5hbCBzaG9ydCBfY29sbGlzaW9uR3JvdXA7XHJcbiAgICAgICAgaW50ZXJuYWwgRGljdGlvbmFyeTxpbnQsIGJvb2w+IF9jb2xsaXNpb25JZ25vcmVzO1xyXG4gICAgICAgIHByaXZhdGUgZmxvYXQgX2ZyaWN0aW9uO1xyXG4gICAgICAgIHByaXZhdGUgZmxvYXQgX3Jlc3RpdHV0aW9uO1xyXG5cclxuICAgICAgICBpbnRlcm5hbCBGaXh0dXJlKClcclxuICAgICAgICB7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwdWJsaWMgRml4dHVyZShCb2R5IGJvZHksIFNoYXBlIHNoYXBlKVxyXG4gICAgICAgICAgICA6IHRoaXMoYm9keSwgc2hhcGUsIG51bGwpXHJcbiAgICAgICAge1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHVibGljIEZpeHR1cmUoQm9keSBib2R5LCBTaGFwZSBzaGFwZSwgb2JqZWN0IHVzZXJEYXRhKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgaWYgKFNldHRpbmdzLlVzZUZQRUNvbGxpc2lvbkNhdGVnb3JpZXMpXHJcbiAgICAgICAgICAgICAgICBfY29sbGlzaW9uQ2F0ZWdvcmllcyA9IENhdGVnb3J5LkFsbDtcclxuICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgX2NvbGxpc2lvbkNhdGVnb3JpZXMgPSBDYXRlZ29yeS5DYXQxO1xyXG5cclxuICAgICAgICAgICAgX2NvbGxpZGVzV2l0aCA9IENhdGVnb3J5LkFsbDtcclxuICAgICAgICAgICAgX2NvbGxpc2lvbkdyb3VwID0gMDtcclxuXHJcbiAgICAgICAgICAgIC8vRml4dHVyZSBkZWZhdWx0c1xyXG4gICAgICAgICAgICBGcmljdGlvbiA9IDAuMmY7XHJcbiAgICAgICAgICAgIFJlc3RpdHV0aW9uID0gMDtcclxuXHJcbiAgICAgICAgICAgIElzU2Vuc29yID0gZmFsc2U7XHJcblxyXG4gICAgICAgICAgICBCb2R5ID0gYm9keTtcclxuICAgICAgICAgICAgVXNlckRhdGEgPSB1c2VyRGF0YTtcclxuXHJcbiAgICAgICAgICAgIGlmIChTZXR0aW5ncy5Db25zZXJ2ZU1lbW9yeSlcclxuICAgICAgICAgICAgICAgIFNoYXBlID0gc2hhcGU7XHJcbiAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgIFNoYXBlID0gc2hhcGUuQ2xvbmUoKTtcclxuXHJcbiAgICAgICAgICAgIFJlZ2lzdGVyRml4dHVyZSgpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBEZWZhdWx0cyB0byAwXHJcbiAgICAgICAgLy8vIFxyXG4gICAgICAgIC8vLyBJZiBTZXR0aW5ncy5Vc2VGUEVDb2xsaXNpb25DYXRlZ29yaWVzIGlzIHNldCB0byBmYWxzZTpcclxuICAgICAgICAvLy8gQ29sbGlzaW9uIGdyb3VwcyBhbGxvdyBhIGNlcnRhaW4gZ3JvdXAgb2Ygb2JqZWN0cyB0byBuZXZlciBjb2xsaWRlIChuZWdhdGl2ZSlcclxuICAgICAgICAvLy8gb3IgYWx3YXlzIGNvbGxpZGUgKHBvc2l0aXZlKS4gWmVybyBtZWFucyBubyBjb2xsaXNpb24gZ3JvdXAuIE5vbi16ZXJvIGdyb3VwXHJcbiAgICAgICAgLy8vIGZpbHRlcmluZyBhbHdheXMgd2lucyBhZ2FpbnN0IHRoZSBtYXNrIGJpdHMuXHJcbiAgICAgICAgLy8vIFxyXG4gICAgICAgIC8vLyBJZiBTZXR0aW5ncy5Vc2VGUEVDb2xsaXNpb25DYXRlZ29yaWVzIGlzIHNldCB0byB0cnVlOlxyXG4gICAgICAgIC8vLyBJZiAyIGZpeHR1cmVzIGFyZSBpbiB0aGUgc2FtZSBjb2xsaXNpb24gZ3JvdXAsIHRoZXkgd2lsbCBub3QgY29sbGlkZS5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIHB1YmxpYyBzaG9ydCBDb2xsaXNpb25Hcm91cFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgc2V0XHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGlmIChfY29sbGlzaW9uR3JvdXAgPT0gdmFsdWUpXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG5cclxuICAgICAgICAgICAgICAgIF9jb2xsaXNpb25Hcm91cCA9IHZhbHVlO1xyXG4gICAgICAgICAgICAgICAgUmVmaWx0ZXIoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBnZXQgeyByZXR1cm4gX2NvbGxpc2lvbkdyb3VwOyB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIERlZmF1bHRzIHRvIENhdGVnb3J5LkFsbFxyXG4gICAgICAgIC8vLyBcclxuICAgICAgICAvLy8gVGhlIGNvbGxpc2lvbiBtYXNrIGJpdHMuIFRoaXMgc3RhdGVzIHRoZSBjYXRlZ29yaWVzIHRoYXQgdGhpc1xyXG4gICAgICAgIC8vLyBmaXh0dXJlIHdvdWxkIGFjY2VwdCBmb3IgY29sbGlzaW9uLlxyXG4gICAgICAgIC8vLyBVc2UgU2V0dGluZ3MuVXNlRlBFQ29sbGlzaW9uQ2F0ZWdvcmllcyB0byBjaGFuZ2UgdGhlIGJlaGF2aW9yLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgcHVibGljIENhdGVnb3J5IENvbGxpZGVzV2l0aFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgZ2V0IHsgcmV0dXJuIF9jb2xsaWRlc1dpdGg7IH1cclxuXHJcbiAgICAgICAgICAgIHNldFxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBpZiAoX2NvbGxpZGVzV2l0aCA9PSB2YWx1ZSlcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcblxyXG4gICAgICAgICAgICAgICAgX2NvbGxpZGVzV2l0aCA9IHZhbHVlO1xyXG4gICAgICAgICAgICAgICAgUmVmaWx0ZXIoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBUaGUgY29sbGlzaW9uIGNhdGVnb3JpZXMgdGhpcyBmaXh0dXJlIGlzIGEgcGFydCBvZi5cclxuICAgICAgICAvLy8gXHJcbiAgICAgICAgLy8vIElmIFNldHRpbmdzLlVzZUZQRUNvbGxpc2lvbkNhdGVnb3JpZXMgaXMgc2V0IHRvIGZhbHNlOlxyXG4gICAgICAgIC8vLyBEZWZhdWx0cyB0byBDYXRlZ29yeS5DYXQxXHJcbiAgICAgICAgLy8vIFxyXG4gICAgICAgIC8vLyBJZiBTZXR0aW5ncy5Vc2VGUEVDb2xsaXNpb25DYXRlZ29yaWVzIGlzIHNldCB0byB0cnVlOlxyXG4gICAgICAgIC8vLyBEZWZhdWx0cyB0byBDYXRlZ29yeS5BbGxcclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIHB1YmxpYyBDYXRlZ29yeSBDb2xsaXNpb25DYXRlZ29yaWVzXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBnZXQgeyByZXR1cm4gX2NvbGxpc2lvbkNhdGVnb3JpZXM7IH1cclxuXHJcbiAgICAgICAgICAgIHNldFxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBpZiAoX2NvbGxpc2lvbkNhdGVnb3JpZXMgPT0gdmFsdWUpXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG5cclxuICAgICAgICAgICAgICAgIF9jb2xsaXNpb25DYXRlZ29yaWVzID0gdmFsdWU7XHJcbiAgICAgICAgICAgICAgICBSZWZpbHRlcigpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIEdldCB0aGUgdHlwZSBvZiB0aGUgY2hpbGQgU2hhcGUuIFlvdSBjYW4gdXNlIHRoaXMgdG8gZG93biBjYXN0IHRvIHRoZSBjb25jcmV0ZSBTaGFwZS5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8dmFsdWU+VGhlIHR5cGUgb2YgdGhlIHNoYXBlLjwvdmFsdWU+XHJcbiAgICAgICAgcHVibGljIFNoYXBlVHlwZSBTaGFwZVR5cGVcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGdldCB7IHJldHVybiBTaGFwZS5TaGFwZVR5cGU7IH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gR2V0IHRoZSBjaGlsZCBTaGFwZS4gWW91IGNhbiBtb2RpZnkgdGhlIGNoaWxkIFNoYXBlLCBob3dldmVyIHlvdSBzaG91bGQgbm90IGNoYW5nZSB0aGVcclxuICAgICAgICAvLy8gbnVtYmVyIG9mIHZlcnRpY2VzIGJlY2F1c2UgdGhpcyB3aWxsIGNyYXNoIHNvbWUgY29sbGlzaW9uIGNhY2hpbmcgbWVjaGFuaXNtcy5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8dmFsdWU+VGhlIHNoYXBlLjwvdmFsdWU+XHJcbiAgICAgICAgcHVibGljIFNoYXBlIFNoYXBlIHsgZ2V0OyBpbnRlcm5hbCBzZXQ7IH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBHZXRzIG9yIHNldHMgYSB2YWx1ZSBpbmRpY2F0aW5nIHdoZXRoZXIgdGhpcyBmaXh0dXJlIGlzIGEgc2Vuc29yLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDx2YWx1ZT48Yz50cnVlPC9jPiBpZiB0aGlzIGluc3RhbmNlIGlzIGEgc2Vuc29yOyBvdGhlcndpc2UsIDxjPmZhbHNlPC9jPi48L3ZhbHVlPlxyXG4gICAgICAgIHB1YmxpYyBib29sIElzU2Vuc29yIHsgZ2V0OyBzZXQ7IH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBHZXQgdGhlIHBhcmVudCBib2R5IG9mIHRoaXMgZml4dHVyZS4gVGhpcyBpcyBudWxsIGlmIHRoZSBmaXh0dXJlIGlzIG5vdCBhdHRhY2hlZC5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8dmFsdWU+VGhlIGJvZHkuPC92YWx1ZT5cclxuICAgICAgICBwdWJsaWMgQm9keSBCb2R5IHsgZ2V0OyBpbnRlcm5hbCBzZXQ7IH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBTZXQgdGhlIHVzZXIgZGF0YS4gVXNlIHRoaXMgdG8gc3RvcmUgeW91ciBhcHBsaWNhdGlvbiBzcGVjaWZpYyBkYXRhLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDx2YWx1ZT5UaGUgdXNlciBkYXRhLjwvdmFsdWU+XHJcbiAgICAgICAgcHVibGljIG9iamVjdCBVc2VyRGF0YSB7IGdldDsgc2V0OyB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gR2V0IG9yIHNldCB0aGUgY29lZmZpY2llbnQgb2YgZnJpY3Rpb24uXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHZhbHVlPlRoZSBmcmljdGlvbi48L3ZhbHVlPlxyXG4gICAgICAgIHB1YmxpYyBmbG9hdCBGcmljdGlvblxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgZ2V0IHsgcmV0dXJuIF9mcmljdGlvbjsgfVxyXG4gICAgICAgICAgICBzZXRcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgRGVidWcuQXNzZXJ0KCFmbG9hdC5Jc05hTih2YWx1ZSkpO1xyXG5cclxuICAgICAgICAgICAgICAgIF9mcmljdGlvbiA9IHZhbHVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIEdldCBvciBzZXQgdGhlIGNvZWZmaWNpZW50IG9mIHJlc3RpdHV0aW9uLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDx2YWx1ZT5UaGUgcmVzdGl0dXRpb24uPC92YWx1ZT5cclxuICAgICAgICBwdWJsaWMgZmxvYXQgUmVzdGl0dXRpb25cclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGdldCB7IHJldHVybiBfcmVzdGl0dXRpb247IH1cclxuICAgICAgICAgICAgc2V0XHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIERlYnVnLkFzc2VydCghZmxvYXQuSXNOYU4odmFsdWUpKTtcclxuXHJcbiAgICAgICAgICAgICAgICBfcmVzdGl0dXRpb24gPSB2YWx1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBHZXRzIGEgdW5pcXVlIElEIGZvciB0aGlzIGZpeHR1cmUuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHZhbHVlPlRoZSBmaXh0dXJlIGlkLjwvdmFsdWU+XHJcbiAgICAgICAgcHVibGljIGludCBGaXh0dXJlSWQgeyBnZXQ7IHByaXZhdGUgc2V0OyB9XHJcblxyXG4gICAgICAgICNyZWdpb24gSURpc3Bvc2FibGUgTWVtYmVyc1xyXG5cclxuICAgICAgICBwdWJsaWMgYm9vbCBJc0Rpc3Bvc2VkIHsgZ2V0OyBzZXQ7IH1cclxuXHJcbiAgICAgICAgcHVibGljIHZvaWQgRGlzcG9zZSgpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBpZiAoIUlzRGlzcG9zZWQpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIEJvZHkuRGVzdHJveUZpeHR1cmUodGhpcyk7XHJcbiAgICAgICAgICAgICAgICBJc0Rpc3Bvc2VkID0gdHJ1ZTtcclxuI2lmICFIdG1sNVxyXG4gICAgICAgICAgICAgICAgR0MuU3VwcHJlc3NGaW5hbGl6ZSh0aGlzKTtcclxuI2VuZGlmXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4jZW5kcmVnaW9uXHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gUmVzdG9yZXMgY29sbGlzaW9ucyBiZXR3ZWVuIHRoaXMgZml4dHVyZSBhbmQgdGhlIHByb3ZpZGVkIGZpeHR1cmUuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJmaXh0dXJlXCI+VGhlIGZpeHR1cmUuPC9wYXJhbT5cclxuICAgICAgICBwdWJsaWMgdm9pZCBSZXN0b3JlQ29sbGlzaW9uV2l0aChGaXh0dXJlIGZpeHR1cmUpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBpZiAoX2NvbGxpc2lvbklnbm9yZXMgPT0gbnVsbClcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuXHJcbiAgICAgICAgICAgIGlmIChfY29sbGlzaW9uSWdub3Jlcy5Db250YWluc0tleShmaXh0dXJlLkZpeHR1cmVJZCkpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIF9jb2xsaXNpb25JZ25vcmVzW2ZpeHR1cmUuRml4dHVyZUlkXSA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgUmVmaWx0ZXIoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBJZ25vcmVzIGNvbGxpc2lvbnMgYmV0d2VlbiB0aGlzIGZpeHR1cmUgYW5kIHRoZSBwcm92aWRlZCBmaXh0dXJlLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwiZml4dHVyZVwiPlRoZSBmaXh0dXJlLjwvcGFyYW0+XHJcbiAgICAgICAgcHVibGljIHZvaWQgSWdub3JlQ29sbGlzaW9uV2l0aChGaXh0dXJlIGZpeHR1cmUpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBpZiAoX2NvbGxpc2lvbklnbm9yZXMgPT0gbnVsbClcclxuICAgICAgICAgICAgICAgIF9jb2xsaXNpb25JZ25vcmVzID0gbmV3IERpY3Rpb25hcnk8aW50LCBib29sPigpO1xyXG5cclxuICAgICAgICAgICAgaWYgKF9jb2xsaXNpb25JZ25vcmVzLkNvbnRhaW5zS2V5KGZpeHR1cmUuRml4dHVyZUlkKSlcclxuICAgICAgICAgICAgICAgIF9jb2xsaXNpb25JZ25vcmVzW2ZpeHR1cmUuRml4dHVyZUlkXSA9IHRydWU7XHJcbiAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgIF9jb2xsaXNpb25JZ25vcmVzLkFkZChmaXh0dXJlLkZpeHR1cmVJZCwgdHJ1ZSk7XHJcblxyXG4gICAgICAgICAgICBSZWZpbHRlcigpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBEZXRlcm1pbmVzIHdoZXRoZXIgY29sbGlzaW9ucyBhcmUgaWdub3JlZCBiZXR3ZWVuIHRoaXMgZml4dHVyZSBhbmQgdGhlIHByb3ZpZGVkIGZpeHR1cmUuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJmaXh0dXJlXCI+VGhlIGZpeHR1cmUuPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHJldHVybnM+XHJcbiAgICAgICAgLy8vIFx0PGM+dHJ1ZTwvYz4gaWYgdGhlIGZpeHR1cmUgaXMgaWdub3JlZDsgb3RoZXJ3aXNlLCA8Yz5mYWxzZTwvYz4uXHJcbiAgICAgICAgLy8vIDwvcmV0dXJucz5cclxuICAgICAgICBwdWJsaWMgYm9vbCBJc0ZpeHR1cmVJZ25vcmVkKEZpeHR1cmUgZml4dHVyZSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGlmIChfY29sbGlzaW9uSWdub3JlcyA9PSBudWxsKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG5cclxuICAgICAgICAgICAgaWYgKF9jb2xsaXNpb25JZ25vcmVzLkNvbnRhaW5zS2V5KGZpeHR1cmUuRml4dHVyZUlkKSlcclxuICAgICAgICAgICAgICAgIHJldHVybiBfY29sbGlzaW9uSWdub3Jlc1tmaXh0dXJlLkZpeHR1cmVJZF07XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIENvbnRhY3RzIGFyZSBwZXJzaXN0YW50IGFuZCB3aWxsIGtlZXAgYmVpbmcgcGVyc2lzdGFudCB1bmxlc3MgdGhleSBhcmVcclxuICAgICAgICAvLy8gZmxhZ2dlZCBmb3IgZmlsdGVyaW5nLlxyXG4gICAgICAgIC8vLyBUaGlzIG1ldGhvZHMgZmxhZ3MgYWxsIGNvbnRhY3RzIGFzc29jaWF0ZWQgd2l0aCB0aGUgYm9keSBmb3IgZmlsdGVyaW5nLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgaW50ZXJuYWwgdm9pZCBSZWZpbHRlcigpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICAvLyBGbGFnIGFzc29jaWF0ZWQgY29udGFjdHMgZm9yIGZpbHRlcmluZy5cclxuICAgICAgICAgICAgQ29udGFjdEVkZ2UgZWRnZSA9IEJvZHkuQ29udGFjdExpc3Q7XHJcbiAgICAgICAgICAgIHdoaWxlIChlZGdlICE9IG51bGwpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIENvbnRhY3QgY29udGFjdCA9IGVkZ2UuQ29udGFjdDtcclxuICAgICAgICAgICAgICAgIEZpeHR1cmUgZml4dHVyZUEgPSBjb250YWN0LkZpeHR1cmVBO1xyXG4gICAgICAgICAgICAgICAgRml4dHVyZSBmaXh0dXJlQiA9IGNvbnRhY3QuRml4dHVyZUI7XHJcbiAgICAgICAgICAgICAgICBpZiAoZml4dHVyZUEgPT0gdGhpcyB8fCBmaXh0dXJlQiA9PSB0aGlzKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnRhY3QuRmxhZ0ZvckZpbHRlcmluZygpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGVkZ2UgPSBlZGdlLk5leHQ7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIFdvcmxkIHdvcmxkID0gQm9keS5Xb3JsZDtcclxuXHJcbiAgICAgICAgICAgIGlmICh3b3JsZCA9PSBudWxsKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIFRvdWNoIGVhY2ggcHJveHkgc28gdGhhdCBuZXcgcGFpcnMgbWF5IGJlIGNyZWF0ZWRcclxuICAgICAgICAgICAgSUJyb2FkUGhhc2UgYnJvYWRQaGFzZSA9IHdvcmxkLkNvbnRhY3RNYW5hZ2VyLkJyb2FkUGhhc2U7XHJcbiAgICAgICAgICAgIGZvciAoaW50IGkgPSAwOyBpIDwgUHJveHlDb3VudDsgKytpKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBicm9hZFBoYXNlLlRvdWNoUHJveHkoUHJveGllc1tpXS5Qcm94eUlkKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHJpdmF0ZSB2b2lkIFJlZ2lzdGVyRml4dHVyZSgpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICAvLyBSZXNlcnZlIHByb3h5IHNwYWNlXHJcbiAgICAgICAgICAgIFByb3hpZXMgPSBuZXcgRml4dHVyZVByb3h5W1NoYXBlLkNoaWxkQ291bnRdO1xyXG4gICAgICAgICAgICBQcm94eUNvdW50ID0gMDtcclxuXHJcbiAgICAgICAgICAgIEZpeHR1cmVJZCA9IF9maXh0dXJlSWRDb3VudGVyKys7XHJcblxyXG4gICAgICAgICAgICBpZiAoKEJvZHkuRmxhZ3MgJiBCb2R5RmxhZ3MuRW5hYmxlZCkgPT0gQm9keUZsYWdzLkVuYWJsZWQpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIElCcm9hZFBoYXNlIGJyb2FkUGhhc2UgPSBCb2R5LldvcmxkLkNvbnRhY3RNYW5hZ2VyLkJyb2FkUGhhc2U7XHJcbiAgICAgICAgICAgICAgICBDcmVhdGVQcm94aWVzKGJyb2FkUGhhc2UsIHJlZiBCb2R5LlhmKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgQm9keS5GaXh0dXJlTGlzdC5BZGQodGhpcyk7XHJcblxyXG4gICAgICAgICAgICAvLyBBZGp1c3QgbWFzcyBwcm9wZXJ0aWVzIGlmIG5lZWRlZC5cclxuICAgICAgICAgICAgaWYgKFNoYXBlLl9kZW5zaXR5ID4gMC4wZilcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgQm9keS5SZXNldE1hc3NEYXRhKCk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIExldCB0aGUgd29ybGQga25vdyB3ZSBoYXZlIGEgbmV3IGZpeHR1cmUuIFRoaXMgd2lsbCBjYXVzZSBuZXcgY29udGFjdHNcclxuICAgICAgICAgICAgLy8gdG8gYmUgY3JlYXRlZCBhdCB0aGUgYmVnaW5uaW5nIG9mIHRoZSBuZXh0IHRpbWUgc3RlcC5cclxuICAgICAgICAgICAgQm9keS5Xb3JsZC5GbGFncyB8PSBXb3JsZEZsYWdzLk5ld0ZpeHR1cmU7XHJcblxyXG4gICAgICAgICAgICBpZiAoQm9keS5Xb3JsZC5GaXh0dXJlQWRkZWQgIT0gbnVsbClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgQm9keS5Xb3JsZC5GaXh0dXJlQWRkZWQodGhpcyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gVGVzdCBhIHBvaW50IGZvciBjb250YWlubWVudCBpbiB0aGlzIGZpeHR1cmUuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJwb2ludFwiPkEgcG9pbnQgaW4gd29ybGQgY29vcmRpbmF0ZXMuPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHJldHVybnM+PC9yZXR1cm5zPlxyXG4gICAgICAgIHB1YmxpYyBib29sIFRlc3RQb2ludChyZWYgVmVjdG9yMiBwb2ludClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiBTaGFwZS5UZXN0UG9pbnQocmVmIEJvZHkuWGYsIHJlZiBwb2ludCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIENhc3QgYSByYXkgYWdhaW5zdCB0aGlzIFNoYXBlLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwib3V0cHV0XCI+VGhlIHJheS1jYXN0IHJlc3VsdHMuPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJpbnB1dFwiPlRoZSByYXktY2FzdCBpbnB1dCBwYXJhbWV0ZXJzLjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwiY2hpbGRJbmRleFwiPkluZGV4IG9mIHRoZSBjaGlsZC48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cmV0dXJucz48L3JldHVybnM+XHJcbiAgICAgICAgcHVibGljIGJvb2wgUmF5Q2FzdChvdXQgUmF5Q2FzdE91dHB1dCBvdXRwdXQsIHJlZiBSYXlDYXN0SW5wdXQgaW5wdXQsIGludCBjaGlsZEluZGV4KVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIFNoYXBlLlJheUNhc3Qob3V0IG91dHB1dCwgcmVmIGlucHV0LCByZWYgQm9keS5YZiwgY2hpbGRJbmRleCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIEdldCB0aGUgZml4dHVyZSdzIEFBQkIuIFRoaXMgQUFCQiBtYXkgYmUgZW5sYXJnZSBhbmQvb3Igc3RhbGUuXHJcbiAgICAgICAgLy8vIElmIHlvdSBuZWVkIGEgbW9yZSBhY2N1cmF0ZSBBQUJCLCBjb21wdXRlIGl0IHVzaW5nIHRoZSBTaGFwZSBhbmRcclxuICAgICAgICAvLy8gdGhlIGJvZHkgdHJhbnNmb3JtLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwiYWFiYlwiPlRoZSBhYWJiLjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwiY2hpbGRJbmRleFwiPkluZGV4IG9mIHRoZSBjaGlsZC48L3BhcmFtPlxyXG4gICAgICAgIHB1YmxpYyB2b2lkIEdldEFBQkIob3V0IEFBQkIgYWFiYiwgaW50IGNoaWxkSW5kZXgpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBEZWJ1Zy5Bc3NlcnQoMCA8PSBjaGlsZEluZGV4ICYmIGNoaWxkSW5kZXggPCBQcm94eUNvdW50KTtcclxuICAgICAgICAgICAgYWFiYiA9IFByb3hpZXNbY2hpbGRJbmRleF0uQUFCQjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHB1YmxpYyBGaXh0dXJlIENsb25lKEJvZHkgYm9keSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIEZpeHR1cmUgZml4dHVyZSA9IG5ldyBGaXh0dXJlKCk7XHJcbiAgICAgICAgICAgIGZpeHR1cmUuQm9keSA9IGJvZHk7XHJcblxyXG4gICAgICAgICAgICBpZiAoU2V0dGluZ3MuQ29uc2VydmVNZW1vcnkpXHJcbiAgICAgICAgICAgICAgICBmaXh0dXJlLlNoYXBlID0gU2hhcGU7XHJcbiAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgIGZpeHR1cmUuU2hhcGUgPSBTaGFwZS5DbG9uZSgpO1xyXG5cclxuICAgICAgICAgICAgZml4dHVyZS5Vc2VyRGF0YSA9IFVzZXJEYXRhO1xyXG4gICAgICAgICAgICBmaXh0dXJlLlJlc3RpdHV0aW9uID0gUmVzdGl0dXRpb247XHJcbiAgICAgICAgICAgIGZpeHR1cmUuRnJpY3Rpb24gPSBGcmljdGlvbjtcclxuICAgICAgICAgICAgZml4dHVyZS5Jc1NlbnNvciA9IElzU2Vuc29yO1xyXG4gICAgICAgICAgICBmaXh0dXJlLl9jb2xsaXNpb25Hcm91cCA9IENvbGxpc2lvbkdyb3VwO1xyXG4gICAgICAgICAgICBmaXh0dXJlLl9jb2xsaXNpb25DYXRlZ29yaWVzID0gQ29sbGlzaW9uQ2F0ZWdvcmllcztcclxuICAgICAgICAgICAgZml4dHVyZS5fY29sbGlkZXNXaXRoID0gQ29sbGlkZXNXaXRoO1xyXG5cclxuICAgICAgICAgICAgaWYgKF9jb2xsaXNpb25JZ25vcmVzICE9IG51bGwpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGZpeHR1cmUuX2NvbGxpc2lvbklnbm9yZXMgPSBuZXcgRGljdGlvbmFyeTxpbnQsIGJvb2w+KCk7XHJcblxyXG4gICAgICAgICAgICAgICAgZm9yZWFjaCAoS2V5VmFsdWVQYWlyPGludCwgYm9vbD4gcGFpciBpbiBfY29sbGlzaW9uSWdub3JlcylcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBmaXh0dXJlLl9jb2xsaXNpb25JZ25vcmVzLkFkZChwYWlyLktleSwgcGFpci5WYWx1ZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGZpeHR1cmUuUmVnaXN0ZXJGaXh0dXJlKCk7XHJcbiAgICAgICAgICAgIHJldHVybiBmaXh0dXJlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHVibGljIEZpeHR1cmUgRGVlcENsb25lKClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIEZpeHR1cmUgZml4ID0gQ2xvbmUoQm9keS5DbG9uZSgpKTtcclxuICAgICAgICAgICAgcmV0dXJuIGZpeDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGludGVybmFsIHZvaWQgRGVzdHJveSgpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICAvLyBUaGUgcHJveGllcyBtdXN0IGJlIGRlc3Ryb3llZCBiZWZvcmUgY2FsbGluZyB0aGlzLlxyXG4gICAgICAgICAgICBEZWJ1Zy5Bc3NlcnQoUHJveHlDb3VudCA9PSAwKTtcclxuXHJcbiAgICAgICAgICAgIC8vIEZyZWUgdGhlIHByb3h5IGFycmF5LlxyXG4gICAgICAgICAgICBQcm94aWVzID0gbnVsbDtcclxuICAgICAgICAgICAgU2hhcGUgPSBudWxsO1xyXG5cclxuICAgICAgICAgICAgQmVmb3JlQ29sbGlzaW9uID0gbnVsbDtcclxuICAgICAgICAgICAgT25Db2xsaXNpb24gPSBudWxsO1xyXG4gICAgICAgICAgICBPblNlcGFyYXRpb24gPSBudWxsO1xyXG4gICAgICAgICAgICBBZnRlckNvbGxpc2lvbiA9IG51bGw7XHJcblxyXG4gICAgICAgICAgICBpZiAoQm9keS5Xb3JsZC5GaXh0dXJlUmVtb3ZlZCAhPSBudWxsKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBCb2R5LldvcmxkLkZpeHR1cmVSZW1vdmVkKHRoaXMpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBCb2R5LldvcmxkLkZpeHR1cmVBZGRlZCA9IG51bGw7XHJcbiAgICAgICAgICAgIEJvZHkuV29ybGQuRml4dHVyZVJlbW92ZWQgPSBudWxsO1xyXG4gICAgICAgICAgICBPblNlcGFyYXRpb24gPSBudWxsO1xyXG4gICAgICAgICAgICBPbkNvbGxpc2lvbiA9IG51bGw7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBUaGVzZSBzdXBwb3J0IGJvZHkgYWN0aXZhdGlvbi9kZWFjdGl2YXRpb24uXHJcbiAgICAgICAgaW50ZXJuYWwgdm9pZCBDcmVhdGVQcm94aWVzKElCcm9hZFBoYXNlIGJyb2FkUGhhc2UsIHJlZiBUcmFuc2Zvcm0geGYpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBEZWJ1Zy5Bc3NlcnQoUHJveHlDb3VudCA9PSAwKTtcclxuXHJcbiAgICAgICAgICAgIC8vIENyZWF0ZSBwcm94aWVzIGluIHRoZSBicm9hZC1waGFzZS5cclxuICAgICAgICAgICAgUHJveHlDb3VudCA9IFNoYXBlLkNoaWxkQ291bnQ7XHJcblxyXG4gICAgICAgICAgICBmb3IgKGludCBpID0gMDsgaSA8IFByb3h5Q291bnQ7ICsraSlcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgRml4dHVyZVByb3h5IHByb3h5ID0gbmV3IEZpeHR1cmVQcm94eSgpO1xyXG4gICAgICAgICAgICAgICAgU2hhcGUuQ29tcHV0ZUFBQkIob3V0IHByb3h5LkFBQkIsIHJlZiB4ZiwgaSk7XHJcblxyXG4gICAgICAgICAgICAgICAgcHJveHkuRml4dHVyZSA9IHRoaXM7XHJcbiAgICAgICAgICAgICAgICBwcm94eS5DaGlsZEluZGV4ID0gaTtcclxuICAgICAgICAgICAgICAgIHByb3h5LlByb3h5SWQgPSBicm9hZFBoYXNlLkFkZFByb3h5KHJlZiBwcm94eSk7XHJcblxyXG4gICAgICAgICAgICAgICAgUHJveGllc1tpXSA9IHByb3h5O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpbnRlcm5hbCB2b2lkIERlc3Ryb3lQcm94aWVzKElCcm9hZFBoYXNlIGJyb2FkUGhhc2UpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICAvLyBEZXN0cm95IHByb3hpZXMgaW4gdGhlIGJyb2FkLXBoYXNlLlxyXG4gICAgICAgICAgICBmb3IgKGludCBpID0gMDsgaSA8IFByb3h5Q291bnQ7ICsraSlcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgYnJvYWRQaGFzZS5SZW1vdmVQcm94eShQcm94aWVzW2ldLlByb3h5SWQpO1xyXG4gICAgICAgICAgICAgICAgUHJveGllc1tpXS5Qcm94eUlkID0gLTE7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIFByb3h5Q291bnQgPSAwO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaW50ZXJuYWwgdm9pZCBTeW5jaHJvbml6ZShJQnJvYWRQaGFzZSBicm9hZFBoYXNlLCByZWYgVHJhbnNmb3JtIHRyYW5zZm9ybTEsIHJlZiBUcmFuc2Zvcm0gdHJhbnNmb3JtMilcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGlmIChQcm94eUNvdW50ID09IDApXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgZm9yIChpbnQgaSA9IDA7IGkgPCBQcm94eUNvdW50OyArK2kpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIEZpeHR1cmVQcm94eSBwcm94eSA9IFByb3hpZXNbaV07XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gQ29tcHV0ZSBhbiBBQUJCIHRoYXQgY292ZXJzIHRoZSBzd2VwdCBTaGFwZSAobWF5IG1pc3Mgc29tZSByb3RhdGlvbiBlZmZlY3QpLlxyXG4gICAgICAgICAgICAgICAgQUFCQiBhYWJiMSwgYWFiYjI7XHJcbiAgICAgICAgICAgICAgICBTaGFwZS5Db21wdXRlQUFCQihvdXQgYWFiYjEsIHJlZiB0cmFuc2Zvcm0xLCBwcm94eS5DaGlsZEluZGV4KTtcclxuICAgICAgICAgICAgICAgIFNoYXBlLkNvbXB1dGVBQUJCKG91dCBhYWJiMiwgcmVmIHRyYW5zZm9ybTIsIHByb3h5LkNoaWxkSW5kZXgpO1xyXG5cclxuICAgICAgICAgICAgICAgIHByb3h5LkFBQkIuQ29tYmluZShyZWYgYWFiYjEsIHJlZiBhYWJiMik7XHJcblxyXG4gICAgICAgICAgICAgICAgVmVjdG9yMiBkaXNwbGFjZW1lbnQgPSB0cmFuc2Zvcm0yLlBvc2l0aW9uIC0gdHJhbnNmb3JtMS5Qb3NpdGlvbjtcclxuXHJcbiAgICAgICAgICAgICAgICBicm9hZFBoYXNlLk1vdmVQcm94eShwcm94eS5Qcm94eUlkLCByZWYgcHJveHkuQUFCQiwgZGlzcGxhY2VtZW50KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaW50ZXJuYWwgYm9vbCBDb21wYXJlVG8oRml4dHVyZSBmaXh0dXJlKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIChcclxuICAgICAgICAgICAgICAgICAgICAgICBDb2xsaWRlc1dpdGggPT0gZml4dHVyZS5Db2xsaWRlc1dpdGggJiZcclxuICAgICAgICAgICAgICAgICAgICAgICBDb2xsaXNpb25DYXRlZ29yaWVzID09IGZpeHR1cmUuQ29sbGlzaW9uQ2F0ZWdvcmllcyAmJlxyXG4gICAgICAgICAgICAgICAgICAgICAgIENvbGxpc2lvbkdyb3VwID09IGZpeHR1cmUuQ29sbGlzaW9uR3JvdXAgJiZcclxuICAgICAgICAgICAgICAgICAgICAgICBGcmljdGlvbiA9PSBmaXh0dXJlLkZyaWN0aW9uICYmXHJcbiAgICAgICAgICAgICAgICAgICAgICAgSXNTZW5zb3IgPT0gZml4dHVyZS5Jc1NlbnNvciAmJlxyXG4gICAgICAgICAgICAgICAgICAgICAgIFJlc3RpdHV0aW9uID09IGZpeHR1cmUuUmVzdGl0dXRpb24gJiZcclxuICAgICAgICAgICAgICAgICAgICAgICBTaGFwZS5Db21wYXJlVG8oZml4dHVyZS5TaGFwZSkgJiZcclxuICAgICAgICAgICAgICAgICAgICAgICBVc2VyRGF0YSA9PSBmaXh0dXJlLlVzZXJEYXRhKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn0iLCIvKlxyXG4qIEZhcnNlZXIgUGh5c2ljcyBFbmdpbmUgYmFzZWQgb24gQm94MkQuWE5BIHBvcnQ6XHJcbiogQ29weXJpZ2h0IChjKSAyMDEwIElhbiBRdmlzdFxyXG4qIFxyXG4qIEJveDJELlhOQSBwb3J0IG9mIEJveDJEOlxyXG4qIENvcHlyaWdodCAoYykgMjAwOSBCcmFuZG9uIEZ1cnR3YW5nbGVyLCBOYXRoYW4gRnVydHdhbmdsZXJcclxuKlxyXG4qIE9yaWdpbmFsIHNvdXJjZSBCb3gyRDpcclxuKiBDb3B5cmlnaHQgKGMpIDIwMDYtMjAwOSBFcmluIENhdHRvIGh0dHA6Ly93d3cuZ3BoeXNpY3MuY29tIFxyXG4qIFxyXG4qIFRoaXMgc29mdHdhcmUgaXMgcHJvdmlkZWQgJ2FzLWlzJywgd2l0aG91dCBhbnkgZXhwcmVzcyBvciBpbXBsaWVkIFxyXG4qIHdhcnJhbnR5LiAgSW4gbm8gZXZlbnQgd2lsbCB0aGUgYXV0aG9ycyBiZSBoZWxkIGxpYWJsZSBmb3IgYW55IGRhbWFnZXMgXHJcbiogYXJpc2luZyBmcm9tIHRoZSB1c2Ugb2YgdGhpcyBzb2Z0d2FyZS4gXHJcbiogUGVybWlzc2lvbiBpcyBncmFudGVkIHRvIGFueW9uZSB0byB1c2UgdGhpcyBzb2Z0d2FyZSBmb3IgYW55IHB1cnBvc2UsIFxyXG4qIGluY2x1ZGluZyBjb21tZXJjaWFsIGFwcGxpY2F0aW9ucywgYW5kIHRvIGFsdGVyIGl0IGFuZCByZWRpc3RyaWJ1dGUgaXQgXHJcbiogZnJlZWx5LCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgcmVzdHJpY3Rpb25zOiBcclxuKiAxLiBUaGUgb3JpZ2luIG9mIHRoaXMgc29mdHdhcmUgbXVzdCBub3QgYmUgbWlzcmVwcmVzZW50ZWQ7IHlvdSBtdXN0IG5vdCBcclxuKiBjbGFpbSB0aGF0IHlvdSB3cm90ZSB0aGUgb3JpZ2luYWwgc29mdHdhcmUuIElmIHlvdSB1c2UgdGhpcyBzb2Z0d2FyZSBcclxuKiBpbiBhIHByb2R1Y3QsIGFuIGFja25vd2xlZGdtZW50IGluIHRoZSBwcm9kdWN0IGRvY3VtZW50YXRpb24gd291bGQgYmUgXHJcbiogYXBwcmVjaWF0ZWQgYnV0IGlzIG5vdCByZXF1aXJlZC4gXHJcbiogMi4gQWx0ZXJlZCBzb3VyY2UgdmVyc2lvbnMgbXVzdCBiZSBwbGFpbmx5IG1hcmtlZCBhcyBzdWNoLCBhbmQgbXVzdCBub3QgYmUgXHJcbiogbWlzcmVwcmVzZW50ZWQgYXMgYmVpbmcgdGhlIG9yaWdpbmFsIHNvZnR3YXJlLiBcclxuKiAzLiBUaGlzIG5vdGljZSBtYXkgbm90IGJlIHJlbW92ZWQgb3IgYWx0ZXJlZCBmcm9tIGFueSBzb3VyY2UgZGlzdHJpYnV0aW9uLiBcclxuKi9cclxuXHJcbnVzaW5nIFN5c3RlbS5Db2xsZWN0aW9ucy5HZW5lcmljO1xyXG51c2luZyBGYXJzZWVyUGh5c2ljcy5Db2xsaXNpb247XHJcbnVzaW5nIEZhcnNlZXJQaHlzaWNzLkR5bmFtaWNzLkNvbnRhY3RzO1xyXG5cclxubmFtZXNwYWNlIEZhcnNlZXJQaHlzaWNzLkR5bmFtaWNzXHJcbntcclxuICAgIHB1YmxpYyBjbGFzcyBDb250YWN0TWFuYWdlclxyXG4gICAge1xyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gRmlyZXMgd2hlbiBhIGNvbnRhY3QgaXMgY3JlYXRlZFxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgcHVibGljIEJlZ2luQ29udGFjdERlbGVnYXRlIEJlZ2luQ29udGFjdDtcclxuXHJcbiAgICAgICAgcHVibGljIElCcm9hZFBoYXNlIEJyb2FkUGhhc2U7XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gVGhlIGZpbHRlciB1c2VkIGJ5IHRoZSBjb250YWN0IG1hbmFnZXIuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICBwdWJsaWMgQ29sbGlzaW9uRmlsdGVyRGVsZWdhdGUgQ29udGFjdEZpbHRlcjtcclxuXHJcbiAgICAgICAgcHVibGljIExpc3Q8Q29udGFjdD4gQ29udGFjdExpc3QgPSBuZXcgTGlzdDxDb250YWN0PigxMjgpO1xyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIEZpcmVzIHdoZW4gYSBjb250YWN0IGlzIGRlbGV0ZWRcclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIHB1YmxpYyBFbmRDb250YWN0RGVsZWdhdGUgRW5kQ29udGFjdDtcclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBGaXJlcyB3aGVuIHRoZSBicm9hZHBoYXNlIGRldGVjdHMgdGhhdCB0d28gRml4dHVyZXMgYXJlIGNsb3NlIHRvIGVhY2ggb3RoZXIuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICBwdWJsaWMgQnJvYWRwaGFzZURlbGVnYXRlIE9uQnJvYWRwaGFzZUNvbGxpc2lvbjtcclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBGaXJlcyBhZnRlciB0aGUgc29sdmVyIGhhcyBydW5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIHB1YmxpYyBQb3N0U29sdmVEZWxlZ2F0ZSBQb3N0U29sdmU7XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gRmlyZXMgYmVmb3JlIHRoZSBzb2x2ZXIgcnVuc1xyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgcHVibGljIFByZVNvbHZlRGVsZWdhdGUgUHJlU29sdmU7XHJcblxyXG4gICAgICAgIGludGVybmFsIENvbnRhY3RNYW5hZ2VyKElCcm9hZFBoYXNlIGJyb2FkUGhhc2UpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBCcm9hZFBoYXNlID0gYnJvYWRQaGFzZTtcclxuICAgICAgICAgICAgT25Ccm9hZHBoYXNlQ29sbGlzaW9uID0gQWRkUGFpcjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIEJyb2FkLXBoYXNlIGNhbGxiYWNrLlxyXG4gICAgICAgIHByaXZhdGUgdm9pZCBBZGRQYWlyKHJlZiBGaXh0dXJlUHJveHkgcHJveHlBLCByZWYgRml4dHVyZVByb3h5IHByb3h5QilcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIEZpeHR1cmUgZml4dHVyZUEgPSBwcm94eUEuRml4dHVyZTtcclxuICAgICAgICAgICAgRml4dHVyZSBmaXh0dXJlQiA9IHByb3h5Qi5GaXh0dXJlO1xyXG5cclxuICAgICAgICAgICAgaW50IGluZGV4QSA9IHByb3h5QS5DaGlsZEluZGV4O1xyXG4gICAgICAgICAgICBpbnQgaW5kZXhCID0gcHJveHlCLkNoaWxkSW5kZXg7XHJcblxyXG4gICAgICAgICAgICBCb2R5IGJvZHlBID0gZml4dHVyZUEuQm9keTtcclxuICAgICAgICAgICAgQm9keSBib2R5QiA9IGZpeHR1cmVCLkJvZHk7XHJcblxyXG4gICAgICAgICAgICAvLyBBcmUgdGhlIGZpeHR1cmVzIG9uIHRoZSBzYW1lIGJvZHk/XHJcbiAgICAgICAgICAgIGlmIChib2R5QSA9PSBib2R5QilcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBEb2VzIGEgY29udGFjdCBhbHJlYWR5IGV4aXN0P1xyXG4gICAgICAgICAgICBDb250YWN0RWRnZSBlZGdlID0gYm9keUIuQ29udGFjdExpc3Q7XHJcbiAgICAgICAgICAgIHdoaWxlIChlZGdlICE9IG51bGwpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGlmIChlZGdlLk90aGVyID09IGJvZHlBKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIEZpeHR1cmUgZkEgPSBlZGdlLkNvbnRhY3QuRml4dHVyZUE7XHJcbiAgICAgICAgICAgICAgICAgICAgRml4dHVyZSBmQiA9IGVkZ2UuQ29udGFjdC5GaXh0dXJlQjtcclxuICAgICAgICAgICAgICAgICAgICBpbnQgaUEgPSBlZGdlLkNvbnRhY3QuQ2hpbGRJbmRleEE7XHJcbiAgICAgICAgICAgICAgICAgICAgaW50IGlCID0gZWRnZS5Db250YWN0LkNoaWxkSW5kZXhCO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZiAoZkEgPT0gZml4dHVyZUEgJiYgZkIgPT0gZml4dHVyZUIgJiYgaUEgPT0gaW5kZXhBICYmIGlCID09IGluZGV4QilcclxuICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEEgY29udGFjdCBhbHJlYWR5IGV4aXN0cy5cclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGZBID09IGZpeHR1cmVCICYmIGZCID09IGZpeHR1cmVBICYmIGlBID09IGluZGV4QiAmJiBpQiA9PSBpbmRleEEpXHJcbiAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBBIGNvbnRhY3QgYWxyZWFkeSBleGlzdHMuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgZWRnZSA9IGVkZ2UuTmV4dDtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gRG9lcyBhIGpvaW50IG92ZXJyaWRlIGNvbGxpc2lvbj8gSXMgYXQgbGVhc3Qgb25lIGJvZHkgZHluYW1pYz9cclxuICAgICAgICAgICAgaWYgKGJvZHlCLlNob3VsZENvbGxpZGUoYm9keUEpID09IGZhbHNlKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG5cclxuICAgICAgICAgICAgLy9DaGVjayBkZWZhdWx0IGZpbHRlclxyXG4gICAgICAgICAgICBpZiAoU2hvdWxkQ29sbGlkZShmaXh0dXJlQSwgZml4dHVyZUIpID09IGZhbHNlKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG5cclxuICAgICAgICAgICAgLy8gQ2hlY2sgdXNlciBmaWx0ZXJpbmcuXHJcbiAgICAgICAgICAgIGlmIChDb250YWN0RmlsdGVyICE9IG51bGwgJiYgQ29udGFjdEZpbHRlcihmaXh0dXJlQSwgZml4dHVyZUIpID09IGZhbHNlKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG5cclxuICAgICAgICAgICAgaWYgKGZpeHR1cmVBLkJlZm9yZUNvbGxpc2lvbiAhPSBudWxsICYmIGZpeHR1cmVBLkJlZm9yZUNvbGxpc2lvbihmaXh0dXJlQSwgZml4dHVyZUIpID09IGZhbHNlKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG5cclxuICAgICAgICAgICAgaWYgKGZpeHR1cmVCLkJlZm9yZUNvbGxpc2lvbiAhPSBudWxsICYmIGZpeHR1cmVCLkJlZm9yZUNvbGxpc2lvbihmaXh0dXJlQiwgZml4dHVyZUEpID09IGZhbHNlKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG5cclxuICAgICAgICAgICAgLy8gQ2FsbCB0aGUgZmFjdG9yeS5cclxuICAgICAgICAgICAgQ29udGFjdCBjID0gQ29udGFjdC5DcmVhdGUoZml4dHVyZUEsIGluZGV4QSwgZml4dHVyZUIsIGluZGV4Qik7XHJcblxyXG4gICAgICAgICAgICAvLyBDb250YWN0IGNyZWF0aW9uIG1heSBzd2FwIGZpeHR1cmVzLlxyXG4gICAgICAgICAgICBmaXh0dXJlQSA9IGMuRml4dHVyZUE7XHJcbiAgICAgICAgICAgIGZpeHR1cmVCID0gYy5GaXh0dXJlQjtcclxuICAgICAgICAgICAgYm9keUEgPSBmaXh0dXJlQS5Cb2R5O1xyXG4gICAgICAgICAgICBib2R5QiA9IGZpeHR1cmVCLkJvZHk7XHJcblxyXG4gICAgICAgICAgICAvLyBJbnNlcnQgaW50byB0aGUgd29ybGQuXHJcbiAgICAgICAgICAgIENvbnRhY3RMaXN0LkFkZChjKTtcclxuXHJcbiAgICAgICAgICAgIC8vIENvbm5lY3QgdG8gaXNsYW5kIGdyYXBoLlxyXG5cclxuICAgICAgICAgICAgLy8gQ29ubmVjdCB0byBib2R5IEFcclxuICAgICAgICAgICAgYy5Ob2RlQS5Db250YWN0ID0gYztcclxuICAgICAgICAgICAgYy5Ob2RlQS5PdGhlciA9IGJvZHlCO1xyXG5cclxuICAgICAgICAgICAgYy5Ob2RlQS5QcmV2ID0gbnVsbDtcclxuICAgICAgICAgICAgYy5Ob2RlQS5OZXh0ID0gYm9keUEuQ29udGFjdExpc3Q7XHJcbiAgICAgICAgICAgIGlmIChib2R5QS5Db250YWN0TGlzdCAhPSBudWxsKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBib2R5QS5Db250YWN0TGlzdC5QcmV2ID0gYy5Ob2RlQTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBib2R5QS5Db250YWN0TGlzdCA9IGMuTm9kZUE7XHJcblxyXG4gICAgICAgICAgICAvLyBDb25uZWN0IHRvIGJvZHkgQlxyXG4gICAgICAgICAgICBjLk5vZGVCLkNvbnRhY3QgPSBjO1xyXG4gICAgICAgICAgICBjLk5vZGVCLk90aGVyID0gYm9keUE7XHJcblxyXG4gICAgICAgICAgICBjLk5vZGVCLlByZXYgPSBudWxsO1xyXG4gICAgICAgICAgICBjLk5vZGVCLk5leHQgPSBib2R5Qi5Db250YWN0TGlzdDtcclxuICAgICAgICAgICAgaWYgKGJvZHlCLkNvbnRhY3RMaXN0ICE9IG51bGwpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGJvZHlCLkNvbnRhY3RMaXN0LlByZXYgPSBjLk5vZGVCO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGJvZHlCLkNvbnRhY3RMaXN0ID0gYy5Ob2RlQjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGludGVybmFsIHZvaWQgRmluZE5ld0NvbnRhY3RzKClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIEJyb2FkUGhhc2UuVXBkYXRlUGFpcnMoKGdsb2JhbDo6RmFyc2VlclBoeXNpY3MuRHluYW1pY3MuQnJvYWRwaGFzZURlbGVnYXRlKU9uQnJvYWRwaGFzZUNvbGxpc2lvbik7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpbnRlcm5hbCB2b2lkIERlc3Ryb3koQ29udGFjdCBjb250YWN0KVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgRml4dHVyZSBmaXh0dXJlQSA9IGNvbnRhY3QuRml4dHVyZUE7XHJcbiAgICAgICAgICAgIEZpeHR1cmUgZml4dHVyZUIgPSBjb250YWN0LkZpeHR1cmVCO1xyXG4gICAgICAgICAgICBCb2R5IGJvZHlBID0gZml4dHVyZUEuQm9keTtcclxuICAgICAgICAgICAgQm9keSBib2R5QiA9IGZpeHR1cmVCLkJvZHk7XHJcblxyXG4gICAgICAgICAgICBpZiAoRW5kQ29udGFjdCAhPSBudWxsICYmIGNvbnRhY3QuSXNUb3VjaGluZygpKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBFbmRDb250YWN0KGNvbnRhY3QpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBSZW1vdmUgZnJvbSB0aGUgd29ybGQuXHJcbiAgICAgICAgICAgIENvbnRhY3RMaXN0LlJlbW92ZShjb250YWN0KTtcclxuXHJcbiAgICAgICAgICAgIC8vIFJlbW92ZSBmcm9tIGJvZHkgMVxyXG4gICAgICAgICAgICBpZiAoY29udGFjdC5Ob2RlQS5QcmV2ICE9IG51bGwpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGNvbnRhY3QuTm9kZUEuUHJldi5OZXh0ID0gY29udGFjdC5Ob2RlQS5OZXh0O1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAoY29udGFjdC5Ob2RlQS5OZXh0ICE9IG51bGwpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGNvbnRhY3QuTm9kZUEuTmV4dC5QcmV2ID0gY29udGFjdC5Ob2RlQS5QcmV2O1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAoY29udGFjdC5Ob2RlQSA9PSBib2R5QS5Db250YWN0TGlzdClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgYm9keUEuQ29udGFjdExpc3QgPSBjb250YWN0Lk5vZGVBLk5leHQ7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIFJlbW92ZSBmcm9tIGJvZHkgMlxyXG4gICAgICAgICAgICBpZiAoY29udGFjdC5Ob2RlQi5QcmV2ICE9IG51bGwpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGNvbnRhY3QuTm9kZUIuUHJldi5OZXh0ID0gY29udGFjdC5Ob2RlQi5OZXh0O1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAoY29udGFjdC5Ob2RlQi5OZXh0ICE9IG51bGwpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGNvbnRhY3QuTm9kZUIuTmV4dC5QcmV2ID0gY29udGFjdC5Ob2RlQi5QcmV2O1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAoY29udGFjdC5Ob2RlQiA9PSBib2R5Qi5Db250YWN0TGlzdClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgYm9keUIuQ29udGFjdExpc3QgPSBjb250YWN0Lk5vZGVCLk5leHQ7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGNvbnRhY3QuRGVzdHJveSgpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaW50ZXJuYWwgdm9pZCBDb2xsaWRlKClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIC8vIFVwZGF0ZSBhd2FrZSBjb250YWN0cy5cclxuICAgICAgICAgICAgZm9yIChpbnQgaSA9IDA7IGkgPCBDb250YWN0TGlzdC5Db3VudDsgaSsrKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBDb250YWN0IGMgPSBDb250YWN0TGlzdFtpXTtcclxuICAgICAgICAgICAgICAgIEZpeHR1cmUgZml4dHVyZUEgPSBjLkZpeHR1cmVBO1xyXG4gICAgICAgICAgICAgICAgRml4dHVyZSBmaXh0dXJlQiA9IGMuRml4dHVyZUI7XHJcbiAgICAgICAgICAgICAgICBpbnQgaW5kZXhBID0gYy5DaGlsZEluZGV4QTtcclxuICAgICAgICAgICAgICAgIGludCBpbmRleEIgPSBjLkNoaWxkSW5kZXhCO1xyXG4gICAgICAgICAgICAgICAgQm9keSBib2R5QSA9IGZpeHR1cmVBLkJvZHk7XHJcbiAgICAgICAgICAgICAgICBCb2R5IGJvZHlCID0gZml4dHVyZUIuQm9keTtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoYm9keUEuQXdha2UgPT0gZmFsc2UgJiYgYm9keUIuQXdha2UgPT0gZmFsc2UpXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gSXMgdGhpcyBjb250YWN0IGZsYWdnZWQgZm9yIGZpbHRlcmluZz9cclxuICAgICAgICAgICAgICAgIGlmICgoYy5GbGFncyAmIENvbnRhY3RGbGFncy5GaWx0ZXIpID09IENvbnRhY3RGbGFncy5GaWx0ZXIpXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gU2hvdWxkIHRoZXNlIGJvZGllcyBjb2xsaWRlP1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChib2R5Qi5TaG91bGRDb2xsaWRlKGJvZHlBKSA9PSBmYWxzZSlcclxuICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIENvbnRhY3QgY051a2UgPSBjO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBEZXN0cm95KGNOdWtlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBDaGVjayBkZWZhdWx0IGZpbHRlcmluZ1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChTaG91bGRDb2xsaWRlKGZpeHR1cmVBLCBmaXh0dXJlQikgPT0gZmFsc2UpXHJcbiAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBDb250YWN0IGNOdWtlID0gYztcclxuICAgICAgICAgICAgICAgICAgICAgICAgRGVzdHJveShjTnVrZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gQ2hlY2sgdXNlciBmaWx0ZXJpbmcuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKENvbnRhY3RGaWx0ZXIgIT0gbnVsbCAmJiBDb250YWN0RmlsdGVyKGZpeHR1cmVBLCBmaXh0dXJlQikgPT0gZmFsc2UpXHJcbiAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBDb250YWN0IGNOdWtlID0gYztcclxuICAgICAgICAgICAgICAgICAgICAgICAgRGVzdHJveShjTnVrZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gQ2xlYXIgdGhlIGZpbHRlcmluZyBmbGFnLlxyXG4gICAgICAgICAgICAgICAgICAgIGMuRmxhZ3MgJj0gfkNvbnRhY3RGbGFncy5GaWx0ZXI7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgaW50IHByb3h5SWRBID0gZml4dHVyZUEuUHJveGllc1tpbmRleEFdLlByb3h5SWQ7XHJcbiAgICAgICAgICAgICAgICBpbnQgcHJveHlJZEIgPSBmaXh0dXJlQi5Qcm94aWVzW2luZGV4Ql0uUHJveHlJZDtcclxuXHJcbiAgICAgICAgICAgICAgICBib29sIG92ZXJsYXAgPSBCcm9hZFBoYXNlLlRlc3RPdmVybGFwKHByb3h5SWRBLCBwcm94eUlkQik7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gSGVyZSB3ZSBkZXN0cm95IGNvbnRhY3RzIHRoYXQgY2Vhc2UgdG8gb3ZlcmxhcCBpbiB0aGUgYnJvYWQtcGhhc2UuXHJcbiAgICAgICAgICAgICAgICBpZiAob3ZlcmxhcCA9PSBmYWxzZSlcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBDb250YWN0IGNOdWtlID0gYztcclxuICAgICAgICAgICAgICAgICAgICBEZXN0cm95KGNOdWtlKTtcclxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAvLyBUaGUgY29udGFjdCBwZXJzaXN0cy5cclxuICAgICAgICAgICAgICAgIGMuVXBkYXRlKHRoaXMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwcml2YXRlIHN0YXRpYyBib29sIFNob3VsZENvbGxpZGUoRml4dHVyZSBmaXh0dXJlQSwgRml4dHVyZSBmaXh0dXJlQilcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGlmIChTZXR0aW5ncy5Vc2VGUEVDb2xsaXNpb25DYXRlZ29yaWVzKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBpZiAoKGZpeHR1cmVBLkNvbGxpc2lvbkdyb3VwID09IGZpeHR1cmVCLkNvbGxpc2lvbkdyb3VwKSAmJlxyXG4gICAgICAgICAgICAgICAgICAgIGZpeHR1cmVBLkNvbGxpc2lvbkdyb3VwICE9IDAgJiYgZml4dHVyZUIuQ29sbGlzaW9uR3JvdXAgIT0gMClcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKCgoZml4dHVyZUEuQ29sbGlzaW9uQ2F0ZWdvcmllcyAmIGZpeHR1cmVCLkNvbGxpZGVzV2l0aCkgPT1cclxuICAgICAgICAgICAgICAgICAgICAgQ2F0ZWdvcnkuTm9uZSkgJlxyXG4gICAgICAgICAgICAgICAgICAgICgoZml4dHVyZUIuQ29sbGlzaW9uQ2F0ZWdvcmllcyAmIGZpeHR1cmVBLkNvbGxpZGVzV2l0aCkgPT1cclxuICAgICAgICAgICAgICAgICAgICAgQ2F0ZWdvcnkuTm9uZSkpXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmIChmaXh0dXJlQS5Jc0ZpeHR1cmVJZ25vcmVkKGZpeHR1cmVCKSB8fFxyXG4gICAgICAgICAgICAgICAgICAgIGZpeHR1cmVCLklzRml4dHVyZUlnbm9yZWQoZml4dHVyZUEpKVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKGZpeHR1cmVBLkNvbGxpc2lvbkdyb3VwID09IGZpeHR1cmVCLkNvbGxpc2lvbkdyb3VwICYmXHJcbiAgICAgICAgICAgICAgICBmaXh0dXJlQS5Db2xsaXNpb25Hcm91cCAhPSAwKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZml4dHVyZUEuQ29sbGlzaW9uR3JvdXAgPiAwO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBib29sIGNvbGxpZGUgPSAoZml4dHVyZUEuQ29sbGlkZXNXaXRoICYgZml4dHVyZUIuQ29sbGlzaW9uQ2F0ZWdvcmllcykgIT0gMCAmJlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAoZml4dHVyZUEuQ29sbGlzaW9uQ2F0ZWdvcmllcyAmIGZpeHR1cmVCLkNvbGxpZGVzV2l0aCkgIT0gMDtcclxuXHJcbiAgICAgICAgICAgIGlmIChjb2xsaWRlKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBpZiAoZml4dHVyZUEuSXNGaXh0dXJlSWdub3JlZChmaXh0dXJlQikgfHxcclxuICAgICAgICAgICAgICAgICAgICBmaXh0dXJlQi5Jc0ZpeHR1cmVJZ25vcmVkKGZpeHR1cmVBKSlcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHJldHVybiBjb2xsaWRlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufSIsIi8qXHJcbiogRmFyc2VlciBQaHlzaWNzIEVuZ2luZSBiYXNlZCBvbiBCb3gyRC5YTkEgcG9ydDpcclxuKiBDb3B5cmlnaHQgKGMpIDIwMTAgSWFuIFF2aXN0XHJcbiogXHJcbiogQm94MkQuWE5BIHBvcnQgb2YgQm94MkQ6XHJcbiogQ29weXJpZ2h0IChjKSAyMDA5IEJyYW5kb24gRnVydHdhbmdsZXIsIE5hdGhhbiBGdXJ0d2FuZ2xlclxyXG4qXHJcbiogT3JpZ2luYWwgc291cmNlIEJveDJEOlxyXG4qIENvcHlyaWdodCAoYykgMjAwNi0yMDA5IEVyaW4gQ2F0dG8gaHR0cDovL3d3dy5ncGh5c2ljcy5jb20gXHJcbiogXHJcbiogVGhpcyBzb2Z0d2FyZSBpcyBwcm92aWRlZCAnYXMtaXMnLCB3aXRob3V0IGFueSBleHByZXNzIG9yIGltcGxpZWQgXHJcbiogd2FycmFudHkuICBJbiBubyBldmVudCB3aWxsIHRoZSBhdXRob3JzIGJlIGhlbGQgbGlhYmxlIGZvciBhbnkgZGFtYWdlcyBcclxuKiBhcmlzaW5nIGZyb20gdGhlIHVzZSBvZiB0aGlzIHNvZnR3YXJlLiBcclxuKiBQZXJtaXNzaW9uIGlzIGdyYW50ZWQgdG8gYW55b25lIHRvIHVzZSB0aGlzIHNvZnR3YXJlIGZvciBhbnkgcHVycG9zZSwgXHJcbiogaW5jbHVkaW5nIGNvbW1lcmNpYWwgYXBwbGljYXRpb25zLCBhbmQgdG8gYWx0ZXIgaXQgYW5kIHJlZGlzdHJpYnV0ZSBpdCBcclxuKiBmcmVlbHksIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyByZXN0cmljdGlvbnM6IFxyXG4qIDEuIFRoZSBvcmlnaW4gb2YgdGhpcyBzb2Z0d2FyZSBtdXN0IG5vdCBiZSBtaXNyZXByZXNlbnRlZDsgeW91IG11c3Qgbm90IFxyXG4qIGNsYWltIHRoYXQgeW91IHdyb3RlIHRoZSBvcmlnaW5hbCBzb2Z0d2FyZS4gSWYgeW91IHVzZSB0aGlzIHNvZnR3YXJlIFxyXG4qIGluIGEgcHJvZHVjdCwgYW4gYWNrbm93bGVkZ21lbnQgaW4gdGhlIHByb2R1Y3QgZG9jdW1lbnRhdGlvbiB3b3VsZCBiZSBcclxuKiBhcHByZWNpYXRlZCBidXQgaXMgbm90IHJlcXVpcmVkLiBcclxuKiAyLiBBbHRlcmVkIHNvdXJjZSB2ZXJzaW9ucyBtdXN0IGJlIHBsYWlubHkgbWFya2VkIGFzIHN1Y2gsIGFuZCBtdXN0IG5vdCBiZSBcclxuKiBtaXNyZXByZXNlbnRlZCBhcyBiZWluZyB0aGUgb3JpZ2luYWwgc29mdHdhcmUuIFxyXG4qIDMuIFRoaXMgbm90aWNlIG1heSBub3QgYmUgcmVtb3ZlZCBvciBhbHRlcmVkIGZyb20gYW55IHNvdXJjZSBkaXN0cmlidXRpb24uIFxyXG4qL1xyXG5cclxudXNpbmcgU3lzdGVtO1xyXG51c2luZyBTeXN0ZW0uQ29sbGVjdGlvbnMuR2VuZXJpYztcclxudXNpbmcgU3lzdGVtLkRpYWdub3N0aWNzO1xyXG51c2luZyBGYXJzZWVyUGh5c2ljcy5Db2xsaXNpb247XHJcbnVzaW5nIEZhcnNlZXJQaHlzaWNzLkNvbGxpc2lvbi5TaGFwZXM7XHJcbnVzaW5nIEZhcnNlZXJQaHlzaWNzLkNvbW1vbjtcclxudXNpbmcgTWljcm9zb2Z0LlhuYS5GcmFtZXdvcms7XHJcblxyXG5uYW1lc3BhY2UgRmFyc2VlclBoeXNpY3MuRHluYW1pY3MuQ29udGFjdHNcclxue1xyXG4gICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgLy8vIEEgY29udGFjdCBlZGdlIGlzIHVzZWQgdG8gY29ubmVjdCBib2RpZXMgYW5kIGNvbnRhY3RzIHRvZ2V0aGVyXHJcbiAgICAvLy8gaW4gYSBjb250YWN0IGdyYXBoIHdoZXJlIGVhY2ggYm9keSBpcyBhIG5vZGUgYW5kIGVhY2ggY29udGFjdFxyXG4gICAgLy8vIGlzIGFuIGVkZ2UuIEEgY29udGFjdCBlZGdlIGJlbG9uZ3MgdG8gYSBkb3VibHkgbGlua2VkIGxpc3RcclxuICAgIC8vLyBtYWludGFpbmVkIGluIGVhY2ggYXR0YWNoZWQgYm9keS4gRWFjaCBjb250YWN0IGhhcyB0d28gY29udGFjdFxyXG4gICAgLy8vIG5vZGVzLCBvbmUgZm9yIGVhY2ggYXR0YWNoZWQgYm9keS5cclxuICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICBwdWJsaWMgc2VhbGVkIGNsYXNzIENvbnRhY3RFZGdlXHJcbiAgICB7XHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBUaGUgY29udGFjdFxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgcHVibGljIENvbnRhY3QgQ29udGFjdDtcclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBUaGUgbmV4dCBjb250YWN0IGVkZ2UgaW4gdGhlIGJvZHkncyBjb250YWN0IGxpc3RcclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIHB1YmxpYyBDb250YWN0RWRnZSBOZXh0O1xyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIFByb3ZpZGVzIHF1aWNrIGFjY2VzcyB0byB0aGUgb3RoZXIgYm9keSBhdHRhY2hlZC5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIHB1YmxpYyBCb2R5IE90aGVyO1xyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIFRoZSBwcmV2aW91cyBjb250YWN0IGVkZ2UgaW4gdGhlIGJvZHkncyBjb250YWN0IGxpc3RcclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIHB1YmxpYyBDb250YWN0RWRnZSBQcmV2O1xyXG4gICAgfVxyXG5cclxuICAgIFtGbGFnc11cclxuICAgIHB1YmxpYyBlbnVtIENvbnRhY3RGbGFnc1xyXG4gICAge1xyXG4gICAgICAgIE5vbmUgPSAwLFxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIFVzZWQgd2hlbiBjcmF3bGluZyBjb250YWN0IGdyYXBoIHdoZW4gZm9ybWluZyBpc2xhbmRzLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgSXNsYW5kID0gMHgwMDAxLFxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIFNldCB3aGVuIHRoZSBzaGFwZXMgYXJlIHRvdWNoaW5nLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgVG91Y2hpbmcgPSAweDAwMDIsXHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gVGhpcyBjb250YWN0IGNhbiBiZSBkaXNhYmxlZCAoYnkgdXNlcilcclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIEVuYWJsZWQgPSAweDAwMDQsXHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gVGhpcyBjb250YWN0IG5lZWRzIGZpbHRlcmluZyBiZWNhdXNlIGEgZml4dHVyZSBmaWx0ZXIgd2FzIGNoYW5nZWQuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICBGaWx0ZXIgPSAweDAwMDgsXHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gVGhpcyBidWxsZXQgY29udGFjdCBoYWQgYSBUT0kgZXZlbnRcclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIEJ1bGxldEhpdCA9IDB4MDAxMCxcclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBUaGlzIGNvbnRhY3QgaGFzIGEgdmFsaWQgVE9JIGkgdGhlIGZpZWxkIFRPSVxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgVE9JID0gMHgwMDIwXHJcbiAgICB9XHJcblxyXG4gICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgLy8vIFRoZSBjbGFzcyBtYW5hZ2VzIGNvbnRhY3QgYmV0d2VlbiB0d28gc2hhcGVzLiBBIGNvbnRhY3QgZXhpc3RzIGZvciBlYWNoIG92ZXJsYXBwaW5nXHJcbiAgICAvLy8gQUFCQiBpbiB0aGUgYnJvYWQtcGhhc2UgKGV4Y2VwdCBpZiBmaWx0ZXJlZCkuIFRoZXJlZm9yZSBhIGNvbnRhY3Qgb2JqZWN0IG1heSBleGlzdFxyXG4gICAgLy8vIHRoYXQgaGFzIG5vIGNvbnRhY3QgcG9pbnRzLlxyXG4gICAgLy8vIDwvc3VtbWFyeT5cclxuICAgIHB1YmxpYyBjbGFzcyBDb250YWN0XHJcbiAgICB7XHJcbiAgICAgICAgcHJpdmF0ZSBzdGF0aWMgRWRnZVNoYXBlIF9lZGdlID0gbmV3IEVkZ2VTaGFwZSgpO1xyXG5cclxuICAgICAgICBwcml2YXRlIHN0YXRpYyBDb250YWN0VHlwZVssXSBfcmVnaXN0ZXJzID0gbmV3WyxdXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBDb250YWN0VHlwZS5DaXJjbGUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIENvbnRhY3RUeXBlLkVkZ2VBbmRDaXJjbGUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIENvbnRhY3RUeXBlLlBvbHlnb25BbmRDaXJjbGUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIENvbnRhY3RUeXBlLkxvb3BBbmRDaXJjbGUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIENvbnRhY3RUeXBlLkVkZ2VBbmRDaXJjbGUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIENvbnRhY3RUeXBlLk5vdFN1cHBvcnRlZCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gMSwxIGlzIGludmFsaWQgKG5vIENvbnRhY3RUeXBlLkVkZ2UpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIENvbnRhY3RUeXBlLkVkZ2VBbmRQb2x5Z29uLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBDb250YWN0VHlwZS5Ob3RTdXBwb3J0ZWQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIDEsMyBpcyBpbnZhbGlkIChubyBDb250YWN0VHlwZS5FZGdlQW5kTG9vcClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgQ29udGFjdFR5cGUuUG9seWdvbkFuZENpcmNsZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgQ29udGFjdFR5cGUuRWRnZUFuZFBvbHlnb24sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIENvbnRhY3RUeXBlLlBvbHlnb24sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIENvbnRhY3RUeXBlLkxvb3BBbmRQb2x5Z29uLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBDb250YWN0VHlwZS5Mb29wQW5kQ2lyY2xlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBDb250YWN0VHlwZS5Ob3RTdXBwb3J0ZWQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIDMsMSBpcyBpbnZhbGlkIChubyBDb250YWN0VHlwZS5FZGdlQW5kTG9vcClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgQ29udGFjdFR5cGUuTG9vcEFuZFBvbHlnb24sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIENvbnRhY3RUeXBlLk5vdFN1cHBvcnRlZCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gMywzIGlzIGludmFsaWQgKG5vIENvbnRhY3RUeXBlLkxvb3ApXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgIHB1YmxpYyBGaXh0dXJlIEZpeHR1cmVBO1xyXG4gICAgICAgIHB1YmxpYyBGaXh0dXJlIEZpeHR1cmVCO1xyXG4gICAgICAgIGludGVybmFsIENvbnRhY3RGbGFncyBGbGFncztcclxuXHJcbiAgICAgICAgcHVibGljIE1hbmlmb2xkIE1hbmlmb2xkO1xyXG5cclxuICAgICAgICAvLyBOb2RlcyBmb3IgY29ubmVjdGluZyBib2RpZXMuXHJcbiAgICAgICAgaW50ZXJuYWwgQ29udGFjdEVkZ2UgTm9kZUEgPSBuZXcgQ29udGFjdEVkZ2UoKTtcclxuICAgICAgICBpbnRlcm5hbCBDb250YWN0RWRnZSBOb2RlQiA9IG5ldyBDb250YWN0RWRnZSgpO1xyXG4gICAgICAgIHB1YmxpYyBmbG9hdCBUT0k7XHJcbiAgICAgICAgaW50ZXJuYWwgaW50IFRPSUNvdW50O1xyXG4gICAgICAgIHByaXZhdGUgQ29udGFjdFR5cGUgX3R5cGU7XHJcblxyXG4gICAgICAgIHByaXZhdGUgQ29udGFjdChGaXh0dXJlIGZBLCBpbnQgaW5kZXhBLCBGaXh0dXJlIGZCLCBpbnQgaW5kZXhCKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgUmVzZXQoZkEsIGluZGV4QSwgZkIsIGluZGV4Qik7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gRW5hYmxlL2Rpc2FibGUgdGhpcyBjb250YWN0LiBUaGlzIGNhbiBiZSB1c2VkIGluc2lkZSB0aGUgcHJlLXNvbHZlXHJcbiAgICAgICAgLy8vIGNvbnRhY3QgbGlzdGVuZXIuIFRoZSBjb250YWN0IGlzIG9ubHkgZGlzYWJsZWQgZm9yIHRoZSBjdXJyZW50XHJcbiAgICAgICAgLy8vIHRpbWUgc3RlcCAob3Igc3ViLXN0ZXAgaW4gY29udGludW91cyBjb2xsaXNpb25zKS5cclxuICAgICAgICBwdWJsaWMgYm9vbCBFbmFibGVkXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBzZXRcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIEZsYWdzIHw9IENvbnRhY3RGbGFncy5FbmFibGVkO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIEZsYWdzICY9IH5Db250YWN0RmxhZ3MuRW5hYmxlZDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgZ2V0IHsgcmV0dXJuIChGbGFncyAmIENvbnRhY3RGbGFncy5FbmFibGVkKSA9PSBDb250YWN0RmxhZ3MuRW5hYmxlZDsgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBHZXQgdGhlIGNoaWxkIHByaW1pdGl2ZSBpbmRleCBmb3IgZml4dHVyZSBBLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDx2YWx1ZT5UaGUgY2hpbGQgaW5kZXggQS48L3ZhbHVlPlxyXG4gICAgICAgIHB1YmxpYyBpbnQgQ2hpbGRJbmRleEEgeyBnZXQ7IGludGVybmFsIHNldDsgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIEdldCB0aGUgY2hpbGQgcHJpbWl0aXZlIGluZGV4IGZvciBmaXh0dXJlIEIuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHZhbHVlPlRoZSBjaGlsZCBpbmRleCBCLjwvdmFsdWU+XHJcbiAgICAgICAgcHVibGljIGludCBDaGlsZEluZGV4QiB7IGdldDsgaW50ZXJuYWwgc2V0OyB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gR2V0IHRoZSBjb250YWN0IG1hbmlmb2xkLiBEbyBub3QgbW9kaWZ5IHRoZSBtYW5pZm9sZCB1bmxlc3MgeW91IHVuZGVyc3RhbmQgdGhlXHJcbiAgICAgICAgLy8vIGludGVybmFscyBvZiBCb3gyRC5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cIm1hbmlmb2xkXCI+VGhlIG1hbmlmb2xkLjwvcGFyYW0+XHJcbiAgICAgICAgcHVibGljIHZvaWQgR2V0TWFuaWZvbGQob3V0IE1hbmlmb2xkIG1hbmlmb2xkKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgbWFuaWZvbGQgPSBNYW5pZm9sZDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gR2V0cyB0aGUgd29ybGQgbWFuaWZvbGQuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICBwdWJsaWMgdm9pZCBHZXRXb3JsZE1hbmlmb2xkKG91dCBWZWN0b3IyIG5vcm1hbCwgb3V0IEZpeGVkQXJyYXkyPFZlY3RvcjI+IHBvaW50cylcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIEJvZHkgYm9keUEgPSBGaXh0dXJlQS5Cb2R5O1xyXG4gICAgICAgICAgICBCb2R5IGJvZHlCID0gRml4dHVyZUIuQm9keTtcclxuICAgICAgICAgICAgU2hhcGUgc2hhcGVBID0gRml4dHVyZUEuU2hhcGU7XHJcbiAgICAgICAgICAgIFNoYXBlIHNoYXBlQiA9IEZpeHR1cmVCLlNoYXBlO1xyXG5cclxuICAgICAgICAgICAgQ29sbGlzaW9uLkNvbGxpc2lvbi5HZXRXb3JsZE1hbmlmb2xkKHJlZiBNYW5pZm9sZCwgcmVmIGJvZHlBLlhmLCBzaGFwZUEuUmFkaXVzLCByZWYgYm9keUIuWGYsIHNoYXBlQi5SYWRpdXMsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdXQgbm9ybWFsLCBvdXQgcG9pbnRzKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gRGV0ZXJtaW5lcyB3aGV0aGVyIHRoaXMgY29udGFjdCBpcyB0b3VjaGluZy5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8cmV0dXJucz5cclxuICAgICAgICAvLy8gXHQ8Yz50cnVlPC9jPiBpZiB0aGlzIGluc3RhbmNlIGlzIHRvdWNoaW5nOyBvdGhlcndpc2UsIDxjPmZhbHNlPC9jPi5cclxuICAgICAgICAvLy8gPC9yZXR1cm5zPlxyXG4gICAgICAgIHB1YmxpYyBib29sIElzVG91Y2hpbmcoKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIChGbGFncyAmIENvbnRhY3RGbGFncy5Ub3VjaGluZykgPT0gQ29udGFjdEZsYWdzLlRvdWNoaW5nO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBGbGFnIHRoaXMgY29udGFjdCBmb3IgZmlsdGVyaW5nLiBGaWx0ZXJpbmcgd2lsbCBvY2N1ciB0aGUgbmV4dCB0aW1lIHN0ZXAuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICBwdWJsaWMgdm9pZCBGbGFnRm9yRmlsdGVyaW5nKClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIEZsYWdzIHw9IENvbnRhY3RGbGFncy5GaWx0ZXI7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwcml2YXRlIHZvaWQgUmVzZXQoRml4dHVyZSBmQSwgaW50IGluZGV4QSwgRml4dHVyZSBmQiwgaW50IGluZGV4QilcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIEZsYWdzID0gQ29udGFjdEZsYWdzLkVuYWJsZWQ7XHJcblxyXG4gICAgICAgICAgICBGaXh0dXJlQSA9IGZBO1xyXG4gICAgICAgICAgICBGaXh0dXJlQiA9IGZCO1xyXG5cclxuICAgICAgICAgICAgQ2hpbGRJbmRleEEgPSBpbmRleEE7XHJcbiAgICAgICAgICAgIENoaWxkSW5kZXhCID0gaW5kZXhCO1xyXG5cclxuICAgICAgICAgICAgTWFuaWZvbGQuUG9pbnRDb3VudCA9IDA7XHJcblxyXG4gICAgICAgICAgICBOb2RlQS5Db250YWN0ID0gbnVsbDtcclxuICAgICAgICAgICAgTm9kZUEuUHJldiA9IG51bGw7XHJcbiAgICAgICAgICAgIE5vZGVBLk5leHQgPSBudWxsO1xyXG4gICAgICAgICAgICBOb2RlQS5PdGhlciA9IG51bGw7XHJcblxyXG4gICAgICAgICAgICBOb2RlQi5Db250YWN0ID0gbnVsbDtcclxuICAgICAgICAgICAgTm9kZUIuUHJldiA9IG51bGw7XHJcbiAgICAgICAgICAgIE5vZGVCLk5leHQgPSBudWxsO1xyXG4gICAgICAgICAgICBOb2RlQi5PdGhlciA9IG51bGw7XHJcblxyXG4gICAgICAgICAgICBUT0lDb3VudCA9IDA7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIFVwZGF0ZSB0aGUgY29udGFjdCBtYW5pZm9sZCBhbmQgdG91Y2hpbmcgc3RhdHVzLlxyXG4gICAgICAgIC8vLyBOb3RlOiBkbyBub3QgYXNzdW1lIHRoZSBmaXh0dXJlIEFBQkJzIGFyZSBvdmVybGFwcGluZyBvciBhcmUgdmFsaWQuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJjb250YWN0TWFuYWdlclwiPlRoZSBjb250YWN0IG1hbmFnZXIuPC9wYXJhbT5cclxuICAgICAgICBpbnRlcm5hbCB2b2lkIFVwZGF0ZShDb250YWN0TWFuYWdlciBjb250YWN0TWFuYWdlcilcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIE1hbmlmb2xkIG9sZE1hbmlmb2xkID0gTWFuaWZvbGQ7XHJcblxyXG4gICAgICAgICAgICAvLyBSZS1lbmFibGUgdGhpcyBjb250YWN0LlxyXG4gICAgICAgICAgICBGbGFncyB8PSBDb250YWN0RmxhZ3MuRW5hYmxlZDtcclxuXHJcbiAgICAgICAgICAgIGJvb2wgdG91Y2hpbmc7XHJcbiAgICAgICAgICAgIGJvb2wgd2FzVG91Y2hpbmcgPSAoRmxhZ3MgJiBDb250YWN0RmxhZ3MuVG91Y2hpbmcpID09IENvbnRhY3RGbGFncy5Ub3VjaGluZztcclxuXHJcbiAgICAgICAgICAgIGJvb2wgc2Vuc29yID0gRml4dHVyZUEuSXNTZW5zb3IgfHwgRml4dHVyZUIuSXNTZW5zb3I7XHJcblxyXG4gICAgICAgICAgICBCb2R5IGJvZHlBID0gRml4dHVyZUEuQm9keTtcclxuICAgICAgICAgICAgQm9keSBib2R5QiA9IEZpeHR1cmVCLkJvZHk7XHJcblxyXG4gICAgICAgICAgICAvLyBJcyB0aGlzIGNvbnRhY3QgYSBzZW5zb3I/XHJcbiAgICAgICAgICAgIGlmIChzZW5zb3IpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIFNoYXBlIHNoYXBlQSA9IEZpeHR1cmVBLlNoYXBlO1xyXG4gICAgICAgICAgICAgICAgU2hhcGUgc2hhcGVCID0gRml4dHVyZUIuU2hhcGU7XHJcbiAgICAgICAgICAgICAgICB0b3VjaGluZyA9IEFBQkIuVGVzdE92ZXJsYXAoc2hhcGVBLCBDaGlsZEluZGV4QSwgc2hhcGVCLCBDaGlsZEluZGV4QiwgcmVmIGJvZHlBLlhmLCByZWYgYm9keUIuWGYpO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIFNlbnNvcnMgZG9uJ3QgZ2VuZXJhdGUgbWFuaWZvbGRzLlxyXG4gICAgICAgICAgICAgICAgTWFuaWZvbGQuUG9pbnRDb3VudCA9IDA7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBFdmFsdWF0ZShyZWYgTWFuaWZvbGQsIHJlZiBib2R5QS5YZiwgcmVmIGJvZHlCLlhmKTtcclxuICAgICAgICAgICAgICAgIHRvdWNoaW5nID0gTWFuaWZvbGQuUG9pbnRDb3VudCA+IDA7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gTWF0Y2ggb2xkIGNvbnRhY3QgaWRzIHRvIG5ldyBjb250YWN0IGlkcyBhbmQgY29weSB0aGVcclxuICAgICAgICAgICAgICAgIC8vIHN0b3JlZCBpbXB1bHNlcyB0byB3YXJtIHN0YXJ0IHRoZSBzb2x2ZXIuXHJcbiAgICAgICAgICAgICAgICBmb3IgKGludCBpID0gMDsgaSA8IE1hbmlmb2xkLlBvaW50Q291bnQ7ICsraSlcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBNYW5pZm9sZFBvaW50IG1wMiA9IE1hbmlmb2xkLlBvaW50c1tpXTtcclxuICAgICAgICAgICAgICAgICAgICBtcDIuTm9ybWFsSW1wdWxzZSA9IDAuMGY7XHJcbiAgICAgICAgICAgICAgICAgICAgbXAyLlRhbmdlbnRJbXB1bHNlID0gMC4wZjtcclxuICAgICAgICAgICAgICAgICAgICBDb250YWN0SUQgaWQyID0gbXAyLklkO1xyXG4gICAgICAgICAgICAgICAgICAgIGJvb2wgZm91bmQgPSBmYWxzZTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgZm9yIChpbnQgaiA9IDA7IGogPCBvbGRNYW5pZm9sZC5Qb2ludENvdW50OyArK2opXHJcbiAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBNYW5pZm9sZFBvaW50IG1wMSA9IG9sZE1hbmlmb2xkLlBvaW50c1tqXTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtcDEuSWQuS2V5ID09IGlkMi5LZXkpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1wMi5Ob3JtYWxJbXB1bHNlID0gbXAxLk5vcm1hbEltcHVsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtcDIuVGFuZ2VudEltcHVsc2UgPSBtcDEuVGFuZ2VudEltcHVsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3VuZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAoZm91bmQgPT0gZmFsc2UpXHJcbiAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBtcDIuTm9ybWFsSW1wdWxzZSA9IDAuMGY7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1wMi5UYW5nZW50SW1wdWxzZSA9IDAuMGY7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICBNYW5pZm9sZC5Qb2ludHNbaV0gPSBtcDI7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKHRvdWNoaW5nICE9IHdhc1RvdWNoaW5nKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIGJvZHlBLkF3YWtlID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICBib2R5Qi5Bd2FrZSA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmICh0b3VjaGluZylcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgRmxhZ3MgfD0gQ29udGFjdEZsYWdzLlRvdWNoaW5nO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgRmxhZ3MgJj0gfkNvbnRhY3RGbGFncy5Ub3VjaGluZztcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKHdhc1RvdWNoaW5nID09IGZhbHNlICYmIHRvdWNoaW5nKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAvL1JlcG9ydCB0aGUgY29sbGlzaW9uIHRvIGJvdGggcGFydGljaXBhbnRzOlxyXG4gICAgICAgICAgICAgICAgaWYgKEZpeHR1cmVBLk9uQ29sbGlzaW9uICE9IG51bGwpXHJcbiAgICAgICAgICAgICAgICAgICAgRW5hYmxlZCA9IEZpeHR1cmVBLk9uQ29sbGlzaW9uKEZpeHR1cmVBLCBGaXh0dXJlQiwgdGhpcyk7XHJcblxyXG4gICAgICAgICAgICAgICAgLy9SZXZlcnNlIHRoZSBvcmRlciBvZiB0aGUgcmVwb3J0ZWQgZml4dHVyZXMuIFRoZSBmaXJzdCBmaXh0dXJlIGlzIGFsd2F5cyB0aGUgb25lIHRoYXQgdGhlXHJcbiAgICAgICAgICAgICAgICAvL3VzZXIgc3Vic2NyaWJlZCB0by5cclxuICAgICAgICAgICAgICAgIGlmIChGaXh0dXJlQi5PbkNvbGxpc2lvbiAhPSBudWxsKVxyXG4gICAgICAgICAgICAgICAgICAgIEVuYWJsZWQgPSBGaXh0dXJlQi5PbkNvbGxpc2lvbihGaXh0dXJlQiwgRml4dHVyZUEsIHRoaXMpO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vQmVnaW5Db250YWN0IGNhbiBhbHNvIHJldHVybiBmYWxzZSBhbmQgZGlzYWJsZSB0aGUgY29udGFjdFxyXG4gICAgICAgICAgICAgICAgaWYgKGNvbnRhY3RNYW5hZ2VyLkJlZ2luQ29udGFjdCAhPSBudWxsKVxyXG4gICAgICAgICAgICAgICAgICAgIEVuYWJsZWQgPSBjb250YWN0TWFuYWdlci5CZWdpbkNvbnRhY3QodGhpcyk7XHJcblxyXG4gICAgICAgICAgICAgICAgLy9pZiB0aGUgdXNlciBkaXNhYmxlZCB0aGUgY29udGFjdCAobmVlZGVkIHRvIGV4Y2x1ZGUgaXQgaW4gVE9JIHNvbHZlciksIHdlIGFsc28gbmVlZCB0byBtYXJrXHJcbiAgICAgICAgICAgICAgICAvL2l0IGFzIG5vdCB0b3VjaGluZy5cclxuICAgICAgICAgICAgICAgIGlmIChFbmFibGVkID09IGZhbHNlKVxyXG4gICAgICAgICAgICAgICAgICAgIEZsYWdzICY9IH5Db250YWN0RmxhZ3MuVG91Y2hpbmc7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmICh3YXNUb3VjaGluZyAmJiB0b3VjaGluZyA9PSBmYWxzZSlcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgLy9SZXBvcnQgdGhlIHNlcGFyYXRpb24gdG8gYm90aCBwYXJ0aWNpcGFudHM6XHJcbiAgICAgICAgICAgICAgICBpZiAoRml4dHVyZUEgIT0gbnVsbCAmJiBGaXh0dXJlQS5PblNlcGFyYXRpb24gIT0gbnVsbClcclxuICAgICAgICAgICAgICAgICAgICBGaXh0dXJlQS5PblNlcGFyYXRpb24oRml4dHVyZUEsIEZpeHR1cmVCKTtcclxuXHJcbiAgICAgICAgICAgICAgICAvL1JldmVyc2UgdGhlIG9yZGVyIG9mIHRoZSByZXBvcnRlZCBmaXh0dXJlcy4gVGhlIGZpcnN0IGZpeHR1cmUgaXMgYWx3YXlzIHRoZSBvbmUgdGhhdCB0aGVcclxuICAgICAgICAgICAgICAgIC8vdXNlciBzdWJzY3JpYmVkIHRvLlxyXG4gICAgICAgICAgICAgICAgaWYgKEZpeHR1cmVCICE9IG51bGwgJiYgRml4dHVyZUIuT25TZXBhcmF0aW9uICE9IG51bGwpXHJcbiAgICAgICAgICAgICAgICAgICAgRml4dHVyZUIuT25TZXBhcmF0aW9uKEZpeHR1cmVCLCBGaXh0dXJlQSk7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKGNvbnRhY3RNYW5hZ2VyLkVuZENvbnRhY3QgIT0gbnVsbClcclxuICAgICAgICAgICAgICAgICAgICBjb250YWN0TWFuYWdlci5FbmRDb250YWN0KHRoaXMpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAoc2Vuc29yKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG5cclxuICAgICAgICAgICAgaWYgKGNvbnRhY3RNYW5hZ2VyLlByZVNvbHZlICE9IG51bGwpXHJcbiAgICAgICAgICAgICAgICBjb250YWN0TWFuYWdlci5QcmVTb2x2ZSh0aGlzLCByZWYgb2xkTWFuaWZvbGQpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBFdmFsdWF0ZSB0aGlzIGNvbnRhY3Qgd2l0aCB5b3VyIG93biBtYW5pZm9sZCBhbmQgdHJhbnNmb3Jtcy4gICBcclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cIm1hbmlmb2xkXCI+VGhlIG1hbmlmb2xkLjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwidHJhbnNmb3JtQVwiPlRoZSBmaXJzdCB0cmFuc2Zvcm0uPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJ0cmFuc2Zvcm1CXCI+VGhlIHNlY29uZCB0cmFuc2Zvcm0uPC9wYXJhbT5cclxuICAgICAgICBwcml2YXRlIHZvaWQgRXZhbHVhdGUocmVmIE1hbmlmb2xkIG1hbmlmb2xkLCByZWYgVHJhbnNmb3JtIHRyYW5zZm9ybUEsIHJlZiBUcmFuc2Zvcm0gdHJhbnNmb3JtQilcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHN3aXRjaCAoX3R5cGUpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGNhc2UgQ29udGFjdFR5cGUuUG9seWdvbjpcclxuICAgICAgICAgICAgICAgICAgICBDb2xsaXNpb24uQ29sbGlzaW9uLkNvbGxpZGVQb2x5Z29ucyhyZWYgbWFuaWZvbGQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKFBvbHlnb25TaGFwZSlGaXh0dXJlQS5TaGFwZSwgcmVmIHRyYW5zZm9ybUEsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKFBvbHlnb25TaGFwZSlGaXh0dXJlQi5TaGFwZSwgcmVmIHRyYW5zZm9ybUIpO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSBDb250YWN0VHlwZS5Qb2x5Z29uQW5kQ2lyY2xlOlxyXG4gICAgICAgICAgICAgICAgICAgIENvbGxpc2lvbi5Db2xsaXNpb24uQ29sbGlkZVBvbHlnb25BbmRDaXJjbGUocmVmIG1hbmlmb2xkLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKFBvbHlnb25TaGFwZSlGaXh0dXJlQS5TaGFwZSwgcmVmIHRyYW5zZm9ybUEsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoQ2lyY2xlU2hhcGUpRml4dHVyZUIuU2hhcGUsIHJlZiB0cmFuc2Zvcm1CKTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgQ29udGFjdFR5cGUuRWRnZUFuZENpcmNsZTpcclxuICAgICAgICAgICAgICAgICAgICBDb2xsaXNpb24uQ29sbGlzaW9uLkNvbGxpZGVFZGdlQW5kQ2lyY2xlKHJlZiBtYW5pZm9sZCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChFZGdlU2hhcGUpRml4dHVyZUEuU2hhcGUsIHJlZiB0cmFuc2Zvcm1BLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKENpcmNsZVNoYXBlKUZpeHR1cmVCLlNoYXBlLCByZWYgdHJhbnNmb3JtQik7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlIENvbnRhY3RUeXBlLkVkZ2VBbmRQb2x5Z29uOlxyXG4gICAgICAgICAgICAgICAgICAgIENvbGxpc2lvbi5Db2xsaXNpb24uQ29sbGlkZUVkZ2VBbmRQb2x5Z29uKHJlZiBtYW5pZm9sZCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoRWRnZVNoYXBlKUZpeHR1cmVBLlNoYXBlLCByZWYgdHJhbnNmb3JtQSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoUG9seWdvblNoYXBlKUZpeHR1cmVCLlNoYXBlLCByZWYgdHJhbnNmb3JtQik7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlIENvbnRhY3RUeXBlLkxvb3BBbmRDaXJjbGU6XHJcbiAgICAgICAgICAgICAgICAgICAgTG9vcFNoYXBlIGxvb3AgPSAoTG9vcFNoYXBlKUZpeHR1cmVBLlNoYXBlO1xyXG4gICAgICAgICAgICAgICAgICAgIGxvb3AuR2V0Q2hpbGRFZGdlKHJlZiBfZWRnZSwgQ2hpbGRJbmRleEEpO1xyXG4gICAgICAgICAgICAgICAgICAgIENvbGxpc2lvbi5Db2xsaXNpb24uQ29sbGlkZUVkZ2VBbmRDaXJjbGUocmVmIG1hbmlmb2xkLCBfZWRnZSwgcmVmIHRyYW5zZm9ybUEsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoQ2lyY2xlU2hhcGUpRml4dHVyZUIuU2hhcGUsIHJlZiB0cmFuc2Zvcm1CKTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgQ29udGFjdFR5cGUuTG9vcEFuZFBvbHlnb246XHJcbiAgICAgICAgICAgICAgICAgICAgTG9vcFNoYXBlIGxvb3AyID0gKExvb3BTaGFwZSlGaXh0dXJlQS5TaGFwZTtcclxuICAgICAgICAgICAgICAgICAgICBsb29wMi5HZXRDaGlsZEVkZ2UocmVmIF9lZGdlLCBDaGlsZEluZGV4QSk7XHJcbiAgICAgICAgICAgICAgICAgICAgQ29sbGlzaW9uLkNvbGxpc2lvbi5Db2xsaWRlRWRnZUFuZFBvbHlnb24ocmVmIG1hbmlmb2xkLCBfZWRnZSwgcmVmIHRyYW5zZm9ybUEsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKFBvbHlnb25TaGFwZSlGaXh0dXJlQi5TaGFwZSwgcmVmIHRyYW5zZm9ybUIpO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSBDb250YWN0VHlwZS5DaXJjbGU6XHJcbiAgICAgICAgICAgICAgICAgICAgQ29sbGlzaW9uLkNvbGxpc2lvbi5Db2xsaWRlQ2lyY2xlcyhyZWYgbWFuaWZvbGQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoQ2lyY2xlU2hhcGUpRml4dHVyZUEuU2hhcGUsIHJlZiB0cmFuc2Zvcm1BLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKENpcmNsZVNoYXBlKUZpeHR1cmVCLlNoYXBlLCByZWYgdHJhbnNmb3JtQik7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGludGVybmFsIHN0YXRpYyBDb250YWN0IENyZWF0ZShGaXh0dXJlIGZpeHR1cmVBLCBpbnQgaW5kZXhBLCBGaXh0dXJlIGZpeHR1cmVCLCBpbnQgaW5kZXhCKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgU2hhcGVUeXBlIHR5cGUxID0gZml4dHVyZUEuU2hhcGVUeXBlO1xyXG4gICAgICAgICAgICBTaGFwZVR5cGUgdHlwZTIgPSBmaXh0dXJlQi5TaGFwZVR5cGU7XHJcblxyXG4gICAgICAgICAgICBEZWJ1Zy5Bc3NlcnQoU2hhcGVUeXBlLlVua25vd24gPCB0eXBlMSAmJiB0eXBlMSA8IFNoYXBlVHlwZS5UeXBlQ291bnQpO1xyXG4gICAgICAgICAgICBEZWJ1Zy5Bc3NlcnQoU2hhcGVUeXBlLlVua25vd24gPCB0eXBlMiAmJiB0eXBlMiA8IFNoYXBlVHlwZS5UeXBlQ291bnQpO1xyXG5cclxuICAgICAgICAgICAgQ29udGFjdCBjO1xyXG4gICAgICAgICAgICBRdWV1ZTxDb250YWN0PiBwb29sID0gZml4dHVyZUEuQm9keS5Xb3JsZC5Db250YWN0UG9vbDtcclxuICAgICAgICAgICAgaWYgKHBvb2wuQ291bnQgPiAwKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBjID0gcG9vbC5EZXF1ZXVlKCk7XHJcbiAgICAgICAgICAgICAgICBpZiAoKHR5cGUxID49IHR5cGUyIHx8ICh0eXBlMSA9PSBTaGFwZVR5cGUuRWRnZSAmJiB0eXBlMiA9PSBTaGFwZVR5cGUuUG9seWdvbikpXHJcbiAgICAgICAgICAgICAgICAgICAgJiZcclxuICAgICAgICAgICAgICAgICAgICAhKHR5cGUyID09IFNoYXBlVHlwZS5FZGdlICYmIHR5cGUxID09IFNoYXBlVHlwZS5Qb2x5Z29uKSlcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBjLlJlc2V0KGZpeHR1cmVBLCBpbmRleEEsIGZpeHR1cmVCLCBpbmRleEIpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIGMuUmVzZXQoZml4dHVyZUIsIGluZGV4QiwgZml4dHVyZUEsIGluZGV4QSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAvLyBFZGdlK1BvbHlnb24gaXMgbm9uLXN5bWV0cmljYWwgZHVlIHRvIHRoZSB3YXkgRXJpbiBoYW5kbGVzIGNvbGxpc2lvbiB0eXBlIHJlZ2lzdHJhdGlvbi5cclxuICAgICAgICAgICAgICAgIGlmICgodHlwZTEgPj0gdHlwZTIgfHwgKHR5cGUxID09IFNoYXBlVHlwZS5FZGdlICYmIHR5cGUyID09IFNoYXBlVHlwZS5Qb2x5Z29uKSlcclxuICAgICAgICAgICAgICAgICAgICAmJlxyXG4gICAgICAgICAgICAgICAgICAgICEodHlwZTIgPT0gU2hhcGVUeXBlLkVkZ2UgJiYgdHlwZTEgPT0gU2hhcGVUeXBlLlBvbHlnb24pKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIGMgPSBuZXcgQ29udGFjdChmaXh0dXJlQSwgaW5kZXhBLCBmaXh0dXJlQiwgaW5kZXhCKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBjID0gbmV3IENvbnRhY3QoZml4dHVyZUIsIGluZGV4QiwgZml4dHVyZUEsIGluZGV4QSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGMuX3R5cGUgPSBfcmVnaXN0ZXJzWyhpbnQpdHlwZTEsIChpbnQpdHlwZTJdO1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIGM7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpbnRlcm5hbCB2b2lkIERlc3Ryb3koKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgRml4dHVyZUEuQm9keS5Xb3JsZC5Db250YWN0UG9vbC5FbnF1ZXVlKHRoaXMpO1xyXG4gICAgICAgICAgICBSZXNldChudWxsLCAwLCBudWxsLCAwKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgICNyZWdpb24gTmVzdGVkIHR5cGU6IENvbnRhY3RUeXBlXHJcblxyXG4gICAgICAgIHByaXZhdGUgZW51bSBDb250YWN0VHlwZVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgTm90U3VwcG9ydGVkLFxyXG4gICAgICAgICAgICBQb2x5Z29uLFxyXG4gICAgICAgICAgICBQb2x5Z29uQW5kQ2lyY2xlLFxyXG4gICAgICAgICAgICBDaXJjbGUsXHJcbiAgICAgICAgICAgIEVkZ2VBbmRQb2x5Z29uLFxyXG4gICAgICAgICAgICBFZGdlQW5kQ2lyY2xlLFxyXG4gICAgICAgICAgICBMb29wQW5kUG9seWdvbixcclxuICAgICAgICAgICAgTG9vcEFuZENpcmNsZSxcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgICNlbmRyZWdpb25cclxuICAgIH1cclxufSIsIi8qXHJcbiogRmFyc2VlciBQaHlzaWNzIEVuZ2luZSBiYXNlZCBvbiBCb3gyRC5YTkEgcG9ydDpcclxuKiBDb3B5cmlnaHQgKGMpIDIwMTAgSWFuIFF2aXN0XHJcbiogXHJcbiogQm94MkQuWE5BIHBvcnQgb2YgQm94MkQ6XHJcbiogQ29weXJpZ2h0IChjKSAyMDA5IEJyYW5kb24gRnVydHdhbmdsZXIsIE5hdGhhbiBGdXJ0d2FuZ2xlclxyXG4qXHJcbiogT3JpZ2luYWwgc291cmNlIEJveDJEOlxyXG4qIENvcHlyaWdodCAoYykgMjAwNi0yMDA5IEVyaW4gQ2F0dG8gaHR0cDovL3d3dy5ncGh5c2ljcy5jb20gXHJcbiogXHJcbiogVGhpcyBzb2Z0d2FyZSBpcyBwcm92aWRlZCAnYXMtaXMnLCB3aXRob3V0IGFueSBleHByZXNzIG9yIGltcGxpZWQgXHJcbiogd2FycmFudHkuICBJbiBubyBldmVudCB3aWxsIHRoZSBhdXRob3JzIGJlIGhlbGQgbGlhYmxlIGZvciBhbnkgZGFtYWdlcyBcclxuKiBhcmlzaW5nIGZyb20gdGhlIHVzZSBvZiB0aGlzIHNvZnR3YXJlLiBcclxuKiBQZXJtaXNzaW9uIGlzIGdyYW50ZWQgdG8gYW55b25lIHRvIHVzZSB0aGlzIHNvZnR3YXJlIGZvciBhbnkgcHVycG9zZSwgXHJcbiogaW5jbHVkaW5nIGNvbW1lcmNpYWwgYXBwbGljYXRpb25zLCBhbmQgdG8gYWx0ZXIgaXQgYW5kIHJlZGlzdHJpYnV0ZSBpdCBcclxuKiBmcmVlbHksIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyByZXN0cmljdGlvbnM6IFxyXG4qIDEuIFRoZSBvcmlnaW4gb2YgdGhpcyBzb2Z0d2FyZSBtdXN0IG5vdCBiZSBtaXNyZXByZXNlbnRlZDsgeW91IG11c3Qgbm90IFxyXG4qIGNsYWltIHRoYXQgeW91IHdyb3RlIHRoZSBvcmlnaW5hbCBzb2Z0d2FyZS4gSWYgeW91IHVzZSB0aGlzIHNvZnR3YXJlIFxyXG4qIGluIGEgcHJvZHVjdCwgYW4gYWNrbm93bGVkZ21lbnQgaW4gdGhlIHByb2R1Y3QgZG9jdW1lbnRhdGlvbiB3b3VsZCBiZSBcclxuKiBhcHByZWNpYXRlZCBidXQgaXMgbm90IHJlcXVpcmVkLiBcclxuKiAyLiBBbHRlcmVkIHNvdXJjZSB2ZXJzaW9ucyBtdXN0IGJlIHBsYWlubHkgbWFya2VkIGFzIHN1Y2gsIGFuZCBtdXN0IG5vdCBiZSBcclxuKiBtaXNyZXByZXNlbnRlZCBhcyBiZWluZyB0aGUgb3JpZ2luYWwgc29mdHdhcmUuIFxyXG4qIDMuIFRoaXMgbm90aWNlIG1heSBub3QgYmUgcmVtb3ZlZCBvciBhbHRlcmVkIGZyb20gYW55IHNvdXJjZSBkaXN0cmlidXRpb24uIFxyXG4qL1xyXG5cclxudXNpbmcgU3lzdGVtO1xyXG51c2luZyBTeXN0ZW0uTGlucTtcclxudXNpbmcgU3lzdGVtLkRpYWdub3N0aWNzO1xyXG51c2luZyBGYXJzZWVyUGh5c2ljcy5Db2xsaXNpb247XHJcbnVzaW5nIEZhcnNlZXJQaHlzaWNzLkNvbGxpc2lvbi5TaGFwZXM7XHJcbnVzaW5nIEZhcnNlZXJQaHlzaWNzLkNvbW1vbjtcclxudXNpbmcgTWljcm9zb2Z0LlhuYS5GcmFtZXdvcms7XHJcblxyXG5uYW1lc3BhY2UgRmFyc2VlclBoeXNpY3MuRHluYW1pY3MuQ29udGFjdHNcclxue1xyXG4gICAgcHVibGljIHNlYWxlZCBjbGFzcyBDb250YWN0Q29uc3RyYWludFBvaW50XHJcbiAgICB7XHJcbiAgICAgICAgcHVibGljIFZlY3RvcjIgTG9jYWxQb2ludDtcclxuICAgICAgICBwdWJsaWMgZmxvYXQgTm9ybWFsSW1wdWxzZTtcclxuICAgICAgICBwdWJsaWMgZmxvYXQgTm9ybWFsTWFzcztcclxuICAgICAgICBwdWJsaWMgZmxvYXQgVGFuZ2VudEltcHVsc2U7XHJcbiAgICAgICAgcHVibGljIGZsb2F0IFRhbmdlbnRNYXNzO1xyXG4gICAgICAgIHB1YmxpYyBmbG9hdCBWZWxvY2l0eUJpYXM7XHJcbiAgICAgICAgcHVibGljIFZlY3RvcjIgckE7XHJcbiAgICAgICAgcHVibGljIFZlY3RvcjIgckI7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIHNlYWxlZCBjbGFzcyBDb250YWN0Q29uc3RyYWludFxyXG4gICAge1xyXG4gICAgICAgIHB1YmxpYyBCb2R5IEJvZHlBO1xyXG4gICAgICAgIHB1YmxpYyBCb2R5IEJvZHlCO1xyXG4gICAgICAgIHB1YmxpYyBmbG9hdCBGcmljdGlvbjtcclxuICAgICAgICBwdWJsaWMgTWF0MjIgSztcclxuICAgICAgICBwdWJsaWMgVmVjdG9yMiBMb2NhbE5vcm1hbDtcclxuICAgICAgICBwdWJsaWMgVmVjdG9yMiBMb2NhbFBvaW50O1xyXG4gICAgICAgIHB1YmxpYyBNYW5pZm9sZCBNYW5pZm9sZDtcclxuICAgICAgICBwdWJsaWMgVmVjdG9yMiBOb3JtYWw7XHJcbiAgICAgICAgcHVibGljIE1hdDIyIE5vcm1hbE1hc3M7XHJcbiAgICAgICAgcHVibGljIGludCBQb2ludENvdW50O1xyXG4gICAgICAgIHB1YmxpYyBDb250YWN0Q29uc3RyYWludFBvaW50W10gUG9pbnRzID0gbmV3IENvbnRhY3RDb25zdHJhaW50UG9pbnRbU2V0dGluZ3MuTWF4UG9seWdvblZlcnRpY2VzXTtcclxuICAgICAgICBwdWJsaWMgZmxvYXQgUmFkaXVzQTtcclxuICAgICAgICBwdWJsaWMgZmxvYXQgUmFkaXVzQjtcclxuICAgICAgICBwdWJsaWMgZmxvYXQgUmVzdGl0dXRpb247XHJcbiAgICAgICAgcHVibGljIE1hbmlmb2xkVHlwZSBUeXBlO1xyXG5cclxuICAgICAgICBwdWJsaWMgQ29udGFjdENvbnN0cmFpbnQoKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgZm9yIChpbnQgaSA9IDA7IGkgPCBTZXR0aW5ncy5NYXhNYW5pZm9sZFBvaW50czsgaSsrKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBQb2ludHNbaV0gPSBuZXcgQ29udGFjdENvbnN0cmFpbnRQb2ludCgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBjbGFzcyBDb250YWN0U29sdmVyXHJcbiAgICB7XHJcbiAgICAgICAgcHVibGljIENvbnRhY3RDb25zdHJhaW50W10gQ29uc3RyYWludHM7XHJcbiAgICAgICAgcHJpdmF0ZSBpbnQgX2NvbnN0cmFpbnRDb3VudDsgLy8gY29sbGVjdGlvbiBjYW4gYmUgYmlnZ2VyLlxyXG4gICAgICAgIHByaXZhdGUgQ29udGFjdFtdIF9jb250YWN0cztcclxuXHJcbiAgICAgICAgcHVibGljIHZvaWQgUmVzZXQoQ29udGFjdFtdIGNvbnRhY3RzLCBpbnQgY29udGFjdENvdW50LCBmbG9hdCBpbXB1bHNlUmF0aW8sIGJvb2wgd2FybXN0YXJ0aW5nKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgX2NvbnRhY3RzID0gY29udGFjdHM7XHJcbiAgICAgICAgICAgIF9jb25zdHJhaW50Q291bnQgPSBjb250YWN0Q291bnQ7XHJcblxyXG4gICAgICAgICAgICAvLyBncm93IHRoZSBhcnJheVxyXG4gICAgICAgICAgICBpZiAoQ29uc3RyYWludHMgPT0gbnVsbCB8fCBDb25zdHJhaW50cy5MZW5ndGggPCBfY29uc3RyYWludENvdW50KVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBDb25zdHJhaW50cyA9IG5ldyBDb250YWN0Q29uc3RyYWludFtjb250YWN0Q291bnQgKiAyXTtcclxuICAgICAgICAgICAgICAgIGZvciAoaW50IGkgPSAwOyBpIDwgQ29uc3RyYWludHMuTGVuZ3RoOyBpKyspXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIENvbnN0cmFpbnRzW2ldID0gbmV3IENvbnRhY3RDb25zdHJhaW50KCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIEluaXRpYWxpemUgcG9zaXRpb24gaW5kZXBlbmRlbnQgcG9ydGlvbnMgb2YgdGhlIGNvbnN0cmFpbnRzLlxyXG4gICAgICAgICAgICBmb3IgKGludCBpID0gMDsgaSA8IF9jb25zdHJhaW50Q291bnQ7ICsraSlcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgQ29udGFjdCBjb250YWN0ID0gX2NvbnRhY3RzW2ldO1xyXG5cclxuICAgICAgICAgICAgICAgIEZpeHR1cmUgZml4dHVyZUEgPSBjb250YWN0LkZpeHR1cmVBO1xyXG4gICAgICAgICAgICAgICAgRml4dHVyZSBmaXh0dXJlQiA9IGNvbnRhY3QuRml4dHVyZUI7XHJcbiAgICAgICAgICAgICAgICBTaGFwZSBzaGFwZUEgPSBmaXh0dXJlQS5TaGFwZTtcclxuICAgICAgICAgICAgICAgIFNoYXBlIHNoYXBlQiA9IGZpeHR1cmVCLlNoYXBlO1xyXG4gICAgICAgICAgICAgICAgZmxvYXQgcmFkaXVzQSA9IHNoYXBlQS5SYWRpdXM7XHJcbiAgICAgICAgICAgICAgICBmbG9hdCByYWRpdXNCID0gc2hhcGVCLlJhZGl1cztcclxuICAgICAgICAgICAgICAgIEJvZHkgYm9keUEgPSBmaXh0dXJlQS5Cb2R5O1xyXG4gICAgICAgICAgICAgICAgQm9keSBib2R5QiA9IGZpeHR1cmVCLkJvZHk7XHJcbiAgICAgICAgICAgICAgICBNYW5pZm9sZCBtYW5pZm9sZCA9IGNvbnRhY3QuTWFuaWZvbGQ7XHJcblxyXG4gICAgICAgICAgICAgICAgRGVidWcuQXNzZXJ0KG1hbmlmb2xkLlBvaW50Q291bnQgPiAwKTtcclxuXHJcbiAgICAgICAgICAgICAgICBDb250YWN0Q29uc3RyYWludCBjYyA9IENvbnN0cmFpbnRzW2ldO1xyXG4gICAgICAgICAgICAgICAgY2MuRnJpY3Rpb24gPSBTZXR0aW5ncy5NaXhGcmljdGlvbihmaXh0dXJlQS5GcmljdGlvbiwgZml4dHVyZUIuRnJpY3Rpb24pO1xyXG4gICAgICAgICAgICAgICAgY2MuUmVzdGl0dXRpb24gPSBTZXR0aW5ncy5NaXhSZXN0aXR1dGlvbihmaXh0dXJlQS5SZXN0aXR1dGlvbiwgZml4dHVyZUIuUmVzdGl0dXRpb24pO1xyXG4gICAgICAgICAgICAgICAgY2MuQm9keUEgPSBib2R5QTtcclxuICAgICAgICAgICAgICAgIGNjLkJvZHlCID0gYm9keUI7XHJcbiAgICAgICAgICAgICAgICBjYy5NYW5pZm9sZCA9IG1hbmlmb2xkO1xyXG4gICAgICAgICAgICAgICAgY2MuTm9ybWFsID0gVmVjdG9yMi5aZXJvO1xyXG4gICAgICAgICAgICAgICAgY2MuUG9pbnRDb3VudCA9IG1hbmlmb2xkLlBvaW50Q291bnQ7XHJcblxyXG4gICAgICAgICAgICAgICAgY2MuTG9jYWxOb3JtYWwgPSBtYW5pZm9sZC5Mb2NhbE5vcm1hbDtcclxuICAgICAgICAgICAgICAgIGNjLkxvY2FsUG9pbnQgPSBtYW5pZm9sZC5Mb2NhbFBvaW50O1xyXG4gICAgICAgICAgICAgICAgY2MuUmFkaXVzQSA9IHJhZGl1c0E7XHJcbiAgICAgICAgICAgICAgICBjYy5SYWRpdXNCID0gcmFkaXVzQjtcclxuICAgICAgICAgICAgICAgIGNjLlR5cGUgPSBtYW5pZm9sZC5UeXBlO1xyXG5cclxuICAgICAgICAgICAgICAgIGZvciAoaW50IGogPSAwOyBqIDwgY2MuUG9pbnRDb3VudDsgKytqKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIE1hbmlmb2xkUG9pbnQgY3AgPSBtYW5pZm9sZC5Qb2ludHNbal07XHJcbiAgICAgICAgICAgICAgICAgICAgQ29udGFjdENvbnN0cmFpbnRQb2ludCBjY3AgPSBjYy5Qb2ludHNbal07XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmICh3YXJtc3RhcnRpbmcpXHJcbiAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjY3AuTm9ybWFsSW1wdWxzZSA9IGltcHVsc2VSYXRpbyAqIGNwLk5vcm1hbEltcHVsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNjcC5UYW5nZW50SW1wdWxzZSA9IGltcHVsc2VSYXRpbyAqIGNwLlRhbmdlbnRJbXB1bHNlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjY3AuTm9ybWFsSW1wdWxzZSA9IDAuMGY7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNjcC5UYW5nZW50SW1wdWxzZSA9IDAuMGY7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICBjY3AuTG9jYWxQb2ludCA9IGNwLkxvY2FsUG9pbnQ7XHJcbiAgICAgICAgICAgICAgICAgICAgY2NwLnJBID0gVmVjdG9yMi5aZXJvO1xyXG4gICAgICAgICAgICAgICAgICAgIGNjcC5yQiA9IFZlY3RvcjIuWmVybztcclxuICAgICAgICAgICAgICAgICAgICBjY3AuTm9ybWFsTWFzcyA9IDAuMGY7XHJcbiAgICAgICAgICAgICAgICAgICAgY2NwLlRhbmdlbnRNYXNzID0gMC4wZjtcclxuICAgICAgICAgICAgICAgICAgICBjY3AuVmVsb2NpdHlCaWFzID0gMC4wZjtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBjYy5LLlNldFplcm8oKTtcclxuICAgICAgICAgICAgICAgIGNjLk5vcm1hbE1hc3MuU2V0WmVybygpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwdWJsaWMgdm9pZCBJbml0aWFsaXplVmVsb2NpdHlDb25zdHJhaW50cygpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBmb3IgKGludCBpID0gMDsgaSA8IF9jb25zdHJhaW50Q291bnQ7ICsraSlcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgQ29udGFjdENvbnN0cmFpbnQgY2MgPSBDb25zdHJhaW50c1tpXTtcclxuXHJcbiAgICAgICAgICAgICAgICBmbG9hdCByYWRpdXNBID0gY2MuUmFkaXVzQTtcclxuICAgICAgICAgICAgICAgIGZsb2F0IHJhZGl1c0IgPSBjYy5SYWRpdXNCO1xyXG4gICAgICAgICAgICAgICAgQm9keSBib2R5QSA9IGNjLkJvZHlBO1xyXG4gICAgICAgICAgICAgICAgQm9keSBib2R5QiA9IGNjLkJvZHlCO1xyXG4gICAgICAgICAgICAgICAgTWFuaWZvbGQgbWFuaWZvbGQgPSBjYy5NYW5pZm9sZDtcclxuXHJcbiAgICAgICAgICAgICAgICBWZWN0b3IyIHZBID0gYm9keUEuTGluZWFyVmVsb2NpdHk7XHJcbiAgICAgICAgICAgICAgICBWZWN0b3IyIHZCID0gYm9keUIuTGluZWFyVmVsb2NpdHk7XHJcbiAgICAgICAgICAgICAgICBmbG9hdCB3QSA9IGJvZHlBLkFuZ3VsYXJWZWxvY2l0eTtcclxuICAgICAgICAgICAgICAgIGZsb2F0IHdCID0gYm9keUIuQW5ndWxhclZlbG9jaXR5O1xyXG5cclxuICAgICAgICAgICAgICAgIERlYnVnLkFzc2VydChtYW5pZm9sZC5Qb2ludENvdW50ID4gMCk7XHJcbiAgICAgICAgICAgICAgICBGaXhlZEFycmF5MjxWZWN0b3IyPiBwb2ludHM7XHJcblxyXG4gICAgICAgICAgICAgICAgQ29sbGlzaW9uLkNvbGxpc2lvbi5HZXRXb3JsZE1hbmlmb2xkKHJlZiBtYW5pZm9sZCwgcmVmIGJvZHlBLlhmLCByYWRpdXNBLCByZWYgYm9keUIuWGYsIHJhZGl1c0IsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3V0IGNjLk5vcm1hbCwgb3V0IHBvaW50cyk7XHJcbiAgICAgICAgICAgICAgICBWZWN0b3IyIHRhbmdlbnQgPSBuZXcgVmVjdG9yMihjYy5Ob3JtYWwuWSwgLWNjLk5vcm1hbC5YKTtcclxuXHJcbiAgICAgICAgICAgICAgICBmb3IgKGludCBqID0gMDsgaiA8IGNjLlBvaW50Q291bnQ7ICsrailcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBDb250YWN0Q29uc3RyYWludFBvaW50IGNjcCA9IGNjLlBvaW50c1tqXTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgY2NwLnJBID0gcG9pbnRzW2pdIC0gYm9keUEuU3dlZXAuQztcclxuICAgICAgICAgICAgICAgICAgICBjY3AuckIgPSBwb2ludHNbal0gLSBib2R5Qi5Td2VlcC5DO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBmbG9hdCBybkEgPSBjY3AuckEuWCAqIGNjLk5vcm1hbC5ZIC0gY2NwLnJBLlkgKiBjYy5Ob3JtYWwuWDtcclxuICAgICAgICAgICAgICAgICAgICBmbG9hdCBybkIgPSBjY3AuckIuWCAqIGNjLk5vcm1hbC5ZIC0gY2NwLnJCLlkgKiBjYy5Ob3JtYWwuWDtcclxuICAgICAgICAgICAgICAgICAgICBybkEgKj0gcm5BO1xyXG4gICAgICAgICAgICAgICAgICAgIHJuQiAqPSBybkI7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGZsb2F0IGtOb3JtYWwgPSBib2R5QS5JbnZNYXNzICsgYm9keUIuSW52TWFzcyArIGJvZHlBLkludkkgKiBybkEgKyBib2R5Qi5JbnZJICogcm5CO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBEZWJ1Zy5Bc3NlcnQoa05vcm1hbCA+IFNldHRpbmdzLkVwc2lsb24pO1xyXG4gICAgICAgICAgICAgICAgICAgIGNjcC5Ob3JtYWxNYXNzID0gMS4wZiAvIGtOb3JtYWw7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGZsb2F0IHJ0QSA9IGNjcC5yQS5YICogdGFuZ2VudC5ZIC0gY2NwLnJBLlkgKiB0YW5nZW50Llg7XHJcbiAgICAgICAgICAgICAgICAgICAgZmxvYXQgcnRCID0gY2NwLnJCLlggKiB0YW5nZW50LlkgLSBjY3AuckIuWSAqIHRhbmdlbnQuWDtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgcnRBICo9IHJ0QTtcclxuICAgICAgICAgICAgICAgICAgICBydEIgKj0gcnRCO1xyXG4gICAgICAgICAgICAgICAgICAgIGZsb2F0IGtUYW5nZW50ID0gYm9keUEuSW52TWFzcyArIGJvZHlCLkludk1hc3MgKyBib2R5QS5JbnZJICogcnRBICsgYm9keUIuSW52SSAqIHJ0QjtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgRGVidWcuQXNzZXJ0KGtUYW5nZW50ID4gU2V0dGluZ3MuRXBzaWxvbik7XHJcbiAgICAgICAgICAgICAgICAgICAgY2NwLlRhbmdlbnRNYXNzID0gMS4wZiAvIGtUYW5nZW50O1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBTZXR1cCBhIHZlbG9jaXR5IGJpYXMgZm9yIHJlc3RpdHV0aW9uLlxyXG4gICAgICAgICAgICAgICAgICAgIGNjcC5WZWxvY2l0eUJpYXMgPSAwLjBmO1xyXG4gICAgICAgICAgICAgICAgICAgIGZsb2F0IHZSZWwgPSBjYy5Ob3JtYWwuWCAqICh2Qi5YICsgLXdCICogY2NwLnJCLlkgLSB2QS5YIC0gLXdBICogY2NwLnJBLlkpICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2MuTm9ybWFsLlkgKiAodkIuWSArIHdCICogY2NwLnJCLlggLSB2QS5ZIC0gd0EgKiBjY3AuckEuWCk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZSZWwgPCAtU2V0dGluZ3MuVmVsb2NpdHlUaHJlc2hvbGQpXHJcbiAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjY3AuVmVsb2NpdHlCaWFzID0gLWNjLlJlc3RpdHV0aW9uICogdlJlbDtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gSWYgd2UgaGF2ZSB0d28gcG9pbnRzLCB0aGVuIHByZXBhcmUgdGhlIGJsb2NrIHNvbHZlci5cclxuICAgICAgICAgICAgICAgIGlmIChjYy5Qb2ludENvdW50ID09IDIpXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgQ29udGFjdENvbnN0cmFpbnRQb2ludCBjY3AxID0gY2MuUG9pbnRzWzBdO1xyXG4gICAgICAgICAgICAgICAgICAgIENvbnRhY3RDb25zdHJhaW50UG9pbnQgY2NwMiA9IGNjLlBvaW50c1sxXTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgZmxvYXQgaW52TWFzc0EgPSBib2R5QS5JbnZNYXNzO1xyXG4gICAgICAgICAgICAgICAgICAgIGZsb2F0IGludklBID0gYm9keUEuSW52STtcclxuICAgICAgICAgICAgICAgICAgICBmbG9hdCBpbnZNYXNzQiA9IGJvZHlCLkludk1hc3M7XHJcbiAgICAgICAgICAgICAgICAgICAgZmxvYXQgaW52SUIgPSBib2R5Qi5JbnZJO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBmbG9hdCBybjFBID0gY2NwMS5yQS5YICogY2MuTm9ybWFsLlkgLSBjY3AxLnJBLlkgKiBjYy5Ob3JtYWwuWDtcclxuICAgICAgICAgICAgICAgICAgICBmbG9hdCBybjFCID0gY2NwMS5yQi5YICogY2MuTm9ybWFsLlkgLSBjY3AxLnJCLlkgKiBjYy5Ob3JtYWwuWDtcclxuICAgICAgICAgICAgICAgICAgICBmbG9hdCBybjJBID0gY2NwMi5yQS5YICogY2MuTm9ybWFsLlkgLSBjY3AyLnJBLlkgKiBjYy5Ob3JtYWwuWDtcclxuICAgICAgICAgICAgICAgICAgICBmbG9hdCBybjJCID0gY2NwMi5yQi5YICogY2MuTm9ybWFsLlkgLSBjY3AyLnJCLlkgKiBjYy5Ob3JtYWwuWDtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgZmxvYXQgazExID0gaW52TWFzc0EgKyBpbnZNYXNzQiArIGludklBICogcm4xQSAqIHJuMUEgKyBpbnZJQiAqIHJuMUIgKiBybjFCO1xyXG4gICAgICAgICAgICAgICAgICAgIGZsb2F0IGsyMiA9IGludk1hc3NBICsgaW52TWFzc0IgKyBpbnZJQSAqIHJuMkEgKiBybjJBICsgaW52SUIgKiBybjJCICogcm4yQjtcclxuICAgICAgICAgICAgICAgICAgICBmbG9hdCBrMTIgPSBpbnZNYXNzQSArIGludk1hc3NCICsgaW52SUEgKiBybjFBICogcm4yQSArIGludklCICogcm4xQiAqIHJuMkI7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIEVuc3VyZSBhIHJlYXNvbmFibGUgY29uZGl0aW9uIG51bWJlci5cclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBmbG9hdCBrX21heENvbmRpdGlvbk51bWJlciA9IDEwMC4wZjtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoazExICogazExIDwga19tYXhDb25kaXRpb25OdW1iZXIgKiAoazExICogazIyIC0gazEyICogazEyKSlcclxuICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEsgaXMgc2FmZSB0byBpbnZlcnQuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNjLksuQ29sMS5YID0gazExO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYy5LLkNvbDEuWSA9IGsxMjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2MuSy5Db2wyLlggPSBrMTI7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNjLksuQ29sMi5ZID0gazIyO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgZmxvYXQgYSA9IGNjLksuQ29sMS5YLCBiID0gY2MuSy5Db2wyLlgsIGMgPSBjYy5LLkNvbDEuWSwgZCA9IGNjLksuQ29sMi5ZO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBmbG9hdCBkZXQgPSBhICogZCAtIGIgKiBjO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZGV0ICE9IDAuMGYpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRldCA9IDEuMGYgLyBkZXQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNjLk5vcm1hbE1hc3MuQ29sMS5YID0gZGV0ICogZDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2MuTm9ybWFsTWFzcy5Db2wxLlkgPSAtZGV0ICogYztcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2MuTm9ybWFsTWFzcy5Db2wyLlggPSAtZGV0ICogYjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2MuTm9ybWFsTWFzcy5Db2wyLlkgPSBkZXQgKiBhO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGUgY29uc3RyYWludHMgYXJlIHJlZHVuZGFudCwganVzdCB1c2Ugb25lLlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUT0RPX0VSSU4gdXNlIGRlZXBlc3Q/XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNjLlBvaW50Q291bnQgPSAxO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHVibGljIHZvaWQgV2FybVN0YXJ0KClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIC8vIFdhcm0gc3RhcnQuXHJcbiAgICAgICAgICAgIGZvciAoaW50IGkgPSAwOyBpIDwgX2NvbnN0cmFpbnRDb3VudDsgKytpKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBDb250YWN0Q29uc3RyYWludCBjID0gQ29uc3RyYWludHNbaV07XHJcblxyXG4gICAgICAgICAgICAgICAgZmxvYXQgdGFuZ2VudHggPSBjLk5vcm1hbC5ZO1xyXG4gICAgICAgICAgICAgICAgZmxvYXQgdGFuZ2VudHkgPSAtYy5Ob3JtYWwuWDtcclxuXHJcbiAgICAgICAgICAgICAgICBmb3IgKGludCBqID0gMDsgaiA8IGMuUG9pbnRDb3VudDsgKytqKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIENvbnRhY3RDb25zdHJhaW50UG9pbnQgY2NwID0gYy5Qb2ludHNbal07XHJcbiAgICAgICAgICAgICAgICAgICAgZmxvYXQgcHggPSBjY3AuTm9ybWFsSW1wdWxzZSAqIGMuTm9ybWFsLlggKyBjY3AuVGFuZ2VudEltcHVsc2UgKiB0YW5nZW50eDtcclxuICAgICAgICAgICAgICAgICAgICBmbG9hdCBweSA9IGNjcC5Ob3JtYWxJbXB1bHNlICogYy5Ob3JtYWwuWSArIGNjcC5UYW5nZW50SW1wdWxzZSAqIHRhbmdlbnR5O1xyXG4gICAgICAgICAgICAgICAgICAgIGMuQm9keUEuQW5ndWxhclZlbG9jaXR5SW50ZXJuYWwgLT0gYy5Cb2R5QS5JbnZJICogKGNjcC5yQS5YICogcHkgLSBjY3AuckEuWSAqIHB4KTtcclxuICAgICAgICAgICAgICAgICAgICBjLkJvZHlBLkxpbmVhclZlbG9jaXR5SW50ZXJuYWwuWCAtPSBjLkJvZHlBLkludk1hc3MgKiBweDtcclxuICAgICAgICAgICAgICAgICAgICBjLkJvZHlBLkxpbmVhclZlbG9jaXR5SW50ZXJuYWwuWSAtPSBjLkJvZHlBLkludk1hc3MgKiBweTtcclxuICAgICAgICAgICAgICAgICAgICBjLkJvZHlCLkFuZ3VsYXJWZWxvY2l0eUludGVybmFsICs9IGMuQm9keUIuSW52SSAqIChjY3AuckIuWCAqIHB5IC0gY2NwLnJCLlkgKiBweCk7XHJcbiAgICAgICAgICAgICAgICAgICAgYy5Cb2R5Qi5MaW5lYXJWZWxvY2l0eUludGVybmFsLlggKz0gYy5Cb2R5Qi5JbnZNYXNzICogcHg7XHJcbiAgICAgICAgICAgICAgICAgICAgYy5Cb2R5Qi5MaW5lYXJWZWxvY2l0eUludGVybmFsLlkgKz0gYy5Cb2R5Qi5JbnZNYXNzICogcHk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHB1YmxpYyB2b2lkIFNvbHZlVmVsb2NpdHlDb25zdHJhaW50cygpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBmb3IgKGludCBpID0gMDsgaSA8IF9jb25zdHJhaW50Q291bnQ7ICsraSlcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgQ29udGFjdENvbnN0cmFpbnQgYyA9IENvbnN0cmFpbnRzW2ldO1xyXG4gICAgICAgICAgICAgICAgaWYgKGMuQm9keUEuUGVuZXRyYWJsZSB8fCBjLkJvZHlCLlBlbmV0cmFibGUpXHJcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICBmbG9hdCB3QSA9IGMuQm9keUEuQW5ndWxhclZlbG9jaXR5SW50ZXJuYWw7XHJcbiAgICAgICAgICAgICAgICBmbG9hdCB3QiA9IGMuQm9keUIuQW5ndWxhclZlbG9jaXR5SW50ZXJuYWw7XHJcblxyXG4gICAgICAgICAgICAgICAgZmxvYXQgdGFuZ2VudHggPSBjLk5vcm1hbC5ZO1xyXG4gICAgICAgICAgICAgICAgZmxvYXQgdGFuZ2VudHkgPSAtYy5Ob3JtYWwuWDtcclxuXHJcbiAgICAgICAgICAgICAgICBmbG9hdCBmcmljdGlvbiA9IGMuRnJpY3Rpb247XHJcblxyXG4gICAgICAgICAgICAgICAgRGVidWcuQXNzZXJ0KGMuUG9pbnRDb3VudCA9PSAxIHx8IGMuUG9pbnRDb3VudCA9PSAyKTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBTb2x2ZSB0YW5nZW50IGNvbnN0cmFpbnRzXHJcbiAgICAgICAgICAgICAgICBmb3IgKGludCBqID0gMDsgaiA8IGMuUG9pbnRDb3VudDsgKytqKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIENvbnRhY3RDb25zdHJhaW50UG9pbnQgY2NwID0gYy5Qb2ludHNbal07XHJcbiAgICAgICAgICAgICAgICAgICAgZmxvYXQgbGFtYmRhID0gY2NwLlRhbmdlbnRNYXNzICpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAtKChjLkJvZHlCLkxpbmVhclZlbG9jaXR5SW50ZXJuYWwuWCArICgtd0IgKiBjY3AuckIuWSkgLVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGMuQm9keUEuTGluZWFyVmVsb2NpdHlJbnRlcm5hbC5YIC0gKC13QSAqIGNjcC5yQS5ZKSkgKiB0YW5nZW50eCArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoYy5Cb2R5Qi5MaW5lYXJWZWxvY2l0eUludGVybmFsLlkgKyAod0IgKiBjY3AuckIuWCkgLVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGMuQm9keUEuTGluZWFyVmVsb2NpdHlJbnRlcm5hbC5ZIC0gKHdBICogY2NwLnJBLlgpKSAqIHRhbmdlbnR5KTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gTWF0aFV0aWxzLkNsYW1wIHRoZSBhY2N1bXVsYXRlZCBmb3JjZVxyXG4gICAgICAgICAgICAgICAgICAgIGZsb2F0IG1heEZyaWN0aW9uID0gZnJpY3Rpb24gKiBjY3AuTm9ybWFsSW1wdWxzZTtcclxuICAgICAgICAgICAgICAgICAgICBmbG9hdCBuZXdJbXB1bHNlID0gTWF0aC5NYXgoLW1heEZyaWN0aW9uLCBNYXRoLk1pbihjY3AuVGFuZ2VudEltcHVsc2UgKyBsYW1iZGEsIG1heEZyaWN0aW9uKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgbGFtYmRhID0gbmV3SW1wdWxzZSAtIGNjcC5UYW5nZW50SW1wdWxzZTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gQXBwbHkgY29udGFjdCBpbXB1bHNlXHJcbiAgICAgICAgICAgICAgICAgICAgZmxvYXQgcHggPSBsYW1iZGEgKiB0YW5nZW50eDtcclxuICAgICAgICAgICAgICAgICAgICBmbG9hdCBweSA9IGxhbWJkYSAqIHRhbmdlbnR5O1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBjLkJvZHlBLkxpbmVhclZlbG9jaXR5SW50ZXJuYWwuWCAtPSBjLkJvZHlBLkludk1hc3MgKiBweDtcclxuICAgICAgICAgICAgICAgICAgICBjLkJvZHlBLkxpbmVhclZlbG9jaXR5SW50ZXJuYWwuWSAtPSBjLkJvZHlBLkludk1hc3MgKiBweTtcclxuICAgICAgICAgICAgICAgICAgICB3QSAtPSBjLkJvZHlBLkludkkgKiAoY2NwLnJBLlggKiBweSAtIGNjcC5yQS5ZICogcHgpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBjLkJvZHlCLkxpbmVhclZlbG9jaXR5SW50ZXJuYWwuWCArPSBjLkJvZHlCLkludk1hc3MgKiBweDtcclxuICAgICAgICAgICAgICAgICAgICBjLkJvZHlCLkxpbmVhclZlbG9jaXR5SW50ZXJuYWwuWSArPSBjLkJvZHlCLkludk1hc3MgKiBweTtcclxuICAgICAgICAgICAgICAgICAgICB3QiArPSBjLkJvZHlCLkludkkgKiAoY2NwLnJCLlggKiBweSAtIGNjcC5yQi5ZICogcHgpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBjY3AuVGFuZ2VudEltcHVsc2UgPSBuZXdJbXB1bHNlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIC8vIFNvbHZlIG5vcm1hbCBjb25zdHJhaW50c1xyXG4gICAgICAgICAgICAgICAgaWYgKGMuUG9pbnRDb3VudCA9PSAxKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIENvbnRhY3RDb25zdHJhaW50UG9pbnQgY2NwID0gYy5Qb2ludHNbMF07XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIFJlbGF0aXZlIHZlbG9jaXR5IGF0IGNvbnRhY3RcclxuICAgICAgICAgICAgICAgICAgICAvLyBDb21wdXRlIG5vcm1hbCBpbXB1bHNlXHJcbiAgICAgICAgICAgICAgICAgICAgZmxvYXQgbGFtYmRhID0gLWNjcC5Ob3JtYWxNYXNzICpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKGMuQm9keUIuTGluZWFyVmVsb2NpdHlJbnRlcm5hbC5YICsgKC13QiAqIGNjcC5yQi5ZKSAtXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjLkJvZHlBLkxpbmVhclZlbG9jaXR5SW50ZXJuYWwuWCAtICgtd0EgKiBjY3AuckEuWSkpICogYy5Ob3JtYWwuWCArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChjLkJvZHlCLkxpbmVhclZlbG9jaXR5SW50ZXJuYWwuWSArICh3QiAqIGNjcC5yQi5YKSAtXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjLkJvZHlBLkxpbmVhclZlbG9jaXR5SW50ZXJuYWwuWSAtXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAod0EgKiBjY3AuckEuWCkpICogYy5Ob3JtYWwuWSAtIGNjcC5WZWxvY2l0eUJpYXMpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBDbGFtcCB0aGUgYWNjdW11bGF0ZWQgaW1wdWxzZVxyXG4gICAgICAgICAgICAgICAgICAgIGZsb2F0IG5ld0ltcHVsc2UgPSBNYXRoLk1heChjY3AuTm9ybWFsSW1wdWxzZSArIGxhbWJkYSwgMC4wZik7XHJcbiAgICAgICAgICAgICAgICAgICAgbGFtYmRhID0gbmV3SW1wdWxzZSAtIGNjcC5Ob3JtYWxJbXB1bHNlO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBBcHBseSBjb250YWN0IGltcHVsc2VcclxuICAgICAgICAgICAgICAgICAgICBmbG9hdCBweCA9IGxhbWJkYSAqIGMuTm9ybWFsLlg7XHJcbiAgICAgICAgICAgICAgICAgICAgZmxvYXQgcHkgPSBsYW1iZGEgKiBjLk5vcm1hbC5ZO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBjLkJvZHlBLkxpbmVhclZlbG9jaXR5SW50ZXJuYWwuWCAtPSBjLkJvZHlBLkludk1hc3MgKiBweDtcclxuICAgICAgICAgICAgICAgICAgICBjLkJvZHlBLkxpbmVhclZlbG9jaXR5SW50ZXJuYWwuWSAtPSBjLkJvZHlBLkludk1hc3MgKiBweTtcclxuICAgICAgICAgICAgICAgICAgICB3QSAtPSBjLkJvZHlBLkludkkgKiAoY2NwLnJBLlggKiBweSAtIGNjcC5yQS5ZICogcHgpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBjLkJvZHlCLkxpbmVhclZlbG9jaXR5SW50ZXJuYWwuWCArPSBjLkJvZHlCLkludk1hc3MgKiBweDtcclxuICAgICAgICAgICAgICAgICAgICBjLkJvZHlCLkxpbmVhclZlbG9jaXR5SW50ZXJuYWwuWSArPSBjLkJvZHlCLkludk1hc3MgKiBweTtcclxuICAgICAgICAgICAgICAgICAgICB3QiArPSBjLkJvZHlCLkludkkgKiAoY2NwLnJCLlggKiBweSAtIGNjcC5yQi5ZICogcHgpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBjY3AuTm9ybWFsSW1wdWxzZSA9IG5ld0ltcHVsc2U7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gQmxvY2sgc29sdmVyIGRldmVsb3BlZCBpbiBjb2xsYWJvcmF0aW9uIHdpdGggRGlyayBHcmVnb3JpdXMgKGJhY2sgaW4gMDEvMDcgb24gQm94MkRfTGl0ZSkuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gQnVpbGQgdGhlIG1pbmkgTENQIGZvciB0aGlzIGNvbnRhY3QgcGF0Y2hcclxuICAgICAgICAgICAgICAgICAgICAvL1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIHZuID0gQSAqIHggKyBiLCB2biA+PSAwLCAsIHZuID49IDAsIHggPj0gMCBhbmQgdm5faSAqIHhfaSA9IDAgd2l0aCBpID0gMS4uMlxyXG4gICAgICAgICAgICAgICAgICAgIC8vXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gQSA9IEogKiBXICogSlQgYW5kIEogPSAoIC1uLCAtcjEgeCBuLCBuLCByMiB4IG4gKVxyXG4gICAgICAgICAgICAgICAgICAgIC8vIGIgPSB2bl8wIC0gdmVsb2NpdHlCaWFzXHJcbiAgICAgICAgICAgICAgICAgICAgLy9cclxuICAgICAgICAgICAgICAgICAgICAvLyBUaGUgc3lzdGVtIGlzIHNvbHZlZCB1c2luZyB0aGUgXCJUb3RhbCBlbnVtZXJhdGlvbiBtZXRob2RcIiAocy4gTXVydHkpLiBUaGUgY29tcGxlbWVudGFyeSBjb25zdHJhaW50IHZuX2kgKiB4X2lcclxuICAgICAgICAgICAgICAgICAgICAvLyBpbXBsaWVzIHRoYXQgd2UgbXVzdCBoYXZlIGluIGFueSBzb2x1dGlvbiBlaXRoZXIgdm5faSA9IDAgb3IgeF9pID0gMC4gU28gZm9yIHRoZSAyRCBjb250YWN0IHByb2JsZW0gdGhlIGNhc2VzXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gdm4xID0gMCBhbmQgdm4yID0gMCwgeDEgPSAwIGFuZCB4MiA9IDAsIHgxID0gMCBhbmQgdm4yID0gMCwgeDIgPSAwIGFuZCB2bjEgPSAwIG5lZWQgdG8gYmUgdGVzdGVkLiBUaGUgZmlyc3QgdmFsaWRcclxuICAgICAgICAgICAgICAgICAgICAvLyBzb2x1dGlvbiB0aGF0IHNhdGlzZmllcyB0aGUgcHJvYmxlbSBpcyBjaG9zZW4uXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gSW4gb3JkZXIgdG8gYWNjb3VudCBvZiB0aGUgYWNjdW11bGF0ZWQgaW1wdWxzZSAnYScgKGJlY2F1c2Ugb2YgdGhlIGl0ZXJhdGl2ZSBuYXR1cmUgb2YgdGhlIHNvbHZlciB3aGljaCBvbmx5IHJlcXVpcmVzXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gdGhhdCB0aGUgYWNjdW11bGF0ZWQgaW1wdWxzZSBpcyBjbGFtcGVkIGFuZCBub3QgdGhlIGluY3JlbWVudGFsIGltcHVsc2UpIHdlIGNoYW5nZSB0aGUgaW1wdWxzZSB2YXJpYWJsZSAoeF9pKS5cclxuICAgICAgICAgICAgICAgICAgICAvL1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIFN1YnN0aXR1dGU6XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gXHJcbiAgICAgICAgICAgICAgICAgICAgLy8geCA9IHgnIC0gYVxyXG4gICAgICAgICAgICAgICAgICAgIC8vIFxyXG4gICAgICAgICAgICAgICAgICAgIC8vIFBsdWcgaW50byBhYm92ZSBlcXVhdGlvbjpcclxuICAgICAgICAgICAgICAgICAgICAvL1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIHZuID0gQSAqIHggKyBiXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gICAgPSBBICogKHgnIC0gYSkgKyBiXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gICAgPSBBICogeCcgKyBiIC0gQSAqIGFcclxuICAgICAgICAgICAgICAgICAgICAvLyAgICA9IEEgKiB4JyArIGInXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gYicgPSBiIC0gQSAqIGE7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIENvbnRhY3RDb25zdHJhaW50UG9pbnQgY3AxID0gYy5Qb2ludHNbMF07XHJcbiAgICAgICAgICAgICAgICAgICAgQ29udGFjdENvbnN0cmFpbnRQb2ludCBjcDIgPSBjLlBvaW50c1sxXTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgZmxvYXQgYXggPSBjcDEuTm9ybWFsSW1wdWxzZTtcclxuICAgICAgICAgICAgICAgICAgICBmbG9hdCBheSA9IGNwMi5Ob3JtYWxJbXB1bHNlO1xyXG4gICAgICAgICAgICAgICAgICAgIERlYnVnLkFzc2VydChheCA+PSAwLjBmICYmIGF5ID49IDAuMGYpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBSZWxhdGl2ZSB2ZWxvY2l0eSBhdCBjb250YWN0XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gQ29tcHV0ZSBub3JtYWwgdmVsb2NpdHlcclxuICAgICAgICAgICAgICAgICAgICBmbG9hdCB2bjEgPSAoYy5Cb2R5Qi5MaW5lYXJWZWxvY2l0eUludGVybmFsLlggKyAoLXdCICogY3AxLnJCLlkpIC0gYy5Cb2R5QS5MaW5lYXJWZWxvY2l0eUludGVybmFsLlggLVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoLXdBICogY3AxLnJBLlkpKSAqIGMuTm9ybWFsLlggK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChjLkJvZHlCLkxpbmVhclZlbG9jaXR5SW50ZXJuYWwuWSArICh3QiAqIGNwMS5yQi5YKSAtIGMuQm9keUEuTGluZWFyVmVsb2NpdHlJbnRlcm5hbC5ZIC1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKHdBICogY3AxLnJBLlgpKSAqIGMuTm9ybWFsLlk7XHJcbiAgICAgICAgICAgICAgICAgICAgZmxvYXQgdm4yID0gKGMuQm9keUIuTGluZWFyVmVsb2NpdHlJbnRlcm5hbC5YICsgKC13QiAqIGNwMi5yQi5ZKSAtIGMuQm9keUEuTGluZWFyVmVsb2NpdHlJbnRlcm5hbC5YIC1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKC13QSAqIGNwMi5yQS5ZKSkgKiBjLk5vcm1hbC5YICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoYy5Cb2R5Qi5MaW5lYXJWZWxvY2l0eUludGVybmFsLlkgKyAod0IgKiBjcDIuckIuWCkgLSBjLkJvZHlBLkxpbmVhclZlbG9jaXR5SW50ZXJuYWwuWSAtXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICh3QSAqIGNwMi5yQS5YKSkgKiBjLk5vcm1hbC5ZO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBmbG9hdCBieCA9IHZuMSAtIGNwMS5WZWxvY2l0eUJpYXMgLSAoYy5LLkNvbDEuWCAqIGF4ICsgYy5LLkNvbDIuWCAqIGF5KTtcclxuICAgICAgICAgICAgICAgICAgICBmbG9hdCBieSA9IHZuMiAtIGNwMi5WZWxvY2l0eUJpYXMgLSAoYy5LLkNvbDEuWSAqIGF4ICsgYy5LLkNvbDIuWSAqIGF5KTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgZmxvYXQgeHggPSAtKGMuTm9ybWFsTWFzcy5Db2wxLlggKiBieCArIGMuTm9ybWFsTWFzcy5Db2wyLlggKiBieSk7XHJcbiAgICAgICAgICAgICAgICAgICAgZmxvYXQgeHkgPSAtKGMuTm9ybWFsTWFzcy5Db2wxLlkgKiBieCArIGMuTm9ybWFsTWFzcy5Db2wyLlkgKiBieSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHdoaWxlICh0cnVlKVxyXG4gICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy9cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ2FzZSAxOiB2biA9IDBcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy9cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gMCA9IEEgKiB4JyArIGInXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFNvbHZlIGZvciB4JzpcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy9cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8geCcgPSAtIGludihBKSAqIGInXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh4eCA+PSAwLjBmICYmIHh5ID49IDAuMGYpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFJlc3Vic3RpdHV0ZSBmb3IgdGhlIGluY3JlbWVudGFsIGltcHVsc2VcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZsb2F0IGR4ID0geHggLSBheDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZsb2F0IGR5ID0geHkgLSBheTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBBcHBseSBpbmNyZW1lbnRhbCBpbXB1bHNlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmbG9hdCBwMXggPSBkeCAqIGMuTm9ybWFsLlg7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmbG9hdCBwMXkgPSBkeCAqIGMuTm9ybWFsLlk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmxvYXQgcDJ4ID0gZHkgKiBjLk5vcm1hbC5YO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmxvYXQgcDJ5ID0gZHkgKiBjLk5vcm1hbC5ZO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZsb2F0IHAxMnggPSBwMXggKyBwMng7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmbG9hdCBwMTJ5ID0gcDF5ICsgcDJ5O1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGMuQm9keUEuTGluZWFyVmVsb2NpdHlJbnRlcm5hbC5YIC09IGMuQm9keUEuSW52TWFzcyAqIHAxMng7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjLkJvZHlBLkxpbmVhclZlbG9jaXR5SW50ZXJuYWwuWSAtPSBjLkJvZHlBLkludk1hc3MgKiBwMTJ5O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd0EgLT0gYy5Cb2R5QS5JbnZJICogKChjcDEuckEuWCAqIHAxeSAtIGNwMS5yQS5ZICogcDF4KSArIChjcDIuckEuWCAqIHAyeSAtIGNwMi5yQS5ZICogcDJ4KSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYy5Cb2R5Qi5MaW5lYXJWZWxvY2l0eUludGVybmFsLlggKz0gYy5Cb2R5Qi5JbnZNYXNzICogcDEyeDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGMuQm9keUIuTGluZWFyVmVsb2NpdHlJbnRlcm5hbC5ZICs9IGMuQm9keUIuSW52TWFzcyAqIHAxMnk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3QiArPSBjLkJvZHlCLkludkkgKiAoKGNwMS5yQi5YICogcDF5IC0gY3AxLnJCLlkgKiBwMXgpICsgKGNwMi5yQi5YICogcDJ5IC0gY3AyLnJCLlkgKiBwMngpKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBBY2N1bXVsYXRlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjcDEuTm9ybWFsSW1wdWxzZSA9IHh4O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3AyLk5vcm1hbEltcHVsc2UgPSB4eTtcclxuXHJcbiNpZiBCMl9ERUJVR19TT0xWRVIgXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcclxuXHRcdFx0ICAgICAgICAgICAgICAgIGZsb2F0IGtfZXJyb3JUb2wgPSAxZS0zZjtcclxuXHJcblx0XHRcdFx0XHQgICAgICAgIC8vIFBvc3Rjb25kaXRpb25zXHJcblx0XHRcdFx0XHQgICAgICAgIGR2MSA9IHZCICsgTWF0aFV0aWxzLkNyb3NzKHdCLCBjcDEuckIpIC0gdkEgLSBNYXRoVXRpbHMuQ3Jvc3Mod0EsIGNwMS5yQSk7XHJcblx0XHRcdFx0XHQgICAgICAgIGR2MiA9IHZCICsgTWF0aFV0aWxzLkNyb3NzKHdCLCBjcDIuckIpIC0gdkEgLSBNYXRoVXRpbHMuQ3Jvc3Mod0EsIGNwMi5yQSk7XHJcblxyXG5cdFx0XHRcdFx0ICAgICAgICAvLyBDb21wdXRlIG5vcm1hbCB2ZWxvY2l0eVxyXG5cdFx0XHRcdFx0ICAgICAgICB2bjEgPSBWZWN0b3IyLkRvdChkdjEsIG5vcm1hbCk7XHJcblx0XHRcdFx0XHQgICAgICAgIHZuMiA9IFZlY3RvcjIuRG90KGR2Miwgbm9ybWFsKTtcclxuXHJcblx0XHRcdFx0XHQgICAgICAgIERlYnVnLkFzc2VydChNYXRoVXRpbHMuQWJzKHZuMSAtIGNwMS52ZWxvY2l0eUJpYXMpIDwga19lcnJvclRvbCk7XHJcblx0XHRcdFx0XHQgICAgICAgIERlYnVnLkFzc2VydChNYXRoVXRpbHMuQWJzKHZuMiAtIGNwMi52ZWxvY2l0eUJpYXMpIDwga19lcnJvclRvbCk7XHJcbiNlbmRpZlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIENhc2UgMjogdm4xID0gMCBhbmQgeDIgPSAwXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vICAgMCA9IGExMSAqIHgxJyArIGExMiAqIDAgKyBiMScgXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHZuMiA9IGEyMSAqIHgxJyArIGEyMiAqIDAgKyBiMidcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy9cclxuICAgICAgICAgICAgICAgICAgICAgICAgeHggPSAtY3AxLk5vcm1hbE1hc3MgKiBieDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgeHkgPSAwLjBmO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2bjEgPSAwLjBmO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2bjIgPSBjLksuQ29sMS5ZICogeHggKyBieTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh4eCA+PSAwLjBmICYmIHZuMiA+PSAwLjBmKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBSZXN1YnN0aXR1dGUgZm9yIHRoZSBpbmNyZW1lbnRhbCBpbXB1bHNlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmbG9hdCBkeCA9IHh4IC0gYXg7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmbG9hdCBkeSA9IHh5IC0gYXk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQXBwbHkgaW5jcmVtZW50YWwgaW1wdWxzZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmxvYXQgcDF4ID0gZHggKiBjLk5vcm1hbC5YO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmxvYXQgcDF5ID0gZHggKiBjLk5vcm1hbC5ZO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZsb2F0IHAyeCA9IGR5ICogYy5Ob3JtYWwuWDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZsb2F0IHAyeSA9IGR5ICogYy5Ob3JtYWwuWTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmbG9hdCBwMTJ4ID0gcDF4ICsgcDJ4O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmxvYXQgcDEyeSA9IHAxeSArIHAyeTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjLkJvZHlBLkxpbmVhclZlbG9jaXR5SW50ZXJuYWwuWCAtPSBjLkJvZHlBLkludk1hc3MgKiBwMTJ4O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYy5Cb2R5QS5MaW5lYXJWZWxvY2l0eUludGVybmFsLlkgLT0gYy5Cb2R5QS5JbnZNYXNzICogcDEyeTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdBIC09IGMuQm9keUEuSW52SSAqICgoY3AxLnJBLlggKiBwMXkgLSBjcDEuckEuWSAqIHAxeCkgKyAoY3AyLnJBLlggKiBwMnkgLSBjcDIuckEuWSAqIHAyeCkpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGMuQm9keUIuTGluZWFyVmVsb2NpdHlJbnRlcm5hbC5YICs9IGMuQm9keUIuSW52TWFzcyAqIHAxMng7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjLkJvZHlCLkxpbmVhclZlbG9jaXR5SW50ZXJuYWwuWSArPSBjLkJvZHlCLkludk1hc3MgKiBwMTJ5O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd0IgKz0gYy5Cb2R5Qi5JbnZJICogKChjcDEuckIuWCAqIHAxeSAtIGNwMS5yQi5ZICogcDF4KSArIChjcDIuckIuWCAqIHAyeSAtIGNwMi5yQi5ZICogcDJ4KSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQWNjdW11bGF0ZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3AxLk5vcm1hbEltcHVsc2UgPSB4eDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNwMi5Ob3JtYWxJbXB1bHNlID0geHk7XHJcblxyXG4jaWYgQjJfREVCVUdfU09MVkVSIFxyXG4gICAgLy8gUG9zdGNvbmRpdGlvbnNcclxuXHRcdFx0XHRcdCAgICAgICAgZHYxID0gdkIgKyBNYXRoVXRpbHMuQ3Jvc3Mod0IsIGNwMS5yQikgLSB2QSAtIE1hdGhVdGlscy5Dcm9zcyh3QSwgY3AxLnJBKTtcclxuXHJcblx0XHRcdFx0XHQgICAgICAgIC8vIENvbXB1dGUgbm9ybWFsIHZlbG9jaXR5XHJcblx0XHRcdFx0XHQgICAgICAgIHZuMSA9IFZlY3RvcjIuRG90KGR2MSwgbm9ybWFsKTtcclxuXHJcblx0XHRcdFx0XHQgICAgICAgIERlYnVnLkFzc2VydChNYXRoVXRpbHMuQWJzKHZuMSAtIGNwMS52ZWxvY2l0eUJpYXMpIDwga19lcnJvclRvbCk7XHJcbiNlbmRpZlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvL1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBDYXNlIDM6IHZuMiA9IDAgYW5kIHgxID0gMFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvL1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB2bjEgPSBhMTEgKiAwICsgYTEyICogeDInICsgYjEnIFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyAgIDAgPSBhMjEgKiAwICsgYTIyICogeDInICsgYjInXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHh4ID0gMC4wZjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgeHkgPSAtY3AyLk5vcm1hbE1hc3MgKiBieTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdm4xID0gYy5LLkNvbDIuWCAqIHh5ICsgYng7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZuMiA9IDAuMGY7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoeHkgPj0gMC4wZiAmJiB2bjEgPj0gMC4wZilcclxuICAgICAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gUmVzdWJzdGl0dXRlIGZvciB0aGUgaW5jcmVtZW50YWwgaW1wdWxzZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmxvYXQgZHggPSB4eCAtIGF4O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmxvYXQgZHkgPSB4eSAtIGF5O1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEFwcGx5IGluY3JlbWVudGFsIGltcHVsc2VcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZsb2F0IHAxeCA9IGR4ICogYy5Ob3JtYWwuWDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZsb2F0IHAxeSA9IGR4ICogYy5Ob3JtYWwuWTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmbG9hdCBwMnggPSBkeSAqIGMuTm9ybWFsLlg7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmbG9hdCBwMnkgPSBkeSAqIGMuTm9ybWFsLlk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmxvYXQgcDEyeCA9IHAxeCArIHAyeDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZsb2F0IHAxMnkgPSBwMXkgKyBwMnk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYy5Cb2R5QS5MaW5lYXJWZWxvY2l0eUludGVybmFsLlggLT0gYy5Cb2R5QS5JbnZNYXNzICogcDEyeDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGMuQm9keUEuTGluZWFyVmVsb2NpdHlJbnRlcm5hbC5ZIC09IGMuQm9keUEuSW52TWFzcyAqIHAxMnk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3QSAtPSBjLkJvZHlBLkludkkgKiAoKGNwMS5yQS5YICogcDF5IC0gY3AxLnJBLlkgKiBwMXgpICsgKGNwMi5yQS5YICogcDJ5IC0gY3AyLnJBLlkgKiBwMngpKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjLkJvZHlCLkxpbmVhclZlbG9jaXR5SW50ZXJuYWwuWCArPSBjLkJvZHlCLkludk1hc3MgKiBwMTJ4O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYy5Cb2R5Qi5MaW5lYXJWZWxvY2l0eUludGVybmFsLlkgKz0gYy5Cb2R5Qi5JbnZNYXNzICogcDEyeTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdCICs9IGMuQm9keUIuSW52SSAqICgoY3AxLnJCLlggKiBwMXkgLSBjcDEuckIuWSAqIHAxeCkgKyAoY3AyLnJCLlggKiBwMnkgLSBjcDIuckIuWSAqIHAyeCkpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEFjY3VtdWxhdGVcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNwMS5Ob3JtYWxJbXB1bHNlID0geHg7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjcDIuTm9ybWFsSW1wdWxzZSA9IHh5O1xyXG5cclxuI2lmIEIyX0RFQlVHX1NPTFZFUiBcclxuICAgIC8vIFBvc3Rjb25kaXRpb25zXHJcblx0XHRcdFx0XHQgICAgICAgIGR2MiA9IHZCICsgTWF0aFV0aWxzLkNyb3NzKHdCLCBjcDIuckIpIC0gdkEgLSBNYXRoVXRpbHMuQ3Jvc3Mod0EsIGNwMi5yQSk7XHJcblxyXG5cdFx0XHRcdFx0ICAgICAgICAvLyBDb21wdXRlIG5vcm1hbCB2ZWxvY2l0eVxyXG5cdFx0XHRcdFx0ICAgICAgICB2bjIgPSBWZWN0b3IyLkRvdChkdjIsIG5vcm1hbCk7XHJcblxyXG5cdFx0XHRcdFx0ICAgICAgICBEZWJ1Zy5Bc3NlcnQoTWF0aFV0aWxzLkFicyh2bjIgLSBjcDIudmVsb2NpdHlCaWFzKSA8IGtfZXJyb3JUb2wpO1xyXG4jZW5kaWZcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvL1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBDYXNlIDQ6IHgxID0gMCBhbmQgeDIgPSAwXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB2bjEgPSBiMVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB2bjIgPSBiMjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgeHggPSAwLjBmO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB4eSA9IDAuMGY7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZuMSA9IGJ4O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2bjIgPSBieTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2bjEgPj0gMC4wZiAmJiB2bjIgPj0gMC4wZilcclxuICAgICAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gUmVzdWJzdGl0dXRlIGZvciB0aGUgaW5jcmVtZW50YWwgaW1wdWxzZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmxvYXQgZHggPSB4eCAtIGF4O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmxvYXQgZHkgPSB4eSAtIGF5O1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEFwcGx5IGluY3JlbWVudGFsIGltcHVsc2VcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZsb2F0IHAxeCA9IGR4ICogYy5Ob3JtYWwuWDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZsb2F0IHAxeSA9IGR4ICogYy5Ob3JtYWwuWTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmbG9hdCBwMnggPSBkeSAqIGMuTm9ybWFsLlg7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmbG9hdCBwMnkgPSBkeSAqIGMuTm9ybWFsLlk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmxvYXQgcDEyeCA9IHAxeCArIHAyeDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZsb2F0IHAxMnkgPSBwMXkgKyBwMnk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYy5Cb2R5QS5MaW5lYXJWZWxvY2l0eUludGVybmFsLlggLT0gYy5Cb2R5QS5JbnZNYXNzICogcDEyeDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGMuQm9keUEuTGluZWFyVmVsb2NpdHlJbnRlcm5hbC5ZIC09IGMuQm9keUEuSW52TWFzcyAqIHAxMnk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3QSAtPSBjLkJvZHlBLkludkkgKiAoKGNwMS5yQS5YICogcDF5IC0gY3AxLnJBLlkgKiBwMXgpICsgKGNwMi5yQS5YICogcDJ5IC0gY3AyLnJBLlkgKiBwMngpKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjLkJvZHlCLkxpbmVhclZlbG9jaXR5SW50ZXJuYWwuWCArPSBjLkJvZHlCLkludk1hc3MgKiBwMTJ4O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYy5Cb2R5Qi5MaW5lYXJWZWxvY2l0eUludGVybmFsLlkgKz0gYy5Cb2R5Qi5JbnZNYXNzICogcDEyeTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdCICs9IGMuQm9keUIuSW52SSAqICgoY3AxLnJCLlggKiBwMXkgLSBjcDEuckIuWSAqIHAxeCkgKyAoY3AyLnJCLlggKiBwMnkgLSBjcDIuckIuWSAqIHAyeCkpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEFjY3VtdWxhdGVcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNwMS5Ob3JtYWxJbXB1bHNlID0geHg7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjcDIuTm9ybWFsSW1wdWxzZSA9IHh5O1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBObyBzb2x1dGlvbiwgZ2l2ZSB1cC4gVGhpcyBpcyBoaXQgc29tZXRpbWVzLCBidXQgaXQgZG9lc24ndCBzZWVtIHRvIG1hdHRlci5cclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGMuQm9keUEuQW5ndWxhclZlbG9jaXR5SW50ZXJuYWwgPSB3QTtcclxuICAgICAgICAgICAgICAgIGMuQm9keUIuQW5ndWxhclZlbG9jaXR5SW50ZXJuYWwgPSB3QjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHVibGljIHZvaWQgU3RvcmVJbXB1bHNlcygpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBmb3IgKGludCBpID0gMDsgaSA8IF9jb25zdHJhaW50Q291bnQ7ICsraSlcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgQ29udGFjdENvbnN0cmFpbnQgYyA9IENvbnN0cmFpbnRzW2ldO1xyXG4gICAgICAgICAgICAgICAgaWYgKGMuQm9keUEuUGVuZXRyYWJsZSB8fCBjLkJvZHlCLlBlbmV0cmFibGUpXHJcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcblxyXG4gICAgICAgICAgICAgICAgTWFuaWZvbGQgbSA9IGMuTWFuaWZvbGQ7XHJcblxyXG4gICAgICAgICAgICAgICAgZm9yIChpbnQgaiA9IDA7IGogPCBjLlBvaW50Q291bnQ7ICsrailcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBNYW5pZm9sZFBvaW50IHBqID0gbS5Qb2ludHNbal07XHJcbiAgICAgICAgICAgICAgICAgICAgQ29udGFjdENvbnN0cmFpbnRQb2ludCBjcCA9IGMuUG9pbnRzW2pdO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBwai5Ob3JtYWxJbXB1bHNlID0gY3AuTm9ybWFsSW1wdWxzZTtcclxuICAgICAgICAgICAgICAgICAgICBwai5UYW5nZW50SW1wdWxzZSA9IGNwLlRhbmdlbnRJbXB1bHNlO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBtLlBvaW50c1tqXSA9IHBqO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGMuTWFuaWZvbGQgPSBtO1xyXG4gICAgICAgICAgICAgICAgX2NvbnRhY3RzW2ldLk1hbmlmb2xkID0gbTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHVibGljIGJvb2wgU29sdmVQb3NpdGlvbkNvbnN0cmFpbnRzKGZsb2F0IGJhdW1nYXJ0ZSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGZsb2F0IG1pblNlcGFyYXRpb24gPSAwLjBmO1xyXG5cclxuICAgICAgICAgICAgZm9yIChpbnQgaSA9IDA7IGkgPCBfY29uc3RyYWludENvdW50OyArK2kpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIENvbnRhY3RDb25zdHJhaW50IGMgPSBDb25zdHJhaW50c1tpXTtcclxuICAgICAgICAgICAgICAgIGlmIChjLkJvZHlBLlBlbmV0cmFibGUgfHwgYy5Cb2R5Qi5QZW5ldHJhYmxlKVxyXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG5cclxuICAgICAgICAgICAgICAgIEJvZHkgYm9keUEgPSBjLkJvZHlBO1xyXG4gICAgICAgICAgICAgICAgQm9keSBib2R5QiA9IGMuQm9keUI7XHJcblxyXG4gICAgICAgICAgICAgICAgZmxvYXQgaW52TWFzc0EgPSBib2R5QS5NYXNzICogYm9keUEuSW52TWFzcztcclxuICAgICAgICAgICAgICAgIGZsb2F0IGludklBID0gYm9keUEuTWFzcyAqIGJvZHlBLkludkk7XHJcbiAgICAgICAgICAgICAgICBmbG9hdCBpbnZNYXNzQiA9IGJvZHlCLk1hc3MgKiBib2R5Qi5JbnZNYXNzO1xyXG4gICAgICAgICAgICAgICAgZmxvYXQgaW52SUIgPSBib2R5Qi5NYXNzICogYm9keUIuSW52STtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBTb2x2ZSBub3JtYWwgY29uc3RyYWludHNcclxuICAgICAgICAgICAgICAgIGZvciAoaW50IGogPSAwOyBqIDwgYy5Qb2ludENvdW50OyArK2opXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgVmVjdG9yMiBub3JtYWw7XHJcbiAgICAgICAgICAgICAgICAgICAgVmVjdG9yMiBwb2ludDtcclxuICAgICAgICAgICAgICAgICAgICBmbG9hdCBzZXBhcmF0aW9uO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBTb2x2ZShjLCBqLCBvdXQgbm9ybWFsLCBvdXQgcG9pbnQsIG91dCBzZXBhcmF0aW9uKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgZmxvYXQgcmF4ID0gcG9pbnQuWCAtIGJvZHlBLlN3ZWVwLkMuWDtcclxuICAgICAgICAgICAgICAgICAgICBmbG9hdCByYXkgPSBwb2ludC5ZIC0gYm9keUEuU3dlZXAuQy5ZO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBmbG9hdCByYnggPSBwb2ludC5YIC0gYm9keUIuU3dlZXAuQy5YO1xyXG4gICAgICAgICAgICAgICAgICAgIGZsb2F0IHJieSA9IHBvaW50LlkgLSBib2R5Qi5Td2VlcC5DLlk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIFRyYWNrIG1heCBjb25zdHJhaW50IGVycm9yLlxyXG4gICAgICAgICAgICAgICAgICAgIG1pblNlcGFyYXRpb24gPSBNYXRoLk1pbihtaW5TZXBhcmF0aW9uLCBzZXBhcmF0aW9uKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gUHJldmVudCBsYXJnZSBjb3JyZWN0aW9ucyBhbmQgYWxsb3cgc2xvcC5cclxuICAgICAgICAgICAgICAgICAgICBmbG9hdCBDID0gTWF0aC5NYXgoLVNldHRpbmdzLk1heExpbmVhckNvcnJlY3Rpb24sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE1hdGguTWluKGJhdW1nYXJ0ZSAqIChzZXBhcmF0aW9uICsgU2V0dGluZ3MuTGluZWFyU2xvcCksIDAuMGYpKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gQ29tcHV0ZSB0aGUgZWZmZWN0aXZlIG1hc3MuXHJcbiAgICAgICAgICAgICAgICAgICAgZmxvYXQgcm5BID0gcmF4ICogbm9ybWFsLlkgLSByYXkgKiBub3JtYWwuWDtcclxuICAgICAgICAgICAgICAgICAgICBmbG9hdCBybkIgPSByYnggKiBub3JtYWwuWSAtIHJieSAqIG5vcm1hbC5YO1xyXG4gICAgICAgICAgICAgICAgICAgIGZsb2F0IEsgPSBpbnZNYXNzQSArIGludk1hc3NCICsgaW52SUEgKiBybkEgKiBybkEgKyBpbnZJQiAqIHJuQiAqIHJuQjtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gQ29tcHV0ZSBub3JtYWwgaW1wdWxzZVxyXG4gICAgICAgICAgICAgICAgICAgIGZsb2F0IGltcHVsc2UgPSBLID4gMC4wZiA/IC1DIC8gSyA6IDAuMGY7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGZsb2F0IHB4ID0gaW1wdWxzZSAqIG5vcm1hbC5YO1xyXG4gICAgICAgICAgICAgICAgICAgIGZsb2F0IHB5ID0gaW1wdWxzZSAqIG5vcm1hbC5ZO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBib2R5QS5Td2VlcC5DLlggLT0gaW52TWFzc0EgKiBweDtcclxuICAgICAgICAgICAgICAgICAgICBib2R5QS5Td2VlcC5DLlkgLT0gaW52TWFzc0EgKiBweTtcclxuICAgICAgICAgICAgICAgICAgICBib2R5QS5Td2VlcC5BIC09IGludklBICogKHJheCAqIHB5IC0gcmF5ICogcHgpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBib2R5Qi5Td2VlcC5DLlggKz0gaW52TWFzc0IgKiBweDtcclxuICAgICAgICAgICAgICAgICAgICBib2R5Qi5Td2VlcC5DLlkgKz0gaW52TWFzc0IgKiBweTtcclxuICAgICAgICAgICAgICAgICAgICBib2R5Qi5Td2VlcC5BICs9IGludklCICogKHJieCAqIHB5IC0gcmJ5ICogcHgpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBib2R5QS5TeW5jaHJvbml6ZVRyYW5zZm9ybSgpO1xyXG4gICAgICAgICAgICAgICAgICAgIGJvZHlCLlN5bmNocm9uaXplVHJhbnNmb3JtKCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIFdlIGNhbid0IGV4cGVjdCBtaW5TcGVwYXJhdGlvbiA+PSAtU2V0dGluZ3MuYjJfbGluZWFyU2xvcCBiZWNhdXNlIHdlIGRvbid0XHJcbiAgICAgICAgICAgIC8vIHB1c2ggdGhlIHNlcGFyYXRpb24gYWJvdmUgLVNldHRpbmdzLmIyX2xpbmVhclNsb3AuXHJcbiAgICAgICAgICAgIHJldHVybiBtaW5TZXBhcmF0aW9uID49IC0xLjVmICogU2V0dGluZ3MuTGluZWFyU2xvcDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHByaXZhdGUgc3RhdGljIHZvaWQgU29sdmUoQ29udGFjdENvbnN0cmFpbnQgY2MsIGludCBpbmRleCwgb3V0IFZlY3RvcjIgbm9ybWFsLCBvdXQgVmVjdG9yMiBwb2ludCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG91dCBmbG9hdCBzZXBhcmF0aW9uKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgRGVidWcuQXNzZXJ0KGNjLlBvaW50Q291bnQgPiAwKTtcclxuXHJcbiAgICAgICAgICAgIG5vcm1hbCA9IFZlY3RvcjIuWmVybztcclxuXHJcbiAgICAgICAgICAgIHN3aXRjaCAoY2MuVHlwZSlcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgY2FzZSBNYW5pZm9sZFR5cGUuQ2lyY2xlczpcclxuICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIFZlY3RvcjIgcG9pbnRBID0gY2MuQm9keUEuR2V0V29ybGRQb2ludChyZWYgY2MuTG9jYWxQb2ludCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIFZlY3RvcjIgcG9pbnRCID0gY2MuQm9keUIuR2V0V29ybGRQb2ludChyZWYgY2MuUG9pbnRzWzBdLkxvY2FsUG9pbnQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBmbG9hdCBhID0gKHBvaW50QS5YIC0gcG9pbnRCLlgpICogKHBvaW50QS5YIC0gcG9pbnRCLlgpICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChwb2ludEEuWSAtIHBvaW50Qi5ZKSAqIChwb2ludEEuWSAtIHBvaW50Qi5ZKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGEgPiBTZXR0aW5ncy5FcHNpbG9uICogU2V0dGluZ3MuRXBzaWxvbilcclxuICAgICAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgVmVjdG9yMiBub3JtYWxUbXAgPSBwb2ludEIgLSBwb2ludEE7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmbG9hdCBmYWN0b3IgPSAxZiAvIChmbG9hdClNYXRoLlNxcnQobm9ybWFsVG1wLlggKiBub3JtYWxUbXAuWCArIG5vcm1hbFRtcC5ZICogbm9ybWFsVG1wLlkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9ybWFsLlggPSBub3JtYWxUbXAuWCAqIGZhY3RvcjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vcm1hbC5ZID0gbm9ybWFsVG1wLlkgKiBmYWN0b3I7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBub3JtYWwuWCA9IDE7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBub3JtYWwuWSA9IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvaW50ID0gMC41ZiAqIChwb2ludEEgKyBwb2ludEIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzZXBhcmF0aW9uID0gKHBvaW50Qi5YIC0gcG9pbnRBLlgpICogbm9ybWFsLlggKyAocG9pbnRCLlkgLSBwb2ludEEuWSkgKiBub3JtYWwuWSAtIGNjLlJhZGl1c0EgLVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2MuUmFkaXVzQjtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgICAgICAgICAgY2FzZSBNYW5pZm9sZFR5cGUuRmFjZUE6XHJcbiAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBub3JtYWwgPSBjYy5Cb2R5QS5HZXRXb3JsZFZlY3RvcihyZWYgY2MuTG9jYWxOb3JtYWwpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBWZWN0b3IyIHBsYW5lUG9pbnQgPSBjYy5Cb2R5QS5HZXRXb3JsZFBvaW50KHJlZiBjYy5Mb2NhbFBvaW50KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgVmVjdG9yMiBjbGlwUG9pbnQgPSBjYy5Cb2R5Qi5HZXRXb3JsZFBvaW50KHJlZiBjYy5Qb2ludHNbaW5kZXhdLkxvY2FsUG9pbnQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzZXBhcmF0aW9uID0gKGNsaXBQb2ludC5YIC0gcGxhbmVQb2ludC5YKSAqIG5vcm1hbC5YICsgKGNsaXBQb2ludC5ZIC0gcGxhbmVQb2ludC5ZKSAqIG5vcm1hbC5ZIC1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNjLlJhZGl1c0EgLSBjYy5SYWRpdXNCO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBwb2ludCA9IGNsaXBQb2ludDtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgICAgICAgICAgY2FzZSBNYW5pZm9sZFR5cGUuRmFjZUI6XHJcbiAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBub3JtYWwgPSBjYy5Cb2R5Qi5HZXRXb3JsZFZlY3RvcihyZWYgY2MuTG9jYWxOb3JtYWwpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBWZWN0b3IyIHBsYW5lUG9pbnQgPSBjYy5Cb2R5Qi5HZXRXb3JsZFBvaW50KHJlZiBjYy5Mb2NhbFBvaW50KTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIFZlY3RvcjIgY2xpcFBvaW50ID0gY2MuQm9keUEuR2V0V29ybGRQb2ludChyZWYgY2MuUG9pbnRzW2luZGV4XS5Mb2NhbFBvaW50KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2VwYXJhdGlvbiA9IChjbGlwUG9pbnQuWCAtIHBsYW5lUG9pbnQuWCkgKiBub3JtYWwuWCArIChjbGlwUG9pbnQuWSAtIHBsYW5lUG9pbnQuWSkgKiBub3JtYWwuWSAtXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYy5SYWRpdXNBIC0gY2MuUmFkaXVzQjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcG9pbnQgPSBjbGlwUG9pbnQ7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBFbnN1cmUgbm9ybWFsIHBvaW50cyBmcm9tIEEgdG8gQlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBub3JtYWwgPSAtbm9ybWFsO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICAgICAgcG9pbnQgPSBWZWN0b3IyLlplcm87XHJcbiAgICAgICAgICAgICAgICAgICAgc2VwYXJhdGlvbiA9IDAuMGY7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbn0iLCIvKlxyXG4qIEZhcnNlZXIgUGh5c2ljcyBFbmdpbmUgYmFzZWQgb24gQm94MkQuWE5BIHBvcnQ6XHJcbiogQ29weXJpZ2h0IChjKSAyMDEwIElhbiBRdmlzdFxyXG4qIFxyXG4qIEJveDJELlhOQSBwb3J0IG9mIEJveDJEOlxyXG4qIENvcHlyaWdodCAoYykgMjAwOSBCcmFuZG9uIEZ1cnR3YW5nbGVyLCBOYXRoYW4gRnVydHdhbmdsZXJcclxuKlxyXG4qIE9yaWdpbmFsIHNvdXJjZSBCb3gyRDpcclxuKiBDb3B5cmlnaHQgKGMpIDIwMDYtMjAwOSBFcmluIENhdHRvIGh0dHA6Ly93d3cuZ3BoeXNpY3MuY29tIFxyXG4qIFxyXG4qIFRoaXMgc29mdHdhcmUgaXMgcHJvdmlkZWQgJ2FzLWlzJywgd2l0aG91dCBhbnkgZXhwcmVzcyBvciBpbXBsaWVkIFxyXG4qIHdhcnJhbnR5LiAgSW4gbm8gZXZlbnQgd2lsbCB0aGUgYXV0aG9ycyBiZSBoZWxkIGxpYWJsZSBmb3IgYW55IGRhbWFnZXMgXHJcbiogYXJpc2luZyBmcm9tIHRoZSB1c2Ugb2YgdGhpcyBzb2Z0d2FyZS4gXHJcbiogUGVybWlzc2lvbiBpcyBncmFudGVkIHRvIGFueW9uZSB0byB1c2UgdGhpcyBzb2Z0d2FyZSBmb3IgYW55IHB1cnBvc2UsIFxyXG4qIGluY2x1ZGluZyBjb21tZXJjaWFsIGFwcGxpY2F0aW9ucywgYW5kIHRvIGFsdGVyIGl0IGFuZCByZWRpc3RyaWJ1dGUgaXQgXHJcbiogZnJlZWx5LCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgcmVzdHJpY3Rpb25zOiBcclxuKiAxLiBUaGUgb3JpZ2luIG9mIHRoaXMgc29mdHdhcmUgbXVzdCBub3QgYmUgbWlzcmVwcmVzZW50ZWQ7IHlvdSBtdXN0IG5vdCBcclxuKiBjbGFpbSB0aGF0IHlvdSB3cm90ZSB0aGUgb3JpZ2luYWwgc29mdHdhcmUuIElmIHlvdSB1c2UgdGhpcyBzb2Z0d2FyZSBcclxuKiBpbiBhIHByb2R1Y3QsIGFuIGFja25vd2xlZGdtZW50IGluIHRoZSBwcm9kdWN0IGRvY3VtZW50YXRpb24gd291bGQgYmUgXHJcbiogYXBwcmVjaWF0ZWQgYnV0IGlzIG5vdCByZXF1aXJlZC4gXHJcbiogMi4gQWx0ZXJlZCBzb3VyY2UgdmVyc2lvbnMgbXVzdCBiZSBwbGFpbmx5IG1hcmtlZCBhcyBzdWNoLCBhbmQgbXVzdCBub3QgYmUgXHJcbiogbWlzcmVwcmVzZW50ZWQgYXMgYmVpbmcgdGhlIG9yaWdpbmFsIHNvZnR3YXJlLiBcclxuKiAzLiBUaGlzIG5vdGljZSBtYXkgbm90IGJlIHJlbW92ZWQgb3IgYWx0ZXJlZCBmcm9tIGFueSBzb3VyY2UgZGlzdHJpYnV0aW9uLiBcclxuKi9cclxuXHJcbnVzaW5nIFN5c3RlbTtcclxudXNpbmcgU3lzdGVtLkRpYWdub3N0aWNzO1xyXG51c2luZyBGYXJzZWVyUGh5c2ljcy5Db21tb247XHJcbnVzaW5nIEZhcnNlZXJQaHlzaWNzLkR5bmFtaWNzLkNvbnRhY3RzO1xyXG51c2luZyBGYXJzZWVyUGh5c2ljcy5EeW5hbWljcy5Kb2ludHM7XHJcbnVzaW5nIE1pY3Jvc29mdC5YbmEuRnJhbWV3b3JrO1xyXG5cclxubmFtZXNwYWNlIEZhcnNlZXJQaHlzaWNzLkR5bmFtaWNzXHJcbntcclxuICAgIC8vLyA8c3VtbWFyeT5cclxuICAgIC8vLyBUaGlzIGlzIGFuIGludGVybmFsIGNsYXNzLlxyXG4gICAgLy8vIDwvc3VtbWFyeT5cclxuICAgIHB1YmxpYyBjbGFzcyBJc2xhbmRcclxuICAgIHtcclxuICAgICAgICBwdWJsaWMgQm9keVtdIEJvZGllcztcclxuICAgICAgICBwdWJsaWMgaW50IEJvZHlDb3VudDtcclxuICAgICAgICBwdWJsaWMgaW50IENvbnRhY3RDb3VudDtcclxuICAgICAgICBwdWJsaWMgaW50IEpvaW50Q291bnQ7XHJcbiAgICAgICAgcHJpdmF0ZSBpbnQgX2JvZHlDYXBhY2l0eTtcclxuICAgICAgICBwcml2YXRlIGludCBfY29udGFjdENhcGFjaXR5O1xyXG4gICAgICAgIHByaXZhdGUgQ29udGFjdE1hbmFnZXIgX2NvbnRhY3RNYW5hZ2VyO1xyXG4gICAgICAgIHByaXZhdGUgQ29udGFjdFNvbHZlciBfY29udGFjdFNvbHZlciA9IG5ldyBDb250YWN0U29sdmVyKCk7XHJcbiAgICAgICAgcHJpdmF0ZSBDb250YWN0W10gX2NvbnRhY3RzO1xyXG4gICAgICAgIHByaXZhdGUgaW50IF9qb2ludENhcGFjaXR5O1xyXG4gICAgICAgIHByaXZhdGUgSm9pbnRbXSBfam9pbnRzO1xyXG4gICAgICAgIHB1YmxpYyBmbG9hdCBKb2ludFVwZGF0ZVRpbWU7XHJcblxyXG4gICAgICAgIHByaXZhdGUgY29uc3QgZmxvYXQgTGluVG9sU3FyID0gU2V0dGluZ3MuTGluZWFyU2xlZXBUb2xlcmFuY2UgKiBTZXR0aW5ncy5MaW5lYXJTbGVlcFRvbGVyYW5jZTtcclxuICAgICAgICBwcml2YXRlIGNvbnN0IGZsb2F0IEFuZ1RvbFNxciA9IFNldHRpbmdzLkFuZ3VsYXJTbGVlcFRvbGVyYW5jZSAqIFNldHRpbmdzLkFuZ3VsYXJTbGVlcFRvbGVyYW5jZTtcclxuXHJcblxyXG4gICAgICAgIHB1YmxpYyB2b2lkIFJlc2V0KGludCBib2R5Q2FwYWNpdHksIGludCBjb250YWN0Q2FwYWNpdHksIGludCBqb2ludENhcGFjaXR5LCBDb250YWN0TWFuYWdlciBjb250YWN0TWFuYWdlcilcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIF9ib2R5Q2FwYWNpdHkgPSBib2R5Q2FwYWNpdHk7XHJcbiAgICAgICAgICAgIF9jb250YWN0Q2FwYWNpdHkgPSBjb250YWN0Q2FwYWNpdHk7XHJcbiAgICAgICAgICAgIF9qb2ludENhcGFjaXR5ID0gam9pbnRDYXBhY2l0eTtcclxuXHJcbiAgICAgICAgICAgIEJvZHlDb3VudCA9IDA7XHJcbiAgICAgICAgICAgIENvbnRhY3RDb3VudCA9IDA7XHJcbiAgICAgICAgICAgIEpvaW50Q291bnQgPSAwO1xyXG5cclxuICAgICAgICAgICAgX2NvbnRhY3RNYW5hZ2VyID0gY29udGFjdE1hbmFnZXI7XHJcblxyXG4gICAgICAgICAgICBpZiAoQm9kaWVzID09IG51bGwgfHwgQm9kaWVzLkxlbmd0aCA8IGJvZHlDYXBhY2l0eSlcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgQm9kaWVzID0gbmV3IEJvZHlbYm9keUNhcGFjaXR5XTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKF9jb250YWN0cyA9PSBudWxsIHx8IF9jb250YWN0cy5MZW5ndGggPCBjb250YWN0Q2FwYWNpdHkpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIF9jb250YWN0cyA9IG5ldyBDb250YWN0W2NvbnRhY3RDYXBhY2l0eSAqIDJdO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAoX2pvaW50cyA9PSBudWxsIHx8IF9qb2ludHMuTGVuZ3RoIDwgam9pbnRDYXBhY2l0eSlcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgX2pvaW50cyA9IG5ldyBKb2ludFtqb2ludENhcGFjaXR5ICogMl07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHB1YmxpYyB2b2lkIENsZWFyKClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIEJvZHlDb3VudCA9IDA7XHJcbiAgICAgICAgICAgIENvbnRhY3RDb3VudCA9IDA7XHJcbiAgICAgICAgICAgIEpvaW50Q291bnQgPSAwO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHJpdmF0ZSBmbG9hdCBfdG1wVGltZTtcclxuXHJcbiAgICAgICAgcHVibGljIHZvaWQgU29sdmUocmVmIFRpbWVTdGVwIHN0ZXAsIHJlZiBWZWN0b3IyIGdyYXZpdHkpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICAvLyBJbnRlZ3JhdGUgdmVsb2NpdGllcyBhbmQgYXBwbHkgZGFtcGluZy5cclxuICAgICAgICAgICAgZm9yIChpbnQgaSA9IDA7IGkgPCBCb2R5Q291bnQ7ICsraSlcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgQm9keSBiID0gQm9kaWVzW2ldO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmIChiLkJvZHlUeXBlICE9IEJvZHlUeXBlLkR5bmFtaWMpXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gSW50ZWdyYXRlIHZlbG9jaXRpZXMuXHJcbiAgICAgICAgICAgICAgICAvLyBGUEUgMyBvbmx5IC0gT25seSBhcHBseSBncmF2aXR5IGlmIHRoZSBib2R5IHdhbnRzIGl0LlxyXG4gICAgICAgICAgICAgICAgaWYgKGIuSWdub3JlR3Jhdml0eSlcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBiLkxpbmVhclZlbG9jaXR5SW50ZXJuYWwuWCArPSBzdGVwLmR0ICogKGIuSW52TWFzcyAqIGIuRm9yY2UuWCk7XHJcbiAgICAgICAgICAgICAgICAgICAgYi5MaW5lYXJWZWxvY2l0eUludGVybmFsLlkgKz0gc3RlcC5kdCAqIChiLkludk1hc3MgKiBiLkZvcmNlLlkpO1xyXG4gICAgICAgICAgICAgICAgICAgIGIuQW5ndWxhclZlbG9jaXR5SW50ZXJuYWwgKz0gc3RlcC5kdCAqIGIuSW52SSAqIGIuVG9ycXVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIGIuTGluZWFyVmVsb2NpdHlJbnRlcm5hbC5YICs9IHN0ZXAuZHQgKiAoZ3Jhdml0eS5YICsgYi5JbnZNYXNzICogYi5Gb3JjZS5YKTtcclxuICAgICAgICAgICAgICAgICAgICBiLkxpbmVhclZlbG9jaXR5SW50ZXJuYWwuWSArPSBzdGVwLmR0ICogKGdyYXZpdHkuWSArIGIuSW52TWFzcyAqIGIuRm9yY2UuWSk7XHJcbiAgICAgICAgICAgICAgICAgICAgYi5Bbmd1bGFyVmVsb2NpdHlJbnRlcm5hbCArPSBzdGVwLmR0ICogYi5JbnZJICogYi5Ub3JxdWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gQXBwbHkgZGFtcGluZy5cclxuICAgICAgICAgICAgICAgIC8vIE9ERTogZHYvZHQgKyBjICogdiA9IDBcclxuICAgICAgICAgICAgICAgIC8vIFNvbHV0aW9uOiB2KHQpID0gdjAgKiBleHAoLWMgKiB0KVxyXG4gICAgICAgICAgICAgICAgLy8gVGltZSBzdGVwOiB2KHQgKyBkdCkgPSB2MCAqIGV4cCgtYyAqICh0ICsgZHQpKSA9IHYwICogZXhwKC1jICogdCkgKiBleHAoLWMgKiBkdCkgPSB2ICogZXhwKC1jICogZHQpXHJcbiAgICAgICAgICAgICAgICAvLyB2MiA9IGV4cCgtYyAqIGR0KSAqIHYxXHJcbiAgICAgICAgICAgICAgICAvLyBUYXlsb3IgZXhwYW5zaW9uOlxyXG4gICAgICAgICAgICAgICAgLy8gdjIgPSAoMS4wZiAtIGMgKiBkdCkgKiB2MVxyXG4gICAgICAgICAgICAgICAgYi5MaW5lYXJWZWxvY2l0eUludGVybmFsICo9IE1hdGhVdGlscy5DbGFtcCgxLjBmIC0gc3RlcC5kdCAqIGIuTGluZWFyRGFtcGluZywgMC4wZiwgMS4wZik7XHJcbiAgICAgICAgICAgICAgICBiLkFuZ3VsYXJWZWxvY2l0eUludGVybmFsICo9IE1hdGhVdGlscy5DbGFtcCgxLjBmIC0gc3RlcC5kdCAqIGIuQW5ndWxhckRhbXBpbmcsIDAuMGYsIDEuMGYpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBQYXJ0aXRpb24gY29udGFjdHMgc28gdGhhdCBjb250YWN0cyB3aXRoIHN0YXRpYyBib2RpZXMgYXJlIHNvbHZlZCBsYXN0LlxyXG4gICAgICAgICAgICBpbnQgaTEgPSAtMTtcclxuICAgICAgICAgICAgZm9yIChpbnQgaTIgPSAwOyBpMiA8IENvbnRhY3RDb3VudDsgKytpMilcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgRml4dHVyZSBmaXh0dXJlQSA9IF9jb250YWN0c1tpMl0uRml4dHVyZUE7XHJcbiAgICAgICAgICAgICAgICBGaXh0dXJlIGZpeHR1cmVCID0gX2NvbnRhY3RzW2kyXS5GaXh0dXJlQjtcclxuICAgICAgICAgICAgICAgIEJvZHkgYm9keUEgPSBmaXh0dXJlQS5Cb2R5O1xyXG4gICAgICAgICAgICAgICAgQm9keSBib2R5QiA9IGZpeHR1cmVCLkJvZHk7XHJcbiAgICAgICAgICAgICAgICBib29sIG5vblN0YXRpYyA9IGJvZHlBLkJvZHlUeXBlICE9IEJvZHlUeXBlLlN0YXRpYyAmJiBib2R5Qi5Cb2R5VHlwZSAhPSBCb2R5VHlwZS5TdGF0aWM7XHJcbiAgICAgICAgICAgICAgICBpZiAobm9uU3RhdGljKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICsraTE7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vVE9ETzogT25seSBzd2FwIGlmIHRoZXkgYXJlIG5vdCB0aGUgc2FtZT8gc2VlIGh0dHA6Ly9jb2RlLmdvb2dsZS5jb20vcC9ib3gyZC9pc3N1ZXMvZGV0YWlsP2lkPTE2MlxyXG4gICAgICAgICAgICAgICAgICAgIENvbnRhY3QgdG1wID0gX2NvbnRhY3RzW2kxXTtcclxuICAgICAgICAgICAgICAgICAgICBfY29udGFjdHNbaTFdID0gX2NvbnRhY3RzW2kyXTtcclxuICAgICAgICAgICAgICAgICAgICBfY29udGFjdHNbaTJdID0gdG1wO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBJbml0aWFsaXplIHZlbG9jaXR5IGNvbnN0cmFpbnRzLlxyXG4gICAgICAgICAgICBfY29udGFjdFNvbHZlci5SZXNldChfY29udGFjdHMsIENvbnRhY3RDb3VudCwgc3RlcC5kdFJhdGlvLCBTZXR0aW5ncy5FbmFibGVXYXJtc3RhcnRpbmcpO1xyXG4gICAgICAgICAgICBfY29udGFjdFNvbHZlci5Jbml0aWFsaXplVmVsb2NpdHlDb25zdHJhaW50cygpO1xyXG5cclxuICAgICAgICAgICAgaWYgKFNldHRpbmdzLkVuYWJsZVdhcm1zdGFydGluZylcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgX2NvbnRhY3RTb2x2ZXIuV2FybVN0YXJ0KCk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcblxyXG4gICAgICAgICAgICBmb3IgKGludCBpID0gMDsgaSA8IEpvaW50Q291bnQ7ICsraSlcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgaWYgKF9qb2ludHNbaV0uRW5hYmxlZClcclxuICAgICAgICAgICAgICAgICAgICBfam9pbnRzW2ldLkluaXRWZWxvY2l0eUNvbnN0cmFpbnRzKHJlZiBzdGVwKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuXHJcbiAgICAgICAgICAgIC8vIFNvbHZlIHZlbG9jaXR5IGNvbnN0cmFpbnRzLlxyXG4gICAgICAgICAgICBmb3IgKGludCBpID0gMDsgaSA8IFNldHRpbmdzLlZlbG9jaXR5SXRlcmF0aW9uczsgKytpKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBmb3IgKGludCBqID0gMDsgaiA8IEpvaW50Q291bnQ7ICsrailcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBKb2ludCBqb2ludCA9IF9qb2ludHNbal07XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmICgham9pbnQuRW5hYmxlZClcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGpvaW50LlNvbHZlVmVsb2NpdHlDb25zdHJhaW50cyhyZWYgc3RlcCk7XHJcbiAgICAgICAgICAgICAgICAgICAgam9pbnQuVmFsaWRhdGUoc3RlcC5pbnZfZHQpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuXHJcbiAgICAgICAgICAgICAgICBfY29udGFjdFNvbHZlci5Tb2x2ZVZlbG9jaXR5Q29uc3RyYWludHMoKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gUG9zdC1zb2x2ZSAoc3RvcmUgaW1wdWxzZXMgZm9yIHdhcm0gc3RhcnRpbmcpLlxyXG4gICAgICAgICAgICBfY29udGFjdFNvbHZlci5TdG9yZUltcHVsc2VzKCk7XHJcblxyXG4gICAgICAgICAgICAvLyBJbnRlZ3JhdGUgcG9zaXRpb25zLlxyXG4gICAgICAgICAgICBmb3IgKGludCBpID0gMDsgaSA8IEJvZHlDb3VudDsgKytpKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBCb2R5IGIgPSBCb2RpZXNbaV07XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKGIuQm9keVR5cGUgPT0gQm9keVR5cGUuU3RhdGljKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIC8vIENoZWNrIGZvciBsYXJnZSB2ZWxvY2l0aWVzLlxyXG4gICAgICAgICAgICAgICAgZmxvYXQgdHJhbnNsYXRpb25YID0gc3RlcC5kdCAqIGIuTGluZWFyVmVsb2NpdHlJbnRlcm5hbC5YO1xyXG4gICAgICAgICAgICAgICAgZmxvYXQgdHJhbnNsYXRpb25ZID0gc3RlcC5kdCAqIGIuTGluZWFyVmVsb2NpdHlJbnRlcm5hbC5ZO1xyXG4gICAgICAgICAgICAgICAgZmxvYXQgcmVzdWx0ID0gdHJhbnNsYXRpb25YICogdHJhbnNsYXRpb25YICsgdHJhbnNsYXRpb25ZICogdHJhbnNsYXRpb25ZO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmIChyZXN1bHQgPiBTZXR0aW5ncy5NYXhUcmFuc2xhdGlvblNxdWFyZWQpXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgZmxvYXQgc3EgPSAoZmxvYXQpTWF0aC5TcXJ0KHJlc3VsdCk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGZsb2F0IHJhdGlvID0gU2V0dGluZ3MuTWF4VHJhbnNsYXRpb24gLyBzcTtcclxuICAgICAgICAgICAgICAgICAgICBiLkxpbmVhclZlbG9jaXR5SW50ZXJuYWwuWCAqPSByYXRpbztcclxuICAgICAgICAgICAgICAgICAgICBiLkxpbmVhclZlbG9jaXR5SW50ZXJuYWwuWSAqPSByYXRpbztcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBmbG9hdCByb3RhdGlvbiA9IHN0ZXAuZHQgKiBiLkFuZ3VsYXJWZWxvY2l0eUludGVybmFsO1xyXG4gICAgICAgICAgICAgICAgaWYgKHJvdGF0aW9uICogcm90YXRpb24gPiBTZXR0aW5ncy5NYXhSb3RhdGlvblNxdWFyZWQpXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgZmxvYXQgcmF0aW8gPSBTZXR0aW5ncy5NYXhSb3RhdGlvbiAvIChmbG9hdClNYXRoLkFicyhyb3RhdGlvbik7XHJcbiAgICAgICAgICAgICAgICAgICAgYi5Bbmd1bGFyVmVsb2NpdHlJbnRlcm5hbCAqPSByYXRpbztcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAvLyBTdG9yZSBwb3NpdGlvbnMgZm9yIGNvbnRpbnVvdXMgY29sbGlzaW9uLlxyXG4gICAgICAgICAgICAgICAgYi5Td2VlcC5DMC5YID0gYi5Td2VlcC5DLlg7XHJcbiAgICAgICAgICAgICAgICBiLlN3ZWVwLkMwLlkgPSBiLlN3ZWVwLkMuWTtcclxuICAgICAgICAgICAgICAgIGIuU3dlZXAuQTAgPSBiLlN3ZWVwLkE7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gSW50ZWdyYXRlXHJcbiAgICAgICAgICAgICAgICBiLlN3ZWVwLkMuWCArPSBzdGVwLmR0ICogYi5MaW5lYXJWZWxvY2l0eUludGVybmFsLlg7XHJcbiAgICAgICAgICAgICAgICBiLlN3ZWVwLkMuWSArPSBzdGVwLmR0ICogYi5MaW5lYXJWZWxvY2l0eUludGVybmFsLlk7XHJcbiAgICAgICAgICAgICAgICBiLlN3ZWVwLkEgKz0gc3RlcC5kdCAqIGIuQW5ndWxhclZlbG9jaXR5SW50ZXJuYWw7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gQ29tcHV0ZSBuZXcgdHJhbnNmb3JtXHJcbiAgICAgICAgICAgICAgICBiLlN5bmNocm9uaXplVHJhbnNmb3JtKCk7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gTm90ZTogc2hhcGVzIGFyZSBzeW5jaHJvbml6ZWQgbGF0ZXIuXHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIEl0ZXJhdGUgb3ZlciBjb25zdHJhaW50cy5cclxuICAgICAgICAgICAgZm9yIChpbnQgaSA9IDA7IGkgPCBTZXR0aW5ncy5Qb3NpdGlvbkl0ZXJhdGlvbnM7ICsraSlcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgYm9vbCBjb250YWN0c09rYXkgPSBfY29udGFjdFNvbHZlci5Tb2x2ZVBvc2l0aW9uQ29uc3RyYWludHMoU2V0dGluZ3MuQ29udGFjdEJhdW1nYXJ0ZSk7XHJcbiAgICAgICAgICAgICAgICBib29sIGpvaW50c09rYXkgPSB0cnVlO1xyXG5cclxuICAgICAgICAgICAgICAgIGZvciAoaW50IGogPSAwOyBqIDwgSm9pbnRDb3VudDsgKytqKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIEpvaW50IGpvaW50ID0gX2pvaW50c1tqXTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIWpvaW50LkVuYWJsZWQpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBib29sIGpvaW50T2theSA9IGpvaW50LlNvbHZlUG9zaXRpb25Db25zdHJhaW50cygpO1xyXG4gICAgICAgICAgICAgICAgICAgIGpvaW50c09rYXkgPSBqb2ludHNPa2F5ICYmIGpvaW50T2theTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoY29udGFjdHNPa2F5ICYmIGpvaW50c09rYXkpXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gRXhpdCBlYXJseSBpZiB0aGUgcG9zaXRpb24gZXJyb3JzIGFyZSBzbWFsbC5cclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuXHJcbiAgICAgICAgICAgIFJlcG9ydChfY29udGFjdFNvbHZlci5Db25zdHJhaW50cyk7XHJcblxyXG4gICAgICAgICAgICBpZiAoU2V0dGluZ3MuQWxsb3dTbGVlcClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgZmxvYXQgbWluU2xlZXBUaW1lID0gU2V0dGluZ3MuTWF4RmxvYXQ7XHJcblxyXG4gICAgICAgICAgICAgICAgZm9yIChpbnQgaSA9IDA7IGkgPCBCb2R5Q291bnQ7ICsraSlcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBCb2R5IGIgPSBCb2RpZXNbaV07XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGIuQm9keVR5cGUgPT0gQm9keVR5cGUuU3RhdGljKVxyXG4gICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZiAoKGIuRmxhZ3MgJiBCb2R5RmxhZ3MuQXV0b1NsZWVwKSA9PSAwKVxyXG4gICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYi5TbGVlcFRpbWUgPSAwLjBmO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBtaW5TbGVlcFRpbWUgPSAwLjBmO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKChiLkZsYWdzICYgQm9keUZsYWdzLkF1dG9TbGVlcCkgPT0gMCB8fFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBiLkFuZ3VsYXJWZWxvY2l0eUludGVybmFsICogYi5Bbmd1bGFyVmVsb2NpdHlJbnRlcm5hbCA+IEFuZ1RvbFNxciB8fFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBWZWN0b3IyLkRvdChiLkxpbmVhclZlbG9jaXR5SW50ZXJuYWwsIGIuTGluZWFyVmVsb2NpdHlJbnRlcm5hbCkgPiBMaW5Ub2xTcXIpXHJcbiAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBiLlNsZWVwVGltZSA9IDAuMGY7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1pblNsZWVwVGltZSA9IDAuMGY7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGIuU2xlZXBUaW1lICs9IHN0ZXAuZHQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1pblNsZWVwVGltZSA9IE1hdGguTWluKG1pblNsZWVwVGltZSwgYi5TbGVlcFRpbWUpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBpZiAobWluU2xlZXBUaW1lID49IFNldHRpbmdzLlRpbWVUb1NsZWVwKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIGZvciAoaW50IGkgPSAwOyBpIDwgQm9keUNvdW50OyArK2kpXHJcbiAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBCb2R5IGIgPSBCb2RpZXNbaV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGIuQXdha2UgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGludGVybmFsIHZvaWQgU29sdmVUT0kocmVmIFRpbWVTdGVwIHN1YlN0ZXApXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBfY29udGFjdFNvbHZlci5SZXNldChfY29udGFjdHMsIENvbnRhY3RDb3VudCwgc3ViU3RlcC5kdFJhdGlvLCBmYWxzZSk7XHJcblxyXG4gICAgICAgICAgICAvLyBTb2x2ZSBwb3NpdGlvbiBjb25zdHJhaW50cy5cclxuICAgICAgICAgICAgY29uc3QgZmxvYXQga1RPSUJhdW1nYXJ0ZSA9IDAuNzVmO1xyXG4gICAgICAgICAgICBmb3IgKGludCBpID0gMDsgaSA8IFNldHRpbmdzLlRPSVBvc2l0aW9uSXRlcmF0aW9uczsgKytpKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBib29sIGNvbnRhY3RzT2theSA9IF9jb250YWN0U29sdmVyLlNvbHZlUG9zaXRpb25Db25zdHJhaW50cyhrVE9JQmF1bWdhcnRlKTtcclxuICAgICAgICAgICAgICAgIGlmIChjb250YWN0c09rYXkpXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKGkgPT0gU2V0dGluZ3MuVE9JUG9zaXRpb25JdGVyYXRpb25zIC0gMSlcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBpICs9IDA7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIExlYXAgb2YgZmFpdGggdG8gbmV3IHNhZmUgc3RhdGUuXHJcbiAgICAgICAgICAgIGZvciAoaW50IGkgPSAwOyBpIDwgQm9keUNvdW50OyArK2kpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIEJvZHkgYm9keSA9IEJvZGllc1tpXTtcclxuICAgICAgICAgICAgICAgIGJvZHkuU3dlZXAuQTAgPSBib2R5LlN3ZWVwLkE7XHJcbiAgICAgICAgICAgICAgICBib2R5LlN3ZWVwLkMwID0gYm9keS5Td2VlcC5DO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBObyB3YXJtIHN0YXJ0aW5nIGlzIG5lZWRlZCBmb3IgVE9JIGV2ZW50cyBiZWNhdXNlIHdhcm1cclxuICAgICAgICAgICAgLy8gc3RhcnRpbmcgaW1wdWxzZXMgd2VyZSBhcHBsaWVkIGluIHRoZSBkaXNjcmV0ZSBzb2x2ZXIuXHJcbiAgICAgICAgICAgIF9jb250YWN0U29sdmVyLkluaXRpYWxpemVWZWxvY2l0eUNvbnN0cmFpbnRzKCk7XHJcblxyXG4gICAgICAgICAgICAvLyBTb2x2ZSB2ZWxvY2l0eSBjb25zdHJhaW50cy5cclxuICAgICAgICAgICAgZm9yIChpbnQgaSA9IDA7IGkgPCBTZXR0aW5ncy5UT0lWZWxvY2l0eUl0ZXJhdGlvbnM7ICsraSlcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgX2NvbnRhY3RTb2x2ZXIuU29sdmVWZWxvY2l0eUNvbnN0cmFpbnRzKCk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIERvbid0IHN0b3JlIHRoZSBUT0kgY29udGFjdCBmb3JjZXMgZm9yIHdhcm0gc3RhcnRpbmdcclxuICAgICAgICAgICAgLy8gYmVjYXVzZSB0aGV5IGNhbiBiZSBxdWl0ZSBsYXJnZS5cclxuXHJcbiAgICAgICAgICAgIC8vIEludGVncmF0ZSBwb3NpdGlvbnMuXHJcbiAgICAgICAgICAgIGZvciAoaW50IGkgPSAwOyBpIDwgQm9keUNvdW50OyArK2kpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIEJvZHkgYiA9IEJvZGllc1tpXTtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoYi5Cb2R5VHlwZSA9PSBCb2R5VHlwZS5TdGF0aWMpXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gQ2hlY2sgZm9yIGxhcmdlIHZlbG9jaXRpZXMuXHJcbiAgICAgICAgICAgICAgICBmbG9hdCB0cmFuc2xhdGlvbnggPSBzdWJTdGVwLmR0ICogYi5MaW5lYXJWZWxvY2l0eUludGVybmFsLlg7XHJcbiAgICAgICAgICAgICAgICBmbG9hdCB0cmFuc2xhdGlvbnkgPSBzdWJTdGVwLmR0ICogYi5MaW5lYXJWZWxvY2l0eUludGVybmFsLlk7XHJcbiAgICAgICAgICAgICAgICBmbG9hdCBkb3QgPSB0cmFuc2xhdGlvbnggKiB0cmFuc2xhdGlvbnggKyB0cmFuc2xhdGlvbnkgKiB0cmFuc2xhdGlvbnk7XHJcbiAgICAgICAgICAgICAgICBpZiAoZG90ID4gU2V0dGluZ3MuTWF4VHJhbnNsYXRpb25TcXVhcmVkKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIGZsb2F0IG5vcm0gPSAxZiAvIChmbG9hdClNYXRoLlNxcnQoZG90KTtcclxuICAgICAgICAgICAgICAgICAgICBmbG9hdCB2YWx1ZSA9IFNldHRpbmdzLk1heFRyYW5zbGF0aW9uICogc3ViU3RlcC5pbnZfZHQ7XHJcbiAgICAgICAgICAgICAgICAgICAgYi5MaW5lYXJWZWxvY2l0eUludGVybmFsLlggPSB2YWx1ZSAqICh0cmFuc2xhdGlvbnggKiBub3JtKTtcclxuICAgICAgICAgICAgICAgICAgICBiLkxpbmVhclZlbG9jaXR5SW50ZXJuYWwuWSA9IHZhbHVlICogKHRyYW5zbGF0aW9ueSAqIG5vcm0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGZsb2F0IHJvdGF0aW9uID0gc3ViU3RlcC5kdCAqIGIuQW5ndWxhclZlbG9jaXR5O1xyXG4gICAgICAgICAgICAgICAgaWYgKHJvdGF0aW9uICogcm90YXRpb24gPiBTZXR0aW5ncy5NYXhSb3RhdGlvblNxdWFyZWQpXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJvdGF0aW9uIDwgMC4wKVxyXG4gICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYi5Bbmd1bGFyVmVsb2NpdHlJbnRlcm5hbCA9IC1zdWJTdGVwLmludl9kdCAqIFNldHRpbmdzLk1heFJvdGF0aW9uO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBiLkFuZ3VsYXJWZWxvY2l0eUludGVybmFsID0gc3ViU3RlcC5pbnZfZHQgKiBTZXR0aW5ncy5NYXhSb3RhdGlvbjtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gSW50ZWdyYXRlXHJcbiAgICAgICAgICAgICAgICBiLlN3ZWVwLkMuWCArPSBzdWJTdGVwLmR0ICogYi5MaW5lYXJWZWxvY2l0eUludGVybmFsLlg7XHJcbiAgICAgICAgICAgICAgICBiLlN3ZWVwLkMuWSArPSBzdWJTdGVwLmR0ICogYi5MaW5lYXJWZWxvY2l0eUludGVybmFsLlk7XHJcbiAgICAgICAgICAgICAgICBiLlN3ZWVwLkEgKz0gc3ViU3RlcC5kdCAqIGIuQW5ndWxhclZlbG9jaXR5SW50ZXJuYWw7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gQ29tcHV0ZSBuZXcgdHJhbnNmb3JtXHJcbiAgICAgICAgICAgICAgICBiLlN5bmNocm9uaXplVHJhbnNmb3JtKCk7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gTm90ZTogc2hhcGVzIGFyZSBzeW5jaHJvbml6ZWQgbGF0ZXIuXHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIFJlcG9ydChfY29udGFjdFNvbHZlci5Db25zdHJhaW50cyk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwdWJsaWMgdm9pZCBBZGQoQm9keSBib2R5KVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgRGVidWcuQXNzZXJ0KEJvZHlDb3VudCA8IF9ib2R5Q2FwYWNpdHkpO1xyXG4gICAgICAgICAgICBCb2RpZXNbQm9keUNvdW50KytdID0gYm9keTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHB1YmxpYyB2b2lkIEFkZChDb250YWN0IGNvbnRhY3QpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBEZWJ1Zy5Bc3NlcnQoQ29udGFjdENvdW50IDwgX2NvbnRhY3RDYXBhY2l0eSk7XHJcbiAgICAgICAgICAgIF9jb250YWN0c1tDb250YWN0Q291bnQrK10gPSBjb250YWN0O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHVibGljIHZvaWQgQWRkKEpvaW50IGpvaW50KVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgRGVidWcuQXNzZXJ0KEpvaW50Q291bnQgPCBfam9pbnRDYXBhY2l0eSk7XHJcbiAgICAgICAgICAgIF9qb2ludHNbSm9pbnRDb3VudCsrXSA9IGpvaW50O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHJpdmF0ZSB2b2lkIFJlcG9ydChDb250YWN0Q29uc3RyYWludFtdIGNvbnN0cmFpbnRzKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgaWYgKF9jb250YWN0TWFuYWdlciA9PSBudWxsKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG5cclxuICAgICAgICAgICAgZm9yIChpbnQgaSA9IDA7IGkgPCBDb250YWN0Q291bnQ7ICsraSlcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgQ29udGFjdCBjID0gX2NvbnRhY3RzW2ldO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmIChjLkZpeHR1cmVBLkFmdGVyQ29sbGlzaW9uICE9IG51bGwpXHJcbiAgICAgICAgICAgICAgICAgICAgYy5GaXh0dXJlQS5BZnRlckNvbGxpc2lvbihjLkZpeHR1cmVBLCBjLkZpeHR1cmVCLCBjKTtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoYy5GaXh0dXJlQi5BZnRlckNvbGxpc2lvbiAhPSBudWxsKVxyXG4gICAgICAgICAgICAgICAgICAgIGMuRml4dHVyZUIuQWZ0ZXJDb2xsaXNpb24oYy5GaXh0dXJlQiwgYy5GaXh0dXJlQSwgYyk7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKF9jb250YWN0TWFuYWdlci5Qb3N0U29sdmUgIT0gbnVsbClcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBDb250YWN0Q29uc3RyYWludCBjYyA9IGNvbnN0cmFpbnRzW2ldO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBfY29udGFjdE1hbmFnZXIuUG9zdFNvbHZlKGMsIGNjKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxufSIsIi8qXHJcbiogRmFyc2VlciBQaHlzaWNzIEVuZ2luZSBiYXNlZCBvbiBCb3gyRC5YTkEgcG9ydDpcclxuKiBDb3B5cmlnaHQgKGMpIDIwMTAgSWFuIFF2aXN0XHJcbiogXHJcbiogQm94MkQuWE5BIHBvcnQgb2YgQm94MkQ6XHJcbiogQ29weXJpZ2h0IChjKSAyMDA5IEJyYW5kb24gRnVydHdhbmdsZXIsIE5hdGhhbiBGdXJ0d2FuZ2xlclxyXG4qXHJcbiogT3JpZ2luYWwgc291cmNlIEJveDJEOlxyXG4qIENvcHlyaWdodCAoYykgMjAwNi0yMDA5IEVyaW4gQ2F0dG8gaHR0cDovL3d3dy5ncGh5c2ljcy5jb20gXHJcbiogXHJcbiogVGhpcyBzb2Z0d2FyZSBpcyBwcm92aWRlZCAnYXMtaXMnLCB3aXRob3V0IGFueSBleHByZXNzIG9yIGltcGxpZWQgXHJcbiogd2FycmFudHkuICBJbiBubyBldmVudCB3aWxsIHRoZSBhdXRob3JzIGJlIGhlbGQgbGlhYmxlIGZvciBhbnkgZGFtYWdlcyBcclxuKiBhcmlzaW5nIGZyb20gdGhlIHVzZSBvZiB0aGlzIHNvZnR3YXJlLiBcclxuKiBQZXJtaXNzaW9uIGlzIGdyYW50ZWQgdG8gYW55b25lIHRvIHVzZSB0aGlzIHNvZnR3YXJlIGZvciBhbnkgcHVycG9zZSwgXHJcbiogaW5jbHVkaW5nIGNvbW1lcmNpYWwgYXBwbGljYXRpb25zLCBhbmQgdG8gYWx0ZXIgaXQgYW5kIHJlZGlzdHJpYnV0ZSBpdCBcclxuKiBmcmVlbHksIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyByZXN0cmljdGlvbnM6IFxyXG4qIDEuIFRoZSBvcmlnaW4gb2YgdGhpcyBzb2Z0d2FyZSBtdXN0IG5vdCBiZSBtaXNyZXByZXNlbnRlZDsgeW91IG11c3Qgbm90IFxyXG4qIGNsYWltIHRoYXQgeW91IHdyb3RlIHRoZSBvcmlnaW5hbCBzb2Z0d2FyZS4gSWYgeW91IHVzZSB0aGlzIHNvZnR3YXJlIFxyXG4qIGluIGEgcHJvZHVjdCwgYW4gYWNrbm93bGVkZ21lbnQgaW4gdGhlIHByb2R1Y3QgZG9jdW1lbnRhdGlvbiB3b3VsZCBiZSBcclxuKiBhcHByZWNpYXRlZCBidXQgaXMgbm90IHJlcXVpcmVkLiBcclxuKiAyLiBBbHRlcmVkIHNvdXJjZSB2ZXJzaW9ucyBtdXN0IGJlIHBsYWlubHkgbWFya2VkIGFzIHN1Y2gsIGFuZCBtdXN0IG5vdCBiZSBcclxuKiBtaXNyZXByZXNlbnRlZCBhcyBiZWluZyB0aGUgb3JpZ2luYWwgc29mdHdhcmUuIFxyXG4qIDMuIFRoaXMgbm90aWNlIG1heSBub3QgYmUgcmVtb3ZlZCBvciBhbHRlcmVkIGZyb20gYW55IHNvdXJjZSBkaXN0cmlidXRpb24uIFxyXG4qL1xyXG5cclxudXNpbmcgU3lzdGVtO1xyXG51c2luZyBTeXN0ZW0uRGlhZ25vc3RpY3M7XHJcbnVzaW5nIE1pY3Jvc29mdC5YbmEuRnJhbWV3b3JrO1xyXG5cclxubmFtZXNwYWNlIEZhcnNlZXJQaHlzaWNzLkR5bmFtaWNzLkpvaW50c1xyXG57XHJcbiAgICBwdWJsaWMgZW51bSBKb2ludFR5cGVcclxuICAgIHtcclxuICAgICAgICBSZXZvbHV0ZSxcclxuICAgICAgICBQcmlzbWF0aWMsXHJcbiAgICAgICAgRGlzdGFuY2UsXHJcbiAgICAgICAgUHVsbGV5LFxyXG4gICAgICAgIEdlYXIsXHJcbiAgICAgICAgTGluZSxcclxuICAgICAgICBXZWxkLFxyXG4gICAgICAgIEZyaWN0aW9uLFxyXG4gICAgICAgIFNsaWRlcixcclxuICAgICAgICBBbmdsZSxcclxuICAgICAgICBSb3BlLFxyXG4gICAgICAgIEZpeGVkTW91c2UsXHJcbiAgICAgICAgRml4ZWRSZXZvbHV0ZSxcclxuICAgICAgICBGaXhlZERpc3RhbmNlLFxyXG4gICAgICAgIEZpeGVkTGluZSxcclxuICAgICAgICBGaXhlZFByaXNtYXRpYyxcclxuICAgICAgICBGaXhlZEFuZ2xlLFxyXG4gICAgICAgIEZpeGVkRnJpY3Rpb24sXHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGVudW0gTGltaXRTdGF0ZVxyXG4gICAge1xyXG4gICAgICAgIEluYWN0aXZlLFxyXG4gICAgICAgIEF0TG93ZXIsXHJcbiAgICAgICAgQXRVcHBlcixcclxuICAgICAgICBFcXVhbCxcclxuICAgIH1cclxuXHJcbiAgICBpbnRlcm5hbCBzdHJ1Y3QgSmFjb2JpYW5cclxuICAgIHtcclxuICAgICAgICBwdWJsaWMgZmxvYXQgQW5ndWxhckE7XHJcbiAgICAgICAgcHVibGljIGZsb2F0IEFuZ3VsYXJCO1xyXG4gICAgICAgIHB1YmxpYyBWZWN0b3IyIExpbmVhckE7XHJcbiAgICAgICAgcHVibGljIFZlY3RvcjIgTGluZWFyQjtcclxuXHJcbiAgICAgICAgcHVibGljIHZvaWQgU2V0WmVybygpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBMaW5lYXJBID0gVmVjdG9yMi5aZXJvO1xyXG4gICAgICAgICAgICBBbmd1bGFyQSA9IDAuMGY7XHJcbiAgICAgICAgICAgIExpbmVhckIgPSBWZWN0b3IyLlplcm87XHJcbiAgICAgICAgICAgIEFuZ3VsYXJCID0gMC4wZjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHB1YmxpYyB2b2lkIFNldChWZWN0b3IyIHgxLCBmbG9hdCBhMSwgVmVjdG9yMiB4MiwgZmxvYXQgYTIpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBMaW5lYXJBID0geDE7XHJcbiAgICAgICAgICAgIEFuZ3VsYXJBID0gYTE7XHJcbiAgICAgICAgICAgIExpbmVhckIgPSB4MjtcclxuICAgICAgICAgICAgQW5ndWxhckIgPSBhMjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHB1YmxpYyBmbG9hdCBDb21wdXRlKFZlY3RvcjIgeDEsIGZsb2F0IGExLCBWZWN0b3IyIHgyLCBmbG9hdCBhMilcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiBWZWN0b3IyLkRvdChMaW5lYXJBLCB4MSkgKyBBbmd1bGFyQSAqIGExICsgVmVjdG9yMi5Eb3QoTGluZWFyQiwgeDIpICsgQW5ndWxhckIgKiBhMjtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgLy8vIEEgam9pbnQgZWRnZSBpcyB1c2VkIHRvIGNvbm5lY3QgYm9kaWVzIGFuZCBqb2ludHMgdG9nZXRoZXJcclxuICAgIC8vLyBpbiBhIGpvaW50IGdyYXBoIHdoZXJlIGVhY2ggYm9keSBpcyBhIG5vZGUgYW5kIGVhY2ggam9pbnRcclxuICAgIC8vLyBpcyBhbiBlZGdlLiBBIGpvaW50IGVkZ2UgYmVsb25ncyB0byBhIGRvdWJseSBsaW5rZWQgbGlzdFxyXG4gICAgLy8vIG1haW50YWluZWQgaW4gZWFjaCBhdHRhY2hlZCBib2R5LiBFYWNoIGpvaW50IGhhcyB0d28gam9pbnRcclxuICAgIC8vLyBub2Rlcywgb25lIGZvciBlYWNoIGF0dGFjaGVkIGJvZHkuXHJcbiAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgcHVibGljIHNlYWxlZCBjbGFzcyBKb2ludEVkZ2VcclxuICAgIHtcclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIFRoZSBqb2ludC5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIHB1YmxpYyBKb2ludCBKb2ludDtcclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBUaGUgbmV4dCBqb2ludCBlZGdlIGluIHRoZSBib2R5J3Mgam9pbnQgbGlzdC5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIHB1YmxpYyBKb2ludEVkZ2UgTmV4dDtcclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBQcm92aWRlcyBxdWljayBhY2Nlc3MgdG8gdGhlIG90aGVyIGJvZHkgYXR0YWNoZWQuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICBwdWJsaWMgQm9keSBPdGhlcjtcclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBUaGUgcHJldmlvdXMgam9pbnQgZWRnZSBpbiB0aGUgYm9keSdzIGpvaW50IGxpc3QuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICBwdWJsaWMgSm9pbnRFZGdlIFByZXY7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGFic3RyYWN0IGNsYXNzIEpvaW50XHJcbiAgICB7XHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBUaGUgQnJlYWtwb2ludCBzaW1wbHkgaW5kaWNhdGVzIHRoZSBtYXhpbXVtIFZhbHVlIHRoZSBKb2ludEVycm9yIGNhbiBiZSBiZWZvcmUgaXQgYnJlYWtzLlxyXG4gICAgICAgIC8vLyBUaGUgZGVmYXVsdCB2YWx1ZSBpcyBmbG9hdC5NYXhWYWx1ZVxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgcHVibGljIGZsb2F0IEJyZWFrcG9pbnQgPSBmbG9hdC5NYXhWYWx1ZTtcclxuXHJcbiAgICAgICAgaW50ZXJuYWwgSm9pbnRFZGdlIEVkZ2VBID0gbmV3IEpvaW50RWRnZSgpO1xyXG4gICAgICAgIGludGVybmFsIEpvaW50RWRnZSBFZGdlQiA9IG5ldyBKb2ludEVkZ2UoKTtcclxuICAgICAgICBwdWJsaWMgYm9vbCBFbmFibGVkID0gdHJ1ZTtcclxuICAgICAgICBwcm90ZWN0ZWQgZmxvYXQgSW52SUE7XHJcbiAgICAgICAgcHJvdGVjdGVkIGZsb2F0IEludklCO1xyXG4gICAgICAgIHByb3RlY3RlZCBmbG9hdCBJbnZNYXNzQTtcclxuICAgICAgICBwcm90ZWN0ZWQgZmxvYXQgSW52TWFzc0I7XHJcbiAgICAgICAgaW50ZXJuYWwgYm9vbCBJc2xhbmRGbGFnO1xyXG4gICAgICAgIHByb3RlY3RlZCBWZWN0b3IyIExvY2FsQ2VudGVyQSwgTG9jYWxDZW50ZXJCO1xyXG5cclxuICAgICAgICBwcm90ZWN0ZWQgSm9pbnQoKVxyXG4gICAgICAgIHtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHByb3RlY3RlZCBKb2ludChCb2R5IGJvZHksIEJvZHkgYm9keUIpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBEZWJ1Zy5Bc3NlcnQoYm9keSAhPSBib2R5Qik7XHJcblxyXG4gICAgICAgICAgICBCb2R5QSA9IGJvZHk7XHJcbiAgICAgICAgICAgIEJvZHlCID0gYm9keUI7XHJcblxyXG4gICAgICAgICAgICAvL0Nvbm5lY3RlZCBib2RpZXMgc2hvdWxkIG5vdCBjb2xsaWRlIGJ5IGRlZmF1bHRcclxuICAgICAgICAgICAgQ29sbGlkZUNvbm5lY3RlZCA9IGZhbHNlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBDb25zdHJ1Y3RvciBmb3IgZml4ZWQgam9pbnRcclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIHByb3RlY3RlZCBKb2ludChCb2R5IGJvZHkpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBCb2R5QSA9IGJvZHk7XHJcblxyXG4gICAgICAgICAgICAvL0Nvbm5lY3RlZCBib2RpZXMgc2hvdWxkIG5vdCBjb2xsaWRlIGJ5IGRlZmF1bHRcclxuICAgICAgICAgICAgQ29sbGlkZUNvbm5lY3RlZCA9IGZhbHNlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBHZXRzIG9yIHNldHMgdGhlIHR5cGUgb2YgdGhlIGpvaW50LlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDx2YWx1ZT5UaGUgdHlwZSBvZiB0aGUgam9pbnQuPC92YWx1ZT5cclxuICAgICAgICBwdWJsaWMgSm9pbnRUeXBlIEpvaW50VHlwZSB7IGdldDsgcHJvdGVjdGVkIHNldDsgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIEdldCB0aGUgZmlyc3QgYm9keSBhdHRhY2hlZCB0byB0aGlzIGpvaW50LlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDx2YWx1ZT48L3ZhbHVlPlxyXG4gICAgICAgIHB1YmxpYyBCb2R5IEJvZHlBIHsgZ2V0OyBzZXQ7IH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBHZXQgdGhlIHNlY29uZCBib2R5IGF0dGFjaGVkIHRvIHRoaXMgam9pbnQuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHZhbHVlPjwvdmFsdWU+XHJcbiAgICAgICAgcHVibGljIEJvZHkgQm9keUIgeyBnZXQ7IHNldDsgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIEdldCB0aGUgYW5jaG9yIHBvaW50IG9uIGJvZHkxIGluIHdvcmxkIGNvb3JkaW5hdGVzLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDx2YWx1ZT48L3ZhbHVlPlxyXG4gICAgICAgIHB1YmxpYyBhYnN0cmFjdCBWZWN0b3IyIFdvcmxkQW5jaG9yQSB7IGdldDsgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIEdldCB0aGUgYW5jaG9yIHBvaW50IG9uIGJvZHkyIGluIHdvcmxkIGNvb3JkaW5hdGVzLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDx2YWx1ZT48L3ZhbHVlPlxyXG4gICAgICAgIHB1YmxpYyBhYnN0cmFjdCBWZWN0b3IyIFdvcmxkQW5jaG9yQiB7IGdldDsgc2V0OyB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gU2V0IHRoZSB1c2VyIGRhdGEgcG9pbnRlci5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8dmFsdWU+VGhlIGRhdGEuPC92YWx1ZT5cclxuICAgICAgICBwdWJsaWMgb2JqZWN0IFVzZXJEYXRhIHsgZ2V0OyBzZXQ7IH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBTaG9ydC1jdXQgZnVuY3Rpb24gdG8gZGV0ZXJtaW5lIGlmIGVpdGhlciBib2R5IGlzIGluYWN0aXZlLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDx2YWx1ZT48Yz50cnVlPC9jPiBpZiBhY3RpdmU7IG90aGVyd2lzZSwgPGM+ZmFsc2U8L2M+LjwvdmFsdWU+XHJcbiAgICAgICAgcHVibGljIGJvb2wgQWN0aXZlXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBnZXQgeyByZXR1cm4gQm9keUEuRW5hYmxlZCAmJiBCb2R5Qi5FbmFibGVkOyB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIFNldCB0aGlzIGZsYWcgdG8gdHJ1ZSBpZiB0aGUgYXR0YWNoZWQgYm9kaWVzIHNob3VsZCBjb2xsaWRlLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgcHVibGljIGJvb2wgQ29sbGlkZUNvbm5lY3RlZCB7IGdldDsgc2V0OyB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gRmlyZXMgd2hlbiB0aGUgam9pbnQgaXMgYnJva2VuLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgcHVibGljIGV2ZW50IEFjdGlvbjxKb2ludCwgZmxvYXQ+IEJyb2tlO1xyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIEdldCB0aGUgcmVhY3Rpb24gZm9yY2Ugb24gYm9keTIgYXQgdGhlIGpvaW50IGFuY2hvciBpbiBOZXd0b25zLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwiaW52X2R0XCI+VGhlIGludl9kdC48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cmV0dXJucz48L3JldHVybnM+XHJcbiAgICAgICAgcHVibGljIGFic3RyYWN0IFZlY3RvcjIgR2V0UmVhY3Rpb25Gb3JjZShmbG9hdCBpbnZfZHQpO1xyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIEdldCB0aGUgcmVhY3Rpb24gdG9ycXVlIG9uIGJvZHkyIGluIE4qbS5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cImludl9kdFwiPlRoZSBpbnZfZHQuPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHJldHVybnM+PC9yZXR1cm5zPlxyXG4gICAgICAgIHB1YmxpYyBhYnN0cmFjdCBmbG9hdCBHZXRSZWFjdGlvblRvcnF1ZShmbG9hdCBpbnZfZHQpO1xyXG5cclxuICAgICAgICBwcm90ZWN0ZWQgdm9pZCBXYWtlQm9kaWVzKClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIEJvZHlBLkF3YWtlID0gdHJ1ZTtcclxuICAgICAgICAgICAgaWYgKEJvZHlCICE9IG51bGwpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIEJvZHlCLkF3YWtlID0gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBSZXR1cm4gdHJ1ZSBpZiB0aGUgam9pbnQgaXMgYSBmaXhlZCB0eXBlLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgcHVibGljIGJvb2wgSXNGaXhlZFR5cGUoKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIEpvaW50VHlwZSA9PSBKb2ludFR5cGUuRml4ZWRSZXZvbHV0ZSB8fFxyXG4gICAgICAgICAgICAgICAgICAgSm9pbnRUeXBlID09IEpvaW50VHlwZS5GaXhlZERpc3RhbmNlIHx8XHJcbiAgICAgICAgICAgICAgICAgICBKb2ludFR5cGUgPT0gSm9pbnRUeXBlLkZpeGVkUHJpc21hdGljIHx8XHJcbiAgICAgICAgICAgICAgICAgICBKb2ludFR5cGUgPT0gSm9pbnRUeXBlLkZpeGVkTGluZSB8fFxyXG4gICAgICAgICAgICAgICAgICAgSm9pbnRUeXBlID09IEpvaW50VHlwZS5GaXhlZE1vdXNlIHx8XHJcbiAgICAgICAgICAgICAgICAgICBKb2ludFR5cGUgPT0gSm9pbnRUeXBlLkZpeGVkQW5nbGUgfHxcclxuICAgICAgICAgICAgICAgICAgIEpvaW50VHlwZSA9PSBKb2ludFR5cGUuRml4ZWRGcmljdGlvbjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGludGVybmFsIGFic3RyYWN0IHZvaWQgSW5pdFZlbG9jaXR5Q29uc3RyYWludHMocmVmIFRpbWVTdGVwIHN0ZXApO1xyXG5cclxuICAgICAgICBpbnRlcm5hbCB2b2lkIFZhbGlkYXRlKGZsb2F0IGludkRUKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgaWYgKCFFbmFibGVkKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG5cclxuICAgICAgICAgICAgZmxvYXQgam9pbnRFcnJvciA9IEdldFJlYWN0aW9uRm9yY2UoaW52RFQpLkxlbmd0aCgpO1xyXG4gICAgICAgICAgICBpZiAoTWF0aC5BYnMoam9pbnRFcnJvcikgPD0gQnJlYWtwb2ludClcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuXHJcbiAgICAgICAgICAgIEVuYWJsZWQgPSBmYWxzZTtcclxuXHJcbiAgICAgICAgICAgIGlmIChCcm9rZSAhPSBudWxsKVxyXG4gICAgICAgICAgICAgICAgQnJva2UodGhpcywgam9pbnRFcnJvcik7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpbnRlcm5hbCBhYnN0cmFjdCB2b2lkIFNvbHZlVmVsb2NpdHlDb25zdHJhaW50cyhyZWYgVGltZVN0ZXAgc3RlcCk7XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gU29sdmVzIHRoZSBwb3NpdGlvbiBjb25zdHJhaW50cy5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8cmV0dXJucz5yZXR1cm5zIHRydWUgaWYgdGhlIHBvc2l0aW9uIGVycm9ycyBhcmUgd2l0aGluIHRvbGVyYW5jZS48L3JldHVybnM+XHJcbiAgICAgICAgaW50ZXJuYWwgYWJzdHJhY3QgYm9vbCBTb2x2ZVBvc2l0aW9uQ29uc3RyYWludHMoKTtcclxuICAgIH1cclxufSIsInVzaW5nIFN5c3RlbTtcclxudXNpbmcgU3lzdGVtLkNvbGxlY3Rpb25zLkdlbmVyaWM7XHJcbnVzaW5nIEZhcnNlZXJQaHlzaWNzLkNvbGxpc2lvbi5TaGFwZXM7XHJcbnVzaW5nIEZhcnNlZXJQaHlzaWNzLkNvbW1vbjtcclxudXNpbmcgRmFyc2VlclBoeXNpY3MuQ29tbW9uLkRlY29tcG9zaXRpb247XHJcbnVzaW5nIEZhcnNlZXJQaHlzaWNzLkR5bmFtaWNzO1xyXG51c2luZyBNaWNyb3NvZnQuWG5hLkZyYW1ld29yaztcclxuXHJcbm5hbWVzcGFjZSBGYXJzZWVyUGh5c2ljcy5GYWN0b3JpZXNcclxue1xyXG4gICAgcHVibGljIHN0YXRpYyBjbGFzcyBCb2R5RmFjdG9yeVxyXG4gICAge1xyXG4gICAgICAgIHB1YmxpYyBzdGF0aWMgQm9keSBDcmVhdGVCb2R5KFdvcmxkIHdvcmxkKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIENyZWF0ZUJvZHkod29ybGQsIG51bGwpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHVibGljIHN0YXRpYyBCb2R5IENyZWF0ZUJvZHkoV29ybGQgd29ybGQsIG9iamVjdCB1c2VyRGF0YSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIEJvZHkgYm9keSA9IG5ldyBCb2R5KHdvcmxkLCB1c2VyRGF0YSk7XHJcbiAgICAgICAgICAgIHJldHVybiBib2R5O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHVibGljIHN0YXRpYyBCb2R5IENyZWF0ZUJvZHkoV29ybGQgd29ybGQsIFZlY3RvcjIgcG9zaXRpb24pXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gQ3JlYXRlQm9keSh3b3JsZCwgcG9zaXRpb24sIG51bGwpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHVibGljIHN0YXRpYyBCb2R5IENyZWF0ZUJvZHkoV29ybGQgd29ybGQsIFZlY3RvcjIgcG9zaXRpb24sIG9iamVjdCB1c2VyRGF0YSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIEJvZHkgYm9keSA9IENyZWF0ZUJvZHkod29ybGQsIHVzZXJEYXRhKTtcclxuICAgICAgICAgICAgYm9keS5Qb3NpdGlvbiA9IHBvc2l0aW9uO1xyXG4gICAgICAgICAgICByZXR1cm4gYm9keTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHB1YmxpYyBzdGF0aWMgQm9keSBDcmVhdGVFZGdlKFdvcmxkIHdvcmxkLCBWZWN0b3IyIHN0YXJ0LCBWZWN0b3IyIGVuZClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiBDcmVhdGVFZGdlKHdvcmxkLCBzdGFydCwgZW5kLCBudWxsKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHB1YmxpYyBzdGF0aWMgQm9keSBDcmVhdGVFZGdlKFdvcmxkIHdvcmxkLCBWZWN0b3IyIHN0YXJ0LCBWZWN0b3IyIGVuZCwgb2JqZWN0IHVzZXJEYXRhKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgQm9keSBib2R5ID0gQ3JlYXRlQm9keSh3b3JsZCk7XHJcbiAgICAgICAgICAgIEZpeHR1cmVGYWN0b3J5LkF0dGFjaEVkZ2Uoc3RhcnQsIGVuZCwgYm9keSwgdXNlckRhdGEpO1xyXG4gICAgICAgICAgICByZXR1cm4gYm9keTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHB1YmxpYyBzdGF0aWMgQm9keSBDcmVhdGVMb29wU2hhcGUoV29ybGQgd29ybGQsIFZlcnRpY2VzIHZlcnRpY2VzKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIENyZWF0ZUxvb3BTaGFwZSh3b3JsZCwgdmVydGljZXMsIG51bGwpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHVibGljIHN0YXRpYyBCb2R5IENyZWF0ZUxvb3BTaGFwZShXb3JsZCB3b3JsZCwgVmVydGljZXMgdmVydGljZXMsIG9iamVjdCB1c2VyRGF0YSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiBDcmVhdGVMb29wU2hhcGUod29ybGQsIHZlcnRpY2VzLCBWZWN0b3IyLlplcm8sIHVzZXJEYXRhKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHB1YmxpYyBzdGF0aWMgQm9keSBDcmVhdGVMb29wU2hhcGUoV29ybGQgd29ybGQsIFZlcnRpY2VzIHZlcnRpY2VzLCBWZWN0b3IyIHBvc2l0aW9uKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIENyZWF0ZUxvb3BTaGFwZSh3b3JsZCwgdmVydGljZXMsIHBvc2l0aW9uLCBudWxsKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHB1YmxpYyBzdGF0aWMgQm9keSBDcmVhdGVMb29wU2hhcGUoV29ybGQgd29ybGQsIFZlcnRpY2VzIHZlcnRpY2VzLCBWZWN0b3IyIHBvc2l0aW9uLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb2JqZWN0IHVzZXJEYXRhKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgQm9keSBib2R5ID0gQ3JlYXRlQm9keSh3b3JsZCwgcG9zaXRpb24pO1xyXG4gICAgICAgICAgICBGaXh0dXJlRmFjdG9yeS5BdHRhY2hMb29wU2hhcGUodmVydGljZXMsIGJvZHksIHVzZXJEYXRhKTtcclxuICAgICAgICAgICAgcmV0dXJuIGJvZHk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwdWJsaWMgc3RhdGljIEJvZHkgQ3JlYXRlUmVjdGFuZ2xlKFdvcmxkIHdvcmxkLCBmbG9hdCB3aWR0aCwgZmxvYXQgaGVpZ2h0LCBmbG9hdCBkZW5zaXR5KVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIENyZWF0ZVJlY3RhbmdsZSh3b3JsZCwgd2lkdGgsIGhlaWdodCwgZGVuc2l0eSwgbnVsbCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwdWJsaWMgc3RhdGljIEJvZHkgQ3JlYXRlUmVjdGFuZ2xlKFdvcmxkIHdvcmxkLCBmbG9hdCB3aWR0aCwgZmxvYXQgaGVpZ2h0LCBmbG9hdCBkZW5zaXR5LCBvYmplY3QgdXNlckRhdGEpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gQ3JlYXRlUmVjdGFuZ2xlKHdvcmxkLCB3aWR0aCwgaGVpZ2h0LCBkZW5zaXR5LCBWZWN0b3IyLlplcm8sIHVzZXJEYXRhKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHB1YmxpYyBzdGF0aWMgQm9keSBDcmVhdGVSZWN0YW5nbGUoV29ybGQgd29ybGQsIGZsb2F0IHdpZHRoLCBmbG9hdCBoZWlnaHQsIGZsb2F0IGRlbnNpdHksIFZlY3RvcjIgcG9zaXRpb24pXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gQ3JlYXRlUmVjdGFuZ2xlKHdvcmxkLCB3aWR0aCwgaGVpZ2h0LCBkZW5zaXR5LCBwb3NpdGlvbiwgbnVsbCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwdWJsaWMgc3RhdGljIEJvZHkgQ3JlYXRlUmVjdGFuZ2xlKFdvcmxkIHdvcmxkLCBmbG9hdCB3aWR0aCwgZmxvYXQgaGVpZ2h0LCBmbG9hdCBkZW5zaXR5LCBWZWN0b3IyIHBvc2l0aW9uLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb2JqZWN0IHVzZXJEYXRhKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgaWYgKHdpZHRoIDw9IDApXHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQXJndW1lbnRPdXRPZlJhbmdlRXhjZXB0aW9uKFwid2lkdGhcIiwgXCJXaWR0aCBtdXN0IGJlIG1vcmUgdGhhbiAwIG1ldGVyc1wiKTtcclxuXHJcbiAgICAgICAgICAgIGlmIChoZWlnaHQgPD0gMClcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBBcmd1bWVudE91dE9mUmFuZ2VFeGNlcHRpb24oXCJoZWlnaHRcIiwgXCJIZWlnaHQgbXVzdCBiZSBtb3JlIHRoYW4gMCBtZXRlcnNcIik7XHJcblxyXG4gICAgICAgICAgICBCb2R5IG5ld0JvZHkgPSBDcmVhdGVCb2R5KHdvcmxkLCBwb3NpdGlvbik7XHJcbiAgICAgICAgICAgIFZlcnRpY2VzIHJlY3RhbmdsZVZlcnRpY2VzID0gUG9seWdvblRvb2xzLkNyZWF0ZVJlY3RhbmdsZSh3aWR0aCAvIDIsIGhlaWdodCAvIDIpO1xyXG4gICAgICAgICAgICBQb2x5Z29uU2hhcGUgcmVjdGFuZ2xlU2hhcGUgPSBuZXcgUG9seWdvblNoYXBlKHJlY3RhbmdsZVZlcnRpY2VzLCBkZW5zaXR5KTtcclxuICAgICAgICAgICAgbmV3Qm9keS5DcmVhdGVGaXh0dXJlKHJlY3RhbmdsZVNoYXBlLCB1c2VyRGF0YSk7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gbmV3Qm9keTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHB1YmxpYyBzdGF0aWMgQm9keSBDcmVhdGVDaXJjbGUoV29ybGQgd29ybGQsIGZsb2F0IHJhZGl1cywgZmxvYXQgZGVuc2l0eSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiBDcmVhdGVDaXJjbGUod29ybGQsIHJhZGl1cywgZGVuc2l0eSwgbnVsbCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwdWJsaWMgc3RhdGljIEJvZHkgQ3JlYXRlQ2lyY2xlKFdvcmxkIHdvcmxkLCBmbG9hdCByYWRpdXMsIGZsb2F0IGRlbnNpdHksIG9iamVjdCB1c2VyRGF0YSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiBDcmVhdGVDaXJjbGUod29ybGQsIHJhZGl1cywgZGVuc2l0eSwgVmVjdG9yMi5aZXJvLCB1c2VyRGF0YSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwdWJsaWMgc3RhdGljIEJvZHkgQ3JlYXRlQ2lyY2xlKFdvcmxkIHdvcmxkLCBmbG9hdCByYWRpdXMsIGZsb2F0IGRlbnNpdHksIFZlY3RvcjIgcG9zaXRpb24pXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gQ3JlYXRlQ2lyY2xlKHdvcmxkLCByYWRpdXMsIGRlbnNpdHksIHBvc2l0aW9uLCBudWxsKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHB1YmxpYyBzdGF0aWMgQm9keSBDcmVhdGVDaXJjbGUoV29ybGQgd29ybGQsIGZsb2F0IHJhZGl1cywgZmxvYXQgZGVuc2l0eSwgVmVjdG9yMiBwb3NpdGlvbiwgb2JqZWN0IHVzZXJEYXRhKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgQm9keSBib2R5ID0gQ3JlYXRlQm9keSh3b3JsZCwgcG9zaXRpb24pO1xyXG4gICAgICAgICAgICBGaXh0dXJlRmFjdG9yeS5BdHRhY2hDaXJjbGUocmFkaXVzLCBkZW5zaXR5LCBib2R5LCB1c2VyRGF0YSk7XHJcbiAgICAgICAgICAgIHJldHVybiBib2R5O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHVibGljIHN0YXRpYyBCb2R5IENyZWF0ZUVsbGlwc2UoV29ybGQgd29ybGQsIGZsb2F0IHhSYWRpdXMsIGZsb2F0IHlSYWRpdXMsIGludCBlZGdlcywgZmxvYXQgZGVuc2l0eSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiBDcmVhdGVFbGxpcHNlKHdvcmxkLCB4UmFkaXVzLCB5UmFkaXVzLCBlZGdlcywgZGVuc2l0eSwgbnVsbCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwdWJsaWMgc3RhdGljIEJvZHkgQ3JlYXRlRWxsaXBzZShXb3JsZCB3b3JsZCwgZmxvYXQgeFJhZGl1cywgZmxvYXQgeVJhZGl1cywgaW50IGVkZ2VzLCBmbG9hdCBkZW5zaXR5LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9iamVjdCB1c2VyRGF0YSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiBDcmVhdGVFbGxpcHNlKHdvcmxkLCB4UmFkaXVzLCB5UmFkaXVzLCBlZGdlcywgZGVuc2l0eSwgVmVjdG9yMi5aZXJvLCB1c2VyRGF0YSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwdWJsaWMgc3RhdGljIEJvZHkgQ3JlYXRlRWxsaXBzZShXb3JsZCB3b3JsZCwgZmxvYXQgeFJhZGl1cywgZmxvYXQgeVJhZGl1cywgaW50IGVkZ2VzLCBmbG9hdCBkZW5zaXR5LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFZlY3RvcjIgcG9zaXRpb24pXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gQ3JlYXRlRWxsaXBzZSh3b3JsZCwgeFJhZGl1cywgeVJhZGl1cywgZWRnZXMsIGRlbnNpdHksIHBvc2l0aW9uLCBudWxsKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHB1YmxpYyBzdGF0aWMgQm9keSBDcmVhdGVFbGxpcHNlKFdvcmxkIHdvcmxkLCBmbG9hdCB4UmFkaXVzLCBmbG9hdCB5UmFkaXVzLCBpbnQgZWRnZXMsIGZsb2F0IGRlbnNpdHksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgVmVjdG9yMiBwb3NpdGlvbiwgb2JqZWN0IHVzZXJEYXRhKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgQm9keSBib2R5ID0gQ3JlYXRlQm9keSh3b3JsZCwgcG9zaXRpb24pO1xyXG4gICAgICAgICAgICBGaXh0dXJlRmFjdG9yeS5BdHRhY2hFbGxpcHNlKHhSYWRpdXMsIHlSYWRpdXMsIGVkZ2VzLCBkZW5zaXR5LCBib2R5LCB1c2VyRGF0YSk7XHJcbiAgICAgICAgICAgIHJldHVybiBib2R5O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHVibGljIHN0YXRpYyBCb2R5IENyZWF0ZVBvbHlnb24oV29ybGQgd29ybGQsIFZlcnRpY2VzIHZlcnRpY2VzLCBmbG9hdCBkZW5zaXR5KVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIENyZWF0ZVBvbHlnb24od29ybGQsIHZlcnRpY2VzLCBkZW5zaXR5LCBudWxsKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHB1YmxpYyBzdGF0aWMgQm9keSBDcmVhdGVQb2x5Z29uKFdvcmxkIHdvcmxkLCBWZXJ0aWNlcyB2ZXJ0aWNlcywgZmxvYXQgZGVuc2l0eSwgb2JqZWN0IHVzZXJEYXRhKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIENyZWF0ZVBvbHlnb24od29ybGQsIHZlcnRpY2VzLCBkZW5zaXR5LCBWZWN0b3IyLlplcm8sIHVzZXJEYXRhKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHB1YmxpYyBzdGF0aWMgQm9keSBDcmVhdGVQb2x5Z29uKFdvcmxkIHdvcmxkLCBWZXJ0aWNlcyB2ZXJ0aWNlcywgZmxvYXQgZGVuc2l0eSwgVmVjdG9yMiBwb3NpdGlvbilcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiBDcmVhdGVQb2x5Z29uKHdvcmxkLCB2ZXJ0aWNlcywgZGVuc2l0eSwgcG9zaXRpb24sIG51bGwpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHVibGljIHN0YXRpYyBCb2R5IENyZWF0ZVBvbHlnb24oV29ybGQgd29ybGQsIFZlcnRpY2VzIHZlcnRpY2VzLCBmbG9hdCBkZW5zaXR5LCBWZWN0b3IyIHBvc2l0aW9uLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9iamVjdCB1c2VyRGF0YSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIEJvZHkgYm9keSA9IENyZWF0ZUJvZHkod29ybGQsIHBvc2l0aW9uKTtcclxuICAgICAgICAgICAgRml4dHVyZUZhY3RvcnkuQXR0YWNoUG9seWdvbih2ZXJ0aWNlcywgZGVuc2l0eSwgYm9keSwgdXNlckRhdGEpO1xyXG4gICAgICAgICAgICByZXR1cm4gYm9keTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHB1YmxpYyBzdGF0aWMgQm9keSBDcmVhdGVDb21wb3VuZFBvbHlnb24oV29ybGQgd29ybGQsIExpc3Q8VmVydGljZXM+IGxpc3QsIGZsb2F0IGRlbnNpdHkpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gQ3JlYXRlQ29tcG91bmRQb2x5Z29uKHdvcmxkLCBsaXN0LCBkZW5zaXR5LCBCb2R5VHlwZS5TdGF0aWMpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHVibGljIHN0YXRpYyBCb2R5IENyZWF0ZUNvbXBvdW5kUG9seWdvbihXb3JsZCB3b3JsZCwgTGlzdDxWZXJ0aWNlcz4gbGlzdCwgZmxvYXQgZGVuc2l0eSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9iamVjdCB1c2VyRGF0YSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiBDcmVhdGVDb21wb3VuZFBvbHlnb24od29ybGQsIGxpc3QsIGRlbnNpdHksIFZlY3RvcjIuWmVybywgdXNlckRhdGEpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHVibGljIHN0YXRpYyBCb2R5IENyZWF0ZUNvbXBvdW5kUG9seWdvbihXb3JsZCB3b3JsZCwgTGlzdDxWZXJ0aWNlcz4gbGlzdCwgZmxvYXQgZGVuc2l0eSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFZlY3RvcjIgcG9zaXRpb24pXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gQ3JlYXRlQ29tcG91bmRQb2x5Z29uKHdvcmxkLCBsaXN0LCBkZW5zaXR5LCBwb3NpdGlvbiwgbnVsbCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwdWJsaWMgc3RhdGljIEJvZHkgQ3JlYXRlQ29tcG91bmRQb2x5Z29uKFdvcmxkIHdvcmxkLCBMaXN0PFZlcnRpY2VzPiBsaXN0LCBmbG9hdCBkZW5zaXR5LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgVmVjdG9yMiBwb3NpdGlvbiwgb2JqZWN0IHVzZXJEYXRhKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgLy9XZSBjcmVhdGUgYSBzaW5nbGUgYm9keVxyXG4gICAgICAgICAgICBCb2R5IHBvbHlnb25Cb2R5ID0gQ3JlYXRlQm9keSh3b3JsZCwgcG9zaXRpb24pO1xyXG4gICAgICAgICAgICBGaXh0dXJlRmFjdG9yeS5BdHRhY2hDb21wb3VuZFBvbHlnb24obGlzdCwgZGVuc2l0eSwgcG9seWdvbkJvZHksIHVzZXJEYXRhKTtcclxuICAgICAgICAgICAgcmV0dXJuIHBvbHlnb25Cb2R5O1xyXG4gICAgICAgIH1cclxuXHJcblxyXG4gICAgICAgIHB1YmxpYyBzdGF0aWMgQm9keSBDcmVhdGVHZWFyKFdvcmxkIHdvcmxkLCBmbG9hdCByYWRpdXMsIGludCBudW1iZXJPZlRlZXRoLCBmbG9hdCB0aXBQZXJjZW50YWdlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZsb2F0IHRvb3RoSGVpZ2h0LCBmbG9hdCBkZW5zaXR5KVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIENyZWF0ZUdlYXIod29ybGQsIHJhZGl1cywgbnVtYmVyT2ZUZWV0aCwgdGlwUGVyY2VudGFnZSwgdG9vdGhIZWlnaHQsIGRlbnNpdHksIG51bGwpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHVibGljIHN0YXRpYyBCb2R5IENyZWF0ZUdlYXIoV29ybGQgd29ybGQsIGZsb2F0IHJhZGl1cywgaW50IG51bWJlck9mVGVldGgsIGZsb2F0IHRpcFBlcmNlbnRhZ2UsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmxvYXQgdG9vdGhIZWlnaHQsIGZsb2F0IGRlbnNpdHksIG9iamVjdCB1c2VyRGF0YSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIFZlcnRpY2VzIGdlYXJQb2x5Z29uID0gUG9seWdvblRvb2xzLkNyZWF0ZUdlYXIocmFkaXVzLCBudW1iZXJPZlRlZXRoLCB0aXBQZXJjZW50YWdlLCB0b290aEhlaWdodCk7XHJcblxyXG4gICAgICAgICAgICAvL0dlYXJzIGNhbiBpbiBzb21lIGNhc2VzIGJlIGNvbnZleFxyXG4gICAgICAgICAgICBpZiAoIWdlYXJQb2x5Z29uLklzQ29udmV4KCkpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIC8vRGVjb21wb3NlIHRoZSBnZWFyOlxyXG4gICAgICAgICAgICAgICAgTGlzdDxWZXJ0aWNlcz4gbGlzdCA9IEVhcmNsaXBEZWNvbXBvc2VyLkNvbnZleFBhcnRpdGlvbihnZWFyUG9seWdvbik7XHJcblxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIENyZWF0ZUNvbXBvdW5kUG9seWdvbih3b3JsZCwgbGlzdCwgZGVuc2l0eSwgdXNlckRhdGEpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gQ3JlYXRlUG9seWdvbih3b3JsZCwgZ2VhclBvbHlnb24sIGRlbnNpdHksIHVzZXJEYXRhKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gQ3JlYXRlcyBhIGNhcHN1bGUuXHJcbiAgICAgICAgLy8vIE5vdGU6IEF1dG9tYXRpY2FsbHkgZGVjb21wb3NlcyB0aGUgY2Fwc3VsZSBpZiBpdCBjb250YWlucyB0b28gbWFueSB2ZXJ0aWNlcyAoY29udHJvbGxlZCBieSBTZXR0aW5ncy5NYXhQb2x5Z29uVmVydGljZXMpXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJ3b3JsZFwiPlRoZSB3b3JsZC48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cImhlaWdodFwiPlRoZSBoZWlnaHQuPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJ0b3BSYWRpdXNcIj5UaGUgdG9wIHJhZGl1cy48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cInRvcEVkZ2VzXCI+VGhlIHRvcCBlZGdlcy48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cImJvdHRvbVJhZGl1c1wiPlRoZSBib3R0b20gcmFkaXVzLjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwiYm90dG9tRWRnZXNcIj5UaGUgYm90dG9tIGVkZ2VzLjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwiZGVuc2l0eVwiPlRoZSBkZW5zaXR5LjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwicG9zaXRpb25cIj5UaGUgcG9zaXRpb24uPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHJldHVybnM+PC9yZXR1cm5zPlxyXG4gICAgICAgIHB1YmxpYyBzdGF0aWMgQm9keSBDcmVhdGVDYXBzdWxlKFdvcmxkIHdvcmxkLCBmbG9hdCBoZWlnaHQsIGZsb2F0IHRvcFJhZGl1cywgaW50IHRvcEVkZ2VzLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZsb2F0IGJvdHRvbVJhZGl1cyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnQgYm90dG9tRWRnZXMsIGZsb2F0IGRlbnNpdHksIFZlY3RvcjIgcG9zaXRpb24sIG9iamVjdCB1c2VyRGF0YSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIFZlcnRpY2VzIHZlcnRzID0gUG9seWdvblRvb2xzLkNyZWF0ZUNhcHN1bGUoaGVpZ2h0LCB0b3BSYWRpdXMsIHRvcEVkZ2VzLCBib3R0b21SYWRpdXMsIGJvdHRvbUVkZ2VzKTtcclxuXHJcbiAgICAgICAgICAgIEJvZHkgYm9keTtcclxuXHJcbiAgICAgICAgICAgIC8vVGhlcmUgYXJlIHRvbyBtYW55IHZlcnRpY2VzIGluIHRoZSBjYXBzdWxlLiBXZSBkZWNvbXBvc2UgaXQuXHJcbiAgICAgICAgICAgIGlmICh2ZXJ0cy5Db3VudCA+PSBTZXR0aW5ncy5NYXhQb2x5Z29uVmVydGljZXMpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIExpc3Q8VmVydGljZXM+IHZlcnRMaXN0ID0gRWFyY2xpcERlY29tcG9zZXIuQ29udmV4UGFydGl0aW9uKHZlcnRzKTtcclxuICAgICAgICAgICAgICAgIGJvZHkgPSBDcmVhdGVDb21wb3VuZFBvbHlnb24od29ybGQsIHZlcnRMaXN0LCBkZW5zaXR5LCB1c2VyRGF0YSk7XHJcbiAgICAgICAgICAgICAgICBib2R5LlBvc2l0aW9uID0gcG9zaXRpb247XHJcblxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGJvZHk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGJvZHkgPSBDcmVhdGVQb2x5Z29uKHdvcmxkLCB2ZXJ0cywgZGVuc2l0eSwgdXNlckRhdGEpO1xyXG4gICAgICAgICAgICBib2R5LlBvc2l0aW9uID0gcG9zaXRpb247XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gYm9keTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHB1YmxpYyBzdGF0aWMgQm9keSBDcmVhdGVDYXBzdWxlKFdvcmxkIHdvcmxkLCBmbG9hdCBoZWlnaHQsIGZsb2F0IHRvcFJhZGl1cywgaW50IHRvcEVkZ2VzLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZsb2F0IGJvdHRvbVJhZGl1cyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnQgYm90dG9tRWRnZXMsIGZsb2F0IGRlbnNpdHksIFZlY3RvcjIgcG9zaXRpb24pXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gQ3JlYXRlQ2Fwc3VsZSh3b3JsZCwgaGVpZ2h0LCB0b3BSYWRpdXMsIHRvcEVkZ2VzLCBib3R0b21SYWRpdXMsIGJvdHRvbUVkZ2VzLCBkZW5zaXR5LCBwb3NpdGlvbiwgbnVsbCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwdWJsaWMgc3RhdGljIEJvZHkgQ3JlYXRlQ2Fwc3VsZShXb3JsZCB3b3JsZCwgZmxvYXQgaGVpZ2h0LCBmbG9hdCBlbmRSYWRpdXMsIGZsb2F0IGRlbnNpdHkpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gQ3JlYXRlQ2Fwc3VsZSh3b3JsZCwgaGVpZ2h0LCBlbmRSYWRpdXMsIGRlbnNpdHksIG51bGwpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHVibGljIHN0YXRpYyBCb2R5IENyZWF0ZUNhcHN1bGUoV29ybGQgd29ybGQsIGZsb2F0IGhlaWdodCwgZmxvYXQgZW5kUmFkaXVzLCBmbG9hdCBkZW5zaXR5LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9iamVjdCB1c2VyRGF0YSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIC8vQ3JlYXRlIHRoZSBtaWRkbGUgcmVjdGFuZ2xlXHJcbiAgICAgICAgICAgIFZlcnRpY2VzIHJlY3RhbmdsZSA9IFBvbHlnb25Ub29scy5DcmVhdGVSZWN0YW5nbGUoZW5kUmFkaXVzLCBoZWlnaHQgLyAyKTtcclxuXHJcbiAgICAgICAgICAgIExpc3Q8VmVydGljZXM+IGxpc3QgPSBuZXcgTGlzdDxWZXJ0aWNlcz4oKTtcclxuICAgICAgICAgICAgbGlzdC5BZGQocmVjdGFuZ2xlKTtcclxuXHJcbiAgICAgICAgICAgIEJvZHkgYm9keSA9IENyZWF0ZUNvbXBvdW5kUG9seWdvbih3b3JsZCwgbGlzdCwgZGVuc2l0eSwgdXNlckRhdGEpO1xyXG5cclxuICAgICAgICAgICAgLy9DcmVhdGUgdGhlIHR3byBjaXJjbGVzXHJcbiAgICAgICAgICAgIENpcmNsZVNoYXBlIHRvcENpcmNsZSA9IG5ldyBDaXJjbGVTaGFwZShlbmRSYWRpdXMsIGRlbnNpdHkpO1xyXG4gICAgICAgICAgICB0b3BDaXJjbGUuUG9zaXRpb24gPSBuZXcgVmVjdG9yMigwLCBoZWlnaHQgLyAyKTtcclxuICAgICAgICAgICAgYm9keS5DcmVhdGVGaXh0dXJlKHRvcENpcmNsZSwgdXNlckRhdGEpO1xyXG5cclxuICAgICAgICAgICAgQ2lyY2xlU2hhcGUgYm90dG9tQ2lyY2xlID0gbmV3IENpcmNsZVNoYXBlKGVuZFJhZGl1cywgZGVuc2l0eSk7XHJcbiAgICAgICAgICAgIGJvdHRvbUNpcmNsZS5Qb3NpdGlvbiA9IG5ldyBWZWN0b3IyKDAsIC0oaGVpZ2h0IC8gMikpO1xyXG4gICAgICAgICAgICBib2R5LkNyZWF0ZUZpeHR1cmUoYm90dG9tQ2lyY2xlLCB1c2VyRGF0YSk7XHJcbiAgICAgICAgICAgIHJldHVybiBib2R5O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBDcmVhdGVzIGEgcm91bmRlZCByZWN0YW5nbGUuXHJcbiAgICAgICAgLy8vIE5vdGU6IEF1dG9tYXRpY2FsbHkgZGVjb21wb3NlcyB0aGUgY2Fwc3VsZSBpZiBpdCBjb250YWlucyB0b28gbWFueSB2ZXJ0aWNlcyAoY29udHJvbGxlZCBieSBTZXR0aW5ncy5NYXhQb2x5Z29uVmVydGljZXMpXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJ3b3JsZFwiPlRoZSB3b3JsZC48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cIndpZHRoXCI+VGhlIHdpZHRoLjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwiaGVpZ2h0XCI+VGhlIGhlaWdodC48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cInhSYWRpdXNcIj5UaGUgeCByYWRpdXMuPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJ5UmFkaXVzXCI+VGhlIHkgcmFkaXVzLjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwic2VnbWVudHNcIj5UaGUgc2VnbWVudHMuPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJkZW5zaXR5XCI+VGhlIGRlbnNpdHkuPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJwb3NpdGlvblwiPlRoZSBwb3NpdGlvbi48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cmV0dXJucz48L3JldHVybnM+XHJcbiAgICAgICAgcHVibGljIHN0YXRpYyBCb2R5IENyZWF0ZVJvdW5kZWRSZWN0YW5nbGUoV29ybGQgd29ybGQsIGZsb2F0IHdpZHRoLCBmbG9hdCBoZWlnaHQsIGZsb2F0IHhSYWRpdXMsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmxvYXQgeVJhZGl1cyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnQgc2VnbWVudHMsIGZsb2F0IGRlbnNpdHksIFZlY3RvcjIgcG9zaXRpb24sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb2JqZWN0IHVzZXJEYXRhKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgVmVydGljZXMgdmVydHMgPSBQb2x5Z29uVG9vbHMuQ3JlYXRlUm91bmRlZFJlY3RhbmdsZSh3aWR0aCwgaGVpZ2h0LCB4UmFkaXVzLCB5UmFkaXVzLCBzZWdtZW50cyk7XHJcblxyXG4gICAgICAgICAgICAvL1RoZXJlIGFyZSB0b28gbWFueSB2ZXJ0aWNlcyBpbiB0aGUgY2Fwc3VsZS4gV2UgZGVjb21wb3NlIGl0LlxyXG4gICAgICAgICAgICBpZiAodmVydHMuQ291bnQgPj0gU2V0dGluZ3MuTWF4UG9seWdvblZlcnRpY2VzKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBMaXN0PFZlcnRpY2VzPiB2ZXJ0TGlzdCA9IEVhcmNsaXBEZWNvbXBvc2VyLkNvbnZleFBhcnRpdGlvbih2ZXJ0cyk7XHJcbiAgICAgICAgICAgICAgICBCb2R5IGJvZHkgPSBDcmVhdGVDb21wb3VuZFBvbHlnb24od29ybGQsIHZlcnRMaXN0LCBkZW5zaXR5LCB1c2VyRGF0YSk7XHJcbiAgICAgICAgICAgICAgICBib2R5LlBvc2l0aW9uID0gcG9zaXRpb247XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gYm9keTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuIENyZWF0ZVBvbHlnb24od29ybGQsIHZlcnRzLCBkZW5zaXR5KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHB1YmxpYyBzdGF0aWMgQm9keSBDcmVhdGVSb3VuZGVkUmVjdGFuZ2xlKFdvcmxkIHdvcmxkLCBmbG9hdCB3aWR0aCwgZmxvYXQgaGVpZ2h0LCBmbG9hdCB4UmFkaXVzLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZsb2F0IHlSYWRpdXMsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW50IHNlZ21lbnRzLCBmbG9hdCBkZW5zaXR5LCBWZWN0b3IyIHBvc2l0aW9uKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIENyZWF0ZVJvdW5kZWRSZWN0YW5nbGUod29ybGQsIHdpZHRoLCBoZWlnaHQsIHhSYWRpdXMsIHlSYWRpdXMsIHNlZ21lbnRzLCBkZW5zaXR5LCBwb3NpdGlvbiwgbnVsbCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwdWJsaWMgc3RhdGljIEJvZHkgQ3JlYXRlUm91bmRlZFJlY3RhbmdsZShXb3JsZCB3b3JsZCwgZmxvYXQgd2lkdGgsIGZsb2F0IGhlaWdodCwgZmxvYXQgeFJhZGl1cyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmbG9hdCB5UmFkaXVzLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGludCBzZWdtZW50cywgZmxvYXQgZGVuc2l0eSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiBDcmVhdGVSb3VuZGVkUmVjdGFuZ2xlKHdvcmxkLCB3aWR0aCwgaGVpZ2h0LCB4UmFkaXVzLCB5UmFkaXVzLCBzZWdtZW50cywgZGVuc2l0eSwgbnVsbCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwdWJsaWMgc3RhdGljIEJvZHkgQ3JlYXRlUm91bmRlZFJlY3RhbmdsZShXb3JsZCB3b3JsZCwgZmxvYXQgd2lkdGgsIGZsb2F0IGhlaWdodCwgZmxvYXQgeFJhZGl1cyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmbG9hdCB5UmFkaXVzLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGludCBzZWdtZW50cywgZmxvYXQgZGVuc2l0eSwgb2JqZWN0IHVzZXJEYXRhKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIENyZWF0ZVJvdW5kZWRSZWN0YW5nbGUod29ybGQsIHdpZHRoLCBoZWlnaHQsIHhSYWRpdXMsIHlSYWRpdXMsIHNlZ21lbnRzLCBkZW5zaXR5LCBWZWN0b3IyLlplcm8sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVzZXJEYXRhKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHB1YmxpYyBzdGF0aWMgQnJlYWthYmxlQm9keSBDcmVhdGVCcmVha2FibGVCb2R5KFdvcmxkIHdvcmxkLCBWZXJ0aWNlcyB2ZXJ0aWNlcywgZmxvYXQgZGVuc2l0eSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiBDcmVhdGVCcmVha2FibGVCb2R5KHdvcmxkLCB2ZXJ0aWNlcywgZGVuc2l0eSwgbnVsbCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwdWJsaWMgc3RhdGljIEJyZWFrYWJsZUJvZHkgQ3JlYXRlQnJlYWthYmxlQm9keShXb3JsZCB3b3JsZCwgVmVydGljZXMgdmVydGljZXMsIGZsb2F0IGRlbnNpdHksIG9iamVjdCB1c2VyRGF0YSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiBDcmVhdGVCcmVha2FibGVCb2R5KHdvcmxkLCB2ZXJ0aWNlcywgZGVuc2l0eSwgVmVjdG9yMi5aZXJvLCB1c2VyRGF0YSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIENyZWF0ZXMgYSBicmVha2FibGUgYm9keS4gWW91IHdvdWxkIHdhbnQgdG8gcmVtb3ZlIGNvbGxpbmVhciBwb2ludHMgYmVmb3JlIHVzaW5nIHRoaXMuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJ3b3JsZFwiPlRoZSB3b3JsZC48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cInZlcnRpY2VzXCI+VGhlIHZlcnRpY2VzLjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwiZGVuc2l0eVwiPlRoZSBkZW5zaXR5LjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwicG9zaXRpb25cIj5UaGUgcG9zaXRpb24uPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHJldHVybnM+PC9yZXR1cm5zPlxyXG4gICAgICAgIHB1YmxpYyBzdGF0aWMgQnJlYWthYmxlQm9keSBDcmVhdGVCcmVha2FibGVCb2R5KFdvcmxkIHdvcmxkLCBWZXJ0aWNlcyB2ZXJ0aWNlcywgZmxvYXQgZGVuc2l0eSwgVmVjdG9yMiBwb3NpdGlvbixcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvYmplY3QgdXNlckRhdGEpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBMaXN0PFZlcnRpY2VzPiB0cmlhbmdsZXMgPSBFYXJjbGlwRGVjb21wb3Nlci5Db252ZXhQYXJ0aXRpb24odmVydGljZXMpO1xyXG5cclxuICAgICAgICAgICAgQnJlYWthYmxlQm9keSBicmVha2FibGVCb2R5ID0gbmV3IEJyZWFrYWJsZUJvZHkodHJpYW5nbGVzLCB3b3JsZCwgZGVuc2l0eSwgdXNlckRhdGEpO1xyXG4gICAgICAgICAgICBicmVha2FibGVCb2R5Lk1haW5Cb2R5LlBvc2l0aW9uID0gcG9zaXRpb247XHJcbiAgICAgICAgICAgIHdvcmxkLkFkZEJyZWFrYWJsZUJvZHkoYnJlYWthYmxlQm9keSk7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gYnJlYWthYmxlQm9keTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHB1YmxpYyBzdGF0aWMgQnJlYWthYmxlQm9keSBDcmVhdGVCcmVha2FibGVCb2R5KFdvcmxkIHdvcmxkLCBWZXJ0aWNlcyB2ZXJ0aWNlcywgZmxvYXQgZGVuc2l0eSwgVmVjdG9yMiBwb3NpdGlvbilcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiBDcmVhdGVCcmVha2FibGVCb2R5KHdvcmxkLCB2ZXJ0aWNlcywgZGVuc2l0eSwgcG9zaXRpb24sIG51bGwpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHVibGljIHN0YXRpYyBCb2R5IENyZWF0ZUxpbmVBcmMoV29ybGQgd29ybGQsIGZsb2F0IHJhZGlhbnMsIGludCBzaWRlcywgZmxvYXQgcmFkaXVzLCBWZWN0b3IyIHBvc2l0aW9uLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZsb2F0IGFuZ2xlLCBib29sIGNsb3NlZClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIEJvZHkgYm9keSA9IENyZWF0ZUJvZHkod29ybGQpO1xyXG4gICAgICAgICAgICBGaXh0dXJlRmFjdG9yeS5BdHRhY2hMaW5lQXJjKHJhZGlhbnMsIHNpZGVzLCByYWRpdXMsIHBvc2l0aW9uLCBhbmdsZSwgY2xvc2VkLCBib2R5KTtcclxuICAgICAgICAgICAgcmV0dXJuIGJvZHk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwdWJsaWMgc3RhdGljIEJvZHkgQ3JlYXRlU29saWRBcmMoV29ybGQgd29ybGQsIGZsb2F0IGRlbnNpdHksIGZsb2F0IHJhZGlhbnMsIGludCBzaWRlcywgZmxvYXQgcmFkaXVzLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBWZWN0b3IyIHBvc2l0aW9uLCBmbG9hdCBhbmdsZSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIEJvZHkgYm9keSA9IENyZWF0ZUJvZHkod29ybGQpO1xyXG4gICAgICAgICAgICBGaXh0dXJlRmFjdG9yeS5BdHRhY2hTb2xpZEFyYyhkZW5zaXR5LCByYWRpYW5zLCBzaWRlcywgcmFkaXVzLCBwb3NpdGlvbiwgYW5nbGUsIGJvZHkpO1xyXG4gICAgICAgICAgICByZXR1cm4gYm9keTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn0iLCJ1c2luZyBTeXN0ZW07XHJcbnVzaW5nIFN5c3RlbS5Db2xsZWN0aW9ucy5HZW5lcmljO1xyXG51c2luZyBGYXJzZWVyUGh5c2ljcy5Db2xsaXNpb24uU2hhcGVzO1xyXG51c2luZyBGYXJzZWVyUGh5c2ljcy5Db21tb247XHJcbnVzaW5nIEZhcnNlZXJQaHlzaWNzLkNvbW1vbi5EZWNvbXBvc2l0aW9uO1xyXG51c2luZyBGYXJzZWVyUGh5c2ljcy5EeW5hbWljcztcclxudXNpbmcgTWljcm9zb2Z0LlhuYS5GcmFtZXdvcms7XHJcblxyXG5uYW1lc3BhY2UgRmFyc2VlclBoeXNpY3MuRmFjdG9yaWVzXHJcbntcclxuICAgIC8vLyA8c3VtbWFyeT5cclxuICAgIC8vLyBBbiBlYXN5IHRvIHVzZSBmYWN0b3J5IGZvciBjcmVhdGluZyBib2RpZXNcclxuICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICBwdWJsaWMgc3RhdGljIGNsYXNzIEZpeHR1cmVGYWN0b3J5XHJcbiAgICB7XHJcbiAgICAgICAgcHVibGljIHN0YXRpYyBGaXh0dXJlIEF0dGFjaEVkZ2UoVmVjdG9yMiBzdGFydCwgVmVjdG9yMiBlbmQsIEJvZHkgYm9keSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiBBdHRhY2hFZGdlKHN0YXJ0LCBlbmQsIGJvZHksIG51bGwpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHVibGljIHN0YXRpYyBGaXh0dXJlIEF0dGFjaEVkZ2UoVmVjdG9yMiBzdGFydCwgVmVjdG9yMiBlbmQsIEJvZHkgYm9keSwgb2JqZWN0IHVzZXJEYXRhKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgRWRnZVNoYXBlIGVkZ2VTaGFwZSA9IG5ldyBFZGdlU2hhcGUoc3RhcnQsIGVuZCk7XHJcbiAgICAgICAgICAgIHJldHVybiBib2R5LkNyZWF0ZUZpeHR1cmUoZWRnZVNoYXBlLCB1c2VyRGF0YSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwdWJsaWMgc3RhdGljIEZpeHR1cmUgQXR0YWNoTG9vcFNoYXBlKFZlcnRpY2VzIHZlcnRpY2VzLCBCb2R5IGJvZHkpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gQXR0YWNoTG9vcFNoYXBlKHZlcnRpY2VzLCBib2R5LCBudWxsKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHB1YmxpYyBzdGF0aWMgRml4dHVyZSBBdHRhY2hMb29wU2hhcGUoVmVydGljZXMgdmVydGljZXMsIEJvZHkgYm9keSwgb2JqZWN0IHVzZXJEYXRhKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgTG9vcFNoYXBlIHNoYXBlID0gbmV3IExvb3BTaGFwZSh2ZXJ0aWNlcyk7XHJcbiAgICAgICAgICAgIHJldHVybiBib2R5LkNyZWF0ZUZpeHR1cmUoc2hhcGUsIHVzZXJEYXRhKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHB1YmxpYyBzdGF0aWMgRml4dHVyZSBBdHRhY2hSZWN0YW5nbGUoZmxvYXQgd2lkdGgsIGZsb2F0IGhlaWdodCwgZmxvYXQgZGVuc2l0eSwgVmVjdG9yMiBvZmZzZXQsIEJvZHkgYm9keSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9iamVjdCB1c2VyRGF0YSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIFZlcnRpY2VzIHJlY3RhbmdsZVZlcnRpY2VzID0gUG9seWdvblRvb2xzLkNyZWF0ZVJlY3RhbmdsZSh3aWR0aCAvIDIsIGhlaWdodCAvIDIpO1xyXG4gICAgICAgICAgICByZWN0YW5nbGVWZXJ0aWNlcy5UcmFuc2xhdGUocmVmIG9mZnNldCk7XHJcbiAgICAgICAgICAgIFBvbHlnb25TaGFwZSByZWN0YW5nbGVTaGFwZSA9IG5ldyBQb2x5Z29uU2hhcGUocmVjdGFuZ2xlVmVydGljZXMsIGRlbnNpdHkpO1xyXG4gICAgICAgICAgICByZXR1cm4gYm9keS5DcmVhdGVGaXh0dXJlKHJlY3RhbmdsZVNoYXBlLCB1c2VyRGF0YSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwdWJsaWMgc3RhdGljIEZpeHR1cmUgQXR0YWNoUmVjdGFuZ2xlKGZsb2F0IHdpZHRoLCBmbG9hdCBoZWlnaHQsIGZsb2F0IGRlbnNpdHksIFZlY3RvcjIgb2Zmc2V0LCBCb2R5IGJvZHkpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gQXR0YWNoUmVjdGFuZ2xlKHdpZHRoLCBoZWlnaHQsIGRlbnNpdHksIG9mZnNldCwgYm9keSwgbnVsbCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwdWJsaWMgc3RhdGljIEZpeHR1cmUgQXR0YWNoQ2lyY2xlKGZsb2F0IHJhZGl1cywgZmxvYXQgZGVuc2l0eSwgQm9keSBib2R5KVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIEF0dGFjaENpcmNsZShyYWRpdXMsIGRlbnNpdHksIGJvZHksIG51bGwpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHVibGljIHN0YXRpYyBGaXh0dXJlIEF0dGFjaENpcmNsZShmbG9hdCByYWRpdXMsIGZsb2F0IGRlbnNpdHksIEJvZHkgYm9keSwgb2JqZWN0IHVzZXJEYXRhKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgaWYgKHJhZGl1cyA8PSAwKVxyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEFyZ3VtZW50T3V0T2ZSYW5nZUV4Y2VwdGlvbihcInJhZGl1c1wiLCBcIlJhZGl1cyBtdXN0IGJlIG1vcmUgdGhhbiAwIG1ldGVyc1wiKTtcclxuXHJcbiAgICAgICAgICAgIENpcmNsZVNoYXBlIGNpcmNsZVNoYXBlID0gbmV3IENpcmNsZVNoYXBlKHJhZGl1cywgZGVuc2l0eSk7XHJcbiAgICAgICAgICAgIHJldHVybiBib2R5LkNyZWF0ZUZpeHR1cmUoY2lyY2xlU2hhcGUsIHVzZXJEYXRhKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHB1YmxpYyBzdGF0aWMgRml4dHVyZSBBdHRhY2hDaXJjbGUoZmxvYXQgcmFkaXVzLCBmbG9hdCBkZW5zaXR5LCBCb2R5IGJvZHksIFZlY3RvcjIgb2Zmc2V0KVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIEF0dGFjaENpcmNsZShyYWRpdXMsIGRlbnNpdHksIGJvZHksIG9mZnNldCwgbnVsbCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwdWJsaWMgc3RhdGljIEZpeHR1cmUgQXR0YWNoQ2lyY2xlKGZsb2F0IHJhZGl1cywgZmxvYXQgZGVuc2l0eSwgQm9keSBib2R5LCBWZWN0b3IyIG9mZnNldCwgb2JqZWN0IHVzZXJEYXRhKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgaWYgKHJhZGl1cyA8PSAwKVxyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEFyZ3VtZW50T3V0T2ZSYW5nZUV4Y2VwdGlvbihcInJhZGl1c1wiLCBcIlJhZGl1cyBtdXN0IGJlIG1vcmUgdGhhbiAwIG1ldGVyc1wiKTtcclxuXHJcbiAgICAgICAgICAgIENpcmNsZVNoYXBlIGNpcmNsZVNoYXBlID0gbmV3IENpcmNsZVNoYXBlKHJhZGl1cywgZGVuc2l0eSk7XHJcbiAgICAgICAgICAgIGNpcmNsZVNoYXBlLlBvc2l0aW9uID0gb2Zmc2V0O1xyXG4gICAgICAgICAgICByZXR1cm4gYm9keS5DcmVhdGVGaXh0dXJlKGNpcmNsZVNoYXBlLCB1c2VyRGF0YSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwdWJsaWMgc3RhdGljIEZpeHR1cmUgQXR0YWNoUG9seWdvbihWZXJ0aWNlcyB2ZXJ0aWNlcywgZmxvYXQgZGVuc2l0eSwgQm9keSBib2R5KVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIEF0dGFjaFBvbHlnb24odmVydGljZXMsIGRlbnNpdHksIGJvZHksIG51bGwpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHVibGljIHN0YXRpYyBGaXh0dXJlIEF0dGFjaFBvbHlnb24oVmVydGljZXMgdmVydGljZXMsIGZsb2F0IGRlbnNpdHksIEJvZHkgYm9keSwgb2JqZWN0IHVzZXJEYXRhKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgaWYgKHZlcnRpY2VzLkNvdW50IDw9IDEpXHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQXJndW1lbnRPdXRPZlJhbmdlRXhjZXB0aW9uKFwidmVydGljZXNcIiwgXCJUb28gZmV3IHBvaW50cyB0byBiZSBhIHBvbHlnb25cIik7XHJcblxyXG4gICAgICAgICAgICBQb2x5Z29uU2hhcGUgcG9seWdvbiA9IG5ldyBQb2x5Z29uU2hhcGUodmVydGljZXMsIGRlbnNpdHkpO1xyXG4gICAgICAgICAgICByZXR1cm4gYm9keS5DcmVhdGVGaXh0dXJlKHBvbHlnb24sIHVzZXJEYXRhKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHB1YmxpYyBzdGF0aWMgRml4dHVyZSBBdHRhY2hFbGxpcHNlKGZsb2F0IHhSYWRpdXMsIGZsb2F0IHlSYWRpdXMsIGludCBlZGdlcywgZmxvYXQgZGVuc2l0eSwgQm9keSBib2R5KVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIEF0dGFjaEVsbGlwc2UoeFJhZGl1cywgeVJhZGl1cywgZWRnZXMsIGRlbnNpdHksIGJvZHksIG51bGwpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHVibGljIHN0YXRpYyBGaXh0dXJlIEF0dGFjaEVsbGlwc2UoZmxvYXQgeFJhZGl1cywgZmxvYXQgeVJhZGl1cywgaW50IGVkZ2VzLCBmbG9hdCBkZW5zaXR5LCBCb2R5IGJvZHksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb2JqZWN0IHVzZXJEYXRhKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgaWYgKHhSYWRpdXMgPD0gMClcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBBcmd1bWVudE91dE9mUmFuZ2VFeGNlcHRpb24oXCJ4UmFkaXVzXCIsIFwiWC1yYWRpdXMgbXVzdCBiZSBtb3JlIHRoYW4gMFwiKTtcclxuXHJcbiAgICAgICAgICAgIGlmICh5UmFkaXVzIDw9IDApXHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQXJndW1lbnRPdXRPZlJhbmdlRXhjZXB0aW9uKFwieVJhZGl1c1wiLCBcIlktcmFkaXVzIG11c3QgYmUgbW9yZSB0aGFuIDBcIik7XHJcblxyXG4gICAgICAgICAgICBWZXJ0aWNlcyBlbGxpcHNlVmVydGljZXMgPSBQb2x5Z29uVG9vbHMuQ3JlYXRlRWxsaXBzZSh4UmFkaXVzLCB5UmFkaXVzLCBlZGdlcyk7XHJcbiAgICAgICAgICAgIFBvbHlnb25TaGFwZSBwb2x5Z29uU2hhcGUgPSBuZXcgUG9seWdvblNoYXBlKGVsbGlwc2VWZXJ0aWNlcywgZGVuc2l0eSk7XHJcbiAgICAgICAgICAgIHJldHVybiBib2R5LkNyZWF0ZUZpeHR1cmUocG9seWdvblNoYXBlLCB1c2VyRGF0YSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwdWJsaWMgc3RhdGljIExpc3Q8Rml4dHVyZT4gQXR0YWNoQ29tcG91bmRQb2x5Z29uKExpc3Q8VmVydGljZXM+IGxpc3QsIGZsb2F0IGRlbnNpdHksIEJvZHkgYm9keSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiBBdHRhY2hDb21wb3VuZFBvbHlnb24obGlzdCwgZGVuc2l0eSwgYm9keSwgbnVsbCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwdWJsaWMgc3RhdGljIExpc3Q8Rml4dHVyZT4gQXR0YWNoQ29tcG91bmRQb2x5Z29uKExpc3Q8VmVydGljZXM+IGxpc3QsIGZsb2F0IGRlbnNpdHksIEJvZHkgYm9keSwgb2JqZWN0IHVzZXJEYXRhKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgTGlzdDxGaXh0dXJlPiByZXMgPSBuZXcgTGlzdDxGaXh0dXJlPihsaXN0LkNvdW50KTtcclxuXHJcbiAgICAgICAgICAgIC8vVGhlbiB3ZSBjcmVhdGUgc2V2ZXJhbCBmaXh0dXJlcyB1c2luZyB0aGUgYm9keVxyXG4gICAgICAgICAgICBmb3JlYWNoIChWZXJ0aWNlcyB2ZXJ0aWNlcyBpbiBsaXN0KVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBpZiAodmVydGljZXMuQ291bnQgPT0gMilcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBFZGdlU2hhcGUgc2hhcGUgPSBuZXcgRWRnZVNoYXBlKHZlcnRpY2VzWzBdLCB2ZXJ0aWNlc1sxXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzLkFkZChib2R5LkNyZWF0ZUZpeHR1cmUoc2hhcGUsIHVzZXJEYXRhKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgUG9seWdvblNoYXBlIHNoYXBlID0gbmV3IFBvbHlnb25TaGFwZSh2ZXJ0aWNlcywgZGVuc2l0eSk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzLkFkZChib2R5LkNyZWF0ZUZpeHR1cmUoc2hhcGUsIHVzZXJEYXRhKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHJldHVybiByZXM7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwdWJsaWMgc3RhdGljIExpc3Q8Rml4dHVyZT4gQXR0YWNoTGluZUFyYyhmbG9hdCByYWRpYW5zLCBpbnQgc2lkZXMsIGZsb2F0IHJhZGl1cywgVmVjdG9yMiBwb3NpdGlvbiwgZmxvYXQgYW5nbGUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYm9vbCBjbG9zZWQsIEJvZHkgYm9keSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIFZlcnRpY2VzIGFyYyA9IFBvbHlnb25Ub29scy5DcmVhdGVBcmMocmFkaWFucywgc2lkZXMsIHJhZGl1cyk7XHJcbiAgICAgICAgICAgIGFyYy5Sb3RhdGUoKE1hdGhIZWxwZXIuUGkgLSByYWRpYW5zKSAvIDIgKyBhbmdsZSk7XHJcbiAgICAgICAgICAgIGFyYy5UcmFuc2xhdGUocmVmIHBvc2l0aW9uKTtcclxuXHJcbiAgICAgICAgICAgIExpc3Q8Rml4dHVyZT4gZml4dHVyZXMgPSBuZXcgTGlzdDxGaXh0dXJlPihhcmMuQ291bnQpO1xyXG5cclxuICAgICAgICAgICAgaWYgKGNsb3NlZClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgZml4dHVyZXMuQWRkKEF0dGFjaExvb3BTaGFwZShhcmMsIGJvZHkpKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgZm9yIChpbnQgaSA9IDE7IGkgPCBhcmMuQ291bnQ7IGkrKylcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgZml4dHVyZXMuQWRkKEF0dGFjaEVkZ2UoYXJjW2ldLCBhcmNbaSAtIDFdLCBib2R5KSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHJldHVybiBmaXh0dXJlcztcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHB1YmxpYyBzdGF0aWMgTGlzdDxGaXh0dXJlPiBBdHRhY2hTb2xpZEFyYyhmbG9hdCBkZW5zaXR5LCBmbG9hdCByYWRpYW5zLCBpbnQgc2lkZXMsIGZsb2F0IHJhZGl1cyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgVmVjdG9yMiBwb3NpdGlvbiwgZmxvYXQgYW5nbGUsIEJvZHkgYm9keSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIFZlcnRpY2VzIGFyYyA9IFBvbHlnb25Ub29scy5DcmVhdGVBcmMocmFkaWFucywgc2lkZXMsIHJhZGl1cyk7XHJcbiAgICAgICAgICAgIGFyYy5Sb3RhdGUoKE1hdGhIZWxwZXIuUGkgLSByYWRpYW5zKSAvIDIgKyBhbmdsZSk7XHJcblxyXG4gICAgICAgICAgICBhcmMuVHJhbnNsYXRlKHJlZiBwb3NpdGlvbik7XHJcblxyXG4gICAgICAgICAgICAvL0Nsb3NlIHRoZSBhcmNcclxuICAgICAgICAgICAgYXJjLkFkZChhcmNbMF0pO1xyXG5cclxuICAgICAgICAgICAgTGlzdDxWZXJ0aWNlcz4gdHJpYW5nbGVzID0gRWFyY2xpcERlY29tcG9zZXIuQ29udmV4UGFydGl0aW9uKGFyYyk7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gQXR0YWNoQ29tcG91bmRQb2x5Z29uKHRyaWFuZ2xlcywgZGVuc2l0eSwgYm9keSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59IiwidXNpbmcgRmFyc2VlclBoeXNpY3MuRHluYW1pY3M7XHJcbnVzaW5nIEZhcnNlZXJQaHlzaWNzLkR5bmFtaWNzLkpvaW50cztcclxudXNpbmcgTWljcm9zb2Z0LlhuYS5GcmFtZXdvcms7XHJcblxyXG5uYW1lc3BhY2UgRmFyc2VlclBoeXNpY3MuRmFjdG9yaWVzXHJcbntcclxuICAgIC8vLyA8c3VtbWFyeT5cclxuICAgIC8vLyBBbiBlYXN5IHRvIHVzZSBmYWN0b3J5IGZvciB1c2luZyBqb2ludHMuXHJcbiAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgcHVibGljIHN0YXRpYyBjbGFzcyBKb2ludEZhY3RvcnlcclxuICAgIHtcclxuICAgICAgICAjcmVnaW9uIFJldm9sdXRlIEpvaW50XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gQ3JlYXRlcyBhIHJldm9sdXRlIGpvaW50LlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwiYm9keUFcIj48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cImJvZHlCXCI+PC9wYXJhbT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJsb2NhbEFuY2hvckJcIj5UaGUgYW5jaG9yIG9mIGJvZHlCIGluIGxvY2FsIGNvb3JkaW5hdGVzPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHJldHVybnM+PC9yZXR1cm5zPlxyXG4gICAgICAgIHB1YmxpYyBzdGF0aWMgUmV2b2x1dGVKb2ludCBDcmVhdGVSZXZvbHV0ZUpvaW50KEJvZHkgYm9keUEsIEJvZHkgYm9keUIsIFZlY3RvcjIgbG9jYWxBbmNob3JCKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgVmVjdG9yMiBsb2NhbGFuY2hvckEgPSBib2R5QS5HZXRMb2NhbFBvaW50KGJvZHlCLkdldFdvcmxkUG9pbnQobG9jYWxBbmNob3JCKSk7XHJcbiAgICAgICAgICAgIFJldm9sdXRlSm9pbnQgam9pbnQgPSBuZXcgUmV2b2x1dGVKb2ludChib2R5QSwgYm9keUIsIGxvY2FsYW5jaG9yQSwgbG9jYWxBbmNob3JCKTtcclxuICAgICAgICAgICAgcmV0dXJuIGpvaW50O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBDcmVhdGVzIGEgcmV2b2x1dGUgam9pbnQgYW5kIGFkZHMgaXQgdG8gdGhlIHdvcmxkXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJ3b3JsZFwiPjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwiYm9keUFcIj48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cImJvZHlCXCI+PC9wYXJhbT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJhbmNob3JcIj48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cmV0dXJucz48L3JldHVybnM+XHJcbiAgICAgICAgcHVibGljIHN0YXRpYyBSZXZvbHV0ZUpvaW50IENyZWF0ZVJldm9sdXRlSm9pbnQoV29ybGQgd29ybGQsIEJvZHkgYm9keUEsIEJvZHkgYm9keUIsIFZlY3RvcjIgYW5jaG9yKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgUmV2b2x1dGVKb2ludCBqb2ludCA9IENyZWF0ZVJldm9sdXRlSm9pbnQoYm9keUEsIGJvZHlCLCBhbmNob3IpO1xyXG4gICAgICAgICAgICB3b3JsZC5BZGRKb2ludChqb2ludCk7XHJcbiAgICAgICAgICAgIHJldHVybiBqb2ludDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gQ3JlYXRlcyB0aGUgZml4ZWQgcmV2b2x1dGUgam9pbnQuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJ3b3JsZFwiPlRoZSB3b3JsZC48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cImJvZHlcIj5UaGUgYm9keS48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cImJvZHlBbmNob3JcIj5UaGUgYm9keSBhbmNob3IuPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJ3b3JsZEFuY2hvclwiPlRoZSB3b3JsZCBhbmNob3IuPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHJldHVybnM+PC9yZXR1cm5zPlxyXG4gICAgICAgIHB1YmxpYyBzdGF0aWMgRml4ZWRSZXZvbHV0ZUpvaW50IENyZWF0ZUZpeGVkUmV2b2x1dGVKb2ludChXb3JsZCB3b3JsZCwgQm9keSBib2R5LCBWZWN0b3IyIGJvZHlBbmNob3IsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFZlY3RvcjIgd29ybGRBbmNob3IpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBGaXhlZFJldm9sdXRlSm9pbnQgZml4ZWRSZXZvbHV0ZUpvaW50ID0gbmV3IEZpeGVkUmV2b2x1dGVKb2ludChib2R5LCBib2R5QW5jaG9yLCB3b3JsZEFuY2hvcik7XHJcbiAgICAgICAgICAgIHdvcmxkLkFkZEpvaW50KGZpeGVkUmV2b2x1dGVKb2ludCk7XHJcbiAgICAgICAgICAgIHJldHVybiBmaXhlZFJldm9sdXRlSm9pbnQ7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAjZW5kcmVnaW9uXHJcblxyXG4gICAgICAgICNyZWdpb24gV2VsZCBKb2ludFxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIENyZWF0ZXMgYSB3ZWxkIGpvaW50XHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJib2R5QVwiPjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwiYm9keUJcIj48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cImxvY2FsQW5jaG9yXCI+PC9wYXJhbT5cclxuICAgICAgICAvLy8gPHJldHVybnM+PC9yZXR1cm5zPlxyXG4gICAgICAgIHB1YmxpYyBzdGF0aWMgV2VsZEpvaW50IENyZWF0ZVdlbGRKb2ludChCb2R5IGJvZHlBLCBCb2R5IGJvZHlCLCBWZWN0b3IyIGxvY2FsQW5jaG9yKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgV2VsZEpvaW50IGpvaW50ID0gbmV3IFdlbGRKb2ludChib2R5QSwgYm9keUIsIGJvZHlBLkdldExvY2FsUG9pbnQobG9jYWxBbmNob3IpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJvZHlCLkdldExvY2FsUG9pbnQobG9jYWxBbmNob3IpKTtcclxuICAgICAgICAgICAgcmV0dXJuIGpvaW50O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBDcmVhdGVzIGEgd2VsZCBqb2ludCBhbmQgYWRkcyBpdCB0byB0aGUgd29ybGRcclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cIndvcmxkXCI+PC9wYXJhbT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJib2R5QVwiPjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwiYm9keUJcIj48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cImxvY2FsYW5jaG9yQlwiPjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxyZXR1cm5zPjwvcmV0dXJucz5cclxuICAgICAgICBwdWJsaWMgc3RhdGljIFdlbGRKb2ludCBDcmVhdGVXZWxkSm9pbnQoV29ybGQgd29ybGQsIEJvZHkgYm9keUEsIEJvZHkgYm9keUIsIFZlY3RvcjIgbG9jYWxhbmNob3JCKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgV2VsZEpvaW50IGpvaW50ID0gQ3JlYXRlV2VsZEpvaW50KGJvZHlBLCBib2R5QiwgbG9jYWxhbmNob3JCKTtcclxuICAgICAgICAgICAgd29ybGQuQWRkSm9pbnQoam9pbnQpO1xyXG4gICAgICAgICAgICByZXR1cm4gam9pbnQ7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwdWJsaWMgc3RhdGljIFdlbGRKb2ludCBDcmVhdGVXZWxkSm9pbnQoV29ybGQgd29ybGQsIEJvZHkgYm9keUEsIEJvZHkgYm9keUIsIFZlY3RvcjIgbG9jYWxBbmNob3JBLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBWZWN0b3IyIGxvY2FsQW5jaG9yQilcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIFdlbGRKb2ludCB3ZWxkSm9pbnQgPSBuZXcgV2VsZEpvaW50KGJvZHlBLCBib2R5QiwgbG9jYWxBbmNob3JBLCBsb2NhbEFuY2hvckIpO1xyXG4gICAgICAgICAgICB3b3JsZC5BZGRKb2ludCh3ZWxkSm9pbnQpO1xyXG4gICAgICAgICAgICByZXR1cm4gd2VsZEpvaW50O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgI2VuZHJlZ2lvblxyXG5cclxuICAgICAgICAjcmVnaW9uIFByaXNtYXRpYyBKb2ludFxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIENyZWF0ZXMgYSBwcnNpbWF0aWMgam9pbnRcclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cImJvZHlBXCI+PC9wYXJhbT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJib2R5QlwiPjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwibG9jYWxhbmNob3JCXCI+PC9wYXJhbT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJheGlzXCI+PC9wYXJhbT5cclxuICAgICAgICAvLy8gPHJldHVybnM+PC9yZXR1cm5zPlxyXG4gICAgICAgIHB1YmxpYyBzdGF0aWMgUHJpc21hdGljSm9pbnQgQ3JlYXRlUHJpc21hdGljSm9pbnQoQm9keSBib2R5QSwgQm9keSBib2R5QiwgVmVjdG9yMiBsb2NhbGFuY2hvckIsIFZlY3RvcjIgYXhpcylcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIFZlY3RvcjIgbG9jYWxhbmNob3JBID0gYm9keUEuR2V0TG9jYWxQb2ludChib2R5Qi5HZXRXb3JsZFBvaW50KGxvY2FsYW5jaG9yQikpO1xyXG4gICAgICAgICAgICBQcmlzbWF0aWNKb2ludCBqb2ludCA9IG5ldyBQcmlzbWF0aWNKb2ludChib2R5QSwgYm9keUIsIGxvY2FsYW5jaG9yQSwgbG9jYWxhbmNob3JCLCBheGlzKTtcclxuICAgICAgICAgICAgcmV0dXJuIGpvaW50O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBDcmVhdGVzIGEgcHJpc21hdGljIGpvaW50IGFuZCBhZGRzIGl0IHRvIHRoZSB3b3JsZFxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwid29ybGRcIj48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cImJvZHlBXCI+PC9wYXJhbT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJib2R5QlwiPjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwibG9jYWxhbmNob3JCXCI+PC9wYXJhbT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJheGlzXCI+PC9wYXJhbT5cclxuICAgICAgICAvLy8gPHJldHVybnM+PC9yZXR1cm5zPlxyXG4gICAgICAgIHB1YmxpYyBzdGF0aWMgUHJpc21hdGljSm9pbnQgQ3JlYXRlUHJpc21hdGljSm9pbnQoV29ybGQgd29ybGQsIEJvZHkgYm9keUEsIEJvZHkgYm9keUIsIFZlY3RvcjIgbG9jYWxhbmNob3JCLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgVmVjdG9yMiBheGlzKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgUHJpc21hdGljSm9pbnQgam9pbnQgPSBDcmVhdGVQcmlzbWF0aWNKb2ludChib2R5QSwgYm9keUIsIGxvY2FsYW5jaG9yQiwgYXhpcyk7XHJcbiAgICAgICAgICAgIHdvcmxkLkFkZEpvaW50KGpvaW50KTtcclxuICAgICAgICAgICAgcmV0dXJuIGpvaW50O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHVibGljIHN0YXRpYyBGaXhlZFByaXNtYXRpY0pvaW50IENyZWF0ZUZpeGVkUHJpc21hdGljSm9pbnQoV29ybGQgd29ybGQsIEJvZHkgYm9keSwgVmVjdG9yMiB3b3JsZEFuY2hvcixcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBWZWN0b3IyIGF4aXMpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBGaXhlZFByaXNtYXRpY0pvaW50IGpvaW50ID0gbmV3IEZpeGVkUHJpc21hdGljSm9pbnQoYm9keSwgd29ybGRBbmNob3IsIGF4aXMpO1xyXG4gICAgICAgICAgICB3b3JsZC5BZGRKb2ludChqb2ludCk7XHJcbiAgICAgICAgICAgIHJldHVybiBqb2ludDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgICNlbmRyZWdpb25cclxuXHJcbiAgICAgICAgI3JlZ2lvbiBMaW5lIEpvaW50XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gQ3JlYXRlcyBhIGxpbmUgam9pbnRcclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cImJvZHlBXCI+PC9wYXJhbT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJib2R5QlwiPjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwiYW5jaG9yXCI+PC9wYXJhbT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJheGlzXCI+PC9wYXJhbT5cclxuICAgICAgICAvLy8gPHJldHVybnM+PC9yZXR1cm5zPlxyXG4gICAgICAgIHB1YmxpYyBzdGF0aWMgTGluZUpvaW50IENyZWF0ZUxpbmVKb2ludChCb2R5IGJvZHlBLCBCb2R5IGJvZHlCLCBWZWN0b3IyIGFuY2hvciwgVmVjdG9yMiBheGlzKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgTGluZUpvaW50IGpvaW50ID0gbmV3IExpbmVKb2ludChib2R5QSwgYm9keUIsIGFuY2hvciwgYXhpcyk7XHJcbiAgICAgICAgICAgIHJldHVybiBqb2ludDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gQ3JlYXRlcyBhIGxpbmUgam9pbnQgYW5kIGFkZHMgaXQgdG8gdGhlIHdvcmxkXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJ3b3JsZFwiPjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwiYm9keUFcIj48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cImJvZHlCXCI+PC9wYXJhbT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJsb2NhbGFuY2hvckJcIj48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cImF4aXNcIj48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cmV0dXJucz48L3JldHVybnM+XHJcbiAgICAgICAgcHVibGljIHN0YXRpYyBMaW5lSm9pbnQgQ3JlYXRlTGluZUpvaW50KFdvcmxkIHdvcmxkLCBCb2R5IGJvZHlBLCBCb2R5IGJvZHlCLCBWZWN0b3IyIGxvY2FsYW5jaG9yQiwgVmVjdG9yMiBheGlzKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgTGluZUpvaW50IGpvaW50ID0gQ3JlYXRlTGluZUpvaW50KGJvZHlBLCBib2R5QiwgbG9jYWxhbmNob3JCLCBheGlzKTtcclxuICAgICAgICAgICAgd29ybGQuQWRkSm9pbnQoam9pbnQpO1xyXG4gICAgICAgICAgICByZXR1cm4gam9pbnQ7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAjZW5kcmVnaW9uXHJcblxyXG4gICAgICAgICNyZWdpb24gQW5nbGUgSm9pbnRcclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBDcmVhdGVzIGFuIGFuZ2xlIGpvaW50LlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwid29ybGRcIj5UaGUgd29ybGQuPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJib2R5QVwiPlRoZSBmaXJzdCBib2R5LjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwiYm9keUJcIj5UaGUgc2Vjb25kIGJvZHkuPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHJldHVybnM+PC9yZXR1cm5zPlxyXG4gICAgICAgIHB1YmxpYyBzdGF0aWMgQW5nbGVKb2ludCBDcmVhdGVBbmdsZUpvaW50KFdvcmxkIHdvcmxkLCBCb2R5IGJvZHlBLCBCb2R5IGJvZHlCKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgQW5nbGVKb2ludCBhbmdsZUpvaW50ID0gbmV3IEFuZ2xlSm9pbnQoYm9keUEsIGJvZHlCKTtcclxuICAgICAgICAgICAgd29ybGQuQWRkSm9pbnQoYW5nbGVKb2ludCk7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gYW5nbGVKb2ludDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gQ3JlYXRlcyBhIGZpeGVkIGFuZ2xlIGpvaW50LlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwid29ybGRcIj5UaGUgd29ybGQuPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJib2R5XCI+VGhlIGJvZHkuPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHJldHVybnM+PC9yZXR1cm5zPlxyXG4gICAgICAgIHB1YmxpYyBzdGF0aWMgRml4ZWRBbmdsZUpvaW50IENyZWF0ZUZpeGVkQW5nbGVKb2ludChXb3JsZCB3b3JsZCwgQm9keSBib2R5KVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgRml4ZWRBbmdsZUpvaW50IGFuZ2xlSm9pbnQgPSBuZXcgRml4ZWRBbmdsZUpvaW50KGJvZHkpO1xyXG4gICAgICAgICAgICB3b3JsZC5BZGRKb2ludChhbmdsZUpvaW50KTtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiBhbmdsZUpvaW50O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgI2VuZHJlZ2lvblxyXG5cclxuICAgICAgICAjcmVnaW9uIERpc3RhbmNlIEpvaW50XHJcblxyXG4gICAgICAgIHB1YmxpYyBzdGF0aWMgRGlzdGFuY2VKb2ludCBDcmVhdGVEaXN0YW5jZUpvaW50KFdvcmxkIHdvcmxkLCBCb2R5IGJvZHlBLCBCb2R5IGJvZHlCLCBWZWN0b3IyIGFuY2hvckEsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgVmVjdG9yMiBhbmNob3JCKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgRGlzdGFuY2VKb2ludCBkaXN0YW5jZUpvaW50ID0gbmV3IERpc3RhbmNlSm9pbnQoYm9keUEsIGJvZHlCLCBhbmNob3JBLCBhbmNob3JCKTtcclxuICAgICAgICAgICAgd29ybGQuQWRkSm9pbnQoZGlzdGFuY2VKb2ludCk7XHJcbiAgICAgICAgICAgIHJldHVybiBkaXN0YW5jZUpvaW50O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHVibGljIHN0YXRpYyBGaXhlZERpc3RhbmNlSm9pbnQgQ3JlYXRlRml4ZWREaXN0YW5jZUpvaW50KFdvcmxkIHdvcmxkLCBCb2R5IGJvZHksIFZlY3RvcjIgbG9jYWxBbmNob3IsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFZlY3RvcjIgd29ybGRBbmNob3IpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBGaXhlZERpc3RhbmNlSm9pbnQgZGlzdGFuY2VKb2ludCA9IG5ldyBGaXhlZERpc3RhbmNlSm9pbnQoYm9keSwgbG9jYWxBbmNob3IsIHdvcmxkQW5jaG9yKTtcclxuICAgICAgICAgICAgd29ybGQuQWRkSm9pbnQoZGlzdGFuY2VKb2ludCk7XHJcbiAgICAgICAgICAgIHJldHVybiBkaXN0YW5jZUpvaW50O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgI2VuZHJlZ2lvblxyXG5cclxuICAgICAgICAjcmVnaW9uIEZyaWN0aW9uIEpvaW50XHJcblxyXG4gICAgICAgIHB1YmxpYyBzdGF0aWMgRnJpY3Rpb25Kb2ludCBDcmVhdGVGcmljdGlvbkpvaW50KFdvcmxkIHdvcmxkLCBCb2R5IGJvZHlBLCBCb2R5IGJvZHlCLCBWZWN0b3IyIGFuY2hvckEsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgVmVjdG9yMiBhbmNob3JCKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgRnJpY3Rpb25Kb2ludCBmcmljdGlvbkpvaW50ID0gbmV3IEZyaWN0aW9uSm9pbnQoYm9keUEsIGJvZHlCLCBhbmNob3JBLCBhbmNob3JCKTtcclxuICAgICAgICAgICAgd29ybGQuQWRkSm9pbnQoZnJpY3Rpb25Kb2ludCk7XHJcbiAgICAgICAgICAgIHJldHVybiBmcmljdGlvbkpvaW50O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHVibGljIHN0YXRpYyBGaXhlZEZyaWN0aW9uSm9pbnQgQ3JlYXRlRml4ZWRGcmljdGlvbkpvaW50KFdvcmxkIHdvcmxkLCBCb2R5IGJvZHksIFZlY3RvcjIgYm9keUFuY2hvcilcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIEZpeGVkRnJpY3Rpb25Kb2ludCBmcmljdGlvbkpvaW50ID0gbmV3IEZpeGVkRnJpY3Rpb25Kb2ludChib2R5LCBib2R5QW5jaG9yKTtcclxuICAgICAgICAgICAgd29ybGQuQWRkSm9pbnQoZnJpY3Rpb25Kb2ludCk7XHJcbiAgICAgICAgICAgIHJldHVybiBmcmljdGlvbkpvaW50O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgI2VuZHJlZ2lvblxyXG5cclxuICAgICAgICAjcmVnaW9uIEdlYXIgSm9pbnRcclxuXHJcbiAgICAgICAgcHVibGljIHN0YXRpYyBHZWFySm9pbnQgQ3JlYXRlR2VhckpvaW50KFdvcmxkIHdvcmxkLCBKb2ludCBqb2ludEEsIEpvaW50IGpvaW50QiwgZmxvYXQgcmF0aW8pXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBHZWFySm9pbnQgZ2VhckpvaW50ID0gbmV3IEdlYXJKb2ludChqb2ludEEsIGpvaW50QiwgcmF0aW8pO1xyXG4gICAgICAgICAgICB3b3JsZC5BZGRKb2ludChnZWFySm9pbnQpO1xyXG4gICAgICAgICAgICByZXR1cm4gZ2VhckpvaW50O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgI2VuZHJlZ2lvblxyXG5cclxuICAgICAgICAjcmVnaW9uIFB1bGxleSBKb2ludFxyXG5cclxuICAgICAgICBwdWJsaWMgc3RhdGljIFB1bGxleUpvaW50IENyZWF0ZVB1bGxleUpvaW50KFdvcmxkIHdvcmxkLCBCb2R5IGJvZHlBLCBCb2R5IGJvZHlCLCBWZWN0b3IyIGdyb3VuZEFuY2hvckEsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBWZWN0b3IyIGdyb3VuZEFuY2hvckIsIFZlY3RvcjIgYW5jaG9yQSwgVmVjdG9yMiBhbmNob3JCLCBmbG9hdCByYXRpbylcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIFB1bGxleUpvaW50IHB1bGxleUpvaW50ID0gbmV3IFB1bGxleUpvaW50KGJvZHlBLCBib2R5QiwgZ3JvdW5kQW5jaG9yQSwgZ3JvdW5kQW5jaG9yQiwgYW5jaG9yQSwgYW5jaG9yQixcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmF0aW8pO1xyXG4gICAgICAgICAgICB3b3JsZC5BZGRKb2ludChwdWxsZXlKb2ludCk7XHJcbiAgICAgICAgICAgIHJldHVybiBwdWxsZXlKb2ludDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgICNlbmRyZWdpb25cclxuXHJcbiAgICAgICAgI3JlZ2lvbiBTbGlkZXIgSm9pbnRcclxuXHJcbiAgICAgICAgcHVibGljIHN0YXRpYyBTbGlkZXJKb2ludCBDcmVhdGVTbGlkZXJKb2ludChXb3JsZCB3b3JsZCwgQm9keSBib2R5QSwgQm9keSBib2R5QiwgVmVjdG9yMiBhbmNob3JBLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgVmVjdG9yMiBhbmNob3JCLCBmbG9hdCBtaW5MZW5ndGgsIGZsb2F0IG1heExlbmd0aClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIFNsaWRlckpvaW50IHNsaWRlckpvaW50ID0gbmV3IFNsaWRlckpvaW50KGJvZHlBLCBib2R5QiwgYW5jaG9yQSwgYW5jaG9yQiwgbWluTGVuZ3RoLCBtYXhMZW5ndGgpO1xyXG4gICAgICAgICAgICB3b3JsZC5BZGRKb2ludChzbGlkZXJKb2ludCk7XHJcbiAgICAgICAgICAgIHJldHVybiBzbGlkZXJKb2ludDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgICNlbmRyZWdpb25cclxuICAgIH1cclxufSIsIi8qXHJcbiogRmFyc2VlciBQaHlzaWNzIEVuZ2luZSBiYXNlZCBvbiBCb3gyRC5YTkEgcG9ydDpcclxuKiBDb3B5cmlnaHQgKGMpIDIwMTAgSWFuIFF2aXN0XHJcbiogXHJcbiogQm94MkQuWE5BIHBvcnQgb2YgQm94MkQ6XHJcbiogQ29weXJpZ2h0IChjKSAyMDA5IEJyYW5kb24gRnVydHdhbmdsZXIsIE5hdGhhbiBGdXJ0d2FuZ2xlclxyXG4qXHJcbiogT3JpZ2luYWwgc291cmNlIEJveDJEOlxyXG4qIENvcHlyaWdodCAoYykgMjAwNi0yMDA5IEVyaW4gQ2F0dG8gaHR0cDovL3d3dy5ncGh5c2ljcy5jb20gXHJcbiogXHJcbiogVGhpcyBzb2Z0d2FyZSBpcyBwcm92aWRlZCAnYXMtaXMnLCB3aXRob3V0IGFueSBleHByZXNzIG9yIGltcGxpZWQgXHJcbiogd2FycmFudHkuICBJbiBubyBldmVudCB3aWxsIHRoZSBhdXRob3JzIGJlIGhlbGQgbGlhYmxlIGZvciBhbnkgZGFtYWdlcyBcclxuKiBhcmlzaW5nIGZyb20gdGhlIHVzZSBvZiB0aGlzIHNvZnR3YXJlLiBcclxuKiBQZXJtaXNzaW9uIGlzIGdyYW50ZWQgdG8gYW55b25lIHRvIHVzZSB0aGlzIHNvZnR3YXJlIGZvciBhbnkgcHVycG9zZSwgXHJcbiogaW5jbHVkaW5nIGNvbW1lcmNpYWwgYXBwbGljYXRpb25zLCBhbmQgdG8gYWx0ZXIgaXQgYW5kIHJlZGlzdHJpYnV0ZSBpdCBcclxuKiBmcmVlbHksIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyByZXN0cmljdGlvbnM6IFxyXG4qIDEuIFRoZSBvcmlnaW4gb2YgdGhpcyBzb2Z0d2FyZSBtdXN0IG5vdCBiZSBtaXNyZXByZXNlbnRlZDsgeW91IG11c3Qgbm90IFxyXG4qIGNsYWltIHRoYXQgeW91IHdyb3RlIHRoZSBvcmlnaW5hbCBzb2Z0d2FyZS4gSWYgeW91IHVzZSB0aGlzIHNvZnR3YXJlIFxyXG4qIGluIGEgcHJvZHVjdCwgYW4gYWNrbm93bGVkZ21lbnQgaW4gdGhlIHByb2R1Y3QgZG9jdW1lbnRhdGlvbiB3b3VsZCBiZSBcclxuKiBhcHByZWNpYXRlZCBidXQgaXMgbm90IHJlcXVpcmVkLiBcclxuKiAyLiBBbHRlcmVkIHNvdXJjZSB2ZXJzaW9ucyBtdXN0IGJlIHBsYWlubHkgbWFya2VkIGFzIHN1Y2gsIGFuZCBtdXN0IG5vdCBiZSBcclxuKiBtaXNyZXByZXNlbnRlZCBhcyBiZWluZyB0aGUgb3JpZ2luYWwgc29mdHdhcmUuIFxyXG4qIDMuIFRoaXMgbm90aWNlIG1heSBub3QgYmUgcmVtb3ZlZCBvciBhbHRlcmVkIGZyb20gYW55IHNvdXJjZSBkaXN0cmlidXRpb24uIFxyXG4qL1xyXG5cclxudXNpbmcgU3lzdGVtO1xyXG5cclxubmFtZXNwYWNlIEZhcnNlZXJQaHlzaWNzXHJcbntcclxuICAgIHB1YmxpYyBzdGF0aWMgY2xhc3MgU2V0dGluZ3NcclxuICAgIHtcclxuICAgICAgICBwdWJsaWMgY29uc3QgZmxvYXQgTWF4RmxvYXQgPSAzLjQwMjgyMzQ2NmUrMzhmO1xyXG4gICAgICAgIHB1YmxpYyBjb25zdCBmbG9hdCBFcHNpbG9uID0gMS4xOTIwOTI4OTZlLTA3ZjtcclxuICAgICAgICBwdWJsaWMgY29uc3QgZmxvYXQgUGkgPSAzLjE0MTU5MjY1MzU5ZjtcclxuXHJcbiAgICAgICAgLy8gQ29tbW9uXHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gRW5hYmxpbmcgZGlhZ25pc3RpY3MgY2F1c2VzIHRoZSBlbmdpbmUgdG8gZ2F0aGVyIHRpbWluZyBpbmZvcm1hdGlvbi5cclxuICAgICAgICAvLy8gWW91IGNhbiBzZWUgaG93IG11Y2ggdGltZSBpdCB0b29rIHRvIHNvbHZlIHRoZSBjb250YWN0cywgc29sdmUgQ0NEXHJcbiAgICAgICAgLy8vIGFuZCB1cGRhdGUgdGhlIGNvbnRyb2xsZXJzLlxyXG4gICAgICAgIC8vLyBOT1RFOiBJZiB5b3UgYXJlIHVzaW5nIGEgZGVidWcgdmlldyB0aGF0IHNob3dzIHBlcmZvcm1hbmNlIGNvdW50ZXJzLFxyXG4gICAgICAgIC8vLyB5b3UgbWlnaHQgd2FudCB0byBlbmFibGUgdGhpcy5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIHB1YmxpYyBzdGF0aWMgYm9vbCBFbmFibGVEaWFnbm9zdGljcyA9IHRydWU7XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gVGhlIG51bWJlciBvZiB2ZWxvY2l0eSBpdGVyYXRpb25zIHVzZWQgaW4gdGhlIHNvbHZlci5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIHB1YmxpYyBzdGF0aWMgaW50IFZlbG9jaXR5SXRlcmF0aW9ucyA9IDg7XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gVGhlIG51bWJlciBvZiBwb3NpdGlvbiBpdGVyYXRpb25zIHVzZWQgaW4gdGhlIHNvbHZlci5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIHB1YmxpYyBzdGF0aWMgaW50IFBvc2l0aW9uSXRlcmF0aW9ucyA9IDM7XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gRW5hYmxlL0Rpc2FibGUgQ29udGludW91cyBDb2xsaXNpb24gRGV0ZWN0aW9uIChDQ0QpXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICBwdWJsaWMgc3RhdGljIGJvb2wgQ29udGludW91c1BoeXNpY3MgPSB0cnVlO1xyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIFRoZSBudW1iZXIgb2YgdmVsb2NpdHkgaXRlcmF0aW9ucyBpbiB0aGUgVE9JIHNvbHZlclxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgcHVibGljIHN0YXRpYyBpbnQgVE9JVmVsb2NpdHlJdGVyYXRpb25zID0gODtcclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBUaGUgbnVtYmVyIG9mIHBvc2l0aW9uIGl0ZXJhdGlvbnMgaW4gdGhlIFRPSSBzb2x2ZXJcclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIHB1YmxpYyBzdGF0aWMgaW50IFRPSVBvc2l0aW9uSXRlcmF0aW9ucyA9IDIwO1xyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIE1heGltdW0gbnVtYmVyIG9mIHN1Yi1zdGVwcyBwZXIgY29udGFjdCBpbiBjb250aW51b3VzIHBoeXNpY3Mgc2ltdWxhdGlvbi5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIHB1YmxpYyBjb25zdCBpbnQgTWF4U3ViU3RlcHMgPSA4O1xyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIEVuYWJsZS9EaXNhYmxlIHdhcm1zdGFydGluZ1xyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgcHVibGljIHN0YXRpYyBib29sIEVuYWJsZVdhcm1zdGFydGluZyA9IHRydWU7XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gRW5hYmxlL0Rpc2FibGUgc2xlZXBpbmdcclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIHB1YmxpYyBzdGF0aWMgYm9vbCBBbGxvd1NsZWVwID0gdHJ1ZTtcclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBUaGUgbWF4aW11bSBudW1iZXIgb2YgdmVydGljZXMgb24gYSBjb252ZXggcG9seWdvbi5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIHB1YmxpYyBzdGF0aWMgaW50IE1heFBvbHlnb25WZXJ0aWNlcyA9IDMwO1xyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIEZhcnNlZXIgUGh5c2ljcyBFbmdpbmUgaGFzIGEgZGlmZmVyZW50IHdheSBvZiBmaWx0ZXJpbmcgZml4dHVyZXMgdGhhbiBCb3gyZC5cclxuICAgICAgICAvLy8gV2UgaGF2ZSBib3RoIEZQRSBhbmQgQm94MkQgZmlsdGVyaW5nIGluIHRoZSBlbmdpbmUuIElmIHlvdSBhcmUgdXBncmFkaW5nXHJcbiAgICAgICAgLy8vIGZyb20gZWFybGllciB2ZXJzaW9ucyBvZiBGUEUsIHNldCB0aGlzIHRvIHRydWUuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICBwdWJsaWMgc3RhdGljIGJvb2wgVXNlRlBFQ29sbGlzaW9uQ2F0ZWdvcmllcztcclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBDb25zZXJ2ZSBtZW1vcnkgbWFrZXMgc3VyZSB0aGF0IG9iamVjdHMgYXJlIHVzZWQgYnkgcmVmZXJlbmNlIGluc3RlYWQgb2YgY2xvbmVkLlxyXG4gICAgICAgIC8vLyBXaGVuIHlvdSBnaXZlIGEgdmVydGljZXMgY29sbGVjdGlvbiB0byBhIFBvbHlnb25TaGFwZSwgaXQgd2lsbCBieSBkZWZhdWx0IGNvcHkgdGhlIHZlcnRpY2VzXHJcbiAgICAgICAgLy8vIGluc3RlYWQgb2YgdXNpbmcgdGhlIG9yaWdpbmFsIHJlZmVyZW5jZS4gVGhpcyBpcyB0byBlbnN1cmUgdGhhdCBvYmplY3RzIG1vZGlmaWVkIG91dHNpZGUgdGhlIGVuZ2luZVxyXG4gICAgICAgIC8vLyBkb2VzIG5vdCBhZmZlY3QgdGhlIGVuZ2luZSBpdHNlbGYsIGhvd2V2ZXIsIHRoaXMgdXNlcyBleHRyYSBtZW1vcnkuIFRoaXMgYmVoYXZpb3JcclxuICAgICAgICAvLy8gY2FuIGJlIHR1cm5lZCBvZmYgYnkgc2V0dGluZyBDb25zZXJ2ZU1lbW9yeSB0byB0cnVlLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgcHVibGljIGNvbnN0IGJvb2wgQ29uc2VydmVNZW1vcnkgPSBmYWxzZTtcclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBUaGUgbWF4aW11bSBudW1iZXIgb2YgY29udGFjdCBwb2ludHMgYmV0d2VlbiB0d28gY29udmV4IHNoYXBlcy5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIHB1YmxpYyBjb25zdCBpbnQgTWF4TWFuaWZvbGRQb2ludHMgPSAyO1xyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIFRoaXMgaXMgdXNlZCB0byBmYXR0ZW4gQUFCQnMgaW4gdGhlIGR5bmFtaWMgdHJlZS4gVGhpcyBhbGxvd3MgcHJveGllc1xyXG4gICAgICAgIC8vLyB0byBtb3ZlIGJ5IGEgc21hbGwgYW1vdW50IHdpdGhvdXQgdHJpZ2dlcmluZyBhIHRyZWUgYWRqdXN0bWVudC5cclxuICAgICAgICAvLy8gVGhpcyBpcyBpbiBtZXRlcnMuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICBwdWJsaWMgY29uc3QgZmxvYXQgQUFCQkV4dGVuc2lvbiA9IDAuMWY7XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gVGhpcyBpcyB1c2VkIHRvIGZhdHRlbiBBQUJCcyBpbiB0aGUgZHluYW1pYyB0cmVlLiBUaGlzIGlzIHVzZWQgdG8gcHJlZGljdFxyXG4gICAgICAgIC8vLyB0aGUgZnV0dXJlIHBvc2l0aW9uIGJhc2VkIG9uIHRoZSBjdXJyZW50IGRpc3BsYWNlbWVudC5cclxuICAgICAgICAvLy8gVGhpcyBpcyBhIGRpbWVuc2lvbmxlc3MgbXVsdGlwbGllci5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIHB1YmxpYyBjb25zdCBmbG9hdCBBQUJCTXVsdGlwbGllciA9IDIuMGY7XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gQSBzbWFsbCBsZW5ndGggdXNlZCBhcyBhIGNvbGxpc2lvbiBhbmQgY29uc3RyYWludCB0b2xlcmFuY2UuIFVzdWFsbHkgaXQgaXNcclxuICAgICAgICAvLy8gY2hvc2VuIHRvIGJlIG51bWVyaWNhbGx5IHNpZ25pZmljYW50LCBidXQgdmlzdWFsbHkgaW5zaWduaWZpY2FudC5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIHB1YmxpYyBjb25zdCBmbG9hdCBMaW5lYXJTbG9wID0gMC4wMDVmO1xyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIEEgc21hbGwgYW5nbGUgdXNlZCBhcyBhIGNvbGxpc2lvbiBhbmQgY29uc3RyYWludCB0b2xlcmFuY2UuIFVzdWFsbHkgaXQgaXNcclxuICAgICAgICAvLy8gY2hvc2VuIHRvIGJlIG51bWVyaWNhbGx5IHNpZ25pZmljYW50LCBidXQgdmlzdWFsbHkgaW5zaWduaWZpY2FudC5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIHB1YmxpYyBjb25zdCBmbG9hdCBBbmd1bGFyU2xvcCA9ICgyLjBmIC8gMTgwLjBmICogUGkpO1xyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIFRoZSByYWRpdXMgb2YgdGhlIHBvbHlnb24vZWRnZSBzaGFwZSBza2luLiBUaGlzIHNob3VsZCBub3QgYmUgbW9kaWZpZWQuIE1ha2luZ1xyXG4gICAgICAgIC8vLyB0aGlzIHNtYWxsZXIgbWVhbnMgcG9seWdvbnMgd2lsbCBoYXZlIGFuIGluc3VmZmljaWVudCBidWZmZXIgZm9yIGNvbnRpbnVvdXMgY29sbGlzaW9uLlxyXG4gICAgICAgIC8vLyBNYWtpbmcgaXQgbGFyZ2VyIG1heSBjcmVhdGUgYXJ0aWZhY3RzIGZvciB2ZXJ0ZXggY29sbGlzaW9uLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgcHVibGljIGNvbnN0IGZsb2F0IFBvbHlnb25SYWRpdXMgPSAoMi4wZiAqIExpbmVhclNsb3ApO1xyXG5cclxuICAgICAgICAvLyBEeW5hbWljc1xyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIE1heGltdW0gbnVtYmVyIG9mIGNvbnRhY3RzIHRvIGJlIGhhbmRsZWQgdG8gc29sdmUgYSBUT0kgaW1wYWN0LlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgcHVibGljIGNvbnN0IGludCBNYXhUT0lDb250YWN0cyA9IDUwO1xyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIEEgdmVsb2NpdHkgdGhyZXNob2xkIGZvciBlbGFzdGljIGNvbGxpc2lvbnMuIEFueSBjb2xsaXNpb24gd2l0aCBhIHJlbGF0aXZlIGxpbmVhclxyXG4gICAgICAgIC8vLyB2ZWxvY2l0eSBiZWxvdyB0aGlzIHRocmVzaG9sZCB3aWxsIGJlIHRyZWF0ZWQgYXMgaW5lbGFzdGljLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgcHVibGljIGNvbnN0IGZsb2F0IFZlbG9jaXR5VGhyZXNob2xkID0gMS4wZjtcclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBUaGUgbWF4aW11bSBsaW5lYXIgcG9zaXRpb24gY29ycmVjdGlvbiB1c2VkIHdoZW4gc29sdmluZyBjb25zdHJhaW50cy4gVGhpcyBoZWxwcyB0b1xyXG4gICAgICAgIC8vLyBwcmV2ZW50IG92ZXJzaG9vdC5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIHB1YmxpYyBjb25zdCBmbG9hdCBNYXhMaW5lYXJDb3JyZWN0aW9uID0gMC4yZjtcclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBUaGUgbWF4aW11bSBhbmd1bGFyIHBvc2l0aW9uIGNvcnJlY3Rpb24gdXNlZCB3aGVuIHNvbHZpbmcgY29uc3RyYWludHMuIFRoaXMgaGVscHMgdG9cclxuICAgICAgICAvLy8gcHJldmVudCBvdmVyc2hvb3QuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICBwdWJsaWMgY29uc3QgZmxvYXQgTWF4QW5ndWxhckNvcnJlY3Rpb24gPSAoOC4wZiAvIDE4MC4wZiAqIFBpKTtcclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBUaGlzIHNjYWxlIGZhY3RvciBjb250cm9scyBob3cgZmFzdCBvdmVybGFwIGlzIHJlc29sdmVkLiBJZGVhbGx5IHRoaXMgd291bGQgYmUgMSBzb1xyXG4gICAgICAgIC8vLyB0aGF0IG92ZXJsYXAgaXMgcmVtb3ZlZCBpbiBvbmUgdGltZSBzdGVwLiBIb3dldmVyIHVzaW5nIHZhbHVlcyBjbG9zZSB0byAxIG9mdGVuIGxlYWRcclxuICAgICAgICAvLy8gdG8gb3ZlcnNob290LlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgcHVibGljIGNvbnN0IGZsb2F0IENvbnRhY3RCYXVtZ2FydGUgPSAwLjJmO1xyXG5cclxuICAgICAgICAvLyBTbGVlcFxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIFRoZSB0aW1lIHRoYXQgYSBib2R5IG11c3QgYmUgc3RpbGwgYmVmb3JlIGl0IHdpbGwgZ28gdG8gc2xlZXAuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICBwdWJsaWMgY29uc3QgZmxvYXQgVGltZVRvU2xlZXAgPSAwLjVmO1xyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIEEgYm9keSBjYW5ub3Qgc2xlZXAgaWYgaXRzIGxpbmVhciB2ZWxvY2l0eSBpcyBhYm92ZSB0aGlzIHRvbGVyYW5jZS5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIHB1YmxpYyBjb25zdCBmbG9hdCBMaW5lYXJTbGVlcFRvbGVyYW5jZSA9IDAuMDFmO1xyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIEEgYm9keSBjYW5ub3Qgc2xlZXAgaWYgaXRzIGFuZ3VsYXIgdmVsb2NpdHkgaXMgYWJvdmUgdGhpcyB0b2xlcmFuY2UuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICBwdWJsaWMgY29uc3QgZmxvYXQgQW5ndWxhclNsZWVwVG9sZXJhbmNlID0gKDIuMGYgLyAxODAuMGYgKiBQaSk7XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gVGhlIG1heGltdW0gbGluZWFyIHZlbG9jaXR5IG9mIGEgYm9keS4gVGhpcyBsaW1pdCBpcyB2ZXJ5IGxhcmdlIGFuZCBpcyB1c2VkXHJcbiAgICAgICAgLy8vIHRvIHByZXZlbnQgbnVtZXJpY2FsIHByb2JsZW1zLiBZb3Ugc2hvdWxkbid0IG5lZWQgdG8gYWRqdXN0IHRoaXMuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICBwdWJsaWMgY29uc3QgZmxvYXQgTWF4VHJhbnNsYXRpb24gPSAyLjBmO1xyXG5cclxuICAgICAgICBwdWJsaWMgY29uc3QgZmxvYXQgTWF4VHJhbnNsYXRpb25TcXVhcmVkID0gKE1heFRyYW5zbGF0aW9uICogTWF4VHJhbnNsYXRpb24pO1xyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIFRoZSBtYXhpbXVtIGFuZ3VsYXIgdmVsb2NpdHkgb2YgYSBib2R5LiBUaGlzIGxpbWl0IGlzIHZlcnkgbGFyZ2UgYW5kIGlzIHVzZWRcclxuICAgICAgICAvLy8gdG8gcHJldmVudCBudW1lcmljYWwgcHJvYmxlbXMuIFlvdSBzaG91bGRuJ3QgbmVlZCB0byBhZGp1c3QgdGhpcy5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIHB1YmxpYyBjb25zdCBmbG9hdCBNYXhSb3RhdGlvbiA9ICgwLjVmICogUGkpO1xyXG5cclxuICAgICAgICBwdWJsaWMgY29uc3QgZmxvYXQgTWF4Um90YXRpb25TcXVhcmVkID0gKE1heFJvdGF0aW9uICogTWF4Um90YXRpb24pO1xyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIEZyaWN0aW9uIG1peGluZyBsYXcuIEZlZWwgZnJlZSB0byBjdXN0b21pemUgdGhpcy5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cImZyaWN0aW9uMVwiPlRoZSBmcmljdGlvbjEuPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJmcmljdGlvbjJcIj5UaGUgZnJpY3Rpb24yLjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxyZXR1cm5zPjwvcmV0dXJucz5cclxuICAgICAgICBwdWJsaWMgc3RhdGljIGZsb2F0IE1peEZyaWN0aW9uKGZsb2F0IGZyaWN0aW9uMSwgZmxvYXQgZnJpY3Rpb24yKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIChmbG9hdCkgTWF0aC5TcXJ0KGZyaWN0aW9uMSAqIGZyaWN0aW9uMik7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIFJlc3RpdHV0aW9uIG1peGluZyBsYXcuIEZlZWwgZnJlZSB0byBjdXN0b21pemUgdGhpcy5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cInJlc3RpdHV0aW9uMVwiPlRoZSByZXN0aXR1dGlvbjEuPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJyZXN0aXR1dGlvbjJcIj5UaGUgcmVzdGl0dXRpb24yLjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxyZXR1cm5zPjwvcmV0dXJucz5cclxuICAgICAgICBwdWJsaWMgc3RhdGljIGZsb2F0IE1peFJlc3RpdHV0aW9uKGZsb2F0IHJlc3RpdHV0aW9uMSwgZmxvYXQgcmVzdGl0dXRpb24yKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIHJlc3RpdHV0aW9uMSA+IHJlc3RpdHV0aW9uMiA/IHJlc3RpdHV0aW9uMSA6IHJlc3RpdHV0aW9uMjtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn0iLCJ1c2luZyBTeXN0ZW07XHJcbnVzaW5nIEZhcnNlZXJQaHlzaWNzLkR5bmFtaWNzO1xyXG51c2luZyBNaWNyb3NvZnQuWG5hLkZyYW1ld29yaztcclxudXNpbmcgTWljcm9zb2Z0LlhuYS5GcmFtZXdvcmsuR3JhcGhpY3M7XHJcblxyXG5uYW1lc3BhY2UgRmFyc2VlclBoeXNpY3MuVXRpbGl0eVxyXG57XHJcbiAgICBwdWJsaWMgY2xhc3MgQ2FtZXJhMkRcclxuICAgIHtcclxuICAgICAgICBwcml2YXRlIGNvbnN0IGZsb2F0IF9taW5ab29tID0gMC4wMmY7XHJcbiAgICAgICAgcHJpdmF0ZSBjb25zdCBmbG9hdCBfbWF4Wm9vbSA9IDIwZjtcclxuICAgICAgICBwcml2YXRlIHN0YXRpYyBHcmFwaGljc0RldmljZSBfZ3JhcGhpY3M7XHJcblxyXG4gICAgICAgIHByaXZhdGUgTWF0cml4IF9iYXRjaFZpZXc7XHJcblxyXG4gICAgICAgIHByaXZhdGUgVmVjdG9yMiBfY3VycmVudFBvc2l0aW9uO1xyXG5cclxuICAgICAgICBwcml2YXRlIGZsb2F0IF9jdXJyZW50Um90YXRpb247XHJcblxyXG4gICAgICAgIHByaXZhdGUgZmxvYXQgX2N1cnJlbnRab29tO1xyXG4gICAgICAgIHByaXZhdGUgVmVjdG9yMiBfbWF4UG9zaXRpb247XHJcbiAgICAgICAgcHJpdmF0ZSBmbG9hdCBfbWF4Um90YXRpb247XHJcbiAgICAgICAgcHJpdmF0ZSBWZWN0b3IyIF9taW5Qb3NpdGlvbjtcclxuICAgICAgICBwcml2YXRlIGZsb2F0IF9taW5Sb3RhdGlvbjtcclxuICAgICAgICBwcml2YXRlIGJvb2wgX3Bvc2l0aW9uVHJhY2tpbmc7XHJcbiAgICAgICAgcHJpdmF0ZSBNYXRyaXggX3Byb2plY3Rpb247XHJcbiAgICAgICAgcHJpdmF0ZSBib29sIF9yb3RhdGlvblRyYWNraW5nO1xyXG4gICAgICAgIHByaXZhdGUgVmVjdG9yMiBfdGFyZ2V0UG9zaXRpb247XHJcbiAgICAgICAgcHJpdmF0ZSBmbG9hdCBfdGFyZ2V0Um90YXRpb247XHJcbiAgICAgICAgcHJpdmF0ZSBCb2R5IF90cmFja2luZ0JvZHk7XHJcbiAgICAgICAgcHJpdmF0ZSBWZWN0b3IyIF90cmFuc2xhdGVDZW50ZXI7XHJcbiAgICAgICAgcHJpdmF0ZSBNYXRyaXggX3ZpZXc7XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gVGhlIGNvbnN0cnVjdG9yIGZvciB0aGUgQ2FtZXJhMkQgY2xhc3MuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJncmFwaGljc1wiPjwvcGFyYW0+XHJcbiAgICAgICAgcHVibGljIENhbWVyYTJEKEdyYXBoaWNzRGV2aWNlIGdyYXBoaWNzKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgX2dyYXBoaWNzID0gZ3JhcGhpY3M7XHJcbiAgICAgICAgICAgIF9wcm9qZWN0aW9uID0gTWF0cml4LkNyZWF0ZU9ydGhvZ3JhcGhpY09mZkNlbnRlcigwZiwgQ29udmVydFVuaXRzLlRvU2ltVW5pdHMoX2dyYXBoaWNzLlZpZXdwb3J0LldpZHRoKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIENvbnZlcnRVbml0cy5Ub1NpbVVuaXRzKF9ncmFwaGljcy5WaWV3cG9ydC5IZWlnaHQpLCAwZiwgMGYsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAxZik7XHJcbiAgICAgICAgICAgIF92aWV3ID0gTWF0cml4LklkZW50aXR5O1xyXG4gICAgICAgICAgICBfYmF0Y2hWaWV3ID0gTWF0cml4LklkZW50aXR5O1xyXG5cclxuICAgICAgICAgICAgX3RyYW5zbGF0ZUNlbnRlciA9IG5ldyBWZWN0b3IyKENvbnZlcnRVbml0cy5Ub1NpbVVuaXRzKF9ncmFwaGljcy5WaWV3cG9ydC5XaWR0aCAvIDJmKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIENvbnZlcnRVbml0cy5Ub1NpbVVuaXRzKF9ncmFwaGljcy5WaWV3cG9ydC5IZWlnaHQgLyAyZikpO1xyXG5cclxuICAgICAgICAgICAgUmVzZXRDYW1lcmEoKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHB1YmxpYyBNYXRyaXggVmlld1xyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgZ2V0IHsgcmV0dXJuIF9iYXRjaFZpZXc7IH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHB1YmxpYyBNYXRyaXggU2ltVmlld1xyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgZ2V0IHsgcmV0dXJuIF92aWV3OyB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwdWJsaWMgTWF0cml4IFNpbVByb2plY3Rpb25cclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGdldCB7IHJldHVybiBfcHJvamVjdGlvbjsgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBUaGUgY3VycmVudCBwb3NpdGlvbiBvZiB0aGUgY2FtZXJhLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgcHVibGljIFZlY3RvcjIgUG9zaXRpb25cclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGdldCB7IHJldHVybiBDb252ZXJ0VW5pdHMuVG9EaXNwbGF5VW5pdHMoX2N1cnJlbnRQb3NpdGlvbik7IH1cclxuICAgICAgICAgICAgc2V0XHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIF90YXJnZXRQb3NpdGlvbiA9IENvbnZlcnRVbml0cy5Ub1NpbVVuaXRzKHZhbHVlKTtcclxuICAgICAgICAgICAgICAgIGlmIChfbWluUG9zaXRpb24gIT0gX21heFBvc2l0aW9uKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIFZlY3RvcjIuQ2xhbXAocmVmIF90YXJnZXRQb3NpdGlvbiwgcmVmIF9taW5Qb3NpdGlvbiwgcmVmIF9tYXhQb3NpdGlvbiwgb3V0IF90YXJnZXRQb3NpdGlvbik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gVGhlIGZ1cnRoZXN0IHVwLCBhbmQgdGhlIGZ1cnRoZXN0IGxlZnQgdGhlIGNhbWVyYSBjYW4gZ28uXHJcbiAgICAgICAgLy8vIGlmIHRoaXMgdmFsdWUgZXF1YWxzIG1heFBvc2l0aW9uLCB0aGVuIG5vIGNsYW1waW5nIHdpbGwgYmUgXHJcbiAgICAgICAgLy8vIGFwcGxpZWQgKHVubGVzcyB5b3Ugb3ZlcnJpZGUgdGhhdCBmdW5jdGlvbikuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICBwdWJsaWMgVmVjdG9yMiBNaW5Qb3NpdGlvblxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgZ2V0IHsgcmV0dXJuIENvbnZlcnRVbml0cy5Ub0Rpc3BsYXlVbml0cyhfbWluUG9zaXRpb24pOyB9XHJcbiAgICAgICAgICAgIHNldCB7IF9taW5Qb3NpdGlvbiA9IENvbnZlcnRVbml0cy5Ub1NpbVVuaXRzKHZhbHVlKTsgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyB0aGUgZnVydGhlc3QgZG93biwgYW5kIHRoZSBmdXJ0aGVzdCByaWdodCB0aGUgY2FtZXJhIHdpbGwgZ28uXHJcbiAgICAgICAgLy8vIGlmIHRoaXMgdmFsdWUgZXF1YWxzIG1pblBvc2l0aW9uLCB0aGVuIG5vIGNsYW1waW5nIHdpbGwgYmUgXHJcbiAgICAgICAgLy8vIGFwcGxpZWQgKHVubGVzcyB5b3Ugb3ZlcnJpZGUgdGhhdCBmdW5jdGlvbikuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICBwdWJsaWMgVmVjdG9yMiBNYXhQb3NpdGlvblxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgZ2V0IHsgcmV0dXJuIENvbnZlcnRVbml0cy5Ub0Rpc3BsYXlVbml0cyhfbWF4UG9zaXRpb24pOyB9XHJcbiAgICAgICAgICAgIHNldCB7IF9tYXhQb3NpdGlvbiA9IENvbnZlcnRVbml0cy5Ub1NpbVVuaXRzKHZhbHVlKTsgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBUaGUgY3VycmVudCByb3RhdGlvbiBvZiB0aGUgY2FtZXJhIGluIHJhZGlhbnMuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICBwdWJsaWMgZmxvYXQgUm90YXRpb25cclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGdldCB7IHJldHVybiBfY3VycmVudFJvdGF0aW9uOyB9XHJcbiAgICAgICAgICAgIHNldFxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBfdGFyZ2V0Um90YXRpb24gPSB2YWx1ZSAlIE1hdGhIZWxwZXIuVHdvUGk7XHJcbiAgICAgICAgICAgICAgICBpZiAoX21pblJvdGF0aW9uICE9IF9tYXhSb3RhdGlvbilcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBfdGFyZ2V0Um90YXRpb24gPSBNYXRoSGVscGVyLkNsYW1wKF90YXJnZXRSb3RhdGlvbiwgX21pblJvdGF0aW9uLCBfbWF4Um90YXRpb24pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIEdldHMgb3Igc2V0cyB0aGUgbWluaW11bSByb3RhdGlvbiBpbiByYWRpYW5zLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDx2YWx1ZT5UaGUgbWluIHJvdGF0aW9uLjwvdmFsdWU+XHJcbiAgICAgICAgcHVibGljIGZsb2F0IE1pblJvdGF0aW9uXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBnZXQgeyByZXR1cm4gX21pblJvdGF0aW9uOyB9XHJcbiAgICAgICAgICAgIHNldCB7IF9taW5Sb3RhdGlvbiA9IE1hdGhIZWxwZXIuQ2xhbXAodmFsdWUsIC1NYXRoSGVscGVyLlBpLCAwZik7IH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gR2V0cyBvciBzZXRzIHRoZSBtYXhpbXVtIHJvdGF0aW9uIGluIHJhZGlhbnMuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHZhbHVlPlRoZSBtYXggcm90YXRpb24uPC92YWx1ZT5cclxuICAgICAgICBwdWJsaWMgZmxvYXQgTWF4Um90YXRpb25cclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGdldCB7IHJldHVybiBfbWF4Um90YXRpb247IH1cclxuICAgICAgICAgICAgc2V0IHsgX21heFJvdGF0aW9uID0gTWF0aEhlbHBlci5DbGFtcCh2YWx1ZSwgMGYsIE1hdGhIZWxwZXIuUGkpOyB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIFRoZSBjdXJyZW50IHJvdGF0aW9uIG9mIHRoZSBjYW1lcmEgaW4gcmFkaWFucy5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIHB1YmxpYyBmbG9hdCBab29tXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBnZXQgeyByZXR1cm4gX2N1cnJlbnRab29tOyB9XHJcbiAgICAgICAgICAgIHNldFxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBfY3VycmVudFpvb20gPSB2YWx1ZTtcclxuICAgICAgICAgICAgICAgIF9jdXJyZW50Wm9vbSA9IE1hdGhIZWxwZXIuQ2xhbXAoX2N1cnJlbnRab29tLCBfbWluWm9vbSwgX21heFpvb20pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIHRoZSBib2R5IHRoYXQgdGhpcyBjYW1lcmEgaXMgY3VycmVudGx5IHRyYWNraW5nLiBcclxuICAgICAgICAvLy8gTnVsbCBpZiBub3QgdHJhY2tpbmcgYW55LlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgcHVibGljIEJvZHkgVHJhY2tpbmdCb2R5XHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBnZXQgeyByZXR1cm4gX3RyYWNraW5nQm9keTsgfVxyXG4gICAgICAgICAgICBzZXRcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgX3RyYWNraW5nQm9keSA9IHZhbHVlO1xyXG4gICAgICAgICAgICAgICAgaWYgKF90cmFja2luZ0JvZHkgIT0gbnVsbClcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBfcG9zaXRpb25UcmFja2luZyA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHB1YmxpYyBib29sIEVuYWJsZVBvc2l0aW9uVHJhY2tpbmdcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGdldCB7IHJldHVybiBfcG9zaXRpb25UcmFja2luZzsgfVxyXG4gICAgICAgICAgICBzZXRcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlICYmIF90cmFja2luZ0JvZHkgIT0gbnVsbClcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBfcG9zaXRpb25UcmFja2luZyA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgX3Bvc2l0aW9uVHJhY2tpbmcgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHVibGljIGJvb2wgRW5hYmxlUm90YXRpb25UcmFja2luZ1xyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgZ2V0IHsgcmV0dXJuIF9yb3RhdGlvblRyYWNraW5nOyB9XHJcbiAgICAgICAgICAgIHNldFxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgJiYgX3RyYWNraW5nQm9keSAhPSBudWxsKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIF9yb3RhdGlvblRyYWNraW5nID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBfcm90YXRpb25UcmFja2luZyA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwdWJsaWMgYm9vbCBFbmFibGVUcmFja2luZ1xyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgc2V0XHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIEVuYWJsZVBvc2l0aW9uVHJhY2tpbmcgPSB2YWx1ZTtcclxuICAgICAgICAgICAgICAgIEVuYWJsZVJvdGF0aW9uVHJhY2tpbmcgPSB2YWx1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHVibGljIHZvaWQgTW92ZUNhbWVyYShWZWN0b3IyIGFtb3VudClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIF9jdXJyZW50UG9zaXRpb24gKz0gYW1vdW50O1xyXG4gICAgICAgICAgICBpZiAoX21pblBvc2l0aW9uICE9IF9tYXhQb3NpdGlvbilcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgVmVjdG9yMi5DbGFtcChyZWYgX2N1cnJlbnRQb3NpdGlvbiwgcmVmIF9taW5Qb3NpdGlvbiwgcmVmIF9tYXhQb3NpdGlvbiwgb3V0IF9jdXJyZW50UG9zaXRpb24pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIF90YXJnZXRQb3NpdGlvbiA9IF9jdXJyZW50UG9zaXRpb247XHJcbiAgICAgICAgICAgIF9wb3NpdGlvblRyYWNraW5nID0gZmFsc2U7XHJcbiAgICAgICAgICAgIF9yb3RhdGlvblRyYWNraW5nID0gZmFsc2U7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwdWJsaWMgdm9pZCBSb3RhdGVDYW1lcmEoZmxvYXQgYW1vdW50KVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgX2N1cnJlbnRSb3RhdGlvbiArPSBhbW91bnQ7XHJcbiAgICAgICAgICAgIGlmIChfbWluUm90YXRpb24gIT0gX21heFJvdGF0aW9uKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBfY3VycmVudFJvdGF0aW9uID0gTWF0aEhlbHBlci5DbGFtcChfY3VycmVudFJvdGF0aW9uLCBfbWluUm90YXRpb24sIF9tYXhSb3RhdGlvbik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgX3RhcmdldFJvdGF0aW9uID0gX2N1cnJlbnRSb3RhdGlvbjtcclxuICAgICAgICAgICAgX3Bvc2l0aW9uVHJhY2tpbmcgPSBmYWxzZTtcclxuICAgICAgICAgICAgX3JvdGF0aW9uVHJhY2tpbmcgPSBmYWxzZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gUmVzZXRzIHRoZSBjYW1lcmEgdG8gZGVmYXVsdCB2YWx1ZXMuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICBwdWJsaWMgdm9pZCBSZXNldENhbWVyYSgpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBfY3VycmVudFBvc2l0aW9uID0gVmVjdG9yMi5aZXJvO1xyXG4gICAgICAgICAgICBfdGFyZ2V0UG9zaXRpb24gPSBWZWN0b3IyLlplcm87XHJcbiAgICAgICAgICAgIF9taW5Qb3NpdGlvbiA9IFZlY3RvcjIuWmVybztcclxuICAgICAgICAgICAgX21heFBvc2l0aW9uID0gVmVjdG9yMi5aZXJvO1xyXG5cclxuICAgICAgICAgICAgX2N1cnJlbnRSb3RhdGlvbiA9IDBmO1xyXG4gICAgICAgICAgICBfdGFyZ2V0Um90YXRpb24gPSAwZjtcclxuICAgICAgICAgICAgX21pblJvdGF0aW9uID0gLU1hdGhIZWxwZXIuUGk7XHJcbiAgICAgICAgICAgIF9tYXhSb3RhdGlvbiA9IE1hdGhIZWxwZXIuUGk7XHJcblxyXG4gICAgICAgICAgICBfcG9zaXRpb25UcmFja2luZyA9IGZhbHNlO1xyXG4gICAgICAgICAgICBfcm90YXRpb25UcmFja2luZyA9IGZhbHNlO1xyXG5cclxuICAgICAgICAgICAgX2N1cnJlbnRab29tID0gMWY7XHJcblxyXG4gICAgICAgICAgICBTZXRWaWV3KCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwdWJsaWMgdm9pZCBKdW1wMlRhcmdldCgpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBfY3VycmVudFBvc2l0aW9uID0gX3RhcmdldFBvc2l0aW9uO1xyXG4gICAgICAgICAgICBfY3VycmVudFJvdGF0aW9uID0gX3RhcmdldFJvdGF0aW9uO1xyXG5cclxuICAgICAgICAgICAgU2V0VmlldygpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHJpdmF0ZSB2b2lkIFNldFZpZXcoKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgTWF0cml4IG1hdFJvdGF0aW9uID0gTWF0cml4LkNyZWF0ZVJvdGF0aW9uWihfY3VycmVudFJvdGF0aW9uKTtcclxuICAgICAgICAgICAgTWF0cml4IG1hdFpvb20gPSBNYXRyaXguQ3JlYXRlU2NhbGUoX2N1cnJlbnRab29tKTtcclxuICAgICAgICAgICAgVmVjdG9yMyB0cmFuc2xhdGVDZW50ZXIgPSBuZXcgVmVjdG9yMyhfdHJhbnNsYXRlQ2VudGVyLCAwZik7XHJcbiAgICAgICAgICAgIFZlY3RvcjMgdHJhbnNsYXRlQm9keSA9IG5ldyBWZWN0b3IzKC1fY3VycmVudFBvc2l0aW9uLCAwZik7XHJcblxyXG4gICAgICAgICAgICBfdmlldyA9IE1hdHJpeC5DcmVhdGVUcmFuc2xhdGlvbih0cmFuc2xhdGVCb2R5KSAqXHJcbiAgICAgICAgICAgICAgICAgICAgbWF0Um90YXRpb24gKlxyXG4gICAgICAgICAgICAgICAgICAgIG1hdFpvb20gKlxyXG4gICAgICAgICAgICAgICAgICAgIE1hdHJpeC5DcmVhdGVUcmFuc2xhdGlvbih0cmFuc2xhdGVDZW50ZXIpO1xyXG5cclxuICAgICAgICAgICAgdHJhbnNsYXRlQ2VudGVyID0gQ29udmVydFVuaXRzLlRvRGlzcGxheVVuaXRzKHRyYW5zbGF0ZUNlbnRlcik7XHJcbiAgICAgICAgICAgIHRyYW5zbGF0ZUJvZHkgPSBDb252ZXJ0VW5pdHMuVG9EaXNwbGF5VW5pdHModHJhbnNsYXRlQm9keSk7XHJcblxyXG4gICAgICAgICAgICBfYmF0Y2hWaWV3ID0gTWF0cml4LkNyZWF0ZVRyYW5zbGF0aW9uKHRyYW5zbGF0ZUJvZHkpICpcclxuICAgICAgICAgICAgICAgICAgICAgICAgIG1hdFJvdGF0aW9uICpcclxuICAgICAgICAgICAgICAgICAgICAgICAgIG1hdFpvb20gKlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgTWF0cml4LkNyZWF0ZVRyYW5zbGF0aW9uKHRyYW5zbGF0ZUNlbnRlcik7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIE1vdmVzIHRoZSBjYW1lcmEgZm9yd2FyZCBvbmUgdGltZXN0ZXAuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICBwdWJsaWMgdm9pZCBVcGRhdGUoR2FtZVRpbWUgZ2FtZVRpbWUpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBpZiAoX3RyYWNraW5nQm9keSAhPSBudWxsKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBpZiAoX3Bvc2l0aW9uVHJhY2tpbmcpXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgX3RhcmdldFBvc2l0aW9uID0gX3RyYWNraW5nQm9keS5Qb3NpdGlvbjtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoX21pblBvc2l0aW9uICE9IF9tYXhQb3NpdGlvbilcclxuICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIFZlY3RvcjIuQ2xhbXAocmVmIF90YXJnZXRQb3NpdGlvbiwgcmVmIF9taW5Qb3NpdGlvbiwgcmVmIF9tYXhQb3NpdGlvbiwgb3V0IF90YXJnZXRQb3NpdGlvbik7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKF9yb3RhdGlvblRyYWNraW5nKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIF90YXJnZXRSb3RhdGlvbiA9IC1fdHJhY2tpbmdCb2R5LlJvdGF0aW9uICUgTWF0aEhlbHBlci5Ud29QaTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoX21pblJvdGF0aW9uICE9IF9tYXhSb3RhdGlvbilcclxuICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF90YXJnZXRSb3RhdGlvbiA9IE1hdGhIZWxwZXIuQ2xhbXAoX3RhcmdldFJvdGF0aW9uLCBfbWluUm90YXRpb24sIF9tYXhSb3RhdGlvbik7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIFZlY3RvcjIgZGVsdGEgPSBfdGFyZ2V0UG9zaXRpb24gLSBfY3VycmVudFBvc2l0aW9uO1xyXG4gICAgICAgICAgICBmbG9hdCBkaXN0YW5jZSA9IGRlbHRhLkxlbmd0aCgpO1xyXG4gICAgICAgICAgICBpZiAoZGlzdGFuY2UgPiAwZilcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgZGVsdGEgLz0gZGlzdGFuY2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZmxvYXQgaW5lcnRpYTtcclxuICAgICAgICAgICAgaWYgKGRpc3RhbmNlIDwgMTBmKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBpbmVydGlhID0gKGZsb2F0KSBNYXRoLlBvdyhkaXN0YW5jZSAvIDEwLjAsIDIuMCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBpbmVydGlhID0gMWY7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGZsb2F0IHJvdERlbHRhID0gX3RhcmdldFJvdGF0aW9uIC0gX2N1cnJlbnRSb3RhdGlvbjtcclxuXHJcbiAgICAgICAgICAgIGZsb2F0IHJvdEluZXJ0aWE7XHJcbiAgICAgICAgICAgIGlmIChNYXRoLkFicyhyb3REZWx0YSkgPCA1ZilcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgcm90SW5lcnRpYSA9IChmbG9hdCkgTWF0aC5Qb3cocm90RGVsdGEgLyA1LjAsIDIuMCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICByb3RJbmVydGlhID0gMWY7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKE1hdGguQWJzKHJvdERlbHRhKSA+IDBmKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICByb3REZWx0YSAvPSAoZmxvYXQpTWF0aC5BYnMocm90RGVsdGEpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBfY3VycmVudFBvc2l0aW9uICs9IDEwMGYgKiBkZWx0YSAqIGluZXJ0aWEgKiAoZmxvYXQpIGdhbWVUaW1lLkVsYXBzZWRHYW1lVGltZS5Ub3RhbFNlY29uZHM7XHJcbiAgICAgICAgICAgIF9jdXJyZW50Um90YXRpb24gKz0gODBmICogcm90RGVsdGEgKiByb3RJbmVydGlhICogKGZsb2F0KSBnYW1lVGltZS5FbGFwc2VkR2FtZVRpbWUuVG90YWxTZWNvbmRzO1xyXG5cclxuICAgICAgICAgICAgU2V0VmlldygpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHVibGljIFZlY3RvcjIgQ29udmVydFNjcmVlblRvV29ybGQoVmVjdG9yMiBsb2NhdGlvbilcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIFZlY3RvcjMgdCA9IG5ldyBWZWN0b3IzKGxvY2F0aW9uLCAwKTtcclxuXHJcbiAgICAgICAgICAgIHQgPSBfZ3JhcGhpY3MuVmlld3BvcnQuVW5wcm9qZWN0KHQsIF9wcm9qZWN0aW9uLCBfdmlldywgTWF0cml4LklkZW50aXR5KTtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgVmVjdG9yMih0LlgsIHQuWSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwdWJsaWMgVmVjdG9yMiBDb252ZXJ0V29ybGRUb1NjcmVlbihWZWN0b3IyIGxvY2F0aW9uKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgVmVjdG9yMyB0ID0gbmV3IFZlY3RvcjMobG9jYXRpb24sIDApO1xyXG5cclxuICAgICAgICAgICAgdCA9IF9ncmFwaGljcy5WaWV3cG9ydC5Qcm9qZWN0KHQsIF9wcm9qZWN0aW9uLCBfdmlldywgTWF0cml4LklkZW50aXR5KTtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgVmVjdG9yMih0LlgsIHQuWSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59IiwidXNpbmcgU3lzdGVtO1xyXG51c2luZyBTeXN0ZW0uQ29sbGVjdGlvbnMuR2VuZXJpYztcclxudXNpbmcgU3lzdGVtLkxpbnE7XHJcbnVzaW5nIFN5c3RlbS5UZXh0O1xyXG51c2luZyBNaWNyb3NvZnQuWG5hLkZyYW1ld29yaztcclxudXNpbmcgTWljcm9zb2Z0LlhuYS5GcmFtZXdvcmsuQ29udGVudDtcclxudXNpbmcgTWljcm9zb2Z0LlhuYS5GcmFtZXdvcmsuR3JhcGhpY3M7XHJcbnVzaW5nIE1pY3Jvc29mdC5YbmEuRnJhbWV3b3JrLklucHV0O1xyXG51c2luZyBNaWNyb3NvZnQuWG5hLkZyYW1ld29yay5JbnB1dC5Ub3VjaDtcclxuXHJcbnVzaW5nIEZhcnNlZXJQaHlzaWNzLkNvbW1vbjtcclxudXNpbmcgRmFyc2VlclBoeXNpY3MuQ29tbW9uLkRlY29tcG9zaXRpb247XHJcbnVzaW5nIEZhcnNlZXJQaHlzaWNzLkNvbW1vbi5Qb2x5Z29uTWFuaXB1bGF0aW9uO1xyXG51c2luZyBGYXJzZWVyUGh5c2ljcy5EeW5hbWljcztcclxudXNpbmcgRmFyc2VlclBoeXNpY3MuRmFjdG9yaWVzO1xyXG51c2luZyBGYXJzZWVyUGh5c2ljcy5VdGlsaXR5O1xyXG5cclxubmFtZXNwYWNlIEZhcnNlZXJQaHlzaWNzLlV0aWxpdHlcclxue1xyXG4gICAgcHVibGljIHN0YXRpYyBjbGFzcyBDb21tb25cclxuICAgIHtcclxuXHJcbiAgICAgICAgcHVibGljIHN0YXRpYyBMaXN0PFZlcnRpY2VzPiBHZXRDb21wb3VuZFBvbHlnb25WZXJ0aWNlcyhUZXh0dXJlMkQgX3BvbHlnb25UZXh0dXJlLCBmbG9hdCBfc2NhbGUsIHJlZiBWZWN0b3IyIG9yaWdpbilcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHVpbnRbXSBkYXRhID0gbmV3IHVpbnRbX3BvbHlnb25UZXh0dXJlLldpZHRoICogX3BvbHlnb25UZXh0dXJlLkhlaWdodF07XHJcbiAgICAgICAgICAgIF9wb2x5Z29uVGV4dHVyZS5HZXREYXRhPHVpbnQ+KGRhdGEpO1xyXG5cclxuICAgICAgICAgICAgVmVydGljZXMgdGV4dHVyZVZlcnRpY2VzID0gUG9seWdvblRvb2xzLkNyZWF0ZVBvbHlnb24oZGF0YSwgX3BvbHlnb25UZXh0dXJlLldpZHRoLCBmYWxzZSk7XHJcblxyXG4gICAgICAgICAgICBWZWN0b3IyIGNlbnRyb2lkID0gLXRleHR1cmVWZXJ0aWNlcy5HZXRDZW50cm9pZCgpO1xyXG4gICAgICAgICAgICB0ZXh0dXJlVmVydGljZXMuVHJhbnNsYXRlKHJlZiBjZW50cm9pZCk7XHJcblxyXG4gICAgICAgICAgICBvcmlnaW4gPSAtY2VudHJvaWQ7XHJcblxyXG4gICAgICAgICAgICB0ZXh0dXJlVmVydGljZXMgPSBTaW1wbGlmeVRvb2xzLlJlZHVjZUJ5RGlzdGFuY2UodGV4dHVyZVZlcnRpY2VzLCA0Zik7XHJcblxyXG4gICAgICAgICAgICBMaXN0PFZlcnRpY2VzPiBsaXN0ID0gQmF5YXppdERlY29tcG9zZXIuQ29udmV4UGFydGl0aW9uKHRleHR1cmVWZXJ0aWNlcyk7XHJcblxyXG4gICAgICAgICAgICBWZWN0b3IyIHZlcnRTY2FsZSA9IG5ldyBWZWN0b3IyKENvbnZlcnRVbml0cy5Ub1NpbVVuaXRzKDEpKSAqIF9zY2FsZTtcclxuICAgICAgICAgICAgZm9yZWFjaCAoVmVydGljZXMgdmVydGljZXMgaW4gbGlzdClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdmVydGljZXMuU2NhbGUocmVmIHZlcnRTY2FsZSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHJldHVybiBsaXN0O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHVibGljIHN0YXRpYyBWZXJ0aWNlcyBHZXRQb2x5Z29uVmVydGljZXMoVGV4dHVyZTJEIF9wb2x5Z29uVGV4dHVyZSwgZmxvYXQgX3NjYWxlLCByZWYgVmVjdG9yMiBvcmlnaW4pXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB1aW50W10gZGF0YSA9IG5ldyB1aW50W19wb2x5Z29uVGV4dHVyZS5XaWR0aCAqIF9wb2x5Z29uVGV4dHVyZS5IZWlnaHRdO1xyXG4gICAgICAgICAgICBfcG9seWdvblRleHR1cmUuR2V0RGF0YTx1aW50PihkYXRhKTtcclxuXHJcbiAgICAgICAgICAgIFZlcnRpY2VzIHRleHR1cmVWZXJ0aWNlcyA9IFBvbHlnb25Ub29scy5DcmVhdGVQb2x5Z29uKGRhdGEsIF9wb2x5Z29uVGV4dHVyZS5XaWR0aCwgZmFsc2UpO1xyXG5cclxuICAgICAgICAgICAgVmVjdG9yMiBjZW50cm9pZCA9IC10ZXh0dXJlVmVydGljZXMuR2V0Q2VudHJvaWQoKTtcclxuICAgICAgICAgICAgdGV4dHVyZVZlcnRpY2VzLlRyYW5zbGF0ZShyZWYgY2VudHJvaWQpO1xyXG5cclxuICAgICAgICAgICAgb3JpZ2luID0gLWNlbnRyb2lkO1xyXG5cclxuICAgICAgICAgICAgdGV4dHVyZVZlcnRpY2VzID0gU2ltcGxpZnlUb29scy5Db2xsaW5lYXJTaW1wbGlmeSh0ZXh0dXJlVmVydGljZXMsIDEwZik7XHJcbiAgICAgICAgICAgIFZlY3RvcjIgdmVydFNjYWxlID0gbmV3IFZlY3RvcjIoQ29udmVydFVuaXRzLlRvU2ltVW5pdHMoMSkpICogX3NjYWxlO1xyXG4gICAgICAgICAgICB0ZXh0dXJlVmVydGljZXMuU2NhbGUocmVmIHZlcnRTY2FsZSk7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gdGV4dHVyZVZlcnRpY2VzO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHVibGljIHN0YXRpYyBDb2xvciBHZXRBbHBoYShmbG9hdCBvcGFjaXR5KVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBDb2xvcihvcGFjaXR5LCBvcGFjaXR5LCBvcGFjaXR5LCBvcGFjaXR5KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHB1YmxpYyBzdGF0aWMgYm9vbCBJc1JlY3RhbmdsZVRvdWNoKFZlY3RvcjIgcG9zaXRpb24sIFZlY3RvcjIgb3JpZ2luLCBmbG9hdCByZWN0V2lkdGgsIGZsb2F0IHJlY3RIZWlnaHQpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gKHBvc2l0aW9uLlggPj0gb3JpZ2luLlggLSByZWN0V2lkdGggLyAyICYmIHBvc2l0aW9uLlggPD0gb3JpZ2luLlggKyByZWN0V2lkdGggLyAyICYmXHJcbiAgICAgICAgICAgICAgICBwb3NpdGlvbi5ZID49IG9yaWdpbi5ZIC0gcmVjdEhlaWdodCAvIDIgJiYgcG9zaXRpb24uWSA8PSBvcmlnaW4uWSArIHJlY3RIZWlnaHQgLyAyKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuIiwidXNpbmcgTWljcm9zb2Z0LlhuYS5GcmFtZXdvcms7XHJcblxyXG5uYW1lc3BhY2UgRmFyc2VlclBoeXNpY3MuVXRpbGl0eVxyXG57XHJcbiAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAvLy8gQ29udmVydCB1bml0cyBiZXR3ZWVuIGRpc3BsYXkgYW5kIHNpbXVsYXRpb24gdW5pdHMuXHJcbiAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgcHVibGljIHN0YXRpYyBjbGFzcyBDb252ZXJ0VW5pdHNcclxuICAgIHtcclxuICAgICAgICBwcml2YXRlIHN0YXRpYyBmbG9hdCBfZGlzcGxheVVuaXRzVG9TaW1Vbml0c1JhdGlvID0gMTAwZjtcclxuICAgICAgICBwcml2YXRlIHN0YXRpYyBmbG9hdCBfc2ltVW5pdHNUb0Rpc3BsYXlVbml0c1JhdGlvID0gMSAvIF9kaXNwbGF5VW5pdHNUb1NpbVVuaXRzUmF0aW87XHJcblxyXG4gICAgICAgIHB1YmxpYyBzdGF0aWMgdm9pZCBTZXREaXNwbGF5VW5pdFRvU2ltVW5pdFJhdGlvKGZsb2F0IGRpc3BsYXlVbml0c1BlclNpbVVuaXQpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBfZGlzcGxheVVuaXRzVG9TaW1Vbml0c1JhdGlvID0gZGlzcGxheVVuaXRzUGVyU2ltVW5pdDtcclxuICAgICAgICAgICAgX3NpbVVuaXRzVG9EaXNwbGF5VW5pdHNSYXRpbyA9IDEgLyBkaXNwbGF5VW5pdHNQZXJTaW1Vbml0O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHVibGljIHN0YXRpYyBmbG9hdCBUb0Rpc3BsYXlVbml0cyhmbG9hdCBzaW1Vbml0cylcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiBzaW1Vbml0cyAqIF9kaXNwbGF5VW5pdHNUb1NpbVVuaXRzUmF0aW87XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwdWJsaWMgc3RhdGljIGZsb2F0IFRvRGlzcGxheVVuaXRzKGludCBzaW1Vbml0cylcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiBzaW1Vbml0cyAqIF9kaXNwbGF5VW5pdHNUb1NpbVVuaXRzUmF0aW87XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwdWJsaWMgc3RhdGljIFZlY3RvcjIgVG9EaXNwbGF5VW5pdHMoVmVjdG9yMiBzaW1Vbml0cylcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiBzaW1Vbml0cyAqIF9kaXNwbGF5VW5pdHNUb1NpbVVuaXRzUmF0aW87XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwdWJsaWMgc3RhdGljIHZvaWQgVG9EaXNwbGF5VW5pdHMocmVmIFZlY3RvcjIgc2ltVW5pdHMsIG91dCBWZWN0b3IyIGRpc3BsYXlVbml0cylcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIFZlY3RvcjIuTXVsdGlwbHkocmVmIHNpbVVuaXRzLCBfZGlzcGxheVVuaXRzVG9TaW1Vbml0c1JhdGlvLCBvdXQgZGlzcGxheVVuaXRzKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHB1YmxpYyBzdGF0aWMgVmVjdG9yMyBUb0Rpc3BsYXlVbml0cyhWZWN0b3IzIHNpbVVuaXRzKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIHNpbVVuaXRzICogX2Rpc3BsYXlVbml0c1RvU2ltVW5pdHNSYXRpbztcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHB1YmxpYyBzdGF0aWMgVmVjdG9yMiBUb0Rpc3BsYXlVbml0cyhmbG9hdCB4LCBmbG9hdCB5KVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBWZWN0b3IyKHgsIHkpICogX2Rpc3BsYXlVbml0c1RvU2ltVW5pdHNSYXRpbztcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHB1YmxpYyBzdGF0aWMgdm9pZCBUb0Rpc3BsYXlVbml0cyhmbG9hdCB4LCBmbG9hdCB5LCBvdXQgVmVjdG9yMiBkaXNwbGF5VW5pdHMpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBkaXNwbGF5VW5pdHMgPSBWZWN0b3IyLlplcm87XHJcbiAgICAgICAgICAgIGRpc3BsYXlVbml0cy5YID0geCAqIF9kaXNwbGF5VW5pdHNUb1NpbVVuaXRzUmF0aW87XHJcbiAgICAgICAgICAgIGRpc3BsYXlVbml0cy5ZID0geSAqIF9kaXNwbGF5VW5pdHNUb1NpbVVuaXRzUmF0aW87XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwdWJsaWMgc3RhdGljIGZsb2F0IFRvU2ltVW5pdHMoZmxvYXQgZGlzcGxheVVuaXRzKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIGRpc3BsYXlVbml0cyAqIF9zaW1Vbml0c1RvRGlzcGxheVVuaXRzUmF0aW87XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwdWJsaWMgc3RhdGljIGZsb2F0IFRvU2ltVW5pdHMoZG91YmxlIGRpc3BsYXlVbml0cylcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiAoZmxvYXQpZGlzcGxheVVuaXRzICogX3NpbVVuaXRzVG9EaXNwbGF5VW5pdHNSYXRpbztcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHB1YmxpYyBzdGF0aWMgZmxvYXQgVG9TaW1Vbml0cyhpbnQgZGlzcGxheVVuaXRzKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIGRpc3BsYXlVbml0cyAqIF9zaW1Vbml0c1RvRGlzcGxheVVuaXRzUmF0aW87XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwdWJsaWMgc3RhdGljIFZlY3RvcjIgVG9TaW1Vbml0cyhWZWN0b3IyIGRpc3BsYXlVbml0cylcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiBkaXNwbGF5VW5pdHMgKiBfc2ltVW5pdHNUb0Rpc3BsYXlVbml0c1JhdGlvO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHVibGljIHN0YXRpYyBWZWN0b3IzIFRvU2ltVW5pdHMoVmVjdG9yMyBkaXNwbGF5VW5pdHMpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gZGlzcGxheVVuaXRzICogX3NpbVVuaXRzVG9EaXNwbGF5VW5pdHNSYXRpbztcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHB1YmxpYyBzdGF0aWMgdm9pZCBUb1NpbVVuaXRzKHJlZiBWZWN0b3IyIGRpc3BsYXlVbml0cywgb3V0IFZlY3RvcjIgc2ltVW5pdHMpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBWZWN0b3IyLk11bHRpcGx5KHJlZiBkaXNwbGF5VW5pdHMsIF9zaW1Vbml0c1RvRGlzcGxheVVuaXRzUmF0aW8sIG91dCBzaW1Vbml0cyk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwdWJsaWMgc3RhdGljIFZlY3RvcjIgVG9TaW1Vbml0cyhmbG9hdCB4LCBmbG9hdCB5KVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBWZWN0b3IyKHgsIHkpICogX3NpbVVuaXRzVG9EaXNwbGF5VW5pdHNSYXRpbztcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHB1YmxpYyBzdGF0aWMgVmVjdG9yMiBUb1NpbVVuaXRzKGRvdWJsZSB4LCBkb3VibGUgeSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgVmVjdG9yMigoZmxvYXQpeCwgKGZsb2F0KXkpICogX3NpbVVuaXRzVG9EaXNwbGF5VW5pdHNSYXRpbztcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHB1YmxpYyBzdGF0aWMgdm9pZCBUb1NpbVVuaXRzKGZsb2F0IHgsIGZsb2F0IHksIG91dCBWZWN0b3IyIHNpbVVuaXRzKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgc2ltVW5pdHMgPSBWZWN0b3IyLlplcm87XHJcbiAgICAgICAgICAgIHNpbVVuaXRzLlggPSB4ICogX3NpbVVuaXRzVG9EaXNwbGF5VW5pdHNSYXRpbztcclxuICAgICAgICAgICAgc2ltVW5pdHMuWSA9IHkgKiBfc2ltVW5pdHNUb0Rpc3BsYXlVbml0c1JhdGlvO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufSIsIiNyZWdpb24gRmlsZSBEZXNjcmlwdGlvblxyXG5cclxuLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4vLyBQbGF5ZXJJbmRleEV2ZW50QXJncy5jc1xyXG4vL1xyXG4vLyBYTkEgQ29tbXVuaXR5IEdhbWUgUGxhdGZvcm1cclxuLy8gQ29weXJpZ2h0IChDKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbi8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuXHJcbiNlbmRyZWdpb25cclxuXHJcbnVzaW5nIFN5c3RlbTtcclxudXNpbmcgTWljcm9zb2Z0LlhuYS5GcmFtZXdvcms7XHJcbnVzaW5nIE1pY3Jvc29mdC5YbmEuRnJhbWV3b3JrLklucHV0LlRvdWNoO1xyXG5cclxubmFtZXNwYWNlIEZhcnNlZXJQaHlzaWNzLlV0aWxpdHlcclxue1xyXG4gICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgLy8vIEVudW0gZGVzY3JpYmVzIHRoZSBzY3JlZW4gdHJhbnNpdGlvbiBzdGF0ZS5cclxuICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICBwdWJsaWMgZW51bSBTY3JlZW5TdGF0ZVxyXG4gICAge1xyXG4gICAgICAgIFRyYW5zaXRpb25PbixcclxuICAgICAgICBBY3RpdmUsXHJcbiAgICAgICAgVHJhbnNpdGlvbk9mZixcclxuICAgICAgICBIaWRkZW4sXHJcbiAgICB9XHJcblxyXG4gICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgLy8vIEEgc2NyZWVuIGlzIGEgc2luZ2xlIGxheWVyIHRoYXQgaGFzIHVwZGF0ZSBhbmQgZHJhdyBsb2dpYywgYW5kIHdoaWNoXHJcbiAgICAvLy8gY2FuIGJlIGNvbWJpbmVkIHdpdGggb3RoZXIgbGF5ZXJzIHRvIGJ1aWxkIHVwIGEgY29tcGxleCBtZW51IHN5c3RlbS5cclxuICAgIC8vLyBGb3IgaW5zdGFuY2UgdGhlIG1haW4gbWVudSwgdGhlIG9wdGlvbnMgbWVudSwgdGhlIFwiYXJlIHlvdSBzdXJlIHlvdVxyXG4gICAgLy8vIHdhbnQgdG8gcXVpdFwiIG1lc3NhZ2UgYm94LCBhbmQgdGhlIG1haW4gZ2FtZSBpdHNlbGYgYXJlIGFsbCBpbXBsZW1lbnRlZFxyXG4gICAgLy8vIGFzIHNjcmVlbnMuXHJcbiAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgcHVibGljIGFic3RyYWN0IGNsYXNzIEdhbWVTY3JlZW5cclxuICAgIHtcclxuICAgICAgICBwcml2YXRlIEdlc3R1cmVUeXBlIF9lbmFibGVkR2VzdHVyZXMgPSBHZXN0dXJlVHlwZS5Ob25lO1xyXG4gICAgICAgIHByaXZhdGUgYm9vbCBfb3RoZXJTY3JlZW5IYXNGb2N1cztcclxuXHJcbiAgICAgICAgcHVibGljIEdhbWVTY3JlZW4oKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgU2NyZWVuU3RhdGUgPSBTY3JlZW5TdGF0ZS5UcmFuc2l0aW9uT247XHJcbiAgICAgICAgICAgIFRyYW5zaXRpb25Qb3NpdGlvbiA9IDE7XHJcbiAgICAgICAgICAgIFRyYW5zaXRpb25PZmZUaW1lID0gVGltZVNwYW4uWmVybztcclxuICAgICAgICAgICAgVHJhbnNpdGlvbk9uVGltZSA9IFRpbWVTcGFuLlplcm87XHJcbiAgICAgICAgICAgIEhhc0N1cnNvciA9IGZhbHNlO1xyXG4gICAgICAgICAgICBIYXNWaXJ0dWFsU3RpY2sgPSBmYWxzZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHB1YmxpYyBib29sIEhhc0N1cnNvciB7IGdldDsgc2V0OyB9XHJcblxyXG4gICAgICAgIHB1YmxpYyBib29sIEhhc1ZpcnR1YWxTdGljayB7IGdldDsgc2V0OyB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gTm9ybWFsbHkgd2hlbiBvbmUgc2NyZWVuIGlzIGJyb3VnaHQgdXAgb3ZlciB0aGUgdG9wIG9mIGFub3RoZXIsXHJcbiAgICAgICAgLy8vIHRoZSBmaXJzdCBzY3JlZW4gd2lsbCB0cmFuc2l0aW9uIG9mZiB0byBtYWtlIHJvb20gZm9yIHRoZSBuZXdcclxuICAgICAgICAvLy8gb25lLiBUaGlzIHByb3BlcnR5IGluZGljYXRlcyB3aGV0aGVyIHRoZSBzY3JlZW4gaXMgb25seSBhIHNtYWxsXHJcbiAgICAgICAgLy8vIHBvcHVwLCBpbiB3aGljaCBjYXNlIHNjcmVlbnMgdW5kZXJuZWF0aCBpdCBkbyBub3QgbmVlZCB0byBib3RoZXJcclxuICAgICAgICAvLy8gdHJhbnNpdGlvbmluZyBvZmYuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICBwdWJsaWMgYm9vbCBJc1BvcHVwIHsgZ2V0OyBwcm90ZWN0ZWQgc2V0OyB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gSW5kaWNhdGVzIGhvdyBsb25nIHRoZSBzY3JlZW4gdGFrZXMgdG9cclxuICAgICAgICAvLy8gdHJhbnNpdGlvbiBvbiB3aGVuIGl0IGlzIGFjdGl2YXRlZC5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIHB1YmxpYyBUaW1lU3BhbiBUcmFuc2l0aW9uT25UaW1lIHsgZ2V0OyBwcm90ZWN0ZWQgc2V0OyB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gSW5kaWNhdGVzIGhvdyBsb25nIHRoZSBzY3JlZW4gdGFrZXMgdG9cclxuICAgICAgICAvLy8gdHJhbnNpdGlvbiBvZmYgd2hlbiBpdCBpcyBkZWFjdGl2YXRlZC5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIHB1YmxpYyBUaW1lU3BhbiBUcmFuc2l0aW9uT2ZmVGltZSB7IGdldDsgcHJvdGVjdGVkIHNldDsgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIEdldHMgdGhlIGN1cnJlbnQgcG9zaXRpb24gb2YgdGhlIHNjcmVlbiB0cmFuc2l0aW9uLCByYW5naW5nXHJcbiAgICAgICAgLy8vIGZyb20gemVybyAoZnVsbHkgYWN0aXZlLCBubyB0cmFuc2l0aW9uKSB0byBvbmUgKHRyYW5zaXRpb25lZFxyXG4gICAgICAgIC8vLyBmdWxseSBvZmYgdG8gbm90aGluZykuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICBwdWJsaWMgZmxvYXQgVHJhbnNpdGlvblBvc2l0aW9uIHsgZ2V0OyBwcm90ZWN0ZWQgc2V0OyB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gR2V0cyB0aGUgY3VycmVudCBhbHBoYSBvZiB0aGUgc2NyZWVuIHRyYW5zaXRpb24sIHJhbmdpbmdcclxuICAgICAgICAvLy8gZnJvbSAxIChmdWxseSBhY3RpdmUsIG5vIHRyYW5zaXRpb24pIHRvIDAgKHRyYW5zaXRpb25lZFxyXG4gICAgICAgIC8vLyBmdWxseSBvZmYgdG8gbm90aGluZykuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICBwdWJsaWMgZmxvYXQgVHJhbnNpdGlvbkFscGhhXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBnZXQgeyByZXR1cm4gMWYgLSBUcmFuc2l0aW9uUG9zaXRpb247IH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gR2V0cyB0aGUgY3VycmVudCBzY3JlZW4gdHJhbnNpdGlvbiBzdGF0ZS5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIHB1YmxpYyBTY3JlZW5TdGF0ZSBTY3JlZW5TdGF0ZSB7IGdldDsgcHJvdGVjdGVkIHNldDsgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIFRoZXJlIGFyZSB0d28gcG9zc2libGUgcmVhc29ucyB3aHkgYSBzY3JlZW4gbWlnaHQgYmUgdHJhbnNpdGlvbmluZ1xyXG4gICAgICAgIC8vLyBvZmYuIEl0IGNvdWxkIGJlIHRlbXBvcmFyaWx5IGdvaW5nIGF3YXkgdG8gbWFrZSByb29tIGZvciBhbm90aGVyXHJcbiAgICAgICAgLy8vIHNjcmVlbiB0aGF0IGlzIG9uIHRvcCBvZiBpdCwgb3IgaXQgY291bGQgYmUgZ29pbmcgYXdheSBmb3IgZ29vZC5cclxuICAgICAgICAvLy8gVGhpcyBwcm9wZXJ0eSBpbmRpY2F0ZXMgd2hldGhlciB0aGUgc2NyZWVuIGlzIGV4aXRpbmcgZm9yIHJlYWw6XHJcbiAgICAgICAgLy8vIGlmIHNldCwgdGhlIHNjcmVlbiB3aWxsIGF1dG9tYXRpY2FsbHkgcmVtb3ZlIGl0c2VsZiBhcyBzb29uIGFzIHRoZVxyXG4gICAgICAgIC8vLyB0cmFuc2l0aW9uIGZpbmlzaGVzLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgcHVibGljIGJvb2wgSXNFeGl0aW5nIHsgZ2V0OyBwcm90ZWN0ZWQgaW50ZXJuYWwgc2V0OyB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gQ2hlY2tzIHdoZXRoZXIgdGhpcyBzY3JlZW4gaXMgYWN0aXZlIGFuZCBjYW4gcmVzcG9uZCB0byB1c2VyIGlucHV0LlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgcHVibGljIGJvb2wgSXNBY3RpdmVcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGdldFxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gIV9vdGhlclNjcmVlbkhhc0ZvY3VzICYmXHJcbiAgICAgICAgICAgICAgICAgICAgICAgKFNjcmVlblN0YXRlID09IFNjcmVlblN0YXRlLlRyYW5zaXRpb25PbiB8fFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBTY3JlZW5TdGF0ZSA9PSBTY3JlZW5TdGF0ZS5BY3RpdmUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIEdldHMgdGhlIG1hbmFnZXIgdGhhdCB0aGlzIHNjcmVlbiBiZWxvbmdzIHRvLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgcHVibGljIFNjcmVlbk1hbmFnZXIgU2NyZWVuTWFuYWdlciB7IGdldDsgaW50ZXJuYWwgc2V0OyB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gR2V0cyB0aGUgZ2VzdHVyZXMgdGhlIHNjcmVlbiBpcyBpbnRlcmVzdGVkIGluLiBTY3JlZW5zIHNob3VsZCBiZSBhcyBzcGVjaWZpY1xyXG4gICAgICAgIC8vLyBhcyBwb3NzaWJsZSB3aXRoIGdlc3R1cmVzIHRvIGluY3JlYXNlIHRoZSBhY2N1cmFjeSBvZiB0aGUgZ2VzdHVyZSBlbmdpbmUuXHJcbiAgICAgICAgLy8vIEZvciBleGFtcGxlLCBtb3N0IG1lbnVzIG9ubHkgbmVlZCBUYXAgb3IgcGVyaGFwcyBUYXAgYW5kIFZlcnRpY2FsRHJhZyB0byBvcGVyYXRlLlxyXG4gICAgICAgIC8vLyBUaGVzZSBnZXN0dXJlcyBhcmUgaGFuZGxlZCBieSB0aGUgU2NyZWVuTWFuYWdlciB3aGVuIHNjcmVlbnMgY2hhbmdlIGFuZFxyXG4gICAgICAgIC8vLyBhbGwgZ2VzdHVyZXMgYXJlIHBsYWNlZCBpbiB0aGUgSW5wdXRTdGF0ZSBwYXNzZWQgdG8gdGhlIEhhbmRsZUlucHV0IG1ldGhvZC5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIHB1YmxpYyBHZXN0dXJlVHlwZSBFbmFibGVkR2VzdHVyZXNcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGdldCB7IHJldHVybiBfZW5hYmxlZEdlc3R1cmVzOyB9XHJcbiAgICAgICAgICAgIHByb3RlY3RlZCBzZXRcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgX2VuYWJsZWRHZXN0dXJlcyA9IHZhbHVlO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIHRoZSBzY3JlZW4gbWFuYWdlciBoYW5kbGVzIHRoaXMgZHVyaW5nIHNjcmVlbiBjaGFuZ2VzLCBidXRcclxuICAgICAgICAgICAgICAgIC8vIGlmIHRoaXMgc2NyZWVuIGlzIGFjdGl2ZSBhbmQgdGhlIGdlc3R1cmUgdHlwZXMgYXJlIGNoYW5naW5nLFxyXG4gICAgICAgICAgICAgICAgLy8gd2UgaGF2ZSB0byB1cGRhdGUgdGhlIFRvdWNoUGFuZWwgb3Vyc2VsZi5cclxuICAgICAgICAgICAgICAgIGlmIChTY3JlZW5TdGF0ZSA9PSBTY3JlZW5TdGF0ZS5BY3RpdmUpXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgVG91Y2hQYW5lbC5FbmFibGVkR2VzdHVyZXMgPSB2YWx1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBMb2FkIGdyYXBoaWNzIGNvbnRlbnQgZm9yIHRoZSBzY3JlZW4uXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICBwdWJsaWMgdmlydHVhbCB2b2lkIExvYWRDb250ZW50KClcclxuICAgICAgICB7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIFVubG9hZCBjb250ZW50IGZvciB0aGUgc2NyZWVuLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgcHVibGljIHZpcnR1YWwgdm9pZCBVbmxvYWRDb250ZW50KClcclxuICAgICAgICB7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIEFsbG93cyB0aGUgc2NyZWVuIHRvIHJ1biBsb2dpYywgc3VjaCBhcyB1cGRhdGluZyB0aGUgdHJhbnNpdGlvbiBwb3NpdGlvbi5cclxuICAgICAgICAvLy8gVW5saWtlIEhhbmRsZUlucHV0LCB0aGlzIG1ldGhvZCBpcyBjYWxsZWQgcmVnYXJkbGVzcyBvZiB3aGV0aGVyIHRoZSBzY3JlZW5cclxuICAgICAgICAvLy8gaXMgYWN0aXZlLCBoaWRkZW4sIG9yIGluIHRoZSBtaWRkbGUgb2YgYSB0cmFuc2l0aW9uLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgcHVibGljIHZpcnR1YWwgdm9pZCBVcGRhdGUoR2FtZVRpbWUgZ2FtZVRpbWUsIGJvb2wgb3RoZXJTY3JlZW5IYXNGb2N1cyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBib29sIGNvdmVyZWRCeU90aGVyU2NyZWVuKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgX290aGVyU2NyZWVuSGFzRm9jdXMgPSBvdGhlclNjcmVlbkhhc0ZvY3VzO1xyXG4gICAgICAgICAgICBpZiAoSXNFeGl0aW5nKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAvLyBJZiB0aGUgc2NyZWVuIGlzIGdvaW5nIGF3YXkgdG8gZGllLCBpdCBzaG91bGQgdHJhbnNpdGlvbiBvZmYuXHJcbiAgICAgICAgICAgICAgICBTY3JlZW5TdGF0ZSA9IFNjcmVlblN0YXRlLlRyYW5zaXRpb25PZmY7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKCFVcGRhdGVUcmFuc2l0aW9uKGdhbWVUaW1lLCBUcmFuc2l0aW9uT2ZmVGltZSwgMSkpXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gV2hlbiB0aGUgdHJhbnNpdGlvbiBmaW5pc2hlcywgcmVtb3ZlIHRoZSBzY3JlZW4uXHJcbiAgICAgICAgICAgICAgICAgICAgU2NyZWVuTWFuYWdlci5SZW1vdmVTY3JlZW4odGhpcyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoY292ZXJlZEJ5T3RoZXJTY3JlZW4pXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIC8vIElmIHRoZSBzY3JlZW4gaXMgY292ZXJlZCBieSBhbm90aGVyLCBpdCBzaG91bGQgdHJhbnNpdGlvbiBvZmYuXHJcbiAgICAgICAgICAgICAgICBpZiAoVXBkYXRlVHJhbnNpdGlvbihnYW1lVGltZSwgVHJhbnNpdGlvbk9mZlRpbWUsIDEpKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIFN0aWxsIGJ1c3kgdHJhbnNpdGlvbmluZy5cclxuICAgICAgICAgICAgICAgICAgICBTY3JlZW5TdGF0ZSA9IFNjcmVlblN0YXRlLlRyYW5zaXRpb25PZmY7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gVHJhbnNpdGlvbiBmaW5pc2hlZCFcclxuICAgICAgICAgICAgICAgICAgICBTY3JlZW5TdGF0ZSA9IFNjcmVlblN0YXRlLkhpZGRlbjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIC8vIE90aGVyd2lzZSB0aGUgc2NyZWVuIHNob3VsZCB0cmFuc2l0aW9uIG9uIGFuZCBiZWNvbWUgYWN0aXZlLlxyXG4gICAgICAgICAgICAgICAgaWYgKFVwZGF0ZVRyYW5zaXRpb24oZ2FtZVRpbWUsIFRyYW5zaXRpb25PblRpbWUsIC0xKSlcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBTdGlsbCBidXN5IHRyYW5zaXRpb25pbmcuXHJcbiAgICAgICAgICAgICAgICAgICAgU2NyZWVuU3RhdGUgPSBTY3JlZW5TdGF0ZS5UcmFuc2l0aW9uT247XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gVHJhbnNpdGlvbiBmaW5pc2hlZCFcclxuICAgICAgICAgICAgICAgICAgICBTY3JlZW5TdGF0ZSA9IFNjcmVlblN0YXRlLkFjdGl2ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBIZWxwZXIgZm9yIHVwZGF0aW5nIHRoZSBzY3JlZW4gdHJhbnNpdGlvbiBwb3NpdGlvbi5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIHByaXZhdGUgYm9vbCBVcGRhdGVUcmFuc2l0aW9uKEdhbWVUaW1lIGdhbWVUaW1lLCBUaW1lU3BhbiB0aW1lLCBpbnQgZGlyZWN0aW9uKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgLy8gSG93IG11Y2ggc2hvdWxkIHdlIG1vdmUgYnk/XHJcbiAgICAgICAgICAgIGZsb2F0IHRyYW5zaXRpb25EZWx0YTtcclxuXHJcbiAgICAgICAgICAgIGlmICh0aW1lID09IFRpbWVTcGFuLlplcm8pXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHRyYW5zaXRpb25EZWx0YSA9IDFmO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdHJhbnNpdGlvbkRlbHRhID0gKGZsb2F0KShnYW1lVGltZS5FbGFwc2VkR2FtZVRpbWUuVG90YWxNaWxsaXNlY29uZHMgL1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGltZS5Ub3RhbE1pbGxpc2Vjb25kcyk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIFVwZGF0ZSB0aGUgdHJhbnNpdGlvbiBwb3NpdGlvbi5cclxuICAgICAgICAgICAgVHJhbnNpdGlvblBvc2l0aW9uICs9IHRyYW5zaXRpb25EZWx0YSAqIGRpcmVjdGlvbjtcclxuXHJcbiAgICAgICAgICAgIC8vIERpZCB3ZSByZWFjaCB0aGUgZW5kIG9mIHRoZSB0cmFuc2l0aW9uP1xyXG4gICAgICAgICAgICBpZiAoKChkaXJlY3Rpb24gPCAwKSAmJiAoVHJhbnNpdGlvblBvc2l0aW9uIDw9IDApKSB8fFxyXG4gICAgICAgICAgICAgICAgKChkaXJlY3Rpb24gPiAwKSAmJiAoVHJhbnNpdGlvblBvc2l0aW9uID49IDEpKSlcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgVHJhbnNpdGlvblBvc2l0aW9uID0gTWF0aEhlbHBlci5DbGFtcChUcmFuc2l0aW9uUG9zaXRpb24sIDAsIDEpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBPdGhlcndpc2Ugd2UgYXJlIHN0aWxsIGJ1c3kgdHJhbnNpdGlvbmluZy5cclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIFRoaXMgaXMgY2FsbGVkIHdoZW4gdGhlIHNjcmVlbiBzaG91bGQgZHJhdyBpdHNlbGYuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICBwdWJsaWMgdmlydHVhbCB2b2lkIERyYXcoR2FtZVRpbWUgZ2FtZVRpbWUpXHJcbiAgICAgICAge1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBUZWxscyB0aGUgc2NyZWVuIHRvIGdvIGF3YXkuIFVubGlrZSBTY3JlZW5NYW5hZ2VyLlJlbW92ZVNjcmVlbiwgd2hpY2hcclxuICAgICAgICAvLy8gaW5zdGFudGx5IGtpbGxzIHRoZSBzY3JlZW4sIHRoaXMgbWV0aG9kIHJlc3BlY3RzIHRoZSB0cmFuc2l0aW9uIHRpbWluZ3NcclxuICAgICAgICAvLy8gYW5kIHdpbGwgZ2l2ZSB0aGUgc2NyZWVuIGEgY2hhbmNlIHRvIGdyYWR1YWxseSB0cmFuc2l0aW9uIG9mZi5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIHB1YmxpYyB2b2lkIEV4aXRTY3JlZW4oKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgaWYgKFRyYW5zaXRpb25PZmZUaW1lID09IFRpbWVTcGFuLlplcm8pXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIC8vIElmIHRoZSBzY3JlZW4gaGFzIGEgemVybyB0cmFuc2l0aW9uIHRpbWUsIHJlbW92ZSBpdCBpbW1lZGlhdGVseS5cclxuICAgICAgICAgICAgICAgIFNjcmVlbk1hbmFnZXIuUmVtb3ZlU2NyZWVuKHRoaXMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgLy8gT3RoZXJ3aXNlIGZsYWcgdGhhdCBpdCBzaG91bGQgdHJhbnNpdGlvbiBvZmYgYW5kIHRoZW4gZXhpdC5cclxuICAgICAgICAgICAgICAgIElzRXhpdGluZyA9IHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbn0iLCJ1c2luZyBTeXN0ZW0uQ29sbGVjdGlvbnMuR2VuZXJpYztcclxudXNpbmcgTWljcm9zb2Z0LlhuYS5GcmFtZXdvcms7XHJcbnVzaW5nIE1pY3Jvc29mdC5YbmEuRnJhbWV3b3JrLkNvbnRlbnQ7XHJcbnVzaW5nIE1pY3Jvc29mdC5YbmEuRnJhbWV3b3JrLkdyYXBoaWNzO1xyXG51c2luZyBNaWNyb3NvZnQuWG5hLkZyYW1ld29yay5JbnB1dC5Ub3VjaDtcclxuXHJcbm5hbWVzcGFjZSBGYXJzZWVyUGh5c2ljcy5VdGlsaXR5XHJcbntcclxuICAgIC8vLyA8c3VtbWFyeT5cclxuICAgIC8vLyBUaGUgc2NyZWVuIG1hbmFnZXIgaXMgYSBjb21wb25lbnQgd2hpY2ggbWFuYWdlcyBvbmUgb3IgbW9yZSBHYW1lU2NyZWVuXHJcbiAgICAvLy8gaW5zdGFuY2VzLiBJdCBtYWludGFpbnMgYSBzdGFjayBvZiBzY3JlZW5zLCBjYWxscyB0aGVpciBVcGRhdGUgYW5kIERyYXdcclxuICAgIC8vLyBtZXRob2RzIGF0IHRoZSBhcHByb3ByaWF0ZSB0aW1lcywgYW5kIGF1dG9tYXRpY2FsbHkgcm91dGVzIGlucHV0IHRvIHRoZVxyXG4gICAgLy8vIHRvcG1vc3QgYWN0aXZlIHNjcmVlbi5cclxuICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICBwdWJsaWMgY2xhc3MgU2NyZWVuTWFuYWdlciA6IERyYXdhYmxlR2FtZUNvbXBvbmVudFxyXG4gICAge1xyXG4gICAgICAgIHByaXZhdGUgQ29udGVudE1hbmFnZXIgX2NvbnRlbnRNYW5hZ2VyO1xyXG5cclxuICAgICAgICBwcml2YXRlIGJvb2wgX2lzSW5pdGlhbGl6ZWQ7XHJcblxyXG4gICAgICAgIHByaXZhdGUgTGlzdDxHYW1lU2NyZWVuPiBfc2NyZWVucztcclxuICAgICAgICBwcml2YXRlIExpc3Q8R2FtZVNjcmVlbj4gX3NjcmVlbnNUb1VwZGF0ZTtcclxuXHJcbiAgICAgICAgcHJpdmF0ZSBTcHJpdGVCYXRjaCBfc3ByaXRlQmF0Y2g7XHJcblxyXG5cclxuICAgICAgICBwcml2YXRlIExpc3Q8UmVuZGVyVGFyZ2V0MkQ+IF90cmFuc2l0aW9ucztcclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBDb25zdHJ1Y3RzIGEgbmV3IHNjcmVlbiBtYW5hZ2VyIGNvbXBvbmVudC5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIHB1YmxpYyBTY3JlZW5NYW5hZ2VyKEdhbWUgZ2FtZSlcclxuICAgICAgICAgICAgOiBiYXNlKGdhbWUpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICAvLyB3ZSBtdXN0IHNldCBFbmFibGVkR2VzdHVyZXMgYmVmb3JlIHdlIGNhbiBxdWVyeSBmb3IgdGhlbSwgYnV0XHJcbiAgICAgICAgICAgIC8vIHdlIGRvbid0IGFzc3VtZSB0aGUgZ2FtZSB3YW50cyB0byByZWFkIHRoZW0uXHJcbiAgICAgICAgICAgIFRvdWNoUGFuZWwuRW5hYmxlZEdlc3R1cmVzID0gR2VzdHVyZVR5cGUuTm9uZTtcclxuICAgICAgICAgICAgX2NvbnRlbnRNYW5hZ2VyID0gZ2FtZS5Db250ZW50O1xyXG4gICAgICAgICAgICBfY29udGVudE1hbmFnZXIuUm9vdERpcmVjdG9yeSA9IFwiQ29udGVudFwiO1xyXG5cclxuICAgICAgICAgICAgX3NjcmVlbnMgPSBuZXcgTGlzdDxHYW1lU2NyZWVuPigpO1xyXG4gICAgICAgICAgICBfc2NyZWVuc1RvVXBkYXRlID0gbmV3IExpc3Q8R2FtZVNjcmVlbj4oKTtcclxuICAgICAgICAgICAgX3RyYW5zaXRpb25zID0gbmV3IExpc3Q8UmVuZGVyVGFyZ2V0MkQ+KCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIEEgZGVmYXVsdCBTcHJpdGVCYXRjaCBzaGFyZWQgYnkgYWxsIHRoZSBzY3JlZW5zLiBUaGlzIHNhdmVzXHJcbiAgICAgICAgLy8vIGVhY2ggc2NyZWVuIGhhdmluZyB0byBib3RoZXIgY3JlYXRpbmcgdGhlaXIgb3duIGxvY2FsIGluc3RhbmNlLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgcHVibGljIFNwcml0ZUJhdGNoIFNwcml0ZUJhdGNoXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBnZXQgeyByZXR1cm4gX3Nwcml0ZUJhdGNoOyB9XHJcbiAgICAgICAgfVxyXG5cclxuXHJcbiAgICAgICAgcHVibGljIENvbnRlbnRNYW5hZ2VyIENvbnRlbnRcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGdldCB7IHJldHVybiBfY29udGVudE1hbmFnZXI7IH1cclxuICAgICAgICB9XHJcblxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIEluaXRpYWxpemVzIHRoZSBzY3JlZW4gbWFuYWdlciBjb21wb25lbnQuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICBwdWJsaWMgb3ZlcnJpZGUgdm9pZCBJbml0aWFsaXplKClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIC8vX3Nwcml0ZUZvbnRzID0gbmV3IFNwcml0ZUZvbnRzKF9jb250ZW50TWFuYWdlcik7XHJcbiAgICAgICAgICAgIGJhc2UuSW5pdGlhbGl6ZSgpO1xyXG5cclxuICAgICAgICAgICAgX2lzSW5pdGlhbGl6ZWQgPSB0cnVlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBMb2FkIHlvdXIgZ3JhcGhpY3MgY29udGVudC5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIHByb3RlY3RlZCBvdmVycmlkZSB2b2lkIExvYWRDb250ZW50KClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIF9zcHJpdGVCYXRjaCA9IG5ldyBTcHJpdGVCYXRjaChHcmFwaGljc0RldmljZSk7XHJcblxyXG4gICAgICAgICAgICAvLyBUZWxsIGVhY2ggb2YgdGhlIHNjcmVlbnMgdG8gbG9hZCB0aGVpciBjb250ZW50LlxyXG4gICAgICAgICAgICBmb3JlYWNoIChHYW1lU2NyZWVuIHNjcmVlbiBpbiBfc2NyZWVucylcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgc2NyZWVuLkxvYWRDb250ZW50KCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gVW5sb2FkIHlvdXIgZ3JhcGhpY3MgY29udGVudC5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIHByb3RlY3RlZCBvdmVycmlkZSB2b2lkIFVubG9hZENvbnRlbnQoKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgLy8gVGVsbCBlYWNoIG9mIHRoZSBzY3JlZW5zIHRvIHVubG9hZCB0aGVpciBjb250ZW50LlxyXG4gICAgICAgICAgICBmb3JlYWNoIChHYW1lU2NyZWVuIHNjcmVlbiBpbiBfc2NyZWVucylcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgc2NyZWVuLlVubG9hZENvbnRlbnQoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBBbGxvd3MgZWFjaCBzY3JlZW4gdG8gcnVuIGxvZ2ljLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgcHVibGljIG92ZXJyaWRlIHZvaWQgVXBkYXRlKEdhbWVUaW1lIGdhbWVUaW1lKVxyXG4gICAgICAgIHtcclxuXHJcbiAgICAgICAgICAgIC8vIE1ha2UgYSBjb3B5IG9mIHRoZSBtYXN0ZXIgc2NyZWVuIGxpc3QsIHRvIGF2b2lkIGNvbmZ1c2lvbiBpZlxyXG4gICAgICAgICAgICAvLyB0aGUgcHJvY2VzcyBvZiB1cGRhdGluZyBvbmUgc2NyZWVuIGFkZHMgb3IgcmVtb3ZlcyBvdGhlcnMuXHJcbiAgICAgICAgICAgIF9zY3JlZW5zVG9VcGRhdGUuQ2xlYXIoKTtcclxuICAgICAgICAgICAgZm9yZWFjaCAoR2FtZVNjcmVlbiBzY3JlZW4gaW4gX3NjcmVlbnMpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIF9zY3JlZW5zVG9VcGRhdGUuQWRkKHNjcmVlbik7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGJvb2wgb3RoZXJTY3JlZW5IYXNGb2N1cyA9ICFHYW1lLklzQWN0aXZlO1xyXG4gICAgICAgICAgICBib29sIGNvdmVyZWRCeU90aGVyU2NyZWVuID0gZmFsc2U7XHJcblxyXG4gICAgICAgICAgICAvLyBMb29wIGFzIGxvbmcgYXMgdGhlcmUgYXJlIHNjcmVlbnMgd2FpdGluZyB0byBiZSB1cGRhdGVkLlxyXG4gICAgICAgICAgICB3aGlsZSAoX3NjcmVlbnNUb1VwZGF0ZS5Db3VudCA+IDApXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIC8vIFBvcCB0aGUgdG9wbW9zdCBzY3JlZW4gb2ZmIHRoZSB3YWl0aW5nIGxpc3QuXHJcbiAgICAgICAgICAgICAgICBHYW1lU2NyZWVuIHNjcmVlbiA9IF9zY3JlZW5zVG9VcGRhdGVbX3NjcmVlbnNUb1VwZGF0ZS5Db3VudCAtIDFdO1xyXG5cclxuICAgICAgICAgICAgICAgIF9zY3JlZW5zVG9VcGRhdGUuUmVtb3ZlQXQoX3NjcmVlbnNUb1VwZGF0ZS5Db3VudCAtIDEpO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIFVwZGF0ZSB0aGUgc2NyZWVuLlxyXG4gICAgICAgICAgICAgICAgc2NyZWVuLlVwZGF0ZShnYW1lVGltZSwgb3RoZXJTY3JlZW5IYXNGb2N1cywgY292ZXJlZEJ5T3RoZXJTY3JlZW4pO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmIChzY3JlZW4uU2NyZWVuU3RhdGUgPT0gU2NyZWVuU3RhdGUuVHJhbnNpdGlvbk9uIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgc2NyZWVuLlNjcmVlblN0YXRlID09IFNjcmVlblN0YXRlLkFjdGl2ZSlcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBJZiB0aGlzIGlzIHRoZSBmaXJzdCBhY3RpdmUgc2NyZWVuIHdlIGNhbWUgYWNyb3NzLFxyXG4gICAgICAgICAgICAgICAgICAgIC8vIGdpdmUgaXQgYSBjaGFuY2UgdG8gaGFuZGxlIGlucHV0LlxyXG4gICAgICAgICAgICAgICAgICAgIGlmICghb3RoZXJTY3JlZW5IYXNGb2N1cylcclxuICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG90aGVyU2NyZWVuSGFzRm9jdXMgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgdGhpcyBpcyBhbiBhY3RpdmUgbm9uLXBvcHVwLCBpbmZvcm0gYW55IHN1YnNlcXVlbnRcclxuICAgICAgICAgICAgICAgICAgICAvLyBzY3JlZW5zIHRoYXQgdGhleSBhcmUgY292ZXJlZCBieSBpdC5cclxuICAgICAgICAgICAgICAgICAgICBpZiAoIXNjcmVlbi5Jc1BvcHVwKVxyXG4gICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY292ZXJlZEJ5T3RoZXJTY3JlZW4gPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBUZWxscyBlYWNoIHNjcmVlbiB0byBkcmF3IGl0c2VsZi5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIHB1YmxpYyBvdmVycmlkZSB2b2lkIERyYXcoR2FtZVRpbWUgZ2FtZVRpbWUpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBHcmFwaGljc0RldmljZS5DbGVhcihDb2xvci5CbGFjayk7XHJcbiAgICAgICAgICAgIGZvcmVhY2ggKEdhbWVTY3JlZW4gc2NyZWVuIGluIF9zY3JlZW5zKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBzY3JlZW4uRHJhdyhnYW1lVGltZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgIGludCB0cmFuc2l0aW9uQ291bnQgPSAwO1xyXG4gICAgICAgICAgICBmb3JlYWNoIChHYW1lU2NyZWVuIHNjcmVlbiBpbiBfc2NyZWVucylcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgaWYgKHNjcmVlbi5TY3JlZW5TdGF0ZSA9PSBTY3JlZW5TdGF0ZS5UcmFuc2l0aW9uT24gfHxcclxuICAgICAgICAgICAgICAgICAgICBzY3JlZW4uU2NyZWVuU3RhdGUgPT0gU2NyZWVuU3RhdGUuVHJhbnNpdGlvbk9mZilcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICArK3RyYW5zaXRpb25Db3VudDtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoX3RyYW5zaXRpb25zLkNvdW50IDwgdHJhbnNpdGlvbkNvdW50KVxyXG4gICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgUHJlc2VudGF0aW9uUGFyYW1ldGVycyBfcHAgPSBHcmFwaGljc0RldmljZS5QcmVzZW50YXRpb25QYXJhbWV0ZXJzO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBfdHJhbnNpdGlvbnMuQWRkKG5ldyBSZW5kZXJUYXJnZXQyRChHcmFwaGljc0RldmljZSwgX3BwLkJhY2tCdWZmZXJXaWR0aCwgX3BwLkJhY2tCdWZmZXJIZWlnaHQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZhbHNlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBTdXJmYWNlRm9ybWF0LkNvbG9yLCBfcHAuRGVwdGhTdGVuY2lsRm9ybWF0LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfcHAuTXVsdGlTYW1wbGVDb3VudCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgUmVuZGVyVGFyZ2V0VXNhZ2UuRGlzY2FyZENvbnRlbnRzKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIEdyYXBoaWNzRGV2aWNlLlNldFJlbmRlclRhcmdldChfdHJhbnNpdGlvbnNbdHJhbnNpdGlvbkNvdW50IC0gMV0pO1xyXG4gICAgICAgICAgICAgICAgICAgIEdyYXBoaWNzRGV2aWNlLkNsZWFyKENvbG9yLlRyYW5zcGFyZW50KTtcclxuICAgICAgICAgICAgICAgICAgICBzY3JlZW4uRHJhdyhnYW1lVGltZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgR3JhcGhpY3NEZXZpY2UuU2V0UmVuZGVyVGFyZ2V0KG51bGwpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBHcmFwaGljc0RldmljZS5DbGVhcihDb2xvci5CbGFjayk7XHJcblxyXG4gICAgICAgICAgICB0cmFuc2l0aW9uQ291bnQgPSAwO1xyXG4gICAgICAgICAgICBmb3JlYWNoIChHYW1lU2NyZWVuIHNjcmVlbiBpbiBfc2NyZWVucylcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgaWYgKHNjcmVlbi5TY3JlZW5TdGF0ZSA9PSBTY3JlZW5TdGF0ZS5IaWRkZW4pXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKHNjcmVlbi5TY3JlZW5TdGF0ZSA9PSBTY3JlZW5TdGF0ZS5UcmFuc2l0aW9uT24gfHxcclxuICAgICAgICAgICAgICAgICAgICBzY3JlZW4uU2NyZWVuU3RhdGUgPT0gU2NyZWVuU3RhdGUuVHJhbnNpdGlvbk9mZilcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBfc3ByaXRlQmF0Y2guQmVnaW4oMCwgQmxlbmRTdGF0ZS5BbHBoYUJsZW5kKTtcclxuICAgICAgICAgICAgICAgICAgICBfc3ByaXRlQmF0Y2guRHJhdyhfdHJhbnNpdGlvbnNbdHJhbnNpdGlvbkNvdW50XSwgVmVjdG9yMi5aZXJvLCBDb2xvci5XaGl0ZSAqIHNjcmVlbi5UcmFuc2l0aW9uQWxwaGEpO1xyXG4gICAgICAgICAgICAgICAgICAgIF9zcHJpdGVCYXRjaC5FbmQoKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgKyt0cmFuc2l0aW9uQ291bnQ7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgc2NyZWVuLkRyYXcoZ2FtZVRpbWUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICoqL1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBBZGRzIGEgbmV3IHNjcmVlbiB0byB0aGUgc2NyZWVuIG1hbmFnZXIuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICBwdWJsaWMgdm9pZCBBZGRTY3JlZW4oR2FtZVNjcmVlbiBzY3JlZW4pXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBzY3JlZW4uU2NyZWVuTWFuYWdlciA9IHRoaXM7XHJcbiAgICAgICAgICAgIHNjcmVlbi5Jc0V4aXRpbmcgPSBmYWxzZTtcclxuXHJcbiAgICAgICAgICAgIC8vIElmIHdlIGhhdmUgYSBncmFwaGljcyBkZXZpY2UsIHRlbGwgdGhlIHNjcmVlbiB0byBsb2FkIGNvbnRlbnQuXHJcbiAgICAgICAgICAgIGlmIChfaXNJbml0aWFsaXplZClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgc2NyZWVuLkxvYWRDb250ZW50KCk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIF9zY3JlZW5zLkFkZChzY3JlZW4pO1xyXG5cclxuICAgICAgICAgICAgLy8gdXBkYXRlIHRoZSBUb3VjaFBhbmVsIHRvIHJlc3BvbmQgdG8gZ2VzdHVyZXMgdGhpcyBzY3JlZW4gaXMgaW50ZXJlc3RlZCBpblxyXG4gICAgICAgICAgICBUb3VjaFBhbmVsLkVuYWJsZWRHZXN0dXJlcyA9IHNjcmVlbi5FbmFibGVkR2VzdHVyZXM7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIFJlbW92ZXMgYSBzY3JlZW4gZnJvbSB0aGUgc2NyZWVuIG1hbmFnZXIuIFlvdSBzaG91bGQgbm9ybWFsbHlcclxuICAgICAgICAvLy8gdXNlIEdhbWVTY3JlZW4uRXhpdFNjcmVlbiBpbnN0ZWFkIG9mIGNhbGxpbmcgdGhpcyBkaXJlY3RseSwgc29cclxuICAgICAgICAvLy8gdGhlIHNjcmVlbiBjYW4gZ3JhZHVhbGx5IHRyYW5zaXRpb24gb2ZmIHJhdGhlciB0aGFuIGp1c3QgYmVpbmdcclxuICAgICAgICAvLy8gaW5zdGFudGx5IHJlbW92ZWQuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICBwdWJsaWMgdm9pZCBSZW1vdmVTY3JlZW4oR2FtZVNjcmVlbiBzY3JlZW4pXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICAvLyBJZiB3ZSBoYXZlIGEgZ3JhcGhpY3MgZGV2aWNlLCB0ZWxsIHRoZSBzY3JlZW4gdG8gdW5sb2FkIGNvbnRlbnQuXHJcbiAgICAgICAgICAgIGlmIChfaXNJbml0aWFsaXplZClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgc2NyZWVuLlVubG9hZENvbnRlbnQoKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgX3NjcmVlbnMuUmVtb3ZlKHNjcmVlbik7XHJcbiAgICAgICAgICAgIF9zY3JlZW5zVG9VcGRhdGUuUmVtb3ZlKHNjcmVlbik7XHJcblxyXG4gICAgICAgICAgICAvLyBpZiB0aGVyZSBpcyBhIHNjcmVlbiBzdGlsbCBpbiB0aGUgbWFuYWdlciwgdXBkYXRlIFRvdWNoUGFuZWxcclxuICAgICAgICAgICAgLy8gdG8gcmVzcG9uZCB0byBnZXN0dXJlcyB0aGF0IHNjcmVlbiBpcyBpbnRlcmVzdGVkIGluLlxyXG4gICAgICAgICAgICBpZiAoX3NjcmVlbnMuQ291bnQgPiAwKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBUb3VjaFBhbmVsLkVuYWJsZWRHZXN0dXJlcyA9IF9zY3JlZW5zW19zY3JlZW5zLkNvdW50IC0gMV0uRW5hYmxlZEdlc3R1cmVzO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIEV4cG9zZSBhbiBhcnJheSBob2xkaW5nIGFsbCB0aGUgc2NyZWVucy4gV2UgcmV0dXJuIGEgY29weSByYXRoZXJcclxuICAgICAgICAvLy8gdGhhbiB0aGUgcmVhbCBtYXN0ZXIgbGlzdCwgYmVjYXVzZSBzY3JlZW5zIHNob3VsZCBvbmx5IGV2ZXIgYmUgYWRkZWRcclxuICAgICAgICAvLy8gb3IgcmVtb3ZlZCB1c2luZyB0aGUgQWRkU2NyZWVuIGFuZCBSZW1vdmVTY3JlZW4gbWV0aG9kcy5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIHB1YmxpYyBHYW1lU2NyZWVuW10gR2V0U2NyZWVucygpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gX3NjcmVlbnMuVG9BcnJheSgpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufSIsInVzaW5nIE1pY3Jvc29mdC5YbmEuRnJhbWV3b3JrO1xyXG51c2luZyBNaWNyb3NvZnQuWG5hLkZyYW1ld29yay5HcmFwaGljcztcclxuXHJcbm5hbWVzcGFjZSBGYXJzZWVyUGh5c2ljcy5VdGlsaXR5XHJcbntcclxuICAgIHB1YmxpYyBzdHJ1Y3QgU3ByaXRlXHJcbiAgICB7XHJcbiAgICAgICAgcHVibGljIFZlY3RvcjIgT3JpZ2luO1xyXG4gICAgICAgIHB1YmxpYyBUZXh0dXJlMkQgVGV4dHVyZTtcclxuXHJcbiAgICAgICAgcHVibGljIFNwcml0ZShUZXh0dXJlMkQgdGV4dHVyZSwgVmVjdG9yMiBvcmlnaW4pXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB0aGlzLlRleHR1cmUgPSB0ZXh0dXJlO1xyXG4gICAgICAgICAgICB0aGlzLk9yaWdpbiA9IG9yaWdpbjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHB1YmxpYyBTcHJpdGUoVGV4dHVyZTJEIHNwcml0ZSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIFRleHR1cmUgPSBzcHJpdGU7XHJcbiAgICAgICAgICAgIE9yaWdpbiA9IG5ldyBWZWN0b3IyKHNwcml0ZS5XaWR0aCAvIDJmLCBzcHJpdGUuSGVpZ2h0IC8gMmYpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufSIsIi8qIFBvbHkyVHJpXHJcbiAqIENvcHlyaWdodCAoYykgMjAwOS0yMDEwLCBQb2x5MlRyaSBDb250cmlidXRvcnNcclxuICogaHR0cDovL2NvZGUuZ29vZ2xlLmNvbS9wL3BvbHkydHJpL1xyXG4gKlxyXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKlxyXG4gKiBSZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRoIG9yIHdpdGhvdXQgbW9kaWZpY2F0aW9uLFxyXG4gKiBhcmUgcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBjb25kaXRpb25zIGFyZSBtZXQ6XHJcbiAqXHJcbiAqICogUmVkaXN0cmlidXRpb25zIG9mIHNvdXJjZSBjb2RlIG11c3QgcmV0YWluIHRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlLFxyXG4gKiAgIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIuXHJcbiAqICogUmVkaXN0cmlidXRpb25zIGluIGJpbmFyeSBmb3JtIG11c3QgcmVwcm9kdWNlIHRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlLFxyXG4gKiAgIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIgaW4gdGhlIGRvY3VtZW50YXRpb25cclxuICogICBhbmQvb3Igb3RoZXIgbWF0ZXJpYWxzIHByb3ZpZGVkIHdpdGggdGhlIGRpc3RyaWJ1dGlvbi5cclxuICogKiBOZWl0aGVyIHRoZSBuYW1lIG9mIFBvbHkyVHJpIG5vciB0aGUgbmFtZXMgb2YgaXRzIGNvbnRyaWJ1dG9ycyBtYXkgYmVcclxuICogICB1c2VkIHRvIGVuZG9yc2Ugb3IgcHJvbW90ZSBwcm9kdWN0cyBkZXJpdmVkIGZyb20gdGhpcyBzb2Z0d2FyZSB3aXRob3V0IHNwZWNpZmljXHJcbiAqICAgcHJpb3Igd3JpdHRlbiBwZXJtaXNzaW9uLlxyXG4gKlxyXG4gKiBUSElTIFNPRlRXQVJFIElTIFBST1ZJREVEIEJZIFRIRSBDT1BZUklHSFQgSE9MREVSUyBBTkQgQ09OVFJJQlVUT1JTXHJcbiAqIFwiQVMgSVNcIiBBTkQgQU5ZIEVYUFJFU1MgT1IgSU1QTElFRCBXQVJSQU5USUVTLCBJTkNMVURJTkcsIEJVVCBOT1RcclxuICogTElNSVRFRCBUTywgVEhFIElNUExJRUQgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFkgQU5EIEZJVE5FU1MgRk9SXHJcbiAqIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFSRSBESVNDTEFJTUVELiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQ09QWVJJR0hUIE9XTkVSIE9SXHJcbiAqIENPTlRSSUJVVE9SUyBCRSBMSUFCTEUgRk9SIEFOWSBESVJFQ1QsIElORElSRUNULCBJTkNJREVOVEFMLCBTUEVDSUFMLFxyXG4gKiBFWEVNUExBUlksIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFUyAoSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sXHJcbiAqIFBST0NVUkVNRU5UIE9GIFNVQlNUSVRVVEUgR09PRFMgT1IgU0VSVklDRVM7IExPU1MgT0YgVVNFLCBEQVRBLCBPUlxyXG4gKiBQUk9GSVRTOyBPUiBCVVNJTkVTUyBJTlRFUlJVUFRJT04pIEhPV0VWRVIgQ0FVU0VEIEFORCBPTiBBTlkgVEhFT1JZIE9GXHJcbiAqIExJQUJJTElUWSwgV0hFVEhFUiBJTiBDT05UUkFDVCwgU1RSSUNUIExJQUJJTElUWSwgT1IgVE9SVCAoSU5DTFVESU5HXHJcbiAqIE5FR0xJR0VOQ0UgT1IgT1RIRVJXSVNFKSBBUklTSU5HIElOIEFOWSBXQVkgT1VUIE9GIFRIRSBVU0UgT0YgVEhJU1xyXG4gKiBTT0ZUV0FSRSwgRVZFTiBJRiBBRFZJU0VEIE9GIFRIRSBQT1NTSUJJTElUWSBPRiBTVUNIIERBTUFHRS5cclxuICovXHJcblxyXG4vLyBDaGFuZ2VzIGZyb20gdGhlIEphdmEgdmVyc2lvblxyXG4vLyAgIGF0dHJpYnV0aWZpY2F0aW9uXHJcbi8vIEZ1dHVyZSBwb3NzaWJpbGl0aWVzXHJcbi8vICAgRmxhdHRlbmluZyBvdXQgdGhlIG51bWJlciBvZiBpbmRpcmVjdGlvbnNcclxuLy8gICAgIFJlcGxhY2luZyBhcnJheXMgb2YgMyB3aXRoIGZpeGVkLWxlbmd0aCBhcnJheXM/XHJcbi8vICAgICBSZXBsYWNpbmcgYm9vbFszXSB3aXRoIGEgYml0IGFycmF5IG9mIHNvbWUgc29ydD9cclxuLy8gICAgIEJ1bmRsaW5nIGV2ZXJ5dGhpbmcgaW50byBhbiBBb1MgbWVzcz9cclxuLy8gICAgIEhhcmRjb2RlIHRoZW0gYWxsIGFzIEFCQyA/XHJcblxyXG51c2luZyBTeXN0ZW07XHJcbnVzaW5nIFN5c3RlbS5Db2xsZWN0aW9ucy5HZW5lcmljO1xyXG51c2luZyBTeXN0ZW0uRGlhZ25vc3RpY3M7XHJcbnVzaW5nIFBvbHkyVHJpLlRyaWFuZ3VsYXRpb24uRGVsYXVuYXkuU3dlZXA7XHJcbnVzaW5nIFBvbHkyVHJpLlRyaWFuZ3VsYXRpb24uVXRpbDtcclxuXHJcbm5hbWVzcGFjZSBQb2x5MlRyaS5Ucmlhbmd1bGF0aW9uLkRlbGF1bmF5XHJcbntcclxuICAgIHB1YmxpYyBjbGFzcyBEZWxhdW5heVRyaWFuZ2xlXHJcbiAgICB7XHJcbiAgICAgICAgLyoqIE5laWdoYm9yIHBvaW50ZXJzICovXHJcblxyXG4gICAgICAgIC8qKiBGbGFncyB0byBkZXRlcm1pbmUgaWYgYW4gZWRnZSBpcyBhIERlbGF1bmV5IGVkZ2UgKi9cclxuICAgICAgICBwdWJsaWMgRml4ZWRCaXRBcnJheTMgRWRnZUlzQ29uc3RyYWluZWQ7XHJcblxyXG4gICAgICAgIC8qKiBGbGFncyB0byBkZXRlcm1pbmUgaWYgYW4gZWRnZSBpcyBhIENvbnN0cmFpbmVkIGVkZ2UgKi9cclxuICAgICAgICBwdWJsaWMgRml4ZWRCaXRBcnJheTMgRWRnZUlzRGVsYXVuYXk7XHJcbiAgICAgICAgcHVibGljIEZpeGVkQXJyYXkzPERlbGF1bmF5VHJpYW5nbGU+IE5laWdoYm9ycztcclxuXHJcbiAgICAgICAgLyoqIEhhcyB0aGlzIHRyaWFuZ2xlIGJlZW4gbWFya2VkIGFzIGFuIGludGVyaW9yIHRyaWFuZ2xlPyAqL1xyXG5cclxuICAgICAgICBwdWJsaWMgRml4ZWRBcnJheTM8VHJpYW5ndWxhdGlvblBvaW50PiBQb2ludHM7XHJcblxyXG4gICAgICAgIHB1YmxpYyBEZWxhdW5heVRyaWFuZ2xlKFRyaWFuZ3VsYXRpb25Qb2ludCBwMSwgVHJpYW5ndWxhdGlvblBvaW50IHAyLCBUcmlhbmd1bGF0aW9uUG9pbnQgcDMpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBQb2ludHNbMF0gPSBwMTtcclxuICAgICAgICAgICAgUG9pbnRzWzFdID0gcDI7XHJcbiAgICAgICAgICAgIFBvaW50c1syXSA9IHAzO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHVibGljIGJvb2wgSXNJbnRlcmlvciB7IGdldDsgc2V0OyB9XHJcblxyXG4gICAgICAgIHB1YmxpYyBpbnQgSW5kZXhPZihUcmlhbmd1bGF0aW9uUG9pbnQgcClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGludCBpID0gUG9pbnRzLkluZGV4T2YocCk7XHJcbiAgICAgICAgICAgIGlmIChpID09IC0xKSB0aHJvdyBuZXcgRXhjZXB0aW9uKFwiQ2FsbGluZyBpbmRleCB3aXRoIGEgcG9pbnQgdGhhdCBkb2Vzbid0IGV4aXN0IGluIHRyaWFuZ2xlXCIpO1xyXG4gICAgICAgICAgICByZXR1cm4gaTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vVE9ETzogUG9ydCBub3RlIC0gZGlmZmVyZW50IGltcGxlbWVudGF0aW9uXHJcbiAgICAgICAgcHVibGljIGludCBJbmRleENXKFRyaWFuZ3VsYXRpb25Qb2ludCBwKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgaW50IGluZGV4ID0gSW5kZXhPZihwKTtcclxuICAgICAgICAgICAgc3dpdGNoIChpbmRleClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgY2FzZSAwOlxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAyO1xyXG4gICAgICAgICAgICAgICAgY2FzZSAxOlxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAwO1xyXG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gMTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy9UT0RPOiBQb3J0IG5vdGUgLSBkaWZmZXJlbnQgaW1wbGVtZW50YXRpb25cclxuICAgICAgICBwdWJsaWMgaW50IEluZGV4Q0NXKFRyaWFuZ3VsYXRpb25Qb2ludCBwKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgaW50IGluZGV4ID0gSW5kZXhPZihwKTtcclxuICAgICAgICAgICAgc3dpdGNoIChpbmRleClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgY2FzZSAwOlxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAxO1xyXG4gICAgICAgICAgICAgICAgY2FzZSAxOlxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAyO1xyXG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gMDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHVibGljIGJvb2wgQ29udGFpbnMoVHJpYW5ndWxhdGlvblBvaW50IHApXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gKHAgPT0gUG9pbnRzWzBdIHx8IHAgPT0gUG9pbnRzWzFdIHx8IHAgPT0gUG9pbnRzWzJdKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHB1YmxpYyBib29sIENvbnRhaW5zKERUU3dlZXBDb25zdHJhaW50IGUpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gKENvbnRhaW5zKGUuUCkgJiYgQ29udGFpbnMoZS5RKSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwdWJsaWMgYm9vbCBDb250YWlucyhUcmlhbmd1bGF0aW9uUG9pbnQgcCwgVHJpYW5ndWxhdGlvblBvaW50IHEpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gKENvbnRhaW5zKHApICYmIENvbnRhaW5zKHEpKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gVXBkYXRlIG5laWdoYm9yIHBvaW50ZXJzXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJwMVwiPlBvaW50IDEgb2YgdGhlIHNoYXJlZCBlZGdlPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJwMlwiPlBvaW50IDIgb2YgdGhlIHNoYXJlZCBlZGdlPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJ0XCI+VGhpcyB0cmlhbmdsZSdzIG5ldyBuZWlnaGJvcjwvcGFyYW0+XHJcbiAgICAgICAgcHJpdmF0ZSB2b2lkIE1hcmtOZWlnaGJvcihUcmlhbmd1bGF0aW9uUG9pbnQgcDEsIFRyaWFuZ3VsYXRpb25Qb2ludCBwMiwgRGVsYXVuYXlUcmlhbmdsZSB0KVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgaWYgKChwMSA9PSBQb2ludHNbMl0gJiYgcDIgPT0gUG9pbnRzWzFdKSB8fCAocDEgPT0gUG9pbnRzWzFdICYmIHAyID09IFBvaW50c1syXSkpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIE5laWdoYm9yc1swXSA9IHQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoKHAxID09IFBvaW50c1swXSAmJiBwMiA9PSBQb2ludHNbMl0pIHx8IChwMSA9PSBQb2ludHNbMl0gJiYgcDIgPT0gUG9pbnRzWzBdKSlcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgTmVpZ2hib3JzWzFdID0gdDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmICgocDEgPT0gUG9pbnRzWzBdICYmIHAyID09IFBvaW50c1sxXSkgfHwgKHAxID09IFBvaW50c1sxXSAmJiBwMiA9PSBQb2ludHNbMF0pKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBOZWlnaGJvcnNbMl0gPSB0O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgRGVidWcuV3JpdGVMaW5lKFwiTmVpZ2hib3IgZXJyb3IsIHBsZWFzZSByZXBvcnQhXCIpO1xyXG4gICAgICAgICAgICAgICAgLy8gdGhyb3cgbmV3IEV4Y2VwdGlvbihcIk5laWdoYm9yIGVycm9yLCBwbGVhc2UgcmVwb3J0IVwiKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBFeGhhdXN0aXZlIHNlYXJjaCB0byB1cGRhdGUgbmVpZ2hib3IgcG9pbnRlcnNcclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIHB1YmxpYyB2b2lkIE1hcmtOZWlnaGJvcihEZWxhdW5heVRyaWFuZ2xlIHQpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBpZiAodC5Db250YWlucyhQb2ludHNbMV0sIFBvaW50c1syXSkpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIE5laWdoYm9yc1swXSA9IHQ7XHJcbiAgICAgICAgICAgICAgICB0Lk1hcmtOZWlnaGJvcihQb2ludHNbMV0sIFBvaW50c1syXSwgdGhpcyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAodC5Db250YWlucyhQb2ludHNbMF0sIFBvaW50c1syXSkpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIE5laWdoYm9yc1sxXSA9IHQ7XHJcbiAgICAgICAgICAgICAgICB0Lk1hcmtOZWlnaGJvcihQb2ludHNbMF0sIFBvaW50c1syXSwgdGhpcyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAodC5Db250YWlucyhQb2ludHNbMF0sIFBvaW50c1sxXSkpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIE5laWdoYm9yc1syXSA9IHQ7XHJcbiAgICAgICAgICAgICAgICB0Lk1hcmtOZWlnaGJvcihQb2ludHNbMF0sIFBvaW50c1sxXSwgdGhpcyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBEZWJ1Zy5Xcml0ZUxpbmUoXCJtYXJrTmVpZ2hib3IgZmFpbGVkXCIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwdWJsaWMgdm9pZCBDbGVhck5laWdoYm9ycygpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBOZWlnaGJvcnNbMF0gPSBOZWlnaGJvcnNbMV0gPSBOZWlnaGJvcnNbMl0gPSBudWxsO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHVibGljIHZvaWQgQ2xlYXJOZWlnaGJvcihEZWxhdW5heVRyaWFuZ2xlIHRyaWFuZ2xlKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgaWYgKE5laWdoYm9yc1swXSA9PSB0cmlhbmdsZSlcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgTmVpZ2hib3JzWzBdID0gbnVsbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChOZWlnaGJvcnNbMV0gPT0gdHJpYW5nbGUpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIE5laWdoYm9yc1sxXSA9IG51bGw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBOZWlnaGJvcnNbMl0gPSBudWxsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBDbGVhcnMgYWxsIHJlZmVyZW5jZXMgdG8gYWxsIG90aGVyIHRyaWFuZ2xlcyBhbmQgcG9pbnRzXHJcbiAgICAgICAgICovXHJcblxyXG4gICAgICAgIHB1YmxpYyB2b2lkIENsZWFyKClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIERlbGF1bmF5VHJpYW5nbGUgdDtcclxuICAgICAgICAgICAgZm9yIChpbnQgaSA9IDA7IGkgPCAzOyBpKyspXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHQgPSBOZWlnaGJvcnNbaV07XHJcbiAgICAgICAgICAgICAgICBpZiAodCAhPSBudWxsKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIHQuQ2xlYXJOZWlnaGJvcih0aGlzKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBDbGVhck5laWdoYm9ycygpO1xyXG4gICAgICAgICAgICBQb2ludHNbMF0gPSBQb2ludHNbMV0gPSBQb2ludHNbMl0gPSBudWxsO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwidFwiPk9wcG9zaXRlIHRyaWFuZ2xlPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJwXCI+VGhlIHBvaW50IGluIHQgdGhhdCBpc24ndCBzaGFyZWQgYmV0d2VlbiB0aGUgdHJpYW5nbGVzPC9wYXJhbT5cclxuICAgICAgICBwdWJsaWMgVHJpYW5ndWxhdGlvblBvaW50IE9wcG9zaXRlUG9pbnQoRGVsYXVuYXlUcmlhbmdsZSB0LCBUcmlhbmd1bGF0aW9uUG9pbnQgcClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIERlYnVnLkFzc2VydCh0ICE9IHRoaXMsIFwic2VsZi1wb2ludGVyIGVycm9yXCIpO1xyXG4gICAgICAgICAgICByZXR1cm4gUG9pbnRDVyh0LlBvaW50Q1cocCkpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHVibGljIERlbGF1bmF5VHJpYW5nbGUgTmVpZ2hib3JDVyhUcmlhbmd1bGF0aW9uUG9pbnQgcG9pbnQpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gTmVpZ2hib3JzWyhQb2ludHMuSW5kZXhPZihwb2ludCkgKyAxKSUzXTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHB1YmxpYyBEZWxhdW5heVRyaWFuZ2xlIE5laWdoYm9yQ0NXKFRyaWFuZ3VsYXRpb25Qb2ludCBwb2ludClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiBOZWlnaGJvcnNbKFBvaW50cy5JbmRleE9mKHBvaW50KSArIDIpJTNdO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHVibGljIERlbGF1bmF5VHJpYW5nbGUgTmVpZ2hib3JBY3Jvc3MoVHJpYW5ndWxhdGlvblBvaW50IHBvaW50KVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIE5laWdoYm9yc1tQb2ludHMuSW5kZXhPZihwb2ludCldO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHVibGljIFRyaWFuZ3VsYXRpb25Qb2ludCBQb2ludENDVyhUcmlhbmd1bGF0aW9uUG9pbnQgcG9pbnQpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gUG9pbnRzWyhJbmRleE9mKHBvaW50KSArIDEpJTNdO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHVibGljIFRyaWFuZ3VsYXRpb25Qb2ludCBQb2ludENXKFRyaWFuZ3VsYXRpb25Qb2ludCBwb2ludClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiBQb2ludHNbKEluZGV4T2YocG9pbnQpICsgMiklM107XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwcml2YXRlIHZvaWQgUm90YXRlQ1coKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdmFyIHQgPSBQb2ludHNbMl07XHJcbiAgICAgICAgICAgIFBvaW50c1syXSA9IFBvaW50c1sxXTtcclxuICAgICAgICAgICAgUG9pbnRzWzFdID0gUG9pbnRzWzBdO1xyXG4gICAgICAgICAgICBQb2ludHNbMF0gPSB0O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBMZWdhbGl6ZSB0cmlhbmdsZSBieSByb3RhdGluZyBjbG9ja3dpc2UgYXJvdW5kIG9Qb2ludFxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwib1BvaW50XCI+VGhlIG9yaWdpbiBwb2ludCB0byByb3RhdGUgYXJvdW5kPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJuUG9pbnRcIj4/Pz88L3BhcmFtPlxyXG4gICAgICAgIHB1YmxpYyB2b2lkIExlZ2FsaXplKFRyaWFuZ3VsYXRpb25Qb2ludCBvUG9pbnQsIFRyaWFuZ3VsYXRpb25Qb2ludCBuUG9pbnQpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBSb3RhdGVDVygpO1xyXG4gICAgICAgICAgICBQb2ludHNbSW5kZXhDQ1cob1BvaW50KV0gPSBuUG9pbnQ7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwdWJsaWMgb3ZlcnJpZGUgc3RyaW5nIFRvU3RyaW5nKClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiBQb2ludHNbMF0gKyBcIixcIiArIFBvaW50c1sxXSArIFwiLFwiICsgUG9pbnRzWzJdO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBGaW5hbGl6ZSBlZGdlIG1hcmtpbmdcclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIHB1YmxpYyB2b2lkIE1hcmtOZWlnaGJvckVkZ2VzKClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGZvciAoaW50IGkgPSAwOyBpIDwgMzsgaSsrKVxyXG4gICAgICAgICAgICAgICAgaWYgKEVkZ2VJc0NvbnN0cmFpbmVkW2ldICYmIE5laWdoYm9yc1tpXSAhPSBudWxsKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIE5laWdoYm9yc1tpXS5NYXJrQ29uc3RyYWluZWRFZGdlKFBvaW50c1soaSArIDEpJTNdLCBQb2ludHNbKGkgKyAyKSUzXSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwdWJsaWMgdm9pZCBNYXJrRWRnZShEZWxhdW5heVRyaWFuZ2xlIHRyaWFuZ2xlKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgZm9yIChpbnQgaSA9IDA7IGkgPCAzOyBpKyspXHJcbiAgICAgICAgICAgICAgICBpZiAoRWRnZUlzQ29uc3RyYWluZWRbaV0pXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgdHJpYW5nbGUuTWFya0NvbnN0cmFpbmVkRWRnZShQb2ludHNbKGkgKyAxKSUzXSwgUG9pbnRzWyhpICsgMiklM10pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHVibGljIHZvaWQgTWFya0VkZ2UoTGlzdDxEZWxhdW5heVRyaWFuZ2xlPiB0TGlzdClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGZvcmVhY2ggKERlbGF1bmF5VHJpYW5nbGUgdCBpbiB0TGlzdClcclxuICAgICAgICAgICAgICAgIGZvciAoaW50IGkgPSAwOyBpIDwgMzsgaSsrKVxyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0LkVkZ2VJc0NvbnN0cmFpbmVkW2ldKVxyXG4gICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgTWFya0NvbnN0cmFpbmVkRWRnZSh0LlBvaW50c1soaSArIDEpJTNdLCB0LlBvaW50c1soaSArIDIpJTNdKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwdWJsaWMgdm9pZCBNYXJrQ29uc3RyYWluZWRFZGdlKGludCBpbmRleClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIEVkZ2VJc0NvbnN0cmFpbmVkW2luZGV4XSA9IHRydWU7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwdWJsaWMgdm9pZCBNYXJrQ29uc3RyYWluZWRFZGdlKERUU3dlZXBDb25zdHJhaW50IGVkZ2UpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBNYXJrQ29uc3RyYWluZWRFZGdlKGVkZ2UuUCwgZWRnZS5RKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gTWFyayBlZGdlIGFzIGNvbnN0cmFpbmVkXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICBwdWJsaWMgdm9pZCBNYXJrQ29uc3RyYWluZWRFZGdlKFRyaWFuZ3VsYXRpb25Qb2ludCBwLCBUcmlhbmd1bGF0aW9uUG9pbnQgcSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGludCBpID0gRWRnZUluZGV4KHAsIHEpO1xyXG4gICAgICAgICAgICBpZiAoaSAhPSAtMSkgRWRnZUlzQ29uc3RyYWluZWRbaV0gPSB0cnVlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHVibGljIGRvdWJsZSBBcmVhKClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGRvdWJsZSBiID0gUG9pbnRzWzBdLlggLSBQb2ludHNbMV0uWDtcclxuICAgICAgICAgICAgZG91YmxlIGggPSBQb2ludHNbMl0uWSAtIFBvaW50c1sxXS5ZO1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIE1hdGguQWJzKChiKmgqMC41ZikpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHVibGljIFRyaWFuZ3VsYXRpb25Qb2ludCBDZW50cm9pZCgpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBkb3VibGUgY3ggPSAoUG9pbnRzWzBdLlggKyBQb2ludHNbMV0uWCArIFBvaW50c1syXS5YKS8zZjtcclxuICAgICAgICAgICAgZG91YmxlIGN5ID0gKFBvaW50c1swXS5ZICsgUG9pbnRzWzFdLlkgKyBQb2ludHNbMl0uWSkvM2Y7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgVHJpYW5ndWxhdGlvblBvaW50KGN4LCBjeSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIEdldCB0aGUgaW5kZXggb2YgdGhlIG5laWdoYm9yIHRoYXQgc2hhcmVzIHRoaXMgZWRnZSAob3IgLTEgaWYgaXQgaXNuJ3Qgc2hhcmVkKVxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDxyZXR1cm5zPmluZGV4IG9mIHRoZSBzaGFyZWQgZWRnZSBvciAtMSBpZiBlZGdlIGlzbid0IHNoYXJlZDwvcmV0dXJucz5cclxuICAgICAgICBwdWJsaWMgaW50IEVkZ2VJbmRleChUcmlhbmd1bGF0aW9uUG9pbnQgcDEsIFRyaWFuZ3VsYXRpb25Qb2ludCBwMilcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGludCBpMSA9IFBvaW50cy5JbmRleE9mKHAxKTtcclxuICAgICAgICAgICAgaW50IGkyID0gUG9pbnRzLkluZGV4T2YocDIpO1xyXG5cclxuICAgICAgICAgICAgLy8gUG9pbnRzIG9mIHRoaXMgdHJpYW5nbGUgaW4gdGhlIGVkZ2UgcDEtcDJcclxuICAgICAgICAgICAgYm9vbCBhID0gKGkxID09IDAgfHwgaTIgPT0gMCk7XHJcbiAgICAgICAgICAgIGJvb2wgYiA9IChpMSA9PSAxIHx8IGkyID09IDEpO1xyXG4gICAgICAgICAgICBib29sIGMgPSAoaTEgPT0gMiB8fCBpMiA9PSAyKTtcclxuXHJcbiAgICAgICAgICAgIGlmIChiICYmIGMpIHJldHVybiAwO1xyXG4gICAgICAgICAgICBpZiAoYSAmJiBjKSByZXR1cm4gMTtcclxuICAgICAgICAgICAgaWYgKGEgJiYgYikgcmV0dXJuIDI7XHJcbiAgICAgICAgICAgIHJldHVybiAtMTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHB1YmxpYyBib29sIEdldENvbnN0cmFpbmVkRWRnZUNDVyhUcmlhbmd1bGF0aW9uUG9pbnQgcClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiBFZGdlSXNDb25zdHJhaW5lZFsoSW5kZXhPZihwKSArIDIpJTNdO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHVibGljIGJvb2wgR2V0Q29uc3RyYWluZWRFZGdlQ1coVHJpYW5ndWxhdGlvblBvaW50IHApXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gRWRnZUlzQ29uc3RyYWluZWRbKEluZGV4T2YocCkgKyAxKSUzXTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHB1YmxpYyBib29sIEdldENvbnN0cmFpbmVkRWRnZUFjcm9zcyhUcmlhbmd1bGF0aW9uUG9pbnQgcClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiBFZGdlSXNDb25zdHJhaW5lZFtJbmRleE9mKHApXTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHB1YmxpYyB2b2lkIFNldENvbnN0cmFpbmVkRWRnZUNDVyhUcmlhbmd1bGF0aW9uUG9pbnQgcCwgYm9vbCBjZSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIEVkZ2VJc0NvbnN0cmFpbmVkWyhJbmRleE9mKHApICsgMiklM10gPSBjZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHB1YmxpYyB2b2lkIFNldENvbnN0cmFpbmVkRWRnZUNXKFRyaWFuZ3VsYXRpb25Qb2ludCBwLCBib29sIGNlKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgRWRnZUlzQ29uc3RyYWluZWRbKEluZGV4T2YocCkgKyAxKSUzXSA9IGNlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHVibGljIHZvaWQgU2V0Q29uc3RyYWluZWRFZGdlQWNyb3NzKFRyaWFuZ3VsYXRpb25Qb2ludCBwLCBib29sIGNlKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgRWRnZUlzQ29uc3RyYWluZWRbSW5kZXhPZihwKV0gPSBjZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHB1YmxpYyBib29sIEdldERlbGF1bmF5RWRnZUNDVyhUcmlhbmd1bGF0aW9uUG9pbnQgcClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiBFZGdlSXNEZWxhdW5heVsoSW5kZXhPZihwKSArIDIpJTNdO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHVibGljIGJvb2wgR2V0RGVsYXVuYXlFZGdlQ1coVHJpYW5ndWxhdGlvblBvaW50IHApXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gRWRnZUlzRGVsYXVuYXlbKEluZGV4T2YocCkgKyAxKSUzXTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHB1YmxpYyBib29sIEdldERlbGF1bmF5RWRnZUFjcm9zcyhUcmlhbmd1bGF0aW9uUG9pbnQgcClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiBFZGdlSXNEZWxhdW5heVtJbmRleE9mKHApXTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHB1YmxpYyB2b2lkIFNldERlbGF1bmF5RWRnZUNDVyhUcmlhbmd1bGF0aW9uUG9pbnQgcCwgYm9vbCBjZSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIEVkZ2VJc0RlbGF1bmF5WyhJbmRleE9mKHApICsgMiklM10gPSBjZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHB1YmxpYyB2b2lkIFNldERlbGF1bmF5RWRnZUNXKFRyaWFuZ3VsYXRpb25Qb2ludCBwLCBib29sIGNlKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgRWRnZUlzRGVsYXVuYXlbKEluZGV4T2YocCkgKyAxKSUzXSA9IGNlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHVibGljIHZvaWQgU2V0RGVsYXVuYXlFZGdlQWNyb3NzKFRyaWFuZ3VsYXRpb25Qb2ludCBwLCBib29sIGNlKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgRWRnZUlzRGVsYXVuYXlbSW5kZXhPZihwKV0gPSBjZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn0iLCIvKiBQb2x5MlRyaVxyXG4gKiBDb3B5cmlnaHQgKGMpIDIwMDktMjAxMCwgUG9seTJUcmkgQ29udHJpYnV0b3JzXHJcbiAqIGh0dHA6Ly9jb2RlLmdvb2dsZS5jb20vcC9wb2x5MnRyaS9cclxuICpcclxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICpcclxuICogUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aCBvciB3aXRob3V0IG1vZGlmaWNhdGlvbixcclxuICogYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgY29uZGl0aW9ucyBhcmUgbWV0OlxyXG4gKlxyXG4gKiAqIFJlZGlzdHJpYnV0aW9ucyBvZiBzb3VyY2UgY29kZSBtdXN0IHJldGFpbiB0aGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSxcclxuICogICB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyLlxyXG4gKiAqIFJlZGlzdHJpYnV0aW9ucyBpbiBiaW5hcnkgZm9ybSBtdXN0IHJlcHJvZHVjZSB0aGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSxcclxuICogICB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyIGluIHRoZSBkb2N1bWVudGF0aW9uXHJcbiAqICAgYW5kL29yIG90aGVyIG1hdGVyaWFscyBwcm92aWRlZCB3aXRoIHRoZSBkaXN0cmlidXRpb24uXHJcbiAqICogTmVpdGhlciB0aGUgbmFtZSBvZiBQb2x5MlRyaSBub3IgdGhlIG5hbWVzIG9mIGl0cyBjb250cmlidXRvcnMgbWF5IGJlXHJcbiAqICAgdXNlZCB0byBlbmRvcnNlIG9yIHByb21vdGUgcHJvZHVjdHMgZGVyaXZlZCBmcm9tIHRoaXMgc29mdHdhcmUgd2l0aG91dCBzcGVjaWZpY1xyXG4gKiAgIHByaW9yIHdyaXR0ZW4gcGVybWlzc2lvbi5cclxuICpcclxuICogVEhJUyBTT0ZUV0FSRSBJUyBQUk9WSURFRCBCWSBUSEUgQ09QWVJJR0hUIEhPTERFUlMgQU5EIENPTlRSSUJVVE9SU1xyXG4gKiBcIkFTIElTXCIgQU5EIEFOWSBFWFBSRVNTIE9SIElNUExJRUQgV0FSUkFOVElFUywgSU5DTFVESU5HLCBCVVQgTk9UXHJcbiAqIExJTUlURUQgVE8sIFRIRSBJTVBMSUVEIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZIEFORCBGSVRORVNTIEZPUlxyXG4gKiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBUkUgRElTQ0xBSU1FRC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIENPUFlSSUdIVCBPV05FUiBPUlxyXG4gKiBDT05UUklCVVRPUlMgQkUgTElBQkxFIEZPUiBBTlkgRElSRUNULCBJTkRJUkVDVCwgSU5DSURFTlRBTCwgU1BFQ0lBTCxcclxuICogRVhFTVBMQVJZLCBPUiBDT05TRVFVRU5USUFMIERBTUFHRVMgKElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLFxyXG4gKiBQUk9DVVJFTUVOVCBPRiBTVUJTVElUVVRFIEdPT0RTIE9SIFNFUlZJQ0VTOyBMT1NTIE9GIFVTRSwgREFUQSwgT1JcclxuICogUFJPRklUUzsgT1IgQlVTSU5FU1MgSU5URVJSVVBUSU9OKSBIT1dFVkVSIENBVVNFRCBBTkQgT04gQU5ZIFRIRU9SWSBPRlxyXG4gKiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQ09OVFJBQ1QsIFNUUklDVCBMSUFCSUxJVFksIE9SIFRPUlQgKElOQ0xVRElOR1xyXG4gKiBORUdMSUdFTkNFIE9SIE9USEVSV0lTRSkgQVJJU0lORyBJTiBBTlkgV0FZIE9VVCBPRiBUSEUgVVNFIE9GIFRISVNcclxuICogU09GVFdBUkUsIEVWRU4gSUYgQURWSVNFRCBPRiBUSEUgUE9TU0lCSUxJVFkgT0YgU1VDSCBEQU1BR0UuXHJcbiAqL1xyXG5cclxuLy8gQ2hhbmdlcyBmcm9tIHRoZSBKYXZhIHZlcnNpb25cclxuLy8gICBSZW1vdmVkIEJTVCBjb2RlLCBidXQgbm90IGFsbCBhcnRpZmFjdHMgb2YgaXRcclxuLy8gRnV0dXJlIHBvc3NpYmlsaXRpZXNcclxuLy8gICBFbGltaW5hdGUgQWRkL1JlbW92ZU5vZGUgP1xyXG4vLyAgIENvbW1lbnRzIGNvbW1lbnRzIGFuZCBtb3JlIGNvbW1lbnRzIVxyXG5cclxudXNpbmcgU3lzdGVtO1xyXG51c2luZyBTeXN0ZW0uVGV4dDtcclxuXHJcbm5hbWVzcGFjZSBQb2x5MlRyaS5Ucmlhbmd1bGF0aW9uLkRlbGF1bmF5LlN3ZWVwXHJcbntcclxuICAgIC8qKlxyXG4gICAgICogQGF1dGhvciBUaG9tYXMgw4VobGVuICh0aGFobGVuQGdtYWlsLmNvbSlcclxuICAgICAqL1xyXG5cclxuICAgIHB1YmxpYyBjbGFzcyBBZHZhbmNpbmdGcm9udFxyXG4gICAge1xyXG4gICAgICAgIHB1YmxpYyBBZHZhbmNpbmdGcm9udE5vZGUgSGVhZDtcclxuICAgICAgICBwcm90ZWN0ZWQgQWR2YW5jaW5nRnJvbnROb2RlIFNlYXJjaDtcclxuICAgICAgICBwdWJsaWMgQWR2YW5jaW5nRnJvbnROb2RlIFRhaWw7XHJcblxyXG4gICAgICAgIHB1YmxpYyBBZHZhbmNpbmdGcm9udChBZHZhbmNpbmdGcm9udE5vZGUgaGVhZCwgQWR2YW5jaW5nRnJvbnROb2RlIHRhaWwpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBIZWFkID0gaGVhZDtcclxuICAgICAgICAgICAgVGFpbCA9IHRhaWw7XHJcbiAgICAgICAgICAgIFNlYXJjaCA9IGhlYWQ7XHJcbiAgICAgICAgICAgIEFkZE5vZGUoaGVhZCk7XHJcbiAgICAgICAgICAgIEFkZE5vZGUodGFpbCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwdWJsaWMgdm9pZCBBZGROb2RlKEFkdmFuY2luZ0Zyb250Tm9kZSBub2RlKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgLy9fc2VhcmNoVHJlZS5wdXQobm9kZS5rZXksIG5vZGUpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHVibGljIHZvaWQgUmVtb3ZlTm9kZShBZHZhbmNpbmdGcm9udE5vZGUgbm9kZSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIC8vX3NlYXJjaFRyZWUuZGVsZXRlKCBub2RlLmtleSApO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHVibGljIG92ZXJyaWRlIHN0cmluZyBUb1N0cmluZygpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBTdHJpbmdCdWlsZGVyIHNiID0gbmV3IFN0cmluZ0J1aWxkZXIoKTtcclxuICAgICAgICAgICAgQWR2YW5jaW5nRnJvbnROb2RlIG5vZGUgPSBIZWFkO1xyXG4gICAgICAgICAgICB3aGlsZSAobm9kZSAhPSBUYWlsKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBzYi5BcHBlbmQobm9kZS5Qb2ludC5YKS5BcHBlbmQoXCItPlwiKTtcclxuICAgICAgICAgICAgICAgIG5vZGUgPSBub2RlLk5leHQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgc2IuQXBwZW5kKFRhaWwuUG9pbnQuWCk7XHJcbiAgICAgICAgICAgIHJldHVybiBzYi5Ub1N0cmluZygpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBNTTogIFRoaXMgc2VlbXMgdG8gYmUgdXNlZCBieSBMb2NhdGVOb2RlIHRvIGd1ZXNzIGEgcG9zaXRpb24gaW4gdGhlIGltcGxpY2l0IGxpbmtlZCBsaXN0IG9mIEFkdmFuY2luZ0Zyb250Tm9kZXMgbmVhciB4XHJcbiAgICAgICAgLy8vICAgICAgUmVtb3ZlZCBhbiBvdmVybG9hZCB0aGF0IGRlcGVuZGVkIG9uIHRoaXMgYmVpbmcgZXhhY3RcclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIHByaXZhdGUgQWR2YW5jaW5nRnJvbnROb2RlIEZpbmRTZWFyY2hOb2RlKGRvdWJsZSB4KVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgLy8gVE9ETzogaW1wbGVtZW50IEJTVCBpbmRleCBcclxuICAgICAgICAgICAgcmV0dXJuIFNlYXJjaDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gV2UgdXNlIGEgYmFsYW5jaW5nIHRyZWUgdG8gbG9jYXRlIGEgbm9kZSBzbWFsbGVyIG9yIGVxdWFsIHRvIGdpdmVuIGtleSB2YWx1ZVxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgcHVibGljIEFkdmFuY2luZ0Zyb250Tm9kZSBMb2NhdGVOb2RlKFRyaWFuZ3VsYXRpb25Qb2ludCBwb2ludClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiBMb2NhdGVOb2RlKHBvaW50LlgpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHJpdmF0ZSBBZHZhbmNpbmdGcm9udE5vZGUgTG9jYXRlTm9kZShkb3VibGUgeClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIEFkdmFuY2luZ0Zyb250Tm9kZSBub2RlID0gRmluZFNlYXJjaE5vZGUoeCk7XHJcbiAgICAgICAgICAgIGlmICh4IDwgbm9kZS5WYWx1ZSlcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgd2hpbGUgKChub2RlID0gbm9kZS5QcmV2KSAhPSBudWxsKVxyXG4gICAgICAgICAgICAgICAgICAgIGlmICh4ID49IG5vZGUuVmFsdWUpXHJcbiAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBTZWFyY2ggPSBub2RlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbm9kZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB3aGlsZSAoKG5vZGUgPSBub2RlLk5leHQpICE9IG51bGwpXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHggPCBub2RlLlZhbHVlKVxyXG4gICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgU2VhcmNoID0gbm9kZS5QcmV2O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbm9kZS5QcmV2O1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gVGhpcyBpbXBsZW1lbnRhdGlvbiB3aWxsIHVzZSBzaW1wbGUgbm9kZSB0cmF2ZXJzYWwgYWxnb3JpdGhtIHRvIGZpbmQgYSBwb2ludCBvbiB0aGUgZnJvbnRcclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIHB1YmxpYyBBZHZhbmNpbmdGcm9udE5vZGUgTG9jYXRlUG9pbnQoVHJpYW5ndWxhdGlvblBvaW50IHBvaW50KVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgZG91YmxlIHB4ID0gcG9pbnQuWDtcclxuICAgICAgICAgICAgQWR2YW5jaW5nRnJvbnROb2RlIG5vZGUgPSBGaW5kU2VhcmNoTm9kZShweCk7XHJcbiAgICAgICAgICAgIGRvdWJsZSBueCA9IG5vZGUuUG9pbnQuWDtcclxuXHJcbiAgICAgICAgICAgIGlmIChweCA9PSBueClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgaWYgKHBvaW50ICE9IG5vZGUuUG9pbnQpXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gV2UgbWlnaHQgaGF2ZSB0d28gbm9kZXMgd2l0aCBzYW1lIHggdmFsdWUgZm9yIGEgc2hvcnQgdGltZVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChwb2ludCA9PSBub2RlLlByZXYuUG9pbnQpXHJcbiAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBub2RlID0gbm9kZS5QcmV2O1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChwb2ludCA9PSBub2RlLk5leHQuUG9pbnQpXHJcbiAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBub2RlID0gbm9kZS5OZXh0O1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXhjZXB0aW9uKFwiRmFpbGVkIHRvIGZpbmQgTm9kZSBmb3IgZ2l2ZW4gYWZyb250IHBvaW50XCIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvL25vZGUgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChweCA8IG54KVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB3aGlsZSAoKG5vZGUgPSBub2RlLlByZXYpICE9IG51bGwpXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBvaW50ID09IG5vZGUuUG9pbnQpXHJcbiAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB3aGlsZSAoKG5vZGUgPSBub2RlLk5leHQpICE9IG51bGwpXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBvaW50ID09IG5vZGUuUG9pbnQpXHJcbiAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgU2VhcmNoID0gbm9kZTtcclxuICAgICAgICAgICAgcmV0dXJuIG5vZGU7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59IiwiLyogUG9seTJUcmlcclxuICogQ29weXJpZ2h0IChjKSAyMDA5LTIwMTAsIFBvbHkyVHJpIENvbnRyaWJ1dG9yc1xyXG4gKiBodHRwOi8vY29kZS5nb29nbGUuY29tL3AvcG9seTJ0cmkvXHJcbiAqXHJcbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqXHJcbiAqIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGggb3Igd2l0aG91dCBtb2RpZmljYXRpb24sXHJcbiAqIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnMgYXJlIG1ldDpcclxuICpcclxuICogKiBSZWRpc3RyaWJ1dGlvbnMgb2Ygc291cmNlIGNvZGUgbXVzdCByZXRhaW4gdGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UsXHJcbiAqICAgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lci5cclxuICogKiBSZWRpc3RyaWJ1dGlvbnMgaW4gYmluYXJ5IGZvcm0gbXVzdCByZXByb2R1Y2UgdGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UsXHJcbiAqICAgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lciBpbiB0aGUgZG9jdW1lbnRhdGlvblxyXG4gKiAgIGFuZC9vciBvdGhlciBtYXRlcmlhbHMgcHJvdmlkZWQgd2l0aCB0aGUgZGlzdHJpYnV0aW9uLlxyXG4gKiAqIE5laXRoZXIgdGhlIG5hbWUgb2YgUG9seTJUcmkgbm9yIHRoZSBuYW1lcyBvZiBpdHMgY29udHJpYnV0b3JzIG1heSBiZVxyXG4gKiAgIHVzZWQgdG8gZW5kb3JzZSBvciBwcm9tb3RlIHByb2R1Y3RzIGRlcml2ZWQgZnJvbSB0aGlzIHNvZnR3YXJlIHdpdGhvdXQgc3BlY2lmaWNcclxuICogICBwcmlvciB3cml0dGVuIHBlcm1pc3Npb24uXHJcbiAqXHJcbiAqIFRISVMgU09GVFdBUkUgSVMgUFJPVklERUQgQlkgVEhFIENPUFlSSUdIVCBIT0xERVJTIEFORCBDT05UUklCVVRPUlNcclxuICogXCJBUyBJU1wiIEFORCBBTlkgRVhQUkVTUyBPUiBJTVBMSUVEIFdBUlJBTlRJRVMsIElOQ0xVRElORywgQlVUIE5PVFxyXG4gKiBMSU1JVEVEIFRPLCBUSEUgSU1QTElFRCBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSBBTkQgRklUTkVTUyBGT1JcclxuICogQSBQQVJUSUNVTEFSIFBVUlBPU0UgQVJFIERJU0NMQUlNRUQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBDT1BZUklHSFQgT1dORVIgT1JcclxuICogQ09OVFJJQlVUT1JTIEJFIExJQUJMRSBGT1IgQU5ZIERJUkVDVCwgSU5ESVJFQ1QsIElOQ0lERU5UQUwsIFNQRUNJQUwsXHJcbiAqIEVYRU1QTEFSWSwgT1IgQ09OU0VRVUVOVElBTCBEQU1BR0VTIChJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRCBUTyxcclxuICogUFJPQ1VSRU1FTlQgT0YgU1VCU1RJVFVURSBHT09EUyBPUiBTRVJWSUNFUzsgTE9TUyBPRiBVU0UsIERBVEEsIE9SXHJcbiAqIFBST0ZJVFM7IE9SIEJVU0lORVNTIElOVEVSUlVQVElPTikgSE9XRVZFUiBDQVVTRUQgQU5EIE9OIEFOWSBUSEVPUlkgT0ZcclxuICogTElBQklMSVRZLCBXSEVUSEVSIElOIENPTlRSQUNULCBTVFJJQ1QgTElBQklMSVRZLCBPUiBUT1JUIChJTkNMVURJTkdcclxuICogTkVHTElHRU5DRSBPUiBPVEhFUldJU0UpIEFSSVNJTkcgSU4gQU5ZIFdBWSBPVVQgT0YgVEhFIFVTRSBPRiBUSElTXHJcbiAqIFNPRlRXQVJFLCBFVkVOIElGIEFEVklTRUQgT0YgVEhFIFBPU1NJQklMSVRZIE9GIFNVQ0ggREFNQUdFLlxyXG4gKi9cclxuXHJcbi8vIENoYW5nZXMgZnJvbSB0aGUgSmF2YSB2ZXJzaW9uXHJcbi8vICAgUmVtb3ZlZCBnZXR0ZXJzXHJcbi8vICAgSGFzKiB0dXJuZWQgaW50byBhdHRyaWJ1dGVzXHJcbi8vIEZ1dHVyZSBwb3NzaWJpbGl0aWVzXHJcbi8vICAgQ29tbWVudHMhXHJcblxyXG5uYW1lc3BhY2UgUG9seTJUcmkuVHJpYW5ndWxhdGlvbi5EZWxhdW5heS5Td2VlcFxyXG57XHJcbiAgICBwdWJsaWMgY2xhc3MgQWR2YW5jaW5nRnJvbnROb2RlXHJcbiAgICB7XHJcbiAgICAgICAgcHVibGljIEFkdmFuY2luZ0Zyb250Tm9kZSBOZXh0O1xyXG4gICAgICAgIHB1YmxpYyBUcmlhbmd1bGF0aW9uUG9pbnQgUG9pbnQ7XHJcbiAgICAgICAgcHVibGljIEFkdmFuY2luZ0Zyb250Tm9kZSBQcmV2O1xyXG4gICAgICAgIHB1YmxpYyBEZWxhdW5heVRyaWFuZ2xlIFRyaWFuZ2xlO1xyXG4gICAgICAgIHB1YmxpYyBkb3VibGUgVmFsdWU7XHJcblxyXG4gICAgICAgIHB1YmxpYyBBZHZhbmNpbmdGcm9udE5vZGUoVHJpYW5ndWxhdGlvblBvaW50IHBvaW50KVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgUG9pbnQgPSBwb2ludDtcclxuICAgICAgICAgICAgVmFsdWUgPSBwb2ludC5YO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHVibGljIGJvb2wgSGFzTmV4dFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgZ2V0IHsgcmV0dXJuIE5leHQgIT0gbnVsbDsgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHVibGljIGJvb2wgSGFzUHJldlxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgZ2V0IHsgcmV0dXJuIFByZXYgIT0gbnVsbDsgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxufSIsIi8qIFBvbHkyVHJpXHJcbiAqIENvcHlyaWdodCAoYykgMjAwOS0yMDEwLCBQb2x5MlRyaSBDb250cmlidXRvcnNcclxuICogaHR0cDovL2NvZGUuZ29vZ2xlLmNvbS9wL3BvbHkydHJpL1xyXG4gKlxyXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKlxyXG4gKiBSZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRoIG9yIHdpdGhvdXQgbW9kaWZpY2F0aW9uLFxyXG4gKiBhcmUgcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBjb25kaXRpb25zIGFyZSBtZXQ6XHJcbiAqXHJcbiAqICogUmVkaXN0cmlidXRpb25zIG9mIHNvdXJjZSBjb2RlIG11c3QgcmV0YWluIHRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlLFxyXG4gKiAgIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIuXHJcbiAqICogUmVkaXN0cmlidXRpb25zIGluIGJpbmFyeSBmb3JtIG11c3QgcmVwcm9kdWNlIHRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlLFxyXG4gKiAgIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIgaW4gdGhlIGRvY3VtZW50YXRpb25cclxuICogICBhbmQvb3Igb3RoZXIgbWF0ZXJpYWxzIHByb3ZpZGVkIHdpdGggdGhlIGRpc3RyaWJ1dGlvbi5cclxuICogKiBOZWl0aGVyIHRoZSBuYW1lIG9mIFBvbHkyVHJpIG5vciB0aGUgbmFtZXMgb2YgaXRzIGNvbnRyaWJ1dG9ycyBtYXkgYmVcclxuICogICB1c2VkIHRvIGVuZG9yc2Ugb3IgcHJvbW90ZSBwcm9kdWN0cyBkZXJpdmVkIGZyb20gdGhpcyBzb2Z0d2FyZSB3aXRob3V0IHNwZWNpZmljXHJcbiAqICAgcHJpb3Igd3JpdHRlbiBwZXJtaXNzaW9uLlxyXG4gKlxyXG4gKiBUSElTIFNPRlRXQVJFIElTIFBST1ZJREVEIEJZIFRIRSBDT1BZUklHSFQgSE9MREVSUyBBTkQgQ09OVFJJQlVUT1JTXHJcbiAqIFwiQVMgSVNcIiBBTkQgQU5ZIEVYUFJFU1MgT1IgSU1QTElFRCBXQVJSQU5USUVTLCBJTkNMVURJTkcsIEJVVCBOT1RcclxuICogTElNSVRFRCBUTywgVEhFIElNUExJRUQgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFkgQU5EIEZJVE5FU1MgRk9SXHJcbiAqIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFSRSBESVNDTEFJTUVELiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQ09QWVJJR0hUIE9XTkVSIE9SXHJcbiAqIENPTlRSSUJVVE9SUyBCRSBMSUFCTEUgRk9SIEFOWSBESVJFQ1QsIElORElSRUNULCBJTkNJREVOVEFMLCBTUEVDSUFMLFxyXG4gKiBFWEVNUExBUlksIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFUyAoSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sXHJcbiAqIFBST0NVUkVNRU5UIE9GIFNVQlNUSVRVVEUgR09PRFMgT1IgU0VSVklDRVM7IExPU1MgT0YgVVNFLCBEQVRBLCBPUlxyXG4gKiBQUk9GSVRTOyBPUiBCVVNJTkVTUyBJTlRFUlJVUFRJT04pIEhPV0VWRVIgQ0FVU0VEIEFORCBPTiBBTlkgVEhFT1JZIE9GXHJcbiAqIExJQUJJTElUWSwgV0hFVEhFUiBJTiBDT05UUkFDVCwgU1RSSUNUIExJQUJJTElUWSwgT1IgVE9SVCAoSU5DTFVESU5HXHJcbiAqIE5FR0xJR0VOQ0UgT1IgT1RIRVJXSVNFKSBBUklTSU5HIElOIEFOWSBXQVkgT1VUIE9GIFRIRSBVU0UgT0YgVEhJU1xyXG4gKiBTT0ZUV0FSRSwgRVZFTiBJRiBBRFZJU0VEIE9GIFRIRSBQT1NTSUJJTElUWSBPRiBTVUNIIERBTUFHRS5cclxuICovXHJcblxyXG4vKlxyXG4gKiBTd2VlcC1saW5lLCBDb25zdHJhaW5lZCBEZWxhdW5leSBUcmlhbmd1bGF0aW9uIChDRFQpIFNlZTogRG9taXRlciwgVi4gYW5kXHJcbiAqIFphbGlrLCBCLigyMDA4KSdTd2VlcC1saW5lIGFsZ29yaXRobSBmb3IgY29uc3RyYWluZWQgRGVsYXVuYXkgdHJpYW5ndWxhdGlvbicsXHJcbiAqIEludGVybmF0aW9uYWwgSm91cm5hbCBvZiBHZW9ncmFwaGljYWwgSW5mb3JtYXRpb24gU2NpZW5jZVxyXG4gKiBcclxuICogXCJGbGlwU2NhblwiIENvbnN0cmFpbmVkIEVkZ2UgQWxnb3JpdGhtIGludmVudGVkIGJ5IGF1dGhvciBvZiB0aGlzIGNvZGUuXHJcbiAqIFxyXG4gKiBBdXRob3I6IFRob21hcyDDhWhsw6luLCB0aGFobGVuQGdtYWlsLmNvbSBcclxuICovXHJcblxyXG4vLyBDaGFuZ2VzIGZyb20gdGhlIEphdmEgdmVyc2lvblxyXG4vLyAgIFR1cm5lZCBEVFN3ZWVwIGludG8gYSBzdGF0aWMgY2xhc3NcclxuLy8gICBMb3RzIG9mIGRlaW5kZW50YXRpb24gdmlhIGVhcmx5IGJhaWxvdXRcclxuLy8gRnV0dXJlIHBvc3NpYmlsaXRpZXNcclxuLy8gICBDb21tZW50cyFcclxuXHJcbnVzaW5nIFN5c3RlbTtcclxudXNpbmcgU3lzdGVtLkNvbGxlY3Rpb25zLkdlbmVyaWM7XHJcbnVzaW5nIFN5c3RlbS5EaWFnbm9zdGljcztcclxudXNpbmcgRmFyc2VlclBoeXNpY3MuQ29tbW9uLkRlY29tcG9zaXRpb24uQ0RUO1xyXG5cclxubmFtZXNwYWNlIFBvbHkyVHJpLlRyaWFuZ3VsYXRpb24uRGVsYXVuYXkuU3dlZXBcclxue1xyXG4gICAgcHVibGljIHN0YXRpYyBjbGFzcyBEVFN3ZWVwXHJcbiAgICB7XHJcbiAgICAgICAgcHJpdmF0ZSBjb25zdCBkb3VibGUgUElfZGl2MiA9IE1hdGguUEkvMjtcclxuICAgICAgICBwcml2YXRlIGNvbnN0IGRvdWJsZSBQSV8zZGl2NCA9IDMqTWF0aC5QSS80O1xyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIFRyaWFuZ3VsYXRlIHNpbXBsZSBwb2x5Z29uIHdpdGggaG9sZXNcclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIHB1YmxpYyBzdGF0aWMgdm9pZCBUcmlhbmd1bGF0ZShEVFN3ZWVwQ29udGV4dCB0Y3gpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB0Y3guQ3JlYXRlQWR2YW5jaW5nRnJvbnQoKTtcclxuXHJcbiAgICAgICAgICAgIFN3ZWVwKHRjeCk7XHJcblxyXG4gICAgICAgICAgICAvLyBGaW5hbGl6ZSB0cmlhbmd1bGF0aW9uXHJcbiAgICAgICAgICAgIGlmICh0Y3guVHJpYW5ndWxhdGlvbk1vZGUgPT0gVHJpYW5ndWxhdGlvbk1vZGUuUG9seWdvbilcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgRmluYWxpemF0aW9uUG9seWdvbih0Y3gpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgRmluYWxpemF0aW9uQ29udmV4SHVsbCh0Y3gpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB0Y3guRG9uZSgpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBTdGFydCBzd2VlcGluZyB0aGUgWS1zb3J0ZWQgcG9pbnQgc2V0IGZyb20gYm90dG9tIHRvIHRvcFxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgcHJpdmF0ZSBzdGF0aWMgdm9pZCBTd2VlcChEVFN3ZWVwQ29udGV4dCB0Y3gpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBMaXN0PFRyaWFuZ3VsYXRpb25Qb2ludD4gcG9pbnRzID0gdGN4LlBvaW50cztcclxuICAgICAgICAgICAgVHJpYW5ndWxhdGlvblBvaW50IHBvaW50O1xyXG4gICAgICAgICAgICBBZHZhbmNpbmdGcm9udE5vZGUgbm9kZTtcclxuXHJcbiAgICAgICAgICAgIGZvciAoaW50IGkgPSAxOyBpIDwgcG9pbnRzLkNvdW50OyBpKyspXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHBvaW50ID0gcG9pbnRzW2ldO1xyXG5cclxuICAgICAgICAgICAgICAgIG5vZGUgPSBQb2ludEV2ZW50KHRjeCwgcG9pbnQpO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmIChwb2ludC5IYXNFZGdlcylcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBmb3JlYWNoIChEVFN3ZWVwQ29uc3RyYWludCBlIGluIHBvaW50LkVkZ2VzKVxyXG4gICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgRWRnZUV2ZW50KHRjeCwgZSwgbm9kZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdGN4LlVwZGF0ZShudWxsKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBJZiB0aGlzIGlzIGEgRGVsYXVuYXkgVHJpYW5ndWxhdGlvbiBvZiBhIHBvaW50c2V0IHdlIG5lZWQgdG8gZmlsbCBzbyB0aGUgdHJpYW5nbGUgbWVzaCBnZXRzIGEgQ29udmV4SHVsbCBcclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIHByaXZhdGUgc3RhdGljIHZvaWQgRmluYWxpemF0aW9uQ29udmV4SHVsbChEVFN3ZWVwQ29udGV4dCB0Y3gpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBBZHZhbmNpbmdGcm9udE5vZGUgbjEsIG4yO1xyXG4gICAgICAgICAgICBEZWxhdW5heVRyaWFuZ2xlIHQxLCB0MjtcclxuICAgICAgICAgICAgVHJpYW5ndWxhdGlvblBvaW50IGZpcnN0LCBwMTtcclxuXHJcbiAgICAgICAgICAgIG4xID0gdGN4LmFGcm9udC5IZWFkLk5leHQ7XHJcbiAgICAgICAgICAgIG4yID0gbjEuTmV4dDtcclxuICAgICAgICAgICAgZmlyc3QgPSBuMS5Qb2ludDtcclxuXHJcbiAgICAgICAgICAgIFR1cm5BZHZhbmNpbmdGcm9udENvbnZleCh0Y3gsIG4xLCBuMik7XHJcblxyXG4gICAgICAgICAgICAvLyBUT0RPOiBpbXBsZW1lbnQgQ29udmV4SHVsbCBmb3IgbG93ZXIgcmlnaHQgYW5kIGxlZnQgYm91bmRhcnlcclxuXHJcbiAgICAgICAgICAgIC8vIExldHMgcmVtb3ZlIHRyaWFuZ2xlcyBjb25uZWN0ZWQgdG8gdGhlIHR3byBcImFsZ29yaXRobVwiIHBvaW50c1xyXG5cclxuICAgICAgICAgICAgLy8gWFhYOiBXaGVuIHRoZSBmaXJzdCB0aGUgbm9kZXMgYXJlIHBvaW50cyBpbiBhIHRyaWFuZ2xlIHdlIG5lZWQgdG8gZG8gYSBmbGlwIGJlZm9yZSBcclxuICAgICAgICAgICAgLy8gICAgICByZW1vdmluZyB0cmlhbmdsZXMgb3Igd2Ugd2lsbCBsb3NlIGEgdmFsaWQgdHJpYW5nbGUuXHJcbiAgICAgICAgICAgIC8vICAgICAgU2FtZSBmb3IgbGFzdCB0aHJlZSBub2RlcyFcclxuICAgICAgICAgICAgLy8gISEhIElmIEkgaW1wbGVtZW50IENvbnZleEh1bGwgZm9yIGxvd2VyIHJpZ2h0IGFuZCBsZWZ0IGJvdW5kYXJ5IHRoaXMgZml4IHNob3VsZCBub3QgYmUgXHJcbiAgICAgICAgICAgIC8vICAgICBuZWVkZWQgYW5kIHRoZSByZW1vdmVkIHRyaWFuZ2xlcyB3aWxsIGJlIGFkZGVkIGFnYWluIGJ5IGRlZmF1bHRcclxuICAgICAgICAgICAgbjEgPSB0Y3guYUZyb250LlRhaWwuUHJldjtcclxuICAgICAgICAgICAgaWYgKG4xLlRyaWFuZ2xlLkNvbnRhaW5zKG4xLk5leHQuUG9pbnQpICYmIG4xLlRyaWFuZ2xlLkNvbnRhaW5zKG4xLlByZXYuUG9pbnQpKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB0MSA9IG4xLlRyaWFuZ2xlLk5laWdoYm9yQWNyb3NzKG4xLlBvaW50KTtcclxuICAgICAgICAgICAgICAgIFJvdGF0ZVRyaWFuZ2xlUGFpcihuMS5UcmlhbmdsZSwgbjEuUG9pbnQsIHQxLCB0MS5PcHBvc2l0ZVBvaW50KG4xLlRyaWFuZ2xlLCBuMS5Qb2ludCkpO1xyXG4gICAgICAgICAgICAgICAgdGN4Lk1hcFRyaWFuZ2xlVG9Ob2RlcyhuMS5UcmlhbmdsZSk7XHJcbiAgICAgICAgICAgICAgICB0Y3guTWFwVHJpYW5nbGVUb05vZGVzKHQxKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBuMSA9IHRjeC5hRnJvbnQuSGVhZC5OZXh0O1xyXG4gICAgICAgICAgICBpZiAobjEuVHJpYW5nbGUuQ29udGFpbnMobjEuUHJldi5Qb2ludCkgJiYgbjEuVHJpYW5nbGUuQ29udGFpbnMobjEuTmV4dC5Qb2ludCkpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHQxID0gbjEuVHJpYW5nbGUuTmVpZ2hib3JBY3Jvc3MobjEuUG9pbnQpO1xyXG4gICAgICAgICAgICAgICAgUm90YXRlVHJpYW5nbGVQYWlyKG4xLlRyaWFuZ2xlLCBuMS5Qb2ludCwgdDEsIHQxLk9wcG9zaXRlUG9pbnQobjEuVHJpYW5nbGUsIG4xLlBvaW50KSk7XHJcbiAgICAgICAgICAgICAgICB0Y3guTWFwVHJpYW5nbGVUb05vZGVzKG4xLlRyaWFuZ2xlKTtcclxuICAgICAgICAgICAgICAgIHRjeC5NYXBUcmlhbmdsZVRvTm9kZXModDEpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBMb3dlciByaWdodCBib3VuZGFyeSBcclxuICAgICAgICAgICAgZmlyc3QgPSB0Y3guYUZyb250LkhlYWQuUG9pbnQ7XHJcbiAgICAgICAgICAgIG4yID0gdGN4LmFGcm9udC5UYWlsLlByZXY7XHJcbiAgICAgICAgICAgIHQxID0gbjIuVHJpYW5nbGU7XHJcbiAgICAgICAgICAgIHAxID0gbjIuUG9pbnQ7XHJcbiAgICAgICAgICAgIG4yLlRyaWFuZ2xlID0gbnVsbDtcclxuICAgICAgICAgICAgZG9cclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdGN4LlJlbW92ZUZyb21MaXN0KHQxKTtcclxuICAgICAgICAgICAgICAgIHAxID0gdDEuUG9pbnRDQ1cocDEpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHAxID09IGZpcnN0KSBicmVhaztcclxuICAgICAgICAgICAgICAgIHQyID0gdDEuTmVpZ2hib3JDQ1cocDEpO1xyXG4gICAgICAgICAgICAgICAgdDEuQ2xlYXIoKTtcclxuICAgICAgICAgICAgICAgIHQxID0gdDI7XHJcbiAgICAgICAgICAgIH0gd2hpbGUgKHRydWUpO1xyXG5cclxuICAgICAgICAgICAgLy8gTG93ZXIgbGVmdCBib3VuZGFyeVxyXG4gICAgICAgICAgICBmaXJzdCA9IHRjeC5hRnJvbnQuSGVhZC5OZXh0LlBvaW50O1xyXG4gICAgICAgICAgICBwMSA9IHQxLlBvaW50Q1codGN4LmFGcm9udC5IZWFkLlBvaW50KTtcclxuICAgICAgICAgICAgdDIgPSB0MS5OZWlnaGJvckNXKHRjeC5hRnJvbnQuSGVhZC5Qb2ludCk7XHJcbiAgICAgICAgICAgIHQxLkNsZWFyKCk7XHJcbiAgICAgICAgICAgIHQxID0gdDI7XHJcbiAgICAgICAgICAgIHdoaWxlIChwMSAhPSBmaXJzdCkgLy9UT0RPOiBQb3J0IG5vdGUuIFRoaXMgd2FzIGRvIHdoaWxlIGJlZm9yZS5cclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdGN4LlJlbW92ZUZyb21MaXN0KHQxKTtcclxuICAgICAgICAgICAgICAgIHAxID0gdDEuUG9pbnRDQ1cocDEpO1xyXG4gICAgICAgICAgICAgICAgdDIgPSB0MS5OZWlnaGJvckNDVyhwMSk7XHJcbiAgICAgICAgICAgICAgICB0MS5DbGVhcigpO1xyXG4gICAgICAgICAgICAgICAgdDEgPSB0MjtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gUmVtb3ZlIGN1cnJlbnQgaGVhZCBhbmQgdGFpbCBub2RlIG5vdyB0aGF0IHdlIGhhdmUgcmVtb3ZlZCBhbGwgdHJpYW5nbGVzIGF0dGFjaGVkXHJcbiAgICAgICAgICAgIC8vIHRvIHRoZW0uIFRoZW4gc2V0IG5ldyBoZWFkIGFuZCB0YWlsIG5vZGUgcG9pbnRzXHJcbiAgICAgICAgICAgIHRjeC5hRnJvbnQuSGVhZCA9IHRjeC5hRnJvbnQuSGVhZC5OZXh0O1xyXG4gICAgICAgICAgICB0Y3guYUZyb250LkhlYWQuUHJldiA9IG51bGw7XHJcbiAgICAgICAgICAgIHRjeC5hRnJvbnQuVGFpbCA9IHRjeC5hRnJvbnQuVGFpbC5QcmV2O1xyXG4gICAgICAgICAgICB0Y3guYUZyb250LlRhaWwuTmV4dCA9IG51bGw7XHJcblxyXG4gICAgICAgICAgICB0Y3guRmluYWxpemVUcmlhbmd1bGF0aW9uKCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIFdlIHdpbGwgdHJhdmVyc2UgdGhlIGVudGlyZSBhZHZhbmNpbmcgZnJvbnQgYW5kIGZpbGwgaXQgdG8gZm9ybSBhIGNvbnZleCBodWxsLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgcHJpdmF0ZSBzdGF0aWMgdm9pZCBUdXJuQWR2YW5jaW5nRnJvbnRDb252ZXgoRFRTd2VlcENvbnRleHQgdGN4LCBBZHZhbmNpbmdGcm9udE5vZGUgYiwgQWR2YW5jaW5nRnJvbnROb2RlIGMpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBBZHZhbmNpbmdGcm9udE5vZGUgZmlyc3QgPSBiO1xyXG4gICAgICAgICAgICB3aGlsZSAoYyAhPSB0Y3guYUZyb250LlRhaWwpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGlmIChUcmlhbmd1bGF0aW9uVXRpbC5PcmllbnQyZChiLlBvaW50LCBjLlBvaW50LCBjLk5leHQuUG9pbnQpID09IE9yaWVudGF0aW9uLkNDVylcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBbYixjLGRdIENvbmNhdmUgLSBmaWxsIGFyb3VuZCBjXHJcbiAgICAgICAgICAgICAgICAgICAgRmlsbCh0Y3gsIGMpO1xyXG4gICAgICAgICAgICAgICAgICAgIGMgPSBjLk5leHQ7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gW2IsYyxkXSBDb252ZXhcclxuICAgICAgICAgICAgICAgICAgICBpZiAoYiAhPSBmaXJzdCAmJiBUcmlhbmd1bGF0aW9uVXRpbC5PcmllbnQyZChiLlByZXYuUG9pbnQsIGIuUG9pbnQsIGMuUG9pbnQpID09IE9yaWVudGF0aW9uLkNDVylcclxuICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFthLGIsY10gQ29uY2F2ZSAtIGZpbGwgYXJvdW5kIGJcclxuICAgICAgICAgICAgICAgICAgICAgICAgRmlsbCh0Y3gsIGIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBiID0gYi5QcmV2O1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBbYSxiLGNdIENvbnZleCAtIG5vdGhpbmcgdG8gZmlsbFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBiID0gYztcclxuICAgICAgICAgICAgICAgICAgICAgICAgYyA9IGMuTmV4dDtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHByaXZhdGUgc3RhdGljIHZvaWQgRmluYWxpemF0aW9uUG9seWdvbihEVFN3ZWVwQ29udGV4dCB0Y3gpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICAvLyBHZXQgYW4gSW50ZXJuYWwgdHJpYW5nbGUgdG8gc3RhcnQgd2l0aFxyXG4gICAgICAgICAgICBEZWxhdW5heVRyaWFuZ2xlIHQgPSB0Y3guYUZyb250LkhlYWQuTmV4dC5UcmlhbmdsZTtcclxuICAgICAgICAgICAgVHJpYW5ndWxhdGlvblBvaW50IHAgPSB0Y3guYUZyb250LkhlYWQuTmV4dC5Qb2ludDtcclxuICAgICAgICAgICAgd2hpbGUgKCF0LkdldENvbnN0cmFpbmVkRWRnZUNXKHApKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB0ID0gdC5OZWlnaGJvckNDVyhwKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gQ29sbGVjdCBpbnRlcmlvciB0cmlhbmdsZXMgY29uc3RyYWluZWQgYnkgZWRnZXNcclxuICAgICAgICAgICAgdGN4Lk1lc2hDbGVhbih0KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gRmluZCBjbG9zZXMgbm9kZSB0byB0aGUgbGVmdCBvZiB0aGUgbmV3IHBvaW50IGFuZFxyXG4gICAgICAgIC8vLyBjcmVhdGUgYSBuZXcgdHJpYW5nbGUuIElmIG5lZWRlZCBuZXcgaG9sZXMgYW5kIGJhc2luc1xyXG4gICAgICAgIC8vLyB3aWxsIGJlIGZpbGxlZCB0by5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIHByaXZhdGUgc3RhdGljIEFkdmFuY2luZ0Zyb250Tm9kZSBQb2ludEV2ZW50KERUU3dlZXBDb250ZXh0IHRjeCwgVHJpYW5ndWxhdGlvblBvaW50IHBvaW50KVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgQWR2YW5jaW5nRnJvbnROb2RlIG5vZGUsIG5ld05vZGU7XHJcblxyXG4gICAgICAgICAgICBub2RlID0gdGN4LkxvY2F0ZU5vZGUocG9pbnQpO1xyXG4gICAgICAgICAgICBuZXdOb2RlID0gTmV3RnJvbnRUcmlhbmdsZSh0Y3gsIHBvaW50LCBub2RlKTtcclxuXHJcbiAgICAgICAgICAgIC8vIE9ubHkgbmVlZCB0byBjaGVjayArZXBzaWxvbiBzaW5jZSBwb2ludCBuZXZlciBoYXZlIHNtYWxsZXIgXHJcbiAgICAgICAgICAgIC8vIHggdmFsdWUgdGhhbiBub2RlIGR1ZSB0byBob3cgd2UgZmV0Y2ggbm9kZXMgZnJvbSB0aGUgZnJvbnRcclxuICAgICAgICAgICAgaWYgKHBvaW50LlggPD0gbm9kZS5Qb2ludC5YICsgVHJpYW5ndWxhdGlvblV0aWwuRVBTSUxPTilcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgRmlsbCh0Y3gsIG5vZGUpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB0Y3guQWRkTm9kZShuZXdOb2RlKTtcclxuXHJcbiAgICAgICAgICAgIEZpbGxBZHZhbmNpbmdGcm9udCh0Y3gsIG5ld05vZGUpO1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3Tm9kZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gQ3JlYXRlcyBhIG5ldyBmcm9udCB0cmlhbmdsZSBhbmQgbGVnYWxpemUgaXRcclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIHByaXZhdGUgc3RhdGljIEFkdmFuY2luZ0Zyb250Tm9kZSBOZXdGcm9udFRyaWFuZ2xlKERUU3dlZXBDb250ZXh0IHRjeCwgVHJpYW5ndWxhdGlvblBvaW50IHBvaW50LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEFkdmFuY2luZ0Zyb250Tm9kZSBub2RlKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgQWR2YW5jaW5nRnJvbnROb2RlIG5ld05vZGU7XHJcbiAgICAgICAgICAgIERlbGF1bmF5VHJpYW5nbGUgdHJpYW5nbGU7XHJcblxyXG4gICAgICAgICAgICB0cmlhbmdsZSA9IG5ldyBEZWxhdW5heVRyaWFuZ2xlKHBvaW50LCBub2RlLlBvaW50LCBub2RlLk5leHQuUG9pbnQpO1xyXG4gICAgICAgICAgICB0cmlhbmdsZS5NYXJrTmVpZ2hib3Iobm9kZS5UcmlhbmdsZSk7XHJcbiAgICAgICAgICAgIHRjeC5UcmlhbmdsZXMuQWRkKHRyaWFuZ2xlKTtcclxuXHJcbiAgICAgICAgICAgIG5ld05vZGUgPSBuZXcgQWR2YW5jaW5nRnJvbnROb2RlKHBvaW50KTtcclxuICAgICAgICAgICAgbmV3Tm9kZS5OZXh0ID0gbm9kZS5OZXh0O1xyXG4gICAgICAgICAgICBuZXdOb2RlLlByZXYgPSBub2RlO1xyXG4gICAgICAgICAgICBub2RlLk5leHQuUHJldiA9IG5ld05vZGU7XHJcbiAgICAgICAgICAgIG5vZGUuTmV4dCA9IG5ld05vZGU7XHJcblxyXG4gICAgICAgICAgICB0Y3guQWRkTm9kZShuZXdOb2RlKTsgLy8gWFhYOiBCU1RcclxuXHJcbiAgICAgICAgICAgIGlmICghTGVnYWxpemUodGN4LCB0cmlhbmdsZSkpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHRjeC5NYXBUcmlhbmdsZVRvTm9kZXModHJpYW5nbGUpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gbmV3Tm9kZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHByaXZhdGUgc3RhdGljIHZvaWQgRWRnZUV2ZW50KERUU3dlZXBDb250ZXh0IHRjeCwgRFRTd2VlcENvbnN0cmFpbnQgZWRnZSwgQWR2YW5jaW5nRnJvbnROb2RlIG5vZGUpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB0cnlcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdGN4LkVkZ2VFdmVudC5Db25zdHJhaW5lZEVkZ2UgPSBlZGdlO1xyXG4gICAgICAgICAgICAgICAgdGN4LkVkZ2VFdmVudC5SaWdodCA9IGVkZ2UuUC5YID4gZWRnZS5RLlg7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKElzRWRnZVNpZGVPZlRyaWFuZ2xlKG5vZGUuVHJpYW5nbGUsIGVkZ2UuUCwgZWRnZS5RKSlcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gRm9yIG5vdyB3ZSB3aWxsIGRvIGFsbCBuZWVkZWQgZmlsbGluZ1xyXG4gICAgICAgICAgICAgICAgLy8gVE9ETzogaW50ZWdyYXRlIHdpdGggZmxpcCBwcm9jZXNzIG1pZ2h0IGdpdmUgc29tZSBiZXR0ZXIgcGVyZm9ybWFuY2UgXHJcbiAgICAgICAgICAgICAgICAvLyAgICAgICBidXQgZm9yIG5vdyB0aGlzIGF2b2lkIHRoZSBpc3N1ZSB3aXRoIGNhc2VzIHRoYXQgbmVlZHMgYm90aCBmbGlwcyBhbmQgZmlsbHNcclxuICAgICAgICAgICAgICAgIEZpbGxFZGdlRXZlbnQodGN4LCBlZGdlLCBub2RlKTtcclxuXHJcbiAgICAgICAgICAgICAgICBFZGdlRXZlbnQodGN4LCBlZGdlLlAsIGVkZ2UuUSwgbm9kZS5UcmlhbmdsZSwgZWRnZS5RKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjYXRjaCAoUG9pbnRPbkVkZ2VFeGNlcHRpb24gZSlcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgRGVidWcuV3JpdGVMaW5lKFN0cmluZy5Gb3JtYXQoXCJTa2lwcGluZyBFZGdlOiB7MH1cIiwgZS5NZXNzYWdlKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHByaXZhdGUgc3RhdGljIHZvaWQgRmlsbEVkZ2VFdmVudChEVFN3ZWVwQ29udGV4dCB0Y3gsIERUU3dlZXBDb25zdHJhaW50IGVkZ2UsIEFkdmFuY2luZ0Zyb250Tm9kZSBub2RlKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgaWYgKHRjeC5FZGdlRXZlbnQuUmlnaHQpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIEZpbGxSaWdodEFib3ZlRWRnZUV2ZW50KHRjeCwgZWRnZSwgbm9kZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBGaWxsTGVmdEFib3ZlRWRnZUV2ZW50KHRjeCwgZWRnZSwgbm9kZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHByaXZhdGUgc3RhdGljIHZvaWQgRmlsbFJpZ2h0Q29uY2F2ZUVkZ2VFdmVudChEVFN3ZWVwQ29udGV4dCB0Y3gsIERUU3dlZXBDb25zdHJhaW50IGVkZ2UsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEFkdmFuY2luZ0Zyb250Tm9kZSBub2RlKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgRmlsbCh0Y3gsIG5vZGUuTmV4dCk7XHJcbiAgICAgICAgICAgIGlmIChub2RlLk5leHQuUG9pbnQgIT0gZWRnZS5QKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAvLyBOZXh0IGFib3ZlIG9yIGJlbG93IGVkZ2U/XHJcbiAgICAgICAgICAgICAgICBpZiAoVHJpYW5ndWxhdGlvblV0aWwuT3JpZW50MmQoZWRnZS5RLCBub2RlLk5leHQuUG9pbnQsIGVkZ2UuUCkgPT0gT3JpZW50YXRpb24uQ0NXKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIEJlbG93XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKFRyaWFuZ3VsYXRpb25VdGlsLk9yaWVudDJkKG5vZGUuUG9pbnQsIG5vZGUuTmV4dC5Qb2ludCwgbm9kZS5OZXh0Lk5leHQuUG9pbnQpID09IE9yaWVudGF0aW9uLkNDVylcclxuICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIE5leHQgaXMgY29uY2F2ZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBGaWxsUmlnaHRDb25jYXZlRWRnZUV2ZW50KHRjeCwgZWRnZSwgbm9kZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIE5leHQgaXMgY29udmV4XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwcml2YXRlIHN0YXRpYyB2b2lkIEZpbGxSaWdodENvbnZleEVkZ2VFdmVudChEVFN3ZWVwQ29udGV4dCB0Y3gsIERUU3dlZXBDb25zdHJhaW50IGVkZ2UsIEFkdmFuY2luZ0Zyb250Tm9kZSBub2RlKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgLy8gTmV4dCBjb25jYXZlIG9yIGNvbnZleD9cclxuICAgICAgICAgICAgaWYgKFRyaWFuZ3VsYXRpb25VdGlsLk9yaWVudDJkKG5vZGUuTmV4dC5Qb2ludCwgbm9kZS5OZXh0Lk5leHQuUG9pbnQsIG5vZGUuTmV4dC5OZXh0Lk5leHQuUG9pbnQpID09XHJcbiAgICAgICAgICAgICAgICBPcmllbnRhdGlvbi5DQ1cpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIC8vIENvbmNhdmVcclxuICAgICAgICAgICAgICAgIEZpbGxSaWdodENvbmNhdmVFZGdlRXZlbnQodGN4LCBlZGdlLCBub2RlLk5leHQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgLy8gQ29udmV4XHJcbiAgICAgICAgICAgICAgICAvLyBOZXh0IGFib3ZlIG9yIGJlbG93IGVkZ2U/XHJcbiAgICAgICAgICAgICAgICBpZiAoVHJpYW5ndWxhdGlvblV0aWwuT3JpZW50MmQoZWRnZS5RLCBub2RlLk5leHQuTmV4dC5Qb2ludCwgZWRnZS5QKSA9PSBPcmllbnRhdGlvbi5DQ1cpXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gQmVsb3dcclxuICAgICAgICAgICAgICAgICAgICBGaWxsUmlnaHRDb252ZXhFZGdlRXZlbnQodGN4LCBlZGdlLCBub2RlLk5leHQpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIEFib3ZlXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHByaXZhdGUgc3RhdGljIHZvaWQgRmlsbFJpZ2h0QmVsb3dFZGdlRXZlbnQoRFRTd2VlcENvbnRleHQgdGN4LCBEVFN3ZWVwQ29uc3RyYWludCBlZGdlLCBBZHZhbmNpbmdGcm9udE5vZGUgbm9kZSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGlmIChub2RlLlBvaW50LlggPCBlZGdlLlAuWCkgLy8gbmVlZGVkP1xyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBpZiAoVHJpYW5ndWxhdGlvblV0aWwuT3JpZW50MmQobm9kZS5Qb2ludCwgbm9kZS5OZXh0LlBvaW50LCBub2RlLk5leHQuTmV4dC5Qb2ludCkgPT0gT3JpZW50YXRpb24uQ0NXKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIENvbmNhdmUgXHJcbiAgICAgICAgICAgICAgICAgICAgRmlsbFJpZ2h0Q29uY2F2ZUVkZ2VFdmVudCh0Y3gsIGVkZ2UsIG5vZGUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIENvbnZleFxyXG4gICAgICAgICAgICAgICAgICAgIEZpbGxSaWdodENvbnZleEVkZ2VFdmVudCh0Y3gsIGVkZ2UsIG5vZGUpO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIFJldHJ5IHRoaXMgb25lXHJcbiAgICAgICAgICAgICAgICAgICAgRmlsbFJpZ2h0QmVsb3dFZGdlRXZlbnQodGN4LCBlZGdlLCBub2RlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHJpdmF0ZSBzdGF0aWMgdm9pZCBGaWxsUmlnaHRBYm92ZUVkZ2VFdmVudChEVFN3ZWVwQ29udGV4dCB0Y3gsIERUU3dlZXBDb25zdHJhaW50IGVkZ2UsIEFkdmFuY2luZ0Zyb250Tm9kZSBub2RlKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgd2hpbGUgKG5vZGUuTmV4dC5Qb2ludC5YIDwgZWRnZS5QLlgpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIC8vIENoZWNrIGlmIG5leHQgbm9kZSBpcyBiZWxvdyB0aGUgZWRnZVxyXG4gICAgICAgICAgICAgICAgT3JpZW50YXRpb24gbzEgPSBUcmlhbmd1bGF0aW9uVXRpbC5PcmllbnQyZChlZGdlLlEsIG5vZGUuTmV4dC5Qb2ludCwgZWRnZS5QKTtcclxuICAgICAgICAgICAgICAgIGlmIChvMSA9PSBPcmllbnRhdGlvbi5DQ1cpXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgRmlsbFJpZ2h0QmVsb3dFZGdlRXZlbnQodGN4LCBlZGdlLCBub2RlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBub2RlID0gbm9kZS5OZXh0O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwcml2YXRlIHN0YXRpYyB2b2lkIEZpbGxMZWZ0Q29udmV4RWRnZUV2ZW50KERUU3dlZXBDb250ZXh0IHRjeCwgRFRTd2VlcENvbnN0cmFpbnQgZWRnZSwgQWR2YW5jaW5nRnJvbnROb2RlIG5vZGUpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICAvLyBOZXh0IGNvbmNhdmUgb3IgY29udmV4P1xyXG4gICAgICAgICAgICBpZiAoVHJpYW5ndWxhdGlvblV0aWwuT3JpZW50MmQobm9kZS5QcmV2LlBvaW50LCBub2RlLlByZXYuUHJldi5Qb2ludCwgbm9kZS5QcmV2LlByZXYuUHJldi5Qb2ludCkgPT1cclxuICAgICAgICAgICAgICAgIE9yaWVudGF0aW9uLkNXKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAvLyBDb25jYXZlXHJcbiAgICAgICAgICAgICAgICBGaWxsTGVmdENvbmNhdmVFZGdlRXZlbnQodGN4LCBlZGdlLCBub2RlLlByZXYpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgLy8gQ29udmV4XHJcbiAgICAgICAgICAgICAgICAvLyBOZXh0IGFib3ZlIG9yIGJlbG93IGVkZ2U/XHJcbiAgICAgICAgICAgICAgICBpZiAoVHJpYW5ndWxhdGlvblV0aWwuT3JpZW50MmQoZWRnZS5RLCBub2RlLlByZXYuUHJldi5Qb2ludCwgZWRnZS5QKSA9PSBPcmllbnRhdGlvbi5DVylcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBCZWxvd1xyXG4gICAgICAgICAgICAgICAgICAgIEZpbGxMZWZ0Q29udmV4RWRnZUV2ZW50KHRjeCwgZWRnZSwgbm9kZS5QcmV2KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBBYm92ZVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwcml2YXRlIHN0YXRpYyB2b2lkIEZpbGxMZWZ0Q29uY2F2ZUVkZ2VFdmVudChEVFN3ZWVwQ29udGV4dCB0Y3gsIERUU3dlZXBDb25zdHJhaW50IGVkZ2UsIEFkdmFuY2luZ0Zyb250Tm9kZSBub2RlKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgRmlsbCh0Y3gsIG5vZGUuUHJldik7XHJcbiAgICAgICAgICAgIGlmIChub2RlLlByZXYuUG9pbnQgIT0gZWRnZS5QKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAvLyBOZXh0IGFib3ZlIG9yIGJlbG93IGVkZ2U/XHJcbiAgICAgICAgICAgICAgICBpZiAoVHJpYW5ndWxhdGlvblV0aWwuT3JpZW50MmQoZWRnZS5RLCBub2RlLlByZXYuUG9pbnQsIGVkZ2UuUCkgPT0gT3JpZW50YXRpb24uQ1cpXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gQmVsb3dcclxuICAgICAgICAgICAgICAgICAgICBpZiAoVHJpYW5ndWxhdGlvblV0aWwuT3JpZW50MmQobm9kZS5Qb2ludCwgbm9kZS5QcmV2LlBvaW50LCBub2RlLlByZXYuUHJldi5Qb2ludCkgPT0gT3JpZW50YXRpb24uQ1cpXHJcbiAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBOZXh0IGlzIGNvbmNhdmVcclxuICAgICAgICAgICAgICAgICAgICAgICAgRmlsbExlZnRDb25jYXZlRWRnZUV2ZW50KHRjeCwgZWRnZSwgbm9kZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIE5leHQgaXMgY29udmV4XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwcml2YXRlIHN0YXRpYyB2b2lkIEZpbGxMZWZ0QmVsb3dFZGdlRXZlbnQoRFRTd2VlcENvbnRleHQgdGN4LCBEVFN3ZWVwQ29uc3RyYWludCBlZGdlLCBBZHZhbmNpbmdGcm9udE5vZGUgbm9kZSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGlmIChub2RlLlBvaW50LlggPiBlZGdlLlAuWClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgaWYgKFRyaWFuZ3VsYXRpb25VdGlsLk9yaWVudDJkKG5vZGUuUG9pbnQsIG5vZGUuUHJldi5Qb2ludCwgbm9kZS5QcmV2LlByZXYuUG9pbnQpID09IE9yaWVudGF0aW9uLkNXKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIENvbmNhdmUgXHJcbiAgICAgICAgICAgICAgICAgICAgRmlsbExlZnRDb25jYXZlRWRnZUV2ZW50KHRjeCwgZWRnZSwgbm9kZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gQ29udmV4XHJcbiAgICAgICAgICAgICAgICAgICAgRmlsbExlZnRDb252ZXhFZGdlRXZlbnQodGN4LCBlZGdlLCBub2RlKTtcclxuICAgICAgICAgICAgICAgICAgICAvLyBSZXRyeSB0aGlzIG9uZVxyXG4gICAgICAgICAgICAgICAgICAgIEZpbGxMZWZ0QmVsb3dFZGdlRXZlbnQodGN4LCBlZGdlLCBub2RlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHJpdmF0ZSBzdGF0aWMgdm9pZCBGaWxsTGVmdEFib3ZlRWRnZUV2ZW50KERUU3dlZXBDb250ZXh0IHRjeCwgRFRTd2VlcENvbnN0cmFpbnQgZWRnZSwgQWR2YW5jaW5nRnJvbnROb2RlIG5vZGUpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB3aGlsZSAobm9kZS5QcmV2LlBvaW50LlggPiBlZGdlLlAuWClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgLy8gQ2hlY2sgaWYgbmV4dCBub2RlIGlzIGJlbG93IHRoZSBlZGdlXHJcbiAgICAgICAgICAgICAgICBPcmllbnRhdGlvbiBvMSA9IFRyaWFuZ3VsYXRpb25VdGlsLk9yaWVudDJkKGVkZ2UuUSwgbm9kZS5QcmV2LlBvaW50LCBlZGdlLlApO1xyXG4gICAgICAgICAgICAgICAgaWYgKG8xID09IE9yaWVudGF0aW9uLkNXKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIEZpbGxMZWZ0QmVsb3dFZGdlRXZlbnQodGN4LCBlZGdlLCBub2RlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBub2RlID0gbm9kZS5QcmV2O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvL1RPRE86IFBvcnQgbm90ZTogVGhlcmUgd2VyZSBzb21lIHN0cnVjdHVyYWwgZGlmZmVyZW5jZXMgaGVyZS5cclxuICAgICAgICBwcml2YXRlIHN0YXRpYyBib29sIElzRWRnZVNpZGVPZlRyaWFuZ2xlKERlbGF1bmF5VHJpYW5nbGUgdHJpYW5nbGUsIFRyaWFuZ3VsYXRpb25Qb2ludCBlcCwgVHJpYW5ndWxhdGlvblBvaW50IGVxKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgaW50IGluZGV4O1xyXG4gICAgICAgICAgICBpbmRleCA9IHRyaWFuZ2xlLkVkZ2VJbmRleChlcCwgZXEpO1xyXG4gICAgICAgICAgICBpZiAoaW5kZXggIT0gLTEpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHRyaWFuZ2xlLk1hcmtDb25zdHJhaW5lZEVkZ2UoaW5kZXgpO1xyXG4gICAgICAgICAgICAgICAgdHJpYW5nbGUgPSB0cmlhbmdsZS5OZWlnaGJvcnNbaW5kZXhdO1xyXG4gICAgICAgICAgICAgICAgaWYgKHRyaWFuZ2xlICE9IG51bGwpXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgdHJpYW5nbGUuTWFya0NvbnN0cmFpbmVkRWRnZShlcCwgZXEpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHJpdmF0ZSBzdGF0aWMgdm9pZCBFZGdlRXZlbnQoRFRTd2VlcENvbnRleHQgdGN4LCBUcmlhbmd1bGF0aW9uUG9pbnQgZXAsIFRyaWFuZ3VsYXRpb25Qb2ludCBlcSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBEZWxhdW5heVRyaWFuZ2xlIHRyaWFuZ2xlLCBUcmlhbmd1bGF0aW9uUG9pbnQgcG9pbnQpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBUcmlhbmd1bGF0aW9uUG9pbnQgcDEsIHAyO1xyXG5cclxuICAgICAgICAgICAgaWYgKElzRWRnZVNpZGVPZlRyaWFuZ2xlKHRyaWFuZ2xlLCBlcCwgZXEpKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHAxID0gdHJpYW5nbGUuUG9pbnRDQ1cocG9pbnQpO1xyXG4gICAgICAgICAgICBPcmllbnRhdGlvbiBvMSA9IFRyaWFuZ3VsYXRpb25VdGlsLk9yaWVudDJkKGVxLCBwMSwgZXApO1xyXG4gICAgICAgICAgICBpZiAobzEgPT0gT3JpZW50YXRpb24uQ29sbGluZWFyKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBpZiAodHJpYW5nbGUuQ29udGFpbnMoZXEsIHAxKSlcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICB0cmlhbmdsZS5NYXJrQ29uc3RyYWluZWRFZGdlKGVxLCBwMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gV2UgYXJlIG1vZGlmeWluZyB0aGUgY29uc3RyYWludCBtYXliZSBpdCB3b3VsZCBiZSBiZXR0ZXIgdG8gXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gbm90IGNoYW5nZSB0aGUgZ2l2ZW4gY29uc3RyYWludCBhbmQganVzdCBrZWVwIGEgdmFyaWFibGUgZm9yIHRoZSBuZXcgY29uc3RyYWludFxyXG4gICAgICAgICAgICAgICAgICAgIHRjeC5FZGdlRXZlbnQuQ29uc3RyYWluZWRFZGdlLlEgPSBwMTtcclxuICAgICAgICAgICAgICAgICAgICB0cmlhbmdsZSA9IHRyaWFuZ2xlLk5laWdoYm9yQWNyb3NzKHBvaW50KTtcclxuICAgICAgICAgICAgICAgICAgICBFZGdlRXZlbnQodGN4LCBlcCwgcDEsIHRyaWFuZ2xlLCBwMSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFBvaW50T25FZGdlRXhjZXB0aW9uKFwiRWRnZUV2ZW50IC0gUG9pbnQgb24gY29uc3RyYWluZWQgZWRnZSBub3Qgc3VwcG9ydGVkIHlldFwiKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmICh0Y3guSXNEZWJ1Z0VuYWJsZWQpXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgRGVidWcuV3JpdGVMaW5lKFwiRWRnZUV2ZW50IC0gUG9pbnQgb24gY29uc3RyYWluZWQgZWRnZVwiKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcDIgPSB0cmlhbmdsZS5Qb2ludENXKHBvaW50KTtcclxuICAgICAgICAgICAgT3JpZW50YXRpb24gbzIgPSBUcmlhbmd1bGF0aW9uVXRpbC5PcmllbnQyZChlcSwgcDIsIGVwKTtcclxuICAgICAgICAgICAgaWYgKG8yID09IE9yaWVudGF0aW9uLkNvbGxpbmVhcilcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgaWYgKHRyaWFuZ2xlLkNvbnRhaW5zKGVxLCBwMikpXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgdHJpYW5nbGUuTWFya0NvbnN0cmFpbmVkRWRnZShlcSwgcDIpO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIFdlIGFyZSBtb2RpZnlpbmcgdGhlIGNvbnN0cmFpbnQgbWF5YmUgaXQgd291bGQgYmUgYmV0dGVyIHRvIFxyXG4gICAgICAgICAgICAgICAgICAgIC8vIG5vdCBjaGFuZ2UgdGhlIGdpdmVuIGNvbnN0cmFpbnQgYW5kIGp1c3Qga2VlcCBhIHZhcmlhYmxlIGZvciB0aGUgbmV3IGNvbnN0cmFpbnRcclxuICAgICAgICAgICAgICAgICAgICB0Y3guRWRnZUV2ZW50LkNvbnN0cmFpbmVkRWRnZS5RID0gcDI7XHJcbiAgICAgICAgICAgICAgICAgICAgdHJpYW5nbGUgPSB0cmlhbmdsZS5OZWlnaGJvckFjcm9zcyhwb2ludCk7XHJcbiAgICAgICAgICAgICAgICAgICAgRWRnZUV2ZW50KHRjeCwgZXAsIHAyLCB0cmlhbmdsZSwgcDIpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBQb2ludE9uRWRnZUV4Y2VwdGlvbihcIkVkZ2VFdmVudCAtIFBvaW50IG9uIGNvbnN0cmFpbmVkIGVkZ2Ugbm90IHN1cHBvcnRlZCB5ZXRcIik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAodGN4LklzRGVidWdFbmFibGVkKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIERlYnVnLldyaXRlTGluZShcIkVkZ2VFdmVudCAtIFBvaW50IG9uIGNvbnN0cmFpbmVkIGVkZ2VcIik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmIChvMSA9PSBvMilcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgLy8gTmVlZCB0byBkZWNpZGUgaWYgd2UgYXJlIHJvdGF0aW5nIENXIG9yIENDVyB0byBnZXQgdG8gYSB0cmlhbmdsZVxyXG4gICAgICAgICAgICAgICAgLy8gdGhhdCB3aWxsIGNyb3NzIGVkZ2VcclxuICAgICAgICAgICAgICAgIGlmIChvMSA9PSBPcmllbnRhdGlvbi5DVylcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICB0cmlhbmdsZSA9IHRyaWFuZ2xlLk5laWdoYm9yQ0NXKHBvaW50KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICB0cmlhbmdsZSA9IHRyaWFuZ2xlLk5laWdoYm9yQ1cocG9pbnQpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgRWRnZUV2ZW50KHRjeCwgZXAsIGVxLCB0cmlhbmdsZSwgcG9pbnQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgLy8gVGhpcyB0cmlhbmdsZSBjcm9zc2VzIGNvbnN0cmFpbnQgc28gbGV0cyBmbGlwcGluIHN0YXJ0IVxyXG4gICAgICAgICAgICAgICAgRmxpcEVkZ2VFdmVudCh0Y3gsIGVwLCBlcSwgdHJpYW5nbGUsIHBvaW50KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHJpdmF0ZSBzdGF0aWMgdm9pZCBGbGlwRWRnZUV2ZW50KERUU3dlZXBDb250ZXh0IHRjeCwgVHJpYW5ndWxhdGlvblBvaW50IGVwLCBUcmlhbmd1bGF0aW9uUG9pbnQgZXEsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIERlbGF1bmF5VHJpYW5nbGUgdCwgVHJpYW5ndWxhdGlvblBvaW50IHApXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBUcmlhbmd1bGF0aW9uUG9pbnQgb3AsIG5ld1A7XHJcbiAgICAgICAgICAgIERlbGF1bmF5VHJpYW5nbGUgb3Q7XHJcbiAgICAgICAgICAgIGJvb2wgaW5TY2FuQXJlYTtcclxuXHJcbiAgICAgICAgICAgIG90ID0gdC5OZWlnaGJvckFjcm9zcyhwKTtcclxuICAgICAgICAgICAgb3AgPSBvdC5PcHBvc2l0ZVBvaW50KHQsIHApO1xyXG5cclxuICAgICAgICAgICAgaWYgKG90ID09IG51bGwpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIC8vIElmIHdlIHdhbnQgdG8gaW50ZWdyYXRlIHRoZSBmaWxsRWRnZUV2ZW50IGRvIGl0IGhlcmVcclxuICAgICAgICAgICAgICAgIC8vIFdpdGggY3VycmVudCBpbXBsZW1lbnRhdGlvbiB3ZSBzaG91bGQgbmV2ZXIgZ2V0IGhlcmVcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBJbnZhbGlkT3BlcmF0aW9uRXhjZXB0aW9uKFwiW0JVRzpGSVhNRV0gRkxJUCBmYWlsZWQgZHVlIHRvIG1pc3NpbmcgdHJpYW5nbGVcIik7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGluU2NhbkFyZWEgPSBUcmlhbmd1bGF0aW9uVXRpbC5JblNjYW5BcmVhKHAsIHQuUG9pbnRDQ1cocCksIHQuUG9pbnRDVyhwKSwgb3ApO1xyXG4gICAgICAgICAgICBpZiAoaW5TY2FuQXJlYSlcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgLy8gTGV0cyByb3RhdGUgc2hhcmVkIGVkZ2Ugb25lIHZlcnRleCBDV1xyXG4gICAgICAgICAgICAgICAgUm90YXRlVHJpYW5nbGVQYWlyKHQsIHAsIG90LCBvcCk7XHJcbiAgICAgICAgICAgICAgICB0Y3guTWFwVHJpYW5nbGVUb05vZGVzKHQpO1xyXG4gICAgICAgICAgICAgICAgdGN4Lk1hcFRyaWFuZ2xlVG9Ob2RlcyhvdCk7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKHAgPT0gZXEgJiYgb3AgPT0gZXApXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVxID09IHRjeC5FZGdlRXZlbnQuQ29uc3RyYWluZWRFZGdlLlFcclxuICAgICAgICAgICAgICAgICAgICAgICAgJiYgZXAgPT0gdGN4LkVkZ2VFdmVudC5Db25zdHJhaW5lZEVkZ2UuUClcclxuICAgICAgICAgICAgICAgICAgICB7XHJcbiNpZiAhTkVURlhfQ09SRVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGN4LklzRGVidWdFbmFibGVkKSBDb25zb2xlLldyaXRlTGluZShcIltGTElQXSAtIGNvbnN0cmFpbmVkIGVkZ2UgZG9uZVwiKTsgLy8gVE9ETzogcmVtb3ZlXHJcbiNlbmRpZlxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0Lk1hcmtDb25zdHJhaW5lZEVkZ2UoZXAsIGVxKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgb3QuTWFya0NvbnN0cmFpbmVkRWRnZShlcCwgZXEpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBMZWdhbGl6ZSh0Y3gsIHQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBMZWdhbGl6ZSh0Y3gsIG90KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgICAgIHtcclxuI2lmICFORVRGWF9DT1JFXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0Y3guSXNEZWJ1Z0VuYWJsZWQpIENvbnNvbGUuV3JpdGVMaW5lKFwiW0ZMSVBdIC0gc3ViZWRnZSBkb25lXCIpOyAvLyBUT0RPOiByZW1vdmVcclxuI2VuZGlmXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFhYWDogSSB0aGluayBvbmUgb2YgdGhlIHRyaWFuZ2xlcyBzaG91bGQgYmUgbGVnYWxpemVkIGhlcmU/XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAge1xyXG4jaWYgIU5FVEZYX0NPUkVcclxuICAgICAgICAgICAgICAgICAgICBpZiAodGN4LklzRGVidWdFbmFibGVkKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBDb25zb2xlLldyaXRlTGluZShcIltGTElQXSAtIGZsaXBwaW5nIGFuZCBjb250aW51aW5nIHdpdGggdHJpYW5nbGUgc3RpbGwgY3Jvc3NpbmcgZWRnZVwiKTtcclxuI2VuZGlmXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBUT0RPOiByZW1vdmVcclxuICAgICAgICAgICAgICAgICAgICBPcmllbnRhdGlvbiBvID0gVHJpYW5ndWxhdGlvblV0aWwuT3JpZW50MmQoZXEsIG9wLCBlcCk7XHJcbiAgICAgICAgICAgICAgICAgICAgdCA9IE5leHRGbGlwVHJpYW5nbGUodGN4LCBvLCB0LCBvdCwgcCwgb3ApO1xyXG4gICAgICAgICAgICAgICAgICAgIEZsaXBFZGdlRXZlbnQodGN4LCBlcCwgZXEsIHQsIHApO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgbmV3UCA9IE5leHRGbGlwUG9pbnQoZXAsIGVxLCBvdCwgb3ApO1xyXG4gICAgICAgICAgICAgICAgRmxpcFNjYW5FZGdlRXZlbnQodGN4LCBlcCwgZXEsIHQsIG90LCBuZXdQKTtcclxuICAgICAgICAgICAgICAgIEVkZ2VFdmVudCh0Y3gsIGVwLCBlcSwgdCwgcCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gV2hlbiB3ZSBuZWVkIHRvIHRyYXZlcnNlIGZyb20gb25lIHRyaWFuZ2xlIHRvIHRoZSBuZXh0IHdlIG5lZWQgXHJcbiAgICAgICAgLy8vIHRoZSBwb2ludCBpbiBjdXJyZW50IHRyaWFuZ2xlIHRoYXQgaXMgdGhlIG9wcG9zaXRlIHBvaW50IHRvIHRoZSBuZXh0XHJcbiAgICAgICAgLy8vIHRyaWFuZ2xlLiBcclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIHByaXZhdGUgc3RhdGljIFRyaWFuZ3VsYXRpb25Qb2ludCBOZXh0RmxpcFBvaW50KFRyaWFuZ3VsYXRpb25Qb2ludCBlcCwgVHJpYW5ndWxhdGlvblBvaW50IGVxLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIERlbGF1bmF5VHJpYW5nbGUgb3QsIFRyaWFuZ3VsYXRpb25Qb2ludCBvcClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIE9yaWVudGF0aW9uIG8yZCA9IFRyaWFuZ3VsYXRpb25VdGlsLk9yaWVudDJkKGVxLCBvcCwgZXApO1xyXG4gICAgICAgICAgICBpZiAobzJkID09IE9yaWVudGF0aW9uLkNXKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAvLyBSaWdodFxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG90LlBvaW50Q0NXKG9wKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChvMmQgPT0gT3JpZW50YXRpb24uQ0NXKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAvLyBMZWZ0XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gb3QuUG9pbnRDVyhvcCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAvLyBUT0RPOiBpbXBsZW1lbnQgc3VwcG9ydCBmb3IgcG9pbnQgb24gY29uc3RyYWludCBlZGdlXHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUG9pbnRPbkVkZ2VFeGNlcHRpb24oXCJQb2ludCBvbiBjb25zdHJhaW5lZCBlZGdlIG5vdCBzdXBwb3J0ZWQgeWV0XCIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIEFmdGVyIGEgZmxpcCB3ZSBoYXZlIHR3byB0cmlhbmdsZXMgYW5kIGtub3cgdGhhdCBvbmx5IG9uZSB3aWxsIHN0aWxsIGJlXHJcbiAgICAgICAgLy8vIGludGVyc2VjdGluZyB0aGUgZWRnZS4gU28gZGVjaWRlIHdoaWNoIHRvIGNvbnRpdW5lIHdpdGggYW5kIGxlZ2FsaXplIHRoZSBvdGhlclxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwidGN4XCI+PC9wYXJhbT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJvXCI+c2hvdWxkIGJlIHRoZSByZXN1bHQgb2YgYW4gVHJpYW5ndWxhdGlvblV0aWwub3JpZW50MmQoIGVxLCBvcCwgZXAgKTwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwidFwiPnRyaWFuZ2xlIDE8L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cIm90XCI+dHJpYW5nbGUgMjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwicFwiPmEgcG9pbnQgc2hhcmVkIGJ5IGJvdGggdHJpYW5nbGVzPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJvcFwiPmFub3RoZXIgcG9pbnQgc2hhcmVkIGJ5IGJvdGggdHJpYW5nbGVzPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHJldHVybnM+cmV0dXJucyB0aGUgdHJpYW5nbGUgc3RpbGwgaW50ZXJzZWN0aW5nIHRoZSBlZGdlPC9yZXR1cm5zPlxyXG4gICAgICAgIHByaXZhdGUgc3RhdGljIERlbGF1bmF5VHJpYW5nbGUgTmV4dEZsaXBUcmlhbmdsZShEVFN3ZWVwQ29udGV4dCB0Y3gsIE9yaWVudGF0aW9uIG8sIERlbGF1bmF5VHJpYW5nbGUgdCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgRGVsYXVuYXlUcmlhbmdsZSBvdCwgVHJpYW5ndWxhdGlvblBvaW50IHAsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFRyaWFuZ3VsYXRpb25Qb2ludCBvcClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGludCBlZGdlSW5kZXg7XHJcbiAgICAgICAgICAgIGlmIChvID09IE9yaWVudGF0aW9uLkNDVylcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgLy8gb3QgaXMgbm90IGNyb3NzaW5nIGVkZ2UgYWZ0ZXIgZmxpcFxyXG4gICAgICAgICAgICAgICAgZWRnZUluZGV4ID0gb3QuRWRnZUluZGV4KHAsIG9wKTtcclxuICAgICAgICAgICAgICAgIG90LkVkZ2VJc0RlbGF1bmF5W2VkZ2VJbmRleF0gPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgTGVnYWxpemUodGN4LCBvdCk7XHJcbiAgICAgICAgICAgICAgICBvdC5FZGdlSXNEZWxhdW5heS5DbGVhcigpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gdCBpcyBub3QgY3Jvc3NpbmcgZWRnZSBhZnRlciBmbGlwXHJcbiAgICAgICAgICAgIGVkZ2VJbmRleCA9IHQuRWRnZUluZGV4KHAsIG9wKTtcclxuICAgICAgICAgICAgdC5FZGdlSXNEZWxhdW5heVtlZGdlSW5kZXhdID0gdHJ1ZTtcclxuICAgICAgICAgICAgTGVnYWxpemUodGN4LCB0KTtcclxuICAgICAgICAgICAgdC5FZGdlSXNEZWxhdW5heS5DbGVhcigpO1xyXG4gICAgICAgICAgICByZXR1cm4gb3Q7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIFNjYW4gcGFydCBvZiB0aGUgRmxpcFNjYW4gYWxnb3JpdGhtPGJyPlxyXG4gICAgICAgIC8vLyBXaGVuIGEgdHJpYW5nbGUgcGFpciBpc24ndCBmbGlwcGFibGUgd2Ugd2lsbCBzY2FuIGZvciB0aGUgbmV4dCBcclxuICAgICAgICAvLy8gcG9pbnQgdGhhdCBpcyBpbnNpZGUgdGhlIGZsaXAgdHJpYW5nbGUgc2NhbiBhcmVhLiBXaGVuIGZvdW5kIFxyXG4gICAgICAgIC8vLyB3ZSBnZW5lcmF0ZSBhIG5ldyBmbGlwRWRnZUV2ZW50XHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJ0Y3hcIj48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cImVwXCI+bGFzdCBwb2ludCBvbiB0aGUgZWRnZSB3ZSBhcmUgdHJhdmVyc2luZzwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwiZXFcIj5maXJzdCBwb2ludCBvbiB0aGUgZWRnZSB3ZSBhcmUgdHJhdmVyc2luZzwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwiZmxpcFRyaWFuZ2xlXCI+dGhlIGN1cnJlbnQgdHJpYW5nbGUgc2hhcmluZyB0aGUgcG9pbnQgZXEgd2l0aCBlZGdlPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJ0XCI+PC9wYXJhbT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJwXCI+PC9wYXJhbT5cclxuICAgICAgICBwcml2YXRlIHN0YXRpYyB2b2lkIEZsaXBTY2FuRWRnZUV2ZW50KERUU3dlZXBDb250ZXh0IHRjeCwgVHJpYW5ndWxhdGlvblBvaW50IGVwLCBUcmlhbmd1bGF0aW9uUG9pbnQgZXEsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBEZWxhdW5heVRyaWFuZ2xlIGZsaXBUcmlhbmdsZSwgRGVsYXVuYXlUcmlhbmdsZSB0LCBUcmlhbmd1bGF0aW9uUG9pbnQgcClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIERlbGF1bmF5VHJpYW5nbGUgb3Q7XHJcbiAgICAgICAgICAgIFRyaWFuZ3VsYXRpb25Qb2ludCBvcCwgbmV3UDtcclxuICAgICAgICAgICAgYm9vbCBpblNjYW5BcmVhO1xyXG5cclxuICAgICAgICAgICAgb3QgPSB0Lk5laWdoYm9yQWNyb3NzKHApO1xyXG4gICAgICAgICAgICBvcCA9IG90Lk9wcG9zaXRlUG9pbnQodCwgcCk7XHJcblxyXG4gICAgICAgICAgICBpZiAob3QgPT0gbnVsbClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgLy8gSWYgd2Ugd2FudCB0byBpbnRlZ3JhdGUgdGhlIGZpbGxFZGdlRXZlbnQgZG8gaXQgaGVyZVxyXG4gICAgICAgICAgICAgICAgLy8gV2l0aCBjdXJyZW50IGltcGxlbWVudGF0aW9uIHdlIHNob3VsZCBuZXZlciBnZXQgaGVyZVxyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEV4Y2VwdGlvbihcIltCVUc6RklYTUVdIEZMSVAgZmFpbGVkIGR1ZSB0byBtaXNzaW5nIHRyaWFuZ2xlXCIpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpblNjYW5BcmVhID0gVHJpYW5ndWxhdGlvblV0aWwuSW5TY2FuQXJlYShlcSwgZmxpcFRyaWFuZ2xlLlBvaW50Q0NXKGVxKSwgZmxpcFRyaWFuZ2xlLlBvaW50Q1coZXEpLCBvcCk7XHJcbiAgICAgICAgICAgIGlmIChpblNjYW5BcmVhKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAvLyBmbGlwIHdpdGggbmV3IGVkZ2Ugb3AtPmVxXHJcbiAgICAgICAgICAgICAgICBGbGlwRWRnZUV2ZW50KHRjeCwgZXEsIG9wLCBvdCwgb3ApO1xyXG4gICAgICAgICAgICAgICAgLy8gVE9ETzogQWN0dWFsbHkgSSBqdXN0IGZpZ3VyZWQgb3V0IHRoYXQgaXQgc2hvdWxkIGJlIHBvc3NpYmxlIHRvIFxyXG4gICAgICAgICAgICAgICAgLy8gICAgICAgaW1wcm92ZSB0aGlzIGJ5IGdldHRpbmcgdGhlIG5leHQgb3QgYW5kIG9wIGJlZm9yZSB0aGUgdGhlIGFib3ZlIFxyXG4gICAgICAgICAgICAgICAgLy8gICAgICAgZmxpcCBhbmQgY29udGludWUgdGhlIGZsaXBTY2FuRWRnZUV2ZW50IGhlcmVcclxuICAgICAgICAgICAgICAgIC8vIHNldCBuZXcgb3QgYW5kIG9wIGhlcmUgYW5kIGxvb3AgYmFjayB0byBpblNjYW5BcmVhIHRlc3RcclxuICAgICAgICAgICAgICAgIC8vIGFsc28gbmVlZCB0byBzZXQgYSBuZXcgZmxpcFRyaWFuZ2xlIGZpcnN0XHJcbiAgICAgICAgICAgICAgICAvLyBUdXJucyBvdXQgYXQgZmlyc3QgZ2xhbmNlIHRoYXQgdGhpcyBpcyBzb21ld2hhdCBjb21wbGljYXRlZFxyXG4gICAgICAgICAgICAgICAgLy8gc28gaXQgd2lsbCBoYXZlIHRvIHdhaXQuXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBuZXdQID0gTmV4dEZsaXBQb2ludChlcCwgZXEsIG90LCBvcCk7XHJcbiAgICAgICAgICAgICAgICBGbGlwU2NhbkVkZ2VFdmVudCh0Y3gsIGVwLCBlcSwgZmxpcFRyaWFuZ2xlLCBvdCwgbmV3UCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gRmlsbHMgaG9sZXMgaW4gdGhlIEFkdmFuY2luZyBGcm9udFxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgcHJpdmF0ZSBzdGF0aWMgdm9pZCBGaWxsQWR2YW5jaW5nRnJvbnQoRFRTd2VlcENvbnRleHQgdGN4LCBBZHZhbmNpbmdGcm9udE5vZGUgbilcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIEFkdmFuY2luZ0Zyb250Tm9kZSBub2RlO1xyXG4gICAgICAgICAgICBkb3VibGUgYW5nbGU7XHJcblxyXG4gICAgICAgICAgICAvLyBGaWxsIHJpZ2h0IGhvbGVzXHJcbiAgICAgICAgICAgIG5vZGUgPSBuLk5leHQ7XHJcbiAgICAgICAgICAgIHdoaWxlIChub2RlLkhhc05leHQpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGFuZ2xlID0gSG9sZUFuZ2xlKG5vZGUpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGFuZ2xlID4gUElfZGl2MiB8fCBhbmdsZSA8IC1QSV9kaXYyKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgRmlsbCh0Y3gsIG5vZGUpO1xyXG4gICAgICAgICAgICAgICAgbm9kZSA9IG5vZGUuTmV4dDtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gRmlsbCBsZWZ0IGhvbGVzXHJcbiAgICAgICAgICAgIG5vZGUgPSBuLlByZXY7XHJcbiAgICAgICAgICAgIHdoaWxlIChub2RlLkhhc1ByZXYpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGFuZ2xlID0gSG9sZUFuZ2xlKG5vZGUpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGFuZ2xlID4gUElfZGl2MiB8fCBhbmdsZSA8IC1QSV9kaXYyKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgRmlsbCh0Y3gsIG5vZGUpO1xyXG4gICAgICAgICAgICAgICAgbm9kZSA9IG5vZGUuUHJldjtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gRmlsbCByaWdodCBiYXNpbnNcclxuICAgICAgICAgICAgaWYgKG4uSGFzTmV4dCAmJiBuLk5leHQuSGFzTmV4dClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgYW5nbGUgPSBCYXNpbkFuZ2xlKG4pO1xyXG4gICAgICAgICAgICAgICAgaWYgKGFuZ2xlIDwgUElfM2RpdjQpXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgRmlsbEJhc2luKHRjeCwgbik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gRmlsbHMgYSBiYXNpbiB0aGF0IGhhcyBmb3JtZWQgb24gdGhlIEFkdmFuY2luZyBGcm9udCB0byB0aGUgcmlnaHRcclxuICAgICAgICAvLy8gb2YgZ2l2ZW4gbm9kZS48YnI+XHJcbiAgICAgICAgLy8vIEZpcnN0IHdlIGRlY2lkZSBhIGxlZnQsYm90dG9tIGFuZCByaWdodCBub2RlIHRoYXQgZm9ybXMgdGhlIFxyXG4gICAgICAgIC8vLyBib3VuZGFyaWVzIG9mIHRoZSBiYXNpbi4gVGhlbiB3ZSBkbyBhIHJlcXVyc2l2ZSBmaWxsLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwidGN4XCI+PC9wYXJhbT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJub2RlXCI+c3RhcnRpbmcgbm9kZSwgdGhpcyBvciBuZXh0IG5vZGUgd2lsbCBiZSBsZWZ0IG5vZGU8L3BhcmFtPlxyXG4gICAgICAgIHByaXZhdGUgc3RhdGljIHZvaWQgRmlsbEJhc2luKERUU3dlZXBDb250ZXh0IHRjeCwgQWR2YW5jaW5nRnJvbnROb2RlIG5vZGUpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBpZiAoVHJpYW5ndWxhdGlvblV0aWwuT3JpZW50MmQobm9kZS5Qb2ludCwgbm9kZS5OZXh0LlBvaW50LCBub2RlLk5leHQuTmV4dC5Qb2ludCkgPT0gT3JpZW50YXRpb24uQ0NXKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAvLyB0Y3guYmFzaW4ubGVmdE5vZGUgPSBub2RlLm5leHQubmV4dDtcclxuICAgICAgICAgICAgICAgIHRjeC5CYXNpbi5sZWZ0Tm9kZSA9IG5vZGU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB0Y3guQmFzaW4ubGVmdE5vZGUgPSBub2RlLk5leHQ7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIEZpbmQgdGhlIGJvdHRvbSBhbmQgcmlnaHQgbm9kZVxyXG4gICAgICAgICAgICB0Y3guQmFzaW4uYm90dG9tTm9kZSA9IHRjeC5CYXNpbi5sZWZ0Tm9kZTtcclxuICAgICAgICAgICAgd2hpbGUgKHRjeC5CYXNpbi5ib3R0b21Ob2RlLkhhc05leHQgJiYgdGN4LkJhc2luLmJvdHRvbU5vZGUuUG9pbnQuWSA+PSB0Y3guQmFzaW4uYm90dG9tTm9kZS5OZXh0LlBvaW50LlkpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHRjeC5CYXNpbi5ib3R0b21Ob2RlID0gdGN4LkJhc2luLmJvdHRvbU5vZGUuTmV4dDtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKHRjeC5CYXNpbi5ib3R0b21Ob2RlID09IHRjeC5CYXNpbi5sZWZ0Tm9kZSlcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgLy8gTm8gdmFsaWQgYmFzaW5zXHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHRjeC5CYXNpbi5yaWdodE5vZGUgPSB0Y3guQmFzaW4uYm90dG9tTm9kZTtcclxuICAgICAgICAgICAgd2hpbGUgKHRjeC5CYXNpbi5yaWdodE5vZGUuSGFzTmV4dCAmJiB0Y3guQmFzaW4ucmlnaHROb2RlLlBvaW50LlkgPCB0Y3guQmFzaW4ucmlnaHROb2RlLk5leHQuUG9pbnQuWSlcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdGN4LkJhc2luLnJpZ2h0Tm9kZSA9IHRjeC5CYXNpbi5yaWdodE5vZGUuTmV4dDtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKHRjeC5CYXNpbi5yaWdodE5vZGUgPT0gdGN4LkJhc2luLmJvdHRvbU5vZGUpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIC8vIE5vIHZhbGlkIGJhc2luc1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB0Y3guQmFzaW4ud2lkdGggPSB0Y3guQmFzaW4ucmlnaHROb2RlLlBvaW50LlggLSB0Y3guQmFzaW4ubGVmdE5vZGUuUG9pbnQuWDtcclxuICAgICAgICAgICAgdGN4LkJhc2luLmxlZnRIaWdoZXN0ID0gdGN4LkJhc2luLmxlZnROb2RlLlBvaW50LlkgPiB0Y3guQmFzaW4ucmlnaHROb2RlLlBvaW50Llk7XHJcblxyXG4gICAgICAgICAgICBGaWxsQmFzaW5SZXEodGN4LCB0Y3guQmFzaW4uYm90dG9tTm9kZSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIFJlY3Vyc2l2ZSBhbGdvcml0aG0gdG8gZmlsbCBhIEJhc2luIHdpdGggdHJpYW5nbGVzXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICBwcml2YXRlIHN0YXRpYyB2b2lkIEZpbGxCYXNpblJlcShEVFN3ZWVwQ29udGV4dCB0Y3gsIEFkdmFuY2luZ0Zyb250Tm9kZSBub2RlKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgLy8gaWYgc2hhbGxvdyBzdG9wIGZpbGxpbmdcclxuICAgICAgICAgICAgaWYgKElzU2hhbGxvdyh0Y3gsIG5vZGUpKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIEZpbGwodGN4LCBub2RlKTtcclxuICAgICAgICAgICAgaWYgKG5vZGUuUHJldiA9PSB0Y3guQmFzaW4ubGVmdE5vZGUgJiYgbm9kZS5OZXh0ID09IHRjeC5CYXNpbi5yaWdodE5vZGUpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChub2RlLlByZXYgPT0gdGN4LkJhc2luLmxlZnROb2RlKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBPcmllbnRhdGlvbiBvID0gVHJpYW5ndWxhdGlvblV0aWwuT3JpZW50MmQobm9kZS5Qb2ludCwgbm9kZS5OZXh0LlBvaW50LCBub2RlLk5leHQuTmV4dC5Qb2ludCk7XHJcbiAgICAgICAgICAgICAgICBpZiAobyA9PSBPcmllbnRhdGlvbi5DVylcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBub2RlID0gbm9kZS5OZXh0O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKG5vZGUuTmV4dCA9PSB0Y3guQmFzaW4ucmlnaHROb2RlKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBPcmllbnRhdGlvbiBvID0gVHJpYW5ndWxhdGlvblV0aWwuT3JpZW50MmQobm9kZS5Qb2ludCwgbm9kZS5QcmV2LlBvaW50LCBub2RlLlByZXYuUHJldi5Qb2ludCk7XHJcbiAgICAgICAgICAgICAgICBpZiAobyA9PSBPcmllbnRhdGlvbi5DQ1cpXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgbm9kZSA9IG5vZGUuUHJldjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIC8vIENvbnRpbnVlIHdpdGggdGhlIG5laWdoYm9yIG5vZGUgd2l0aCBsb3dlc3QgWSB2YWx1ZVxyXG4gICAgICAgICAgICAgICAgaWYgKG5vZGUuUHJldi5Qb2ludC5ZIDwgbm9kZS5OZXh0LlBvaW50LlkpXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgbm9kZSA9IG5vZGUuUHJldjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBub2RlID0gbm9kZS5OZXh0O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIEZpbGxCYXNpblJlcSh0Y3gsIG5vZGUpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHJpdmF0ZSBzdGF0aWMgYm9vbCBJc1NoYWxsb3coRFRTd2VlcENvbnRleHQgdGN4LCBBZHZhbmNpbmdGcm9udE5vZGUgbm9kZSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGRvdWJsZSBoZWlnaHQ7XHJcblxyXG4gICAgICAgICAgICBpZiAodGN4LkJhc2luLmxlZnRIaWdoZXN0KVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBoZWlnaHQgPSB0Y3guQmFzaW4ubGVmdE5vZGUuUG9pbnQuWSAtIG5vZGUuUG9pbnQuWTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGhlaWdodCA9IHRjeC5CYXNpbi5yaWdodE5vZGUuUG9pbnQuWSAtIG5vZGUuUG9pbnQuWTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAodGN4LkJhc2luLndpZHRoID4gaGVpZ2h0KVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vID8/P1xyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwibm9kZVwiPm1pZGRsZSBub2RlPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHJldHVybnM+dGhlIGFuZ2xlIGJldHdlZW4gMyBmcm9udCBub2RlczwvcmV0dXJucz5cclxuICAgICAgICBwcml2YXRlIHN0YXRpYyBkb3VibGUgSG9sZUFuZ2xlKEFkdmFuY2luZ0Zyb250Tm9kZSBub2RlKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgLy8gWFhYOiBkbyB3ZSByZWFsbHkgbmVlZCBhIHNpZ25lZCBhbmdsZSBmb3IgaG9sZUFuZ2xlP1xyXG4gICAgICAgICAgICAvLyAgICAgIGNvdWxkIHBvc3NpYmxlIHNhdmUgc29tZSBjeWNsZXMgaGVyZVxyXG4gICAgICAgICAgICAvKiBDb21wbGV4IHBsYW5lXHJcbiAgICAgICAgICAgICAqIGFiID0gY29zQSAraSpzaW5BXHJcbiAgICAgICAgICAgICAqIGFiID0gKGF4ICsgYXkqaSkoYnggKyBieSppKSA9IChheCpieCArIGF5KmJ5KSArIGkoYXgqYnktYXkqYngpXHJcbiAgICAgICAgICAgICAqIGF0YW4yKHkseCkgY29tcHV0ZXMgdGhlIHByaW5jaXBhbCB2YWx1ZSBvZiB0aGUgYXJndW1lbnQgZnVuY3Rpb25cclxuICAgICAgICAgICAgICogYXBwbGllZCB0byB0aGUgY29tcGxleCBudW1iZXIgeCtpeVxyXG4gICAgICAgICAgICAgKiBXaGVyZSB4ID0gYXgqYnggKyBheSpieVxyXG4gICAgICAgICAgICAgKiAgICAgICB5ID0gYXgqYnkgLSBheSpieFxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgZG91YmxlIHB4ID0gbm9kZS5Qb2ludC5YO1xyXG4gICAgICAgICAgICBkb3VibGUgcHkgPSBub2RlLlBvaW50Llk7XHJcbiAgICAgICAgICAgIGRvdWJsZSBheCA9IG5vZGUuTmV4dC5Qb2ludC5YIC0gcHg7XHJcbiAgICAgICAgICAgIGRvdWJsZSBheSA9IG5vZGUuTmV4dC5Qb2ludC5ZIC0gcHk7XHJcbiAgICAgICAgICAgIGRvdWJsZSBieCA9IG5vZGUuUHJldi5Qb2ludC5YIC0gcHg7XHJcbiAgICAgICAgICAgIGRvdWJsZSBieSA9IG5vZGUuUHJldi5Qb2ludC5ZIC0gcHk7XHJcbiAgICAgICAgICAgIHJldHVybiBNYXRoLkF0YW4yKGF4KmJ5IC0gYXkqYngsIGF4KmJ4ICsgYXkqYnkpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBUaGUgYmFzaW4gYW5nbGUgaXMgZGVjaWRlZCBhZ2FpbnN0IHRoZSBob3Jpem9udGFsIGxpbmUgWzEsMF1cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIHByaXZhdGUgc3RhdGljIGRvdWJsZSBCYXNpbkFuZ2xlKEFkdmFuY2luZ0Zyb250Tm9kZSBub2RlKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgZG91YmxlIGF4ID0gbm9kZS5Qb2ludC5YIC0gbm9kZS5OZXh0Lk5leHQuUG9pbnQuWDtcclxuICAgICAgICAgICAgZG91YmxlIGF5ID0gbm9kZS5Qb2ludC5ZIC0gbm9kZS5OZXh0Lk5leHQuUG9pbnQuWTtcclxuICAgICAgICAgICAgcmV0dXJuIE1hdGguQXRhbjIoYXksIGF4KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gQWRkcyBhIHRyaWFuZ2xlIHRvIHRoZSBhZHZhbmNpbmcgZnJvbnQgdG8gZmlsbCBhIGhvbGUuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJ0Y3hcIj48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cIm5vZGVcIj5taWRkbGUgbm9kZSwgdGhhdCBpcyB0aGUgYm90dG9tIG9mIHRoZSBob2xlPC9wYXJhbT5cclxuICAgICAgICBwcml2YXRlIHN0YXRpYyB2b2lkIEZpbGwoRFRTd2VlcENvbnRleHQgdGN4LCBBZHZhbmNpbmdGcm9udE5vZGUgbm9kZSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIERlbGF1bmF5VHJpYW5nbGUgdHJpYW5nbGUgPSBuZXcgRGVsYXVuYXlUcmlhbmdsZShub2RlLlByZXYuUG9pbnQsIG5vZGUuUG9pbnQsIG5vZGUuTmV4dC5Qb2ludCk7XHJcbiAgICAgICAgICAgIC8vIFRPRE86IHNob3VsZCBjb3B5IHRoZSBjRWRnZSB2YWx1ZSBmcm9tIG5laWdoYm9yIHRyaWFuZ2xlc1xyXG4gICAgICAgICAgICAvLyAgICAgICBmb3Igbm93IGNFZGdlIHZhbHVlcyBhcmUgY29waWVkIGR1cmluZyB0aGUgbGVnYWxpemUgXHJcbiAgICAgICAgICAgIHRyaWFuZ2xlLk1hcmtOZWlnaGJvcihub2RlLlByZXYuVHJpYW5nbGUpO1xyXG4gICAgICAgICAgICB0cmlhbmdsZS5NYXJrTmVpZ2hib3Iobm9kZS5UcmlhbmdsZSk7XHJcbiAgICAgICAgICAgIHRjeC5UcmlhbmdsZXMuQWRkKHRyaWFuZ2xlKTtcclxuXHJcbiAgICAgICAgICAgIC8vIFVwZGF0ZSB0aGUgYWR2YW5jaW5nIGZyb250XHJcbiAgICAgICAgICAgIG5vZGUuUHJldi5OZXh0ID0gbm9kZS5OZXh0O1xyXG4gICAgICAgICAgICBub2RlLk5leHQuUHJldiA9IG5vZGUuUHJldjtcclxuICAgICAgICAgICAgdGN4LlJlbW92ZU5vZGUobm9kZSk7XHJcblxyXG4gICAgICAgICAgICAvLyBJZiBpdCB3YXMgbGVnYWxpemVkIHRoZSB0cmlhbmdsZSBoYXMgYWxyZWFkeSBiZWVuIG1hcHBlZFxyXG4gICAgICAgICAgICBpZiAoIUxlZ2FsaXplKHRjeCwgdHJpYW5nbGUpKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB0Y3guTWFwVHJpYW5nbGVUb05vZGVzKHRyaWFuZ2xlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBSZXR1cm5zIHRydWUgaWYgdHJpYW5nbGUgd2FzIGxlZ2FsaXplZFxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgcHJpdmF0ZSBzdGF0aWMgYm9vbCBMZWdhbGl6ZShEVFN3ZWVwQ29udGV4dCB0Y3gsIERlbGF1bmF5VHJpYW5nbGUgdClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGludCBvaTtcclxuICAgICAgICAgICAgYm9vbCBpbnNpZGU7XHJcbiAgICAgICAgICAgIFRyaWFuZ3VsYXRpb25Qb2ludCBwLCBvcDtcclxuICAgICAgICAgICAgRGVsYXVuYXlUcmlhbmdsZSBvdDtcclxuXHJcbiAgICAgICAgICAgIC8vIFRvIGxlZ2FsaXplIGEgdHJpYW5nbGUgd2Ugc3RhcnQgYnkgZmluZGluZyBpZiBhbnkgb2YgdGhlIHRocmVlIGVkZ2VzXHJcbiAgICAgICAgICAgIC8vIHZpb2xhdGUgdGhlIERlbGF1bmF5IGNvbmRpdGlvblxyXG4gICAgICAgICAgICBmb3IgKGludCBpID0gMDsgaSA8IDM7IGkrKylcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgLy8gVE9ETzogZml4IHNvIHRoYXQgY0VkZ2UgaXMgYWx3YXlzIHZhbGlkIHdoZW4gY3JlYXRpbmcgbmV3IHRyaWFuZ2xlcyB0aGVuIHdlIGNhbiBjaGVjayBpdCBoZXJlXHJcbiAgICAgICAgICAgICAgICAvLyAgICAgICBpbnN0ZWFkIG9mIGJlbG93IHdpdGggb3RcclxuICAgICAgICAgICAgICAgIGlmICh0LkVkZ2VJc0RlbGF1bmF5W2ldKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIG90ID0gdC5OZWlnaGJvcnNbaV07XHJcbiAgICAgICAgICAgICAgICBpZiAob3QgIT0gbnVsbClcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBwID0gdC5Qb2ludHNbaV07XHJcbiAgICAgICAgICAgICAgICAgICAgb3AgPSBvdC5PcHBvc2l0ZVBvaW50KHQsIHApO1xyXG4gICAgICAgICAgICAgICAgICAgIG9pID0gb3QuSW5kZXhPZihvcCk7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgdGhpcyBpcyBhIENvbnN0cmFpbmVkIEVkZ2Ugb3IgYSBEZWxhdW5heSBFZGdlKG9ubHkgZHVyaW5nIHJlY3Vyc2l2ZSBsZWdhbGl6YXRpb24pXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gdGhlbiB3ZSBzaG91bGQgbm90IHRyeSB0byBsZWdhbGl6ZVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChvdC5FZGdlSXNDb25zdHJhaW5lZFtvaV0gfHwgb3QuRWRnZUlzRGVsYXVuYXlbb2ldKVxyXG4gICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdC5FZGdlSXNDb25zdHJhaW5lZFtpXSA9IG90LkVkZ2VJc0NvbnN0cmFpbmVkW29pXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFhYWDogaGF2ZSBubyBnb29kIHdheSBvZiBzZXR0aW5nIHRoaXMgcHJvcGVydHkgd2hlbiBjcmVhdGluZyBuZXcgdHJpYW5nbGVzIHNvIGxldHMgc2V0IGl0IGhlcmVcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICBpbnNpZGUgPSBUcmlhbmd1bGF0aW9uVXRpbC5TbWFydEluY2lyY2xlKHAsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0LlBvaW50Q0NXKHApLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdC5Qb2ludENXKHApLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3ApO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZiAoaW5zaWRlKVxyXG4gICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYm9vbCBub3RMZWdhbGl6ZWQ7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBMZXRzIG1hcmsgdGhpcyBzaGFyZWQgZWRnZSBhcyBEZWxhdW5heSBcclxuICAgICAgICAgICAgICAgICAgICAgICAgdC5FZGdlSXNEZWxhdW5heVtpXSA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG90LkVkZ2VJc0RlbGF1bmF5W29pXSA9IHRydWU7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBMZXRzIHJvdGF0ZSBzaGFyZWQgZWRnZSBvbmUgdmVydGV4IENXIHRvIGxlZ2FsaXplIGl0XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIFJvdGF0ZVRyaWFuZ2xlUGFpcih0LCBwLCBvdCwgb3ApO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gV2Ugbm93IGdvdCBvbmUgdmFsaWQgRGVsYXVuYXkgRWRnZSBzaGFyZWQgYnkgdHdvIHRyaWFuZ2xlc1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGlzIGdpdmVzIHVzIDQgbmV3IGVkZ2VzIHRvIGNoZWNrIGZvciBEZWxhdW5heVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gTWFrZSBzdXJlIHRoYXQgdHJpYW5nbGUgdG8gbm9kZSBtYXBwaW5nIGlzIGRvbmUgb25seSBvbmUgdGltZSBmb3IgYSBzcGVjaWZpYyB0cmlhbmdsZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBub3RMZWdhbGl6ZWQgPSAhTGVnYWxpemUodGN4LCB0KTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChub3RMZWdhbGl6ZWQpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRjeC5NYXBUcmlhbmdsZVRvTm9kZXModCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgbm90TGVnYWxpemVkID0gIUxlZ2FsaXplKHRjeCwgb3QpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobm90TGVnYWxpemVkKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0Y3guTWFwVHJpYW5nbGVUb05vZGVzKG90KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gUmVzZXQgdGhlIERlbGF1bmF5IGVkZ2VzLCBzaW5jZSB0aGV5IG9ubHkgYXJlIHZhbGlkIERlbGF1bmF5IGVkZ2VzXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHVudGlsIHdlIGFkZCBhIG5ldyB0cmlhbmdsZSBvciBwb2ludC5cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gWFhYOiBuZWVkIHRvIHRoaW5rIGFib3V0IHRoaXMuIENhbiB0aGVzZSBlZGdlcyBiZSB0cmllZCBhZnRlciB3ZSBcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gICAgICByZXR1cm4gdG8gcHJldmlvdXMgcmVjdXJzaXZlIGxldmVsP1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0LkVkZ2VJc0RlbGF1bmF5W2ldID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG90LkVkZ2VJc0RlbGF1bmF5W29pXSA9IGZhbHNlO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWYgdHJpYW5nbGUgaGF2ZSBiZWVuIGxlZ2FsaXplZCBubyBuZWVkIHRvIGNoZWNrIHRoZSBvdGhlciBlZGdlcyBzaW5jZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB0aGUgcmVjdXJzaXZlIGxlZ2FsaXphdGlvbiB3aWxsIGhhbmRsZXMgdGhvc2Ugc28gd2UgY2FuIGVuZCBoZXJlLlxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBSb3RhdGVzIGEgdHJpYW5nbGUgcGFpciBvbmUgdmVydGV4IENXXHJcbiAgICAgICAgLy8vICAgICAgIG4yICAgICAgICAgICAgICAgICAgICBuMlxyXG4gICAgICAgIC8vLyAgUCArLS0tLS0rICAgICAgICAgICAgIFAgKy0tLS0tK1xyXG4gICAgICAgIC8vLyAgICB8IHQgIC98ICAgICAgICAgICAgICAgfFxcICB0IHwgIFxyXG4gICAgICAgIC8vLyAgICB8ICAgLyB8ICAgICAgICAgICAgICAgfCBcXCAgIHxcclxuICAgICAgICAvLy8gIG4xfCAgLyAgfG4zICAgICAgICAgICBuMXwgIFxcICB8bjNcclxuICAgICAgICAvLy8gICAgfCAvICAgfCAgICBhZnRlciBDVyAgIHwgICBcXCB8XHJcbiAgICAgICAgLy8vICAgIHwvIG9UIHwgICAgICAgICAgICAgICB8IG9UIFxcfFxyXG4gICAgICAgIC8vLyAgICArLS0tLS0rIG9QICAgICAgICAgICAgKy0tLS0tK1xyXG4gICAgICAgIC8vLyAgICAgICBuNCAgICAgICAgICAgICAgICAgICAgbjRcclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIHByaXZhdGUgc3RhdGljIHZvaWQgUm90YXRlVHJpYW5nbGVQYWlyKERlbGF1bmF5VHJpYW5nbGUgdCwgVHJpYW5ndWxhdGlvblBvaW50IHAsIERlbGF1bmF5VHJpYW5nbGUgb3QsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgVHJpYW5ndWxhdGlvblBvaW50IG9wKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgRGVsYXVuYXlUcmlhbmdsZSBuMSwgbjIsIG4zLCBuNDtcclxuICAgICAgICAgICAgbjEgPSB0Lk5laWdoYm9yQ0NXKHApO1xyXG4gICAgICAgICAgICBuMiA9IHQuTmVpZ2hib3JDVyhwKTtcclxuICAgICAgICAgICAgbjMgPSBvdC5OZWlnaGJvckNDVyhvcCk7XHJcbiAgICAgICAgICAgIG40ID0gb3QuTmVpZ2hib3JDVyhvcCk7XHJcblxyXG4gICAgICAgICAgICBib29sIGNlMSwgY2UyLCBjZTMsIGNlNDtcclxuICAgICAgICAgICAgY2UxID0gdC5HZXRDb25zdHJhaW5lZEVkZ2VDQ1cocCk7XHJcbiAgICAgICAgICAgIGNlMiA9IHQuR2V0Q29uc3RyYWluZWRFZGdlQ1cocCk7XHJcbiAgICAgICAgICAgIGNlMyA9IG90LkdldENvbnN0cmFpbmVkRWRnZUNDVyhvcCk7XHJcbiAgICAgICAgICAgIGNlNCA9IG90LkdldENvbnN0cmFpbmVkRWRnZUNXKG9wKTtcclxuXHJcbiAgICAgICAgICAgIGJvb2wgZGUxLCBkZTIsIGRlMywgZGU0O1xyXG4gICAgICAgICAgICBkZTEgPSB0LkdldERlbGF1bmF5RWRnZUNDVyhwKTtcclxuICAgICAgICAgICAgZGUyID0gdC5HZXREZWxhdW5heUVkZ2VDVyhwKTtcclxuICAgICAgICAgICAgZGUzID0gb3QuR2V0RGVsYXVuYXlFZGdlQ0NXKG9wKTtcclxuICAgICAgICAgICAgZGU0ID0gb3QuR2V0RGVsYXVuYXlFZGdlQ1cob3ApO1xyXG5cclxuICAgICAgICAgICAgdC5MZWdhbGl6ZShwLCBvcCk7XHJcbiAgICAgICAgICAgIG90LkxlZ2FsaXplKG9wLCBwKTtcclxuXHJcbiAgICAgICAgICAgIC8vIFJlbWFwIGRFZGdlXHJcbiAgICAgICAgICAgIG90LlNldERlbGF1bmF5RWRnZUNDVyhwLCBkZTEpO1xyXG4gICAgICAgICAgICB0LlNldERlbGF1bmF5RWRnZUNXKHAsIGRlMik7XHJcbiAgICAgICAgICAgIHQuU2V0RGVsYXVuYXlFZGdlQ0NXKG9wLCBkZTMpO1xyXG4gICAgICAgICAgICBvdC5TZXREZWxhdW5heUVkZ2VDVyhvcCwgZGU0KTtcclxuXHJcbiAgICAgICAgICAgIC8vIFJlbWFwIGNFZGdlXHJcbiAgICAgICAgICAgIG90LlNldENvbnN0cmFpbmVkRWRnZUNDVyhwLCBjZTEpO1xyXG4gICAgICAgICAgICB0LlNldENvbnN0cmFpbmVkRWRnZUNXKHAsIGNlMik7XHJcbiAgICAgICAgICAgIHQuU2V0Q29uc3RyYWluZWRFZGdlQ0NXKG9wLCBjZTMpO1xyXG4gICAgICAgICAgICBvdC5TZXRDb25zdHJhaW5lZEVkZ2VDVyhvcCwgY2U0KTtcclxuXHJcbiAgICAgICAgICAgIC8vIFJlbWFwIG5laWdoYm9yc1xyXG4gICAgICAgICAgICAvLyBYWFg6IG1pZ2h0IG9wdGltaXplIHRoZSBtYXJrTmVpZ2hib3IgYnkga2VlcGluZyB0cmFjayBvZlxyXG4gICAgICAgICAgICAvLyAgICAgIHdoYXQgc2lkZSBzaG91bGQgYmUgYXNzaWduZWQgdG8gd2hhdCBuZWlnaGJvciBhZnRlciB0aGUgXHJcbiAgICAgICAgICAgIC8vICAgICAgcm90YXRpb24uIE5vdyBtYXJrIG5laWdoYm9yIGRvZXMgbG90cyBvZiB0ZXN0aW5nIHRvIGZpbmQgXHJcbiAgICAgICAgICAgIC8vICAgICAgdGhlIHJpZ2h0IHNpZGUuXHJcbiAgICAgICAgICAgIHQuTmVpZ2hib3JzLkNsZWFyKCk7XHJcbiAgICAgICAgICAgIG90Lk5laWdoYm9ycy5DbGVhcigpO1xyXG4gICAgICAgICAgICBpZiAobjEgIT0gbnVsbCkgb3QuTWFya05laWdoYm9yKG4xKTtcclxuICAgICAgICAgICAgaWYgKG4yICE9IG51bGwpIHQuTWFya05laWdoYm9yKG4yKTtcclxuICAgICAgICAgICAgaWYgKG4zICE9IG51bGwpIHQuTWFya05laWdoYm9yKG4zKTtcclxuICAgICAgICAgICAgaWYgKG40ICE9IG51bGwpIG90Lk1hcmtOZWlnaGJvcihuNCk7XHJcbiAgICAgICAgICAgIHQuTWFya05laWdoYm9yKG90KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn0iLCIvKiBQb2x5MlRyaVxyXG4gKiBDb3B5cmlnaHQgKGMpIDIwMDktMjAxMCwgUG9seTJUcmkgQ29udHJpYnV0b3JzXHJcbiAqIGh0dHA6Ly9jb2RlLmdvb2dsZS5jb20vcC9wb2x5MnRyaS9cclxuICpcclxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICpcclxuICogUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aCBvciB3aXRob3V0IG1vZGlmaWNhdGlvbixcclxuICogYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgY29uZGl0aW9ucyBhcmUgbWV0OlxyXG4gKlxyXG4gKiAqIFJlZGlzdHJpYnV0aW9ucyBvZiBzb3VyY2UgY29kZSBtdXN0IHJldGFpbiB0aGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSxcclxuICogICB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyLlxyXG4gKiAqIFJlZGlzdHJpYnV0aW9ucyBpbiBiaW5hcnkgZm9ybSBtdXN0IHJlcHJvZHVjZSB0aGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSxcclxuICogICB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyIGluIHRoZSBkb2N1bWVudGF0aW9uXHJcbiAqICAgYW5kL29yIG90aGVyIG1hdGVyaWFscyBwcm92aWRlZCB3aXRoIHRoZSBkaXN0cmlidXRpb24uXHJcbiAqICogTmVpdGhlciB0aGUgbmFtZSBvZiBQb2x5MlRyaSBub3IgdGhlIG5hbWVzIG9mIGl0cyBjb250cmlidXRvcnMgbWF5IGJlXHJcbiAqICAgdXNlZCB0byBlbmRvcnNlIG9yIHByb21vdGUgcHJvZHVjdHMgZGVyaXZlZCBmcm9tIHRoaXMgc29mdHdhcmUgd2l0aG91dCBzcGVjaWZpY1xyXG4gKiAgIHByaW9yIHdyaXR0ZW4gcGVybWlzc2lvbi5cclxuICpcclxuICogVEhJUyBTT0ZUV0FSRSBJUyBQUk9WSURFRCBCWSBUSEUgQ09QWVJJR0hUIEhPTERFUlMgQU5EIENPTlRSSUJVVE9SU1xyXG4gKiBcIkFTIElTXCIgQU5EIEFOWSBFWFBSRVNTIE9SIElNUExJRUQgV0FSUkFOVElFUywgSU5DTFVESU5HLCBCVVQgTk9UXHJcbiAqIExJTUlURUQgVE8sIFRIRSBJTVBMSUVEIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZIEFORCBGSVRORVNTIEZPUlxyXG4gKiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBUkUgRElTQ0xBSU1FRC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIENPUFlSSUdIVCBPV05FUiBPUlxyXG4gKiBDT05UUklCVVRPUlMgQkUgTElBQkxFIEZPUiBBTlkgRElSRUNULCBJTkRJUkVDVCwgSU5DSURFTlRBTCwgU1BFQ0lBTCxcclxuICogRVhFTVBMQVJZLCBPUiBDT05TRVFVRU5USUFMIERBTUFHRVMgKElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLFxyXG4gKiBQUk9DVVJFTUVOVCBPRiBTVUJTVElUVVRFIEdPT0RTIE9SIFNFUlZJQ0VTOyBMT1NTIE9GIFVTRSwgREFUQSwgT1JcclxuICogUFJPRklUUzsgT1IgQlVTSU5FU1MgSU5URVJSVVBUSU9OKSBIT1dFVkVSIENBVVNFRCBBTkQgT04gQU5ZIFRIRU9SWSBPRlxyXG4gKiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQ09OVFJBQ1QsIFNUUklDVCBMSUFCSUxJVFksIE9SIFRPUlQgKElOQ0xVRElOR1xyXG4gKiBORUdMSUdFTkNFIE9SIE9USEVSV0lTRSkgQVJJU0lORyBJTiBBTlkgV0FZIE9VVCBPRiBUSEUgVVNFIE9GIFRISVNcclxuICogU09GVFdBUkUsIEVWRU4gSUYgQURWSVNFRCBPRiBUSEUgUE9TU0lCSUxJVFkgT0YgU1VDSCBEQU1BR0UuXHJcbiAqL1xyXG5cclxudXNpbmcgU3lzdGVtLkNvbGxlY3Rpb25zLkdlbmVyaWM7XHJcbnVzaW5nIFN5c3RlbS5SdW50aW1lLkNvbXBpbGVyU2VydmljZXM7XHJcbnVzaW5nIFBvbHkyVHJpLlRyaWFuZ3VsYXRpb24uRGVsYXVuYXk7XHJcblxyXG5uYW1lc3BhY2UgUG9seTJUcmkuVHJpYW5ndWxhdGlvblxyXG57XHJcbiAgICBwdWJsaWMgYWJzdHJhY3QgY2xhc3MgVHJpYW5ndWxhdGlvbkNvbnRleHRcclxuICAgIHtcclxuICAgICAgICBwdWJsaWMgcmVhZG9ubHkgTGlzdDxUcmlhbmd1bGF0aW9uUG9pbnQ+IFBvaW50cyA9IG5ldyBMaXN0PFRyaWFuZ3VsYXRpb25Qb2ludD4oMjAwKTtcclxuICAgICAgICBwdWJsaWMgcmVhZG9ubHkgTGlzdDxEZWxhdW5heVRyaWFuZ2xlPiBUcmlhbmdsZXMgPSBuZXcgTGlzdDxEZWxhdW5heVRyaWFuZ2xlPigpO1xyXG4gICAgICAgIHByaXZhdGUgaW50IF9zdGVwVGltZSA9IC0xO1xyXG5cclxuICAgICAgICBwdWJsaWMgVHJpYW5ndWxhdGlvbkNvbnRleHQoKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgVGVybWluYXRlZCA9IGZhbHNlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHVibGljIFRyaWFuZ3VsYXRpb25Nb2RlIFRyaWFuZ3VsYXRpb25Nb2RlIHsgZ2V0OyBwcm90ZWN0ZWQgc2V0OyB9XHJcbiAgICAgICAgcHVibGljIFRyaWFuZ3VsYXRhYmxlIFRyaWFuZ3VsYXRhYmxlIHsgZ2V0OyBwcml2YXRlIHNldDsgfVxyXG5cclxuICAgICAgICBwdWJsaWMgYm9vbCBXYWl0VW50aWxOb3RpZmllZCB7IGdldDsgcHJpdmF0ZSBzZXQ7IH1cclxuICAgICAgICBwdWJsaWMgYm9vbCBUZXJtaW5hdGVkIHsgZ2V0OyBzZXQ7IH1cclxuXHJcbiAgICAgICAgcHVibGljIGludCBTdGVwQ291bnQgeyBnZXQ7IHByaXZhdGUgc2V0OyB9XHJcbiAgICAgICAgcHVibGljIHZpcnR1YWwgYm9vbCBJc0RlYnVnRW5hYmxlZCB7IGdldDsgcHJvdGVjdGVkIHNldDsgfVxyXG5cclxuICAgICAgICBwdWJsaWMgdm9pZCBEb25lKClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIFN0ZXBDb3VudCsrO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHVibGljIHZpcnR1YWwgdm9pZCBQcmVwYXJlVHJpYW5ndWxhdGlvbihUcmlhbmd1bGF0YWJsZSB0KVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgVHJpYW5ndWxhdGFibGUgPSB0O1xyXG4gICAgICAgICAgICBUcmlhbmd1bGF0aW9uTW9kZSA9IHQuVHJpYW5ndWxhdGlvbk1vZGU7XHJcbiAgICAgICAgICAgIHQuUHJlcGFyZVRyaWFuZ3VsYXRpb24odGhpcyk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwdWJsaWMgYWJzdHJhY3QgVHJpYW5ndWxhdGlvbkNvbnN0cmFpbnQgTmV3Q29uc3RyYWludChUcmlhbmd1bGF0aW9uUG9pbnQgYSwgVHJpYW5ndWxhdGlvblBvaW50IGIpO1xyXG5cclxuI2lmICFORVRGWF9DT1JFXHJcbiAgICAgICAgW01ldGhvZEltcGwoTWV0aG9kSW1wbE9wdGlvbnMuU3luY2hyb25pemVkKV1cclxuI2VuZGlmXHJcbiAgICAgICAgcHVibGljIHZvaWQgVXBkYXRlKHN0cmluZyBtZXNzYWdlKVxyXG4gICAgICAgIHtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHB1YmxpYyB2aXJ0dWFsIHZvaWQgQ2xlYXIoKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgUG9pbnRzLkNsZWFyKCk7XHJcbiAgICAgICAgICAgIFRlcm1pbmF0ZWQgPSBmYWxzZTtcclxuICAgICAgICAgICAgU3RlcENvdW50ID0gMDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn0iLCIvKiBQb2x5MlRyaVxyXG4gKiBDb3B5cmlnaHQgKGMpIDIwMDktMjAxMCwgUG9seTJUcmkgQ29udHJpYnV0b3JzXHJcbiAqIGh0dHA6Ly9jb2RlLmdvb2dsZS5jb20vcC9wb2x5MnRyaS9cclxuICpcclxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICpcclxuICogUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aCBvciB3aXRob3V0IG1vZGlmaWNhdGlvbixcclxuICogYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgY29uZGl0aW9ucyBhcmUgbWV0OlxyXG4gKlxyXG4gKiAqIFJlZGlzdHJpYnV0aW9ucyBvZiBzb3VyY2UgY29kZSBtdXN0IHJldGFpbiB0aGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSxcclxuICogICB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyLlxyXG4gKiAqIFJlZGlzdHJpYnV0aW9ucyBpbiBiaW5hcnkgZm9ybSBtdXN0IHJlcHJvZHVjZSB0aGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSxcclxuICogICB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyIGluIHRoZSBkb2N1bWVudGF0aW9uXHJcbiAqICAgYW5kL29yIG90aGVyIG1hdGVyaWFscyBwcm92aWRlZCB3aXRoIHRoZSBkaXN0cmlidXRpb24uXHJcbiAqICogTmVpdGhlciB0aGUgbmFtZSBvZiBQb2x5MlRyaSBub3IgdGhlIG5hbWVzIG9mIGl0cyBjb250cmlidXRvcnMgbWF5IGJlXHJcbiAqICAgdXNlZCB0byBlbmRvcnNlIG9yIHByb21vdGUgcHJvZHVjdHMgZGVyaXZlZCBmcm9tIHRoaXMgc29mdHdhcmUgd2l0aG91dCBzcGVjaWZpY1xyXG4gKiAgIHByaW9yIHdyaXR0ZW4gcGVybWlzc2lvbi5cclxuICpcclxuICogVEhJUyBTT0ZUV0FSRSBJUyBQUk9WSURFRCBCWSBUSEUgQ09QWVJJR0hUIEhPTERFUlMgQU5EIENPTlRSSUJVVE9SU1xyXG4gKiBcIkFTIElTXCIgQU5EIEFOWSBFWFBSRVNTIE9SIElNUExJRUQgV0FSUkFOVElFUywgSU5DTFVESU5HLCBCVVQgTk9UXHJcbiAqIExJTUlURUQgVE8sIFRIRSBJTVBMSUVEIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZIEFORCBGSVRORVNTIEZPUlxyXG4gKiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBUkUgRElTQ0xBSU1FRC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIENPUFlSSUdIVCBPV05FUiBPUlxyXG4gKiBDT05UUklCVVRPUlMgQkUgTElBQkxFIEZPUiBBTlkgRElSRUNULCBJTkRJUkVDVCwgSU5DSURFTlRBTCwgU1BFQ0lBTCxcclxuICogRVhFTVBMQVJZLCBPUiBDT05TRVFVRU5USUFMIERBTUFHRVMgKElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLFxyXG4gKiBQUk9DVVJFTUVOVCBPRiBTVUJTVElUVVRFIEdPT0RTIE9SIFNFUlZJQ0VTOyBMT1NTIE9GIFVTRSwgREFUQSwgT1JcclxuICogUFJPRklUUzsgT1IgQlVTSU5FU1MgSU5URVJSVVBUSU9OKSBIT1dFVkVSIENBVVNFRCBBTkQgT04gQU5ZIFRIRU9SWSBPRlxyXG4gKiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQ09OVFJBQ1QsIFNUUklDVCBMSUFCSUxJVFksIE9SIFRPUlQgKElOQ0xVRElOR1xyXG4gKiBORUdMSUdFTkNFIE9SIE9USEVSV0lTRSkgQVJJU0lORyBJTiBBTlkgV0FZIE9VVCBPRiBUSEUgVVNFIE9GIFRISVNcclxuICogU09GVFdBUkUsIEVWRU4gSUYgQURWSVNFRCBPRiBUSEUgUE9TU0lCSUxJVFkgT0YgU1VDSCBEQU1BR0UuXHJcbiAqL1xyXG5cclxudXNpbmcgU3lzdGVtLkNvbGxlY3Rpb25zLkdlbmVyaWM7XHJcbnVzaW5nIFBvbHkyVHJpLlRyaWFuZ3VsYXRpb24uRGVsYXVuYXkuU3dlZXA7XHJcblxyXG5uYW1lc3BhY2UgUG9seTJUcmkuVHJpYW5ndWxhdGlvblxyXG57XHJcbiAgICBwdWJsaWMgY2xhc3MgVHJpYW5ndWxhdGlvblBvaW50XHJcbiAgICB7XHJcbiAgICAgICAgLy8gTGlzdCBvZiBlZGdlcyB0aGlzIHBvaW50IGNvbnN0aXR1dGVzIGFuIHVwcGVyIGVuZGluZyBwb2ludCAoQ0RUKVxyXG5cclxuICAgICAgICBwdWJsaWMgZG91YmxlIFgsIFk7XHJcblxyXG4gICAgICAgIHB1YmxpYyBUcmlhbmd1bGF0aW9uUG9pbnQoZG91YmxlIHgsIGRvdWJsZSB5KVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgWCA9IHg7XHJcbiAgICAgICAgICAgIFkgPSB5O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHVibGljIExpc3Q8RFRTd2VlcENvbnN0cmFpbnQ+IEVkZ2VzIHsgZ2V0OyBwcml2YXRlIHNldDsgfVxyXG5cclxuICAgICAgICBwdWJsaWMgZmxvYXQgWGZcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGdldCB7IHJldHVybiAoZmxvYXQpIFg7IH1cclxuICAgICAgICAgICAgc2V0IHsgWCA9IHZhbHVlOyB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwdWJsaWMgZmxvYXQgWWZcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGdldCB7IHJldHVybiAoZmxvYXQpIFk7IH1cclxuICAgICAgICAgICAgc2V0IHsgWSA9IHZhbHVlOyB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwdWJsaWMgYm9vbCBIYXNFZGdlc1xyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgZ2V0IHsgcmV0dXJuIEVkZ2VzICE9IG51bGw7IH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHB1YmxpYyBvdmVycmlkZSBzdHJpbmcgVG9TdHJpbmcoKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIFwiW1wiICsgWCArIFwiLFwiICsgWSArIFwiXVwiO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHVibGljIHZvaWQgQWRkRWRnZShEVFN3ZWVwQ29uc3RyYWludCBlKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgaWYgKEVkZ2VzID09IG51bGwpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIEVkZ2VzID0gbmV3IExpc3Q8RFRTd2VlcENvbnN0cmFpbnQ+KCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgRWRnZXMuQWRkKGUpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufSIsIi8qIFBvbHkyVHJpXHJcbiAqIENvcHlyaWdodCAoYykgMjAwOS0yMDEwLCBQb2x5MlRyaSBDb250cmlidXRvcnNcclxuICogaHR0cDovL2NvZGUuZ29vZ2xlLmNvbS9wL3BvbHkydHJpL1xyXG4gKlxyXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKlxyXG4gKiBSZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRoIG9yIHdpdGhvdXQgbW9kaWZpY2F0aW9uLFxyXG4gKiBhcmUgcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBjb25kaXRpb25zIGFyZSBtZXQ6XHJcbiAqXHJcbiAqICogUmVkaXN0cmlidXRpb25zIG9mIHNvdXJjZSBjb2RlIG11c3QgcmV0YWluIHRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlLFxyXG4gKiAgIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIuXHJcbiAqICogUmVkaXN0cmlidXRpb25zIGluIGJpbmFyeSBmb3JtIG11c3QgcmVwcm9kdWNlIHRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlLFxyXG4gKiAgIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIgaW4gdGhlIGRvY3VtZW50YXRpb25cclxuICogICBhbmQvb3Igb3RoZXIgbWF0ZXJpYWxzIHByb3ZpZGVkIHdpdGggdGhlIGRpc3RyaWJ1dGlvbi5cclxuICogKiBOZWl0aGVyIHRoZSBuYW1lIG9mIFBvbHkyVHJpIG5vciB0aGUgbmFtZXMgb2YgaXRzIGNvbnRyaWJ1dG9ycyBtYXkgYmVcclxuICogICB1c2VkIHRvIGVuZG9yc2Ugb3IgcHJvbW90ZSBwcm9kdWN0cyBkZXJpdmVkIGZyb20gdGhpcyBzb2Z0d2FyZSB3aXRob3V0IHNwZWNpZmljXHJcbiAqICAgcHJpb3Igd3JpdHRlbiBwZXJtaXNzaW9uLlxyXG4gKlxyXG4gKiBUSElTIFNPRlRXQVJFIElTIFBST1ZJREVEIEJZIFRIRSBDT1BZUklHSFQgSE9MREVSUyBBTkQgQ09OVFJJQlVUT1JTXHJcbiAqIFwiQVMgSVNcIiBBTkQgQU5ZIEVYUFJFU1MgT1IgSU1QTElFRCBXQVJSQU5USUVTLCBJTkNMVURJTkcsIEJVVCBOT1RcclxuICogTElNSVRFRCBUTywgVEhFIElNUExJRUQgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFkgQU5EIEZJVE5FU1MgRk9SXHJcbiAqIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFSRSBESVNDTEFJTUVELiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQ09QWVJJR0hUIE9XTkVSIE9SXHJcbiAqIENPTlRSSUJVVE9SUyBCRSBMSUFCTEUgRk9SIEFOWSBESVJFQ1QsIElORElSRUNULCBJTkNJREVOVEFMLCBTUEVDSUFMLFxyXG4gKiBFWEVNUExBUlksIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFUyAoSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sXHJcbiAqIFBST0NVUkVNRU5UIE9GIFNVQlNUSVRVVEUgR09PRFMgT1IgU0VSVklDRVM7IExPU1MgT0YgVVNFLCBEQVRBLCBPUlxyXG4gKiBQUk9GSVRTOyBPUiBCVVNJTkVTUyBJTlRFUlJVUFRJT04pIEhPV0VWRVIgQ0FVU0VEIEFORCBPTiBBTlkgVEhFT1JZIE9GXHJcbiAqIExJQUJJTElUWSwgV0hFVEhFUiBJTiBDT05UUkFDVCwgU1RSSUNUIExJQUJJTElUWSwgT1IgVE9SVCAoSU5DTFVESU5HXHJcbiAqIE5FR0xJR0VOQ0UgT1IgT1RIRVJXSVNFKSBBUklTSU5HIElOIEFOWSBXQVkgT1VUIE9GIFRIRSBVU0UgT0YgVEhJU1xyXG4gKiBTT0ZUV0FSRSwgRVZFTiBJRiBBRFZJU0VEIE9GIFRIRSBQT1NTSUJJTElUWSBPRiBTVUNIIERBTUFHRS5cclxuICovXHJcblxyXG51c2luZyBTeXN0ZW07XHJcblxyXG5uYW1lc3BhY2UgUG9seTJUcmkuVHJpYW5ndWxhdGlvbi5EZWxhdW5heS5Td2VlcFxyXG57XHJcbiAgICBwdWJsaWMgY2xhc3MgUG9pbnRPbkVkZ2VFeGNlcHRpb24gOiBOb3RJbXBsZW1lbnRlZEV4Y2VwdGlvblxyXG4gICAge1xyXG4gICAgICAgIHB1YmxpYyBQb2ludE9uRWRnZUV4Y2VwdGlvbihzdHJpbmcgbWVzc2FnZSlcclxuICAgICAgICAgICAgOiBiYXNlKG1lc3NhZ2UpXHJcbiAgICAgICAge1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufSIsIi8qIFBvbHkyVHJpXHJcbiAqIENvcHlyaWdodCAoYykgMjAwOS0yMDEwLCBQb2x5MlRyaSBDb250cmlidXRvcnNcclxuICogaHR0cDovL2NvZGUuZ29vZ2xlLmNvbS9wL3BvbHkydHJpL1xyXG4gKlxyXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKlxyXG4gKiBSZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRoIG9yIHdpdGhvdXQgbW9kaWZpY2F0aW9uLFxyXG4gKiBhcmUgcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBjb25kaXRpb25zIGFyZSBtZXQ6XHJcbiAqXHJcbiAqICogUmVkaXN0cmlidXRpb25zIG9mIHNvdXJjZSBjb2RlIG11c3QgcmV0YWluIHRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlLFxyXG4gKiAgIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIuXHJcbiAqICogUmVkaXN0cmlidXRpb25zIGluIGJpbmFyeSBmb3JtIG11c3QgcmVwcm9kdWNlIHRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlLFxyXG4gKiAgIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIgaW4gdGhlIGRvY3VtZW50YXRpb25cclxuICogICBhbmQvb3Igb3RoZXIgbWF0ZXJpYWxzIHByb3ZpZGVkIHdpdGggdGhlIGRpc3RyaWJ1dGlvbi5cclxuICogKiBOZWl0aGVyIHRoZSBuYW1lIG9mIFBvbHkyVHJpIG5vciB0aGUgbmFtZXMgb2YgaXRzIGNvbnRyaWJ1dG9ycyBtYXkgYmVcclxuICogICB1c2VkIHRvIGVuZG9yc2Ugb3IgcHJvbW90ZSBwcm9kdWN0cyBkZXJpdmVkIGZyb20gdGhpcyBzb2Z0d2FyZSB3aXRob3V0IHNwZWNpZmljXHJcbiAqICAgcHJpb3Igd3JpdHRlbiBwZXJtaXNzaW9uLlxyXG4gKlxyXG4gKiBUSElTIFNPRlRXQVJFIElTIFBST1ZJREVEIEJZIFRIRSBDT1BZUklHSFQgSE9MREVSUyBBTkQgQ09OVFJJQlVUT1JTXHJcbiAqIFwiQVMgSVNcIiBBTkQgQU5ZIEVYUFJFU1MgT1IgSU1QTElFRCBXQVJSQU5USUVTLCBJTkNMVURJTkcsIEJVVCBOT1RcclxuICogTElNSVRFRCBUTywgVEhFIElNUExJRUQgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFkgQU5EIEZJVE5FU1MgRk9SXHJcbiAqIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFSRSBESVNDTEFJTUVELiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQ09QWVJJR0hUIE9XTkVSIE9SXHJcbiAqIENPTlRSSUJVVE9SUyBCRSBMSUFCTEUgRk9SIEFOWSBESVJFQ1QsIElORElSRUNULCBJTkNJREVOVEFMLCBTUEVDSUFMLFxyXG4gKiBFWEVNUExBUlksIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFUyAoSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sXHJcbiAqIFBST0NVUkVNRU5UIE9GIFNVQlNUSVRVVEUgR09PRFMgT1IgU0VSVklDRVM7IExPU1MgT0YgVVNFLCBEQVRBLCBPUlxyXG4gKiBQUk9GSVRTOyBPUiBCVVNJTkVTUyBJTlRFUlJVUFRJT04pIEhPV0VWRVIgQ0FVU0VEIEFORCBPTiBBTlkgVEhFT1JZIE9GXHJcbiAqIExJQUJJTElUWSwgV0hFVEhFUiBJTiBDT05UUkFDVCwgU1RSSUNUIExJQUJJTElUWSwgT1IgVE9SVCAoSU5DTFVESU5HXHJcbiAqIE5FR0xJR0VOQ0UgT1IgT1RIRVJXSVNFKSBBUklTSU5HIElOIEFOWSBXQVkgT1VUIE9GIFRIRSBVU0UgT0YgVEhJU1xyXG4gKiBTT0ZUV0FSRSwgRVZFTiBJRiBBRFZJU0VEIE9GIFRIRSBQT1NTSUJJTElUWSBPRiBTVUNIIERBTUFHRS5cclxuICovXHJcblxyXG4vLyBDaGFuZ2VzIGZyb20gdGhlIEphdmEgdmVyc2lvblxyXG4vLyAgIFJlcGxhY2VkIGdldFBvbHlnb25zIHdpdGggYXR0cmlidXRlXHJcbi8vIEZ1dHVyZSBwb3NzaWJpbGl0aWVzXHJcbi8vICAgUmVwbGFjZSBBZGQoUG9seWdvbikgd2l0aCBleHBvc2VkIGNvbnRhaW5lcj9cclxuLy8gICBSZXBsYWNlIGVudGlyZSBjbGFzcyB3aXRoIEhhc2hTZXQ8UG9seWdvbj4gP1xyXG5cclxudXNpbmcgU3lzdGVtLkNvbGxlY3Rpb25zLkdlbmVyaWM7XHJcblxyXG5uYW1lc3BhY2UgUG9seTJUcmkuVHJpYW5ndWxhdGlvbi5Qb2x5Z29uXHJcbntcclxuICAgIHB1YmxpYyBjbGFzcyBQb2x5Z29uU2V0XHJcbiAgICB7XHJcbiAgICAgICAgcHJvdGVjdGVkIExpc3Q8UG9seWdvbj4gX3BvbHlnb25zID0gbmV3IExpc3Q8UG9seWdvbj4oKTtcclxuXHJcbiAgICAgICAgcHVibGljIFBvbHlnb25TZXQoKVxyXG4gICAgICAgIHtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHB1YmxpYyBQb2x5Z29uU2V0KFBvbHlnb24gcG9seSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIF9wb2x5Z29ucy5BZGQocG9seSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwdWJsaWMgSUVudW1lcmFibGU8UG9seWdvbj4gUG9seWdvbnNcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGdldCB7IHJldHVybiBfcG9seWdvbnM7IH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHB1YmxpYyB2b2lkIEFkZChQb2x5Z29uIHApXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBfcG9seWdvbnMuQWRkKHApO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufSIsIi8qIFBvbHkyVHJpXHJcbiAqIENvcHlyaWdodCAoYykgMjAwOS0yMDEwLCBQb2x5MlRyaSBDb250cmlidXRvcnNcclxuICogaHR0cDovL2NvZGUuZ29vZ2xlLmNvbS9wL3BvbHkydHJpL1xyXG4gKlxyXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKlxyXG4gKiBSZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRoIG9yIHdpdGhvdXQgbW9kaWZpY2F0aW9uLFxyXG4gKiBhcmUgcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBjb25kaXRpb25zIGFyZSBtZXQ6XHJcbiAqXHJcbiAqICogUmVkaXN0cmlidXRpb25zIG9mIHNvdXJjZSBjb2RlIG11c3QgcmV0YWluIHRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlLFxyXG4gKiAgIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIuXHJcbiAqICogUmVkaXN0cmlidXRpb25zIGluIGJpbmFyeSBmb3JtIG11c3QgcmVwcm9kdWNlIHRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlLFxyXG4gKiAgIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIgaW4gdGhlIGRvY3VtZW50YXRpb25cclxuICogICBhbmQvb3Igb3RoZXIgbWF0ZXJpYWxzIHByb3ZpZGVkIHdpdGggdGhlIGRpc3RyaWJ1dGlvbi5cclxuICogKiBOZWl0aGVyIHRoZSBuYW1lIG9mIFBvbHkyVHJpIG5vciB0aGUgbmFtZXMgb2YgaXRzIGNvbnRyaWJ1dG9ycyBtYXkgYmVcclxuICogICB1c2VkIHRvIGVuZG9yc2Ugb3IgcHJvbW90ZSBwcm9kdWN0cyBkZXJpdmVkIGZyb20gdGhpcyBzb2Z0d2FyZSB3aXRob3V0IHNwZWNpZmljXHJcbiAqICAgcHJpb3Igd3JpdHRlbiBwZXJtaXNzaW9uLlxyXG4gKlxyXG4gKiBUSElTIFNPRlRXQVJFIElTIFBST1ZJREVEIEJZIFRIRSBDT1BZUklHSFQgSE9MREVSUyBBTkQgQ09OVFJJQlVUT1JTXHJcbiAqIFwiQVMgSVNcIiBBTkQgQU5ZIEVYUFJFU1MgT1IgSU1QTElFRCBXQVJSQU5USUVTLCBJTkNMVURJTkcsIEJVVCBOT1RcclxuICogTElNSVRFRCBUTywgVEhFIElNUExJRUQgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFkgQU5EIEZJVE5FU1MgRk9SXHJcbiAqIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFSRSBESVNDTEFJTUVELiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQ09QWVJJR0hUIE9XTkVSIE9SXHJcbiAqIENPTlRSSUJVVE9SUyBCRSBMSUFCTEUgRk9SIEFOWSBESVJFQ1QsIElORElSRUNULCBJTkNJREVOVEFMLCBTUEVDSUFMLFxyXG4gKiBFWEVNUExBUlksIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFUyAoSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sXHJcbiAqIFBST0NVUkVNRU5UIE9GIFNVQlNUSVRVVEUgR09PRFMgT1IgU0VSVklDRVM7IExPU1MgT0YgVVNFLCBEQVRBLCBPUlxyXG4gKiBQUk9GSVRTOyBPUiBCVVNJTkVTUyBJTlRFUlJVUFRJT04pIEhPV0VWRVIgQ0FVU0VEIEFORCBPTiBBTlkgVEhFT1JZIE9GXHJcbiAqIExJQUJJTElUWSwgV0hFVEhFUiBJTiBDT05UUkFDVCwgU1RSSUNUIExJQUJJTElUWSwgT1IgVE9SVCAoSU5DTFVESU5HXHJcbiAqIE5FR0xJR0VOQ0UgT1IgT1RIRVJXSVNFKSBBUklTSU5HIElOIEFOWSBXQVkgT1VUIE9GIFRIRSBVU0UgT0YgVEhJU1xyXG4gKiBTT0ZUV0FSRSwgRVZFTiBJRiBBRFZJU0VEIE9GIFRIRSBQT1NTSUJJTElUWSBPRiBTVUNIIERBTUFHRS5cclxuICovXHJcblxyXG51c2luZyBGYXJzZWVyUGh5c2ljcy5Db21tb24uRGVjb21wb3NpdGlvbi5DRFQ7XHJcblxyXG5uYW1lc3BhY2UgUG9seTJUcmkuVHJpYW5ndWxhdGlvblxyXG57XHJcbiAgICAvKipcclxuICAgICAqIEBhdXRob3IgVGhvbWFzIMOFaGzDqW4sIHRoYWhsZW5AZ21haWwuY29tXHJcbiAgICAgKi9cclxuXHJcbiAgICBwdWJsaWMgY2xhc3MgVHJpYW5ndWxhdGlvblV0aWxcclxuICAgIHtcclxuICAgICAgICBwdWJsaWMgc3RhdGljIGRvdWJsZSBFUFNJTE9OID0gMWUtMTI7XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gICBSZXF1aXJlbWVudHM6XHJcbiAgICAgICAgLy8vIDEuIGEsYiBhbmQgYyBmb3JtIGEgdHJpYW5nbGUuXHJcbiAgICAgICAgLy8vIDIuIGEgYW5kIGQgaXMga25vdyB0byBiZSBvbiBvcHBvc2l0ZSBzaWRlIG9mIGJjXHJcbiAgICAgICAgLy8vIDxjb2RlPlxyXG4gICAgICAgIC8vLyAgICAgICAgICAgICAgICBhXHJcbiAgICAgICAgLy8vICAgICAgICAgICAgICAgICtcclxuICAgICAgICAvLy8gICAgICAgICAgICAgICAvIFxcXHJcbiAgICAgICAgLy8vICAgICAgICAgICAgICAvICAgXFxcclxuICAgICAgICAvLy8gICAgICAgICAgICBiLyAgICAgXFxjXHJcbiAgICAgICAgLy8vICAgICAgICAgICAgKy0tLS0tLS0rIFxyXG4gICAgICAgIC8vLyAgICAgICAgICAgLyAgICBCICAgIFxcICBcclxuICAgICAgICAvLy8gICAgICAgICAgLyAgICAgICAgICAgXFwgXHJcbiAgICAgICAgLy8vIDwvY29kZT5cclxuICAgICAgICAvLy8gICAgRmFjdHM6XHJcbiAgICAgICAgLy8vICBkIGhhcyB0byBiZSBpbiBhcmVhIEIgdG8gaGF2ZSBhIGNoYW5jZSB0byBiZSBpbnNpZGUgdGhlIGNpcmNsZSBmb3JtZWQgYnkgYSxiIGFuZCBjXHJcbiAgICAgICAgLy8vICBkIGlzIG91dHNpZGUgQiBpZiBvcmllbnQyZChhLGIsZCkgb3Igb3JpZW50MmQoYyxhLGQpIGlzIENXXHJcbiAgICAgICAgLy8vICBUaGlzIHByZWtub3dsZWRnZSBnaXZlcyB1cyBhIHdheSB0byBvcHRpbWl6ZSB0aGUgaW5jaXJjbGUgdGVzdFxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwicGFcIj50cmlhbmdsZSBwb2ludCwgb3Bwb3NpdGUgZDwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwicGJcIj50cmlhbmdsZSBwb2ludDwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwicGNcIj50cmlhbmdsZSBwb2ludDwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwicGRcIj5wb2ludCBvcHBvc2l0ZSBhPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHJldHVybnM+dHJ1ZSBpZiBkIGlzIGluc2lkZSBjaXJjbGUsIGZhbHNlIGlmIG9uIGNpcmNsZSBlZGdlPC9yZXR1cm5zPlxyXG4gICAgICAgIHB1YmxpYyBzdGF0aWMgYm9vbCBTbWFydEluY2lyY2xlKFRyaWFuZ3VsYXRpb25Qb2ludCBwYSwgVHJpYW5ndWxhdGlvblBvaW50IHBiLCBUcmlhbmd1bGF0aW9uUG9pbnQgcGMsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgVHJpYW5ndWxhdGlvblBvaW50IHBkKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgZG91YmxlIHBkeCA9IHBkLlg7XHJcbiAgICAgICAgICAgIGRvdWJsZSBwZHkgPSBwZC5ZO1xyXG4gICAgICAgICAgICBkb3VibGUgYWR4ID0gcGEuWCAtIHBkeDtcclxuICAgICAgICAgICAgZG91YmxlIGFkeSA9IHBhLlkgLSBwZHk7XHJcbiAgICAgICAgICAgIGRvdWJsZSBiZHggPSBwYi5YIC0gcGR4O1xyXG4gICAgICAgICAgICBkb3VibGUgYmR5ID0gcGIuWSAtIHBkeTtcclxuXHJcbiAgICAgICAgICAgIGRvdWJsZSBhZHhiZHkgPSBhZHgqYmR5O1xyXG4gICAgICAgICAgICBkb3VibGUgYmR4YWR5ID0gYmR4KmFkeTtcclxuICAgICAgICAgICAgZG91YmxlIG9hYmQgPSBhZHhiZHkgLSBiZHhhZHk7XHJcbiAgICAgICAgICAgIC8vICAgICAgICBvYWJkID0gb3JpZW50MmQocGEscGIscGQpO1xyXG4gICAgICAgICAgICBpZiAob2FiZCA8PSAwKSByZXR1cm4gZmFsc2U7XHJcblxyXG4gICAgICAgICAgICBkb3VibGUgY2R4ID0gcGMuWCAtIHBkeDtcclxuICAgICAgICAgICAgZG91YmxlIGNkeSA9IHBjLlkgLSBwZHk7XHJcblxyXG4gICAgICAgICAgICBkb3VibGUgY2R4YWR5ID0gY2R4KmFkeTtcclxuICAgICAgICAgICAgZG91YmxlIGFkeGNkeSA9IGFkeCpjZHk7XHJcbiAgICAgICAgICAgIGRvdWJsZSBvY2FkID0gY2R4YWR5IC0gYWR4Y2R5O1xyXG4gICAgICAgICAgICAvLyAgICAgIG9jYWQgPSBvcmllbnQyZChwYyxwYSxwZCk7XHJcbiAgICAgICAgICAgIGlmIChvY2FkIDw9IDApIHJldHVybiBmYWxzZTtcclxuXHJcbiAgICAgICAgICAgIGRvdWJsZSBiZHhjZHkgPSBiZHgqY2R5O1xyXG4gICAgICAgICAgICBkb3VibGUgY2R4YmR5ID0gY2R4KmJkeTtcclxuXHJcbiAgICAgICAgICAgIGRvdWJsZSBhbGlmdCA9IGFkeCphZHggKyBhZHkqYWR5O1xyXG4gICAgICAgICAgICBkb3VibGUgYmxpZnQgPSBiZHgqYmR4ICsgYmR5KmJkeTtcclxuICAgICAgICAgICAgZG91YmxlIGNsaWZ0ID0gY2R4KmNkeCArIGNkeSpjZHk7XHJcblxyXG4gICAgICAgICAgICBkb3VibGUgZGV0ID0gYWxpZnQqKGJkeGNkeSAtIGNkeGJkeSkgKyBibGlmdCpvY2FkICsgY2xpZnQqb2FiZDtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiBkZXQgPiAwO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHVibGljIHN0YXRpYyBib29sIEluU2NhbkFyZWEoVHJpYW5ndWxhdGlvblBvaW50IHBhLCBUcmlhbmd1bGF0aW9uUG9pbnQgcGIsIFRyaWFuZ3VsYXRpb25Qb2ludCBwYyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBUcmlhbmd1bGF0aW9uUG9pbnQgcGQpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBkb3VibGUgcGR4ID0gcGQuWDtcclxuICAgICAgICAgICAgZG91YmxlIHBkeSA9IHBkLlk7XHJcbiAgICAgICAgICAgIGRvdWJsZSBhZHggPSBwYS5YIC0gcGR4O1xyXG4gICAgICAgICAgICBkb3VibGUgYWR5ID0gcGEuWSAtIHBkeTtcclxuICAgICAgICAgICAgZG91YmxlIGJkeCA9IHBiLlggLSBwZHg7XHJcbiAgICAgICAgICAgIGRvdWJsZSBiZHkgPSBwYi5ZIC0gcGR5O1xyXG5cclxuICAgICAgICAgICAgZG91YmxlIGFkeGJkeSA9IGFkeCpiZHk7XHJcbiAgICAgICAgICAgIGRvdWJsZSBiZHhhZHkgPSBiZHgqYWR5O1xyXG4gICAgICAgICAgICBkb3VibGUgb2FiZCA9IGFkeGJkeSAtIGJkeGFkeTtcclxuICAgICAgICAgICAgLy8gICAgICAgIG9hYmQgPSBvcmllbnQyZChwYSxwYixwZCk7XHJcbiAgICAgICAgICAgIGlmIChvYWJkIDw9IDApXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgZG91YmxlIGNkeCA9IHBjLlggLSBwZHg7XHJcbiAgICAgICAgICAgIGRvdWJsZSBjZHkgPSBwYy5ZIC0gcGR5O1xyXG5cclxuICAgICAgICAgICAgZG91YmxlIGNkeGFkeSA9IGNkeCphZHk7XHJcbiAgICAgICAgICAgIGRvdWJsZSBhZHhjZHkgPSBhZHgqY2R5O1xyXG4gICAgICAgICAgICBkb3VibGUgb2NhZCA9IGNkeGFkeSAtIGFkeGNkeTtcclxuICAgICAgICAgICAgLy8gICAgICBvY2FkID0gb3JpZW50MmQocGMscGEscGQpO1xyXG4gICAgICAgICAgICBpZiAob2NhZCA8PSAwKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gRm9ydW1sYSB0byBjYWxjdWxhdGUgc2lnbmVkIGFyZWFcclxuICAgICAgICAvLy8gUG9zaXRpdmUgaWYgQ0NXXHJcbiAgICAgICAgLy8vIE5lZ2F0aXZlIGlmIENXXHJcbiAgICAgICAgLy8vIDAgaWYgY29sbGluZWFyXHJcbiAgICAgICAgLy8vIEFbUDEsUDIsUDNdICA9ICAoeDEqeTIgLSB5MSp4MikgKyAoeDIqeTMgLSB5Mip4MykgKyAoeDMqeTEgLSB5Myp4MSlcclxuICAgICAgICAvLy8gICAgICAgICAgICAgID0gICh4MS14MykqKHkyLXkzKSAtICh5MS15MykqKHgyLXgzKVxyXG4gICAgICAgIHB1YmxpYyBzdGF0aWMgT3JpZW50YXRpb24gT3JpZW50MmQoVHJpYW5ndWxhdGlvblBvaW50IHBhLCBUcmlhbmd1bGF0aW9uUG9pbnQgcGIsIFRyaWFuZ3VsYXRpb25Qb2ludCBwYylcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGRvdWJsZSBkZXRsZWZ0ID0gKHBhLlggLSBwYy5YKSoocGIuWSAtIHBjLlkpO1xyXG4gICAgICAgICAgICBkb3VibGUgZGV0cmlnaHQgPSAocGEuWSAtIHBjLlkpKihwYi5YIC0gcGMuWCk7XHJcbiAgICAgICAgICAgIGRvdWJsZSB2YWwgPSBkZXRsZWZ0IC0gZGV0cmlnaHQ7XHJcbiAgICAgICAgICAgIGlmICh2YWwgPiAtRVBTSUxPTiAmJiB2YWwgPCBFUFNJTE9OKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gT3JpZW50YXRpb24uQ29sbGluZWFyO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKHZhbCA+IDApXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBPcmllbnRhdGlvbi5DQ1c7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIE9yaWVudGF0aW9uLkNXO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufSIsIi8qIFBvbHkyVHJpXHJcbiAqIENvcHlyaWdodCAoYykgMjAwOS0yMDEwLCBQb2x5MlRyaSBDb250cmlidXRvcnNcclxuICogaHR0cDovL2NvZGUuZ29vZ2xlLmNvbS9wL3BvbHkydHJpL1xyXG4gKlxyXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKlxyXG4gKiBSZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRoIG9yIHdpdGhvdXQgbW9kaWZpY2F0aW9uLFxyXG4gKiBhcmUgcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBjb25kaXRpb25zIGFyZSBtZXQ6XHJcbiAqXHJcbiAqICogUmVkaXN0cmlidXRpb25zIG9mIHNvdXJjZSBjb2RlIG11c3QgcmV0YWluIHRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlLFxyXG4gKiAgIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIuXHJcbiAqICogUmVkaXN0cmlidXRpb25zIGluIGJpbmFyeSBmb3JtIG11c3QgcmVwcm9kdWNlIHRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlLFxyXG4gKiAgIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIgaW4gdGhlIGRvY3VtZW50YXRpb25cclxuICogICBhbmQvb3Igb3RoZXIgbWF0ZXJpYWxzIHByb3ZpZGVkIHdpdGggdGhlIGRpc3RyaWJ1dGlvbi5cclxuICogKiBOZWl0aGVyIHRoZSBuYW1lIG9mIFBvbHkyVHJpIG5vciB0aGUgbmFtZXMgb2YgaXRzIGNvbnRyaWJ1dG9ycyBtYXkgYmVcclxuICogICB1c2VkIHRvIGVuZG9yc2Ugb3IgcHJvbW90ZSBwcm9kdWN0cyBkZXJpdmVkIGZyb20gdGhpcyBzb2Z0d2FyZSB3aXRob3V0IHNwZWNpZmljXHJcbiAqICAgcHJpb3Igd3JpdHRlbiBwZXJtaXNzaW9uLlxyXG4gKlxyXG4gKiBUSElTIFNPRlRXQVJFIElTIFBST1ZJREVEIEJZIFRIRSBDT1BZUklHSFQgSE9MREVSUyBBTkQgQ09OVFJJQlVUT1JTXHJcbiAqIFwiQVMgSVNcIiBBTkQgQU5ZIEVYUFJFU1MgT1IgSU1QTElFRCBXQVJSQU5USUVTLCBJTkNMVURJTkcsIEJVVCBOT1RcclxuICogTElNSVRFRCBUTywgVEhFIElNUExJRUQgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFkgQU5EIEZJVE5FU1MgRk9SXHJcbiAqIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFSRSBESVNDTEFJTUVELiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQ09QWVJJR0hUIE9XTkVSIE9SXHJcbiAqIENPTlRSSUJVVE9SUyBCRSBMSUFCTEUgRk9SIEFOWSBESVJFQ1QsIElORElSRUNULCBJTkNJREVOVEFMLCBTUEVDSUFMLFxyXG4gKiBFWEVNUExBUlksIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFUyAoSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sXHJcbiAqIFBST0NVUkVNRU5UIE9GIFNVQlNUSVRVVEUgR09PRFMgT1IgU0VSVklDRVM7IExPU1MgT0YgVVNFLCBEQVRBLCBPUlxyXG4gKiBQUk9GSVRTOyBPUiBCVVNJTkVTUyBJTlRFUlJVUFRJT04pIEhPV0VWRVIgQ0FVU0VEIEFORCBPTiBBTlkgVEhFT1JZIE9GXHJcbiAqIExJQUJJTElUWSwgV0hFVEhFUiBJTiBDT05UUkFDVCwgU1RSSUNUIExJQUJJTElUWSwgT1IgVE9SVCAoSU5DTFVESU5HXHJcbiAqIE5FR0xJR0VOQ0UgT1IgT1RIRVJXSVNFKSBBUklTSU5HIElOIEFOWSBXQVkgT1VUIE9GIFRIRSBVU0UgT0YgVEhJU1xyXG4gKiBTT0ZUV0FSRSwgRVZFTiBJRiBBRFZJU0VEIE9GIFRIRSBQT1NTSUJJTElUWSBPRiBTVUNIIERBTUFHRS5cclxuICovXHJcblxyXG51c2luZyBTeXN0ZW07XHJcbnVzaW5nIFN5c3RlbS5Db2xsZWN0aW9ucztcclxudXNpbmcgU3lzdGVtLkNvbGxlY3Rpb25zLkdlbmVyaWM7XHJcblxyXG5uYW1lc3BhY2UgUG9seTJUcmkuVHJpYW5ndWxhdGlvbi5VdGlsXHJcbntcclxuICAgIHB1YmxpYyBzdHJ1Y3QgRml4ZWRBcnJheTM8VD4gOiBJRW51bWVyYWJsZTxUPiB3aGVyZSBUIDogY2xhc3NcclxuICAgIHtcclxuICAgICAgICBwdWJsaWMgVCBfMCwgXzEsIF8yO1xyXG5cclxuICAgICAgICBwdWJsaWMgVCB0aGlzW2ludCBpbmRleF1cclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGdldFxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKGluZGV4KVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF8wO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF8xO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMjpcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF8yO1xyXG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBJbmRleE91dE9mUmFuZ2VFeGNlcHRpb24oKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBzZXRcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgc3dpdGNoIChpbmRleClcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF8wID0gdmFsdWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcclxuICAgICAgICAgICAgICAgICAgICAgICAgXzEgPSB2YWx1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAyOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBfMiA9IHZhbHVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgSW5kZXhPdXRPZlJhbmdlRXhjZXB0aW9uKCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgICNyZWdpb24gSUVudW1lcmFibGU8VD4gTWVtYmVyc1xyXG5cclxuICAgICAgICBwdWJsaWMgSUVudW1lcmF0b3I8VD4gR2V0RW51bWVyYXRvcigpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gRW51bWVyYXRlKCkuR2V0RW51bWVyYXRvcigpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgSUVudW1lcmF0b3IgSUVudW1lcmFibGUuR2V0RW51bWVyYXRvcigpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gR2V0RW51bWVyYXRvcigpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgI2VuZHJlZ2lvblxyXG5cclxuICAgICAgICBwdWJsaWMgYm9vbCBDb250YWlucyhUIHZhbHVlKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgZm9yIChpbnQgaSA9IDA7IGkgPCAzOyArK2kpIGlmICh0aGlzW2ldID09IHZhbHVlKSByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHVibGljIGludCBJbmRleE9mKFQgdmFsdWUpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBmb3IgKGludCBpID0gMDsgaSA8IDM7ICsraSkgaWYgKHRoaXNbaV0gPT0gdmFsdWUpIHJldHVybiBpO1xyXG4gICAgICAgICAgICByZXR1cm4gLTE7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwdWJsaWMgdm9pZCBDbGVhcigpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBfMCA9IF8xID0gXzIgPSBudWxsO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHVibGljIHZvaWQgQ2xlYXIoVCB2YWx1ZSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGZvciAoaW50IGkgPSAwOyBpIDwgMzsgKytpKSBpZiAodGhpc1tpXSA9PSB2YWx1ZSkgdGhpc1tpXSA9IG51bGw7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwcml2YXRlIElFbnVtZXJhYmxlPFQ+IEVudW1lcmF0ZSgpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBmb3IgKGludCBpID0gMDsgaSA8IDM7ICsraSkgeWllbGQgcmV0dXJuIHRoaXNbaV07XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59IiwiLyogUG9seTJUcmlcclxuICogQ29weXJpZ2h0IChjKSAyMDA5LTIwMTAsIFBvbHkyVHJpIENvbnRyaWJ1dG9yc1xyXG4gKiBodHRwOi8vY29kZS5nb29nbGUuY29tL3AvcG9seTJ0cmkvXHJcbiAqXHJcbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqXHJcbiAqIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGggb3Igd2l0aG91dCBtb2RpZmljYXRpb24sXHJcbiAqIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnMgYXJlIG1ldDpcclxuICpcclxuICogKiBSZWRpc3RyaWJ1dGlvbnMgb2Ygc291cmNlIGNvZGUgbXVzdCByZXRhaW4gdGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UsXHJcbiAqICAgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lci5cclxuICogKiBSZWRpc3RyaWJ1dGlvbnMgaW4gYmluYXJ5IGZvcm0gbXVzdCByZXByb2R1Y2UgdGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UsXHJcbiAqICAgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lciBpbiB0aGUgZG9jdW1lbnRhdGlvblxyXG4gKiAgIGFuZC9vciBvdGhlciBtYXRlcmlhbHMgcHJvdmlkZWQgd2l0aCB0aGUgZGlzdHJpYnV0aW9uLlxyXG4gKiAqIE5laXRoZXIgdGhlIG5hbWUgb2YgUG9seTJUcmkgbm9yIHRoZSBuYW1lcyBvZiBpdHMgY29udHJpYnV0b3JzIG1heSBiZVxyXG4gKiAgIHVzZWQgdG8gZW5kb3JzZSBvciBwcm9tb3RlIHByb2R1Y3RzIGRlcml2ZWQgZnJvbSB0aGlzIHNvZnR3YXJlIHdpdGhvdXQgc3BlY2lmaWNcclxuICogICBwcmlvciB3cml0dGVuIHBlcm1pc3Npb24uXHJcbiAqXHJcbiAqIFRISVMgU09GVFdBUkUgSVMgUFJPVklERUQgQlkgVEhFIENPUFlSSUdIVCBIT0xERVJTIEFORCBDT05UUklCVVRPUlNcclxuICogXCJBUyBJU1wiIEFORCBBTlkgRVhQUkVTUyBPUiBJTVBMSUVEIFdBUlJBTlRJRVMsIElOQ0xVRElORywgQlVUIE5PVFxyXG4gKiBMSU1JVEVEIFRPLCBUSEUgSU1QTElFRCBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSBBTkQgRklUTkVTUyBGT1JcclxuICogQSBQQVJUSUNVTEFSIFBVUlBPU0UgQVJFIERJU0NMQUlNRUQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBDT1BZUklHSFQgT1dORVIgT1JcclxuICogQ09OVFJJQlVUT1JTIEJFIExJQUJMRSBGT1IgQU5ZIERJUkVDVCwgSU5ESVJFQ1QsIElOQ0lERU5UQUwsIFNQRUNJQUwsXHJcbiAqIEVYRU1QTEFSWSwgT1IgQ09OU0VRVUVOVElBTCBEQU1BR0VTIChJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRCBUTyxcclxuICogUFJPQ1VSRU1FTlQgT0YgU1VCU1RJVFVURSBHT09EUyBPUiBTRVJWSUNFUzsgTE9TUyBPRiBVU0UsIERBVEEsIE9SXHJcbiAqIFBST0ZJVFM7IE9SIEJVU0lORVNTIElOVEVSUlVQVElPTikgSE9XRVZFUiBDQVVTRUQgQU5EIE9OIEFOWSBUSEVPUlkgT0ZcclxuICogTElBQklMSVRZLCBXSEVUSEVSIElOIENPTlRSQUNULCBTVFJJQ1QgTElBQklMSVRZLCBPUiBUT1JUIChJTkNMVURJTkdcclxuICogTkVHTElHRU5DRSBPUiBPVEhFUldJU0UpIEFSSVNJTkcgSU4gQU5ZIFdBWSBPVVQgT0YgVEhFIFVTRSBPRiBUSElTXHJcbiAqIFNPRlRXQVJFLCBFVkVOIElGIEFEVklTRUQgT0YgVEhFIFBPU1NJQklMSVRZIE9GIFNVQ0ggREFNQUdFLlxyXG4gKi9cclxuXHJcbnVzaW5nIFN5c3RlbTtcclxudXNpbmcgU3lzdGVtLkNvbGxlY3Rpb25zO1xyXG51c2luZyBTeXN0ZW0uQ29sbGVjdGlvbnMuR2VuZXJpYztcclxuXHJcbm5hbWVzcGFjZSBQb2x5MlRyaS5Ucmlhbmd1bGF0aW9uLlV0aWxcclxue1xyXG4gICAgcHVibGljIHN0cnVjdCBGaXhlZEJpdEFycmF5MyA6IElFbnVtZXJhYmxlPGJvb2w+XHJcbiAgICB7XHJcbiAgICAgICAgcHVibGljIGJvb2wgXzAsIF8xLCBfMjtcclxuXHJcbiAgICAgICAgcHVibGljIGJvb2wgdGhpc1tpbnQgaW5kZXhdXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBnZXRcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgc3dpdGNoIChpbmRleClcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfMDtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfMTtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDI6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfMjtcclxuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgSW5kZXhPdXRPZlJhbmdlRXhjZXB0aW9uKCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgc2V0XHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHN3aXRjaCAoaW5kZXgpXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBfMCA9IHZhbHVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF8xID0gdmFsdWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMjpcclxuICAgICAgICAgICAgICAgICAgICAgICAgXzIgPSB2YWx1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEluZGV4T3V0T2ZSYW5nZUV4Y2VwdGlvbigpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAjcmVnaW9uIElFbnVtZXJhYmxlPGJvb2w+IE1lbWJlcnNcclxuXHJcbiAgICAgICAgcHVibGljIElFbnVtZXJhdG9yPGJvb2w+IEdldEVudW1lcmF0b3IoKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIEVudW1lcmF0ZSgpLkdldEVudW1lcmF0b3IoKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIElFbnVtZXJhdG9yIElFbnVtZXJhYmxlLkdldEVudW1lcmF0b3IoKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIEdldEVudW1lcmF0b3IoKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgICNlbmRyZWdpb25cclxuXHJcbiAgICAgICAgcHVibGljIGJvb2wgQ29udGFpbnMoYm9vbCB2YWx1ZSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGZvciAoaW50IGkgPSAwOyBpIDwgMzsgKytpKSBpZiAodGhpc1tpXSA9PSB2YWx1ZSkgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHB1YmxpYyBpbnQgSW5kZXhPZihib29sIHZhbHVlKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgZm9yIChpbnQgaSA9IDA7IGkgPCAzOyArK2kpIGlmICh0aGlzW2ldID09IHZhbHVlKSByZXR1cm4gaTtcclxuICAgICAgICAgICAgcmV0dXJuIC0xO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHVibGljIHZvaWQgQ2xlYXIoKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgXzAgPSBfMSA9IF8yID0gZmFsc2U7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwdWJsaWMgdm9pZCBDbGVhcihib29sIHZhbHVlKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgZm9yIChpbnQgaSA9IDA7IGkgPCAzOyArK2kpIGlmICh0aGlzW2ldID09IHZhbHVlKSB0aGlzW2ldID0gZmFsc2U7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwcml2YXRlIElFbnVtZXJhYmxlPGJvb2w+IEVudW1lcmF0ZSgpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBmb3IgKGludCBpID0gMDsgaSA8IDM7ICsraSkgeWllbGQgcmV0dXJuIHRoaXNbaV07XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59IiwidXNpbmcgU3lzdGVtO1xyXG51c2luZyBTeXN0ZW0uQ29sbGVjdGlvbnMuR2VuZXJpYztcclxuXHJcbm5hbWVzcGFjZSBQb2x5MlRyaS5Ucmlhbmd1bGF0aW9uLlV0aWxcclxue1xyXG4gICAgcHVibGljIGNsYXNzIFBvaW50R2VuZXJhdG9yXHJcbiAgICB7XHJcbiAgICAgICAgcHJpdmF0ZSBzdGF0aWMgcmVhZG9ubHkgUmFuZG9tIFJORyA9IG5ldyBSYW5kb20oKTtcclxuXHJcbiAgICAgICAgcHVibGljIHN0YXRpYyBMaXN0PFRyaWFuZ3VsYXRpb25Qb2ludD4gVW5pZm9ybURpc3RyaWJ1dGlvbihpbnQgbiwgZG91YmxlIHNjYWxlKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgTGlzdDxUcmlhbmd1bGF0aW9uUG9pbnQ+IHBvaW50cyA9IG5ldyBMaXN0PFRyaWFuZ3VsYXRpb25Qb2ludD4oKTtcclxuICAgICAgICAgICAgZm9yIChpbnQgaSA9IDA7IGkgPCBuOyBpKyspXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHBvaW50cy5BZGQobmV3IFRyaWFuZ3VsYXRpb25Qb2ludChzY2FsZSooMC41IC0gUk5HLk5leHREb3VibGUoKSksIHNjYWxlKigwLjUgLSBSTkcuTmV4dERvdWJsZSgpKSkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBwb2ludHM7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwdWJsaWMgc3RhdGljIExpc3Q8VHJpYW5ndWxhdGlvblBvaW50PiBVbmlmb3JtR3JpZChpbnQgbiwgZG91YmxlIHNjYWxlKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgZG91YmxlIHggPSAwO1xyXG4gICAgICAgICAgICBkb3VibGUgc2l6ZSA9IHNjYWxlL247XHJcbiAgICAgICAgICAgIGRvdWJsZSBoYWxmU2NhbGUgPSAwLjUqc2NhbGU7XHJcblxyXG4gICAgICAgICAgICBMaXN0PFRyaWFuZ3VsYXRpb25Qb2ludD4gcG9pbnRzID0gbmV3IExpc3Q8VHJpYW5ndWxhdGlvblBvaW50PigpO1xyXG4gICAgICAgICAgICBmb3IgKGludCBpID0gMDsgaSA8IG4gKyAxOyBpKyspXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHggPSBoYWxmU2NhbGUgLSBpKnNpemU7XHJcbiAgICAgICAgICAgICAgICBmb3IgKGludCBqID0gMDsgaiA8IG4gKyAxOyBqKyspXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgcG9pbnRzLkFkZChuZXcgVHJpYW5ndWxhdGlvblBvaW50KHgsIGhhbGZTY2FsZSAtIGoqc2l6ZSkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBwb2ludHM7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59IiwiLyogUG9seTJUcmlcclxuICogQ29weXJpZ2h0IChjKSAyMDA5LTIwMTAsIFBvbHkyVHJpIENvbnRyaWJ1dG9yc1xyXG4gKiBodHRwOi8vY29kZS5nb29nbGUuY29tL3AvcG9seTJ0cmkvXHJcbiAqXHJcbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqXHJcbiAqIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGggb3Igd2l0aG91dCBtb2RpZmljYXRpb24sXHJcbiAqIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnMgYXJlIG1ldDpcclxuICpcclxuICogKiBSZWRpc3RyaWJ1dGlvbnMgb2Ygc291cmNlIGNvZGUgbXVzdCByZXRhaW4gdGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UsXHJcbiAqICAgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lci5cclxuICogKiBSZWRpc3RyaWJ1dGlvbnMgaW4gYmluYXJ5IGZvcm0gbXVzdCByZXByb2R1Y2UgdGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UsXHJcbiAqICAgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lciBpbiB0aGUgZG9jdW1lbnRhdGlvblxyXG4gKiAgIGFuZC9vciBvdGhlciBtYXRlcmlhbHMgcHJvdmlkZWQgd2l0aCB0aGUgZGlzdHJpYnV0aW9uLlxyXG4gKiAqIE5laXRoZXIgdGhlIG5hbWUgb2YgUG9seTJUcmkgbm9yIHRoZSBuYW1lcyBvZiBpdHMgY29udHJpYnV0b3JzIG1heSBiZVxyXG4gKiAgIHVzZWQgdG8gZW5kb3JzZSBvciBwcm9tb3RlIHByb2R1Y3RzIGRlcml2ZWQgZnJvbSB0aGlzIHNvZnR3YXJlIHdpdGhvdXQgc3BlY2lmaWNcclxuICogICBwcmlvciB3cml0dGVuIHBlcm1pc3Npb24uXHJcbiAqXHJcbiAqIFRISVMgU09GVFdBUkUgSVMgUFJPVklERUQgQlkgVEhFIENPUFlSSUdIVCBIT0xERVJTIEFORCBDT05UUklCVVRPUlNcclxuICogXCJBUyBJU1wiIEFORCBBTlkgRVhQUkVTUyBPUiBJTVBMSUVEIFdBUlJBTlRJRVMsIElOQ0xVRElORywgQlVUIE5PVFxyXG4gKiBMSU1JVEVEIFRPLCBUSEUgSU1QTElFRCBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSBBTkQgRklUTkVTUyBGT1JcclxuICogQSBQQVJUSUNVTEFSIFBVUlBPU0UgQVJFIERJU0NMQUlNRUQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBDT1BZUklHSFQgT1dORVIgT1JcclxuICogQ09OVFJJQlVUT1JTIEJFIExJQUJMRSBGT1IgQU5ZIERJUkVDVCwgSU5ESVJFQ1QsIElOQ0lERU5UQUwsIFNQRUNJQUwsXHJcbiAqIEVYRU1QTEFSWSwgT1IgQ09OU0VRVUVOVElBTCBEQU1BR0VTIChJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRCBUTyxcclxuICogUFJPQ1VSRU1FTlQgT0YgU1VCU1RJVFVURSBHT09EUyBPUiBTRVJWSUNFUzsgTE9TUyBPRiBVU0UsIERBVEEsIE9SXHJcbiAqIFBST0ZJVFM7IE9SIEJVU0lORVNTIElOVEVSUlVQVElPTikgSE9XRVZFUiBDQVVTRUQgQU5EIE9OIEFOWSBUSEVPUlkgT0ZcclxuICogTElBQklMSVRZLCBXSEVUSEVSIElOIENPTlRSQUNULCBTVFJJQ1QgTElBQklMSVRZLCBPUiBUT1JUIChJTkNMVURJTkdcclxuICogTkVHTElHRU5DRSBPUiBPVEhFUldJU0UpIEFSSVNJTkcgSU4gQU5ZIFdBWSBPVVQgT0YgVEhFIFVTRSBPRiBUSElTXHJcbiAqIFNPRlRXQVJFLCBFVkVOIElGIEFEVklTRUQgT0YgVEhFIFBPU1NJQklMSVRZIE9GIFNVQ0ggREFNQUdFLlxyXG4gKi9cclxuXHJcbnVzaW5nIFN5c3RlbTtcclxudXNpbmcgUG9seTJUcmkuVHJpYW5ndWxhdGlvbi5Qb2x5Z29uO1xyXG5cclxubmFtZXNwYWNlIFBvbHkyVHJpLlRyaWFuZ3VsYXRpb24uVXRpbFxyXG57XHJcbiAgICBwdWJsaWMgY2xhc3MgUG9seWdvbkdlbmVyYXRvclxyXG4gICAge1xyXG4gICAgICAgIHByaXZhdGUgc3RhdGljIHJlYWRvbmx5IFJhbmRvbSBSTkcgPSBuZXcgUmFuZG9tKCk7XHJcblxyXG4gICAgICAgIHByaXZhdGUgc3RhdGljIGRvdWJsZSBQSV8yID0gMi4wKk1hdGguUEk7XHJcblxyXG4gICAgICAgIHB1YmxpYyBzdGF0aWMgUG9seWdvbi5Qb2x5Z29uIFJhbmRvbUNpcmNsZVN3ZWVwKGRvdWJsZSBzY2FsZSwgaW50IHZlcnRleENvdW50KVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgUG9seWdvblBvaW50IHBvaW50O1xyXG4gICAgICAgICAgICBQb2x5Z29uUG9pbnRbXSBwb2ludHM7XHJcbiAgICAgICAgICAgIGRvdWJsZSByYWRpdXMgPSBzY2FsZS80O1xyXG5cclxuICAgICAgICAgICAgcG9pbnRzID0gbmV3IFBvbHlnb25Qb2ludFt2ZXJ0ZXhDb3VudF07XHJcbiAgICAgICAgICAgIGZvciAoaW50IGkgPSAwOyBpIDwgdmVydGV4Q291bnQ7IGkrKylcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgZG9cclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoaSUyNTAgPT0gMClcclxuICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJhZGl1cyArPSBzY2FsZS8yKigwLjUgLSBSTkcuTmV4dERvdWJsZSgpKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoaSU1MCA9PSAwKVxyXG4gICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmFkaXVzICs9IHNjYWxlLzUqKDAuNSAtIFJORy5OZXh0RG91YmxlKCkpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByYWRpdXMgKz0gMjUqc2NhbGUvdmVydGV4Q291bnQqKDAuNSAtIFJORy5OZXh0RG91YmxlKCkpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICByYWRpdXMgPSByYWRpdXMgPiBzY2FsZS8yID8gc2NhbGUvMiA6IHJhZGl1cztcclxuICAgICAgICAgICAgICAgICAgICByYWRpdXMgPSByYWRpdXMgPCBzY2FsZS8xMCA/IHNjYWxlLzEwIDogcmFkaXVzO1xyXG4gICAgICAgICAgICAgICAgfSB3aGlsZSAocmFkaXVzIDwgc2NhbGUvMTAgfHwgcmFkaXVzID4gc2NhbGUvMik7XHJcbiAgICAgICAgICAgICAgICBwb2ludCA9IG5ldyBQb2x5Z29uUG9pbnQocmFkaXVzKk1hdGguQ29zKChQSV8yKmkpL3ZlcnRleENvdW50KSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByYWRpdXMqTWF0aC5TaW4oKFBJXzIqaSkvdmVydGV4Q291bnQpKTtcclxuICAgICAgICAgICAgICAgIHBvaW50c1tpXSA9IHBvaW50O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgUG9seWdvbi5Qb2x5Z29uKHBvaW50cyk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwdWJsaWMgc3RhdGljIFBvbHlnb24uUG9seWdvbiBSYW5kb21DaXJjbGVTd2VlcDIoZG91YmxlIHNjYWxlLCBpbnQgdmVydGV4Q291bnQpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBQb2x5Z29uUG9pbnQgcG9pbnQ7XHJcbiAgICAgICAgICAgIFBvbHlnb25Qb2ludFtdIHBvaW50cztcclxuICAgICAgICAgICAgZG91YmxlIHJhZGl1cyA9IHNjYWxlLzQ7XHJcblxyXG4gICAgICAgICAgICBwb2ludHMgPSBuZXcgUG9seWdvblBvaW50W3ZlcnRleENvdW50XTtcclxuICAgICAgICAgICAgZm9yIChpbnQgaSA9IDA7IGkgPCB2ZXJ0ZXhDb3VudDsgaSsrKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBkb1xyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIHJhZGl1cyArPSBzY2FsZS81KigwLjUgLSBSTkcuTmV4dERvdWJsZSgpKTtcclxuICAgICAgICAgICAgICAgICAgICByYWRpdXMgPSByYWRpdXMgPiBzY2FsZS8yID8gc2NhbGUvMiA6IHJhZGl1cztcclxuICAgICAgICAgICAgICAgICAgICByYWRpdXMgPSByYWRpdXMgPCBzY2FsZS8xMCA/IHNjYWxlLzEwIDogcmFkaXVzO1xyXG4gICAgICAgICAgICAgICAgfSB3aGlsZSAocmFkaXVzIDwgc2NhbGUvMTAgfHwgcmFkaXVzID4gc2NhbGUvMik7XHJcbiAgICAgICAgICAgICAgICBwb2ludCA9IG5ldyBQb2x5Z29uUG9pbnQocmFkaXVzKk1hdGguQ29zKChQSV8yKmkpL3ZlcnRleENvdW50KSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByYWRpdXMqTWF0aC5TaW4oKFBJXzIqaSkvdmVydGV4Q291bnQpKTtcclxuICAgICAgICAgICAgICAgIHBvaW50c1tpXSA9IHBvaW50O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgUG9seWdvbi5Qb2x5Z29uKHBvaW50cyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59IiwiLypcclxuKiBGYXJzZWVyIFBoeXNpY3MgRW5naW5lIGJhc2VkIG9uIEJveDJELlhOQSBwb3J0OlxyXG4qIENvcHlyaWdodCAoYykgMjAxMCBJYW4gUXZpc3RcclxuKiBcclxuKiBCb3gyRC5YTkEgcG9ydCBvZiBCb3gyRDpcclxuKiBDb3B5cmlnaHQgKGMpIDIwMDkgQnJhbmRvbiBGdXJ0d2FuZ2xlciwgTmF0aGFuIEZ1cnR3YW5nbGVyXHJcbipcclxuKiBPcmlnaW5hbCBzb3VyY2UgQm94MkQ6XHJcbiogQ29weXJpZ2h0IChjKSAyMDA2LTIwMDkgRXJpbiBDYXR0byBodHRwOi8vd3d3LmdwaHlzaWNzLmNvbSBcclxuKiBcclxuKiBUaGlzIHNvZnR3YXJlIGlzIHByb3ZpZGVkICdhcy1pcycsIHdpdGhvdXQgYW55IGV4cHJlc3Mgb3IgaW1wbGllZCBcclxuKiB3YXJyYW50eS4gIEluIG5vIGV2ZW50IHdpbGwgdGhlIGF1dGhvcnMgYmUgaGVsZCBsaWFibGUgZm9yIGFueSBkYW1hZ2VzIFxyXG4qIGFyaXNpbmcgZnJvbSB0aGUgdXNlIG9mIHRoaXMgc29mdHdhcmUuIFxyXG4qIFBlcm1pc3Npb24gaXMgZ3JhbnRlZCB0byBhbnlvbmUgdG8gdXNlIHRoaXMgc29mdHdhcmUgZm9yIGFueSBwdXJwb3NlLCBcclxuKiBpbmNsdWRpbmcgY29tbWVyY2lhbCBhcHBsaWNhdGlvbnMsIGFuZCB0byBhbHRlciBpdCBhbmQgcmVkaXN0cmlidXRlIGl0IFxyXG4qIGZyZWVseSwgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIHJlc3RyaWN0aW9uczogXHJcbiogMS4gVGhlIG9yaWdpbiBvZiB0aGlzIHNvZnR3YXJlIG11c3Qgbm90IGJlIG1pc3JlcHJlc2VudGVkOyB5b3UgbXVzdCBub3QgXHJcbiogY2xhaW0gdGhhdCB5b3Ugd3JvdGUgdGhlIG9yaWdpbmFsIHNvZnR3YXJlLiBJZiB5b3UgdXNlIHRoaXMgc29mdHdhcmUgXHJcbiogaW4gYSBwcm9kdWN0LCBhbiBhY2tub3dsZWRnbWVudCBpbiB0aGUgcHJvZHVjdCBkb2N1bWVudGF0aW9uIHdvdWxkIGJlIFxyXG4qIGFwcHJlY2lhdGVkIGJ1dCBpcyBub3QgcmVxdWlyZWQuIFxyXG4qIDIuIEFsdGVyZWQgc291cmNlIHZlcnNpb25zIG11c3QgYmUgcGxhaW5seSBtYXJrZWQgYXMgc3VjaCwgYW5kIG11c3Qgbm90IGJlIFxyXG4qIG1pc3JlcHJlc2VudGVkIGFzIGJlaW5nIHRoZSBvcmlnaW5hbCBzb2Z0d2FyZS4gXHJcbiogMy4gVGhpcyBub3RpY2UgbWF5IG5vdCBiZSByZW1vdmVkIG9yIGFsdGVyZWQgZnJvbSBhbnkgc291cmNlIGRpc3RyaWJ1dGlvbi4gXHJcbiovXHJcblxyXG51c2luZyBTeXN0ZW07XHJcbnVzaW5nIEZhcnNlZXJQaHlzaWNzLkNvbW1vbjtcclxudXNpbmcgTWljcm9zb2Z0LlhuYS5GcmFtZXdvcms7XHJcblxyXG5uYW1lc3BhY2UgRmFyc2VlclBoeXNpY3MuQ29sbGlzaW9uLlNoYXBlc1xyXG57XHJcbiAgICBwdWJsaWMgY2xhc3MgQ2lyY2xlU2hhcGUgOiBTaGFwZVxyXG4gICAge1xyXG4gICAgICAgIGludGVybmFsIFZlY3RvcjIgX3Bvc2l0aW9uO1xyXG5cclxuICAgICAgICBwdWJsaWMgQ2lyY2xlU2hhcGUoZmxvYXQgcmFkaXVzLCBmbG9hdCBkZW5zaXR5KVxyXG4gICAgICAgICAgICA6IGJhc2UoZGVuc2l0eSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIFNoYXBlVHlwZSA9IFNoYXBlVHlwZS5DaXJjbGU7XHJcbiAgICAgICAgICAgIF9yYWRpdXMgPSByYWRpdXM7XHJcbiAgICAgICAgICAgIF9wb3NpdGlvbiA9IFZlY3RvcjIuWmVybztcclxuICAgICAgICAgICAgQ29tcHV0ZVByb3BlcnRpZXMoKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGludGVybmFsIENpcmNsZVNoYXBlKClcclxuICAgICAgICAgICAgOiBiYXNlKDApXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBTaGFwZVR5cGUgPSBTaGFwZVR5cGUuQ2lyY2xlO1xyXG4gICAgICAgICAgICBfcmFkaXVzID0gMC4wZjtcclxuICAgICAgICAgICAgX3Bvc2l0aW9uID0gVmVjdG9yMi5aZXJvO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHVibGljIG92ZXJyaWRlIGludCBDaGlsZENvdW50XHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBnZXQgeyByZXR1cm4gMTsgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHVibGljIFZlY3RvcjIgUG9zaXRpb25cclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGdldCB7IHJldHVybiBfcG9zaXRpb247IH1cclxuICAgICAgICAgICAgc2V0XHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIF9wb3NpdGlvbiA9IHZhbHVlO1xyXG4gICAgICAgICAgICAgICAgQ29tcHV0ZVByb3BlcnRpZXMoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHVibGljIG92ZXJyaWRlIFNoYXBlIENsb25lKClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIENpcmNsZVNoYXBlIHNoYXBlID0gbmV3IENpcmNsZVNoYXBlKCk7XHJcbiAgICAgICAgICAgIHNoYXBlLl9yYWRpdXMgPSBSYWRpdXM7XHJcbiAgICAgICAgICAgIHNoYXBlLl9kZW5zaXR5ID0gX2RlbnNpdHk7XHJcbiAgICAgICAgICAgIHNoYXBlLl9wb3NpdGlvbiA9IF9wb3NpdGlvbjtcclxuICAgICAgICAgICAgc2hhcGUuU2hhcGVUeXBlID0gU2hhcGVUeXBlO1xyXG4gICAgICAgICAgICBzaGFwZS5NYXNzRGF0YSA9IE1hc3NEYXRhO1xyXG4gICAgICAgICAgICByZXR1cm4gc2hhcGU7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIFRlc3QgYSBwb2ludCBmb3IgY29udGFpbm1lbnQgaW4gdGhpcyBzaGFwZS4gVGhpcyBvbmx5IHdvcmtzIGZvciBjb252ZXggc2hhcGVzLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwidHJhbnNmb3JtXCI+VGhlIHNoYXBlIHdvcmxkIHRyYW5zZm9ybS48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cInBvaW50XCI+YSBwb2ludCBpbiB3b3JsZCBjb29yZGluYXRlcy48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cmV0dXJucz5UcnVlIGlmIHRoZSBwb2ludCBpcyBpbnNpZGUgdGhlIHNoYXBlPC9yZXR1cm5zPlxyXG4gICAgICAgIHB1YmxpYyBvdmVycmlkZSBib29sIFRlc3RQb2ludChyZWYgVHJhbnNmb3JtIHRyYW5zZm9ybSwgcmVmIFZlY3RvcjIgcG9pbnQpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBWZWN0b3IyIGNlbnRlciA9IHRyYW5zZm9ybS5Qb3NpdGlvbiArIE1hdGhVdGlscy5NdWx0aXBseShyZWYgdHJhbnNmb3JtLlIsIFBvc2l0aW9uKTtcclxuICAgICAgICAgICAgVmVjdG9yMiBkID0gcG9pbnQgLSBjZW50ZXI7XHJcbiAgICAgICAgICAgIHJldHVybiBWZWN0b3IyLkRvdChkLCBkKSA8PSBSYWRpdXMgKiBSYWRpdXM7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIENhc3QgYSByYXkgYWdhaW5zdCBhIGNoaWxkIHNoYXBlLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwib3V0cHV0XCI+VGhlIHJheS1jYXN0IHJlc3VsdHMuPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJpbnB1dFwiPlRoZSByYXktY2FzdCBpbnB1dCBwYXJhbWV0ZXJzLjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwidHJhbnNmb3JtXCI+VGhlIHRyYW5zZm9ybSB0byBiZSBhcHBsaWVkIHRvIHRoZSBzaGFwZS48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cImNoaWxkSW5kZXhcIj5UaGUgY2hpbGQgc2hhcGUgaW5kZXguPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHJldHVybnM+VHJ1ZSBpZiB0aGUgcmF5LWNhc3QgaGl0cyB0aGUgc2hhcGU8L3JldHVybnM+XHJcbiAgICAgICAgcHVibGljIG92ZXJyaWRlIGJvb2wgUmF5Q2FzdChvdXQgUmF5Q2FzdE91dHB1dCBvdXRwdXQsIHJlZiBSYXlDYXN0SW5wdXQgaW5wdXQsIHJlZiBUcmFuc2Zvcm0gdHJhbnNmb3JtLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW50IGNoaWxkSW5kZXgpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICAvLyBDb2xsaXNpb24gRGV0ZWN0aW9uIGluIEludGVyYWN0aXZlIDNEIEVudmlyb25tZW50cyBieSBHaW5vIHZhbiBkZW4gQmVyZ2VuXHJcbiAgICAgICAgICAgIC8vIEZyb20gU2VjdGlvbiAzLjEuMlxyXG4gICAgICAgICAgICAvLyB4ID0gcyArIGEgKiByXHJcbiAgICAgICAgICAgIC8vIG5vcm0oeCkgPSByYWRpdXNcclxuXHJcbiAgICAgICAgICAgIG91dHB1dCA9IG5ldyBSYXlDYXN0T3V0cHV0KCk7XHJcblxyXG4gICAgICAgICAgICBWZWN0b3IyIHBvc2l0aW9uID0gdHJhbnNmb3JtLlBvc2l0aW9uICsgTWF0aFV0aWxzLk11bHRpcGx5KHJlZiB0cmFuc2Zvcm0uUiwgUG9zaXRpb24pO1xyXG4gICAgICAgICAgICBWZWN0b3IyIHMgPSBpbnB1dC5Qb2ludDEgLSBwb3NpdGlvbjtcclxuICAgICAgICAgICAgZmxvYXQgYiA9IFZlY3RvcjIuRG90KHMsIHMpIC0gUmFkaXVzICogUmFkaXVzO1xyXG5cclxuICAgICAgICAgICAgLy8gU29sdmUgcXVhZHJhdGljIGVxdWF0aW9uLlxyXG4gICAgICAgICAgICBWZWN0b3IyIHIgPSBpbnB1dC5Qb2ludDIgLSBpbnB1dC5Qb2ludDE7XHJcbiAgICAgICAgICAgIGZsb2F0IGMgPSBWZWN0b3IyLkRvdChzLCByKTtcclxuICAgICAgICAgICAgZmxvYXQgcnIgPSBWZWN0b3IyLkRvdChyLCByKTtcclxuICAgICAgICAgICAgZmxvYXQgc2lnbWEgPSBjICogYyAtIHJyICogYjtcclxuXHJcbiAgICAgICAgICAgIC8vIENoZWNrIGZvciBuZWdhdGl2ZSBkaXNjcmltaW5hbnQgYW5kIHNob3J0IHNlZ21lbnQuXHJcbiAgICAgICAgICAgIGlmIChzaWdtYSA8IDAuMGYgfHwgcnIgPCBTZXR0aW5ncy5FcHNpbG9uKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIEZpbmQgdGhlIHBvaW50IG9mIGludGVyc2VjdGlvbiBvZiB0aGUgbGluZSB3aXRoIHRoZSBjaXJjbGUuXHJcbiAgICAgICAgICAgIGZsb2F0IGEgPSAtKGMgKyAoZmxvYXQpTWF0aC5TcXJ0KHNpZ21hKSk7XHJcblxyXG4gICAgICAgICAgICAvLyBJcyB0aGUgaW50ZXJzZWN0aW9uIHBvaW50IG9uIHRoZSBzZWdtZW50P1xyXG4gICAgICAgICAgICBpZiAoMC4wZiA8PSBhICYmIGEgPD0gaW5wdXQuTWF4RnJhY3Rpb24gKiBycilcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgYSAvPSBycjtcclxuICAgICAgICAgICAgICAgIG91dHB1dC5GcmFjdGlvbiA9IGE7XHJcbiAgICAgICAgICAgICAgICBWZWN0b3IyIG5vcm0gPSAocyArIGEgKiByKTtcclxuICAgICAgICAgICAgICAgIG5vcm0uTm9ybWFsaXplKCk7XHJcbiAgICAgICAgICAgICAgICBvdXRwdXQuTm9ybWFsID0gbm9ybTtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIEdpdmVuIGEgdHJhbnNmb3JtLCBjb21wdXRlIHRoZSBhc3NvY2lhdGVkIGF4aXMgYWxpZ25lZCBib3VuZGluZyBib3ggZm9yIGEgY2hpbGQgc2hhcGUuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJhYWJiXCI+VGhlIGFhYmIgcmVzdWx0cy48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cInRyYW5zZm9ybVwiPlRoZSB3b3JsZCB0cmFuc2Zvcm0gb2YgdGhlIHNoYXBlLjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwiY2hpbGRJbmRleFwiPlRoZSBjaGlsZCBzaGFwZSBpbmRleC48L3BhcmFtPlxyXG4gICAgICAgIHB1YmxpYyBvdmVycmlkZSB2b2lkIENvbXB1dGVBQUJCKG91dCBBQUJCIGFhYmIsIHJlZiBUcmFuc2Zvcm0gdHJhbnNmb3JtLCBpbnQgY2hpbGRJbmRleClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIFZlY3RvcjIgcCA9IHRyYW5zZm9ybS5Qb3NpdGlvbiArIE1hdGhVdGlscy5NdWx0aXBseShyZWYgdHJhbnNmb3JtLlIsIFBvc2l0aW9uKTtcclxuICAgICAgICAgICAgYWFiYi5Mb3dlckJvdW5kID0gbmV3IFZlY3RvcjIocC5YIC0gUmFkaXVzLCBwLlkgLSBSYWRpdXMpO1xyXG4gICAgICAgICAgICBhYWJiLlVwcGVyQm91bmQgPSBuZXcgVmVjdG9yMihwLlggKyBSYWRpdXMsIHAuWSArIFJhZGl1cyk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIENvbXB1dGUgdGhlIG1hc3MgcHJvcGVydGllcyBvZiB0aGlzIHNoYXBlIHVzaW5nIGl0cyBkaW1lbnNpb25zIGFuZCBkZW5zaXR5LlxyXG4gICAgICAgIC8vLyBUaGUgaW5lcnRpYSB0ZW5zb3IgaXMgY29tcHV0ZWQgYWJvdXQgdGhlIGxvY2FsIG9yaWdpbiwgbm90IHRoZSBjZW50cm9pZC5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIHB1YmxpYyBvdmVycmlkZSBzZWFsZWQgdm9pZCBDb21wdXRlUHJvcGVydGllcygpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBmbG9hdCBhcmVhID0gU2V0dGluZ3MuUGkgKiBSYWRpdXMgKiBSYWRpdXM7XHJcbiAgICAgICAgICAgIE1hc3NEYXRhLkFyZWEgPSBhcmVhO1xyXG4gICAgICAgICAgICBNYXNzRGF0YS5NYXNzID0gRGVuc2l0eSAqIGFyZWE7XHJcbiAgICAgICAgICAgIE1hc3NEYXRhLkNlbnRyb2lkID0gUG9zaXRpb247XHJcblxyXG4gICAgICAgICAgICAvLyBpbmVydGlhIGFib3V0IHRoZSBsb2NhbCBvcmlnaW5cclxuICAgICAgICAgICAgTWFzc0RhdGEuSW5lcnRpYSA9IE1hc3NEYXRhLk1hc3MgKiAoMC41ZiAqIFJhZGl1cyAqIFJhZGl1cyArIFZlY3RvcjIuRG90KFBvc2l0aW9uLCBQb3NpdGlvbikpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHVibGljIGJvb2wgQ29tcGFyZVRvKENpcmNsZVNoYXBlIHNoYXBlKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIChSYWRpdXMgPT0gc2hhcGUuUmFkaXVzICYmXHJcbiAgICAgICAgICAgICAgICAgICAgUG9zaXRpb24gPT0gc2hhcGUuUG9zaXRpb24pO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHVibGljIG92ZXJyaWRlIGZsb2F0IENvbXB1dGVTdWJtZXJnZWRBcmVhKFZlY3RvcjIgbm9ybWFsLCBmbG9hdCBvZmZzZXQsIFRyYW5zZm9ybSB4Ziwgb3V0IFZlY3RvcjIgc2MpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBzYyA9IFZlY3RvcjIuWmVybztcclxuXHJcbiAgICAgICAgICAgIFZlY3RvcjIgcCA9IE1hdGhVdGlscy5NdWx0aXBseShyZWYgeGYsIFBvc2l0aW9uKTtcclxuICAgICAgICAgICAgZmxvYXQgbCA9IC0oVmVjdG9yMi5Eb3Qobm9ybWFsLCBwKSAtIG9mZnNldCk7XHJcbiAgICAgICAgICAgIGlmIChsIDwgLVJhZGl1cyArIFNldHRpbmdzLkVwc2lsb24pXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIC8vQ29tcGxldGVseSBkcnlcclxuICAgICAgICAgICAgICAgIHJldHVybiAwO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChsID4gUmFkaXVzKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAvL0NvbXBsZXRlbHkgd2V0XHJcbiAgICAgICAgICAgICAgICBzYyA9IHA7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gU2V0dGluZ3MuUGkgKiBSYWRpdXMgKiBSYWRpdXM7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vTWFnaWNcclxuICAgICAgICAgICAgZmxvYXQgcjIgPSBSYWRpdXMgKiBSYWRpdXM7XHJcbiAgICAgICAgICAgIGZsb2F0IGwyID0gbCAqIGw7XHJcbiAgICAgICAgICAgIGZsb2F0IGFyZWEgPSByMiAqIChmbG9hdCkoKE1hdGguQXNpbihsIC8gUmFkaXVzKSArIFNldHRpbmdzLlBpIC8gMikgKyBsICogTWF0aC5TcXJ0KHIyIC0gbDIpKTtcclxuICAgICAgICAgICAgZmxvYXQgY29tID0gLTIuMGYgLyAzLjBmICogKGZsb2F0KU1hdGguUG93KHIyIC0gbDIsIDEuNWYpIC8gYXJlYTtcclxuXHJcbiAgICAgICAgICAgIHNjLlggPSBwLlggKyBub3JtYWwuWCAqIGNvbTtcclxuICAgICAgICAgICAgc2MuWSA9IHAuWSArIG5vcm1hbC5ZICogY29tO1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIGFyZWE7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59IiwiLypcclxuKiBGYXJzZWVyIFBoeXNpY3MgRW5naW5lIGJhc2VkIG9uIEJveDJELlhOQSBwb3J0OlxyXG4qIENvcHlyaWdodCAoYykgMjAxMCBJYW4gUXZpc3RcclxuKiBcclxuKiBCb3gyRC5YTkEgcG9ydCBvZiBCb3gyRDpcclxuKiBDb3B5cmlnaHQgKGMpIDIwMDkgQnJhbmRvbiBGdXJ0d2FuZ2xlciwgTmF0aGFuIEZ1cnR3YW5nbGVyXHJcbipcclxuKiBPcmlnaW5hbCBzb3VyY2UgQm94MkQ6XHJcbiogQ29weXJpZ2h0IChjKSAyMDA2LTIwMDkgRXJpbiBDYXR0byBodHRwOi8vd3d3LmdwaHlzaWNzLmNvbSBcclxuKiBcclxuKiBUaGlzIHNvZnR3YXJlIGlzIHByb3ZpZGVkICdhcy1pcycsIHdpdGhvdXQgYW55IGV4cHJlc3Mgb3IgaW1wbGllZCBcclxuKiB3YXJyYW50eS4gIEluIG5vIGV2ZW50IHdpbGwgdGhlIGF1dGhvcnMgYmUgaGVsZCBsaWFibGUgZm9yIGFueSBkYW1hZ2VzIFxyXG4qIGFyaXNpbmcgZnJvbSB0aGUgdXNlIG9mIHRoaXMgc29mdHdhcmUuIFxyXG4qIFBlcm1pc3Npb24gaXMgZ3JhbnRlZCB0byBhbnlvbmUgdG8gdXNlIHRoaXMgc29mdHdhcmUgZm9yIGFueSBwdXJwb3NlLCBcclxuKiBpbmNsdWRpbmcgY29tbWVyY2lhbCBhcHBsaWNhdGlvbnMsIGFuZCB0byBhbHRlciBpdCBhbmQgcmVkaXN0cmlidXRlIGl0IFxyXG4qIGZyZWVseSwgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIHJlc3RyaWN0aW9uczogXHJcbiogMS4gVGhlIG9yaWdpbiBvZiB0aGlzIHNvZnR3YXJlIG11c3Qgbm90IGJlIG1pc3JlcHJlc2VudGVkOyB5b3UgbXVzdCBub3QgXHJcbiogY2xhaW0gdGhhdCB5b3Ugd3JvdGUgdGhlIG9yaWdpbmFsIHNvZnR3YXJlLiBJZiB5b3UgdXNlIHRoaXMgc29mdHdhcmUgXHJcbiogaW4gYSBwcm9kdWN0LCBhbiBhY2tub3dsZWRnbWVudCBpbiB0aGUgcHJvZHVjdCBkb2N1bWVudGF0aW9uIHdvdWxkIGJlIFxyXG4qIGFwcHJlY2lhdGVkIGJ1dCBpcyBub3QgcmVxdWlyZWQuIFxyXG4qIDIuIEFsdGVyZWQgc291cmNlIHZlcnNpb25zIG11c3QgYmUgcGxhaW5seSBtYXJrZWQgYXMgc3VjaCwgYW5kIG11c3Qgbm90IGJlIFxyXG4qIG1pc3JlcHJlc2VudGVkIGFzIGJlaW5nIHRoZSBvcmlnaW5hbCBzb2Z0d2FyZS4gXHJcbiogMy4gVGhpcyBub3RpY2UgbWF5IG5vdCBiZSByZW1vdmVkIG9yIGFsdGVyZWQgZnJvbSBhbnkgc291cmNlIGRpc3RyaWJ1dGlvbi4gXHJcbiovXHJcblxyXG51c2luZyBGYXJzZWVyUGh5c2ljcy5Db21tb247XHJcbnVzaW5nIE1pY3Jvc29mdC5YbmEuRnJhbWV3b3JrO1xyXG5cclxubmFtZXNwYWNlIEZhcnNlZXJQaHlzaWNzLkNvbGxpc2lvbi5TaGFwZXNcclxue1xyXG4gICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgLy8vIEEgbGluZSBzZWdtZW50IChlZGdlKSBTaGFwZS4gVGhlc2UgY2FuIGJlIGNvbm5lY3RlZCBpbiBjaGFpbnMgb3IgbG9vcHNcclxuICAgIC8vLyB0byBvdGhlciBlZGdlIFNoYXBlcy4gVGhlIGNvbm5lY3Rpdml0eSBpbmZvcm1hdGlvbiBpcyB1c2VkIHRvIGVuc3VyZVxyXG4gICAgLy8vIGNvcnJlY3QgY29udGFjdCBub3JtYWxzLlxyXG4gICAgLy8vIDwvc3VtbWFyeT5cclxuICAgIHB1YmxpYyBjbGFzcyBFZGdlU2hhcGUgOiBTaGFwZVxyXG4gICAge1xyXG4gICAgICAgIHB1YmxpYyBib29sIEhhc1ZlcnRleDAsIEhhc1ZlcnRleDM7XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gT3B0aW9uYWwgYWRqYWNlbnQgdmVydGljZXMuIFRoZXNlIGFyZSB1c2VkIGZvciBzbW9vdGggY29sbGlzaW9uLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgcHVibGljIFZlY3RvcjIgVmVydGV4MDtcclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBPcHRpb25hbCBhZGphY2VudCB2ZXJ0aWNlcy4gVGhlc2UgYXJlIHVzZWQgZm9yIHNtb290aCBjb2xsaXNpb24uXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICBwdWJsaWMgVmVjdG9yMiBWZXJ0ZXgzO1xyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIEVkZ2Ugc3RhcnQgdmVydGV4XHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICBwcml2YXRlIFZlY3RvcjIgX3ZlcnRleDE7XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gRWRnZSBlbmQgdmVydGV4XHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICBwcml2YXRlIFZlY3RvcjIgX3ZlcnRleDI7XHJcblxyXG4gICAgICAgIGludGVybmFsIEVkZ2VTaGFwZSgpXHJcbiAgICAgICAgICAgIDogYmFzZSgwKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgU2hhcGVUeXBlID0gU2hhcGVUeXBlLkVkZ2U7XHJcbiAgICAgICAgICAgIF9yYWRpdXMgPSBTZXR0aW5ncy5Qb2x5Z29uUmFkaXVzO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHVibGljIEVkZ2VTaGFwZShWZWN0b3IyIHN0YXJ0LCBWZWN0b3IyIGVuZClcclxuICAgICAgICAgICAgOiBiYXNlKDApXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBTaGFwZVR5cGUgPSBTaGFwZVR5cGUuRWRnZTtcclxuICAgICAgICAgICAgX3JhZGl1cyA9IFNldHRpbmdzLlBvbHlnb25SYWRpdXM7XHJcbiAgICAgICAgICAgIFNldChzdGFydCwgZW5kKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHB1YmxpYyBvdmVycmlkZSBpbnQgQ2hpbGRDb3VudFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgZ2V0IHsgcmV0dXJuIDE7IH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gVGhlc2UgYXJlIHRoZSBlZGdlIHZlcnRpY2VzXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICBwdWJsaWMgVmVjdG9yMiBWZXJ0ZXgxXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBnZXQgeyByZXR1cm4gX3ZlcnRleDE7IH1cclxuICAgICAgICAgICAgc2V0XHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIF92ZXJ0ZXgxID0gdmFsdWU7XHJcbiAgICAgICAgICAgICAgICBDb21wdXRlUHJvcGVydGllcygpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIFRoZXNlIGFyZSB0aGUgZWRnZSB2ZXJ0aWNlc1xyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgcHVibGljIFZlY3RvcjIgVmVydGV4MlxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgZ2V0IHsgcmV0dXJuIF92ZXJ0ZXgyOyB9XHJcbiAgICAgICAgICAgIHNldFxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBfdmVydGV4MiA9IHZhbHVlO1xyXG4gICAgICAgICAgICAgICAgQ29tcHV0ZVByb3BlcnRpZXMoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBTZXQgdGhpcyBhcyBhbiBpc29sYXRlZCBlZGdlLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwic3RhcnRcIj5UaGUgc3RhcnQuPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJlbmRcIj5UaGUgZW5kLjwvcGFyYW0+XHJcbiAgICAgICAgcHVibGljIHZvaWQgU2V0KFZlY3RvcjIgc3RhcnQsIFZlY3RvcjIgZW5kKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgX3ZlcnRleDEgPSBzdGFydDtcclxuICAgICAgICAgICAgX3ZlcnRleDIgPSBlbmQ7XHJcbiAgICAgICAgICAgIEhhc1ZlcnRleDAgPSBmYWxzZTtcclxuICAgICAgICAgICAgSGFzVmVydGV4MyA9IGZhbHNlO1xyXG5cclxuICAgICAgICAgICAgQ29tcHV0ZVByb3BlcnRpZXMoKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHB1YmxpYyBvdmVycmlkZSBTaGFwZSBDbG9uZSgpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBFZGdlU2hhcGUgZWRnZSA9IG5ldyBFZGdlU2hhcGUoKTtcclxuICAgICAgICAgICAgZWRnZS5fcmFkaXVzID0gX3JhZGl1cztcclxuICAgICAgICAgICAgZWRnZS5fZGVuc2l0eSA9IF9kZW5zaXR5O1xyXG4gICAgICAgICAgICBlZGdlLkhhc1ZlcnRleDAgPSBIYXNWZXJ0ZXgwO1xyXG4gICAgICAgICAgICBlZGdlLkhhc1ZlcnRleDMgPSBIYXNWZXJ0ZXgzO1xyXG4gICAgICAgICAgICBlZGdlLlZlcnRleDAgPSBWZXJ0ZXgwO1xyXG4gICAgICAgICAgICBlZGdlLl92ZXJ0ZXgxID0gX3ZlcnRleDE7XHJcbiAgICAgICAgICAgIGVkZ2UuX3ZlcnRleDIgPSBfdmVydGV4MjtcclxuICAgICAgICAgICAgZWRnZS5WZXJ0ZXgzID0gVmVydGV4MztcclxuICAgICAgICAgICAgZWRnZS5NYXNzRGF0YSA9IE1hc3NEYXRhO1xyXG4gICAgICAgICAgICByZXR1cm4gZWRnZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gVGVzdCBhIHBvaW50IGZvciBjb250YWlubWVudCBpbiB0aGlzIHNoYXBlLiBUaGlzIG9ubHkgd29ya3MgZm9yIGNvbnZleCBzaGFwZXMuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJ0cmFuc2Zvcm1cIj5UaGUgc2hhcGUgd29ybGQgdHJhbnNmb3JtLjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwicG9pbnRcIj5hIHBvaW50IGluIHdvcmxkIGNvb3JkaW5hdGVzLjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxyZXR1cm5zPlRydWUgaWYgdGhlIHBvaW50IGlzIGluc2lkZSB0aGUgc2hhcGU8L3JldHVybnM+XHJcbiAgICAgICAgcHVibGljIG92ZXJyaWRlIGJvb2wgVGVzdFBvaW50KHJlZiBUcmFuc2Zvcm0gdHJhbnNmb3JtLCByZWYgVmVjdG9yMiBwb2ludClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gQ2FzdCBhIHJheSBhZ2FpbnN0IGEgY2hpbGQgc2hhcGUuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJvdXRwdXRcIj5UaGUgcmF5LWNhc3QgcmVzdWx0cy48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cImlucHV0XCI+VGhlIHJheS1jYXN0IGlucHV0IHBhcmFtZXRlcnMuPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJ0cmFuc2Zvcm1cIj5UaGUgdHJhbnNmb3JtIHRvIGJlIGFwcGxpZWQgdG8gdGhlIHNoYXBlLjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwiY2hpbGRJbmRleFwiPlRoZSBjaGlsZCBzaGFwZSBpbmRleC48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cmV0dXJucz5UcnVlIGlmIHRoZSByYXktY2FzdCBoaXRzIHRoZSBzaGFwZTwvcmV0dXJucz5cclxuICAgICAgICBwdWJsaWMgb3ZlcnJpZGUgYm9vbCBSYXlDYXN0KG91dCBSYXlDYXN0T3V0cHV0IG91dHB1dCwgcmVmIFJheUNhc3RJbnB1dCBpbnB1dCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlZiBUcmFuc2Zvcm0gdHJhbnNmb3JtLCBpbnQgY2hpbGRJbmRleClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIC8vIHAgPSBwMSArIHQgKiBkXHJcbiAgICAgICAgICAgIC8vIHYgPSB2MSArIHMgKiBlXHJcbiAgICAgICAgICAgIC8vIHAxICsgdCAqIGQgPSB2MSArIHMgKiBlXHJcbiAgICAgICAgICAgIC8vIHMgKiBlIC0gdCAqIGQgPSBwMSAtIHYxXHJcblxyXG4gICAgICAgICAgICBvdXRwdXQgPSBuZXcgUmF5Q2FzdE91dHB1dCgpO1xyXG5cclxuICAgICAgICAgICAgLy8gUHV0IHRoZSByYXkgaW50byB0aGUgZWRnZSdzIGZyYW1lIG9mIHJlZmVyZW5jZS5cclxuICAgICAgICAgICAgVmVjdG9yMiBwMSA9IE1hdGhVdGlscy5NdWx0aXBseVQocmVmIHRyYW5zZm9ybS5SLCBpbnB1dC5Qb2ludDEgLSB0cmFuc2Zvcm0uUG9zaXRpb24pO1xyXG4gICAgICAgICAgICBWZWN0b3IyIHAyID0gTWF0aFV0aWxzLk11bHRpcGx5VChyZWYgdHJhbnNmb3JtLlIsIGlucHV0LlBvaW50MiAtIHRyYW5zZm9ybS5Qb3NpdGlvbik7XHJcbiAgICAgICAgICAgIFZlY3RvcjIgZCA9IHAyIC0gcDE7XHJcblxyXG4gICAgICAgICAgICBWZWN0b3IyIHYxID0gX3ZlcnRleDE7XHJcbiAgICAgICAgICAgIFZlY3RvcjIgdjIgPSBfdmVydGV4MjtcclxuICAgICAgICAgICAgVmVjdG9yMiBlID0gdjIgLSB2MTtcclxuICAgICAgICAgICAgVmVjdG9yMiBub3JtYWwgPSBuZXcgVmVjdG9yMihlLlksIC1lLlgpO1xyXG4gICAgICAgICAgICBub3JtYWwuTm9ybWFsaXplKCk7XHJcblxyXG4gICAgICAgICAgICAvLyBxID0gcDEgKyB0ICogZFxyXG4gICAgICAgICAgICAvLyBkb3Qobm9ybWFsLCBxIC0gdjEpID0gMFxyXG4gICAgICAgICAgICAvLyBkb3Qobm9ybWFsLCBwMSAtIHYxKSArIHQgKiBkb3Qobm9ybWFsLCBkKSA9IDBcclxuICAgICAgICAgICAgZmxvYXQgbnVtZXJhdG9yID0gVmVjdG9yMi5Eb3Qobm9ybWFsLCB2MSAtIHAxKTtcclxuICAgICAgICAgICAgZmxvYXQgZGVub21pbmF0b3IgPSBWZWN0b3IyLkRvdChub3JtYWwsIGQpO1xyXG5cclxuICAgICAgICAgICAgaWYgKGRlbm9taW5hdG9yID09IDAuMGYpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgZmxvYXQgdCA9IG51bWVyYXRvciAvIGRlbm9taW5hdG9yO1xyXG4gICAgICAgICAgICBpZiAodCA8IDAuMGYgfHwgMS4wZiA8IHQpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgVmVjdG9yMiBxID0gcDEgKyB0ICogZDtcclxuXHJcbiAgICAgICAgICAgIC8vIHEgPSB2MSArIHMgKiByXHJcbiAgICAgICAgICAgIC8vIHMgPSBkb3QocSAtIHYxLCByKSAvIGRvdChyLCByKVxyXG4gICAgICAgICAgICBWZWN0b3IyIHIgPSB2MiAtIHYxO1xyXG4gICAgICAgICAgICBmbG9hdCByciA9IFZlY3RvcjIuRG90KHIsIHIpO1xyXG4gICAgICAgICAgICBpZiAocnIgPT0gMC4wZilcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBmbG9hdCBzID0gVmVjdG9yMi5Eb3QocSAtIHYxLCByKSAvIHJyO1xyXG4gICAgICAgICAgICBpZiAocyA8IDAuMGYgfHwgMS4wZiA8IHMpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgb3V0cHV0LkZyYWN0aW9uID0gdDtcclxuICAgICAgICAgICAgaWYgKG51bWVyYXRvciA+IDAuMGYpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIG91dHB1dC5Ob3JtYWwgPSAtbm9ybWFsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgb3V0cHV0Lk5vcm1hbCA9IG5vcm1hbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gR2l2ZW4gYSB0cmFuc2Zvcm0sIGNvbXB1dGUgdGhlIGFzc29jaWF0ZWQgYXhpcyBhbGlnbmVkIGJvdW5kaW5nIGJveCBmb3IgYSBjaGlsZCBzaGFwZS5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cImFhYmJcIj5UaGUgYWFiYiByZXN1bHRzLjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwidHJhbnNmb3JtXCI+VGhlIHdvcmxkIHRyYW5zZm9ybSBvZiB0aGUgc2hhcGUuPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJjaGlsZEluZGV4XCI+VGhlIGNoaWxkIHNoYXBlIGluZGV4LjwvcGFyYW0+XHJcbiAgICAgICAgcHVibGljIG92ZXJyaWRlIHZvaWQgQ29tcHV0ZUFBQkIob3V0IEFBQkIgYWFiYiwgcmVmIFRyYW5zZm9ybSB0cmFuc2Zvcm0sIGludCBjaGlsZEluZGV4KVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgVmVjdG9yMiB2MSA9IE1hdGhVdGlscy5NdWx0aXBseShyZWYgdHJhbnNmb3JtLCBfdmVydGV4MSk7XHJcbiAgICAgICAgICAgIFZlY3RvcjIgdjIgPSBNYXRoVXRpbHMuTXVsdGlwbHkocmVmIHRyYW5zZm9ybSwgX3ZlcnRleDIpO1xyXG5cclxuICAgICAgICAgICAgVmVjdG9yMiBsb3dlciA9IFZlY3RvcjIuTWluKHYxLCB2Mik7XHJcbiAgICAgICAgICAgIFZlY3RvcjIgdXBwZXIgPSBWZWN0b3IyLk1heCh2MSwgdjIpO1xyXG5cclxuICAgICAgICAgICAgVmVjdG9yMiByID0gbmV3IFZlY3RvcjIoUmFkaXVzLCBSYWRpdXMpO1xyXG4gICAgICAgICAgICBhYWJiLkxvd2VyQm91bmQgPSBsb3dlciAtIHI7XHJcbiAgICAgICAgICAgIGFhYmIuVXBwZXJCb3VuZCA9IHVwcGVyICsgcjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gQ29tcHV0ZSB0aGUgbWFzcyBwcm9wZXJ0aWVzIG9mIHRoaXMgc2hhcGUgdXNpbmcgaXRzIGRpbWVuc2lvbnMgYW5kIGRlbnNpdHkuXHJcbiAgICAgICAgLy8vIFRoZSBpbmVydGlhIHRlbnNvciBpcyBjb21wdXRlZCBhYm91dCB0aGUgbG9jYWwgb3JpZ2luLCBub3QgdGhlIGNlbnRyb2lkLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgcHVibGljIG92ZXJyaWRlIHZvaWQgQ29tcHV0ZVByb3BlcnRpZXMoKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgTWFzc0RhdGEuQ2VudHJvaWQgPSAwLjVmICogKF92ZXJ0ZXgxICsgX3ZlcnRleDIpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHVibGljIG92ZXJyaWRlIGZsb2F0IENvbXB1dGVTdWJtZXJnZWRBcmVhKFZlY3RvcjIgbm9ybWFsLCBmbG9hdCBvZmZzZXQsIFRyYW5zZm9ybSB4Ziwgb3V0IFZlY3RvcjIgc2MpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBzYyA9IFZlY3RvcjIuWmVybztcclxuICAgICAgICAgICAgcmV0dXJuIDA7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwdWJsaWMgYm9vbCBDb21wYXJlVG8oRWRnZVNoYXBlIHNoYXBlKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIChIYXNWZXJ0ZXgwID09IHNoYXBlLkhhc1ZlcnRleDAgJiZcclxuICAgICAgICAgICAgICAgICAgICBIYXNWZXJ0ZXgzID09IHNoYXBlLkhhc1ZlcnRleDMgJiZcclxuICAgICAgICAgICAgICAgICAgICBWZXJ0ZXgwID09IHNoYXBlLlZlcnRleDAgJiZcclxuICAgICAgICAgICAgICAgICAgICBWZXJ0ZXgxID09IHNoYXBlLlZlcnRleDEgJiZcclxuICAgICAgICAgICAgICAgICAgICBWZXJ0ZXgyID09IHNoYXBlLlZlcnRleDIgJiZcclxuICAgICAgICAgICAgICAgICAgICBWZXJ0ZXgzID09IHNoYXBlLlZlcnRleDMpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufSIsIi8qXHJcbiogRmFyc2VlciBQaHlzaWNzIEVuZ2luZSBiYXNlZCBvbiBCb3gyRC5YTkEgcG9ydDpcclxuKiBDb3B5cmlnaHQgKGMpIDIwMTAgSWFuIFF2aXN0XHJcbiogXHJcbiogQm94MkQuWE5BIHBvcnQgb2YgQm94MkQ6XHJcbiogQ29weXJpZ2h0IChjKSAyMDA5IEJyYW5kb24gRnVydHdhbmdsZXIsIE5hdGhhbiBGdXJ0d2FuZ2xlclxyXG4qXHJcbiogT3JpZ2luYWwgc291cmNlIEJveDJEOlxyXG4qIENvcHlyaWdodCAoYykgMjAwNi0yMDA5IEVyaW4gQ2F0dG8gaHR0cDovL3d3dy5ncGh5c2ljcy5jb20gXHJcbiogXHJcbiogVGhpcyBzb2Z0d2FyZSBpcyBwcm92aWRlZCAnYXMtaXMnLCB3aXRob3V0IGFueSBleHByZXNzIG9yIGltcGxpZWQgXHJcbiogd2FycmFudHkuICBJbiBubyBldmVudCB3aWxsIHRoZSBhdXRob3JzIGJlIGhlbGQgbGlhYmxlIGZvciBhbnkgZGFtYWdlcyBcclxuKiBhcmlzaW5nIGZyb20gdGhlIHVzZSBvZiB0aGlzIHNvZnR3YXJlLiBcclxuKiBQZXJtaXNzaW9uIGlzIGdyYW50ZWQgdG8gYW55b25lIHRvIHVzZSB0aGlzIHNvZnR3YXJlIGZvciBhbnkgcHVycG9zZSwgXHJcbiogaW5jbHVkaW5nIGNvbW1lcmNpYWwgYXBwbGljYXRpb25zLCBhbmQgdG8gYWx0ZXIgaXQgYW5kIHJlZGlzdHJpYnV0ZSBpdCBcclxuKiBmcmVlbHksIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyByZXN0cmljdGlvbnM6IFxyXG4qIDEuIFRoZSBvcmlnaW4gb2YgdGhpcyBzb2Z0d2FyZSBtdXN0IG5vdCBiZSBtaXNyZXByZXNlbnRlZDsgeW91IG11c3Qgbm90IFxyXG4qIGNsYWltIHRoYXQgeW91IHdyb3RlIHRoZSBvcmlnaW5hbCBzb2Z0d2FyZS4gSWYgeW91IHVzZSB0aGlzIHNvZnR3YXJlIFxyXG4qIGluIGEgcHJvZHVjdCwgYW4gYWNrbm93bGVkZ21lbnQgaW4gdGhlIHByb2R1Y3QgZG9jdW1lbnRhdGlvbiB3b3VsZCBiZSBcclxuKiBhcHByZWNpYXRlZCBidXQgaXMgbm90IHJlcXVpcmVkLiBcclxuKiAyLiBBbHRlcmVkIHNvdXJjZSB2ZXJzaW9ucyBtdXN0IGJlIHBsYWlubHkgbWFya2VkIGFzIHN1Y2gsIGFuZCBtdXN0IG5vdCBiZSBcclxuKiBtaXNyZXByZXNlbnRlZCBhcyBiZWluZyB0aGUgb3JpZ2luYWwgc29mdHdhcmUuIFxyXG4qIDMuIFRoaXMgbm90aWNlIG1heSBub3QgYmUgcmVtb3ZlZCBvciBhbHRlcmVkIGZyb20gYW55IHNvdXJjZSBkaXN0cmlidXRpb24uIFxyXG4qL1xyXG5cclxudXNpbmcgU3lzdGVtLkRpYWdub3N0aWNzO1xyXG51c2luZyBGYXJzZWVyUGh5c2ljcy5Db21tb247XHJcbnVzaW5nIE1pY3Jvc29mdC5YbmEuRnJhbWV3b3JrO1xyXG5cclxubmFtZXNwYWNlIEZhcnNlZXJQaHlzaWNzLkNvbGxpc2lvbi5TaGFwZXNcclxue1xyXG4gICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgLy8vIEEgbG9vcCBTaGFwZSBpcyBhIGZyZWUgZm9ybSBzZXF1ZW5jZSBvZiBsaW5lIHNlZ21lbnRzIHRoYXQgZm9ybSBhIGNpcmN1bGFyIGxpc3QuXHJcbiAgICAvLy8gVGhlIGxvb3AgbWF5IGNyb3NzIHVwb24gaXRzZWxmLCBidXQgdGhpcyBpcyBub3QgcmVjb21tZW5kZWQgZm9yIHNtb290aCBjb2xsaXNpb24uXHJcbiAgICAvLy8gVGhlIGxvb3AgaGFzIGRvdWJsZSBzaWRlZCBjb2xsaXNpb24sIHNvIHlvdSBjYW4gdXNlIGluc2lkZSBhbmQgb3V0c2lkZSBjb2xsaXNpb24uXHJcbiAgICAvLy8gVGhlcmVmb3JlLCB5b3UgbWF5IHVzZSBhbnkgd2luZGluZyBvcmRlci5cclxuICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICBwdWJsaWMgY2xhc3MgTG9vcFNoYXBlIDogU2hhcGVcclxuICAgIHtcclxuICAgICAgICBwcml2YXRlIHN0YXRpYyBFZGdlU2hhcGUgX2VkZ2VTaGFwZSA9IG5ldyBFZGdlU2hhcGUoKTtcclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBUaGUgdmVydGljZXMuIFRoZXNlIGFyZSBub3Qgb3duZWQvZnJlZWQgYnkgdGhlIGxvb3AgU2hhcGUuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICBwdWJsaWMgVmVydGljZXMgVmVydGljZXM7XHJcblxyXG4gICAgICAgIHByaXZhdGUgTG9vcFNoYXBlKClcclxuICAgICAgICAgICAgOiBiYXNlKDApXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBTaGFwZVR5cGUgPSBTaGFwZVR5cGUuTG9vcDtcclxuICAgICAgICAgICAgX3JhZGl1cyA9IFNldHRpbmdzLlBvbHlnb25SYWRpdXM7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwdWJsaWMgTG9vcFNoYXBlKFZlcnRpY2VzIHZlcnRpY2VzKVxyXG4gICAgICAgICAgICA6IGJhc2UoMClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIFNoYXBlVHlwZSA9IFNoYXBlVHlwZS5Mb29wO1xyXG4gICAgICAgICAgICBfcmFkaXVzID0gU2V0dGluZ3MuUG9seWdvblJhZGl1cztcclxuXHJcbiAgICAgICAgICAgIGlmIChTZXR0aW5ncy5Db25zZXJ2ZU1lbW9yeSlcclxuICAgICAgICAgICAgICAgIFZlcnRpY2VzID0gdmVydGljZXM7XHJcbiAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgIC8vIENvcHkgdmVydGljZXMuXHJcbiAgICAgICAgICAgICAgICBWZXJ0aWNlcyA9IG5ldyBWZXJ0aWNlcyh2ZXJ0aWNlcyk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwdWJsaWMgb3ZlcnJpZGUgaW50IENoaWxkQ291bnRcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGdldCB7IHJldHVybiBWZXJ0aWNlcy5Db3VudDsgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHVibGljIG92ZXJyaWRlIFNoYXBlIENsb25lKClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIExvb3BTaGFwZSBsb29wID0gbmV3IExvb3BTaGFwZSgpO1xyXG4gICAgICAgICAgICBsb29wLl9kZW5zaXR5ID0gX2RlbnNpdHk7XHJcbiAgICAgICAgICAgIGxvb3AuX3JhZGl1cyA9IF9yYWRpdXM7XHJcbiAgICAgICAgICAgIGxvb3AuVmVydGljZXMgPSBWZXJ0aWNlcztcclxuICAgICAgICAgICAgbG9vcC5NYXNzRGF0YSA9IE1hc3NEYXRhO1xyXG4gICAgICAgICAgICByZXR1cm4gbG9vcDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gR2V0IGEgY2hpbGQgZWRnZS5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cImVkZ2VcIj5UaGUgZWRnZS48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cImluZGV4XCI+VGhlIGluZGV4LjwvcGFyYW0+XHJcbiAgICAgICAgcHVibGljIHZvaWQgR2V0Q2hpbGRFZGdlKHJlZiBFZGdlU2hhcGUgZWRnZSwgaW50IGluZGV4KVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgRGVidWcuQXNzZXJ0KDIgPD0gVmVydGljZXMuQ291bnQpO1xyXG4gICAgICAgICAgICBEZWJ1Zy5Bc3NlcnQoMCA8PSBpbmRleCAmJiBpbmRleCA8IFZlcnRpY2VzLkNvdW50KTtcclxuICAgICAgICAgICAgZWRnZS5TaGFwZVR5cGUgPSBTaGFwZVR5cGUuRWRnZTtcclxuICAgICAgICAgICAgZWRnZS5fcmFkaXVzID0gX3JhZGl1cztcclxuICAgICAgICAgICAgZWRnZS5IYXNWZXJ0ZXgwID0gdHJ1ZTtcclxuICAgICAgICAgICAgZWRnZS5IYXNWZXJ0ZXgzID0gdHJ1ZTtcclxuXHJcbiAgICAgICAgICAgIGludCBpMCA9IGluZGV4IC0gMSA+PSAwID8gaW5kZXggLSAxIDogVmVydGljZXMuQ291bnQgLSAxO1xyXG4gICAgICAgICAgICBpbnQgaTEgPSBpbmRleDtcclxuICAgICAgICAgICAgaW50IGkyID0gaW5kZXggKyAxIDwgVmVydGljZXMuQ291bnQgPyBpbmRleCArIDEgOiAwO1xyXG4gICAgICAgICAgICBpbnQgaTMgPSBpbmRleCArIDI7XHJcbiAgICAgICAgICAgIHdoaWxlIChpMyA+PSBWZXJ0aWNlcy5Db3VudClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgaTMgLT0gVmVydGljZXMuQ291bnQ7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGVkZ2UuVmVydGV4MCA9IFZlcnRpY2VzW2kwXTtcclxuICAgICAgICAgICAgZWRnZS5WZXJ0ZXgxID0gVmVydGljZXNbaTFdO1xyXG4gICAgICAgICAgICBlZGdlLlZlcnRleDIgPSBWZXJ0aWNlc1tpMl07XHJcbiAgICAgICAgICAgIGVkZ2UuVmVydGV4MyA9IFZlcnRpY2VzW2kzXTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gVGVzdCBhIHBvaW50IGZvciBjb250YWlubWVudCBpbiB0aGlzIHNoYXBlLiBUaGlzIG9ubHkgd29ya3MgZm9yIGNvbnZleCBzaGFwZXMuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJ0cmFuc2Zvcm1cIj5UaGUgc2hhcGUgd29ybGQgdHJhbnNmb3JtLjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwicG9pbnRcIj5hIHBvaW50IGluIHdvcmxkIGNvb3JkaW5hdGVzLjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxyZXR1cm5zPlRydWUgaWYgdGhlIHBvaW50IGlzIGluc2lkZSB0aGUgc2hhcGU8L3JldHVybnM+XHJcbiAgICAgICAgcHVibGljIG92ZXJyaWRlIGJvb2wgVGVzdFBvaW50KHJlZiBUcmFuc2Zvcm0gdHJhbnNmb3JtLCByZWYgVmVjdG9yMiBwb2ludClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gQ2FzdCBhIHJheSBhZ2FpbnN0IGEgY2hpbGQgc2hhcGUuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJvdXRwdXRcIj5UaGUgcmF5LWNhc3QgcmVzdWx0cy48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cImlucHV0XCI+VGhlIHJheS1jYXN0IGlucHV0IHBhcmFtZXRlcnMuPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJ0cmFuc2Zvcm1cIj5UaGUgdHJhbnNmb3JtIHRvIGJlIGFwcGxpZWQgdG8gdGhlIHNoYXBlLjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwiY2hpbGRJbmRleFwiPlRoZSBjaGlsZCBzaGFwZSBpbmRleC48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cmV0dXJucz5UcnVlIGlmIHRoZSByYXktY2FzdCBoaXRzIHRoZSBzaGFwZTwvcmV0dXJucz5cclxuICAgICAgICBwdWJsaWMgb3ZlcnJpZGUgYm9vbCBSYXlDYXN0KG91dCBSYXlDYXN0T3V0cHV0IG91dHB1dCwgcmVmIFJheUNhc3RJbnB1dCBpbnB1dCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlZiBUcmFuc2Zvcm0gdHJhbnNmb3JtLCBpbnQgY2hpbGRJbmRleClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIERlYnVnLkFzc2VydChjaGlsZEluZGV4IDwgVmVydGljZXMuQ291bnQpO1xyXG5cclxuICAgICAgICAgICAgaW50IGkxID0gY2hpbGRJbmRleDtcclxuICAgICAgICAgICAgaW50IGkyID0gY2hpbGRJbmRleCArIDE7XHJcbiAgICAgICAgICAgIGlmIChpMiA9PSBWZXJ0aWNlcy5Db3VudClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgaTIgPSAwO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBfZWRnZVNoYXBlLlZlcnRleDEgPSBWZXJ0aWNlc1tpMV07XHJcbiAgICAgICAgICAgIF9lZGdlU2hhcGUuVmVydGV4MiA9IFZlcnRpY2VzW2kyXTtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiBfZWRnZVNoYXBlLlJheUNhc3Qob3V0IG91dHB1dCwgcmVmIGlucHV0LCByZWYgdHJhbnNmb3JtLCAwKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gR2l2ZW4gYSB0cmFuc2Zvcm0sIGNvbXB1dGUgdGhlIGFzc29jaWF0ZWQgYXhpcyBhbGlnbmVkIGJvdW5kaW5nIGJveCBmb3IgYSBjaGlsZCBzaGFwZS5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cImFhYmJcIj5UaGUgYWFiYiByZXN1bHRzLjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwidHJhbnNmb3JtXCI+VGhlIHdvcmxkIHRyYW5zZm9ybSBvZiB0aGUgc2hhcGUuPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJjaGlsZEluZGV4XCI+VGhlIGNoaWxkIHNoYXBlIGluZGV4LjwvcGFyYW0+XHJcbiAgICAgICAgcHVibGljIG92ZXJyaWRlIHZvaWQgQ29tcHV0ZUFBQkIob3V0IEFBQkIgYWFiYiwgcmVmIFRyYW5zZm9ybSB0cmFuc2Zvcm0sIGludCBjaGlsZEluZGV4KVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgRGVidWcuQXNzZXJ0KGNoaWxkSW5kZXggPCBWZXJ0aWNlcy5Db3VudCk7XHJcblxyXG4gICAgICAgICAgICBpbnQgaTEgPSBjaGlsZEluZGV4O1xyXG4gICAgICAgICAgICBpbnQgaTIgPSBjaGlsZEluZGV4ICsgMTtcclxuICAgICAgICAgICAgaWYgKGkyID09IFZlcnRpY2VzLkNvdW50KVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBpMiA9IDA7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIFZlY3RvcjIgdjEgPSBNYXRoVXRpbHMuTXVsdGlwbHkocmVmIHRyYW5zZm9ybSwgVmVydGljZXNbaTFdKTtcclxuICAgICAgICAgICAgVmVjdG9yMiB2MiA9IE1hdGhVdGlscy5NdWx0aXBseShyZWYgdHJhbnNmb3JtLCBWZXJ0aWNlc1tpMl0pO1xyXG5cclxuICAgICAgICAgICAgYWFiYi5Mb3dlckJvdW5kID0gVmVjdG9yMi5NaW4odjEsIHYyKTtcclxuICAgICAgICAgICAgYWFiYi5VcHBlckJvdW5kID0gVmVjdG9yMi5NYXgodjEsIHYyKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gQ2hhaW5zIGhhdmUgemVybyBtYXNzLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgcHVibGljIG92ZXJyaWRlIHZvaWQgQ29tcHV0ZVByb3BlcnRpZXMoKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgLy9Eb2VzIG5vdGhpbmcuIExvb3Agc2hhcGVzIGRvbid0IGhhdmUgcHJvcGVydGllcy5cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHB1YmxpYyBvdmVycmlkZSBmbG9hdCBDb21wdXRlU3VibWVyZ2VkQXJlYShWZWN0b3IyIG5vcm1hbCwgZmxvYXQgb2Zmc2V0LCBUcmFuc2Zvcm0geGYsIG91dCBWZWN0b3IyIHNjKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgc2MgPSBWZWN0b3IyLlplcm87XHJcbiAgICAgICAgICAgIHJldHVybiAwO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufSIsIi8qXHJcbiogRmFyc2VlciBQaHlzaWNzIEVuZ2luZSBiYXNlZCBvbiBCb3gyRC5YTkEgcG9ydDpcclxuKiBDb3B5cmlnaHQgKGMpIDIwMTAgSWFuIFF2aXN0XHJcbiogXHJcbiogQm94MkQuWE5BIHBvcnQgb2YgQm94MkQ6XHJcbiogQ29weXJpZ2h0IChjKSAyMDA5IEJyYW5kb24gRnVydHdhbmdsZXIsIE5hdGhhbiBGdXJ0d2FuZ2xlclxyXG4qXHJcbiogT3JpZ2luYWwgc291cmNlIEJveDJEOlxyXG4qIENvcHlyaWdodCAoYykgMjAwNi0yMDA5IEVyaW4gQ2F0dG8gaHR0cDovL3d3dy5ncGh5c2ljcy5jb20gXHJcbiogXHJcbiogVGhpcyBzb2Z0d2FyZSBpcyBwcm92aWRlZCAnYXMtaXMnLCB3aXRob3V0IGFueSBleHByZXNzIG9yIGltcGxpZWQgXHJcbiogd2FycmFudHkuICBJbiBubyBldmVudCB3aWxsIHRoZSBhdXRob3JzIGJlIGhlbGQgbGlhYmxlIGZvciBhbnkgZGFtYWdlcyBcclxuKiBhcmlzaW5nIGZyb20gdGhlIHVzZSBvZiB0aGlzIHNvZnR3YXJlLiBcclxuKiBQZXJtaXNzaW9uIGlzIGdyYW50ZWQgdG8gYW55b25lIHRvIHVzZSB0aGlzIHNvZnR3YXJlIGZvciBhbnkgcHVycG9zZSwgXHJcbiogaW5jbHVkaW5nIGNvbW1lcmNpYWwgYXBwbGljYXRpb25zLCBhbmQgdG8gYWx0ZXIgaXQgYW5kIHJlZGlzdHJpYnV0ZSBpdCBcclxuKiBmcmVlbHksIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyByZXN0cmljdGlvbnM6IFxyXG4qIDEuIFRoZSBvcmlnaW4gb2YgdGhpcyBzb2Z0d2FyZSBtdXN0IG5vdCBiZSBtaXNyZXByZXNlbnRlZDsgeW91IG11c3Qgbm90IFxyXG4qIGNsYWltIHRoYXQgeW91IHdyb3RlIHRoZSBvcmlnaW5hbCBzb2Z0d2FyZS4gSWYgeW91IHVzZSB0aGlzIHNvZnR3YXJlIFxyXG4qIGluIGEgcHJvZHVjdCwgYW4gYWNrbm93bGVkZ21lbnQgaW4gdGhlIHByb2R1Y3QgZG9jdW1lbnRhdGlvbiB3b3VsZCBiZSBcclxuKiBhcHByZWNpYXRlZCBidXQgaXMgbm90IHJlcXVpcmVkLiBcclxuKiAyLiBBbHRlcmVkIHNvdXJjZSB2ZXJzaW9ucyBtdXN0IGJlIHBsYWlubHkgbWFya2VkIGFzIHN1Y2gsIGFuZCBtdXN0IG5vdCBiZSBcclxuKiBtaXNyZXByZXNlbnRlZCBhcyBiZWluZyB0aGUgb3JpZ2luYWwgc29mdHdhcmUuIFxyXG4qIDMuIFRoaXMgbm90aWNlIG1heSBub3QgYmUgcmVtb3ZlZCBvciBhbHRlcmVkIGZyb20gYW55IHNvdXJjZSBkaXN0cmlidXRpb24uIFxyXG4qL1xyXG5cclxudXNpbmcgU3lzdGVtLkRpYWdub3N0aWNzO1xyXG51c2luZyBGYXJzZWVyUGh5c2ljcy5Db21tb247XHJcbnVzaW5nIEZhcnNlZXJQaHlzaWNzLkNvbW1vbi5EZWNvbXBvc2l0aW9uO1xyXG51c2luZyBNaWNyb3NvZnQuWG5hLkZyYW1ld29yaztcclxuXHJcbm5hbWVzcGFjZSBGYXJzZWVyUGh5c2ljcy5Db2xsaXNpb24uU2hhcGVzXHJcbntcclxuICAgIC8vLyA8c3VtbWFyeT5cclxuICAgIC8vLyBSZXByZXNlbnRzIGEgc2ltcGxlIG5vbi1zZWxmaW50ZXJzZWN0aW5nIGNvbnZleCBwb2x5Z29uLlxyXG4gICAgLy8vIElmIHlvdSB3YW50IHRvIGhhdmUgY29uY2F2ZSBwb2x5Z29ucywgeW91IHdpbGwgaGF2ZSB0byB1c2UgdGhlIDxzZWUgY3JlZj1cIkJheWF6aXREZWNvbXBvc2VyXCIvPiBvciB0aGUgPHNlZSBjcmVmPVwiRWFyY2xpcERlY29tcG9zZXJcIi8+XHJcbiAgICAvLy8gdG8gZGVjb21wb3NlIHRoZSBjb25jYXZlIHBvbHlnb24gaW50byAyIG9yIG1vcmUgY29udmV4IHBvbHlnb25zLlxyXG4gICAgLy8vIDwvc3VtbWFyeT5cclxuICAgIHB1YmxpYyBjbGFzcyBQb2x5Z29uU2hhcGUgOiBTaGFwZVxyXG4gICAge1xyXG4gICAgICAgIHB1YmxpYyBWZXJ0aWNlcyBOb3JtYWxzO1xyXG4gICAgICAgIHB1YmxpYyBWZXJ0aWNlcyBWZXJ0aWNlcztcclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBJbml0aWFsaXplcyBhIG5ldyBpbnN0YW5jZSBvZiB0aGUgPHNlZSBjcmVmPVwiUG9seWdvblNoYXBlXCIvPiBjbGFzcy5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cInZlcnRpY2VzXCI+VGhlIHZlcnRpY2VzLjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwiZGVuc2l0eVwiPlRoZSBkZW5zaXR5LjwvcGFyYW0+XHJcbiAgICAgICAgcHVibGljIFBvbHlnb25TaGFwZShWZXJ0aWNlcyB2ZXJ0aWNlcywgZmxvYXQgZGVuc2l0eSlcclxuICAgICAgICAgICAgOiBiYXNlKGRlbnNpdHkpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBTaGFwZVR5cGUgPSBTaGFwZVR5cGUuUG9seWdvbjtcclxuICAgICAgICAgICAgX3JhZGl1cyA9IFNldHRpbmdzLlBvbHlnb25SYWRpdXM7XHJcblxyXG4gICAgICAgICAgICBTZXQodmVydGljZXMpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHVibGljIFBvbHlnb25TaGFwZShmbG9hdCBkZW5zaXR5KVxyXG4gICAgICAgICAgICA6IGJhc2UoZGVuc2l0eSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIFNoYXBlVHlwZSA9IFNoYXBlVHlwZS5Qb2x5Z29uO1xyXG4gICAgICAgICAgICBfcmFkaXVzID0gU2V0dGluZ3MuUG9seWdvblJhZGl1cztcclxuICAgICAgICAgICAgTm9ybWFscyA9IG5ldyBWZXJ0aWNlcygpO1xyXG4gICAgICAgICAgICBWZXJ0aWNlcyA9IG5ldyBWZXJ0aWNlcygpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaW50ZXJuYWwgUG9seWdvblNoYXBlKClcclxuICAgICAgICAgICAgOiBiYXNlKDApXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBTaGFwZVR5cGUgPSBTaGFwZVR5cGUuUG9seWdvbjtcclxuICAgICAgICAgICAgX3JhZGl1cyA9IFNldHRpbmdzLlBvbHlnb25SYWRpdXM7XHJcbiAgICAgICAgICAgIE5vcm1hbHMgPSBuZXcgVmVydGljZXMoKTtcclxuICAgICAgICAgICAgVmVydGljZXMgPSBuZXcgVmVydGljZXMoKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHB1YmxpYyBvdmVycmlkZSBpbnQgQ2hpbGRDb3VudFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgZ2V0IHsgcmV0dXJuIDE7IH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHB1YmxpYyBvdmVycmlkZSBTaGFwZSBDbG9uZSgpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBQb2x5Z29uU2hhcGUgY2xvbmUgPSBuZXcgUG9seWdvblNoYXBlKCk7XHJcbiAgICAgICAgICAgIGNsb25lLlNoYXBlVHlwZSA9IFNoYXBlVHlwZTtcclxuICAgICAgICAgICAgY2xvbmUuX3JhZGl1cyA9IF9yYWRpdXM7XHJcbiAgICAgICAgICAgIGNsb25lLl9kZW5zaXR5ID0gX2RlbnNpdHk7XHJcblxyXG4gICAgICAgICAgICBpZiAoU2V0dGluZ3MuQ29uc2VydmVNZW1vcnkpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGNsb25lLlZlcnRpY2VzID0gVmVydGljZXM7XHJcbiAgICAgICAgICAgICAgICBjbG9uZS5Ob3JtYWxzID0gTm9ybWFscztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGNsb25lLlZlcnRpY2VzID0gbmV3IFZlcnRpY2VzKFZlcnRpY2VzKTtcclxuICAgICAgICAgICAgICAgIGNsb25lLk5vcm1hbHMgPSBuZXcgVmVydGljZXMoTm9ybWFscyk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGNsb25lLk1hc3NEYXRhID0gTWFzc0RhdGE7XHJcbiAgICAgICAgICAgIHJldHVybiBjbG9uZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gQ29weSB2ZXJ0aWNlcy4gVGhpcyBhc3N1bWVzIHRoZSB2ZXJ0aWNlcyBkZWZpbmUgYSBjb252ZXggcG9seWdvbi5cclxuICAgICAgICAvLy8gSXQgaXMgYXNzdW1lZCB0aGF0IHRoZSBleHRlcmlvciBpcyB0aGUgdGhlIHJpZ2h0IG9mIGVhY2ggZWRnZS5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cInZlcnRpY2VzXCI+VGhlIHZlcnRpY2VzLjwvcGFyYW0+XHJcbiAgICAgICAgcHVibGljIHZvaWQgU2V0KFZlcnRpY2VzIHZlcnRpY2VzKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgRGVidWcuQXNzZXJ0KHZlcnRpY2VzLkNvdW50ID49IDMgJiYgdmVydGljZXMuQ291bnQgPD0gU2V0dGluZ3MuTWF4UG9seWdvblZlcnRpY2VzKTtcclxuXHJcbiAgICAgICAgICAgIGlmIChTZXR0aW5ncy5Db25zZXJ2ZU1lbW9yeSlcclxuICAgICAgICAgICAgICAgIFZlcnRpY2VzID0gdmVydGljZXM7XHJcbiAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgIC8vIENvcHkgdmVydGljZXMuXHJcbiAgICAgICAgICAgICAgICBWZXJ0aWNlcyA9IG5ldyBWZXJ0aWNlcyh2ZXJ0aWNlcyk7XHJcblxyXG4gICAgICAgICAgICBOb3JtYWxzID0gbmV3IFZlcnRpY2VzKHZlcnRpY2VzLkNvdW50KTtcclxuXHJcbiAgICAgICAgICAgIC8vIENvbXB1dGUgbm9ybWFscy4gRW5zdXJlIHRoZSBlZGdlcyBoYXZlIG5vbi16ZXJvIGxlbmd0aC5cclxuICAgICAgICAgICAgZm9yIChpbnQgaSA9IDA7IGkgPCB2ZXJ0aWNlcy5Db3VudDsgKytpKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBpbnQgaTEgPSBpO1xyXG4gICAgICAgICAgICAgICAgaW50IGkyID0gaSArIDEgPCB2ZXJ0aWNlcy5Db3VudCA/IGkgKyAxIDogMDtcclxuICAgICAgICAgICAgICAgIFZlY3RvcjIgZWRnZSA9IFZlcnRpY2VzW2kyXSAtIFZlcnRpY2VzW2kxXTtcclxuICAgICAgICAgICAgICAgIERlYnVnLkFzc2VydChlZGdlLkxlbmd0aFNxdWFyZWQoKSA+IFNldHRpbmdzLkVwc2lsb24gKiBTZXR0aW5ncy5FcHNpbG9uKTtcclxuXHJcbiAgICAgICAgICAgICAgICBWZWN0b3IyIHRlbXAgPSBuZXcgVmVjdG9yMihlZGdlLlksIC1lZGdlLlgpO1xyXG4gICAgICAgICAgICAgICAgdGVtcC5Ob3JtYWxpemUoKTtcclxuICAgICAgICAgICAgICAgIE5vcm1hbHMuQWRkKHRlbXApO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4jaWYgREVCVUdcclxuICAgICAgICAgICAgLy8gRW5zdXJlIHRoZSBwb2x5Z29uIGlzIGNvbnZleCBhbmQgdGhlIGludGVyaW9yXHJcbiAgICAgICAgICAgIC8vIGlzIHRvIHRoZSBsZWZ0IG9mIGVhY2ggZWRnZS5cclxuICAgICAgICAgICAgZm9yIChpbnQgaSA9IDA7IGkgPCBWZXJ0aWNlcy5Db3VudDsgKytpKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBpbnQgaTEgPSBpO1xyXG4gICAgICAgICAgICAgICAgaW50IGkyID0gaSArIDEgPCBWZXJ0aWNlcy5Db3VudCA/IGkgKyAxIDogMDtcclxuICAgICAgICAgICAgICAgIFZlY3RvcjIgZWRnZSA9IFZlcnRpY2VzW2kyXSAtIFZlcnRpY2VzW2kxXTtcclxuXHJcbiAgICAgICAgICAgICAgICBmb3IgKGludCBqID0gMDsgaiA8IHZlcnRpY2VzLkNvdW50OyArK2opXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gRG9uJ3QgY2hlY2sgdmVydGljZXMgb24gdGhlIGN1cnJlbnQgZWRnZS5cclxuICAgICAgICAgICAgICAgICAgICBpZiAoaiA9PSBpMSB8fCBqID09IGkyKVxyXG4gICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICBWZWN0b3IyIHIgPSBWZXJ0aWNlc1tqXSAtIFZlcnRpY2VzW2kxXTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gWW91ciBwb2x5Z29uIGlzIG5vbi1jb252ZXggKGl0IGhhcyBhbiBpbmRlbnRhdGlvbikgb3JcclxuICAgICAgICAgICAgICAgICAgICAvLyBoYXMgY29saW5lYXIgZWRnZXMuXHJcbiAgICAgICAgICAgICAgICAgICAgZmxvYXQgcyA9IGVkZ2UuWCAqIHIuWSAtIGVkZ2UuWSAqIHIuWDtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgRGVidWcuQXNzZXJ0KHMgPiAwLjBmKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4jZW5kaWZcclxuXHJcbiAgICAgICAgICAgIC8vIENvbXB1dGUgdGhlIHBvbHlnb24gbWFzcyBkYXRhXHJcbiAgICAgICAgICAgIENvbXB1dGVQcm9wZXJ0aWVzKCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIENvbXB1dGUgdGhlIG1hc3MgcHJvcGVydGllcyBvZiB0aGlzIHNoYXBlIHVzaW5nIGl0cyBkaW1lbnNpb25zIGFuZCBkZW5zaXR5LlxyXG4gICAgICAgIC8vLyBUaGUgaW5lcnRpYSB0ZW5zb3IgaXMgY29tcHV0ZWQgYWJvdXQgdGhlIGxvY2FsIG9yaWdpbiwgbm90IHRoZSBjZW50cm9pZC5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIHB1YmxpYyBvdmVycmlkZSB2b2lkIENvbXB1dGVQcm9wZXJ0aWVzKClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIC8vIFBvbHlnb24gbWFzcywgY2VudHJvaWQsIGFuZCBpbmVydGlhLlxyXG4gICAgICAgICAgICAvLyBMZXQgcmhvIGJlIHRoZSBwb2x5Z29uIGRlbnNpdHkgaW4gbWFzcyBwZXIgdW5pdCBhcmVhLlxyXG4gICAgICAgICAgICAvLyBUaGVuOlxyXG4gICAgICAgICAgICAvLyBtYXNzID0gcmhvICogaW50KGRBKVxyXG4gICAgICAgICAgICAvLyBjZW50cm9pZC5YID0gKDEvbWFzcykgKiByaG8gKiBpbnQoeCAqIGRBKVxyXG4gICAgICAgICAgICAvLyBjZW50cm9pZC5ZID0gKDEvbWFzcykgKiByaG8gKiBpbnQoeSAqIGRBKVxyXG4gICAgICAgICAgICAvLyBJID0gcmhvICogaW50KCh4KnggKyB5KnkpICogZEEpXHJcbiAgICAgICAgICAgIC8vXHJcbiAgICAgICAgICAgIC8vIFdlIGNhbiBjb21wdXRlIHRoZXNlIGludGVncmFscyBieSBzdW1taW5nIGFsbCB0aGUgaW50ZWdyYWxzXHJcbiAgICAgICAgICAgIC8vIGZvciBlYWNoIHRyaWFuZ2xlIG9mIHRoZSBwb2x5Z29uLiBUbyBldmFsdWF0ZSB0aGUgaW50ZWdyYWxcclxuICAgICAgICAgICAgLy8gZm9yIGEgc2luZ2xlIHRyaWFuZ2xlLCB3ZSBtYWtlIGEgY2hhbmdlIG9mIHZhcmlhYmxlcyB0b1xyXG4gICAgICAgICAgICAvLyB0aGUgKHUsdikgY29vcmRpbmF0ZXMgb2YgdGhlIHRyaWFuZ2xlOlxyXG4gICAgICAgICAgICAvLyB4ID0geDAgKyBlMXggKiB1ICsgZTJ4ICogdlxyXG4gICAgICAgICAgICAvLyB5ID0geTAgKyBlMXkgKiB1ICsgZTJ5ICogdlxyXG4gICAgICAgICAgICAvLyB3aGVyZSAwIDw9IHUgJiYgMCA8PSB2ICYmIHUgKyB2IDw9IDEuXHJcbiAgICAgICAgICAgIC8vXHJcbiAgICAgICAgICAgIC8vIFdlIGludGVncmF0ZSB1IGZyb20gWzAsMS12XSBhbmQgdGhlbiB2IGZyb20gWzAsMV0uXHJcbiAgICAgICAgICAgIC8vIFdlIGFsc28gbmVlZCB0byB1c2UgdGhlIEphY29iaWFuIG9mIHRoZSB0cmFuc2Zvcm1hdGlvbjpcclxuICAgICAgICAgICAgLy8gRCA9IGNyb3NzKGUxLCBlMilcclxuICAgICAgICAgICAgLy9cclxuICAgICAgICAgICAgLy8gU2ltcGxpZmljYXRpb246IHRyaWFuZ2xlIGNlbnRyb2lkID0gKDEvMykgKiAocDEgKyBwMiArIHAzKVxyXG4gICAgICAgICAgICAvL1xyXG4gICAgICAgICAgICAvLyBUaGUgcmVzdCBvZiB0aGUgZGVyaXZhdGlvbiBpcyBoYW5kbGVkIGJ5IGNvbXB1dGVyIGFsZ2VicmEuXHJcblxyXG4gICAgICAgICAgICBEZWJ1Zy5Bc3NlcnQoVmVydGljZXMuQ291bnQgPj0gMyk7XHJcblxyXG4gICAgICAgICAgICBpZiAoX2RlbnNpdHkgPD0gMClcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuXHJcbiAgICAgICAgICAgIFZlY3RvcjIgY2VudGVyID0gVmVjdG9yMi5aZXJvO1xyXG4gICAgICAgICAgICBmbG9hdCBhcmVhID0gMC4wZjtcclxuICAgICAgICAgICAgZmxvYXQgSSA9IDAuMGY7XHJcblxyXG4gICAgICAgICAgICAvLyBwUmVmIGlzIHRoZSByZWZlcmVuY2UgcG9pbnQgZm9yIGZvcm1pbmcgdHJpYW5nbGVzLlxyXG4gICAgICAgICAgICAvLyBJdCdzIGxvY2F0aW9uIGRvZXNuJ3QgY2hhbmdlIHRoZSByZXN1bHQgKGV4Y2VwdCBmb3Igcm91bmRpbmcgZXJyb3IpLlxyXG4gICAgICAgICAgICBWZWN0b3IyIHBSZWYgPSBWZWN0b3IyLlplcm87XHJcblxyXG4jaWYgZmFsc2VcclxuICAgIC8vIFRoaXMgY29kZSB3b3VsZCBwdXQgdGhlIHJlZmVyZW5jZSBwb2ludCBpbnNpZGUgdGhlIHBvbHlnb24uXHJcblx0ICAgICAgICBmb3IgKGludCBpID0gMDsgaSA8IGNvdW50OyArK2kpXHJcblx0ICAgICAgICB7XHJcblx0XHQgICAgICAgIHBSZWYgKz0gdnNbaV07XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICBwUmVmICo9IDEuMGYgLyBjb3VudDtcclxuI2VuZGlmXHJcblxyXG4gICAgICAgICAgICBjb25zdCBmbG9hdCBpbnYzID0gMS4wZiAvIDMuMGY7XHJcblxyXG4gICAgICAgICAgICBmb3IgKGludCBpID0gMDsgaSA8IFZlcnRpY2VzLkNvdW50OyArK2kpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIC8vIFRyaWFuZ2xlIHZlcnRpY2VzLlxyXG4gICAgICAgICAgICAgICAgVmVjdG9yMiBwMSA9IHBSZWY7XHJcbiAgICAgICAgICAgICAgICBWZWN0b3IyIHAyID0gVmVydGljZXNbaV07XHJcbiAgICAgICAgICAgICAgICBWZWN0b3IyIHAzID0gaSArIDEgPCBWZXJ0aWNlcy5Db3VudCA/IFZlcnRpY2VzW2kgKyAxXSA6IFZlcnRpY2VzWzBdO1xyXG5cclxuICAgICAgICAgICAgICAgIFZlY3RvcjIgZTEgPSBwMiAtIHAxO1xyXG4gICAgICAgICAgICAgICAgVmVjdG9yMiBlMiA9IHAzIC0gcDE7XHJcblxyXG4gICAgICAgICAgICAgICAgZmxvYXQgZDtcclxuICAgICAgICAgICAgICAgIE1hdGhVdGlscy5Dcm9zcyhyZWYgZTEsIHJlZiBlMiwgb3V0IGQpO1xyXG5cclxuICAgICAgICAgICAgICAgIGZsb2F0IHRyaWFuZ2xlQXJlYSA9IDAuNWYgKiBkO1xyXG4gICAgICAgICAgICAgICAgYXJlYSArPSB0cmlhbmdsZUFyZWE7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gQXJlYSB3ZWlnaHRlZCBjZW50cm9pZFxyXG4gICAgICAgICAgICAgICAgY2VudGVyICs9IHRyaWFuZ2xlQXJlYSAqIGludjMgKiAocDEgKyBwMiArIHAzKTtcclxuXHJcbiAgICAgICAgICAgICAgICBmbG9hdCBweCA9IHAxLlgsIHB5ID0gcDEuWTtcclxuICAgICAgICAgICAgICAgIGZsb2F0IGV4MSA9IGUxLlgsIGV5MSA9IGUxLlk7XHJcbiAgICAgICAgICAgICAgICBmbG9hdCBleDIgPSBlMi5YLCBleTIgPSBlMi5ZO1xyXG5cclxuICAgICAgICAgICAgICAgIGZsb2F0IGludHgyID0gaW52MyAqICgwLjI1ZiAqIChleDEgKiBleDEgKyBleDIgKiBleDEgKyBleDIgKiBleDIpICsgKHB4ICogZXgxICsgcHggKiBleDIpKSArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDAuNWYgKiBweCAqIHB4O1xyXG4gICAgICAgICAgICAgICAgZmxvYXQgaW50eTIgPSBpbnYzICogKDAuMjVmICogKGV5MSAqIGV5MSArIGV5MiAqIGV5MSArIGV5MiAqIGV5MikgKyAocHkgKiBleTEgKyBweSAqIGV5MikpICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMC41ZiAqIHB5ICogcHk7XHJcblxyXG4gICAgICAgICAgICAgICAgSSArPSBkICogKGludHgyICsgaW50eTIpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvL1RoZSBhcmVhIGlzIHRvbyBzbWFsbCBmb3IgdGhlIGVuZ2luZSB0byBoYW5kbGUuXHJcbiAgICAgICAgICAgIERlYnVnLkFzc2VydChhcmVhID4gU2V0dGluZ3MuRXBzaWxvbik7XHJcblxyXG4gICAgICAgICAgICAvLyBXZSBzYXZlIHRoZSBhcmVhXHJcbiAgICAgICAgICAgIE1hc3NEYXRhLkFyZWEgPSBhcmVhO1xyXG5cclxuICAgICAgICAgICAgLy8gVG90YWwgbWFzc1xyXG4gICAgICAgICAgICBNYXNzRGF0YS5NYXNzID0gX2RlbnNpdHkgKiBhcmVhO1xyXG5cclxuICAgICAgICAgICAgLy8gQ2VudGVyIG9mIG1hc3NcclxuICAgICAgICAgICAgY2VudGVyICo9IDEuMGYgLyBhcmVhO1xyXG4gICAgICAgICAgICBNYXNzRGF0YS5DZW50cm9pZCA9IGNlbnRlcjtcclxuXHJcbiAgICAgICAgICAgIC8vIEluZXJ0aWEgdGVuc29yIHJlbGF0aXZlIHRvIHRoZSBsb2NhbCBvcmlnaW4uXHJcbiAgICAgICAgICAgIE1hc3NEYXRhLkluZXJ0aWEgPSBfZGVuc2l0eSAqIEk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIEJ1aWxkIHZlcnRpY2VzIHRvIHJlcHJlc2VudCBhbiBheGlzLWFsaWduZWQgYm94LlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwiaGFsZldpZHRoXCI+VGhlIGhhbGYtd2lkdGguPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJoYWxmSGVpZ2h0XCI+VGhlIGhhbGYtaGVpZ2h0LjwvcGFyYW0+XHJcbiAgICAgICAgcHVibGljIHZvaWQgU2V0QXNCb3goZmxvYXQgaGFsZldpZHRoLCBmbG9hdCBoYWxmSGVpZ2h0KVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgU2V0KFBvbHlnb25Ub29scy5DcmVhdGVSZWN0YW5nbGUoaGFsZldpZHRoLCBoYWxmSGVpZ2h0KSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIEJ1aWxkIHZlcnRpY2VzIHRvIHJlcHJlc2VudCBhbiBvcmllbnRlZCBib3guXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJoYWxmV2lkdGhcIj5UaGUgaGFsZi13aWR0aC4uPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJoYWxmSGVpZ2h0XCI+VGhlIGhhbGYtaGVpZ2h0LjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwiY2VudGVyXCI+VGhlIGNlbnRlciBvZiB0aGUgYm94IGluIGxvY2FsIGNvb3JkaW5hdGVzLjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwiYW5nbGVcIj5UaGUgcm90YXRpb24gb2YgdGhlIGJveCBpbiBsb2NhbCBjb29yZGluYXRlcy48L3BhcmFtPlxyXG4gICAgICAgIHB1YmxpYyB2b2lkIFNldEFzQm94KGZsb2F0IGhhbGZXaWR0aCwgZmxvYXQgaGFsZkhlaWdodCwgVmVjdG9yMiBjZW50ZXIsIGZsb2F0IGFuZ2xlKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgU2V0KFBvbHlnb25Ub29scy5DcmVhdGVSZWN0YW5nbGUoaGFsZldpZHRoLCBoYWxmSGVpZ2h0LCBjZW50ZXIsIGFuZ2xlKSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIFRlc3QgYSBwb2ludCBmb3IgY29udGFpbm1lbnQgaW4gdGhpcyBzaGFwZS4gVGhpcyBvbmx5IHdvcmtzIGZvciBjb252ZXggc2hhcGVzLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwidHJhbnNmb3JtXCI+VGhlIHNoYXBlIHdvcmxkIHRyYW5zZm9ybS48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cInBvaW50XCI+YSBwb2ludCBpbiB3b3JsZCBjb29yZGluYXRlcy48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cmV0dXJucz5UcnVlIGlmIHRoZSBwb2ludCBpcyBpbnNpZGUgdGhlIHNoYXBlPC9yZXR1cm5zPlxyXG4gICAgICAgIHB1YmxpYyBvdmVycmlkZSBib29sIFRlc3RQb2ludChyZWYgVHJhbnNmb3JtIHRyYW5zZm9ybSwgcmVmIFZlY3RvcjIgcG9pbnQpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBWZWN0b3IyIHBMb2NhbCA9IE1hdGhVdGlscy5NdWx0aXBseVQocmVmIHRyYW5zZm9ybS5SLCBwb2ludCAtIHRyYW5zZm9ybS5Qb3NpdGlvbik7XHJcblxyXG4gICAgICAgICAgICBmb3IgKGludCBpID0gMDsgaSA8IFZlcnRpY2VzLkNvdW50OyArK2kpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGZsb2F0IGRvdCA9IFZlY3RvcjIuRG90KE5vcm1hbHNbaV0sIHBMb2NhbCAtIFZlcnRpY2VzW2ldKTtcclxuICAgICAgICAgICAgICAgIGlmIChkb3QgPiAwLjBmKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIENhc3QgYSByYXkgYWdhaW5zdCBhIGNoaWxkIHNoYXBlLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwib3V0cHV0XCI+VGhlIHJheS1jYXN0IHJlc3VsdHMuPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJpbnB1dFwiPlRoZSByYXktY2FzdCBpbnB1dCBwYXJhbWV0ZXJzLjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwidHJhbnNmb3JtXCI+VGhlIHRyYW5zZm9ybSB0byBiZSBhcHBsaWVkIHRvIHRoZSBzaGFwZS48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cImNoaWxkSW5kZXhcIj5UaGUgY2hpbGQgc2hhcGUgaW5kZXguPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHJldHVybnM+VHJ1ZSBpZiB0aGUgcmF5LWNhc3QgaGl0cyB0aGUgc2hhcGU8L3JldHVybnM+XHJcbiAgICAgICAgcHVibGljIG92ZXJyaWRlIGJvb2wgUmF5Q2FzdChvdXQgUmF5Q2FzdE91dHB1dCBvdXRwdXQsIHJlZiBSYXlDYXN0SW5wdXQgaW5wdXQsIHJlZiBUcmFuc2Zvcm0gdHJhbnNmb3JtLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW50IGNoaWxkSW5kZXgpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBvdXRwdXQgPSBuZXcgUmF5Q2FzdE91dHB1dCgpO1xyXG5cclxuICAgICAgICAgICAgLy8gUHV0IHRoZSByYXkgaW50byB0aGUgcG9seWdvbidzIGZyYW1lIG9mIHJlZmVyZW5jZS5cclxuICAgICAgICAgICAgVmVjdG9yMiBwMSA9IE1hdGhVdGlscy5NdWx0aXBseVQocmVmIHRyYW5zZm9ybS5SLCBpbnB1dC5Qb2ludDEgLSB0cmFuc2Zvcm0uUG9zaXRpb24pO1xyXG4gICAgICAgICAgICBWZWN0b3IyIHAyID0gTWF0aFV0aWxzLk11bHRpcGx5VChyZWYgdHJhbnNmb3JtLlIsIGlucHV0LlBvaW50MiAtIHRyYW5zZm9ybS5Qb3NpdGlvbik7XHJcbiAgICAgICAgICAgIFZlY3RvcjIgZCA9IHAyIC0gcDE7XHJcblxyXG4gICAgICAgICAgICBmbG9hdCBsb3dlciA9IDAuMGYsIHVwcGVyID0gaW5wdXQuTWF4RnJhY3Rpb247XHJcblxyXG4gICAgICAgICAgICBpbnQgaW5kZXggPSAtMTtcclxuXHJcbiAgICAgICAgICAgIGZvciAoaW50IGkgPSAwOyBpIDwgVmVydGljZXMuQ291bnQ7ICsraSlcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgLy8gcCA9IHAxICsgYSAqIGRcclxuICAgICAgICAgICAgICAgIC8vIGRvdChub3JtYWwsIHAgLSB2KSA9IDBcclxuICAgICAgICAgICAgICAgIC8vIGRvdChub3JtYWwsIHAxIC0gdikgKyBhICogZG90KG5vcm1hbCwgZCkgPSAwXHJcbiAgICAgICAgICAgICAgICBmbG9hdCBudW1lcmF0b3IgPSBWZWN0b3IyLkRvdChOb3JtYWxzW2ldLCBWZXJ0aWNlc1tpXSAtIHAxKTtcclxuICAgICAgICAgICAgICAgIGZsb2F0IGRlbm9taW5hdG9yID0gVmVjdG9yMi5Eb3QoTm9ybWFsc1tpXSwgZCk7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKGRlbm9taW5hdG9yID09IDAuMGYpXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG51bWVyYXRvciA8IDAuMGYpXHJcbiAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIE5vdGU6IHdlIHdhbnQgdGhpcyBwcmVkaWNhdGUgd2l0aG91dCBkaXZpc2lvbjpcclxuICAgICAgICAgICAgICAgICAgICAvLyBsb3dlciA8IG51bWVyYXRvciAvIGRlbm9taW5hdG9yLCB3aGVyZSBkZW5vbWluYXRvciA8IDBcclxuICAgICAgICAgICAgICAgICAgICAvLyBTaW5jZSBkZW5vbWluYXRvciA8IDAsIHdlIGhhdmUgdG8gZmxpcCB0aGUgaW5lcXVhbGl0eTpcclxuICAgICAgICAgICAgICAgICAgICAvLyBsb3dlciA8IG51bWVyYXRvciAvIGRlbm9taW5hdG9yIDw9PT4gZGVub21pbmF0b3IgKiBsb3dlciA+IG51bWVyYXRvci5cclxuICAgICAgICAgICAgICAgICAgICBpZiAoZGVub21pbmF0b3IgPCAwLjBmICYmIG51bWVyYXRvciA8IGxvd2VyICogZGVub21pbmF0b3IpXHJcbiAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBJbmNyZWFzZSBsb3dlci5cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGhlIHNlZ21lbnQgZW50ZXJzIHRoaXMgaGFsZi1zcGFjZS5cclxuICAgICAgICAgICAgICAgICAgICAgICAgbG93ZXIgPSBudW1lcmF0b3IgLyBkZW5vbWluYXRvcjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXggPSBpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChkZW5vbWluYXRvciA+IDAuMGYgJiYgbnVtZXJhdG9yIDwgdXBwZXIgKiBkZW5vbWluYXRvcilcclxuICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIERlY3JlYXNlIHVwcGVyLlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGUgc2VnbWVudCBleGl0cyB0aGlzIGhhbGYtc3BhY2UuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHVwcGVyID0gbnVtZXJhdG9yIC8gZGVub21pbmF0b3I7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIC8vIFRoZSB1c2Ugb2YgZXBzaWxvbiBoZXJlIGNhdXNlcyB0aGUgYXNzZXJ0IG9uIGxvd2VyIHRvIHRyaXBcclxuICAgICAgICAgICAgICAgIC8vIGluIHNvbWUgY2FzZXMuIEFwcGFyZW50bHkgdGhlIHVzZSBvZiBlcHNpbG9uIHdhcyB0byBtYWtlIGVkZ2VcclxuICAgICAgICAgICAgICAgIC8vIHNoYXBlcyB3b3JrLCBidXQgbm93IHRob3NlIGFyZSBoYW5kbGVkIHNlcGFyYXRlbHkuXHJcbiAgICAgICAgICAgICAgICAvL2lmICh1cHBlciA8IGxvd2VyIC0gYjJfZXBzaWxvbilcclxuICAgICAgICAgICAgICAgIGlmICh1cHBlciA8IGxvd2VyKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgRGVidWcuQXNzZXJ0KDAuMGYgPD0gbG93ZXIgJiYgbG93ZXIgPD0gaW5wdXQuTWF4RnJhY3Rpb24pO1xyXG5cclxuICAgICAgICAgICAgaWYgKGluZGV4ID49IDApXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIG91dHB1dC5GcmFjdGlvbiA9IGxvd2VyO1xyXG4gICAgICAgICAgICAgICAgb3V0cHV0Lk5vcm1hbCA9IE1hdGhVdGlscy5NdWx0aXBseShyZWYgdHJhbnNmb3JtLlIsIE5vcm1hbHNbaW5kZXhdKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIEdpdmVuIGEgdHJhbnNmb3JtLCBjb21wdXRlIHRoZSBhc3NvY2lhdGVkIGF4aXMgYWxpZ25lZCBib3VuZGluZyBib3ggZm9yIGEgY2hpbGQgc2hhcGUuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJhYWJiXCI+VGhlIGFhYmIgcmVzdWx0cy48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cInRyYW5zZm9ybVwiPlRoZSB3b3JsZCB0cmFuc2Zvcm0gb2YgdGhlIHNoYXBlLjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwiY2hpbGRJbmRleFwiPlRoZSBjaGlsZCBzaGFwZSBpbmRleC48L3BhcmFtPlxyXG4gICAgICAgIHB1YmxpYyBvdmVycmlkZSB2b2lkIENvbXB1dGVBQUJCKG91dCBBQUJCIGFhYmIsIHJlZiBUcmFuc2Zvcm0gdHJhbnNmb3JtLCBpbnQgY2hpbGRJbmRleClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIFZlY3RvcjIgbG93ZXIgPSBNYXRoVXRpbHMuTXVsdGlwbHkocmVmIHRyYW5zZm9ybSwgVmVydGljZXNbMF0pO1xyXG4gICAgICAgICAgICBWZWN0b3IyIHVwcGVyID0gbG93ZXI7XHJcblxyXG4gICAgICAgICAgICBmb3IgKGludCBpID0gMTsgaSA8IFZlcnRpY2VzLkNvdW50OyArK2kpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIFZlY3RvcjIgdiA9IE1hdGhVdGlscy5NdWx0aXBseShyZWYgdHJhbnNmb3JtLCBWZXJ0aWNlc1tpXSk7XHJcbiAgICAgICAgICAgICAgICBsb3dlciA9IFZlY3RvcjIuTWluKGxvd2VyLCB2KTtcclxuICAgICAgICAgICAgICAgIHVwcGVyID0gVmVjdG9yMi5NYXgodXBwZXIsIHYpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBWZWN0b3IyIHIgPSBuZXcgVmVjdG9yMihSYWRpdXMsIFJhZGl1cyk7XHJcbiAgICAgICAgICAgIGFhYmIuTG93ZXJCb3VuZCA9IGxvd2VyIC0gcjtcclxuICAgICAgICAgICAgYWFiYi5VcHBlckJvdW5kID0gdXBwZXIgKyByO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHVibGljIGJvb2wgQ29tcGFyZVRvKFBvbHlnb25TaGFwZSBzaGFwZSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGlmIChWZXJ0aWNlcy5Db3VudCAhPSBzaGFwZS5WZXJ0aWNlcy5Db3VudClcclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuXHJcbiAgICAgICAgICAgIGZvciAoaW50IGkgPSAwOyBpIDwgVmVydGljZXMuQ291bnQ7IGkrKylcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgaWYgKFZlcnRpY2VzW2ldICE9IHNoYXBlLlZlcnRpY2VzW2ldKVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuIChSYWRpdXMgPT0gc2hhcGUuUmFkaXVzICYmXHJcbiAgICAgICAgICAgICAgICAgICAgTWFzc0RhdGEgPT0gc2hhcGUuTWFzc0RhdGEpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHVibGljIG92ZXJyaWRlIGZsb2F0IENvbXB1dGVTdWJtZXJnZWRBcmVhKFZlY3RvcjIgbm9ybWFsLCBmbG9hdCBvZmZzZXQsIFRyYW5zZm9ybSB4Ziwgb3V0IFZlY3RvcjIgc2MpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBzYyA9IFZlY3RvcjIuWmVybztcclxuXHJcbiAgICAgICAgICAgIC8vVHJhbnNmb3JtIHBsYW5lIGludG8gc2hhcGUgY28tb3JkaW5hdGVzXHJcbiAgICAgICAgICAgIFZlY3RvcjIgbm9ybWFsTCA9IE1hdGhVdGlscy5NdWx0aXBseVQocmVmIHhmLlIsIG5vcm1hbCk7XHJcbiAgICAgICAgICAgIGZsb2F0IG9mZnNldEwgPSBvZmZzZXQgLSBWZWN0b3IyLkRvdChub3JtYWwsIHhmLlBvc2l0aW9uKTtcclxuXHJcbiAgICAgICAgICAgIGZsb2F0W10gZGVwdGhzID0gbmV3IGZsb2F0W1NldHRpbmdzLk1heFBvbHlnb25WZXJ0aWNlc107XHJcbiAgICAgICAgICAgIGludCBkaXZlQ291bnQgPSAwO1xyXG4gICAgICAgICAgICBpbnQgaW50b0luZGV4ID0gLTE7XHJcbiAgICAgICAgICAgIGludCBvdXRvSW5kZXggPSAtMTtcclxuXHJcbiAgICAgICAgICAgIGJvb2wgbGFzdFN1Ym1lcmdlZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICBpbnQgaTtcclxuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IFZlcnRpY2VzLkNvdW50OyBpKyspXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGRlcHRoc1tpXSA9IFZlY3RvcjIuRG90KG5vcm1hbEwsIFZlcnRpY2VzW2ldKSAtIG9mZnNldEw7XHJcbiAgICAgICAgICAgICAgICBib29sIGlzU3VibWVyZ2VkID0gZGVwdGhzW2ldIDwgLVNldHRpbmdzLkVwc2lsb247XHJcbiAgICAgICAgICAgICAgICBpZiAoaSA+IDApXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzU3VibWVyZ2VkKVxyXG4gICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFsYXN0U3VibWVyZ2VkKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnRvSW5kZXggPSBpIC0gMTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRpdmVDb3VudCsrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChsYXN0U3VibWVyZ2VkKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdXRvSW5kZXggPSBpIC0gMTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRpdmVDb3VudCsrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgbGFzdFN1Ym1lcmdlZCA9IGlzU3VibWVyZ2VkO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHN3aXRjaCAoZGl2ZUNvdW50KVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDA6XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGxhc3RTdWJtZXJnZWQpXHJcbiAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvL0NvbXBsZXRlbHkgc3VibWVyZ2VkXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNjID0gTWF0aFV0aWxzLk11bHRpcGx5KHJlZiB4ZiwgTWFzc0RhdGEuQ2VudHJvaWQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gTWFzc0RhdGEuTWFzcyAvIERlbnNpdHk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vQ29tcGxldGVseSBkcnlcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDA7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSAxOlxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChpbnRvSW5kZXggPT0gLTEpXHJcbiAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpbnRvSW5kZXggPSBWZXJ0aWNlcy5Db3VudCAtIDE7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG91dG9JbmRleCA9IFZlcnRpY2VzLkNvdW50IC0gMTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaW50IGludG9JbmRleDIgPSAoaW50b0luZGV4ICsgMSkgJSBWZXJ0aWNlcy5Db3VudDtcclxuICAgICAgICAgICAgaW50IG91dG9JbmRleDIgPSAob3V0b0luZGV4ICsgMSkgJSBWZXJ0aWNlcy5Db3VudDtcclxuXHJcbiAgICAgICAgICAgIGZsb2F0IGludG9MYW1iZGEgPSAoMCAtIGRlcHRoc1tpbnRvSW5kZXhdKSAvIChkZXB0aHNbaW50b0luZGV4Ml0gLSBkZXB0aHNbaW50b0luZGV4XSk7XHJcbiAgICAgICAgICAgIGZsb2F0IG91dG9MYW1iZGEgPSAoMCAtIGRlcHRoc1tvdXRvSW5kZXhdKSAvIChkZXB0aHNbb3V0b0luZGV4Ml0gLSBkZXB0aHNbb3V0b0luZGV4XSk7XHJcblxyXG4gICAgICAgICAgICBWZWN0b3IyIGludG9WZWMgPSBuZXcgVmVjdG9yMihcclxuICAgICAgICAgICAgICAgIFZlcnRpY2VzW2ludG9JbmRleF0uWCAqICgxIC0gaW50b0xhbWJkYSkgKyBWZXJ0aWNlc1tpbnRvSW5kZXgyXS5YICogaW50b0xhbWJkYSxcclxuICAgICAgICAgICAgICAgIFZlcnRpY2VzW2ludG9JbmRleF0uWSAqICgxIC0gaW50b0xhbWJkYSkgKyBWZXJ0aWNlc1tpbnRvSW5kZXgyXS5ZICogaW50b0xhbWJkYSk7XHJcbiAgICAgICAgICAgIFZlY3RvcjIgb3V0b1ZlYyA9IG5ldyBWZWN0b3IyKFxyXG4gICAgICAgICAgICAgICAgVmVydGljZXNbb3V0b0luZGV4XS5YICogKDEgLSBvdXRvTGFtYmRhKSArIFZlcnRpY2VzW291dG9JbmRleDJdLlggKiBvdXRvTGFtYmRhLFxyXG4gICAgICAgICAgICAgICAgVmVydGljZXNbb3V0b0luZGV4XS5ZICogKDEgLSBvdXRvTGFtYmRhKSArIFZlcnRpY2VzW291dG9JbmRleDJdLlkgKiBvdXRvTGFtYmRhKTtcclxuXHJcbiAgICAgICAgICAgIC8vSW5pdGlhbGl6ZSBhY2N1bXVsYXRvclxyXG4gICAgICAgICAgICBmbG9hdCBhcmVhID0gMDtcclxuICAgICAgICAgICAgVmVjdG9yMiBjZW50ZXIgPSBuZXcgVmVjdG9yMigwLCAwKTtcclxuICAgICAgICAgICAgVmVjdG9yMiBwMiA9IFZlcnRpY2VzW2ludG9JbmRleDJdO1xyXG4gICAgICAgICAgICBWZWN0b3IyIHAzO1xyXG5cclxuICAgICAgICAgICAgZmxvYXQga19pbnYzID0gMS4wZiAvIDMuMGY7XHJcblxyXG4gICAgICAgICAgICAvL0FuIGF3a3dhcmQgbG9vcCBmcm9tIGludG9JbmRleDIrMSB0byBvdXRJbmRleDJcclxuICAgICAgICAgICAgaSA9IGludG9JbmRleDI7XHJcbiAgICAgICAgICAgIHdoaWxlIChpICE9IG91dG9JbmRleDIpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGkgPSAoaSArIDEpICUgVmVydGljZXMuQ291bnQ7XHJcbiAgICAgICAgICAgICAgICBpZiAoaSA9PSBvdXRvSW5kZXgyKVxyXG4gICAgICAgICAgICAgICAgICAgIHAzID0gb3V0b1ZlYztcclxuICAgICAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgICAgICBwMyA9IFZlcnRpY2VzW2ldO1xyXG4gICAgICAgICAgICAgICAgLy9BZGQgdGhlIHRyaWFuZ2xlIGZvcm1lZCBieSBpbnRvVmVjLHAyLHAzXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgVmVjdG9yMiBlMSA9IHAyIC0gaW50b1ZlYztcclxuICAgICAgICAgICAgICAgICAgICBWZWN0b3IyIGUyID0gcDMgLSBpbnRvVmVjO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBmbG9hdCBEID0gTWF0aFV0aWxzLkNyb3NzKGUxLCBlMik7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGZsb2F0IHRyaWFuZ2xlQXJlYSA9IDAuNWYgKiBEO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBhcmVhICs9IHRyaWFuZ2xlQXJlYTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gQXJlYSB3ZWlnaHRlZCBjZW50cm9pZFxyXG4gICAgICAgICAgICAgICAgICAgIGNlbnRlciArPSB0cmlhbmdsZUFyZWEgKiBrX2ludjMgKiAoaW50b1ZlYyArIHAyICsgcDMpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLy9cclxuICAgICAgICAgICAgICAgIHAyID0gcDM7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vTm9ybWFsaXplIGFuZCB0cmFuc2Zvcm0gY2VudHJvaWRcclxuICAgICAgICAgICAgY2VudGVyICo9IDEuMGYgLyBhcmVhO1xyXG5cclxuICAgICAgICAgICAgc2MgPSBNYXRoVXRpbHMuTXVsdGlwbHkocmVmIHhmLCBjZW50ZXIpO1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIGFyZWE7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59IiwidXNpbmcgU3lzdGVtO1xyXG51c2luZyBTeXN0ZW0uRGlhZ25vc3RpY3M7XHJcbnVzaW5nIE1pY3Jvc29mdC5YbmEuRnJhbWV3b3JrO1xyXG5cclxubmFtZXNwYWNlIEZhcnNlZXJQaHlzaWNzLkR5bmFtaWNzLkpvaW50c1xyXG57XHJcbiAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAvLy8gTWFpbnRhaW5zIGEgZml4ZWQgYW5nbGUgYmV0d2VlbiB0d28gYm9kaWVzXHJcbiAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgcHVibGljIGNsYXNzIEFuZ2xlSm9pbnQgOiBKb2ludFxyXG4gICAge1xyXG4gICAgICAgIHB1YmxpYyBmbG9hdCBCaWFzRmFjdG9yO1xyXG4gICAgICAgIHB1YmxpYyBmbG9hdCBNYXhJbXB1bHNlO1xyXG4gICAgICAgIHB1YmxpYyBmbG9hdCBTb2Z0bmVzcztcclxuICAgICAgICBwcml2YXRlIGZsb2F0IF9iaWFzO1xyXG4gICAgICAgIHByaXZhdGUgZmxvYXQgX2pvaW50RXJyb3I7XHJcbiAgICAgICAgcHJpdmF0ZSBmbG9hdCBfbWFzc0ZhY3RvcjtcclxuICAgICAgICBwcml2YXRlIGZsb2F0IF90YXJnZXRBbmdsZTtcclxuXHJcbiAgICAgICAgaW50ZXJuYWwgQW5nbGVKb2ludCgpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBKb2ludFR5cGUgPSBKb2ludFR5cGUuQW5nbGU7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwdWJsaWMgQW5nbGVKb2ludChCb2R5IGJvZHlBLCBCb2R5IGJvZHlCKVxyXG4gICAgICAgICAgICA6IGJhc2UoYm9keUEsIGJvZHlCKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgSm9pbnRUeXBlID0gSm9pbnRUeXBlLkFuZ2xlO1xyXG4gICAgICAgICAgICBUYXJnZXRBbmdsZSA9IDA7XHJcbiAgICAgICAgICAgIEJpYXNGYWN0b3IgPSAuMmY7XHJcbiAgICAgICAgICAgIFNvZnRuZXNzID0gMGY7XHJcbiAgICAgICAgICAgIE1heEltcHVsc2UgPSBmbG9hdC5NYXhWYWx1ZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHB1YmxpYyBmbG9hdCBUYXJnZXRBbmdsZVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgZ2V0IHsgcmV0dXJuIF90YXJnZXRBbmdsZTsgfVxyXG4gICAgICAgICAgICBzZXRcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlICE9IF90YXJnZXRBbmdsZSlcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBfdGFyZ2V0QW5nbGUgPSB2YWx1ZTtcclxuICAgICAgICAgICAgICAgICAgICBXYWtlQm9kaWVzKCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHB1YmxpYyBvdmVycmlkZSBWZWN0b3IyIFdvcmxkQW5jaG9yQVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgZ2V0IHsgcmV0dXJuIEJvZHlBLlBvc2l0aW9uOyB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwdWJsaWMgb3ZlcnJpZGUgVmVjdG9yMiBXb3JsZEFuY2hvckJcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGdldCB7IHJldHVybiBCb2R5Qi5Qb3NpdGlvbjsgfVxyXG4gICAgICAgICAgICBzZXQgeyBEZWJ1Zy5Bc3NlcnQoZmFsc2UsIFwiWW91IGNhbid0IHNldCB0aGUgd29ybGQgYW5jaG9yIG9uIHRoaXMgam9pbnQgdHlwZS5cIik7IH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHB1YmxpYyBvdmVycmlkZSBWZWN0b3IyIEdldFJlYWN0aW9uRm9yY2UoZmxvYXQgaW52X2R0KVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgLy9UT0RPXHJcbiAgICAgICAgICAgIC8vcmV0dXJuIF9pbnZfZHQgKiBfaW1wdWxzZTtcclxuICAgICAgICAgICAgcmV0dXJuIFZlY3RvcjIuWmVybztcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHB1YmxpYyBvdmVycmlkZSBmbG9hdCBHZXRSZWFjdGlvblRvcnF1ZShmbG9hdCBpbnZfZHQpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gMDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGludGVybmFsIG92ZXJyaWRlIHZvaWQgSW5pdFZlbG9jaXR5Q29uc3RyYWludHMocmVmIFRpbWVTdGVwIHN0ZXApXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBfam9pbnRFcnJvciA9IChCb2R5Qi5Td2VlcC5BIC0gQm9keUEuU3dlZXAuQSAtIFRhcmdldEFuZ2xlKTtcclxuXHJcbiAgICAgICAgICAgIF9iaWFzID0gLUJpYXNGYWN0b3IgKiBzdGVwLmludl9kdCAqIF9qb2ludEVycm9yO1xyXG5cclxuICAgICAgICAgICAgX21hc3NGYWN0b3IgPSAoMSAtIFNvZnRuZXNzKSAvIChCb2R5QS5JbnZJICsgQm9keUIuSW52SSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpbnRlcm5hbCBvdmVycmlkZSB2b2lkIFNvbHZlVmVsb2NpdHlDb25zdHJhaW50cyhyZWYgVGltZVN0ZXAgc3RlcClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGZsb2F0IHAgPSAoX2JpYXMgLSBCb2R5Qi5Bbmd1bGFyVmVsb2NpdHkgKyBCb2R5QS5Bbmd1bGFyVmVsb2NpdHkpICogX21hc3NGYWN0b3I7XHJcbiAgICAgICAgICAgIEJvZHlBLkFuZ3VsYXJWZWxvY2l0eSAtPSBCb2R5QS5JbnZJICogTWF0aC5TaWduKHApICogTWF0aC5NaW4oKGZsb2F0KU1hdGguQWJzKHApLCBNYXhJbXB1bHNlKTtcclxuICAgICAgICAgICAgQm9keUIuQW5ndWxhclZlbG9jaXR5ICs9IEJvZHlCLkludkkgKiBNYXRoLlNpZ24ocCkgKiBNYXRoLk1pbigoZmxvYXQpTWF0aC5BYnMocCksIE1heEltcHVsc2UpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaW50ZXJuYWwgb3ZlcnJpZGUgYm9vbCBTb2x2ZVBvc2l0aW9uQ29uc3RyYWludHMoKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgLy9ubyBwb3NpdGlvbiBzb2x2aW5nIGZvciB0aGlzIGpvaW50XHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufSIsIi8qXHJcbiogRmFyc2VlciBQaHlzaWNzIEVuZ2luZSBiYXNlZCBvbiBCb3gyRC5YTkEgcG9ydDpcclxuKiBDb3B5cmlnaHQgKGMpIDIwMTAgSWFuIFF2aXN0XHJcbiogXHJcbiogQm94MkQuWE5BIHBvcnQgb2YgQm94MkQ6XHJcbiogQ29weXJpZ2h0IChjKSAyMDA5IEJyYW5kb24gRnVydHdhbmdsZXIsIE5hdGhhbiBGdXJ0d2FuZ2xlclxyXG4qXHJcbiogT3JpZ2luYWwgc291cmNlIEJveDJEOlxyXG4qIENvcHlyaWdodCAoYykgMjAwNi0yMDA5IEVyaW4gQ2F0dG8gaHR0cDovL3d3dy5ncGh5c2ljcy5jb20gXHJcbiogXHJcbiogVGhpcyBzb2Z0d2FyZSBpcyBwcm92aWRlZCAnYXMtaXMnLCB3aXRob3V0IGFueSBleHByZXNzIG9yIGltcGxpZWQgXHJcbiogd2FycmFudHkuICBJbiBubyBldmVudCB3aWxsIHRoZSBhdXRob3JzIGJlIGhlbGQgbGlhYmxlIGZvciBhbnkgZGFtYWdlcyBcclxuKiBhcmlzaW5nIGZyb20gdGhlIHVzZSBvZiB0aGlzIHNvZnR3YXJlLiBcclxuKiBQZXJtaXNzaW9uIGlzIGdyYW50ZWQgdG8gYW55b25lIHRvIHVzZSB0aGlzIHNvZnR3YXJlIGZvciBhbnkgcHVycG9zZSwgXHJcbiogaW5jbHVkaW5nIGNvbW1lcmNpYWwgYXBwbGljYXRpb25zLCBhbmQgdG8gYWx0ZXIgaXQgYW5kIHJlZGlzdHJpYnV0ZSBpdCBcclxuKiBmcmVlbHksIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyByZXN0cmljdGlvbnM6IFxyXG4qIDEuIFRoZSBvcmlnaW4gb2YgdGhpcyBzb2Z0d2FyZSBtdXN0IG5vdCBiZSBtaXNyZXByZXNlbnRlZDsgeW91IG11c3Qgbm90IFxyXG4qIGNsYWltIHRoYXQgeW91IHdyb3RlIHRoZSBvcmlnaW5hbCBzb2Z0d2FyZS4gSWYgeW91IHVzZSB0aGlzIHNvZnR3YXJlIFxyXG4qIGluIGEgcHJvZHVjdCwgYW4gYWNrbm93bGVkZ21lbnQgaW4gdGhlIHByb2R1Y3QgZG9jdW1lbnRhdGlvbiB3b3VsZCBiZSBcclxuKiBhcHByZWNpYXRlZCBidXQgaXMgbm90IHJlcXVpcmVkLiBcclxuKiAyLiBBbHRlcmVkIHNvdXJjZSB2ZXJzaW9ucyBtdXN0IGJlIHBsYWlubHkgbWFya2VkIGFzIHN1Y2gsIGFuZCBtdXN0IG5vdCBiZSBcclxuKiBtaXNyZXByZXNlbnRlZCBhcyBiZWluZyB0aGUgb3JpZ2luYWwgc29mdHdhcmUuIFxyXG4qIDMuIFRoaXMgbm90aWNlIG1heSBub3QgYmUgcmVtb3ZlZCBvciBhbHRlcmVkIGZyb20gYW55IHNvdXJjZSBkaXN0cmlidXRpb24uIFxyXG4qL1xyXG5cclxudXNpbmcgU3lzdGVtO1xyXG51c2luZyBTeXN0ZW0uRGlhZ25vc3RpY3M7XHJcbnVzaW5nIEZhcnNlZXJQaHlzaWNzLkNvbW1vbjtcclxudXNpbmcgTWljcm9zb2Z0LlhuYS5GcmFtZXdvcms7XHJcblxyXG5uYW1lc3BhY2UgRmFyc2VlclBoeXNpY3MuRHluYW1pY3MuSm9pbnRzXHJcbntcclxuICAgIC8vIDEtRCByYWluZWQgc3lzdGVtXHJcbiAgICAvLyBtICh2MiAtIHYxKSA9IGxhbWJkYVxyXG4gICAgLy8gdjIgKyAoYmV0YS9oKSAqIHgxICsgZ2FtbWEgKiBsYW1iZGEgPSAwLCBnYW1tYSBoYXMgdW5pdHMgb2YgaW52ZXJzZSBtYXNzLlxyXG4gICAgLy8geDIgPSB4MSArIGggKiB2MlxyXG5cclxuICAgIC8vIDEtRCBtYXNzLWRhbXBlci1zcHJpbmcgc3lzdGVtXHJcbiAgICAvLyBtICh2MiAtIHYxKSArIGggKiBkICogdjIgKyBoICogayAqIFxyXG5cclxuICAgIC8vIEMgPSBub3JtKHAyIC0gcDEpIC0gTFxyXG4gICAgLy8gdSA9IChwMiAtIHAxKSAvIG5vcm0ocDIgLSBwMSlcclxuICAgIC8vIENkb3QgPSBkb3QodSwgdjIgKyBjcm9zcyh3MiwgcjIpIC0gdjEgLSBjcm9zcyh3MSwgcjEpKVxyXG4gICAgLy8gSiA9IFstdSAtY3Jvc3MocjEsIHUpIHUgY3Jvc3MocjIsIHUpXVxyXG4gICAgLy8gSyA9IEogKiBpbnZNICogSlRcclxuICAgIC8vICAgPSBpbnZNYXNzMSArIGludkkxICogY3Jvc3MocjEsIHUpXjIgKyBpbnZNYXNzMiArIGludkkyICogY3Jvc3MocjIsIHUpXjJcclxuXHJcbiAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAvLy8gQSBkaXN0YW5jZSBqb2ludCByYWlucyB0d28gcG9pbnRzIG9uIHR3byBib2RpZXNcclxuICAgIC8vLyB0byByZW1haW4gYXQgYSBmaXhlZCBkaXN0YW5jZSBmcm9tIGVhY2ggb3RoZXIuIFlvdSBjYW4gdmlld1xyXG4gICAgLy8vIHRoaXMgYXMgYSBtYXNzbGVzcywgcmlnaWQgcm9kLlxyXG4gICAgLy8vIDwvc3VtbWFyeT5cclxuICAgIHB1YmxpYyBjbGFzcyBEaXN0YW5jZUpvaW50IDogSm9pbnRcclxuICAgIHtcclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIFRoZSBsb2NhbCBhbmNob3IgcG9pbnQgcmVsYXRpdmUgdG8gYm9keUEncyBvcmlnaW4uXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICBwdWJsaWMgVmVjdG9yMiBMb2NhbEFuY2hvckE7XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gVGhlIGxvY2FsIGFuY2hvciBwb2ludCByZWxhdGl2ZSB0byBib2R5QidzIG9yaWdpbi5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIHB1YmxpYyBWZWN0b3IyIExvY2FsQW5jaG9yQjtcclxuXHJcbiAgICAgICAgcHJpdmF0ZSBmbG9hdCBfYmlhcztcclxuICAgICAgICBwcml2YXRlIGZsb2F0IF9nYW1tYTtcclxuICAgICAgICBwcml2YXRlIGZsb2F0IF9pbXB1bHNlO1xyXG4gICAgICAgIHByaXZhdGUgZmxvYXQgX21hc3M7XHJcbiAgICAgICAgcHJpdmF0ZSBmbG9hdCBfdG1wRmxvYXQxO1xyXG4gICAgICAgIHByaXZhdGUgVmVjdG9yMiBfdG1wVmVjdG9yMTtcclxuICAgICAgICBwcml2YXRlIFZlY3RvcjIgX3U7XHJcblxyXG4gICAgICAgIGludGVybmFsIERpc3RhbmNlSm9pbnQoKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgSm9pbnRUeXBlID0gSm9pbnRUeXBlLkRpc3RhbmNlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBUaGlzIHJlcXVpcmVzIGRlZmluaW5nIGFuXHJcbiAgICAgICAgLy8vIGFuY2hvciBwb2ludCBvbiBib3RoIGJvZGllcyBhbmQgdGhlIG5vbi16ZXJvIGxlbmd0aCBvZiB0aGVcclxuICAgICAgICAvLy8gZGlzdGFuY2Ugam9pbnQuIElmIHlvdSBkb24ndCBzdXBwbHkgYSBsZW5ndGgsIHRoZSBsb2NhbCBhbmNob3IgcG9pbnRzXHJcbiAgICAgICAgLy8vIGlzIHVzZWQgc28gdGhhdCB0aGUgaW5pdGlhbCBjb25maWd1cmF0aW9uIGNhbiB2aW9sYXRlIHRoZSBjb25zdHJhaW50XHJcbiAgICAgICAgLy8vIHNsaWdodGx5LiBUaGlzIGhlbHBzIHdoZW4gc2F2aW5nIGFuZCBsb2FkaW5nIGEgZ2FtZS5cclxuICAgICAgICAvLy8gQHdhcm5pbmcgRG8gbm90IHVzZSBhIHplcm8gb3Igc2hvcnQgbGVuZ3RoLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwiYm9keUFcIj5UaGUgZmlyc3QgYm9keTwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwiYm9keUJcIj5UaGUgc2Vjb25kIGJvZHk8L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cImxvY2FsQW5jaG9yQVwiPlRoZSBmaXJzdCBib2R5IGFuY2hvcjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwibG9jYWxBbmNob3JCXCI+VGhlIHNlY29uZCBib2R5IGFuY2hvcjwvcGFyYW0+XHJcbiAgICAgICAgcHVibGljIERpc3RhbmNlSm9pbnQoQm9keSBib2R5QSwgQm9keSBib2R5QiwgVmVjdG9yMiBsb2NhbEFuY2hvckEsIFZlY3RvcjIgbG9jYWxBbmNob3JCKVxyXG4gICAgICAgICAgICA6IGJhc2UoYm9keUEsIGJvZHlCKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgSm9pbnRUeXBlID0gSm9pbnRUeXBlLkRpc3RhbmNlO1xyXG5cclxuICAgICAgICAgICAgTG9jYWxBbmNob3JBID0gbG9jYWxBbmNob3JBO1xyXG4gICAgICAgICAgICBMb2NhbEFuY2hvckIgPSBsb2NhbEFuY2hvckI7XHJcblxyXG4gICAgICAgICAgICBWZWN0b3IyIGQgPSBXb3JsZEFuY2hvckIgLSBXb3JsZEFuY2hvckE7XHJcbiAgICAgICAgICAgIExlbmd0aCA9IGQuTGVuZ3RoKCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIFRoZSBuYXR1cmFsIGxlbmd0aCBiZXR3ZWVuIHRoZSBhbmNob3IgcG9pbnRzLlxyXG4gICAgICAgIC8vLyBNYW5pcHVsYXRpbmcgdGhlIGxlbmd0aCBjYW4gbGVhZCB0byBub24tcGh5c2ljYWwgYmVoYXZpb3Igd2hlbiB0aGUgZnJlcXVlbmN5IGlzIHplcm8uXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICBwdWJsaWMgZmxvYXQgTGVuZ3RoIHsgZ2V0OyBzZXQ7IH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBUaGUgbWFzcy1zcHJpbmctZGFtcGVyIGZyZXF1ZW5jeSBpbiBIZXJ0ei5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIHB1YmxpYyBmbG9hdCBGcmVxdWVuY3kgeyBnZXQ7IHNldDsgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIFRoZSBkYW1waW5nIHJhdGlvLiAwID0gbm8gZGFtcGluZywgMSA9IGNyaXRpY2FsIGRhbXBpbmcuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICBwdWJsaWMgZmxvYXQgRGFtcGluZ1JhdGlvIHsgZ2V0OyBzZXQ7IH1cclxuXHJcbiAgICAgICAgcHVibGljIG92ZXJyaWRlIHNlYWxlZCBWZWN0b3IyIFdvcmxkQW5jaG9yQVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgZ2V0IHsgcmV0dXJuIEJvZHlBLkdldFdvcmxkUG9pbnQoTG9jYWxBbmNob3JBKTsgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHVibGljIG92ZXJyaWRlIHNlYWxlZCBWZWN0b3IyIFdvcmxkQW5jaG9yQlxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgZ2V0IHsgcmV0dXJuIEJvZHlCLkdldFdvcmxkUG9pbnQoTG9jYWxBbmNob3JCKTsgfVxyXG4gICAgICAgICAgICBzZXQgeyBEZWJ1Zy5Bc3NlcnQoZmFsc2UsIFwiWW91IGNhbid0IHNldCB0aGUgd29ybGQgYW5jaG9yIG9uIHRoaXMgam9pbnQgdHlwZS5cIik7IH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHB1YmxpYyBvdmVycmlkZSBWZWN0b3IyIEdldFJlYWN0aW9uRm9yY2UoZmxvYXQgaW52X2R0KVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgVmVjdG9yMiBGID0gKGludl9kdCAqIF9pbXB1bHNlKSAqIF91O1xyXG4gICAgICAgICAgICByZXR1cm4gRjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHB1YmxpYyBvdmVycmlkZSBmbG9hdCBHZXRSZWFjdGlvblRvcnF1ZShmbG9hdCBpbnZfZHQpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gMC4wZjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGludGVybmFsIG92ZXJyaWRlIHZvaWQgSW5pdFZlbG9jaXR5Q29uc3RyYWludHMocmVmIFRpbWVTdGVwIHN0ZXApXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBCb2R5IGIxID0gQm9keUE7XHJcbiAgICAgICAgICAgIEJvZHkgYjIgPSBCb2R5QjtcclxuXHJcbiAgICAgICAgICAgIC8vIENvbXB1dGUgdGhlIGVmZmVjdGl2ZSBtYXNzIG1hdHJpeC5cclxuICAgICAgICAgICAgVmVjdG9yMiByMSA9IE1hdGhVdGlscy5NdWx0aXBseShyZWYgYjEuWGYuUiwgTG9jYWxBbmNob3JBIC0gYjEuTG9jYWxDZW50ZXIpO1xyXG4gICAgICAgICAgICBWZWN0b3IyIHIyID0gTWF0aFV0aWxzLk11bHRpcGx5KHJlZiBiMi5YZi5SLCBMb2NhbEFuY2hvckIgLSBiMi5Mb2NhbENlbnRlcik7XHJcbiAgICAgICAgICAgIF91ID0gYjIuU3dlZXAuQyArIHIyIC0gYjEuU3dlZXAuQyAtIHIxO1xyXG5cclxuICAgICAgICAgICAgLy8gSGFuZGxlIHNpbmd1bGFyaXR5LlxyXG4gICAgICAgICAgICBmbG9hdCBsZW5ndGggPSBfdS5MZW5ndGgoKTtcclxuICAgICAgICAgICAgaWYgKGxlbmd0aCA+IFNldHRpbmdzLkxpbmVhclNsb3ApXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIF91ICo9IDEuMGYgLyBsZW5ndGg7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBfdSA9IFZlY3RvcjIuWmVybztcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgZmxvYXQgY3IxdSwgY3IydTtcclxuICAgICAgICAgICAgTWF0aFV0aWxzLkNyb3NzKHJlZiByMSwgcmVmIF91LCBvdXQgY3IxdSk7XHJcbiAgICAgICAgICAgIE1hdGhVdGlscy5Dcm9zcyhyZWYgcjIsIHJlZiBfdSwgb3V0IGNyMnUpO1xyXG4gICAgICAgICAgICBmbG9hdCBpbnZNYXNzID0gYjEuSW52TWFzcyArIGIxLkludkkgKiBjcjF1ICogY3IxdSArIGIyLkludk1hc3MgKyBiMi5JbnZJICogY3IydSAqIGNyMnU7XHJcbiAgICAgICAgICAgIERlYnVnLkFzc2VydChpbnZNYXNzID4gU2V0dGluZ3MuRXBzaWxvbik7XHJcbiAgICAgICAgICAgIF9tYXNzID0gaW52TWFzcyAhPSAwLjBmID8gMS4wZiAvIGludk1hc3MgOiAwLjBmO1xyXG5cclxuICAgICAgICAgICAgaWYgKEZyZXF1ZW5jeSA+IDAuMGYpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGZsb2F0IEMgPSBsZW5ndGggLSBMZW5ndGg7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gRnJlcXVlbmN5XHJcbiAgICAgICAgICAgICAgICBmbG9hdCBvbWVnYSA9IDIuMGYgKiBTZXR0aW5ncy5QaSAqIEZyZXF1ZW5jeTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBEYW1waW5nIGNvZWZmaWNpZW50XHJcbiAgICAgICAgICAgICAgICBmbG9hdCBkID0gMi4wZiAqIF9tYXNzICogRGFtcGluZ1JhdGlvICogb21lZ2E7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gU3ByaW5nIHN0aWZmbmVzc1xyXG4gICAgICAgICAgICAgICAgZmxvYXQgayA9IF9tYXNzICogb21lZ2EgKiBvbWVnYTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBtYWdpYyBmb3JtdWxhc1xyXG4gICAgICAgICAgICAgICAgX2dhbW1hID0gc3RlcC5kdCAqIChkICsgc3RlcC5kdCAqIGspO1xyXG4gICAgICAgICAgICAgICAgX2dhbW1hID0gX2dhbW1hICE9IDAuMGYgPyAxLjBmIC8gX2dhbW1hIDogMC4wZjtcclxuICAgICAgICAgICAgICAgIF9iaWFzID0gQyAqIHN0ZXAuZHQgKiBrICogX2dhbW1hO1xyXG5cclxuICAgICAgICAgICAgICAgIF9tYXNzID0gaW52TWFzcyArIF9nYW1tYTtcclxuICAgICAgICAgICAgICAgIF9tYXNzID0gX21hc3MgIT0gMC4wZiA/IDEuMGYgLyBfbWFzcyA6IDAuMGY7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmIChTZXR0aW5ncy5FbmFibGVXYXJtc3RhcnRpbmcpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIC8vIFNjYWxlIHRoZSBpbXB1bHNlIHRvIHN1cHBvcnQgYSB2YXJpYWJsZSB0aW1lIHN0ZXAuXHJcbiAgICAgICAgICAgICAgICBfaW1wdWxzZSAqPSBzdGVwLmR0UmF0aW87XHJcblxyXG4gICAgICAgICAgICAgICAgVmVjdG9yMiBQID0gX2ltcHVsc2UgKiBfdTtcclxuICAgICAgICAgICAgICAgIGIxLkxpbmVhclZlbG9jaXR5SW50ZXJuYWwgLT0gYjEuSW52TWFzcyAqIFA7XHJcbiAgICAgICAgICAgICAgICBNYXRoVXRpbHMuQ3Jvc3MocmVmIHIxLCByZWYgUCwgb3V0IF90bXBGbG9hdDEpO1xyXG4gICAgICAgICAgICAgICAgYjEuQW5ndWxhclZlbG9jaXR5SW50ZXJuYWwgLT0gYjEuSW52SSAqIC8qIHIxIHggUCAqLyBfdG1wRmxvYXQxO1xyXG4gICAgICAgICAgICAgICAgYjIuTGluZWFyVmVsb2NpdHlJbnRlcm5hbCArPSBiMi5JbnZNYXNzICogUDtcclxuICAgICAgICAgICAgICAgIE1hdGhVdGlscy5Dcm9zcyhyZWYgcjIsIHJlZiBQLCBvdXQgX3RtcEZsb2F0MSk7XHJcbiAgICAgICAgICAgICAgICBiMi5Bbmd1bGFyVmVsb2NpdHlJbnRlcm5hbCArPSBiMi5JbnZJICogLyogcjIgeCBQICovIF90bXBGbG9hdDE7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBfaW1wdWxzZSA9IDAuMGY7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGludGVybmFsIG92ZXJyaWRlIHZvaWQgU29sdmVWZWxvY2l0eUNvbnN0cmFpbnRzKHJlZiBUaW1lU3RlcCBzdGVwKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgQm9keSBiMSA9IEJvZHlBO1xyXG4gICAgICAgICAgICBCb2R5IGIyID0gQm9keUI7XHJcblxyXG4gICAgICAgICAgICBUcmFuc2Zvcm0geGYxLCB4ZjI7XHJcbiAgICAgICAgICAgIGIxLkdldFRyYW5zZm9ybShvdXQgeGYxKTtcclxuICAgICAgICAgICAgYjIuR2V0VHJhbnNmb3JtKG91dCB4ZjIpO1xyXG5cclxuICAgICAgICAgICAgVmVjdG9yMiByMSA9IE1hdGhVdGlscy5NdWx0aXBseShyZWYgeGYxLlIsIExvY2FsQW5jaG9yQSAtIGIxLkxvY2FsQ2VudGVyKTtcclxuICAgICAgICAgICAgVmVjdG9yMiByMiA9IE1hdGhVdGlscy5NdWx0aXBseShyZWYgeGYyLlIsIExvY2FsQW5jaG9yQiAtIGIyLkxvY2FsQ2VudGVyKTtcclxuXHJcbiAgICAgICAgICAgIC8vIENkb3QgPSBkb3QodSwgdiArIGNyb3NzKHcsIHIpKVxyXG4gICAgICAgICAgICBNYXRoVXRpbHMuQ3Jvc3MoYjEuQW5ndWxhclZlbG9jaXR5SW50ZXJuYWwsIHJlZiByMSwgb3V0IF90bXBWZWN0b3IxKTtcclxuICAgICAgICAgICAgVmVjdG9yMiB2MSA9IGIxLkxpbmVhclZlbG9jaXR5SW50ZXJuYWwgKyBfdG1wVmVjdG9yMTtcclxuICAgICAgICAgICAgTWF0aFV0aWxzLkNyb3NzKGIyLkFuZ3VsYXJWZWxvY2l0eUludGVybmFsLCByZWYgcjIsIG91dCBfdG1wVmVjdG9yMSk7XHJcbiAgICAgICAgICAgIFZlY3RvcjIgdjIgPSBiMi5MaW5lYXJWZWxvY2l0eUludGVybmFsICsgX3RtcFZlY3RvcjE7XHJcbiAgICAgICAgICAgIGZsb2F0IENkb3QgPSBWZWN0b3IyLkRvdChfdSwgdjIgLSB2MSk7XHJcblxyXG4gICAgICAgICAgICBmbG9hdCBpbXB1bHNlID0gLV9tYXNzICogKENkb3QgKyBfYmlhcyArIF9nYW1tYSAqIF9pbXB1bHNlKTtcclxuICAgICAgICAgICAgX2ltcHVsc2UgKz0gaW1wdWxzZTtcclxuXHJcbiAgICAgICAgICAgIFZlY3RvcjIgUCA9IGltcHVsc2UgKiBfdTtcclxuICAgICAgICAgICAgYjEuTGluZWFyVmVsb2NpdHlJbnRlcm5hbCAtPSBiMS5JbnZNYXNzICogUDtcclxuICAgICAgICAgICAgTWF0aFV0aWxzLkNyb3NzKHJlZiByMSwgcmVmIFAsIG91dCBfdG1wRmxvYXQxKTtcclxuICAgICAgICAgICAgYjEuQW5ndWxhclZlbG9jaXR5SW50ZXJuYWwgLT0gYjEuSW52SSAqIF90bXBGbG9hdDE7XHJcbiAgICAgICAgICAgIGIyLkxpbmVhclZlbG9jaXR5SW50ZXJuYWwgKz0gYjIuSW52TWFzcyAqIFA7XHJcbiAgICAgICAgICAgIE1hdGhVdGlscy5Dcm9zcyhyZWYgcjIsIHJlZiBQLCBvdXQgX3RtcEZsb2F0MSk7XHJcbiAgICAgICAgICAgIGIyLkFuZ3VsYXJWZWxvY2l0eUludGVybmFsICs9IGIyLkludkkgKiBfdG1wRmxvYXQxO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaW50ZXJuYWwgb3ZlcnJpZGUgYm9vbCBTb2x2ZVBvc2l0aW9uQ29uc3RyYWludHMoKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgaWYgKEZyZXF1ZW5jeSA+IDAuMGYpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIC8vIFRoZXJlIGlzIG5vIHBvc2l0aW9uIGNvcnJlY3Rpb24gZm9yIHNvZnQgZGlzdGFuY2UgY29uc3RyYWludHMuXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgQm9keSBiMSA9IEJvZHlBO1xyXG4gICAgICAgICAgICBCb2R5IGIyID0gQm9keUI7XHJcblxyXG4gICAgICAgICAgICBUcmFuc2Zvcm0geGYxLCB4ZjI7XHJcbiAgICAgICAgICAgIGIxLkdldFRyYW5zZm9ybShvdXQgeGYxKTtcclxuICAgICAgICAgICAgYjIuR2V0VHJhbnNmb3JtKG91dCB4ZjIpO1xyXG5cclxuICAgICAgICAgICAgVmVjdG9yMiByMSA9IE1hdGhVdGlscy5NdWx0aXBseShyZWYgeGYxLlIsIExvY2FsQW5jaG9yQSAtIGIxLkxvY2FsQ2VudGVyKTtcclxuICAgICAgICAgICAgVmVjdG9yMiByMiA9IE1hdGhVdGlscy5NdWx0aXBseShyZWYgeGYyLlIsIExvY2FsQW5jaG9yQiAtIGIyLkxvY2FsQ2VudGVyKTtcclxuXHJcbiAgICAgICAgICAgIFZlY3RvcjIgZCA9IGIyLlN3ZWVwLkMgKyByMiAtIGIxLlN3ZWVwLkMgLSByMTtcclxuXHJcbiAgICAgICAgICAgIGZsb2F0IGxlbmd0aCA9IGQuTGVuZ3RoKCk7XHJcblxyXG4gICAgICAgICAgICBpZiAobGVuZ3RoID09IDAuMGYpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuXHJcbiAgICAgICAgICAgIGQgLz0gbGVuZ3RoO1xyXG4gICAgICAgICAgICBmbG9hdCBDID0gbGVuZ3RoIC0gTGVuZ3RoO1xyXG4gICAgICAgICAgICBDID0gTWF0aFV0aWxzLkNsYW1wKEMsIC1TZXR0aW5ncy5NYXhMaW5lYXJDb3JyZWN0aW9uLCBTZXR0aW5ncy5NYXhMaW5lYXJDb3JyZWN0aW9uKTtcclxuXHJcbiAgICAgICAgICAgIGZsb2F0IGltcHVsc2UgPSAtX21hc3MgKiBDO1xyXG4gICAgICAgICAgICBfdSA9IGQ7XHJcbiAgICAgICAgICAgIFZlY3RvcjIgUCA9IGltcHVsc2UgKiBfdTtcclxuXHJcbiAgICAgICAgICAgIGIxLlN3ZWVwLkMgLT0gYjEuSW52TWFzcyAqIFA7XHJcbiAgICAgICAgICAgIE1hdGhVdGlscy5Dcm9zcyhyZWYgcjEsIHJlZiBQLCBvdXQgX3RtcEZsb2F0MSk7XHJcbiAgICAgICAgICAgIGIxLlN3ZWVwLkEgLT0gYjEuSW52SSAqIF90bXBGbG9hdDE7XHJcbiAgICAgICAgICAgIGIyLlN3ZWVwLkMgKz0gYjIuSW52TWFzcyAqIFA7XHJcbiAgICAgICAgICAgIE1hdGhVdGlscy5Dcm9zcyhyZWYgcjIsIHJlZiBQLCBvdXQgX3RtcEZsb2F0MSk7XHJcbiAgICAgICAgICAgIGIyLlN3ZWVwLkEgKz0gYjIuSW52SSAqIF90bXBGbG9hdDE7XHJcblxyXG4gICAgICAgICAgICBiMS5TeW5jaHJvbml6ZVRyYW5zZm9ybSgpO1xyXG4gICAgICAgICAgICBiMi5TeW5jaHJvbml6ZVRyYW5zZm9ybSgpO1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIE1hdGguQWJzKEMpIDwgU2V0dGluZ3MuTGluZWFyU2xvcDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn0iLCJ1c2luZyBTeXN0ZW07XHJcbnVzaW5nIFN5c3RlbS5EaWFnbm9zdGljcztcclxudXNpbmcgTWljcm9zb2Z0LlhuYS5GcmFtZXdvcms7XHJcblxyXG5uYW1lc3BhY2UgRmFyc2VlclBoeXNpY3MuRHluYW1pY3MuSm9pbnRzXHJcbntcclxuICAgIHB1YmxpYyBjbGFzcyBGaXhlZEFuZ2xlSm9pbnQgOiBKb2ludFxyXG4gICAge1xyXG4gICAgICAgIHB1YmxpYyBmbG9hdCBCaWFzRmFjdG9yO1xyXG4gICAgICAgIHB1YmxpYyBmbG9hdCBNYXhJbXB1bHNlO1xyXG4gICAgICAgIHB1YmxpYyBmbG9hdCBTb2Z0bmVzcztcclxuICAgICAgICBwcml2YXRlIGZsb2F0IF9iaWFzO1xyXG4gICAgICAgIHByaXZhdGUgZmxvYXQgX2pvaW50RXJyb3I7XHJcbiAgICAgICAgcHJpdmF0ZSBmbG9hdCBfbWFzc0ZhY3RvcjtcclxuICAgICAgICBwcml2YXRlIGZsb2F0IF90YXJnZXRBbmdsZTtcclxuXHJcbiAgICAgICAgcHVibGljIEZpeGVkQW5nbGVKb2ludChCb2R5IGJvZHlBKVxyXG4gICAgICAgICAgICA6IGJhc2UoYm9keUEpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBKb2ludFR5cGUgPSBKb2ludFR5cGUuRml4ZWRBbmdsZTtcclxuICAgICAgICAgICAgVGFyZ2V0QW5nbGUgPSAwO1xyXG4gICAgICAgICAgICBCaWFzRmFjdG9yID0gLjJmO1xyXG4gICAgICAgICAgICBTb2Z0bmVzcyA9IDBmO1xyXG4gICAgICAgICAgICBNYXhJbXB1bHNlID0gZmxvYXQuTWF4VmFsdWU7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwdWJsaWMgZmxvYXQgVGFyZ2V0QW5nbGVcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGdldCB7IHJldHVybiBfdGFyZ2V0QW5nbGU7IH1cclxuICAgICAgICAgICAgc2V0XHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSAhPSBfdGFyZ2V0QW5nbGUpXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgX3RhcmdldEFuZ2xlID0gdmFsdWU7XHJcbiAgICAgICAgICAgICAgICAgICAgV2FrZUJvZGllcygpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwdWJsaWMgb3ZlcnJpZGUgVmVjdG9yMiBXb3JsZEFuY2hvckFcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGdldCB7IHJldHVybiBCb2R5QS5Qb3NpdGlvbjsgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHVibGljIG92ZXJyaWRlIFZlY3RvcjIgV29ybGRBbmNob3JCXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBnZXQgeyByZXR1cm4gQm9keUEuUG9zaXRpb247IH1cclxuICAgICAgICAgICAgc2V0IHsgRGVidWcuQXNzZXJ0KGZhbHNlLCBcIllvdSBjYW4ndCBzZXQgdGhlIHdvcmxkIGFuY2hvciBvbiB0aGlzIGpvaW50IHR5cGUuXCIpOyB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwdWJsaWMgb3ZlcnJpZGUgVmVjdG9yMiBHZXRSZWFjdGlvbkZvcmNlKGZsb2F0IGludl9kdClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIC8vVE9ET1xyXG4gICAgICAgICAgICAvL3JldHVybiBfaW52X2R0ICogX2ltcHVsc2U7XHJcbiAgICAgICAgICAgIHJldHVybiBWZWN0b3IyLlplcm87XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwdWJsaWMgb3ZlcnJpZGUgZmxvYXQgR2V0UmVhY3Rpb25Ub3JxdWUoZmxvYXQgaW52X2R0KVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIDA7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpbnRlcm5hbCBvdmVycmlkZSB2b2lkIEluaXRWZWxvY2l0eUNvbnN0cmFpbnRzKHJlZiBUaW1lU3RlcCBzdGVwKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgX2pvaW50RXJyb3IgPSBCb2R5QS5Td2VlcC5BIC0gVGFyZ2V0QW5nbGU7XHJcblxyXG4gICAgICAgICAgICBfYmlhcyA9IC1CaWFzRmFjdG9yICogc3RlcC5pbnZfZHQgKiBfam9pbnRFcnJvcjtcclxuXHJcbiAgICAgICAgICAgIF9tYXNzRmFjdG9yID0gKDEgLSBTb2Z0bmVzcykgLyAoQm9keUEuSW52SSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpbnRlcm5hbCBvdmVycmlkZSB2b2lkIFNvbHZlVmVsb2NpdHlDb25zdHJhaW50cyhyZWYgVGltZVN0ZXAgc3RlcClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGZsb2F0IHAgPSAoX2JpYXMgLSBCb2R5QS5Bbmd1bGFyVmVsb2NpdHkpICogX21hc3NGYWN0b3I7XHJcbiAgICAgICAgICAgIEJvZHlBLkFuZ3VsYXJWZWxvY2l0eSArPSBCb2R5QS5JbnZJICogTWF0aC5TaWduKHApICogTWF0aC5NaW4oKGZsb2F0KU1hdGguQWJzKHApLCBNYXhJbXB1bHNlKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGludGVybmFsIG92ZXJyaWRlIGJvb2wgU29sdmVQb3NpdGlvbkNvbnN0cmFpbnRzKClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIC8vbm8gcG9zaXRpb24gc29sdmluZyBmb3IgdGhpcyBqb2ludFxyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn0iLCIvKlxyXG4qIEZhcnNlZXIgUGh5c2ljcyBFbmdpbmUgYmFzZWQgb24gQm94MkQuWE5BIHBvcnQ6XHJcbiogQ29weXJpZ2h0IChjKSAyMDEwIElhbiBRdmlzdFxyXG4qIFxyXG4qIEJveDJELlhOQSBwb3J0IG9mIEJveDJEOlxyXG4qIENvcHlyaWdodCAoYykgMjAwOSBCcmFuZG9uIEZ1cnR3YW5nbGVyLCBOYXRoYW4gRnVydHdhbmdsZXJcclxuKlxyXG4qIE9yaWdpbmFsIHNvdXJjZSBCb3gyRDpcclxuKiBDb3B5cmlnaHQgKGMpIDIwMDYtMjAwOSBFcmluIENhdHRvIGh0dHA6Ly93d3cuZ3BoeXNpY3MuY29tIFxyXG4qIFxyXG4qIFRoaXMgc29mdHdhcmUgaXMgcHJvdmlkZWQgJ2FzLWlzJywgd2l0aG91dCBhbnkgZXhwcmVzcyBvciBpbXBsaWVkIFxyXG4qIHdhcnJhbnR5LiAgSW4gbm8gZXZlbnQgd2lsbCB0aGUgYXV0aG9ycyBiZSBoZWxkIGxpYWJsZSBmb3IgYW55IGRhbWFnZXMgXHJcbiogYXJpc2luZyBmcm9tIHRoZSB1c2Ugb2YgdGhpcyBzb2Z0d2FyZS4gXHJcbiogUGVybWlzc2lvbiBpcyBncmFudGVkIHRvIGFueW9uZSB0byB1c2UgdGhpcyBzb2Z0d2FyZSBmb3IgYW55IHB1cnBvc2UsIFxyXG4qIGluY2x1ZGluZyBjb21tZXJjaWFsIGFwcGxpY2F0aW9ucywgYW5kIHRvIGFsdGVyIGl0IGFuZCByZWRpc3RyaWJ1dGUgaXQgXHJcbiogZnJlZWx5LCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgcmVzdHJpY3Rpb25zOiBcclxuKiAxLiBUaGUgb3JpZ2luIG9mIHRoaXMgc29mdHdhcmUgbXVzdCBub3QgYmUgbWlzcmVwcmVzZW50ZWQ7IHlvdSBtdXN0IG5vdCBcclxuKiBjbGFpbSB0aGF0IHlvdSB3cm90ZSB0aGUgb3JpZ2luYWwgc29mdHdhcmUuIElmIHlvdSB1c2UgdGhpcyBzb2Z0d2FyZSBcclxuKiBpbiBhIHByb2R1Y3QsIGFuIGFja25vd2xlZGdtZW50IGluIHRoZSBwcm9kdWN0IGRvY3VtZW50YXRpb24gd291bGQgYmUgXHJcbiogYXBwcmVjaWF0ZWQgYnV0IGlzIG5vdCByZXF1aXJlZC4gXHJcbiogMi4gQWx0ZXJlZCBzb3VyY2UgdmVyc2lvbnMgbXVzdCBiZSBwbGFpbmx5IG1hcmtlZCBhcyBzdWNoLCBhbmQgbXVzdCBub3QgYmUgXHJcbiogbWlzcmVwcmVzZW50ZWQgYXMgYmVpbmcgdGhlIG9yaWdpbmFsIHNvZnR3YXJlLiBcclxuKiAzLiBUaGlzIG5vdGljZSBtYXkgbm90IGJlIHJlbW92ZWQgb3IgYWx0ZXJlZCBmcm9tIGFueSBzb3VyY2UgZGlzdHJpYnV0aW9uLiBcclxuKi9cclxuXHJcbnVzaW5nIFN5c3RlbTtcclxudXNpbmcgU3lzdGVtLkRpYWdub3N0aWNzO1xyXG51c2luZyBGYXJzZWVyUGh5c2ljcy5Db21tb247XHJcbnVzaW5nIE1pY3Jvc29mdC5YbmEuRnJhbWV3b3JrO1xyXG5cclxubmFtZXNwYWNlIEZhcnNlZXJQaHlzaWNzLkR5bmFtaWNzLkpvaW50c1xyXG57XHJcbiAgICAvLyAxLUQgcmFpbmVkIHN5c3RlbVxyXG4gICAgLy8gbSAodjIgLSB2MSkgPSBsYW1iZGFcclxuICAgIC8vIHYyICsgKGJldGEvaCkgKiB4MSArIGdhbW1hICogbGFtYmRhID0gMCwgZ2FtbWEgaGFzIHVuaXRzIG9mIGludmVyc2UgbWFzcy5cclxuICAgIC8vIHgyID0geDEgKyBoICogdjJcclxuXHJcbiAgICAvLyAxLUQgbWFzcy1kYW1wZXItc3ByaW5nIHN5c3RlbVxyXG4gICAgLy8gbSAodjIgLSB2MSkgKyBoICogZCAqIHYyICsgaCAqIGsgKiBcclxuXHJcbiAgICAvLyBDID0gbm9ybShwMiAtIHAxKSAtIExcclxuICAgIC8vIHUgPSAocDIgLSBwMSkgLyBub3JtKHAyIC0gcDEpXHJcbiAgICAvLyBDZG90ID0gZG90KHUsIHYyICsgY3Jvc3ModzIsIHIyKSAtIHYxIC0gY3Jvc3ModzEsIHIxKSlcclxuICAgIC8vIEogPSBbLXUgLWNyb3NzKHIxLCB1KSB1IGNyb3NzKHIyLCB1KV1cclxuICAgIC8vIEsgPSBKICogaW52TSAqIEpUXHJcbiAgICAvLyAgID0gaW52TWFzczEgKyBpbnZJMSAqIGNyb3NzKHIxLCB1KV4yICsgaW52TWFzczIgKyBpbnZJMiAqIGNyb3NzKHIyLCB1KV4yXHJcblxyXG4gICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgLy8vIEEgZGlzdGFuY2Ugam9pbnQgcmFpbnMgdHdvIHBvaW50cyBvbiB0d28gYm9kaWVzXHJcbiAgICAvLy8gdG8gcmVtYWluIGF0IGEgZml4ZWQgZGlzdGFuY2UgZnJvbSBlYWNoIG90aGVyLiBZb3UgY2FuIHZpZXdcclxuICAgIC8vLyB0aGlzIGFzIGEgbWFzc2xlc3MsIHJpZ2lkIHJvZC5cclxuICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICBwdWJsaWMgY2xhc3MgRml4ZWREaXN0YW5jZUpvaW50IDogSm9pbnRcclxuICAgIHtcclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIFRoZSBsb2NhbCBhbmNob3IgcG9pbnQgcmVsYXRpdmUgdG8gYm9keUEncyBvcmlnaW4uXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICBwdWJsaWMgVmVjdG9yMiBMb2NhbEFuY2hvckE7XHJcblxyXG4gICAgICAgIHByaXZhdGUgZmxvYXQgX2JpYXM7XHJcbiAgICAgICAgcHJpdmF0ZSBmbG9hdCBfZ2FtbWE7XHJcbiAgICAgICAgcHJpdmF0ZSBmbG9hdCBfaW1wdWxzZTtcclxuICAgICAgICBwcml2YXRlIGZsb2F0IF9tYXNzO1xyXG4gICAgICAgIHByaXZhdGUgVmVjdG9yMiBfdTtcclxuICAgICAgICBwcml2YXRlIFZlY3RvcjIgX3dvcmxkQW5jaG9yQjtcclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBUaGlzIHJlcXVpcmVzIGRlZmluaW5nIGFuXHJcbiAgICAgICAgLy8vIGFuY2hvciBwb2ludCBvbiBib3RoIGJvZGllcyBhbmQgdGhlIG5vbi16ZXJvIGxlbmd0aCBvZiB0aGVcclxuICAgICAgICAvLy8gZGlzdGFuY2Ugam9pbnQuIElmIHlvdSBkb24ndCBzdXBwbHkgYSBsZW5ndGgsIHRoZSBsb2NhbCBhbmNob3IgcG9pbnRzXHJcbiAgICAgICAgLy8vIGlzIHVzZWQgc28gdGhhdCB0aGUgaW5pdGlhbCBjb25maWd1cmF0aW9uIGNhbiB2aW9sYXRlIHRoZSBjb25zdHJhaW50XHJcbiAgICAgICAgLy8vIHNsaWdodGx5LiBUaGlzIGhlbHBzIHdoZW4gc2F2aW5nIGFuZCBsb2FkaW5nIGEgZ2FtZS5cclxuICAgICAgICAvLy8gQHdhcm5pbmcgRG8gbm90IHVzZSBhIHplcm8gb3Igc2hvcnQgbGVuZ3RoLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwiYm9keVwiPlRoZSBib2R5LjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwiYm9keUFuY2hvclwiPlRoZSBib2R5IGFuY2hvci48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cIndvcmxkQW5jaG9yXCI+VGhlIHdvcmxkIGFuY2hvci48L3BhcmFtPlxyXG4gICAgICAgIHB1YmxpYyBGaXhlZERpc3RhbmNlSm9pbnQoQm9keSBib2R5LCBWZWN0b3IyIGJvZHlBbmNob3IsIFZlY3RvcjIgd29ybGRBbmNob3IpXHJcbiAgICAgICAgICAgIDogYmFzZShib2R5KVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgSm9pbnRUeXBlID0gSm9pbnRUeXBlLkZpeGVkRGlzdGFuY2U7XHJcblxyXG4gICAgICAgICAgICBMb2NhbEFuY2hvckEgPSBib2R5QW5jaG9yO1xyXG4gICAgICAgICAgICBfd29ybGRBbmNob3JCID0gd29ybGRBbmNob3I7XHJcblxyXG4gICAgICAgICAgICAvL0NhbGN1bGF0ZSB0aGUgbGVuZ3RoXHJcbiAgICAgICAgICAgIFZlY3RvcjIgZCA9IFdvcmxkQW5jaG9yQiAtIFdvcmxkQW5jaG9yQTtcclxuICAgICAgICAgICAgTGVuZ3RoID0gZC5MZW5ndGgoKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gVGhlIG5hdHVyYWwgbGVuZ3RoIGJldHdlZW4gdGhlIGFuY2hvciBwb2ludHMuXHJcbiAgICAgICAgLy8vIE1hbmlwdWxhdGluZyB0aGUgbGVuZ3RoIGNhbiBsZWFkIHRvIG5vbi1waHlzaWNhbCBiZWhhdmlvciB3aGVuIHRoZSBmcmVxdWVuY3kgaXMgemVyby5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIHB1YmxpYyBmbG9hdCBMZW5ndGggeyBnZXQ7IHNldDsgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIFRoZSBtYXNzLXNwcmluZy1kYW1wZXIgZnJlcXVlbmN5IGluIEhlcnR6LlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgcHVibGljIGZsb2F0IEZyZXF1ZW5jeSB7IGdldDsgc2V0OyB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gVGhlIGRhbXBpbmcgcmF0aW8uIDAgPSBubyBkYW1waW5nLCAxID0gY3JpdGljYWwgZGFtcGluZy5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIHB1YmxpYyBmbG9hdCBEYW1waW5nUmF0aW8geyBnZXQ7IHNldDsgfVxyXG5cclxuICAgICAgICBwdWJsaWMgb3ZlcnJpZGUgc2VhbGVkIFZlY3RvcjIgV29ybGRBbmNob3JBXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBnZXQgeyByZXR1cm4gQm9keUEuR2V0V29ybGRQb2ludChMb2NhbEFuY2hvckEpOyB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwdWJsaWMgb3ZlcnJpZGUgc2VhbGVkIFZlY3RvcjIgV29ybGRBbmNob3JCXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBnZXQgeyByZXR1cm4gX3dvcmxkQW5jaG9yQjsgfVxyXG4gICAgICAgICAgICBzZXQgeyBfd29ybGRBbmNob3JCID0gdmFsdWU7IH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHB1YmxpYyBvdmVycmlkZSBWZWN0b3IyIEdldFJlYWN0aW9uRm9yY2UoZmxvYXQgaW52RHQpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gKGludkR0ICogX2ltcHVsc2UpICogX3U7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwdWJsaWMgb3ZlcnJpZGUgZmxvYXQgR2V0UmVhY3Rpb25Ub3JxdWUoZmxvYXQgaW52RHQpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gMC4wZjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGludGVybmFsIG92ZXJyaWRlIHZvaWQgSW5pdFZlbG9jaXR5Q29uc3RyYWludHMocmVmIFRpbWVTdGVwIHN0ZXApXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBCb2R5IGIxID0gQm9keUE7XHJcblxyXG4gICAgICAgICAgICBUcmFuc2Zvcm0geGYxO1xyXG4gICAgICAgICAgICBiMS5HZXRUcmFuc2Zvcm0ob3V0IHhmMSk7XHJcblxyXG4gICAgICAgICAgICAvLyBDb21wdXRlIHRoZSBlZmZlY3RpdmUgbWFzcyBtYXRyaXguXHJcbiAgICAgICAgICAgIFZlY3RvcjIgcjEgPSBNYXRoVXRpbHMuTXVsdGlwbHkocmVmIHhmMS5SLCBMb2NhbEFuY2hvckEgLSBiMS5Mb2NhbENlbnRlcik7XHJcbiAgICAgICAgICAgIFZlY3RvcjIgcjIgPSBfd29ybGRBbmNob3JCO1xyXG4gICAgICAgICAgICBfdSA9IHIyIC0gYjEuU3dlZXAuQyAtIHIxO1xyXG5cclxuICAgICAgICAgICAgLy8gSGFuZGxlIHNpbmd1bGFyaXR5LlxyXG4gICAgICAgICAgICBmbG9hdCBsZW5ndGggPSBfdS5MZW5ndGgoKTtcclxuICAgICAgICAgICAgaWYgKGxlbmd0aCA+IFNldHRpbmdzLkxpbmVhclNsb3ApXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIF91ICo9IDEuMGYgLyBsZW5ndGg7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBfdSA9IFZlY3RvcjIuWmVybztcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgZmxvYXQgY3IxdSA9IE1hdGhVdGlscy5Dcm9zcyhyMSwgX3UpO1xyXG4gICAgICAgICAgICBmbG9hdCBjcjJ1ID0gTWF0aFV0aWxzLkNyb3NzKHIyLCBfdSk7XHJcbiAgICAgICAgICAgIGZsb2F0IGludk1hc3MgPSBiMS5JbnZNYXNzICsgYjEuSW52SSAqIGNyMXUgKiBjcjF1ICsgMCAqIGNyMnUgKiBjcjJ1O1xyXG4gICAgICAgICAgICBEZWJ1Zy5Bc3NlcnQoaW52TWFzcyA+IFNldHRpbmdzLkVwc2lsb24pO1xyXG4gICAgICAgICAgICBfbWFzcyA9IGludk1hc3MgIT0gMC4wZiA/IDEuMGYgLyBpbnZNYXNzIDogMC4wZjtcclxuXHJcbiAgICAgICAgICAgIGlmIChGcmVxdWVuY3kgPiAwLjBmKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBmbG9hdCBDID0gbGVuZ3RoIC0gTGVuZ3RoO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIEZyZXF1ZW5jeVxyXG4gICAgICAgICAgICAgICAgZmxvYXQgb21lZ2EgPSAyLjBmICogU2V0dGluZ3MuUGkgKiBGcmVxdWVuY3k7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gRGFtcGluZyBjb2VmZmljaWVudFxyXG4gICAgICAgICAgICAgICAgZmxvYXQgZCA9IDIuMGYgKiBfbWFzcyAqIERhbXBpbmdSYXRpbyAqIG9tZWdhO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIFNwcmluZyBzdGlmZm5lc3NcclxuICAgICAgICAgICAgICAgIGZsb2F0IGsgPSBfbWFzcyAqIG9tZWdhICogb21lZ2E7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gbWFnaWMgZm9ybXVsYXNcclxuICAgICAgICAgICAgICAgIF9nYW1tYSA9IHN0ZXAuZHQgKiAoZCArIHN0ZXAuZHQgKiBrKTtcclxuICAgICAgICAgICAgICAgIF9nYW1tYSA9IF9nYW1tYSAhPSAwLjBmID8gMS4wZiAvIF9nYW1tYSA6IDAuMGY7XHJcbiAgICAgICAgICAgICAgICBfYmlhcyA9IEMgKiBzdGVwLmR0ICogayAqIF9nYW1tYTtcclxuXHJcbiAgICAgICAgICAgICAgICBfbWFzcyA9IGludk1hc3MgKyBfZ2FtbWE7XHJcbiAgICAgICAgICAgICAgICBfbWFzcyA9IF9tYXNzICE9IDAuMGYgPyAxLjBmIC8gX21hc3MgOiAwLjBmO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAoU2V0dGluZ3MuRW5hYmxlV2FybXN0YXJ0aW5nKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAvLyBTY2FsZSB0aGUgaW1wdWxzZSB0byBzdXBwb3J0IGEgdmFyaWFibGUgdGltZSBzdGVwLlxyXG4gICAgICAgICAgICAgICAgX2ltcHVsc2UgKj0gc3RlcC5kdFJhdGlvO1xyXG5cclxuICAgICAgICAgICAgICAgIFZlY3RvcjIgUCA9IF9pbXB1bHNlICogX3U7XHJcbiAgICAgICAgICAgICAgICBiMS5MaW5lYXJWZWxvY2l0eUludGVybmFsIC09IGIxLkludk1hc3MgKiBQO1xyXG4gICAgICAgICAgICAgICAgYjEuQW5ndWxhclZlbG9jaXR5SW50ZXJuYWwgLT0gYjEuSW52SSAqIE1hdGhVdGlscy5Dcm9zcyhyMSwgUCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBfaW1wdWxzZSA9IDAuMGY7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGludGVybmFsIG92ZXJyaWRlIHZvaWQgU29sdmVWZWxvY2l0eUNvbnN0cmFpbnRzKHJlZiBUaW1lU3RlcCBzdGVwKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgQm9keSBiMSA9IEJvZHlBO1xyXG5cclxuICAgICAgICAgICAgVHJhbnNmb3JtIHhmMTtcclxuICAgICAgICAgICAgYjEuR2V0VHJhbnNmb3JtKG91dCB4ZjEpO1xyXG5cclxuICAgICAgICAgICAgVmVjdG9yMiByMSA9IE1hdGhVdGlscy5NdWx0aXBseShyZWYgeGYxLlIsIExvY2FsQW5jaG9yQSAtIGIxLkxvY2FsQ2VudGVyKTtcclxuXHJcbiAgICAgICAgICAgIC8vIENkb3QgPSBkb3QodSwgdiArIGNyb3NzKHcsIHIpKVxyXG4gICAgICAgICAgICBWZWN0b3IyIHYxID0gYjEuTGluZWFyVmVsb2NpdHlJbnRlcm5hbCArIE1hdGhVdGlscy5Dcm9zcyhiMS5Bbmd1bGFyVmVsb2NpdHlJbnRlcm5hbCwgcjEpO1xyXG4gICAgICAgICAgICBWZWN0b3IyIHYyID0gVmVjdG9yMi5aZXJvO1xyXG4gICAgICAgICAgICBmbG9hdCBDZG90ID0gVmVjdG9yMi5Eb3QoX3UsIHYyIC0gdjEpO1xyXG5cclxuICAgICAgICAgICAgZmxvYXQgaW1wdWxzZSA9IC1fbWFzcyAqIChDZG90ICsgX2JpYXMgKyBfZ2FtbWEgKiBfaW1wdWxzZSk7XHJcbiAgICAgICAgICAgIF9pbXB1bHNlICs9IGltcHVsc2U7XHJcblxyXG4gICAgICAgICAgICBWZWN0b3IyIFAgPSBpbXB1bHNlICogX3U7XHJcbiAgICAgICAgICAgIGIxLkxpbmVhclZlbG9jaXR5SW50ZXJuYWwgLT0gYjEuSW52TWFzcyAqIFA7XHJcbiAgICAgICAgICAgIGIxLkFuZ3VsYXJWZWxvY2l0eUludGVybmFsIC09IGIxLkludkkgKiBNYXRoVXRpbHMuQ3Jvc3MocjEsIFApO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaW50ZXJuYWwgb3ZlcnJpZGUgYm9vbCBTb2x2ZVBvc2l0aW9uQ29uc3RyYWludHMoKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgaWYgKEZyZXF1ZW5jeSA+IDAuMGYpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIC8vIFRoZXJlIGlzIG5vIHBvc2l0aW9uIGNvcnJlY3Rpb24gZm9yIHNvZnQgZGlzdGFuY2UgY29uc3RyYWludHMuXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgQm9keSBiMSA9IEJvZHlBO1xyXG5cclxuICAgICAgICAgICAgVHJhbnNmb3JtIHhmMTtcclxuICAgICAgICAgICAgYjEuR2V0VHJhbnNmb3JtKG91dCB4ZjEpO1xyXG5cclxuICAgICAgICAgICAgVmVjdG9yMiByMSA9IE1hdGhVdGlscy5NdWx0aXBseShyZWYgeGYxLlIsIExvY2FsQW5jaG9yQSAtIGIxLkxvY2FsQ2VudGVyKTtcclxuICAgICAgICAgICAgVmVjdG9yMiByMiA9IF93b3JsZEFuY2hvckI7XHJcblxyXG4gICAgICAgICAgICBWZWN0b3IyIGQgPSByMiAtIGIxLlN3ZWVwLkMgLSByMTtcclxuXHJcbiAgICAgICAgICAgIGZsb2F0IGxlbmd0aCA9IGQuTGVuZ3RoKCk7XHJcblxyXG4gICAgICAgICAgICBpZiAobGVuZ3RoID09IDAuMGYpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuXHJcbiAgICAgICAgICAgIGQgLz0gbGVuZ3RoO1xyXG4gICAgICAgICAgICBmbG9hdCBDID0gbGVuZ3RoIC0gTGVuZ3RoO1xyXG4gICAgICAgICAgICBDID0gTWF0aFV0aWxzLkNsYW1wKEMsIC1TZXR0aW5ncy5NYXhMaW5lYXJDb3JyZWN0aW9uLCBTZXR0aW5ncy5NYXhMaW5lYXJDb3JyZWN0aW9uKTtcclxuXHJcbiAgICAgICAgICAgIGZsb2F0IGltcHVsc2UgPSAtX21hc3MgKiBDO1xyXG4gICAgICAgICAgICBfdSA9IGQ7XHJcbiAgICAgICAgICAgIFZlY3RvcjIgUCA9IGltcHVsc2UgKiBfdTtcclxuXHJcbiAgICAgICAgICAgIGIxLlN3ZWVwLkMgLT0gYjEuSW52TWFzcyAqIFA7XHJcbiAgICAgICAgICAgIGIxLlN3ZWVwLkEgLT0gYjEuSW52SSAqIE1hdGhVdGlscy5Dcm9zcyhyMSwgUCk7XHJcblxyXG4gICAgICAgICAgICBiMS5TeW5jaHJvbml6ZVRyYW5zZm9ybSgpO1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIE1hdGguQWJzKEMpIDwgU2V0dGluZ3MuTGluZWFyU2xvcDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn0iLCIvKlxyXG4qIEZhcnNlZXIgUGh5c2ljcyBFbmdpbmUgYmFzZWQgb24gQm94MkQuWE5BIHBvcnQ6XHJcbiogQ29weXJpZ2h0IChjKSAyMDEwIElhbiBRdmlzdFxyXG4qIFxyXG4qIEJveDJELlhOQSBwb3J0IG9mIEJveDJEOlxyXG4qIENvcHlyaWdodCAoYykgMjAwOSBCcmFuZG9uIEZ1cnR3YW5nbGVyLCBOYXRoYW4gRnVydHdhbmdsZXJcclxuKlxyXG4qIE9yaWdpbmFsIHNvdXJjZSBCb3gyRDpcclxuKiBDb3B5cmlnaHQgKGMpIDIwMDYtMjAwOSBFcmluIENhdHRvIGh0dHA6Ly93d3cuZ3BoeXNpY3MuY29tIFxyXG4qIFxyXG4qIFRoaXMgc29mdHdhcmUgaXMgcHJvdmlkZWQgJ2FzLWlzJywgd2l0aG91dCBhbnkgZXhwcmVzcyBvciBpbXBsaWVkIFxyXG4qIHdhcnJhbnR5LiAgSW4gbm8gZXZlbnQgd2lsbCB0aGUgYXV0aG9ycyBiZSBoZWxkIGxpYWJsZSBmb3IgYW55IGRhbWFnZXMgXHJcbiogYXJpc2luZyBmcm9tIHRoZSB1c2Ugb2YgdGhpcyBzb2Z0d2FyZS4gXHJcbiogUGVybWlzc2lvbiBpcyBncmFudGVkIHRvIGFueW9uZSB0byB1c2UgdGhpcyBzb2Z0d2FyZSBmb3IgYW55IHB1cnBvc2UsIFxyXG4qIGluY2x1ZGluZyBjb21tZXJjaWFsIGFwcGxpY2F0aW9ucywgYW5kIHRvIGFsdGVyIGl0IGFuZCByZWRpc3RyaWJ1dGUgaXQgXHJcbiogZnJlZWx5LCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgcmVzdHJpY3Rpb25zOiBcclxuKiAxLiBUaGUgb3JpZ2luIG9mIHRoaXMgc29mdHdhcmUgbXVzdCBub3QgYmUgbWlzcmVwcmVzZW50ZWQ7IHlvdSBtdXN0IG5vdCBcclxuKiBjbGFpbSB0aGF0IHlvdSB3cm90ZSB0aGUgb3JpZ2luYWwgc29mdHdhcmUuIElmIHlvdSB1c2UgdGhpcyBzb2Z0d2FyZSBcclxuKiBpbiBhIHByb2R1Y3QsIGFuIGFja25vd2xlZGdtZW50IGluIHRoZSBwcm9kdWN0IGRvY3VtZW50YXRpb24gd291bGQgYmUgXHJcbiogYXBwcmVjaWF0ZWQgYnV0IGlzIG5vdCByZXF1aXJlZC4gXHJcbiogMi4gQWx0ZXJlZCBzb3VyY2UgdmVyc2lvbnMgbXVzdCBiZSBwbGFpbmx5IG1hcmtlZCBhcyBzdWNoLCBhbmQgbXVzdCBub3QgYmUgXHJcbiogbWlzcmVwcmVzZW50ZWQgYXMgYmVpbmcgdGhlIG9yaWdpbmFsIHNvZnR3YXJlLiBcclxuKiAzLiBUaGlzIG5vdGljZSBtYXkgbm90IGJlIHJlbW92ZWQgb3IgYWx0ZXJlZCBmcm9tIGFueSBzb3VyY2UgZGlzdHJpYnV0aW9uLiBcclxuKi9cclxuXHJcbnVzaW5nIFN5c3RlbTtcclxudXNpbmcgU3lzdGVtLkRpYWdub3N0aWNzO1xyXG51c2luZyBGYXJzZWVyUGh5c2ljcy5Db21tb247XHJcbnVzaW5nIE1pY3Jvc29mdC5YbmEuRnJhbWV3b3JrO1xyXG5cclxubmFtZXNwYWNlIEZhcnNlZXJQaHlzaWNzLkR5bmFtaWNzLkpvaW50c1xyXG57XHJcbiAgICAvLyBQb2ludC10by1wb2ludCBjb25zdHJhaW50XHJcbiAgICAvLyBDZG90ID0gdjIgLSB2MVxyXG4gICAgLy8gICAgICA9IHYyICsgY3Jvc3ModzIsIHIyKSAtIHYxIC0gY3Jvc3ModzEsIHIxKVxyXG4gICAgLy8gSiA9IFstSSAtcjFfc2tldyBJIHIyX3NrZXcgXVxyXG4gICAgLy8gSWRlbnRpdHkgdXNlZDpcclxuICAgIC8vIHcgayAlIChyeCBpICsgcnkgaikgPSB3ICogKC1yeSBpICsgcnggailcclxuXHJcbiAgICAvLyBBbmdsZSBjb25zdHJhaW50XHJcbiAgICAvLyBDZG90ID0gdzIgLSB3MVxyXG4gICAgLy8gSiA9IFswIDAgLTEgMCAwIDFdXHJcbiAgICAvLyBLID0gaW52STEgKyBpbnZJMlxyXG5cclxuICAgIC8vLyA8c3VtbWFyeT5cclxuICAgIC8vLyBGcmljdGlvbiBqb2ludC4gVGhpcyBpcyB1c2VkIGZvciB0b3AtZG93biBmcmljdGlvbi5cclxuICAgIC8vLyBJdCBwcm92aWRlcyAyRCB0cmFuc2xhdGlvbmFsIGZyaWN0aW9uIGFuZCBhbmd1bGFyIGZyaWN0aW9uLlxyXG4gICAgLy8vIDwvc3VtbWFyeT5cclxuICAgIHB1YmxpYyBjbGFzcyBGaXhlZEZyaWN0aW9uSm9pbnQgOiBKb2ludFxyXG4gICAge1xyXG4gICAgICAgIHB1YmxpYyBWZWN0b3IyIExvY2FsQW5jaG9yQTtcclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBUaGUgbWF4aW11bSBmcmljdGlvbiBmb3JjZSBpbiBOLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgcHVibGljIGZsb2F0IE1heEZvcmNlO1xyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIFRoZSBtYXhpbXVtIGZyaWN0aW9uIHRvcnF1ZSBpbiBOLW0uXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICBwdWJsaWMgZmxvYXQgTWF4VG9ycXVlO1xyXG5cclxuICAgICAgICBwcml2YXRlIGZsb2F0IF9hbmd1bGFySW1wdWxzZTtcclxuICAgICAgICBwcml2YXRlIGZsb2F0IF9hbmd1bGFyTWFzcztcclxuICAgICAgICBwcml2YXRlIFZlY3RvcjIgX2xpbmVhckltcHVsc2U7XHJcbiAgICAgICAgcHJpdmF0ZSBNYXQyMiBfbGluZWFyTWFzcztcclxuXHJcbiAgICAgICAgcHVibGljIEZpeGVkRnJpY3Rpb25Kb2ludChCb2R5IGJvZHksIFZlY3RvcjIgbG9jYWxBbmNob3JBKVxyXG4gICAgICAgICAgICA6IGJhc2UoYm9keSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIEpvaW50VHlwZSA9IEpvaW50VHlwZS5GaXhlZEZyaWN0aW9uO1xyXG4gICAgICAgICAgICBMb2NhbEFuY2hvckEgPSBsb2NhbEFuY2hvckE7XHJcblxyXG4gICAgICAgICAgICAvL1NldHRpbmcgZGVmYXVsdCBtYXggZm9yY2UgYW5kIG1heCB0b3JxdWVcclxuICAgICAgICAgICAgY29uc3QgZmxvYXQgZ3Jhdml0eSA9IDEwLjBmO1xyXG5cclxuICAgICAgICAgICAgLy8gRm9yIGEgY2lyY2xlOiBJID0gMC41ICogbSAqIHIgKiByID09PiByID0gc3FydCgyICogSSAvIG0pXHJcbiAgICAgICAgICAgIGZsb2F0IHJhZGl1cyA9IChmbG9hdClNYXRoLlNxcnQoMi4wICogKGJvZHkuSW5lcnRpYSAvIGJvZHkuTWFzcykpO1xyXG5cclxuICAgICAgICAgICAgTWF4Rm9yY2UgPSBib2R5Lk1hc3MgKiBncmF2aXR5O1xyXG4gICAgICAgICAgICBNYXhUb3JxdWUgPSBib2R5Lk1hc3MgKiByYWRpdXMgKiBncmF2aXR5O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHVibGljIG92ZXJyaWRlIFZlY3RvcjIgV29ybGRBbmNob3JBXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBnZXQgeyByZXR1cm4gQm9keUEuR2V0V29ybGRQb2ludChMb2NhbEFuY2hvckEpOyB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwdWJsaWMgb3ZlcnJpZGUgVmVjdG9yMiBXb3JsZEFuY2hvckJcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGdldCB7IHJldHVybiBWZWN0b3IyLlplcm87IH1cclxuICAgICAgICAgICAgc2V0IHsgRGVidWcuQXNzZXJ0KGZhbHNlLCBcIllvdSBjYW4ndCBzZXQgdGhlIHdvcmxkIGFuY2hvciBvbiB0aGlzIGpvaW50IHR5cGUuXCIpOyB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwdWJsaWMgb3ZlcnJpZGUgVmVjdG9yMiBHZXRSZWFjdGlvbkZvcmNlKGZsb2F0IGludkRUKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIGludkRUICogX2xpbmVhckltcHVsc2U7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwdWJsaWMgb3ZlcnJpZGUgZmxvYXQgR2V0UmVhY3Rpb25Ub3JxdWUoZmxvYXQgaW52RFQpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gaW52RFQgKiBfYW5ndWxhckltcHVsc2U7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpbnRlcm5hbCBvdmVycmlkZSB2b2lkIEluaXRWZWxvY2l0eUNvbnN0cmFpbnRzKHJlZiBUaW1lU3RlcCBzdGVwKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgQm9keSBiQSA9IEJvZHlBO1xyXG5cclxuICAgICAgICAgICAgVHJhbnNmb3JtIHhmQTtcclxuICAgICAgICAgICAgYkEuR2V0VHJhbnNmb3JtKG91dCB4ZkEpO1xyXG5cclxuICAgICAgICAgICAgLy8gQ29tcHV0ZSB0aGUgZWZmZWN0aXZlIG1hc3MgbWF0cml4LlxyXG4gICAgICAgICAgICBWZWN0b3IyIHJBID0gTWF0aFV0aWxzLk11bHRpcGx5KHJlZiB4ZkEuUiwgTG9jYWxBbmNob3JBIC0gYkEuTG9jYWxDZW50ZXIpO1xyXG5cclxuICAgICAgICAgICAgLy8gSiA9IFstSSAtcjFfc2tldyBJIHIyX3NrZXddXHJcbiAgICAgICAgICAgIC8vICAgICBbIDAgICAgICAgLTEgMCAgICAgICAxXVxyXG4gICAgICAgICAgICAvLyByX3NrZXcgPSBbLXJ5OyByeF1cclxuXHJcbiAgICAgICAgICAgIC8vIE1hdGxhYlxyXG4gICAgICAgICAgICAvLyBLID0gWyBtQStyMXleMippQSttQityMnleMippQiwgIC1yMXkqaUEqcjF4LXIyeSppQipyMngsICAgICAgICAgIC1yMXkqaUEtcjJ5KmlCXVxyXG4gICAgICAgICAgICAvLyAgICAgWyAgLXIxeSppQSpyMXgtcjJ5KmlCKnIyeCwgbUErcjF4XjIqaUErbUIrcjJ4XjIqaUIsICAgICAgICAgICByMXgqaUErcjJ4KmlCXVxyXG4gICAgICAgICAgICAvLyAgICAgWyAgICAgICAgICAtcjF5KmlBLXIyeSppQiwgICAgICAgICAgIHIxeCppQStyMngqaUIsICAgICAgICAgICAgICAgICAgIGlBK2lCXVxyXG5cclxuICAgICAgICAgICAgZmxvYXQgbUEgPSBiQS5JbnZNYXNzO1xyXG4gICAgICAgICAgICBmbG9hdCBpQSA9IGJBLkludkk7XHJcblxyXG4gICAgICAgICAgICBNYXQyMiBLMSA9IG5ldyBNYXQyMigpO1xyXG4gICAgICAgICAgICBLMS5Db2wxLlggPSBtQTtcclxuICAgICAgICAgICAgSzEuQ29sMi5YID0gMC4wZjtcclxuICAgICAgICAgICAgSzEuQ29sMS5ZID0gMC4wZjtcclxuICAgICAgICAgICAgSzEuQ29sMi5ZID0gbUE7XHJcblxyXG4gICAgICAgICAgICBNYXQyMiBLMiA9IG5ldyBNYXQyMigpO1xyXG4gICAgICAgICAgICBLMi5Db2wxLlggPSBpQSAqIHJBLlkgKiByQS5ZO1xyXG4gICAgICAgICAgICBLMi5Db2wyLlggPSAtaUEgKiByQS5YICogckEuWTtcclxuICAgICAgICAgICAgSzIuQ29sMS5ZID0gLWlBICogckEuWCAqIHJBLlk7XHJcbiAgICAgICAgICAgIEsyLkNvbDIuWSA9IGlBICogckEuWCAqIHJBLlg7XHJcblxyXG4gICAgICAgICAgICBNYXQyMiBLMTI7XHJcbiAgICAgICAgICAgIE1hdDIyLkFkZChyZWYgSzEsIHJlZiBLMiwgb3V0IEsxMik7XHJcblxyXG4gICAgICAgICAgICBfbGluZWFyTWFzcyA9IEsxMi5JbnZlcnNlO1xyXG5cclxuICAgICAgICAgICAgX2FuZ3VsYXJNYXNzID0gaUE7XHJcbiAgICAgICAgICAgIGlmIChfYW5ndWxhck1hc3MgPiAwLjBmKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBfYW5ndWxhck1hc3MgPSAxLjBmIC8gX2FuZ3VsYXJNYXNzO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAoU2V0dGluZ3MuRW5hYmxlV2FybXN0YXJ0aW5nKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAvLyBTY2FsZSBpbXB1bHNlcyB0byBzdXBwb3J0IGEgdmFyaWFibGUgdGltZSBzdGVwLlxyXG4gICAgICAgICAgICAgICAgX2xpbmVhckltcHVsc2UgKj0gc3RlcC5kdFJhdGlvO1xyXG4gICAgICAgICAgICAgICAgX2FuZ3VsYXJJbXB1bHNlICo9IHN0ZXAuZHRSYXRpbztcclxuXHJcbiAgICAgICAgICAgICAgICBWZWN0b3IyIFAgPSBuZXcgVmVjdG9yMihfbGluZWFySW1wdWxzZS5YLCBfbGluZWFySW1wdWxzZS5ZKTtcclxuXHJcbiAgICAgICAgICAgICAgICBiQS5MaW5lYXJWZWxvY2l0eUludGVybmFsIC09IG1BICogUDtcclxuICAgICAgICAgICAgICAgIGJBLkFuZ3VsYXJWZWxvY2l0eUludGVybmFsIC09IGlBICogKE1hdGhVdGlscy5Dcm9zcyhyQSwgUCkgKyBfYW5ndWxhckltcHVsc2UpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgX2xpbmVhckltcHVsc2UgPSBWZWN0b3IyLlplcm87XHJcbiAgICAgICAgICAgICAgICBfYW5ndWxhckltcHVsc2UgPSAwLjBmO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpbnRlcm5hbCBvdmVycmlkZSB2b2lkIFNvbHZlVmVsb2NpdHlDb25zdHJhaW50cyhyZWYgVGltZVN0ZXAgc3RlcClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIEJvZHkgYkEgPSBCb2R5QTtcclxuXHJcbiAgICAgICAgICAgIFZlY3RvcjIgdkEgPSBiQS5MaW5lYXJWZWxvY2l0eUludGVybmFsO1xyXG4gICAgICAgICAgICBmbG9hdCB3QSA9IGJBLkFuZ3VsYXJWZWxvY2l0eUludGVybmFsO1xyXG5cclxuICAgICAgICAgICAgZmxvYXQgbUEgPSBiQS5JbnZNYXNzO1xyXG4gICAgICAgICAgICBmbG9hdCBpQSA9IGJBLkludkk7XHJcblxyXG4gICAgICAgICAgICBUcmFuc2Zvcm0geGZBO1xyXG4gICAgICAgICAgICBiQS5HZXRUcmFuc2Zvcm0ob3V0IHhmQSk7XHJcblxyXG4gICAgICAgICAgICBWZWN0b3IyIHJBID0gTWF0aFV0aWxzLk11bHRpcGx5KHJlZiB4ZkEuUiwgTG9jYWxBbmNob3JBIC0gYkEuTG9jYWxDZW50ZXIpO1xyXG5cclxuICAgICAgICAgICAgLy8gU29sdmUgYW5ndWxhciBmcmljdGlvblxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBmbG9hdCBDZG90ID0gLXdBO1xyXG4gICAgICAgICAgICAgICAgZmxvYXQgaW1wdWxzZSA9IC1fYW5ndWxhck1hc3MgKiBDZG90O1xyXG5cclxuICAgICAgICAgICAgICAgIGZsb2F0IG9sZEltcHVsc2UgPSBfYW5ndWxhckltcHVsc2U7XHJcbiAgICAgICAgICAgICAgICBmbG9hdCBtYXhJbXB1bHNlID0gc3RlcC5kdCAqIE1heFRvcnF1ZTtcclxuICAgICAgICAgICAgICAgIF9hbmd1bGFySW1wdWxzZSA9IE1hdGhVdGlscy5DbGFtcChfYW5ndWxhckltcHVsc2UgKyBpbXB1bHNlLCAtbWF4SW1wdWxzZSwgbWF4SW1wdWxzZSk7XHJcbiAgICAgICAgICAgICAgICBpbXB1bHNlID0gX2FuZ3VsYXJJbXB1bHNlIC0gb2xkSW1wdWxzZTtcclxuXHJcbiAgICAgICAgICAgICAgICB3QSAtPSBpQSAqIGltcHVsc2U7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIFNvbHZlIGxpbmVhciBmcmljdGlvblxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBWZWN0b3IyIENkb3QgPSAtdkEgLSBNYXRoVXRpbHMuQ3Jvc3Mod0EsIHJBKTtcclxuXHJcbiAgICAgICAgICAgICAgICBWZWN0b3IyIGltcHVsc2UgPSAtTWF0aFV0aWxzLk11bHRpcGx5KHJlZiBfbGluZWFyTWFzcywgQ2RvdCk7XHJcbiAgICAgICAgICAgICAgICBWZWN0b3IyIG9sZEltcHVsc2UgPSBfbGluZWFySW1wdWxzZTtcclxuICAgICAgICAgICAgICAgIF9saW5lYXJJbXB1bHNlICs9IGltcHVsc2U7XHJcblxyXG4gICAgICAgICAgICAgICAgZmxvYXQgbWF4SW1wdWxzZSA9IHN0ZXAuZHQgKiBNYXhGb3JjZTtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoX2xpbmVhckltcHVsc2UuTGVuZ3RoU3F1YXJlZCgpID4gbWF4SW1wdWxzZSAqIG1heEltcHVsc2UpXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgX2xpbmVhckltcHVsc2UuTm9ybWFsaXplKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgX2xpbmVhckltcHVsc2UgKj0gbWF4SW1wdWxzZTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBpbXB1bHNlID0gX2xpbmVhckltcHVsc2UgLSBvbGRJbXB1bHNlO1xyXG5cclxuICAgICAgICAgICAgICAgIHZBIC09IG1BICogaW1wdWxzZTtcclxuICAgICAgICAgICAgICAgIHdBIC09IGlBICogTWF0aFV0aWxzLkNyb3NzKHJBLCBpbXB1bHNlKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgYkEuTGluZWFyVmVsb2NpdHlJbnRlcm5hbCA9IHZBO1xyXG4gICAgICAgICAgICBiQS5Bbmd1bGFyVmVsb2NpdHlJbnRlcm5hbCA9IHdBO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaW50ZXJuYWwgb3ZlcnJpZGUgYm9vbCBTb2x2ZVBvc2l0aW9uQ29uc3RyYWludHMoKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59IiwiLypcclxuKiBGYXJzZWVyIFBoeXNpY3MgRW5naW5lIGJhc2VkIG9uIEJveDJELlhOQSBwb3J0OlxyXG4qIENvcHlyaWdodCAoYykgMjAxMCBJYW4gUXZpc3RcclxuKiBcclxuKiBCb3gyRC5YTkEgcG9ydCBvZiBCb3gyRDpcclxuKiBDb3B5cmlnaHQgKGMpIDIwMDkgQnJhbmRvbiBGdXJ0d2FuZ2xlciwgTmF0aGFuIEZ1cnR3YW5nbGVyXHJcbipcclxuKiBPcmlnaW5hbCBzb3VyY2UgQm94MkQ6XHJcbiogQ29weXJpZ2h0IChjKSAyMDA2LTIwMDkgRXJpbiBDYXR0byBodHRwOi8vd3d3LmdwaHlzaWNzLmNvbSBcclxuKiBcclxuKiBUaGlzIHNvZnR3YXJlIGlzIHByb3ZpZGVkICdhcy1pcycsIHdpdGhvdXQgYW55IGV4cHJlc3Mgb3IgaW1wbGllZCBcclxuKiB3YXJyYW50eS4gIEluIG5vIGV2ZW50IHdpbGwgdGhlIGF1dGhvcnMgYmUgaGVsZCBsaWFibGUgZm9yIGFueSBkYW1hZ2VzIFxyXG4qIGFyaXNpbmcgZnJvbSB0aGUgdXNlIG9mIHRoaXMgc29mdHdhcmUuIFxyXG4qIFBlcm1pc3Npb24gaXMgZ3JhbnRlZCB0byBhbnlvbmUgdG8gdXNlIHRoaXMgc29mdHdhcmUgZm9yIGFueSBwdXJwb3NlLCBcclxuKiBpbmNsdWRpbmcgY29tbWVyY2lhbCBhcHBsaWNhdGlvbnMsIGFuZCB0byBhbHRlciBpdCBhbmQgcmVkaXN0cmlidXRlIGl0IFxyXG4qIGZyZWVseSwgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIHJlc3RyaWN0aW9uczogXHJcbiogMS4gVGhlIG9yaWdpbiBvZiB0aGlzIHNvZnR3YXJlIG11c3Qgbm90IGJlIG1pc3JlcHJlc2VudGVkOyB5b3UgbXVzdCBub3QgXHJcbiogY2xhaW0gdGhhdCB5b3Ugd3JvdGUgdGhlIG9yaWdpbmFsIHNvZnR3YXJlLiBJZiB5b3UgdXNlIHRoaXMgc29mdHdhcmUgXHJcbiogaW4gYSBwcm9kdWN0LCBhbiBhY2tub3dsZWRnbWVudCBpbiB0aGUgcHJvZHVjdCBkb2N1bWVudGF0aW9uIHdvdWxkIGJlIFxyXG4qIGFwcHJlY2lhdGVkIGJ1dCBpcyBub3QgcmVxdWlyZWQuIFxyXG4qIDIuIEFsdGVyZWQgc291cmNlIHZlcnNpb25zIG11c3QgYmUgcGxhaW5seSBtYXJrZWQgYXMgc3VjaCwgYW5kIG11c3Qgbm90IGJlIFxyXG4qIG1pc3JlcHJlc2VudGVkIGFzIGJlaW5nIHRoZSBvcmlnaW5hbCBzb2Z0d2FyZS4gXHJcbiogMy4gVGhpcyBub3RpY2UgbWF5IG5vdCBiZSByZW1vdmVkIG9yIGFsdGVyZWQgZnJvbSBhbnkgc291cmNlIGRpc3RyaWJ1dGlvbi4gXHJcbiovXHJcblxyXG51c2luZyBTeXN0ZW07XHJcbnVzaW5nIFN5c3RlbS5EaWFnbm9zdGljcztcclxudXNpbmcgRmFyc2VlclBoeXNpY3MuQ29tbW9uO1xyXG51c2luZyBNaWNyb3NvZnQuWG5hLkZyYW1ld29yaztcclxuXHJcbm5hbWVzcGFjZSBGYXJzZWVyUGh5c2ljcy5EeW5hbWljcy5Kb2ludHNcclxue1xyXG4gICAgcHVibGljIGNsYXNzIEZpeGVkTGluZUpvaW50IDogSm9pbnRcclxuICAgIHtcclxuICAgICAgICBwcml2YXRlIFZlY3RvcjIgX2F4LCBfYXk7XHJcbiAgICAgICAgcHJpdmF0ZSBmbG9hdCBfYmlhcztcclxuICAgICAgICBwcml2YXRlIGJvb2wgX2VuYWJsZU1vdG9yO1xyXG4gICAgICAgIHByaXZhdGUgZmxvYXQgX2dhbW1hO1xyXG4gICAgICAgIHByaXZhdGUgZmxvYXQgX2ltcHVsc2U7XHJcbiAgICAgICAgcHJpdmF0ZSBWZWN0b3IyIF9sb2NhbFhBeGlzO1xyXG4gICAgICAgIHByaXZhdGUgVmVjdG9yMiBfbG9jYWxZQXhpc0E7XHJcbiAgICAgICAgcHJpdmF0ZSBmbG9hdCBfbWFzcztcclxuICAgICAgICBwcml2YXRlIGZsb2F0IF9tYXhNb3RvclRvcnF1ZTtcclxuICAgICAgICBwcml2YXRlIGZsb2F0IF9tb3RvckltcHVsc2U7XHJcbiAgICAgICAgcHJpdmF0ZSBmbG9hdCBfbW90b3JNYXNzO1xyXG4gICAgICAgIHByaXZhdGUgZmxvYXQgX21vdG9yU3BlZWQ7XHJcblxyXG4gICAgICAgIHByaXZhdGUgZmxvYXQgX3NBeDtcclxuICAgICAgICBwcml2YXRlIGZsb2F0IF9zQXk7XHJcbiAgICAgICAgcHJpdmF0ZSBmbG9hdCBfc0J4O1xyXG4gICAgICAgIHByaXZhdGUgZmxvYXQgX3NCeTtcclxuXHJcbiAgICAgICAgcHJpdmF0ZSBmbG9hdCBfc3ByaW5nSW1wdWxzZTtcclxuICAgICAgICBwcml2YXRlIGZsb2F0IF9zcHJpbmdNYXNzO1xyXG5cclxuICAgICAgICAvLyBMaW5lYXIgY29uc3RyYWludCAocG9pbnQtdG8tbGluZSlcclxuICAgICAgICAvLyBkID0gcEIgLSBwQSA9IHhCICsgckIgLSB4QSAtIHJBXHJcbiAgICAgICAgLy8gQyA9IGRvdChheSwgZClcclxuICAgICAgICAvLyBDZG90ID0gZG90KGQsIGNyb3NzKHdBLCBheSkpICsgZG90KGF5LCB2QiArIGNyb3NzKHdCLCByQikgLSB2QSAtIGNyb3NzKHdBLCByQSkpXHJcbiAgICAgICAgLy8gICAgICA9IC1kb3QoYXksIHZBKSAtIGRvdChjcm9zcyhkICsgckEsIGF5KSwgd0EpICsgZG90KGF5LCB2QikgKyBkb3QoY3Jvc3MockIsIGF5KSwgdkIpXHJcbiAgICAgICAgLy8gSiA9IFstYXksIC1jcm9zcyhkICsgckEsIGF5KSwgYXksIGNyb3NzKHJCLCBheSldXHJcblxyXG4gICAgICAgIC8vIFNwcmluZyBsaW5lYXIgY29uc3RyYWludFxyXG4gICAgICAgIC8vIEMgPSBkb3QoYXgsIGQpXHJcbiAgICAgICAgLy8gQ2RvdCA9ID0gLWRvdChheCwgdkEpIC0gZG90KGNyb3NzKGQgKyByQSwgYXgpLCB3QSkgKyBkb3QoYXgsIHZCKSArIGRvdChjcm9zcyhyQiwgYXgpLCB2QilcclxuICAgICAgICAvLyBKID0gWy1heCAtY3Jvc3MoZCtyQSwgYXgpIGF4IGNyb3NzKHJCLCBheCldXHJcblxyXG4gICAgICAgIC8vIE1vdG9yIHJvdGF0aW9uYWwgY29uc3RyYWludFxyXG4gICAgICAgIC8vIENkb3QgPSB3QiAtIHdBXHJcbiAgICAgICAgLy8gSiA9IFswIDAgLTEgMCAwIDFdXHJcblxyXG4gICAgICAgIGludGVybmFsIEZpeGVkTGluZUpvaW50KCkgeyBKb2ludFR5cGUgPSBKb2ludFR5cGUuRml4ZWRMaW5lOyB9XHJcblxyXG4gICAgICAgIHB1YmxpYyBGaXhlZExpbmVKb2ludChCb2R5IGJvZHksIFZlY3RvcjIgd29ybGRBbmNob3IsIFZlY3RvcjIgYXhpcylcclxuICAgICAgICAgICAgOiBiYXNlKGJvZHkpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBKb2ludFR5cGUgPSBKb2ludFR5cGUuRml4ZWRMaW5lO1xyXG5cclxuICAgICAgICAgICAgQm9keUIgPSBCb2R5QTtcclxuXHJcbiAgICAgICAgICAgIExvY2FsQW5jaG9yQSA9IHdvcmxkQW5jaG9yO1xyXG4gICAgICAgICAgICBMb2NhbEFuY2hvckIgPSBCb2R5Qi5HZXRMb2NhbFBvaW50KHdvcmxkQW5jaG9yKTtcclxuICAgICAgICAgICAgTG9jYWxYQXhpcyA9IGF4aXM7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwdWJsaWMgVmVjdG9yMiBMb2NhbEFuY2hvckEgeyBnZXQ7IHNldDsgfVxyXG5cclxuICAgICAgICBwdWJsaWMgVmVjdG9yMiBMb2NhbEFuY2hvckIgeyBnZXQ7IHNldDsgfVxyXG5cclxuICAgICAgICBwdWJsaWMgb3ZlcnJpZGUgVmVjdG9yMiBXb3JsZEFuY2hvckFcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGdldCB7IHJldHVybiBMb2NhbEFuY2hvckE7IH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHB1YmxpYyBvdmVycmlkZSBWZWN0b3IyIFdvcmxkQW5jaG9yQlxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgZ2V0IHsgcmV0dXJuIEJvZHlBLkdldFdvcmxkUG9pbnQoTG9jYWxBbmNob3JCKTsgfVxyXG4gICAgICAgICAgICBzZXQgeyBEZWJ1Zy5Bc3NlcnQoZmFsc2UsIFwiWW91IGNhbid0IHNldCB0aGUgd29ybGQgYW5jaG9yIG9uIHRoaXMgam9pbnQgdHlwZS5cIik7IH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHB1YmxpYyBmbG9hdCBKb2ludFRyYW5zbGF0aW9uXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBnZXRcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgQm9keSBiQSA9IEJvZHlBO1xyXG4gICAgICAgICAgICAgICAgQm9keSBiQiA9IEJvZHlCO1xyXG5cclxuICAgICAgICAgICAgICAgIFZlY3RvcjIgcEEgPSBiQS5HZXRXb3JsZFBvaW50KExvY2FsQW5jaG9yQSk7XHJcbiAgICAgICAgICAgICAgICBWZWN0b3IyIHBCID0gYkIuR2V0V29ybGRQb2ludChMb2NhbEFuY2hvckIpO1xyXG4gICAgICAgICAgICAgICAgVmVjdG9yMiBkID0gcEIgLSBwQTtcclxuICAgICAgICAgICAgICAgIFZlY3RvcjIgYXhpcyA9IGJBLkdldFdvcmxkVmVjdG9yKExvY2FsWEF4aXMpO1xyXG5cclxuICAgICAgICAgICAgICAgIGZsb2F0IHRyYW5zbGF0aW9uID0gVmVjdG9yMi5Eb3QoZCwgYXhpcyk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJhbnNsYXRpb247XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHB1YmxpYyBmbG9hdCBKb2ludFNwZWVkXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBnZXRcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgZmxvYXQgd0EgPSBCb2R5QS5Bbmd1bGFyVmVsb2NpdHlJbnRlcm5hbDtcclxuICAgICAgICAgICAgICAgIGZsb2F0IHdCID0gQm9keUIuQW5ndWxhclZlbG9jaXR5SW50ZXJuYWw7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gd0IgLSB3QTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHVibGljIGJvb2wgTW90b3JFbmFibGVkXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBnZXQgeyByZXR1cm4gX2VuYWJsZU1vdG9yOyB9XHJcbiAgICAgICAgICAgIHNldFxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBCb2R5QS5Bd2FrZSA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICBCb2R5Qi5Bd2FrZSA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICBfZW5hYmxlTW90b3IgPSB2YWx1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHVibGljIGZsb2F0IE1vdG9yU3BlZWRcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHNldFxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBCb2R5QS5Bd2FrZSA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICBCb2R5Qi5Bd2FrZSA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICBfbW90b3JTcGVlZCA9IHZhbHVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGdldCB7IHJldHVybiBfbW90b3JTcGVlZDsgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHVibGljIGZsb2F0IE1heE1vdG9yVG9ycXVlXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBzZXRcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgQm9keUEuQXdha2UgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgQm9keUIuQXdha2UgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgX21heE1vdG9yVG9ycXVlID0gdmFsdWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZ2V0IHsgcmV0dXJuIF9tYXhNb3RvclRvcnF1ZTsgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHVibGljIGZsb2F0IEZyZXF1ZW5jeSB7IGdldDsgc2V0OyB9XHJcblxyXG4gICAgICAgIHB1YmxpYyBmbG9hdCBEYW1waW5nUmF0aW8geyBnZXQ7IHNldDsgfVxyXG5cclxuICAgICAgICBwdWJsaWMgVmVjdG9yMiBMb2NhbFhBeGlzXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBnZXQgeyByZXR1cm4gX2xvY2FsWEF4aXM7IH1cclxuICAgICAgICAgICAgc2V0XHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIF9sb2NhbFhBeGlzID0gdmFsdWU7XHJcbiAgICAgICAgICAgICAgICBfbG9jYWxZQXhpc0EgPSBNYXRoVXRpbHMuQ3Jvc3MoMS4wZiwgX2xvY2FsWEF4aXMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwdWJsaWMgb3ZlcnJpZGUgVmVjdG9yMiBHZXRSZWFjdGlvbkZvcmNlKGZsb2F0IGludkR0KVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIGludkR0ICogKF9pbXB1bHNlICogX2F5ICsgX3NwcmluZ0ltcHVsc2UgKiBfYXgpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHVibGljIG92ZXJyaWRlIGZsb2F0IEdldFJlYWN0aW9uVG9ycXVlKGZsb2F0IGludkR0KVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIGludkR0ICogX21vdG9ySW1wdWxzZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGludGVybmFsIG92ZXJyaWRlIHZvaWQgSW5pdFZlbG9jaXR5Q29uc3RyYWludHMocmVmIFRpbWVTdGVwIHN0ZXApXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBCb2R5IGJCID0gQm9keUI7XHJcblxyXG4gICAgICAgICAgICBMb2NhbENlbnRlckEgPSBWZWN0b3IyLlplcm87XHJcbiAgICAgICAgICAgIExvY2FsQ2VudGVyQiA9IGJCLkxvY2FsQ2VudGVyO1xyXG5cclxuICAgICAgICAgICAgVHJhbnNmb3JtIHhmQjtcclxuICAgICAgICAgICAgYkIuR2V0VHJhbnNmb3JtKG91dCB4ZkIpO1xyXG5cclxuICAgICAgICAgICAgLy8gQ29tcHV0ZSB0aGUgZWZmZWN0aXZlIG1hc3Nlcy5cclxuICAgICAgICAgICAgVmVjdG9yMiByQSA9IExvY2FsQW5jaG9yQTtcclxuICAgICAgICAgICAgVmVjdG9yMiByQiA9IE1hdGhVdGlscy5NdWx0aXBseShyZWYgeGZCLlIsIExvY2FsQW5jaG9yQiAtIExvY2FsQ2VudGVyQik7XHJcbiAgICAgICAgICAgIFZlY3RvcjIgZCA9IGJCLlN3ZWVwLkMgKyByQiAtIHJBO1xyXG5cclxuICAgICAgICAgICAgSW52TWFzc0EgPSAwLjBmO1xyXG4gICAgICAgICAgICBJbnZJQSA9IDAuMGY7XHJcbiAgICAgICAgICAgIEludk1hc3NCID0gYkIuSW52TWFzcztcclxuICAgICAgICAgICAgSW52SUIgPSBiQi5JbnZJO1xyXG5cclxuICAgICAgICAgICAgLy8gUG9pbnQgdG8gbGluZSBjb25zdHJhaW50XHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIF9heSA9IF9sb2NhbFlBeGlzQTtcclxuICAgICAgICAgICAgICAgIF9zQXkgPSBNYXRoVXRpbHMuQ3Jvc3MoZCArIHJBLCBfYXkpO1xyXG4gICAgICAgICAgICAgICAgX3NCeSA9IE1hdGhVdGlscy5Dcm9zcyhyQiwgX2F5KTtcclxuXHJcbiAgICAgICAgICAgICAgICBfbWFzcyA9IEludk1hc3NBICsgSW52TWFzc0IgKyBJbnZJQSAqIF9zQXkgKiBfc0F5ICsgSW52SUIgKiBfc0J5ICogX3NCeTtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoX21hc3MgPiAwLjBmKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIF9tYXNzID0gMS4wZiAvIF9tYXNzO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBTcHJpbmcgY29uc3RyYWludFxyXG4gICAgICAgICAgICBfc3ByaW5nTWFzcyA9IDAuMGY7XHJcbiAgICAgICAgICAgIGlmIChGcmVxdWVuY3kgPiAwLjBmKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBfYXggPSBMb2NhbFhBeGlzO1xyXG4gICAgICAgICAgICAgICAgX3NBeCA9IE1hdGhVdGlscy5Dcm9zcyhkICsgckEsIF9heCk7XHJcbiAgICAgICAgICAgICAgICBfc0J4ID0gTWF0aFV0aWxzLkNyb3NzKHJCLCBfYXgpO1xyXG5cclxuICAgICAgICAgICAgICAgIGZsb2F0IGludk1hc3MgPSBJbnZNYXNzQSArIEludk1hc3NCICsgSW52SUEgKiBfc0F4ICogX3NBeCArIEludklCICogX3NCeCAqIF9zQng7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKGludk1hc3MgPiAwLjBmKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIF9zcHJpbmdNYXNzID0gMS4wZiAvIGludk1hc3M7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGZsb2F0IEMgPSBWZWN0b3IyLkRvdChkLCBfYXgpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBGcmVxdWVuY3lcclxuICAgICAgICAgICAgICAgICAgICBmbG9hdCBvbWVnYSA9IDIuMGYgKiBTZXR0aW5ncy5QaSAqIEZyZXF1ZW5jeTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gRGFtcGluZyBjb2VmZmljaWVudFxyXG4gICAgICAgICAgICAgICAgICAgIGZsb2F0IGRhID0gMi4wZiAqIF9zcHJpbmdNYXNzICogRGFtcGluZ1JhdGlvICogb21lZ2E7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIFNwcmluZyBzdGlmZm5lc3NcclxuICAgICAgICAgICAgICAgICAgICBmbG9hdCBrID0gX3NwcmluZ01hc3MgKiBvbWVnYSAqIG9tZWdhO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBtYWdpYyBmb3JtdWxhc1xyXG4gICAgICAgICAgICAgICAgICAgIF9nYW1tYSA9IHN0ZXAuZHQgKiAoZGEgKyBzdGVwLmR0ICogayk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKF9nYW1tYSA+IDAuMGYpXHJcbiAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBfZ2FtbWEgPSAxLjBmIC8gX2dhbW1hO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgX2JpYXMgPSBDICogc3RlcC5kdCAqIGsgKiBfZ2FtbWE7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIF9zcHJpbmdNYXNzID0gaW52TWFzcyArIF9nYW1tYTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoX3NwcmluZ01hc3MgPiAwLjBmKVxyXG4gICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgX3NwcmluZ01hc3MgPSAxLjBmIC8gX3NwcmluZ01hc3M7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgX3NwcmluZ0ltcHVsc2UgPSAwLjBmO1xyXG4gICAgICAgICAgICAgICAgX3NwcmluZ01hc3MgPSAwLjBmO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBSb3RhdGlvbmFsIG1vdG9yXHJcbiAgICAgICAgICAgIGlmIChfZW5hYmxlTW90b3IpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIF9tb3Rvck1hc3MgPSBJbnZJQSArIEludklCO1xyXG4gICAgICAgICAgICAgICAgaWYgKF9tb3Rvck1hc3MgPiAwLjBmKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIF9tb3Rvck1hc3MgPSAxLjBmIC8gX21vdG9yTWFzcztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIF9tb3Rvck1hc3MgPSAwLjBmO1xyXG4gICAgICAgICAgICAgICAgX21vdG9ySW1wdWxzZSA9IDAuMGY7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmIChTZXR0aW5ncy5FbmFibGVXYXJtc3RhcnRpbmcpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIC8vIEFjY291bnQgZm9yIHZhcmlhYmxlIHRpbWUgc3RlcC5cclxuICAgICAgICAgICAgICAgIF9pbXB1bHNlICo9IHN0ZXAuZHRSYXRpbztcclxuICAgICAgICAgICAgICAgIF9zcHJpbmdJbXB1bHNlICo9IHN0ZXAuZHRSYXRpbztcclxuICAgICAgICAgICAgICAgIF9tb3RvckltcHVsc2UgKj0gc3RlcC5kdFJhdGlvO1xyXG5cclxuICAgICAgICAgICAgICAgIFZlY3RvcjIgUCA9IF9pbXB1bHNlICogX2F5ICsgX3NwcmluZ0ltcHVsc2UgKiBfYXg7XHJcbiAgICAgICAgICAgICAgICBmbG9hdCBMQiA9IF9pbXB1bHNlICogX3NCeSArIF9zcHJpbmdJbXB1bHNlICogX3NCeCArIF9tb3RvckltcHVsc2U7XHJcblxyXG4gICAgICAgICAgICAgICAgYkIuTGluZWFyVmVsb2NpdHlJbnRlcm5hbCArPSBJbnZNYXNzQiAqIFA7XHJcbiAgICAgICAgICAgICAgICBiQi5Bbmd1bGFyVmVsb2NpdHlJbnRlcm5hbCArPSBJbnZJQiAqIExCO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgX2ltcHVsc2UgPSAwLjBmO1xyXG4gICAgICAgICAgICAgICAgX3NwcmluZ0ltcHVsc2UgPSAwLjBmO1xyXG4gICAgICAgICAgICAgICAgX21vdG9ySW1wdWxzZSA9IDAuMGY7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGludGVybmFsIG92ZXJyaWRlIHZvaWQgU29sdmVWZWxvY2l0eUNvbnN0cmFpbnRzKHJlZiBUaW1lU3RlcCBzdGVwKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgQm9keSBiQiA9IEJvZHlCO1xyXG5cclxuICAgICAgICAgICAgVmVjdG9yMiB2QSA9IFZlY3RvcjIuWmVybztcclxuICAgICAgICAgICAgZmxvYXQgd0EgPSAwLjBmO1xyXG4gICAgICAgICAgICBWZWN0b3IyIHZCID0gYkIuTGluZWFyVmVsb2NpdHlJbnRlcm5hbDtcclxuICAgICAgICAgICAgZmxvYXQgd0IgPSBiQi5Bbmd1bGFyVmVsb2NpdHlJbnRlcm5hbDtcclxuXHJcbiAgICAgICAgICAgIC8vIFNvbHZlIHNwcmluZyBjb25zdHJhaW50XHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGZsb2F0IENkb3QgPSBWZWN0b3IyLkRvdChfYXgsIHZCIC0gdkEpICsgX3NCeCAqIHdCIC0gX3NBeCAqIHdBO1xyXG4gICAgICAgICAgICAgICAgZmxvYXQgaW1wdWxzZSA9IC1fc3ByaW5nTWFzcyAqIChDZG90ICsgX2JpYXMgKyBfZ2FtbWEgKiBfc3ByaW5nSW1wdWxzZSk7XHJcbiAgICAgICAgICAgICAgICBfc3ByaW5nSW1wdWxzZSArPSBpbXB1bHNlO1xyXG5cclxuICAgICAgICAgICAgICAgIFZlY3RvcjIgUCA9IGltcHVsc2UgKiBfYXg7XHJcbiAgICAgICAgICAgICAgICBmbG9hdCBMQSA9IGltcHVsc2UgKiBfc0F4O1xyXG4gICAgICAgICAgICAgICAgZmxvYXQgTEIgPSBpbXB1bHNlICogX3NCeDtcclxuXHJcbiAgICAgICAgICAgICAgICB2QSAtPSBJbnZNYXNzQSAqIFA7XHJcbiAgICAgICAgICAgICAgICB3QSAtPSBJbnZJQSAqIExBO1xyXG5cclxuICAgICAgICAgICAgICAgIHZCICs9IEludk1hc3NCICogUDtcclxuICAgICAgICAgICAgICAgIHdCICs9IEludklCICogTEI7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIFNvbHZlIHJvdGF0aW9uYWwgbW90b3IgY29uc3RyYWludFxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBmbG9hdCBDZG90ID0gd0IgLSB3QSAtIF9tb3RvclNwZWVkO1xyXG4gICAgICAgICAgICAgICAgZmxvYXQgaW1wdWxzZSA9IC1fbW90b3JNYXNzICogQ2RvdDtcclxuXHJcbiAgICAgICAgICAgICAgICBmbG9hdCBvbGRJbXB1bHNlID0gX21vdG9ySW1wdWxzZTtcclxuICAgICAgICAgICAgICAgIGZsb2F0IG1heEltcHVsc2UgPSBzdGVwLmR0ICogX21heE1vdG9yVG9ycXVlO1xyXG4gICAgICAgICAgICAgICAgX21vdG9ySW1wdWxzZSA9IE1hdGhVdGlscy5DbGFtcChfbW90b3JJbXB1bHNlICsgaW1wdWxzZSwgLW1heEltcHVsc2UsIG1heEltcHVsc2UpO1xyXG4gICAgICAgICAgICAgICAgaW1wdWxzZSA9IF9tb3RvckltcHVsc2UgLSBvbGRJbXB1bHNlO1xyXG5cclxuICAgICAgICAgICAgICAgIHdBIC09IEludklBICogaW1wdWxzZTtcclxuICAgICAgICAgICAgICAgIHdCICs9IEludklCICogaW1wdWxzZTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gU29sdmUgcG9pbnQgdG8gbGluZSBjb25zdHJhaW50XHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGZsb2F0IENkb3QgPSBWZWN0b3IyLkRvdChfYXksIHZCIC0gdkEpICsgX3NCeSAqIHdCIC0gX3NBeSAqIHdBO1xyXG4gICAgICAgICAgICAgICAgZmxvYXQgaW1wdWxzZSA9IF9tYXNzICogKC1DZG90KTtcclxuICAgICAgICAgICAgICAgIF9pbXB1bHNlICs9IGltcHVsc2U7XHJcblxyXG4gICAgICAgICAgICAgICAgVmVjdG9yMiBQID0gaW1wdWxzZSAqIF9heTtcclxuICAgICAgICAgICAgICAgIGZsb2F0IExCID0gaW1wdWxzZSAqIF9zQnk7XHJcblxyXG4gICAgICAgICAgICAgICAgdkIgKz0gSW52TWFzc0IgKiBQO1xyXG4gICAgICAgICAgICAgICAgd0IgKz0gSW52SUIgKiBMQjtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgYkIuTGluZWFyVmVsb2NpdHlJbnRlcm5hbCA9IHZCO1xyXG4gICAgICAgICAgICBiQi5Bbmd1bGFyVmVsb2NpdHlJbnRlcm5hbCA9IHdCO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaW50ZXJuYWwgb3ZlcnJpZGUgYm9vbCBTb2x2ZVBvc2l0aW9uQ29uc3RyYWludHMoKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgQm9keSBiQiA9IEJvZHlCO1xyXG5cclxuICAgICAgICAgICAgVmVjdG9yMiB4QSA9IFZlY3RvcjIuWmVybztcclxuICAgICAgICAgICAgY29uc3QgZmxvYXQgYW5nbGVBID0gMC4wZjtcclxuXHJcbiAgICAgICAgICAgIFZlY3RvcjIgeEIgPSBiQi5Td2VlcC5DO1xyXG4gICAgICAgICAgICBmbG9hdCBhbmdsZUIgPSBiQi5Td2VlcC5BO1xyXG5cclxuICAgICAgICAgICAgTWF0MjIgUkEgPSBuZXcgTWF0MjIoYW5nbGVBKTtcclxuICAgICAgICAgICAgTWF0MjIgUkIgPSBuZXcgTWF0MjIoYW5nbGVCKTtcclxuXHJcbiAgICAgICAgICAgIFZlY3RvcjIgckEgPSBNYXRoVXRpbHMuTXVsdGlwbHkocmVmIFJBLCBMb2NhbEFuY2hvckEgLSBMb2NhbENlbnRlckEpO1xyXG4gICAgICAgICAgICBWZWN0b3IyIHJCID0gTWF0aFV0aWxzLk11bHRpcGx5KHJlZiBSQiwgTG9jYWxBbmNob3JCIC0gTG9jYWxDZW50ZXJCKTtcclxuICAgICAgICAgICAgVmVjdG9yMiBkID0geEIgKyByQiAtIHhBIC0gckE7XHJcblxyXG4gICAgICAgICAgICBWZWN0b3IyIGF5ID0gTWF0aFV0aWxzLk11bHRpcGx5KHJlZiBSQSwgX2xvY2FsWUF4aXNBKTtcclxuXHJcbiAgICAgICAgICAgIGZsb2F0IHNCeSA9IE1hdGhVdGlscy5Dcm9zcyhyQiwgYXkpO1xyXG5cclxuICAgICAgICAgICAgZmxvYXQgQyA9IFZlY3RvcjIuRG90KGQsIGF5KTtcclxuXHJcbiAgICAgICAgICAgIGZsb2F0IGsgPSBJbnZNYXNzQSArIEludk1hc3NCICsgSW52SUEgKiBfc0F5ICogX3NBeSArIEludklCICogX3NCeSAqIF9zQnk7XHJcblxyXG4gICAgICAgICAgICBmbG9hdCBpbXB1bHNlO1xyXG4gICAgICAgICAgICBpZiAoayAhPSAwLjBmKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBpbXB1bHNlID0gLUMgLyBrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgaW1wdWxzZSA9IDAuMGY7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIFZlY3RvcjIgUCA9IGltcHVsc2UgKiBheTtcclxuICAgICAgICAgICAgZmxvYXQgTEIgPSBpbXB1bHNlICogc0J5O1xyXG5cclxuICAgICAgICAgICAgeEIgKz0gSW52TWFzc0IgKiBQO1xyXG4gICAgICAgICAgICBhbmdsZUIgKz0gSW52SUIgKiBMQjtcclxuXHJcbiAgICAgICAgICAgIC8vIFRPRE9fRVJJTiByZW1vdmUgbmVlZCBmb3IgdGhpcy5cclxuICAgICAgICAgICAgYkIuU3dlZXAuQyA9IHhCO1xyXG4gICAgICAgICAgICBiQi5Td2VlcC5BID0gYW5nbGVCO1xyXG4gICAgICAgICAgICBiQi5TeW5jaHJvbml6ZVRyYW5zZm9ybSgpO1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIE1hdGguQWJzKEMpIDw9IFNldHRpbmdzLkxpbmVhclNsb3A7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwdWJsaWMgZmxvYXQgR2V0TW90b3JUb3JxdWUoZmxvYXQgaW52RHQpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gaW52RHQgKiBfbW90b3JJbXB1bHNlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufSIsIi8qXHJcbiogRmFyc2VlciBQaHlzaWNzIEVuZ2luZSBiYXNlZCBvbiBCb3gyRC5YTkEgcG9ydDpcclxuKiBDb3B5cmlnaHQgKGMpIDIwMTAgSWFuIFF2aXN0XHJcbiogXHJcbiogQm94MkQuWE5BIHBvcnQgb2YgQm94MkQ6XHJcbiogQ29weXJpZ2h0IChjKSAyMDA5IEJyYW5kb24gRnVydHdhbmdsZXIsIE5hdGhhbiBGdXJ0d2FuZ2xlclxyXG4qXHJcbiogT3JpZ2luYWwgc291cmNlIEJveDJEOlxyXG4qIENvcHlyaWdodCAoYykgMjAwNi0yMDA5IEVyaW4gQ2F0dG8gaHR0cDovL3d3dy5ncGh5c2ljcy5jb20gXHJcbiogXHJcbiogVGhpcyBzb2Z0d2FyZSBpcyBwcm92aWRlZCAnYXMtaXMnLCB3aXRob3V0IGFueSBleHByZXNzIG9yIGltcGxpZWQgXHJcbiogd2FycmFudHkuICBJbiBubyBldmVudCB3aWxsIHRoZSBhdXRob3JzIGJlIGhlbGQgbGlhYmxlIGZvciBhbnkgZGFtYWdlcyBcclxuKiBhcmlzaW5nIGZyb20gdGhlIHVzZSBvZiB0aGlzIHNvZnR3YXJlLiBcclxuKiBQZXJtaXNzaW9uIGlzIGdyYW50ZWQgdG8gYW55b25lIHRvIHVzZSB0aGlzIHNvZnR3YXJlIGZvciBhbnkgcHVycG9zZSwgXHJcbiogaW5jbHVkaW5nIGNvbW1lcmNpYWwgYXBwbGljYXRpb25zLCBhbmQgdG8gYWx0ZXIgaXQgYW5kIHJlZGlzdHJpYnV0ZSBpdCBcclxuKiBmcmVlbHksIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyByZXN0cmljdGlvbnM6IFxyXG4qIDEuIFRoZSBvcmlnaW4gb2YgdGhpcyBzb2Z0d2FyZSBtdXN0IG5vdCBiZSBtaXNyZXByZXNlbnRlZDsgeW91IG11c3Qgbm90IFxyXG4qIGNsYWltIHRoYXQgeW91IHdyb3RlIHRoZSBvcmlnaW5hbCBzb2Z0d2FyZS4gSWYgeW91IHVzZSB0aGlzIHNvZnR3YXJlIFxyXG4qIGluIGEgcHJvZHVjdCwgYW4gYWNrbm93bGVkZ21lbnQgaW4gdGhlIHByb2R1Y3QgZG9jdW1lbnRhdGlvbiB3b3VsZCBiZSBcclxuKiBhcHByZWNpYXRlZCBidXQgaXMgbm90IHJlcXVpcmVkLiBcclxuKiAyLiBBbHRlcmVkIHNvdXJjZSB2ZXJzaW9ucyBtdXN0IGJlIHBsYWlubHkgbWFya2VkIGFzIHN1Y2gsIGFuZCBtdXN0IG5vdCBiZSBcclxuKiBtaXNyZXByZXNlbnRlZCBhcyBiZWluZyB0aGUgb3JpZ2luYWwgc29mdHdhcmUuIFxyXG4qIDMuIFRoaXMgbm90aWNlIG1heSBub3QgYmUgcmVtb3ZlZCBvciBhbHRlcmVkIGZyb20gYW55IHNvdXJjZSBkaXN0cmlidXRpb24uIFxyXG4qL1xyXG5cclxudXNpbmcgU3lzdGVtLkRpYWdub3N0aWNzO1xyXG51c2luZyBGYXJzZWVyUGh5c2ljcy5Db21tb247XHJcbnVzaW5nIE1pY3Jvc29mdC5YbmEuRnJhbWV3b3JrO1xyXG5cclxubmFtZXNwYWNlIEZhcnNlZXJQaHlzaWNzLkR5bmFtaWNzLkpvaW50c1xyXG57XHJcbiAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAvLy8gQSBtb3VzZSBqb2ludCBpcyB1c2VkIHRvIG1ha2UgYSBwb2ludCBvbiBhIGJvZHkgdHJhY2sgYVxyXG4gICAgLy8vIHNwZWNpZmllZCB3b3JsZCBwb2ludC4gVGhpcyBhIHNvZnQgY29uc3RyYWludCB3aXRoIGEgbWF4aW11bVxyXG4gICAgLy8vIGZvcmNlLiBUaGlzIGFsbG93cyB0aGUgY29uc3RyYWludCB0byBzdHJldGNoIGFuZCB3aXRob3V0XHJcbiAgICAvLy8gYXBwbHlpbmcgaHVnZSBmb3JjZXMuXHJcbiAgICAvLy8gTk9URTogdGhpcyBqb2ludCBpcyBub3QgZG9jdW1lbnRlZCBpbiB0aGUgbWFudWFsIGJlY2F1c2UgaXQgd2FzXHJcbiAgICAvLy8gZGV2ZWxvcGVkIHRvIGJlIHVzZWQgaW4gdGhlIHRlc3RiZWQuIElmIHlvdSB3YW50IHRvIGxlYXJuIGhvdyB0b1xyXG4gICAgLy8vIHVzZSB0aGUgbW91c2Ugam9pbnQsIGxvb2sgYXQgdGhlIHRlc3RiZWQuXHJcbiAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgcHVibGljIGNsYXNzIEZpeGVkTW91c2VKb2ludCA6IEpvaW50XHJcbiAgICB7XHJcbiAgICAgICAgcHVibGljIFZlY3RvcjIgTG9jYWxBbmNob3JBO1xyXG4gICAgICAgIHByaXZhdGUgVmVjdG9yMiBfQzsgLy8gcG9zaXRpb24gZXJyb3JcclxuICAgICAgICBwcml2YXRlIGZsb2F0IF9iZXRhO1xyXG4gICAgICAgIHByaXZhdGUgZmxvYXQgX2dhbW1hO1xyXG4gICAgICAgIHByaXZhdGUgVmVjdG9yMiBfaW1wdWxzZTtcclxuICAgICAgICBwcml2YXRlIE1hdDIyIF9tYXNzOyAvLyBlZmZlY3RpdmUgbWFzcyBmb3IgcG9pbnQtdG8tcG9pbnQgY29uc3RyYWludC5cclxuXHJcbiAgICAgICAgcHJpdmF0ZSBWZWN0b3IyIF93b3JsZEFuY2hvcjtcclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBUaGlzIHJlcXVpcmVzIGEgd29ybGQgdGFyZ2V0IHBvaW50LFxyXG4gICAgICAgIC8vLyB0dW5pbmcgcGFyYW1ldGVycywgYW5kIHRoZSB0aW1lIHN0ZXAuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJib2R5XCI+VGhlIGJvZHkuPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJ3b3JsZEFuY2hvclwiPlRoZSB0YXJnZXQuPC9wYXJhbT5cclxuICAgICAgICBwdWJsaWMgRml4ZWRNb3VzZUpvaW50KEJvZHkgYm9keSwgVmVjdG9yMiB3b3JsZEFuY2hvcilcclxuICAgICAgICAgICAgOiBiYXNlKGJvZHkpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBKb2ludFR5cGUgPSBKb2ludFR5cGUuRml4ZWRNb3VzZTtcclxuICAgICAgICAgICAgRnJlcXVlbmN5ID0gNS4wZjtcclxuICAgICAgICAgICAgRGFtcGluZ1JhdGlvID0gMC43ZjtcclxuXHJcbiAgICAgICAgICAgIERlYnVnLkFzc2VydCh3b3JsZEFuY2hvci5Jc1ZhbGlkKCkpO1xyXG5cclxuICAgICAgICAgICAgVHJhbnNmb3JtIHhmMTtcclxuICAgICAgICAgICAgQm9keUEuR2V0VHJhbnNmb3JtKG91dCB4ZjEpO1xyXG5cclxuICAgICAgICAgICAgX3dvcmxkQW5jaG9yID0gd29ybGRBbmNob3I7XHJcbiAgICAgICAgICAgIExvY2FsQW5jaG9yQSA9IEJvZHlBLkdldExvY2FsUG9pbnQod29ybGRBbmNob3IpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHVibGljIG92ZXJyaWRlIFZlY3RvcjIgV29ybGRBbmNob3JBXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBnZXQgeyByZXR1cm4gQm9keUEuR2V0V29ybGRQb2ludChMb2NhbEFuY2hvckEpOyB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwdWJsaWMgb3ZlcnJpZGUgVmVjdG9yMiBXb3JsZEFuY2hvckJcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGdldCB7IHJldHVybiBfd29ybGRBbmNob3I7IH1cclxuICAgICAgICAgICAgc2V0XHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIEJvZHlBLkF3YWtlID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIF93b3JsZEFuY2hvciA9IHZhbHVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIFRoZSBtYXhpbXVtIGNvbnN0cmFpbnQgZm9yY2UgdGhhdCBjYW4gYmUgZXhlcnRlZFxyXG4gICAgICAgIC8vLyB0byBtb3ZlIHRoZSBjYW5kaWRhdGUgYm9keS4gVXN1YWxseSB5b3Ugd2lsbCBleHByZXNzXHJcbiAgICAgICAgLy8vIGFzIHNvbWUgbXVsdGlwbGUgb2YgdGhlIHdlaWdodCAobXVsdGlwbGllciAqIG1hc3MgKiBncmF2aXR5KS5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIHB1YmxpYyBmbG9hdCBNYXhGb3JjZSB7IGdldDsgc2V0OyB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gVGhlIHJlc3BvbnNlIHNwZWVkLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgcHVibGljIGZsb2F0IEZyZXF1ZW5jeSB7IGdldDsgc2V0OyB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gVGhlIGRhbXBpbmcgcmF0aW8uIDAgPSBubyBkYW1waW5nLCAxID0gY3JpdGljYWwgZGFtcGluZy5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIHB1YmxpYyBmbG9hdCBEYW1waW5nUmF0aW8geyBnZXQ7IHNldDsgfVxyXG5cclxuICAgICAgICBwdWJsaWMgb3ZlcnJpZGUgVmVjdG9yMiBHZXRSZWFjdGlvbkZvcmNlKGZsb2F0IGludl9kdClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiBpbnZfZHQgKiBfaW1wdWxzZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHB1YmxpYyBvdmVycmlkZSBmbG9hdCBHZXRSZWFjdGlvblRvcnF1ZShmbG9hdCBpbnZfZHQpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gaW52X2R0ICogMC4wZjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGludGVybmFsIG92ZXJyaWRlIHZvaWQgSW5pdFZlbG9jaXR5Q29uc3RyYWludHMocmVmIFRpbWVTdGVwIHN0ZXApXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBCb2R5IGIgPSBCb2R5QTtcclxuXHJcbiAgICAgICAgICAgIGZsb2F0IG1hc3MgPSBiLk1hc3M7XHJcblxyXG4gICAgICAgICAgICAvLyBGcmVxdWVuY3lcclxuICAgICAgICAgICAgZmxvYXQgb21lZ2EgPSAyLjBmICogU2V0dGluZ3MuUGkgKiBGcmVxdWVuY3k7XHJcblxyXG4gICAgICAgICAgICAvLyBEYW1waW5nIGNvZWZmaWNpZW50XHJcbiAgICAgICAgICAgIGZsb2F0IGQgPSAyLjBmICogbWFzcyAqIERhbXBpbmdSYXRpbyAqIG9tZWdhO1xyXG5cclxuICAgICAgICAgICAgLy8gU3ByaW5nIHN0aWZmbmVzc1xyXG4gICAgICAgICAgICBmbG9hdCBrID0gbWFzcyAqIChvbWVnYSAqIG9tZWdhKTtcclxuXHJcbiAgICAgICAgICAgIC8vIG1hZ2ljIGZvcm11bGFzXHJcbiAgICAgICAgICAgIC8vIGdhbW1hIGhhcyB1bml0cyBvZiBpbnZlcnNlIG1hc3MuXHJcbiAgICAgICAgICAgIC8vIGJldGEgaGFzIHVuaXRzIG9mIGludmVyc2UgdGltZS5cclxuICAgICAgICAgICAgRGVidWcuQXNzZXJ0KGQgKyBzdGVwLmR0ICogayA+IFNldHRpbmdzLkVwc2lsb24pO1xyXG5cclxuICAgICAgICAgICAgX2dhbW1hID0gc3RlcC5kdCAqIChkICsgc3RlcC5kdCAqIGspO1xyXG4gICAgICAgICAgICBpZiAoX2dhbW1hICE9IDAuMGYpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIF9nYW1tYSA9IDEuMGYgLyBfZ2FtbWE7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIF9iZXRhID0gc3RlcC5kdCAqIGsgKiBfZ2FtbWE7XHJcblxyXG4gICAgICAgICAgICAvLyBDb21wdXRlIHRoZSBlZmZlY3RpdmUgbWFzcyBtYXRyaXguXHJcbiAgICAgICAgICAgIFRyYW5zZm9ybSB4ZjE7XHJcbiAgICAgICAgICAgIGIuR2V0VHJhbnNmb3JtKG91dCB4ZjEpO1xyXG4gICAgICAgICAgICBWZWN0b3IyIHIgPSBNYXRoVXRpbHMuTXVsdGlwbHkocmVmIHhmMS5SLCBMb2NhbEFuY2hvckEgLSBiLkxvY2FsQ2VudGVyKTtcclxuXHJcbiAgICAgICAgICAgIC8vIEsgICAgPSBbKDEvbTEgKyAxL20yKSAqIGV5ZSgyKSAtIHNrZXcocjEpICogaW52STEgKiBza2V3KHIxKSAtIHNrZXcocjIpICogaW52STIgKiBza2V3KHIyKV1cclxuICAgICAgICAgICAgLy8gICAgICA9IFsxL20xKzEvbTIgICAgIDAgICAgXSArIGludkkxICogW3IxLlkqcjEuWSAtcjEuWCpyMS5ZXSArIGludkkyICogW3IxLlkqcjEuWSAtcjEuWCpyMS5ZXVxyXG4gICAgICAgICAgICAvLyAgICAgICAgWyAgICAwICAgICAxL20xKzEvbTJdICAgICAgICAgICBbLXIxLlgqcjEuWSByMS5YKnIxLlhdICAgICAgICAgICBbLXIxLlgqcjEuWSByMS5YKnIxLlhdXHJcbiAgICAgICAgICAgIGZsb2F0IGludk1hc3MgPSBiLkludk1hc3M7XHJcbiAgICAgICAgICAgIGZsb2F0IGludkkgPSBiLkludkk7XHJcblxyXG4gICAgICAgICAgICBNYXQyMiBLMSA9IG5ldyBNYXQyMihuZXcgVmVjdG9yMihpbnZNYXNzLCAwLjBmKSwgbmV3IFZlY3RvcjIoMC4wZiwgaW52TWFzcykpO1xyXG4gICAgICAgICAgICBNYXQyMiBLMiA9IG5ldyBNYXQyMihuZXcgVmVjdG9yMihpbnZJICogci5ZICogci5ZLCAtaW52SSAqIHIuWCAqIHIuWSksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ldyBWZWN0b3IyKC1pbnZJICogci5YICogci5ZLCBpbnZJICogci5YICogci5YKSk7XHJcblxyXG4gICAgICAgICAgICBNYXQyMiBLO1xyXG4gICAgICAgICAgICBNYXQyMi5BZGQocmVmIEsxLCByZWYgSzIsIG91dCBLKTtcclxuXHJcbiAgICAgICAgICAgIEsuQ29sMS5YICs9IF9nYW1tYTtcclxuICAgICAgICAgICAgSy5Db2wyLlkgKz0gX2dhbW1hO1xyXG5cclxuICAgICAgICAgICAgX21hc3MgPSBLLkludmVyc2U7XHJcblxyXG4gICAgICAgICAgICBfQyA9IGIuU3dlZXAuQyArIHIgLSBfd29ybGRBbmNob3I7XHJcblxyXG4gICAgICAgICAgICAvLyBDaGVhdCB3aXRoIHNvbWUgZGFtcGluZ1xyXG4gICAgICAgICAgICBiLkFuZ3VsYXJWZWxvY2l0eUludGVybmFsICo9IDAuOThmO1xyXG5cclxuICAgICAgICAgICAgLy8gV2FybSBzdGFydGluZy5cclxuICAgICAgICAgICAgX2ltcHVsc2UgKj0gc3RlcC5kdFJhdGlvO1xyXG4gICAgICAgICAgICBiLkxpbmVhclZlbG9jaXR5SW50ZXJuYWwgKz0gaW52TWFzcyAqIF9pbXB1bHNlO1xyXG4gICAgICAgICAgICBiLkFuZ3VsYXJWZWxvY2l0eUludGVybmFsICs9IGludkkgKiBNYXRoVXRpbHMuQ3Jvc3MociwgX2ltcHVsc2UpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaW50ZXJuYWwgb3ZlcnJpZGUgdm9pZCBTb2x2ZVZlbG9jaXR5Q29uc3RyYWludHMocmVmIFRpbWVTdGVwIHN0ZXApXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBCb2R5IGIgPSBCb2R5QTtcclxuXHJcbiAgICAgICAgICAgIFRyYW5zZm9ybSB4ZjE7XHJcbiAgICAgICAgICAgIGIuR2V0VHJhbnNmb3JtKG91dCB4ZjEpO1xyXG5cclxuICAgICAgICAgICAgVmVjdG9yMiByID0gTWF0aFV0aWxzLk11bHRpcGx5KHJlZiB4ZjEuUiwgTG9jYWxBbmNob3JBIC0gYi5Mb2NhbENlbnRlcik7XHJcblxyXG4gICAgICAgICAgICAvLyBDZG90ID0gdiArIGNyb3NzKHcsIHIpXHJcbiAgICAgICAgICAgIFZlY3RvcjIgQ2RvdCA9IGIuTGluZWFyVmVsb2NpdHlJbnRlcm5hbCArIE1hdGhVdGlscy5Dcm9zcyhiLkFuZ3VsYXJWZWxvY2l0eUludGVybmFsLCByKTtcclxuICAgICAgICAgICAgVmVjdG9yMiBpbXB1bHNlID0gTWF0aFV0aWxzLk11bHRpcGx5KHJlZiBfbWFzcywgLShDZG90ICsgX2JldGEgKiBfQyArIF9nYW1tYSAqIF9pbXB1bHNlKSk7XHJcblxyXG4gICAgICAgICAgICBWZWN0b3IyIG9sZEltcHVsc2UgPSBfaW1wdWxzZTtcclxuICAgICAgICAgICAgX2ltcHVsc2UgKz0gaW1wdWxzZTtcclxuICAgICAgICAgICAgZmxvYXQgbWF4SW1wdWxzZSA9IHN0ZXAuZHQgKiBNYXhGb3JjZTtcclxuICAgICAgICAgICAgaWYgKF9pbXB1bHNlLkxlbmd0aFNxdWFyZWQoKSA+IG1heEltcHVsc2UgKiBtYXhJbXB1bHNlKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBfaW1wdWxzZSAqPSBtYXhJbXB1bHNlIC8gX2ltcHVsc2UuTGVuZ3RoKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaW1wdWxzZSA9IF9pbXB1bHNlIC0gb2xkSW1wdWxzZTtcclxuXHJcbiAgICAgICAgICAgIGIuTGluZWFyVmVsb2NpdHlJbnRlcm5hbCArPSBiLkludk1hc3MgKiBpbXB1bHNlO1xyXG4gICAgICAgICAgICBiLkFuZ3VsYXJWZWxvY2l0eUludGVybmFsICs9IGIuSW52SSAqIE1hdGhVdGlscy5Dcm9zcyhyLCBpbXB1bHNlKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGludGVybmFsIG92ZXJyaWRlIGJvb2wgU29sdmVQb3NpdGlvbkNvbnN0cmFpbnRzKClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufSIsIi8qXHJcbiogRmFyc2VlciBQaHlzaWNzIEVuZ2luZSBiYXNlZCBvbiBCb3gyRC5YTkEgcG9ydDpcclxuKiBDb3B5cmlnaHQgKGMpIDIwMTAgSWFuIFF2aXN0XHJcbiogXHJcbiogQm94MkQuWE5BIHBvcnQgb2YgQm94MkQ6XHJcbiogQ29weXJpZ2h0IChjKSAyMDA5IEJyYW5kb24gRnVydHdhbmdsZXIsIE5hdGhhbiBGdXJ0d2FuZ2xlclxyXG4qXHJcbiogT3JpZ2luYWwgc291cmNlIEJveDJEOlxyXG4qIENvcHlyaWdodCAoYykgMjAwNi0yMDA5IEVyaW4gQ2F0dG8gaHR0cDovL3d3dy5ncGh5c2ljcy5jb20gXHJcbiogXHJcbiogVGhpcyBzb2Z0d2FyZSBpcyBwcm92aWRlZCAnYXMtaXMnLCB3aXRob3V0IGFueSBleHByZXNzIG9yIGltcGxpZWQgXHJcbiogd2FycmFudHkuICBJbiBubyBldmVudCB3aWxsIHRoZSBhdXRob3JzIGJlIGhlbGQgbGlhYmxlIGZvciBhbnkgZGFtYWdlcyBcclxuKiBhcmlzaW5nIGZyb20gdGhlIHVzZSBvZiB0aGlzIHNvZnR3YXJlLiBcclxuKiBQZXJtaXNzaW9uIGlzIGdyYW50ZWQgdG8gYW55b25lIHRvIHVzZSB0aGlzIHNvZnR3YXJlIGZvciBhbnkgcHVycG9zZSwgXHJcbiogaW5jbHVkaW5nIGNvbW1lcmNpYWwgYXBwbGljYXRpb25zLCBhbmQgdG8gYWx0ZXIgaXQgYW5kIHJlZGlzdHJpYnV0ZSBpdCBcclxuKiBmcmVlbHksIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyByZXN0cmljdGlvbnM6IFxyXG4qIDEuIFRoZSBvcmlnaW4gb2YgdGhpcyBzb2Z0d2FyZSBtdXN0IG5vdCBiZSBtaXNyZXByZXNlbnRlZDsgeW91IG11c3Qgbm90IFxyXG4qIGNsYWltIHRoYXQgeW91IHdyb3RlIHRoZSBvcmlnaW5hbCBzb2Z0d2FyZS4gSWYgeW91IHVzZSB0aGlzIHNvZnR3YXJlIFxyXG4qIGluIGEgcHJvZHVjdCwgYW4gYWNrbm93bGVkZ21lbnQgaW4gdGhlIHByb2R1Y3QgZG9jdW1lbnRhdGlvbiB3b3VsZCBiZSBcclxuKiBhcHByZWNpYXRlZCBidXQgaXMgbm90IHJlcXVpcmVkLiBcclxuKiAyLiBBbHRlcmVkIHNvdXJjZSB2ZXJzaW9ucyBtdXN0IGJlIHBsYWlubHkgbWFya2VkIGFzIHN1Y2gsIGFuZCBtdXN0IG5vdCBiZSBcclxuKiBtaXNyZXByZXNlbnRlZCBhcyBiZWluZyB0aGUgb3JpZ2luYWwgc29mdHdhcmUuIFxyXG4qIDMuIFRoaXMgbm90aWNlIG1heSBub3QgYmUgcmVtb3ZlZCBvciBhbHRlcmVkIGZyb20gYW55IHNvdXJjZSBkaXN0cmlidXRpb24uIFxyXG4qL1xyXG5cclxudXNpbmcgU3lzdGVtO1xyXG51c2luZyBTeXN0ZW0uRGlhZ25vc3RpY3M7XHJcbnVzaW5nIEZhcnNlZXJQaHlzaWNzLkNvbW1vbjtcclxudXNpbmcgTWljcm9zb2Z0LlhuYS5GcmFtZXdvcms7XHJcblxyXG5uYW1lc3BhY2UgRmFyc2VlclBoeXNpY3MuRHluYW1pY3MuSm9pbnRzXHJcbntcclxuICAgIC8vIExpbmVhciBjb25zdHJhaW50IChwb2ludC10by1saW5lKVxyXG4gICAgLy8gZCA9IHAyIC0gcDEgPSB4MiArIHIyIC0geDEgLSByMVxyXG4gICAgLy8gQyA9IGRvdChwZXJwLCBkKVxyXG4gICAgLy8gQ2RvdCA9IGRvdChkLCBjcm9zcyh3MSwgcGVycCkpICsgZG90KHBlcnAsIHYyICsgY3Jvc3ModzIsIHIyKSAtIHYxIC0gY3Jvc3ModzEsIHIxKSlcclxuICAgIC8vICAgICAgPSAtZG90KHBlcnAsIHYxKSAtIGRvdChjcm9zcyhkICsgcjEsIHBlcnApLCB3MSkgKyBkb3QocGVycCwgdjIpICsgZG90KGNyb3NzKHIyLCBwZXJwKSwgdjIpXHJcbiAgICAvLyBKID0gWy1wZXJwLCAtY3Jvc3MoZCArIHIxLCBwZXJwKSwgcGVycCwgY3Jvc3MocjIscGVycCldXHJcbiAgICAvL1xyXG4gICAgLy8gQW5ndWxhciBjb25zdHJhaW50XHJcbiAgICAvLyBDID0gYTIgLSBhMSArIGFfaW5pdGlhbFxyXG4gICAgLy8gQ2RvdCA9IHcyIC0gdzFcclxuICAgIC8vIEogPSBbMCAwIC0xIDAgMCAxXVxyXG4gICAgLy9cclxuICAgIC8vIEsgPSBKICogaW52TSAqIEpUXHJcbiAgICAvL1xyXG4gICAgLy8gSiA9IFstYSAtczEgYSBzMl1cclxuICAgIC8vICAgICBbMCAgLTEgIDAgIDFdXHJcbiAgICAvLyBhID0gcGVycFxyXG4gICAgLy8gczEgPSBjcm9zcyhkICsgcjEsIGEpID0gY3Jvc3MocDIgLSB4MSwgYSlcclxuICAgIC8vIHMyID0gY3Jvc3MocjIsIGEpID0gY3Jvc3MocDIgLSB4MiwgYSlcclxuICAgIC8vIE1vdG9yL0xpbWl0IGxpbmVhciBjb25zdHJhaW50XHJcbiAgICAvLyBDID0gZG90KGF4MSwgZClcclxuICAgIC8vIENkb3QgPSA9IC1kb3QoYXgxLCB2MSkgLSBkb3QoY3Jvc3MoZCArIHIxLCBheDEpLCB3MSkgKyBkb3QoYXgxLCB2MikgKyBkb3QoY3Jvc3MocjIsIGF4MSksIHYyKVxyXG4gICAgLy8gSiA9IFstYXgxIC1jcm9zcyhkK3IxLGF4MSkgYXgxIGNyb3NzKHIyLGF4MSldXHJcbiAgICAvLyBCbG9jayBTb2x2ZXJcclxuICAgIC8vIFdlIGRldmVsb3AgYSBibG9jayBzb2x2ZXIgdGhhdCBpbmNsdWRlcyB0aGUgam9pbnQgbGltaXQuIFRoaXMgbWFrZXMgdGhlIGxpbWl0IHN0aWZmIChpbmVsYXN0aWMpIGV2ZW5cclxuICAgIC8vIHdoZW4gdGhlIG1hc3MgaGFzIHBvb3IgZGlzdHJpYnV0aW9uIChsZWFkaW5nIHRvIGxhcmdlIHRvcnF1ZXMgYWJvdXQgdGhlIGpvaW50IGFuY2hvciBwb2ludHMpLlxyXG4gICAgLy9cclxuICAgIC8vIFRoZSBKYWNvYmlhbiBoYXMgMyByb3dzOlxyXG4gICAgLy8gSiA9IFstdVQgLXMxIHVUIHMyXSAvLyBsaW5lYXJcclxuICAgIC8vICAgICBbMCAgIC0xICAgMCAgMV0gLy8gYW5ndWxhclxyXG4gICAgLy8gICAgIFstdlQgLWExIHZUIGEyXSAvLyBsaW1pdFxyXG4gICAgLy9cclxuICAgIC8vIHUgPSBwZXJwXHJcbiAgICAvLyB2ID0gYXhpc1xyXG4gICAgLy8gczEgPSBjcm9zcyhkICsgcjEsIHUpLCBzMiA9IGNyb3NzKHIyLCB1KVxyXG4gICAgLy8gYTEgPSBjcm9zcyhkICsgcjEsIHYpLCBhMiA9IGNyb3NzKHIyLCB2KVxyXG4gICAgLy8gTSAqICh2MiAtIHYxKSA9IEpUICogZGZcclxuICAgIC8vIEogKiB2MiA9IGJpYXNcclxuICAgIC8vXHJcbiAgICAvLyB2MiA9IHYxICsgaW52TSAqIEpUICogZGZcclxuICAgIC8vIEogKiAodjEgKyBpbnZNICogSlQgKiBkZikgPSBiaWFzXHJcbiAgICAvLyBLICogZGYgPSBiaWFzIC0gSiAqIHYxID0gLUNkb3RcclxuICAgIC8vIEsgPSBKICogaW52TSAqIEpUXHJcbiAgICAvLyBDZG90ID0gSiAqIHYxIC0gYmlhc1xyXG4gICAgLy9cclxuICAgIC8vIE5vdyBzb2x2ZSBmb3IgZjIuXHJcbiAgICAvLyBkZiA9IGYyIC0gZjFcclxuICAgIC8vIEsgKiAoZjIgLSBmMSkgPSAtQ2RvdFxyXG4gICAgLy8gZjIgPSBpbnZLICogKC1DZG90KSArIGYxXHJcbiAgICAvL1xyXG4gICAgLy8gQ2xhbXAgYWNjdW11bGF0ZWQgbGltaXQgaW1wdWxzZS5cclxuICAgIC8vIGxvd2VyOiBmMigzKSA9IG1heChmMigzKSwgMClcclxuICAgIC8vIHVwcGVyOiBmMigzKSA9IG1pbihmMigzKSwgMClcclxuICAgIC8vXHJcbiAgICAvLyBTb2x2ZSBmb3IgY29ycmVjdCBmMigxOjIpXHJcbiAgICAvLyBLKDE6MiwgMToyKSAqIGYyKDE6MikgPSAtQ2RvdCgxOjIpIC0gSygxOjIsMykgKiBmMigzKSArIEsoMToyLDE6MykgKiBmMVxyXG4gICAgLy8gICAgICAgICAgICAgICAgICAgICAgID0gLUNkb3QoMToyKSAtIEsoMToyLDMpICogZjIoMykgKyBLKDE6MiwxOjIpICogZjEoMToyKSArIEsoMToyLDMpICogZjEoMylcclxuICAgIC8vIEsoMToyLCAxOjIpICogZjIoMToyKSA9IC1DZG90KDE6MikgLSBLKDE6MiwzKSAqIChmMigzKSAtIGYxKDMpKSArIEsoMToyLDE6MikgKiBmMSgxOjIpXHJcbiAgICAvLyBmMigxOjIpID0gaW52SygxOjIsMToyKSAqICgtQ2RvdCgxOjIpIC0gSygxOjIsMykgKiAoZjIoMykgLSBmMSgzKSkpICsgZjEoMToyKVxyXG4gICAgLy9cclxuICAgIC8vIE5vdyBjb21wdXRlIGltcHVsc2UgdG8gYmUgYXBwbGllZDpcclxuICAgIC8vIGRmID0gZjIgLSBmMVxyXG5cclxuICAgIC8vLyA8c3VtbWFyeT5cclxuICAgIC8vLyBBIHByaXNtYXRpYyBqb2ludC4gVGhpcyBqb2ludCBwcm92aWRlcyBvbmUgZGVncmVlIG9mIGZyZWVkb206IHRyYW5zbGF0aW9uXHJcbiAgICAvLy8gYWxvbmcgYW4gYXhpcyBmaXhlZCBpbiBib2R5MS4gUmVsYXRpdmUgcm90YXRpb24gaXMgcHJldmVudGVkLiBZb3UgY2FuXHJcbiAgICAvLy8gdXNlIGEgam9pbnQgbGltaXQgdG8gcmVzdHJpY3QgdGhlIHJhbmdlIG9mIG1vdGlvbiBhbmQgYSBqb2ludCBtb3RvciB0b1xyXG4gICAgLy8vIGRyaXZlIHRoZSBtb3Rpb24gb3IgdG8gbW9kZWwgam9pbnQgZnJpY3Rpb24uXHJcbiAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgcHVibGljIGNsYXNzIEZpeGVkUHJpc21hdGljSm9pbnQgOiBKb2ludFxyXG4gICAge1xyXG4gICAgICAgIHByaXZhdGUgTWF0MzMgX0s7XHJcbiAgICAgICAgcHJpdmF0ZSBmbG9hdCBfYTEsIF9hMjtcclxuICAgICAgICBwcml2YXRlIFZlY3RvcjIgX2F4aXM7XHJcbiAgICAgICAgcHJpdmF0ZSBib29sIF9lbmFibGVMaW1pdDtcclxuICAgICAgICBwcml2YXRlIGJvb2wgX2VuYWJsZU1vdG9yO1xyXG4gICAgICAgIHByaXZhdGUgVmVjdG9yMyBfaW1wdWxzZTtcclxuICAgICAgICBwcml2YXRlIExpbWl0U3RhdGUgX2xpbWl0U3RhdGU7XHJcbiAgICAgICAgcHJpdmF0ZSBWZWN0b3IyIF9sb2NhbFhBeGlzMTtcclxuICAgICAgICBwcml2YXRlIFZlY3RvcjIgX2xvY2FsWUF4aXMxO1xyXG4gICAgICAgIHByaXZhdGUgZmxvYXQgX2xvd2VyVHJhbnNsYXRpb247XHJcbiAgICAgICAgcHJpdmF0ZSBmbG9hdCBfbWF4TW90b3JGb3JjZTtcclxuICAgICAgICBwcml2YXRlIGZsb2F0IF9tb3Rvck1hc3M7IC8vIGVmZmVjdGl2ZSBtYXNzIGZvciBtb3Rvci9saW1pdCB0cmFuc2xhdGlvbmFsIGNvbnN0cmFpbnQuXHJcbiAgICAgICAgcHJpdmF0ZSBmbG9hdCBfbW90b3JTcGVlZDtcclxuICAgICAgICBwcml2YXRlIFZlY3RvcjIgX3BlcnA7XHJcbiAgICAgICAgcHJpdmF0ZSBmbG9hdCBfcmVmQW5nbGU7XHJcbiAgICAgICAgcHJpdmF0ZSBmbG9hdCBfczEsIF9zMjtcclxuICAgICAgICBwcml2YXRlIGZsb2F0IF91cHBlclRyYW5zbGF0aW9uO1xyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIFRoaXMgcmVxdWlyZXMgZGVmaW5pbmcgYSBsaW5lIG9mXHJcbiAgICAgICAgLy8vIG1vdGlvbiB1c2luZyBhbiBheGlzIGFuZCBhbiBhbmNob3IgcG9pbnQuIFRoZSBkZWZpbml0aW9uIHVzZXMgbG9jYWxcclxuICAgICAgICAvLy8gYW5jaG9yIHBvaW50cyBhbmQgYSBsb2NhbCBheGlzIHNvIHRoYXQgdGhlIGluaXRpYWwgY29uZmlndXJhdGlvblxyXG4gICAgICAgIC8vLyBjYW4gdmlvbGF0ZSB0aGUgY29uc3RyYWludCBzbGlnaHRseS4gVGhlIGpvaW50IHRyYW5zbGF0aW9uIGlzIHplcm9cclxuICAgICAgICAvLy8gd2hlbiB0aGUgbG9jYWwgYW5jaG9yIHBvaW50cyBjb2luY2lkZSBpbiB3b3JsZCBzcGFjZS4gVXNpbmcgbG9jYWxcclxuICAgICAgICAvLy8gYW5jaG9ycyBhbmQgYSBsb2NhbCBheGlzIGhlbHBzIHdoZW4gc2F2aW5nIGFuZCBsb2FkaW5nIGEgZ2FtZS5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cImJvZHlcIj5UaGUgYm9keS48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cIndvcmxkQW5jaG9yXCI+VGhlIGFuY2hvci48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cImF4aXNcIj5UaGUgYXhpcy48L3BhcmFtPlxyXG4gICAgICAgIHB1YmxpYyBGaXhlZFByaXNtYXRpY0pvaW50KEJvZHkgYm9keSwgVmVjdG9yMiB3b3JsZEFuY2hvciwgVmVjdG9yMiBheGlzKVxyXG4gICAgICAgICAgICA6IGJhc2UoYm9keSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIEpvaW50VHlwZSA9IEpvaW50VHlwZS5GaXhlZFByaXNtYXRpYztcclxuXHJcbiAgICAgICAgICAgIEJvZHlCID0gQm9keUE7XHJcblxyXG4gICAgICAgICAgICBMb2NhbEFuY2hvckEgPSB3b3JsZEFuY2hvcjtcclxuICAgICAgICAgICAgTG9jYWxBbmNob3JCID0gQm9keUIuR2V0TG9jYWxQb2ludCh3b3JsZEFuY2hvcik7XHJcblxyXG4gICAgICAgICAgICBfbG9jYWxYQXhpczEgPSBheGlzO1xyXG4gICAgICAgICAgICBfbG9jYWxZQXhpczEgPSBNYXRoVXRpbHMuQ3Jvc3MoMS4wZiwgX2xvY2FsWEF4aXMxKTtcclxuICAgICAgICAgICAgX3JlZkFuZ2xlID0gQm9keUIuUm90YXRpb247XHJcblxyXG4gICAgICAgICAgICBfbGltaXRTdGF0ZSA9IExpbWl0U3RhdGUuSW5hY3RpdmU7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwdWJsaWMgVmVjdG9yMiBMb2NhbEFuY2hvckEgeyBnZXQ7IHNldDsgfVxyXG5cclxuICAgICAgICBwdWJsaWMgVmVjdG9yMiBMb2NhbEFuY2hvckIgeyBnZXQ7IHNldDsgfVxyXG5cclxuICAgICAgICBwdWJsaWMgb3ZlcnJpZGUgVmVjdG9yMiBXb3JsZEFuY2hvckFcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGdldCB7IHJldHVybiBMb2NhbEFuY2hvckE7IH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHB1YmxpYyBvdmVycmlkZSBWZWN0b3IyIFdvcmxkQW5jaG9yQlxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgZ2V0IHsgcmV0dXJuIEJvZHlBLkdldFdvcmxkUG9pbnQoTG9jYWxBbmNob3JCKTsgfVxyXG4gICAgICAgICAgICBzZXQgeyBEZWJ1Zy5Bc3NlcnQoZmFsc2UsIFwiWW91IGNhbid0IHNldCB0aGUgd29ybGQgYW5jaG9yIG9uIHRoaXMgam9pbnQgdHlwZS5cIik7IH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gR2V0IHRoZSBjdXJyZW50IGpvaW50IHRyYW5zbGF0aW9uLCB1c3VhbGx5IGluIG1ldGVycy5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8dmFsdWU+PC92YWx1ZT5cclxuICAgICAgICBwdWJsaWMgZmxvYXQgSm9pbnRUcmFuc2xhdGlvblxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgZ2V0XHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIFZlY3RvcjIgZCA9IEJvZHlCLkdldFdvcmxkUG9pbnQoTG9jYWxBbmNob3JCKSAtIExvY2FsQW5jaG9yQTtcclxuICAgICAgICAgICAgICAgIFZlY3RvcjIgYXhpcyA9IF9sb2NhbFhBeGlzMTtcclxuXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gVmVjdG9yMi5Eb3QoZCwgYXhpcyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gR2V0IHRoZSBjdXJyZW50IGpvaW50IHRyYW5zbGF0aW9uIHNwZWVkLCB1c3VhbGx5IGluIG1ldGVycyBwZXIgc2Vjb25kLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDx2YWx1ZT48L3ZhbHVlPlxyXG4gICAgICAgIHB1YmxpYyBmbG9hdCBKb2ludFNwZWVkXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBnZXRcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgVHJhbnNmb3JtIHhmMjtcclxuICAgICAgICAgICAgICAgIEJvZHlCLkdldFRyYW5zZm9ybShvdXQgeGYyKTtcclxuXHJcbiAgICAgICAgICAgICAgICBWZWN0b3IyIHIxID0gTG9jYWxBbmNob3JBO1xyXG4gICAgICAgICAgICAgICAgVmVjdG9yMiByMiA9IE1hdGhVdGlscy5NdWx0aXBseShyZWYgeGYyLlIsIExvY2FsQW5jaG9yQiAtIEJvZHlCLkxvY2FsQ2VudGVyKTtcclxuICAgICAgICAgICAgICAgIFZlY3RvcjIgcDEgPSByMTtcclxuICAgICAgICAgICAgICAgIFZlY3RvcjIgcDIgPSBCb2R5Qi5Td2VlcC5DICsgcjI7XHJcbiAgICAgICAgICAgICAgICBWZWN0b3IyIGQgPSBwMiAtIHAxO1xyXG4gICAgICAgICAgICAgICAgVmVjdG9yMiBheGlzID0gX2xvY2FsWEF4aXMxO1xyXG5cclxuICAgICAgICAgICAgICAgIFZlY3RvcjIgdjEgPSBWZWN0b3IyLlplcm87XHJcbiAgICAgICAgICAgICAgICBWZWN0b3IyIHYyID0gQm9keUIuTGluZWFyVmVsb2NpdHlJbnRlcm5hbDtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGZsb2F0IHcxID0gMC4wZjtcclxuICAgICAgICAgICAgICAgIGZsb2F0IHcyID0gQm9keUIuQW5ndWxhclZlbG9jaXR5SW50ZXJuYWw7XHJcblxyXG4gICAgICAgICAgICAgICAgZmxvYXQgc3BlZWQgPSBWZWN0b3IyLkRvdChkLCBNYXRoVXRpbHMuQ3Jvc3ModzEsIGF4aXMpKSArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFZlY3RvcjIuRG90KGF4aXMsIHYyICsgTWF0aFV0aWxzLkNyb3NzKHcyLCByMikgLSB2MSAtIE1hdGhVdGlscy5Dcm9zcyh3MSwgcjEpKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBzcGVlZDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBJcyB0aGUgam9pbnQgbGltaXQgZW5hYmxlZD9cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8dmFsdWU+PGM+dHJ1ZTwvYz4gaWYgW2xpbWl0IGVuYWJsZWRdOyBvdGhlcndpc2UsIDxjPmZhbHNlPC9jPi48L3ZhbHVlPlxyXG4gICAgICAgIHB1YmxpYyBib29sIExpbWl0RW5hYmxlZFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgZ2V0IHsgcmV0dXJuIF9lbmFibGVMaW1pdDsgfVxyXG4gICAgICAgICAgICBzZXRcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgRGVidWcuQXNzZXJ0KEJvZHlBLkZpeGVkUm90YXRpb24gPT0gZmFsc2UsIFwiV2FybmluZzogbGltaXRzIGRvZXMgY3VycmVudGx5IG5vdCB3b3JrIHdpdGggZml4ZWQgcm90YXRpb25cIik7XHJcblxyXG4gICAgICAgICAgICAgICAgV2FrZUJvZGllcygpO1xyXG4gICAgICAgICAgICAgICAgX2VuYWJsZUxpbWl0ID0gdmFsdWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gR2V0IHRoZSBsb3dlciBqb2ludCBsaW1pdCwgdXN1YWxseSBpbiBtZXRlcnMuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHZhbHVlPjwvdmFsdWU+XHJcbiAgICAgICAgcHVibGljIGZsb2F0IExvd2VyTGltaXRcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGdldCB7IHJldHVybiBfbG93ZXJUcmFuc2xhdGlvbjsgfVxyXG4gICAgICAgICAgICBzZXRcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgV2FrZUJvZGllcygpO1xyXG4gICAgICAgICAgICAgICAgX2xvd2VyVHJhbnNsYXRpb24gPSB2YWx1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBHZXQgdGhlIHVwcGVyIGpvaW50IGxpbWl0LCB1c3VhbGx5IGluIG1ldGVycy5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8dmFsdWU+PC92YWx1ZT5cclxuICAgICAgICBwdWJsaWMgZmxvYXQgVXBwZXJMaW1pdFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgZ2V0IHsgcmV0dXJuIF91cHBlclRyYW5zbGF0aW9uOyB9XHJcbiAgICAgICAgICAgIHNldFxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBXYWtlQm9kaWVzKCk7XHJcbiAgICAgICAgICAgICAgICBfdXBwZXJUcmFuc2xhdGlvbiA9IHZhbHVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIElzIHRoZSBqb2ludCBtb3RvciBlbmFibGVkP1xyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDx2YWx1ZT48Yz50cnVlPC9jPiBpZiBbbW90b3IgZW5hYmxlZF07IG90aGVyd2lzZSwgPGM+ZmFsc2U8L2M+LjwvdmFsdWU+XHJcbiAgICAgICAgcHVibGljIGJvb2wgTW90b3JFbmFibGVkXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBnZXQgeyByZXR1cm4gX2VuYWJsZU1vdG9yOyB9XHJcbiAgICAgICAgICAgIHNldFxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBXYWtlQm9kaWVzKCk7XHJcbiAgICAgICAgICAgICAgICBfZW5hYmxlTW90b3IgPSB2YWx1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBTZXQgdGhlIG1vdG9yIHNwZWVkLCB1c3VhbGx5IGluIG1ldGVycyBwZXIgc2Vjb25kLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDx2YWx1ZT5UaGUgc3BlZWQuPC92YWx1ZT5cclxuICAgICAgICBwdWJsaWMgZmxvYXQgTW90b3JTcGVlZFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgc2V0XHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIFdha2VCb2RpZXMoKTtcclxuICAgICAgICAgICAgICAgIF9tb3RvclNwZWVkID0gdmFsdWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZ2V0IHsgcmV0dXJuIF9tb3RvclNwZWVkOyB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIFNldCB0aGUgbWF4aW11bSBtb3RvciBmb3JjZSwgdXN1YWxseSBpbiBOLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDx2YWx1ZT5UaGUgZm9yY2UuPC92YWx1ZT5cclxuICAgICAgICBwdWJsaWMgZmxvYXQgTWF4TW90b3JGb3JjZVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgc2V0XHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIFdha2VCb2RpZXMoKTtcclxuICAgICAgICAgICAgICAgIF9tYXhNb3RvckZvcmNlID0gdmFsdWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gR2V0IHRoZSBjdXJyZW50IG1vdG9yIGZvcmNlLCB1c3VhbGx5IGluIE4uXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHZhbHVlPjwvdmFsdWU+XHJcbiAgICAgICAgcHVibGljIGZsb2F0IE1vdG9yRm9yY2UgeyBnZXQ7IHNldDsgfVxyXG5cclxuICAgICAgICBwdWJsaWMgVmVjdG9yMiBMb2NhbFhBeGlzMVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgZ2V0IHsgcmV0dXJuIF9sb2NhbFhBeGlzMTsgfVxyXG4gICAgICAgICAgICBzZXRcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgX2xvY2FsWEF4aXMxID0gdmFsdWU7XHJcbiAgICAgICAgICAgICAgICBfbG9jYWxZQXhpczEgPSBNYXRoVXRpbHMuQ3Jvc3MoMS4wZiwgX2xvY2FsWEF4aXMxKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHVibGljIG92ZXJyaWRlIFZlY3RvcjIgR2V0UmVhY3Rpb25Gb3JjZShmbG9hdCBpbnZfZHQpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gaW52X2R0ICogKF9pbXB1bHNlLlggKiBfcGVycCArIChNb3RvckZvcmNlICsgX2ltcHVsc2UuWikgKiBfYXhpcyk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwdWJsaWMgb3ZlcnJpZGUgZmxvYXQgR2V0UmVhY3Rpb25Ub3JxdWUoZmxvYXQgaW52X2R0KVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIGludl9kdCAqIF9pbXB1bHNlLlk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpbnRlcm5hbCBvdmVycmlkZSB2b2lkIEluaXRWZWxvY2l0eUNvbnN0cmFpbnRzKHJlZiBUaW1lU3RlcCBzdGVwKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgQm9keSBiQiA9IEJvZHlCO1xyXG5cclxuICAgICAgICAgICAgTG9jYWxDZW50ZXJBID0gVmVjdG9yMi5aZXJvO1xyXG4gICAgICAgICAgICBMb2NhbENlbnRlckIgPSBiQi5Mb2NhbENlbnRlcjtcclxuXHJcbiAgICAgICAgICAgIFRyYW5zZm9ybSB4ZjI7XHJcbiAgICAgICAgICAgIGJCLkdldFRyYW5zZm9ybShvdXQgeGYyKTtcclxuXHJcbiAgICAgICAgICAgIC8vIENvbXB1dGUgdGhlIGVmZmVjdGl2ZSBtYXNzZXMuXHJcbiAgICAgICAgICAgIFZlY3RvcjIgcjEgPSBMb2NhbEFuY2hvckE7XHJcbiAgICAgICAgICAgIFZlY3RvcjIgcjIgPSBNYXRoVXRpbHMuTXVsdGlwbHkocmVmIHhmMi5SLCBMb2NhbEFuY2hvckIgLSBMb2NhbENlbnRlckIpO1xyXG4gICAgICAgICAgICBWZWN0b3IyIGQgPSBiQi5Td2VlcC5DICsgcjIgLSAvKiBiMS5fc3dlZXAuQ2VudGVyIC0gKi8gcjE7XHJcblxyXG4gICAgICAgICAgICBJbnZNYXNzQSA9IDAuMGY7XHJcbiAgICAgICAgICAgIEludklBID0gMC4wZjtcclxuICAgICAgICAgICAgSW52TWFzc0IgPSBiQi5JbnZNYXNzO1xyXG4gICAgICAgICAgICBJbnZJQiA9IGJCLkludkk7XHJcblxyXG4gICAgICAgICAgICAvLyBDb21wdXRlIG1vdG9yIEphY29iaWFuIGFuZCBlZmZlY3RpdmUgbWFzcy5cclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgX2F4aXMgPSBfbG9jYWxYQXhpczE7XHJcbiAgICAgICAgICAgICAgICBfYTEgPSBNYXRoVXRpbHMuQ3Jvc3MoZCArIHIxLCBfYXhpcyk7XHJcbiAgICAgICAgICAgICAgICBfYTIgPSBNYXRoVXRpbHMuQ3Jvc3MocjIsIF9heGlzKTtcclxuXHJcbiAgICAgICAgICAgICAgICBfbW90b3JNYXNzID0gSW52TWFzc0EgKyBJbnZNYXNzQiArIEludklBICogX2ExICogX2ExICsgSW52SUIgKiBfYTIgKiBfYTI7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKF9tb3Rvck1hc3MgPiBTZXR0aW5ncy5FcHNpbG9uKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIF9tb3Rvck1hc3MgPSAxLjBmIC8gX21vdG9yTWFzcztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gUHJpc21hdGljIGNvbnN0cmFpbnQuXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIF9wZXJwID0gX2xvY2FsWUF4aXMxO1xyXG5cclxuICAgICAgICAgICAgICAgIF9zMSA9IE1hdGhVdGlscy5Dcm9zcyhkICsgcjEsIF9wZXJwKTtcclxuICAgICAgICAgICAgICAgIF9zMiA9IE1hdGhVdGlscy5Dcm9zcyhyMiwgX3BlcnApO1xyXG5cclxuICAgICAgICAgICAgICAgIGZsb2F0IG0xID0gSW52TWFzc0EsIG0yID0gSW52TWFzc0I7XHJcbiAgICAgICAgICAgICAgICBmbG9hdCBpMSA9IEludklBLCBpMiA9IEludklCO1xyXG5cclxuICAgICAgICAgICAgICAgIGZsb2F0IGsxMSA9IG0xICsgbTIgKyBpMSAqIF9zMSAqIF9zMSArIGkyICogX3MyICogX3MyO1xyXG4gICAgICAgICAgICAgICAgZmxvYXQgazEyID0gaTEgKiBfczEgKyBpMiAqIF9zMjtcclxuICAgICAgICAgICAgICAgIGZsb2F0IGsxMyA9IGkxICogX3MxICogX2ExICsgaTIgKiBfczIgKiBfYTI7XHJcbiAgICAgICAgICAgICAgICBmbG9hdCBrMjIgPSBpMSArIGkyO1xyXG4gICAgICAgICAgICAgICAgZmxvYXQgazIzID0gaTEgKiBfYTEgKyBpMiAqIF9hMjtcclxuICAgICAgICAgICAgICAgIGZsb2F0IGszMyA9IG0xICsgbTIgKyBpMSAqIF9hMSAqIF9hMSArIGkyICogX2EyICogX2EyO1xyXG5cclxuICAgICAgICAgICAgICAgIF9LLkNvbDEgPSBuZXcgVmVjdG9yMyhrMTEsIGsxMiwgazEzKTtcclxuICAgICAgICAgICAgICAgIF9LLkNvbDIgPSBuZXcgVmVjdG9yMyhrMTIsIGsyMiwgazIzKTtcclxuICAgICAgICAgICAgICAgIF9LLkNvbDMgPSBuZXcgVmVjdG9yMyhrMTMsIGsyMywgazMzKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gQ29tcHV0ZSBtb3RvciBhbmQgbGltaXQgdGVybXMuXHJcbiAgICAgICAgICAgIGlmIChfZW5hYmxlTGltaXQpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGZsb2F0IGpvaW50VHJhbnNsYXRpb24gPSBWZWN0b3IyLkRvdChfYXhpcywgZCk7XHJcbiAgICAgICAgICAgICAgICBpZiAoTWF0aC5BYnMoX3VwcGVyVHJhbnNsYXRpb24gLSBfbG93ZXJUcmFuc2xhdGlvbikgPCAyLjBmICogU2V0dGluZ3MuTGluZWFyU2xvcClcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBfbGltaXRTdGF0ZSA9IExpbWl0U3RhdGUuRXF1YWw7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChqb2ludFRyYW5zbGF0aW9uIDw9IF9sb3dlclRyYW5zbGF0aW9uKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChfbGltaXRTdGF0ZSAhPSBMaW1pdFN0YXRlLkF0TG93ZXIpXHJcbiAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBfbGltaXRTdGF0ZSA9IExpbWl0U3RhdGUuQXRMb3dlcjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgX2ltcHVsc2UuWiA9IDAuMGY7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoam9pbnRUcmFuc2xhdGlvbiA+PSBfdXBwZXJUcmFuc2xhdGlvbilcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoX2xpbWl0U3RhdGUgIT0gTGltaXRTdGF0ZS5BdFVwcGVyKVxyXG4gICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgX2xpbWl0U3RhdGUgPSBMaW1pdFN0YXRlLkF0VXBwZXI7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF9pbXB1bHNlLlogPSAwLjBmO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBfbGltaXRTdGF0ZSA9IExpbWl0U3RhdGUuSW5hY3RpdmU7XHJcbiAgICAgICAgICAgICAgICAgICAgX2ltcHVsc2UuWiA9IDAuMGY7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBfbGltaXRTdGF0ZSA9IExpbWl0U3RhdGUuSW5hY3RpdmU7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmIChfZW5hYmxlTW90b3IgPT0gZmFsc2UpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIE1vdG9yRm9yY2UgPSAwLjBmO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAoU2V0dGluZ3MuRW5hYmxlV2FybXN0YXJ0aW5nKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAvLyBBY2NvdW50IGZvciB2YXJpYWJsZSB0aW1lIHN0ZXAuXHJcbiAgICAgICAgICAgICAgICBfaW1wdWxzZSAqPSBzdGVwLmR0UmF0aW87XHJcbiAgICAgICAgICAgICAgICBNb3RvckZvcmNlICo9IHN0ZXAuZHRSYXRpbztcclxuXHJcbiAgICAgICAgICAgICAgICBWZWN0b3IyIFAgPSBfaW1wdWxzZS5YICogX3BlcnAgKyAoTW90b3JGb3JjZSArIF9pbXB1bHNlLlopICogX2F4aXM7XHJcbiAgICAgICAgICAgICAgICBmbG9hdCBMMiA9IF9pbXB1bHNlLlggKiBfczIgKyBfaW1wdWxzZS5ZICsgKE1vdG9yRm9yY2UgKyBfaW1wdWxzZS5aKSAqIF9hMjtcclxuXHJcbiAgICAgICAgICAgICAgICBiQi5MaW5lYXJWZWxvY2l0eUludGVybmFsICs9IEludk1hc3NCICogUDtcclxuICAgICAgICAgICAgICAgIGJCLkFuZ3VsYXJWZWxvY2l0eUludGVybmFsICs9IEludklCICogTDI7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBfaW1wdWxzZSA9IFZlY3RvcjMuWmVybztcclxuICAgICAgICAgICAgICAgIE1vdG9yRm9yY2UgPSAwLjBmO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpbnRlcm5hbCBvdmVycmlkZSB2b2lkIFNvbHZlVmVsb2NpdHlDb25zdHJhaW50cyhyZWYgVGltZVN0ZXAgc3RlcClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIEJvZHkgYkIgPSBCb2R5QjtcclxuXHJcbiAgICAgICAgICAgIFZlY3RvcjIgdjEgPSBWZWN0b3IyLlplcm87XHJcbiAgICAgICAgICAgIGZsb2F0IHcxID0gMC4wZjtcclxuICAgICAgICAgICAgVmVjdG9yMiB2MiA9IGJCLkxpbmVhclZlbG9jaXR5SW50ZXJuYWw7XHJcbiAgICAgICAgICAgIGZsb2F0IHcyID0gYkIuQW5ndWxhclZlbG9jaXR5SW50ZXJuYWw7XHJcblxyXG4gICAgICAgICAgICAvLyBTb2x2ZSBsaW5lYXIgbW90b3IgY29uc3RyYWludC5cclxuICAgICAgICAgICAgaWYgKF9lbmFibGVNb3RvciAmJiBfbGltaXRTdGF0ZSAhPSBMaW1pdFN0YXRlLkVxdWFsKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBmbG9hdCBDZG90ID0gVmVjdG9yMi5Eb3QoX2F4aXMsIHYyIC0gdjEpICsgX2EyICogdzIgLSBfYTEgKiB3MTtcclxuICAgICAgICAgICAgICAgIGZsb2F0IGltcHVsc2UgPSBfbW90b3JNYXNzICogKF9tb3RvclNwZWVkIC0gQ2RvdCk7XHJcbiAgICAgICAgICAgICAgICBmbG9hdCBvbGRJbXB1bHNlID0gTW90b3JGb3JjZTtcclxuICAgICAgICAgICAgICAgIGZsb2F0IG1heEltcHVsc2UgPSBzdGVwLmR0ICogX21heE1vdG9yRm9yY2U7XHJcbiAgICAgICAgICAgICAgICBNb3RvckZvcmNlID0gTWF0aFV0aWxzLkNsYW1wKE1vdG9yRm9yY2UgKyBpbXB1bHNlLCAtbWF4SW1wdWxzZSwgbWF4SW1wdWxzZSk7XHJcbiAgICAgICAgICAgICAgICBpbXB1bHNlID0gTW90b3JGb3JjZSAtIG9sZEltcHVsc2U7XHJcblxyXG4gICAgICAgICAgICAgICAgVmVjdG9yMiBQID0gaW1wdWxzZSAqIF9heGlzO1xyXG4gICAgICAgICAgICAgICAgZmxvYXQgTDEgPSBpbXB1bHNlICogX2ExO1xyXG4gICAgICAgICAgICAgICAgZmxvYXQgTDIgPSBpbXB1bHNlICogX2EyO1xyXG5cclxuICAgICAgICAgICAgICAgIHYxIC09IEludk1hc3NBICogUDtcclxuICAgICAgICAgICAgICAgIHcxIC09IEludklBICogTDE7XHJcblxyXG4gICAgICAgICAgICAgICAgdjIgKz0gSW52TWFzc0IgKiBQO1xyXG4gICAgICAgICAgICAgICAgdzIgKz0gSW52SUIgKiBMMjtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgVmVjdG9yMiBDZG90MSA9IG5ldyBWZWN0b3IyKFZlY3RvcjIuRG90KF9wZXJwLCB2MiAtIHYxKSArIF9zMiAqIHcyIC0gX3MxICogdzEsIHcyIC0gdzEpO1xyXG5cclxuICAgICAgICAgICAgaWYgKF9lbmFibGVMaW1pdCAmJiBfbGltaXRTdGF0ZSAhPSBMaW1pdFN0YXRlLkluYWN0aXZlKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAvLyBTb2x2ZSBwcmlzbWF0aWMgYW5kIGxpbWl0IGNvbnN0cmFpbnQgaW4gYmxvY2sgZm9ybS5cclxuICAgICAgICAgICAgICAgIGZsb2F0IENkb3QyID0gVmVjdG9yMi5Eb3QoX2F4aXMsIHYyIC0gdjEpICsgX2EyICogdzIgLSBfYTEgKiB3MTtcclxuICAgICAgICAgICAgICAgIFZlY3RvcjMgQ2RvdCA9IG5ldyBWZWN0b3IzKENkb3QxLlgsIENkb3QxLlksIENkb3QyKTtcclxuXHJcbiAgICAgICAgICAgICAgICBWZWN0b3IzIGYxID0gX2ltcHVsc2U7XHJcbiAgICAgICAgICAgICAgICBWZWN0b3IzIGRmID0gX0suU29sdmUzMygtQ2RvdCk7XHJcbiAgICAgICAgICAgICAgICBfaW1wdWxzZSArPSBkZjtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoX2xpbWl0U3RhdGUgPT0gTGltaXRTdGF0ZS5BdExvd2VyKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIF9pbXB1bHNlLlogPSBNYXRoLk1heChfaW1wdWxzZS5aLCAwLjBmKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKF9saW1pdFN0YXRlID09IExpbWl0U3RhdGUuQXRVcHBlcilcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBfaW1wdWxzZS5aID0gTWF0aC5NaW4oX2ltcHVsc2UuWiwgMC4wZik7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gZjIoMToyKSA9IGludksoMToyLDE6MikgKiAoLUNkb3QoMToyKSAtIEsoMToyLDMpICogKGYyKDMpIC0gZjEoMykpKSArIGYxKDE6MilcclxuICAgICAgICAgICAgICAgIFZlY3RvcjIgYiA9IC1DZG90MSAtIChfaW1wdWxzZS5aIC0gZjEuWikgKiBuZXcgVmVjdG9yMihfSy5Db2wzLlgsIF9LLkNvbDMuWSk7XHJcbiAgICAgICAgICAgICAgICBWZWN0b3IyIGYyciA9IF9LLlNvbHZlMjIoYikgKyBuZXcgVmVjdG9yMihmMS5YLCBmMS5ZKTtcclxuICAgICAgICAgICAgICAgIF9pbXB1bHNlLlggPSBmMnIuWDtcclxuICAgICAgICAgICAgICAgIF9pbXB1bHNlLlkgPSBmMnIuWTtcclxuXHJcbiAgICAgICAgICAgICAgICBkZiA9IF9pbXB1bHNlIC0gZjE7XHJcblxyXG4gICAgICAgICAgICAgICAgVmVjdG9yMiBQID0gZGYuWCAqIF9wZXJwICsgZGYuWiAqIF9heGlzO1xyXG4gICAgICAgICAgICAgICAgZmxvYXQgTDIgPSBkZi5YICogX3MyICsgZGYuWSArIGRmLlogKiBfYTI7XHJcblxyXG4gICAgICAgICAgICAgICAgdjIgKz0gSW52TWFzc0IgKiBQO1xyXG4gICAgICAgICAgICAgICAgdzIgKz0gSW52SUIgKiBMMjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIC8vIExpbWl0IGlzIGluYWN0aXZlLCBqdXN0IHNvbHZlIHRoZSBwcmlzbWF0aWMgY29uc3RyYWludCBpbiBibG9jayBmb3JtLlxyXG4gICAgICAgICAgICAgICAgVmVjdG9yMiBkZiA9IF9LLlNvbHZlMjIoLUNkb3QxKTtcclxuICAgICAgICAgICAgICAgIF9pbXB1bHNlLlggKz0gZGYuWDtcclxuICAgICAgICAgICAgICAgIF9pbXB1bHNlLlkgKz0gZGYuWTtcclxuXHJcbiAgICAgICAgICAgICAgICBWZWN0b3IyIFAgPSBkZi5YICogX3BlcnA7XHJcbiAgICAgICAgICAgICAgICBmbG9hdCBMMiA9IGRmLlggKiBfczIgKyBkZi5ZO1xyXG5cclxuICAgICAgICAgICAgICAgIHYyICs9IEludk1hc3NCICogUDtcclxuICAgICAgICAgICAgICAgIHcyICs9IEludklCICogTDI7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGJCLkxpbmVhclZlbG9jaXR5SW50ZXJuYWwgPSB2MjtcclxuICAgICAgICAgICAgYkIuQW5ndWxhclZlbG9jaXR5SW50ZXJuYWwgPSB3MjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGludGVybmFsIG92ZXJyaWRlIGJvb2wgU29sdmVQb3NpdGlvbkNvbnN0cmFpbnRzKClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIC8vQm9keSBiMSA9IEJvZHlBO1xyXG4gICAgICAgICAgICBCb2R5IGIyID0gQm9keUI7XHJcblxyXG4gICAgICAgICAgICBWZWN0b3IyIGMxID0gVmVjdG9yMi5aZXJvOyAvLyBiMS5fc3dlZXAuQ2VudGVyO1xyXG4gICAgICAgICAgICBmbG9hdCBhMSA9IDAuMGY7IC8vIGIxLl9zd2VlcC5BbmdsZTtcclxuXHJcbiAgICAgICAgICAgIFZlY3RvcjIgYzIgPSBiMi5Td2VlcC5DO1xyXG4gICAgICAgICAgICBmbG9hdCBhMiA9IGIyLlN3ZWVwLkE7XHJcblxyXG4gICAgICAgICAgICAvLyBTb2x2ZSBsaW5lYXIgbGltaXQgY29uc3RyYWludC5cclxuICAgICAgICAgICAgZmxvYXQgbGluZWFyRXJyb3IgPSAwLjBmO1xyXG4gICAgICAgICAgICBib29sIGFjdGl2ZSA9IGZhbHNlO1xyXG4gICAgICAgICAgICBmbG9hdCBDMiA9IDAuMGY7XHJcblxyXG4gICAgICAgICAgICBNYXQyMiBSMSA9IG5ldyBNYXQyMihhMSk7XHJcbiAgICAgICAgICAgIE1hdDIyIFIyID0gbmV3IE1hdDIyKGEyKTtcclxuXHJcbiAgICAgICAgICAgIFZlY3RvcjIgcjEgPSBNYXRoVXRpbHMuTXVsdGlwbHkocmVmIFIxLCBMb2NhbEFuY2hvckEgLSBMb2NhbENlbnRlckEpO1xyXG4gICAgICAgICAgICBWZWN0b3IyIHIyID0gTWF0aFV0aWxzLk11bHRpcGx5KHJlZiBSMiwgTG9jYWxBbmNob3JCIC0gTG9jYWxDZW50ZXJCKTtcclxuICAgICAgICAgICAgVmVjdG9yMiBkID0gYzIgKyByMiAtIGMxIC0gcjE7XHJcblxyXG4gICAgICAgICAgICBpZiAoX2VuYWJsZUxpbWl0KVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBfYXhpcyA9IE1hdGhVdGlscy5NdWx0aXBseShyZWYgUjEsIF9sb2NhbFhBeGlzMSk7XHJcblxyXG4gICAgICAgICAgICAgICAgX2ExID0gTWF0aFV0aWxzLkNyb3NzKGQgKyByMSwgX2F4aXMpO1xyXG4gICAgICAgICAgICAgICAgX2EyID0gTWF0aFV0aWxzLkNyb3NzKHIyLCBfYXhpcyk7XHJcblxyXG4gICAgICAgICAgICAgICAgZmxvYXQgdHJhbnNsYXRpb24gPSBWZWN0b3IyLkRvdChfYXhpcywgZCk7XHJcbiAgICAgICAgICAgICAgICBpZiAoTWF0aC5BYnMoX3VwcGVyVHJhbnNsYXRpb24gLSBfbG93ZXJUcmFuc2xhdGlvbikgPCAyLjBmICogU2V0dGluZ3MuTGluZWFyU2xvcClcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBQcmV2ZW50IGxhcmdlIGFuZ3VsYXIgY29ycmVjdGlvbnNcclxuICAgICAgICAgICAgICAgICAgICBDMiA9IE1hdGhVdGlscy5DbGFtcCh0cmFuc2xhdGlvbiwgLVNldHRpbmdzLk1heExpbmVhckNvcnJlY3Rpb24sIFNldHRpbmdzLk1heExpbmVhckNvcnJlY3Rpb24pO1xyXG4gICAgICAgICAgICAgICAgICAgIGxpbmVhckVycm9yID0gKGZsb2F0KU1hdGguQWJzKHRyYW5zbGF0aW9uKTtcclxuICAgICAgICAgICAgICAgICAgICBhY3RpdmUgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodHJhbnNsYXRpb24gPD0gX2xvd2VyVHJhbnNsYXRpb24pXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gUHJldmVudCBsYXJnZSBsaW5lYXIgY29ycmVjdGlvbnMgYW5kIGFsbG93IHNvbWUgc2xvcC5cclxuICAgICAgICAgICAgICAgICAgICBDMiA9IE1hdGhVdGlscy5DbGFtcCh0cmFuc2xhdGlvbiAtIF9sb3dlclRyYW5zbGF0aW9uICsgU2V0dGluZ3MuTGluZWFyU2xvcCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAtU2V0dGluZ3MuTWF4TGluZWFyQ29ycmVjdGlvbiwgMC4wZik7XHJcbiAgICAgICAgICAgICAgICAgICAgbGluZWFyRXJyb3IgPSBfbG93ZXJUcmFuc2xhdGlvbiAtIHRyYW5zbGF0aW9uO1xyXG4gICAgICAgICAgICAgICAgICAgIGFjdGl2ZSA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmICh0cmFuc2xhdGlvbiA+PSBfdXBwZXJUcmFuc2xhdGlvbilcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBQcmV2ZW50IGxhcmdlIGxpbmVhciBjb3JyZWN0aW9ucyBhbmQgYWxsb3cgc29tZSBzbG9wLlxyXG4gICAgICAgICAgICAgICAgICAgIEMyID0gTWF0aFV0aWxzLkNsYW1wKHRyYW5zbGF0aW9uIC0gX3VwcGVyVHJhbnNsYXRpb24gLSBTZXR0aW5ncy5MaW5lYXJTbG9wLCAwLjBmLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFNldHRpbmdzLk1heExpbmVhckNvcnJlY3Rpb24pO1xyXG4gICAgICAgICAgICAgICAgICAgIGxpbmVhckVycm9yID0gdHJhbnNsYXRpb24gLSBfdXBwZXJUcmFuc2xhdGlvbjtcclxuICAgICAgICAgICAgICAgICAgICBhY3RpdmUgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBfcGVycCA9IE1hdGhVdGlscy5NdWx0aXBseShyZWYgUjEsIF9sb2NhbFlBeGlzMSk7XHJcblxyXG4gICAgICAgICAgICBfczEgPSBNYXRoVXRpbHMuQ3Jvc3MoZCArIHIxLCBfcGVycCk7XHJcbiAgICAgICAgICAgIF9zMiA9IE1hdGhVdGlscy5Dcm9zcyhyMiwgX3BlcnApO1xyXG5cclxuICAgICAgICAgICAgVmVjdG9yMyBpbXB1bHNlO1xyXG4gICAgICAgICAgICBWZWN0b3IyIEMxID0gbmV3IFZlY3RvcjIoVmVjdG9yMi5Eb3QoX3BlcnAsIGQpLCBhMiAtIGExIC0gX3JlZkFuZ2xlKTtcclxuXHJcbiAgICAgICAgICAgIGxpbmVhckVycm9yID0gTWF0aC5NYXgobGluZWFyRXJyb3IsIChmbG9hdClNYXRoLkFicyhDMS5YKSk7XHJcbiAgICAgICAgICAgIGZsb2F0IGFuZ3VsYXJFcnJvciA9IChmbG9hdClNYXRoLkFicyhDMS5ZKTtcclxuXHJcbiAgICAgICAgICAgIGlmIChhY3RpdmUpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGZsb2F0IG0xID0gSW52TWFzc0EsIG0yID0gSW52TWFzc0I7XHJcbiAgICAgICAgICAgICAgICBmbG9hdCBpMSA9IEludklBLCBpMiA9IEludklCO1xyXG5cclxuICAgICAgICAgICAgICAgIGZsb2F0IGsxMSA9IG0xICsgbTIgKyBpMSAqIF9zMSAqIF9zMSArIGkyICogX3MyICogX3MyO1xyXG4gICAgICAgICAgICAgICAgZmxvYXQgazEyID0gaTEgKiBfczEgKyBpMiAqIF9zMjtcclxuICAgICAgICAgICAgICAgIGZsb2F0IGsxMyA9IGkxICogX3MxICogX2ExICsgaTIgKiBfczIgKiBfYTI7XHJcbiAgICAgICAgICAgICAgICBmbG9hdCBrMjIgPSBpMSArIGkyO1xyXG4gICAgICAgICAgICAgICAgZmxvYXQgazIzID0gaTEgKiBfYTEgKyBpMiAqIF9hMjtcclxuICAgICAgICAgICAgICAgIGZsb2F0IGszMyA9IG0xICsgbTIgKyBpMSAqIF9hMSAqIF9hMSArIGkyICogX2EyICogX2EyO1xyXG5cclxuICAgICAgICAgICAgICAgIF9LLkNvbDEgPSBuZXcgVmVjdG9yMyhrMTEsIGsxMiwgazEzKTtcclxuICAgICAgICAgICAgICAgIF9LLkNvbDIgPSBuZXcgVmVjdG9yMyhrMTIsIGsyMiwgazIzKTtcclxuICAgICAgICAgICAgICAgIF9LLkNvbDMgPSBuZXcgVmVjdG9yMyhrMTMsIGsyMywgazMzKTtcclxuXHJcbiAgICAgICAgICAgICAgICBWZWN0b3IzIEMgPSBuZXcgVmVjdG9yMygtQzEuWCwgLUMxLlksIC1DMik7XHJcbiAgICAgICAgICAgICAgICBpbXB1bHNlID0gX0suU29sdmUzMyhDKTsgLy8gbmVnYXRlZCBhYm92ZVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgZmxvYXQgbTEgPSBJbnZNYXNzQSwgbTIgPSBJbnZNYXNzQjtcclxuICAgICAgICAgICAgICAgIGZsb2F0IGkxID0gSW52SUEsIGkyID0gSW52SUI7XHJcblxyXG4gICAgICAgICAgICAgICAgZmxvYXQgazExID0gbTEgKyBtMiArIGkxICogX3MxICogX3MxICsgaTIgKiBfczIgKiBfczI7XHJcbiAgICAgICAgICAgICAgICBmbG9hdCBrMTIgPSBpMSAqIF9zMSArIGkyICogX3MyO1xyXG4gICAgICAgICAgICAgICAgZmxvYXQgazIyID0gaTEgKyBpMjtcclxuXHJcbiAgICAgICAgICAgICAgICBfSy5Db2wxID0gbmV3IFZlY3RvcjMoazExLCBrMTIsIDAuMGYpO1xyXG4gICAgICAgICAgICAgICAgX0suQ29sMiA9IG5ldyBWZWN0b3IzKGsxMiwgazIyLCAwLjBmKTtcclxuXHJcbiAgICAgICAgICAgICAgICBWZWN0b3IyIGltcHVsc2UxID0gX0suU29sdmUyMigtQzEpO1xyXG4gICAgICAgICAgICAgICAgaW1wdWxzZS5YID0gaW1wdWxzZTEuWDtcclxuICAgICAgICAgICAgICAgIGltcHVsc2UuWSA9IGltcHVsc2UxLlk7XHJcbiAgICAgICAgICAgICAgICBpbXB1bHNlLlogPSAwLjBmO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBWZWN0b3IyIFAgPSBpbXB1bHNlLlggKiBfcGVycCArIGltcHVsc2UuWiAqIF9heGlzO1xyXG4gICAgICAgICAgICBmbG9hdCBMMiA9IGltcHVsc2UuWCAqIF9zMiArIGltcHVsc2UuWSArIGltcHVsc2UuWiAqIF9hMjtcclxuXHJcbiAgICAgICAgICAgIGMyICs9IEludk1hc3NCICogUDtcclxuICAgICAgICAgICAgYTIgKz0gSW52SUIgKiBMMjtcclxuXHJcbiAgICAgICAgICAgIC8vIFRPRE9fRVJJTiByZW1vdmUgbmVlZCBmb3IgdGhpcy5cclxuICAgICAgICAgICAgYjIuU3dlZXAuQyA9IGMyO1xyXG4gICAgICAgICAgICBiMi5Td2VlcC5BID0gYTI7XHJcbiAgICAgICAgICAgIGIyLlN5bmNocm9uaXplVHJhbnNmb3JtKCk7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gbGluZWFyRXJyb3IgPD0gU2V0dGluZ3MuTGluZWFyU2xvcCAmJiBhbmd1bGFyRXJyb3IgPD0gU2V0dGluZ3MuQW5ndWxhclNsb3A7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59IiwiLypcclxuKiBGYXJzZWVyIFBoeXNpY3MgRW5naW5lIGJhc2VkIG9uIEJveDJELlhOQSBwb3J0OlxyXG4qIENvcHlyaWdodCAoYykgMjAxMCBJYW4gUXZpc3RcclxuKiBcclxuKiBCb3gyRC5YTkEgcG9ydCBvZiBCb3gyRDpcclxuKiBDb3B5cmlnaHQgKGMpIDIwMDkgQnJhbmRvbiBGdXJ0d2FuZ2xlciwgTmF0aGFuIEZ1cnR3YW5nbGVyXHJcbipcclxuKiBPcmlnaW5hbCBzb3VyY2UgQm94MkQ6XHJcbiogQ29weXJpZ2h0IChjKSAyMDA2LTIwMDkgRXJpbiBDYXR0byBodHRwOi8vd3d3LmdwaHlzaWNzLmNvbSBcclxuKiBcclxuKiBUaGlzIHNvZnR3YXJlIGlzIHByb3ZpZGVkICdhcy1pcycsIHdpdGhvdXQgYW55IGV4cHJlc3Mgb3IgaW1wbGllZCBcclxuKiB3YXJyYW50eS4gIEluIG5vIGV2ZW50IHdpbGwgdGhlIGF1dGhvcnMgYmUgaGVsZCBsaWFibGUgZm9yIGFueSBkYW1hZ2VzIFxyXG4qIGFyaXNpbmcgZnJvbSB0aGUgdXNlIG9mIHRoaXMgc29mdHdhcmUuIFxyXG4qIFBlcm1pc3Npb24gaXMgZ3JhbnRlZCB0byBhbnlvbmUgdG8gdXNlIHRoaXMgc29mdHdhcmUgZm9yIGFueSBwdXJwb3NlLCBcclxuKiBpbmNsdWRpbmcgY29tbWVyY2lhbCBhcHBsaWNhdGlvbnMsIGFuZCB0byBhbHRlciBpdCBhbmQgcmVkaXN0cmlidXRlIGl0IFxyXG4qIGZyZWVseSwgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIHJlc3RyaWN0aW9uczogXHJcbiogMS4gVGhlIG9yaWdpbiBvZiB0aGlzIHNvZnR3YXJlIG11c3Qgbm90IGJlIG1pc3JlcHJlc2VudGVkOyB5b3UgbXVzdCBub3QgXHJcbiogY2xhaW0gdGhhdCB5b3Ugd3JvdGUgdGhlIG9yaWdpbmFsIHNvZnR3YXJlLiBJZiB5b3UgdXNlIHRoaXMgc29mdHdhcmUgXHJcbiogaW4gYSBwcm9kdWN0LCBhbiBhY2tub3dsZWRnbWVudCBpbiB0aGUgcHJvZHVjdCBkb2N1bWVudGF0aW9uIHdvdWxkIGJlIFxyXG4qIGFwcHJlY2lhdGVkIGJ1dCBpcyBub3QgcmVxdWlyZWQuIFxyXG4qIDIuIEFsdGVyZWQgc291cmNlIHZlcnNpb25zIG11c3QgYmUgcGxhaW5seSBtYXJrZWQgYXMgc3VjaCwgYW5kIG11c3Qgbm90IGJlIFxyXG4qIG1pc3JlcHJlc2VudGVkIGFzIGJlaW5nIHRoZSBvcmlnaW5hbCBzb2Z0d2FyZS4gXHJcbiogMy4gVGhpcyBub3RpY2UgbWF5IG5vdCBiZSByZW1vdmVkIG9yIGFsdGVyZWQgZnJvbSBhbnkgc291cmNlIGRpc3RyaWJ1dGlvbi4gXHJcbiovXHJcblxyXG51c2luZyBTeXN0ZW07XHJcbnVzaW5nIFN5c3RlbS5EaWFnbm9zdGljcztcclxudXNpbmcgRmFyc2VlclBoeXNpY3MuQ29tbW9uO1xyXG51c2luZyBNaWNyb3NvZnQuWG5hLkZyYW1ld29yaztcclxuXHJcbm5hbWVzcGFjZSBGYXJzZWVyUGh5c2ljcy5EeW5hbWljcy5Kb2ludHNcclxue1xyXG4gICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgLy8vIEEgcmV2b2x1dGUgam9pbnQgcmFpbnMgdG8gYm9kaWVzIHRvIHNoYXJlIGEgY29tbW9uIHBvaW50IHdoaWxlIHRoZXlcclxuICAgIC8vLyBhcmUgZnJlZSB0byByb3RhdGUgYWJvdXQgdGhlIHBvaW50LiBUaGUgcmVsYXRpdmUgcm90YXRpb24gYWJvdXQgdGhlIHNoYXJlZFxyXG4gICAgLy8vIHBvaW50IGlzIHRoZSBqb2ludCBhbmdsZS4gWW91IGNhbiBsaW1pdCB0aGUgcmVsYXRpdmUgcm90YXRpb24gd2l0aFxyXG4gICAgLy8vIGEgam9pbnQgbGltaXQgdGhhdCBzcGVjaWZpZXMgYSBsb3dlciBhbmQgdXBwZXIgYW5nbGUuIFlvdSBjYW4gdXNlIGEgbW90b3JcclxuICAgIC8vLyB0byBkcml2ZSB0aGUgcmVsYXRpdmUgcm90YXRpb24gYWJvdXQgdGhlIHNoYXJlZCBwb2ludC4gQSBtYXhpbXVtIG1vdG9yIHRvcnF1ZVxyXG4gICAgLy8vIGlzIHByb3ZpZGVkIHNvIHRoYXQgaW5maW5pdGUgZm9yY2VzIGFyZSBub3QgZ2VuZXJhdGVkLlxyXG4gICAgLy8vIDwvc3VtbWFyeT5cclxuICAgIHB1YmxpYyBjbGFzcyBGaXhlZFJldm9sdXRlSm9pbnQgOiBKb2ludFxyXG4gICAge1xyXG4gICAgICAgIHByaXZhdGUgYm9vbCBfZW5hYmxlTGltaXQ7XHJcbiAgICAgICAgcHJpdmF0ZSBib29sIF9lbmFibGVNb3RvcjtcclxuICAgICAgICBwcml2YXRlIFZlY3RvcjMgX2ltcHVsc2U7XHJcbiAgICAgICAgcHJpdmF0ZSBMaW1pdFN0YXRlIF9saW1pdFN0YXRlO1xyXG4gICAgICAgIHByaXZhdGUgZmxvYXQgX2xvd2VyQW5nbGU7XHJcbiAgICAgICAgcHJpdmF0ZSBNYXQzMyBfbWFzczsgLy8gZWZmZWN0aXZlIG1hc3MgZm9yIHBvaW50LXRvLXBvaW50IGNvbnN0cmFpbnQuXHJcbiAgICAgICAgcHJpdmF0ZSBmbG9hdCBfbWF4TW90b3JUb3JxdWU7XHJcbiAgICAgICAgcHJpdmF0ZSBmbG9hdCBfbW90b3JJbXB1bHNlO1xyXG4gICAgICAgIHByaXZhdGUgZmxvYXQgX21vdG9yTWFzczsgLy8gZWZmZWN0aXZlIG1hc3MgZm9yIG1vdG9yL2xpbWl0IGFuZ3VsYXIgY29uc3RyYWludC5cclxuICAgICAgICBwcml2YXRlIGZsb2F0IF9tb3RvclNwZWVkO1xyXG4gICAgICAgIHByaXZhdGUgZmxvYXQgX3VwcGVyQW5nbGU7XHJcbiAgICAgICAgcHJpdmF0ZSBWZWN0b3IyIF93b3JsZEFuY2hvcjtcclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBJbml0aWFsaXplIHRoZSBib2RpZXMsIGFuY2hvcnMsIGFuZCByZWZlcmVuY2UgYW5nbGUgdXNpbmcgdGhlIHdvcmxkXHJcbiAgICAgICAgLy8vIGFuY2hvci5cclxuICAgICAgICAvLy8gVGhpcyByZXF1aXJlcyBkZWZpbmluZyBhblxyXG4gICAgICAgIC8vLyBhbmNob3IgcG9pbnQgd2hlcmUgdGhlIGJvZGllcyBhcmUgam9pbmVkLiBUaGUgZGVmaW5pdGlvblxyXG4gICAgICAgIC8vLyB1c2VzIGxvY2FsIGFuY2hvciBwb2ludHMgc28gdGhhdCB0aGUgaW5pdGlhbCBjb25maWd1cmF0aW9uXHJcbiAgICAgICAgLy8vIGNhbiB2aW9sYXRlIHRoZSBjb25zdHJhaW50IHNsaWdodGx5LiBZb3UgYWxzbyBuZWVkIHRvXHJcbiAgICAgICAgLy8vIHNwZWNpZnkgdGhlIGluaXRpYWwgcmVsYXRpdmUgYW5nbGUgZm9yIGpvaW50IGxpbWl0cy4gVGhpc1xyXG4gICAgICAgIC8vLyBoZWxwcyB3aGVuIHNhdmluZyBhbmQgbG9hZGluZyBhIGdhbWUuXHJcbiAgICAgICAgLy8vIFRoZSBsb2NhbCBhbmNob3IgcG9pbnRzIGFyZSBtZWFzdXJlZCBmcm9tIHRoZSBib2R5J3Mgb3JpZ2luXHJcbiAgICAgICAgLy8vIHJhdGhlciB0aGFuIHRoZSBjZW50ZXIgb2YgbWFzcyBiZWNhdXNlOlxyXG4gICAgICAgIC8vLyAxLiB5b3UgbWlnaHQgbm90IGtub3cgd2hlcmUgdGhlIGNlbnRlciBvZiBtYXNzIHdpbGwgYmUuXHJcbiAgICAgICAgLy8vIDIuIGlmIHlvdSBhZGQvcmVtb3ZlIHNoYXBlcyBmcm9tIGEgYm9keSBhbmQgcmVjb21wdXRlIHRoZSBtYXNzLFxyXG4gICAgICAgIC8vLyB0aGUgam9pbnRzIHdpbGwgYmUgYnJva2VuLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwiYm9keVwiPlRoZSBib2R5LjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwiYm9keUFuY2hvclwiPlRoZSBib2R5IGFuY2hvci48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cIndvcmxkQW5jaG9yXCI+VGhlIHdvcmxkIGFuY2hvci48L3BhcmFtPlxyXG4gICAgICAgIHB1YmxpYyBGaXhlZFJldm9sdXRlSm9pbnQoQm9keSBib2R5LCBWZWN0b3IyIGJvZHlBbmNob3IsIFZlY3RvcjIgd29ybGRBbmNob3IpXHJcbiAgICAgICAgICAgIDogYmFzZShib2R5KVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgSm9pbnRUeXBlID0gSm9pbnRUeXBlLkZpeGVkUmV2b2x1dGU7XHJcblxyXG4gICAgICAgICAgICAvLyBDaGFuZ2VkIHRvIGxvY2FsIGNvb3JkaW5hdGVzLlxyXG4gICAgICAgICAgICBMb2NhbEFuY2hvckEgPSBib2R5QW5jaG9yO1xyXG4gICAgICAgICAgICBfd29ybGRBbmNob3IgPSB3b3JsZEFuY2hvcjtcclxuXHJcbiAgICAgICAgICAgIFJlZmVyZW5jZUFuZ2xlID0gLUJvZHlBLlJvdGF0aW9uO1xyXG5cclxuICAgICAgICAgICAgX2ltcHVsc2UgPSBWZWN0b3IzLlplcm87XHJcblxyXG4gICAgICAgICAgICBfbGltaXRTdGF0ZSA9IExpbWl0U3RhdGUuSW5hY3RpdmU7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwdWJsaWMgb3ZlcnJpZGUgVmVjdG9yMiBXb3JsZEFuY2hvckFcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGdldCB7IHJldHVybiBCb2R5QS5HZXRXb3JsZFBvaW50KExvY2FsQW5jaG9yQSk7IH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHB1YmxpYyBvdmVycmlkZSBWZWN0b3IyIFdvcmxkQW5jaG9yQlxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgZ2V0IHsgcmV0dXJuIF93b3JsZEFuY2hvcjsgfVxyXG4gICAgICAgICAgICBzZXQgeyBfd29ybGRBbmNob3IgPSB2YWx1ZTsgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHVibGljIFZlY3RvcjIgTG9jYWxBbmNob3JBIHsgZ2V0OyBzZXQ7IH1cclxuXHJcbiAgICAgICAgcHVibGljIGZsb2F0IFJlZmVyZW5jZUFuZ2xlIHsgZ2V0OyBzZXQ7IH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBHZXQgdGhlIGN1cnJlbnQgam9pbnQgYW5nbGUgaW4gcmFkaWFucy5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8dmFsdWU+PC92YWx1ZT5cclxuICAgICAgICBwdWJsaWMgZmxvYXQgSm9pbnRBbmdsZVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgZ2V0IHsgcmV0dXJuIEJvZHlBLlN3ZWVwLkEgLSBSZWZlcmVuY2VBbmdsZTsgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBHZXQgdGhlIGN1cnJlbnQgam9pbnQgYW5nbGUgc3BlZWQgaW4gcmFkaWFucyBwZXIgc2Vjb25kLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDx2YWx1ZT48L3ZhbHVlPlxyXG4gICAgICAgIHB1YmxpYyBmbG9hdCBKb2ludFNwZWVkXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBnZXQgeyByZXR1cm4gQm9keUEuQW5ndWxhclZlbG9jaXR5SW50ZXJuYWw7IH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gSXMgdGhlIGpvaW50IGxpbWl0IGVuYWJsZWQ/XHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHZhbHVlPjxjPnRydWU8L2M+IGlmIFtsaW1pdCBlbmFibGVkXTsgb3RoZXJ3aXNlLCA8Yz5mYWxzZTwvYz4uPC92YWx1ZT5cclxuICAgICAgICBwdWJsaWMgYm9vbCBMaW1pdEVuYWJsZWRcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGdldCB7IHJldHVybiBfZW5hYmxlTGltaXQ7IH1cclxuICAgICAgICAgICAgc2V0XHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIFdha2VCb2RpZXMoKTtcclxuICAgICAgICAgICAgICAgIF9lbmFibGVMaW1pdCA9IHZhbHVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIEdldCB0aGUgbG93ZXIgam9pbnQgbGltaXQgaW4gcmFkaWFucy5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8dmFsdWU+PC92YWx1ZT5cclxuICAgICAgICBwdWJsaWMgZmxvYXQgTG93ZXJMaW1pdFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgZ2V0IHsgcmV0dXJuIF9sb3dlckFuZ2xlOyB9XHJcbiAgICAgICAgICAgIHNldFxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBXYWtlQm9kaWVzKCk7XHJcbiAgICAgICAgICAgICAgICBfbG93ZXJBbmdsZSA9IHZhbHVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIEdldCB0aGUgdXBwZXIgam9pbnQgbGltaXQgaW4gcmFkaWFucy5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8dmFsdWU+PC92YWx1ZT5cclxuICAgICAgICBwdWJsaWMgZmxvYXQgVXBwZXJMaW1pdFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgZ2V0IHsgcmV0dXJuIF91cHBlckFuZ2xlOyB9XHJcbiAgICAgICAgICAgIHNldFxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBXYWtlQm9kaWVzKCk7XHJcbiAgICAgICAgICAgICAgICBfdXBwZXJBbmdsZSA9IHZhbHVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIElzIHRoZSBqb2ludCBtb3RvciBlbmFibGVkP1xyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDx2YWx1ZT48Yz50cnVlPC9jPiBpZiBbbW90b3IgZW5hYmxlZF07IG90aGVyd2lzZSwgPGM+ZmFsc2U8L2M+LjwvdmFsdWU+XHJcbiAgICAgICAgcHVibGljIGJvb2wgTW90b3JFbmFibGVkXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBnZXQgeyByZXR1cm4gX2VuYWJsZU1vdG9yOyB9XHJcbiAgICAgICAgICAgIHNldFxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBXYWtlQm9kaWVzKCk7XHJcbiAgICAgICAgICAgICAgICBfZW5hYmxlTW90b3IgPSB2YWx1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBTZXQgdGhlIG1vdG9yIHNwZWVkIGluIHJhZGlhbnMgcGVyIHNlY29uZC5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8dmFsdWU+VGhlIHNwZWVkLjwvdmFsdWU+XHJcbiAgICAgICAgcHVibGljIGZsb2F0IE1vdG9yU3BlZWRcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHNldFxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBXYWtlQm9kaWVzKCk7XHJcbiAgICAgICAgICAgICAgICBfbW90b3JTcGVlZCA9IHZhbHVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGdldCB7IHJldHVybiBfbW90b3JTcGVlZDsgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBTZXQgdGhlIG1heGltdW0gbW90b3IgdG9ycXVlLCB1c3VhbGx5IGluIE4tbS5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8dmFsdWU+VGhlIHRvcnF1ZS48L3ZhbHVlPlxyXG4gICAgICAgIHB1YmxpYyBmbG9hdCBNYXhNb3RvclRvcnF1ZVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgc2V0XHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIFdha2VCb2RpZXMoKTtcclxuICAgICAgICAgICAgICAgIF9tYXhNb3RvclRvcnF1ZSA9IHZhbHVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGdldCB7IHJldHVybiBfbWF4TW90b3JUb3JxdWU7IH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gR2V0IHRoZSBjdXJyZW50IG1vdG9yIHRvcnF1ZSwgdXN1YWxseSBpbiBOLW0uXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHZhbHVlPjwvdmFsdWU+XHJcbiAgICAgICAgcHVibGljIGZsb2F0IE1vdG9yVG9ycXVlXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBnZXQgeyByZXR1cm4gX21vdG9ySW1wdWxzZTsgfVxyXG4gICAgICAgICAgICBzZXRcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgV2FrZUJvZGllcygpO1xyXG4gICAgICAgICAgICAgICAgX21vdG9ySW1wdWxzZSA9IHZhbHVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwdWJsaWMgb3ZlcnJpZGUgVmVjdG9yMiBHZXRSZWFjdGlvbkZvcmNlKGZsb2F0IGludl9kdClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiBpbnZfZHQgKiBuZXcgVmVjdG9yMihfaW1wdWxzZS5YLCBfaW1wdWxzZS5ZKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHB1YmxpYyBvdmVycmlkZSBmbG9hdCBHZXRSZWFjdGlvblRvcnF1ZShmbG9hdCBpbnZfZHQpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gaW52X2R0ICogX2ltcHVsc2UuWjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGludGVybmFsIG92ZXJyaWRlIHZvaWQgSW5pdFZlbG9jaXR5Q29uc3RyYWludHMocmVmIFRpbWVTdGVwIHN0ZXApXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBCb2R5IGIxID0gQm9keUE7XHJcblxyXG4gICAgICAgICAgICBpZiAoX2VuYWJsZU1vdG9yIHx8IF9lbmFibGVMaW1pdClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgLy8gWW91IGNhbm5vdCBjcmVhdGUgYSByb3RhdGlvbiBsaW1pdCBiZXR3ZWVuIGJvZGllcyB0aGF0XHJcbiAgICAgICAgICAgICAgICAvLyBib3RoIGhhdmUgZml4ZWQgcm90YXRpb24uXHJcbiAgICAgICAgICAgICAgICBEZWJ1Zy5Bc3NlcnQoYjEuSW52SSA+IDAuMGYgLyogfHwgYjIuX2ludkkgPiAwLjBmKi8pO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBDb21wdXRlIHRoZSBlZmZlY3RpdmUgbWFzcyBtYXRyaXguXHJcbiAgICAgICAgICAgIFRyYW5zZm9ybSB4ZjE7XHJcbiAgICAgICAgICAgIGIxLkdldFRyYW5zZm9ybShvdXQgeGYxKTtcclxuXHJcbiAgICAgICAgICAgIFZlY3RvcjIgcjEgPSBNYXRoVXRpbHMuTXVsdGlwbHkocmVmIHhmMS5SLCBMb2NhbEFuY2hvckEgLSBiMS5Mb2NhbENlbnRlcik7XHJcbiAgICAgICAgICAgIFZlY3RvcjIgcjIgPSBfd29ybGRBbmNob3I7IC8vIE1hdGhVdGlscy5NdWx0aXBseShyZWYgeGYyLlIsIExvY2FsQW5jaG9yQiAtIGIyLkxvY2FsQ2VudGVyKTtcclxuXHJcbiAgICAgICAgICAgIC8vIEogPSBbLUkgLXIxX3NrZXcgSSByMl9za2V3XVxyXG4gICAgICAgICAgICAvLyAgICAgWyAwICAgICAgIC0xIDAgICAgICAgMV1cclxuICAgICAgICAgICAgLy8gcl9za2V3ID0gWy1yeTsgcnhdXHJcblxyXG4gICAgICAgICAgICAvLyBNYXRsYWJcclxuICAgICAgICAgICAgLy8gSyA9IFsgbTErcjF5XjIqaTErbTIrcjJ5XjIqaTIsICAtcjF5KmkxKnIxeC1yMnkqaTIqcjJ4LCAgICAgICAgICAtcjF5KmkxLXIyeSppMl1cclxuICAgICAgICAgICAgLy8gICAgIFsgIC1yMXkqaTEqcjF4LXIyeSppMipyMngsIG0xK3IxeF4yKmkxK20yK3IyeF4yKmkyLCAgICAgICAgICAgcjF4KmkxK3IyeCppMl1cclxuICAgICAgICAgICAgLy8gICAgIFsgICAgICAgICAgLXIxeSppMS1yMnkqaTIsICAgICAgICAgICByMXgqaTErcjJ4KmkyLCAgICAgICAgICAgICAgICAgICBpMStpMl1cclxuXHJcbiAgICAgICAgICAgIGZsb2F0IG0xID0gYjEuSW52TWFzcztcclxuICAgICAgICAgICAgY29uc3QgZmxvYXQgbTIgPSAwO1xyXG4gICAgICAgICAgICBmbG9hdCBpMSA9IGIxLkludkk7XHJcbiAgICAgICAgICAgIGNvbnN0IGZsb2F0IGkyID0gMDtcclxuXHJcbiAgICAgICAgICAgIF9tYXNzLkNvbDEuWCA9IG0xICsgbTIgKyByMS5ZICogcjEuWSAqIGkxICsgcjIuWSAqIHIyLlkgKiBpMjtcclxuICAgICAgICAgICAgX21hc3MuQ29sMi5YID0gLXIxLlkgKiByMS5YICogaTEgLSByMi5ZICogcjIuWCAqIGkyO1xyXG4gICAgICAgICAgICBfbWFzcy5Db2wzLlggPSAtcjEuWSAqIGkxIC0gcjIuWSAqIGkyO1xyXG4gICAgICAgICAgICBfbWFzcy5Db2wxLlkgPSBfbWFzcy5Db2wyLlg7XHJcbiAgICAgICAgICAgIF9tYXNzLkNvbDIuWSA9IG0xICsgbTIgKyByMS5YICogcjEuWCAqIGkxICsgcjIuWCAqIHIyLlggKiBpMjtcclxuICAgICAgICAgICAgX21hc3MuQ29sMy5ZID0gcjEuWCAqIGkxICsgcjIuWCAqIGkyO1xyXG4gICAgICAgICAgICBfbWFzcy5Db2wxLlogPSBfbWFzcy5Db2wzLlg7XHJcbiAgICAgICAgICAgIF9tYXNzLkNvbDIuWiA9IF9tYXNzLkNvbDMuWTtcclxuICAgICAgICAgICAgX21hc3MuQ29sMy5aID0gaTEgKyBpMjtcclxuXHJcbiAgICAgICAgICAgIF9tb3Rvck1hc3MgPSBpMSArIGkyO1xyXG4gICAgICAgICAgICBpZiAoX21vdG9yTWFzcyA+IDAuMGYpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIF9tb3Rvck1hc3MgPSAxLjBmIC8gX21vdG9yTWFzcztcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKF9lbmFibGVNb3RvciA9PSBmYWxzZSlcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgX21vdG9ySW1wdWxzZSA9IDAuMGY7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmIChfZW5hYmxlTGltaXQpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGZsb2F0IGpvaW50QW5nbGUgPSAwIC0gYjEuU3dlZXAuQSAtIFJlZmVyZW5jZUFuZ2xlO1xyXG4gICAgICAgICAgICAgICAgaWYgKE1hdGguQWJzKF91cHBlckFuZ2xlIC0gX2xvd2VyQW5nbGUpIDwgMi4wZiAqIFNldHRpbmdzLkFuZ3VsYXJTbG9wKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIF9saW1pdFN0YXRlID0gTGltaXRTdGF0ZS5FcXVhbDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGpvaW50QW5nbGUgPD0gX2xvd2VyQW5nbGUpXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKF9saW1pdFN0YXRlICE9IExpbWl0U3RhdGUuQXRMb3dlcilcclxuICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF9pbXB1bHNlLlogPSAwLjBmO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBfbGltaXRTdGF0ZSA9IExpbWl0U3RhdGUuQXRMb3dlcjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGpvaW50QW5nbGUgPj0gX3VwcGVyQW5nbGUpXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKF9saW1pdFN0YXRlICE9IExpbWl0U3RhdGUuQXRVcHBlcilcclxuICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF9pbXB1bHNlLlogPSAwLjBmO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBfbGltaXRTdGF0ZSA9IExpbWl0U3RhdGUuQXRVcHBlcjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBfbGltaXRTdGF0ZSA9IExpbWl0U3RhdGUuSW5hY3RpdmU7XHJcbiAgICAgICAgICAgICAgICAgICAgX2ltcHVsc2UuWiA9IDAuMGY7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBfbGltaXRTdGF0ZSA9IExpbWl0U3RhdGUuSW5hY3RpdmU7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmIChTZXR0aW5ncy5FbmFibGVXYXJtc3RhcnRpbmcpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIC8vIFNjYWxlIGltcHVsc2VzIHRvIHN1cHBvcnQgYSB2YXJpYWJsZSB0aW1lIHN0ZXAuXHJcbiAgICAgICAgICAgICAgICBfaW1wdWxzZSAqPSBzdGVwLmR0UmF0aW87XHJcbiAgICAgICAgICAgICAgICBfbW90b3JJbXB1bHNlICo9IHN0ZXAuZHRSYXRpbztcclxuXHJcbiAgICAgICAgICAgICAgICBWZWN0b3IyIFAgPSBuZXcgVmVjdG9yMihfaW1wdWxzZS5YLCBfaW1wdWxzZS5ZKTtcclxuXHJcbiAgICAgICAgICAgICAgICBiMS5MaW5lYXJWZWxvY2l0eUludGVybmFsIC09IG0xICogUDtcclxuICAgICAgICAgICAgICAgIGIxLkFuZ3VsYXJWZWxvY2l0eUludGVybmFsIC09IGkxICogKE1hdGhVdGlscy5Dcm9zcyhyMSwgUCkgKyBfbW90b3JJbXB1bHNlICsgX2ltcHVsc2UuWik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBfaW1wdWxzZSA9IFZlY3RvcjMuWmVybztcclxuICAgICAgICAgICAgICAgIF9tb3RvckltcHVsc2UgPSAwLjBmO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpbnRlcm5hbCBvdmVycmlkZSB2b2lkIFNvbHZlVmVsb2NpdHlDb25zdHJhaW50cyhyZWYgVGltZVN0ZXAgc3RlcClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIEJvZHkgYjEgPSBCb2R5QTtcclxuXHJcbiAgICAgICAgICAgIFZlY3RvcjIgdjEgPSBiMS5MaW5lYXJWZWxvY2l0eUludGVybmFsO1xyXG4gICAgICAgICAgICBmbG9hdCB3MSA9IGIxLkFuZ3VsYXJWZWxvY2l0eUludGVybmFsO1xyXG4gICAgICAgICAgICBWZWN0b3IyIHYyID0gVmVjdG9yMi5aZXJvO1xyXG4gICAgICAgICAgICBjb25zdCBmbG9hdCB3MiA9IDA7XHJcblxyXG4gICAgICAgICAgICBmbG9hdCBtMSA9IGIxLkludk1hc3M7XHJcbiAgICAgICAgICAgIGZsb2F0IGkxID0gYjEuSW52STtcclxuXHJcbiAgICAgICAgICAgIC8vIFNvbHZlIG1vdG9yIGNvbnN0cmFpbnQuXHJcbiAgICAgICAgICAgIGlmIChfZW5hYmxlTW90b3IgJiYgX2xpbWl0U3RhdGUgIT0gTGltaXRTdGF0ZS5FcXVhbClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgZmxvYXQgQ2RvdCA9IHcyIC0gdzEgLSBfbW90b3JTcGVlZDtcclxuICAgICAgICAgICAgICAgIGZsb2F0IGltcHVsc2UgPSBfbW90b3JNYXNzICogKC1DZG90KTtcclxuICAgICAgICAgICAgICAgIGZsb2F0IG9sZEltcHVsc2UgPSBfbW90b3JJbXB1bHNlO1xyXG4gICAgICAgICAgICAgICAgZmxvYXQgbWF4SW1wdWxzZSA9IHN0ZXAuZHQgKiBfbWF4TW90b3JUb3JxdWU7XHJcbiAgICAgICAgICAgICAgICBfbW90b3JJbXB1bHNlID0gTWF0aFV0aWxzLkNsYW1wKF9tb3RvckltcHVsc2UgKyBpbXB1bHNlLCAtbWF4SW1wdWxzZSwgbWF4SW1wdWxzZSk7XHJcbiAgICAgICAgICAgICAgICBpbXB1bHNlID0gX21vdG9ySW1wdWxzZSAtIG9sZEltcHVsc2U7XHJcblxyXG4gICAgICAgICAgICAgICAgdzEgLT0gaTEgKiBpbXB1bHNlO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBTb2x2ZSBsaW1pdCBjb25zdHJhaW50LlxyXG4gICAgICAgICAgICBpZiAoX2VuYWJsZUxpbWl0ICYmIF9saW1pdFN0YXRlICE9IExpbWl0U3RhdGUuSW5hY3RpdmUpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIFRyYW5zZm9ybSB4ZjE7XHJcbiAgICAgICAgICAgICAgICBiMS5HZXRUcmFuc2Zvcm0ob3V0IHhmMSk7XHJcblxyXG4gICAgICAgICAgICAgICAgVmVjdG9yMiByMSA9IE1hdGhVdGlscy5NdWx0aXBseShyZWYgeGYxLlIsIExvY2FsQW5jaG9yQSAtIGIxLkxvY2FsQ2VudGVyKTtcclxuICAgICAgICAgICAgICAgIFZlY3RvcjIgcjIgPSBfd29ybGRBbmNob3I7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gU29sdmUgcG9pbnQtdG8tcG9pbnQgY29uc3RyYWludFxyXG4gICAgICAgICAgICAgICAgVmVjdG9yMiBDZG90MSA9IHYyICsgTWF0aFV0aWxzLkNyb3NzKHcyLCByMikgLSB2MSAtIE1hdGhVdGlscy5Dcm9zcyh3MSwgcjEpO1xyXG4gICAgICAgICAgICAgICAgZmxvYXQgQ2RvdDIgPSB3MiAtIHcxO1xyXG4gICAgICAgICAgICAgICAgVmVjdG9yMyBDZG90ID0gbmV3IFZlY3RvcjMoQ2RvdDEuWCwgQ2RvdDEuWSwgQ2RvdDIpO1xyXG5cclxuICAgICAgICAgICAgICAgIFZlY3RvcjMgaW1wdWxzZSA9IF9tYXNzLlNvbHZlMzMoLUNkb3QpO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmIChfbGltaXRTdGF0ZSA9PSBMaW1pdFN0YXRlLkVxdWFsKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIF9pbXB1bHNlICs9IGltcHVsc2U7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChfbGltaXRTdGF0ZSA9PSBMaW1pdFN0YXRlLkF0TG93ZXIpXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgZmxvYXQgbmV3SW1wdWxzZSA9IF9pbXB1bHNlLlogKyBpbXB1bHNlLlo7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5ld0ltcHVsc2UgPCAwLjBmKVxyXG4gICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgVmVjdG9yMiByZWR1Y2VkID0gX21hc3MuU29sdmUyMigtQ2RvdDEpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpbXB1bHNlLlggPSByZWR1Y2VkLlg7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGltcHVsc2UuWSA9IHJlZHVjZWQuWTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaW1wdWxzZS5aID0gLV9pbXB1bHNlLlo7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF9pbXB1bHNlLlggKz0gcmVkdWNlZC5YO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBfaW1wdWxzZS5ZICs9IHJlZHVjZWQuWTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgX2ltcHVsc2UuWiA9IDAuMGY7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoX2xpbWl0U3RhdGUgPT0gTGltaXRTdGF0ZS5BdFVwcGVyKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIGZsb2F0IG5ld0ltcHVsc2UgPSBfaW1wdWxzZS5aICsgaW1wdWxzZS5aO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChuZXdJbXB1bHNlID4gMC4wZilcclxuICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIFZlY3RvcjIgcmVkdWNlZCA9IF9tYXNzLlNvbHZlMjIoLUNkb3QxKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaW1wdWxzZS5YID0gcmVkdWNlZC5YO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpbXB1bHNlLlkgPSByZWR1Y2VkLlk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGltcHVsc2UuWiA9IC1faW1wdWxzZS5aO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBfaW1wdWxzZS5YICs9IHJlZHVjZWQuWDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgX2ltcHVsc2UuWSArPSByZWR1Y2VkLlk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF9pbXB1bHNlLlogPSAwLjBmO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBWZWN0b3IyIFAgPSBuZXcgVmVjdG9yMihpbXB1bHNlLlgsIGltcHVsc2UuWSk7XHJcblxyXG4gICAgICAgICAgICAgICAgdjEgLT0gbTEgKiBQO1xyXG4gICAgICAgICAgICAgICAgdzEgLT0gaTEgKiAoTWF0aFV0aWxzLkNyb3NzKHIxLCBQKSArIGltcHVsc2UuWik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBUcmFuc2Zvcm0geGYxO1xyXG4gICAgICAgICAgICAgICAgYjEuR2V0VHJhbnNmb3JtKG91dCB4ZjEpO1xyXG5cclxuICAgICAgICAgICAgICAgIFZlY3RvcjIgcjEgPSBNYXRoVXRpbHMuTXVsdGlwbHkocmVmIHhmMS5SLCBMb2NhbEFuY2hvckEgLSBiMS5Mb2NhbENlbnRlcik7XHJcbiAgICAgICAgICAgICAgICBWZWN0b3IyIHIyID0gX3dvcmxkQW5jaG9yO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIFNvbHZlIHBvaW50LXRvLXBvaW50IGNvbnN0cmFpbnRcclxuICAgICAgICAgICAgICAgIFZlY3RvcjIgQ2RvdCA9IHYyICsgTWF0aFV0aWxzLkNyb3NzKHcyLCByMikgLSB2MSAtIE1hdGhVdGlscy5Dcm9zcyh3MSwgcjEpO1xyXG4gICAgICAgICAgICAgICAgVmVjdG9yMiBpbXB1bHNlID0gX21hc3MuU29sdmUyMigtQ2RvdCk7XHJcblxyXG4gICAgICAgICAgICAgICAgX2ltcHVsc2UuWCArPSBpbXB1bHNlLlg7XHJcbiAgICAgICAgICAgICAgICBfaW1wdWxzZS5ZICs9IGltcHVsc2UuWTtcclxuXHJcbiAgICAgICAgICAgICAgICB2MSAtPSBtMSAqIGltcHVsc2U7XHJcbiAgICAgICAgICAgICAgICB3MSAtPSBpMSAqIE1hdGhVdGlscy5Dcm9zcyhyMSwgaW1wdWxzZSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGIxLkxpbmVhclZlbG9jaXR5SW50ZXJuYWwgPSB2MTtcclxuICAgICAgICAgICAgYjEuQW5ndWxhclZlbG9jaXR5SW50ZXJuYWwgPSB3MTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGludGVybmFsIG92ZXJyaWRlIGJvb2wgU29sdmVQb3NpdGlvbkNvbnN0cmFpbnRzKClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIC8vIFRPRE9fRVJJTiBibG9jayBzb2x2ZSB3aXRoIGxpbWl0LiBDT01FIE9OIEVSSU5cclxuXHJcbiAgICAgICAgICAgIEJvZHkgYjEgPSBCb2R5QTtcclxuXHJcbiAgICAgICAgICAgIGZsb2F0IGFuZ3VsYXJFcnJvciA9IDAuMGY7XHJcbiAgICAgICAgICAgIGZsb2F0IHBvc2l0aW9uRXJyb3I7XHJcblxyXG4gICAgICAgICAgICAvLyBTb2x2ZSBhbmd1bGFyIGxpbWl0IGNvbnN0cmFpbnQuXHJcbiAgICAgICAgICAgIGlmIChfZW5hYmxlTGltaXQgJiYgX2xpbWl0U3RhdGUgIT0gTGltaXRTdGF0ZS5JbmFjdGl2ZSlcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgZmxvYXQgYW5nbGUgPSAwIC0gYjEuU3dlZXAuQSAtIFJlZmVyZW5jZUFuZ2xlO1xyXG4gICAgICAgICAgICAgICAgZmxvYXQgbGltaXRJbXB1bHNlID0gMC4wZjtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoX2xpbWl0U3RhdGUgPT0gTGltaXRTdGF0ZS5FcXVhbClcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBQcmV2ZW50IGxhcmdlIGFuZ3VsYXIgY29ycmVjdGlvbnNcclxuICAgICAgICAgICAgICAgICAgICBmbG9hdCBDID0gTWF0aFV0aWxzLkNsYW1wKGFuZ2xlIC0gX2xvd2VyQW5nbGUsIC1TZXR0aW5ncy5NYXhBbmd1bGFyQ29ycmVjdGlvbixcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFNldHRpbmdzLk1heEFuZ3VsYXJDb3JyZWN0aW9uKTtcclxuICAgICAgICAgICAgICAgICAgICBsaW1pdEltcHVsc2UgPSAtX21vdG9yTWFzcyAqIEM7XHJcbiAgICAgICAgICAgICAgICAgICAgYW5ndWxhckVycm9yID0gKGZsb2F0KU1hdGguQWJzKEMpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoX2xpbWl0U3RhdGUgPT0gTGltaXRTdGF0ZS5BdExvd2VyKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIGZsb2F0IEMgPSBhbmdsZSAtIF9sb3dlckFuZ2xlO1xyXG4gICAgICAgICAgICAgICAgICAgIGFuZ3VsYXJFcnJvciA9IC1DO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBQcmV2ZW50IGxhcmdlIGFuZ3VsYXIgY29ycmVjdGlvbnMgYW5kIGFsbG93IHNvbWUgc2xvcC5cclxuICAgICAgICAgICAgICAgICAgICBDID0gTWF0aFV0aWxzLkNsYW1wKEMgKyBTZXR0aW5ncy5Bbmd1bGFyU2xvcCwgLVNldHRpbmdzLk1heEFuZ3VsYXJDb3JyZWN0aW9uLCAwLjBmKTtcclxuICAgICAgICAgICAgICAgICAgICBsaW1pdEltcHVsc2UgPSAtX21vdG9yTWFzcyAqIEM7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChfbGltaXRTdGF0ZSA9PSBMaW1pdFN0YXRlLkF0VXBwZXIpXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgZmxvYXQgQyA9IGFuZ2xlIC0gX3VwcGVyQW5nbGU7XHJcbiAgICAgICAgICAgICAgICAgICAgYW5ndWxhckVycm9yID0gQztcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gUHJldmVudCBsYXJnZSBhbmd1bGFyIGNvcnJlY3Rpb25zIGFuZCBhbGxvdyBzb21lIHNsb3AuXHJcbiAgICAgICAgICAgICAgICAgICAgQyA9IE1hdGhVdGlscy5DbGFtcChDIC0gU2V0dGluZ3MuQW5ndWxhclNsb3AsIDAuMGYsIFNldHRpbmdzLk1heEFuZ3VsYXJDb3JyZWN0aW9uKTtcclxuICAgICAgICAgICAgICAgICAgICBsaW1pdEltcHVsc2UgPSAtX21vdG9yTWFzcyAqIEM7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgYjEuU3dlZXAuQSAtPSBiMS5JbnZJICogbGltaXRJbXB1bHNlO1xyXG5cclxuICAgICAgICAgICAgICAgIGIxLlN5bmNocm9uaXplVHJhbnNmb3JtKCk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIFNvbHZlIHBvaW50LXRvLXBvaW50IGNvbnN0cmFpbnQuXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIFRyYW5zZm9ybSB4ZjE7XHJcbiAgICAgICAgICAgICAgICBiMS5HZXRUcmFuc2Zvcm0ob3V0IHhmMSk7XHJcblxyXG4gICAgICAgICAgICAgICAgVmVjdG9yMiByMSA9IE1hdGhVdGlscy5NdWx0aXBseShyZWYgeGYxLlIsIExvY2FsQW5jaG9yQSAtIGIxLkxvY2FsQ2VudGVyKTtcclxuICAgICAgICAgICAgICAgIFZlY3RvcjIgcjIgPSBfd29ybGRBbmNob3I7XHJcblxyXG4gICAgICAgICAgICAgICAgVmVjdG9yMiBDID0gVmVjdG9yMi5aZXJvICsgcjIgLSBiMS5Td2VlcC5DIC0gcjE7XHJcbiAgICAgICAgICAgICAgICBwb3NpdGlvbkVycm9yID0gQy5MZW5ndGgoKTtcclxuXHJcbiAgICAgICAgICAgICAgICBmbG9hdCBpbnZNYXNzMSA9IGIxLkludk1hc3M7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBmbG9hdCBpbnZNYXNzMiA9IDA7XHJcbiAgICAgICAgICAgICAgICBmbG9hdCBpbnZJMSA9IGIxLkludkk7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBmbG9hdCBpbnZJMiA9IDA7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gSGFuZGxlIGxhcmdlIGRldGFjaG1lbnQuXHJcbiAgICAgICAgICAgICAgICBjb25zdCBmbG9hdCBrX2FsbG93ZWRTdHJldGNoID0gMTAuMGYgKiBTZXR0aW5ncy5MaW5lYXJTbG9wO1xyXG4gICAgICAgICAgICAgICAgaWYgKEMuTGVuZ3RoU3F1YXJlZCgpID4ga19hbGxvd2VkU3RyZXRjaCAqIGtfYWxsb3dlZFN0cmV0Y2gpXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gVXNlIGEgcGFydGljbGUgc29sdXRpb24gKG5vIHJvdGF0aW9uKS5cclxuICAgICAgICAgICAgICAgICAgICBWZWN0b3IyIHUgPSBDO1xyXG4gICAgICAgICAgICAgICAgICAgIHUuTm9ybWFsaXplKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgZmxvYXQgayA9IGludk1hc3MxICsgaW52TWFzczI7XHJcbiAgICAgICAgICAgICAgICAgICAgRGVidWcuQXNzZXJ0KGsgPiBTZXR0aW5ncy5FcHNpbG9uKTtcclxuICAgICAgICAgICAgICAgICAgICBmbG9hdCBtID0gMS4wZiAvIGs7XHJcbiAgICAgICAgICAgICAgICAgICAgVmVjdG9yMiBpbXB1bHNlMiA9IG0gKiAoLUMpO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGZsb2F0IGtfYmV0YSA9IDAuNWY7XHJcbiAgICAgICAgICAgICAgICAgICAgYjEuU3dlZXAuQyAtPSBrX2JldGEgKiBpbnZNYXNzMSAqIGltcHVsc2UyO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBDID0gVmVjdG9yMi5aZXJvICsgcjIgLSBiMS5Td2VlcC5DIC0gcjE7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgTWF0MjIgSzEgPSBuZXcgTWF0MjIobmV3IFZlY3RvcjIoaW52TWFzczEgKyBpbnZNYXNzMiwgMC4wZiksIG5ldyBWZWN0b3IyKDAuMGYsIGludk1hc3MxICsgaW52TWFzczIpKTtcclxuICAgICAgICAgICAgICAgIE1hdDIyIEsyID0gbmV3IE1hdDIyKG5ldyBWZWN0b3IyKGludkkxICogcjEuWSAqIHIxLlksIC1pbnZJMSAqIHIxLlggKiByMS5ZKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ldyBWZWN0b3IyKC1pbnZJMSAqIHIxLlggKiByMS5ZLCBpbnZJMSAqIHIxLlggKiByMS5YKSk7XHJcbiAgICAgICAgICAgICAgICBNYXQyMiBLMyA9IG5ldyBNYXQyMihuZXcgVmVjdG9yMihpbnZJMiAqIHIyLlkgKiByMi5ZLCAtaW52STIgKiByMi5YICogcjIuWSksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXcgVmVjdG9yMigtaW52STIgKiByMi5YICogcjIuWSwgaW52STIgKiByMi5YICogcjIuWCkpO1xyXG5cclxuICAgICAgICAgICAgICAgIE1hdDIyIEthO1xyXG4gICAgICAgICAgICAgICAgTWF0MjIuQWRkKHJlZiBLMSwgcmVmIEsyLCBvdXQgS2EpO1xyXG5cclxuICAgICAgICAgICAgICAgIE1hdDIyIEs7XHJcbiAgICAgICAgICAgICAgICBNYXQyMi5BZGQocmVmIEthLCByZWYgSzMsIG91dCBLKTtcclxuXHJcbiAgICAgICAgICAgICAgICBWZWN0b3IyIGltcHVsc2UgPSBLLlNvbHZlKC1DKTtcclxuXHJcbiAgICAgICAgICAgICAgICBiMS5Td2VlcC5DIC09IGIxLkludk1hc3MgKiBpbXB1bHNlO1xyXG4gICAgICAgICAgICAgICAgYjEuU3dlZXAuQSAtPSBiMS5JbnZJICogTWF0aFV0aWxzLkNyb3NzKHIxLCBpbXB1bHNlKTtcclxuXHJcbiAgICAgICAgICAgICAgICBiMS5TeW5jaHJvbml6ZVRyYW5zZm9ybSgpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gcG9zaXRpb25FcnJvciA8PSBTZXR0aW5ncy5MaW5lYXJTbG9wICYmIGFuZ3VsYXJFcnJvciA8PSBTZXR0aW5ncy5Bbmd1bGFyU2xvcDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn0iLCIvKlxyXG4qIEZhcnNlZXIgUGh5c2ljcyBFbmdpbmUgYmFzZWQgb24gQm94MkQuWE5BIHBvcnQ6XHJcbiogQ29weXJpZ2h0IChjKSAyMDEwIElhbiBRdmlzdFxyXG4qIFxyXG4qIEJveDJELlhOQSBwb3J0IG9mIEJveDJEOlxyXG4qIENvcHlyaWdodCAoYykgMjAwOSBCcmFuZG9uIEZ1cnR3YW5nbGVyLCBOYXRoYW4gRnVydHdhbmdsZXJcclxuKlxyXG4qIE9yaWdpbmFsIHNvdXJjZSBCb3gyRDpcclxuKiBDb3B5cmlnaHQgKGMpIDIwMDYtMjAwOSBFcmluIENhdHRvIGh0dHA6Ly93d3cuZ3BoeXNpY3MuY29tIFxyXG4qIFxyXG4qIFRoaXMgc29mdHdhcmUgaXMgcHJvdmlkZWQgJ2FzLWlzJywgd2l0aG91dCBhbnkgZXhwcmVzcyBvciBpbXBsaWVkIFxyXG4qIHdhcnJhbnR5LiAgSW4gbm8gZXZlbnQgd2lsbCB0aGUgYXV0aG9ycyBiZSBoZWxkIGxpYWJsZSBmb3IgYW55IGRhbWFnZXMgXHJcbiogYXJpc2luZyBmcm9tIHRoZSB1c2Ugb2YgdGhpcyBzb2Z0d2FyZS4gXHJcbiogUGVybWlzc2lvbiBpcyBncmFudGVkIHRvIGFueW9uZSB0byB1c2UgdGhpcyBzb2Z0d2FyZSBmb3IgYW55IHB1cnBvc2UsIFxyXG4qIGluY2x1ZGluZyBjb21tZXJjaWFsIGFwcGxpY2F0aW9ucywgYW5kIHRvIGFsdGVyIGl0IGFuZCByZWRpc3RyaWJ1dGUgaXQgXHJcbiogZnJlZWx5LCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgcmVzdHJpY3Rpb25zOiBcclxuKiAxLiBUaGUgb3JpZ2luIG9mIHRoaXMgc29mdHdhcmUgbXVzdCBub3QgYmUgbWlzcmVwcmVzZW50ZWQ7IHlvdSBtdXN0IG5vdCBcclxuKiBjbGFpbSB0aGF0IHlvdSB3cm90ZSB0aGUgb3JpZ2luYWwgc29mdHdhcmUuIElmIHlvdSB1c2UgdGhpcyBzb2Z0d2FyZSBcclxuKiBpbiBhIHByb2R1Y3QsIGFuIGFja25vd2xlZGdtZW50IGluIHRoZSBwcm9kdWN0IGRvY3VtZW50YXRpb24gd291bGQgYmUgXHJcbiogYXBwcmVjaWF0ZWQgYnV0IGlzIG5vdCByZXF1aXJlZC4gXHJcbiogMi4gQWx0ZXJlZCBzb3VyY2UgdmVyc2lvbnMgbXVzdCBiZSBwbGFpbmx5IG1hcmtlZCBhcyBzdWNoLCBhbmQgbXVzdCBub3QgYmUgXHJcbiogbWlzcmVwcmVzZW50ZWQgYXMgYmVpbmcgdGhlIG9yaWdpbmFsIHNvZnR3YXJlLiBcclxuKiAzLiBUaGlzIG5vdGljZSBtYXkgbm90IGJlIHJlbW92ZWQgb3IgYWx0ZXJlZCBmcm9tIGFueSBzb3VyY2UgZGlzdHJpYnV0aW9uLiBcclxuKi9cclxuXHJcbnVzaW5nIFN5c3RlbS5EaWFnbm9zdGljcztcclxudXNpbmcgRmFyc2VlclBoeXNpY3MuQ29tbW9uO1xyXG51c2luZyBNaWNyb3NvZnQuWG5hLkZyYW1ld29yaztcclxuXHJcbm5hbWVzcGFjZSBGYXJzZWVyUGh5c2ljcy5EeW5hbWljcy5Kb2ludHNcclxue1xyXG4gICAgLy8gUG9pbnQtdG8tcG9pbnQgY29uc3RyYWludFxyXG4gICAgLy8gQ2RvdCA9IHYyIC0gdjFcclxuICAgIC8vICAgICAgPSB2MiArIGNyb3NzKHcyLCByMikgLSB2MSAtIGNyb3NzKHcxLCByMSlcclxuICAgIC8vIEogPSBbLUkgLXIxX3NrZXcgSSByMl9za2V3IF1cclxuICAgIC8vIElkZW50aXR5IHVzZWQ6XHJcbiAgICAvLyB3IGsgJSAocnggaSArIHJ5IGopID0gdyAqICgtcnkgaSArIHJ4IGopXHJcblxyXG4gICAgLy8gQW5nbGUgY29uc3RyYWludFxyXG4gICAgLy8gQ2RvdCA9IHcyIC0gdzFcclxuICAgIC8vIEogPSBbMCAwIC0xIDAgMCAxXVxyXG4gICAgLy8gSyA9IGludkkxICsgaW52STJcclxuXHJcbiAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAvLy8gRnJpY3Rpb24gam9pbnQuIFRoaXMgaXMgdXNlZCBmb3IgdG9wLWRvd24gZnJpY3Rpb24uXHJcbiAgICAvLy8gSXQgcHJvdmlkZXMgMkQgdHJhbnNsYXRpb25hbCBmcmljdGlvbiBhbmQgYW5ndWxhciBmcmljdGlvbi5cclxuICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICBwdWJsaWMgY2xhc3MgRnJpY3Rpb25Kb2ludCA6IEpvaW50XHJcbiAgICB7XHJcbiAgICAgICAgcHVibGljIFZlY3RvcjIgTG9jYWxBbmNob3JBO1xyXG4gICAgICAgIHB1YmxpYyBWZWN0b3IyIExvY2FsQW5jaG9yQjtcclxuICAgICAgICBwcml2YXRlIGZsb2F0IF9hbmd1bGFySW1wdWxzZTtcclxuICAgICAgICBwcml2YXRlIGZsb2F0IF9hbmd1bGFyTWFzcztcclxuICAgICAgICBwcml2YXRlIFZlY3RvcjIgX2xpbmVhckltcHVsc2U7XHJcbiAgICAgICAgcHJpdmF0ZSBNYXQyMiBfbGluZWFyTWFzcztcclxuXHJcbiAgICAgICAgaW50ZXJuYWwgRnJpY3Rpb25Kb2ludCgpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBKb2ludFR5cGUgPSBKb2ludFR5cGUuRnJpY3Rpb247XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwdWJsaWMgRnJpY3Rpb25Kb2ludChCb2R5IGJvZHlBLCBCb2R5IGJvZHlCLCBWZWN0b3IyIGxvY2FsQW5jaG9yQSwgVmVjdG9yMiBsb2NhbEFuY2hvckIpXHJcbiAgICAgICAgICAgIDogYmFzZShib2R5QSwgYm9keUIpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBKb2ludFR5cGUgPSBKb2ludFR5cGUuRnJpY3Rpb247XHJcbiAgICAgICAgICAgIExvY2FsQW5jaG9yQSA9IGxvY2FsQW5jaG9yQTtcclxuICAgICAgICAgICAgTG9jYWxBbmNob3JCID0gbG9jYWxBbmNob3JCO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHVibGljIG92ZXJyaWRlIFZlY3RvcjIgV29ybGRBbmNob3JBXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBnZXQgeyByZXR1cm4gQm9keUEuR2V0V29ybGRQb2ludChMb2NhbEFuY2hvckEpOyB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwdWJsaWMgb3ZlcnJpZGUgVmVjdG9yMiBXb3JsZEFuY2hvckJcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGdldCB7IHJldHVybiBCb2R5Qi5HZXRXb3JsZFBvaW50KExvY2FsQW5jaG9yQik7IH1cclxuICAgICAgICAgICAgc2V0IHsgRGVidWcuQXNzZXJ0KGZhbHNlLCBcIllvdSBjYW4ndCBzZXQgdGhlIHdvcmxkIGFuY2hvciBvbiB0aGlzIGpvaW50IHR5cGUuXCIpOyB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIFRoZSBtYXhpbXVtIGZyaWN0aW9uIGZvcmNlIGluIE4uXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICBwdWJsaWMgZmxvYXQgTWF4Rm9yY2UgeyBnZXQ7IHNldDsgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIFRoZSBtYXhpbXVtIGZyaWN0aW9uIHRvcnF1ZSBpbiBOLW0uXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICBwdWJsaWMgZmxvYXQgTWF4VG9ycXVlIHsgZ2V0OyBzZXQ7IH1cclxuXHJcbiAgICAgICAgcHVibGljIG92ZXJyaWRlIFZlY3RvcjIgR2V0UmVhY3Rpb25Gb3JjZShmbG9hdCBpbnZfZHQpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gaW52X2R0ICogX2xpbmVhckltcHVsc2U7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwdWJsaWMgb3ZlcnJpZGUgZmxvYXQgR2V0UmVhY3Rpb25Ub3JxdWUoZmxvYXQgaW52X2R0KVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIGludl9kdCAqIF9hbmd1bGFySW1wdWxzZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGludGVybmFsIG92ZXJyaWRlIHZvaWQgSW5pdFZlbG9jaXR5Q29uc3RyYWludHMocmVmIFRpbWVTdGVwIHN0ZXApXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBCb2R5IGJBID0gQm9keUE7XHJcbiAgICAgICAgICAgIEJvZHkgYkIgPSBCb2R5QjtcclxuXHJcbiAgICAgICAgICAgIFRyYW5zZm9ybSB4ZkEsIHhmQjtcclxuICAgICAgICAgICAgYkEuR2V0VHJhbnNmb3JtKG91dCB4ZkEpO1xyXG4gICAgICAgICAgICBiQi5HZXRUcmFuc2Zvcm0ob3V0IHhmQik7XHJcblxyXG4gICAgICAgICAgICAvLyBDb21wdXRlIHRoZSBlZmZlY3RpdmUgbWFzcyBtYXRyaXguXHJcbiAgICAgICAgICAgIFZlY3RvcjIgckEgPSBNYXRoVXRpbHMuTXVsdGlwbHkocmVmIHhmQS5SLCBMb2NhbEFuY2hvckEgLSBiQS5Mb2NhbENlbnRlcik7XHJcbiAgICAgICAgICAgIFZlY3RvcjIgckIgPSBNYXRoVXRpbHMuTXVsdGlwbHkocmVmIHhmQi5SLCBMb2NhbEFuY2hvckIgLSBiQi5Mb2NhbENlbnRlcik7XHJcblxyXG4gICAgICAgICAgICAvLyBKID0gWy1JIC1yMV9za2V3IEkgcjJfc2tld11cclxuICAgICAgICAgICAgLy8gICAgIFsgMCAgICAgICAtMSAwICAgICAgIDFdXHJcbiAgICAgICAgICAgIC8vIHJfc2tldyA9IFstcnk7IHJ4XVxyXG5cclxuICAgICAgICAgICAgLy8gTWF0bGFiXHJcbiAgICAgICAgICAgIC8vIEsgPSBbIG1BK3IxeV4yKmlBK21CK3IyeV4yKmlCLCAgLXIxeSppQSpyMXgtcjJ5KmlCKnIyeCwgICAgICAgICAgLXIxeSppQS1yMnkqaUJdXHJcbiAgICAgICAgICAgIC8vICAgICBbICAtcjF5KmlBKnIxeC1yMnkqaUIqcjJ4LCBtQStyMXheMippQSttQityMnheMippQiwgICAgICAgICAgIHIxeCppQStyMngqaUJdXHJcbiAgICAgICAgICAgIC8vICAgICBbICAgICAgICAgIC1yMXkqaUEtcjJ5KmlCLCAgICAgICAgICAgcjF4KmlBK3IyeCppQiwgICAgICAgICAgICAgICAgICAgaUEraUJdXHJcblxyXG4gICAgICAgICAgICBmbG9hdCBtQSA9IGJBLkludk1hc3MsIG1CID0gYkIuSW52TWFzcztcclxuICAgICAgICAgICAgZmxvYXQgaUEgPSBiQS5JbnZJLCBpQiA9IGJCLkludkk7XHJcblxyXG4gICAgICAgICAgICBNYXQyMiBLMSA9IG5ldyBNYXQyMigpO1xyXG4gICAgICAgICAgICBLMS5Db2wxLlggPSBtQSArIG1CO1xyXG4gICAgICAgICAgICBLMS5Db2wyLlggPSAwLjBmO1xyXG4gICAgICAgICAgICBLMS5Db2wxLlkgPSAwLjBmO1xyXG4gICAgICAgICAgICBLMS5Db2wyLlkgPSBtQSArIG1CO1xyXG5cclxuICAgICAgICAgICAgTWF0MjIgSzIgPSBuZXcgTWF0MjIoKTtcclxuICAgICAgICAgICAgSzIuQ29sMS5YID0gaUEgKiByQS5ZICogckEuWTtcclxuICAgICAgICAgICAgSzIuQ29sMi5YID0gLWlBICogckEuWCAqIHJBLlk7XHJcbiAgICAgICAgICAgIEsyLkNvbDEuWSA9IC1pQSAqIHJBLlggKiByQS5ZO1xyXG4gICAgICAgICAgICBLMi5Db2wyLlkgPSBpQSAqIHJBLlggKiByQS5YO1xyXG5cclxuICAgICAgICAgICAgTWF0MjIgSzMgPSBuZXcgTWF0MjIoKTtcclxuICAgICAgICAgICAgSzMuQ29sMS5YID0gaUIgKiByQi5ZICogckIuWTtcclxuICAgICAgICAgICAgSzMuQ29sMi5YID0gLWlCICogckIuWCAqIHJCLlk7XHJcbiAgICAgICAgICAgIEszLkNvbDEuWSA9IC1pQiAqIHJCLlggKiByQi5ZO1xyXG4gICAgICAgICAgICBLMy5Db2wyLlkgPSBpQiAqIHJCLlggKiByQi5YO1xyXG5cclxuICAgICAgICAgICAgTWF0MjIgSzEyO1xyXG4gICAgICAgICAgICBNYXQyMi5BZGQocmVmIEsxLCByZWYgSzIsIG91dCBLMTIpO1xyXG5cclxuICAgICAgICAgICAgTWF0MjIgSztcclxuICAgICAgICAgICAgTWF0MjIuQWRkKHJlZiBLMTIsIHJlZiBLMywgb3V0IEspO1xyXG5cclxuICAgICAgICAgICAgX2xpbmVhck1hc3MgPSBLLkludmVyc2U7XHJcblxyXG4gICAgICAgICAgICBfYW5ndWxhck1hc3MgPSBpQSArIGlCO1xyXG4gICAgICAgICAgICBpZiAoX2FuZ3VsYXJNYXNzID4gMC4wZilcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgX2FuZ3VsYXJNYXNzID0gMS4wZiAvIF9hbmd1bGFyTWFzcztcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKFNldHRpbmdzLkVuYWJsZVdhcm1zdGFydGluZylcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgLy8gU2NhbGUgaW1wdWxzZXMgdG8gc3VwcG9ydCBhIHZhcmlhYmxlIHRpbWUgc3RlcC5cclxuICAgICAgICAgICAgICAgIF9saW5lYXJJbXB1bHNlICo9IHN0ZXAuZHRSYXRpbztcclxuICAgICAgICAgICAgICAgIF9hbmd1bGFySW1wdWxzZSAqPSBzdGVwLmR0UmF0aW87XHJcblxyXG4gICAgICAgICAgICAgICAgVmVjdG9yMiBQID0gbmV3IFZlY3RvcjIoX2xpbmVhckltcHVsc2UuWCwgX2xpbmVhckltcHVsc2UuWSk7XHJcblxyXG4gICAgICAgICAgICAgICAgYkEuTGluZWFyVmVsb2NpdHlJbnRlcm5hbCAtPSBtQSAqIFA7XHJcbiAgICAgICAgICAgICAgICBiQS5Bbmd1bGFyVmVsb2NpdHlJbnRlcm5hbCAtPSBpQSAqIChNYXRoVXRpbHMuQ3Jvc3MockEsIFApICsgX2FuZ3VsYXJJbXB1bHNlKTtcclxuXHJcbiAgICAgICAgICAgICAgICBiQi5MaW5lYXJWZWxvY2l0eUludGVybmFsICs9IG1CICogUDtcclxuICAgICAgICAgICAgICAgIGJCLkFuZ3VsYXJWZWxvY2l0eUludGVybmFsICs9IGlCICogKE1hdGhVdGlscy5Dcm9zcyhyQiwgUCkgKyBfYW5ndWxhckltcHVsc2UpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgX2xpbmVhckltcHVsc2UgPSBWZWN0b3IyLlplcm87XHJcbiAgICAgICAgICAgICAgICBfYW5ndWxhckltcHVsc2UgPSAwLjBmO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpbnRlcm5hbCBvdmVycmlkZSB2b2lkIFNvbHZlVmVsb2NpdHlDb25zdHJhaW50cyhyZWYgVGltZVN0ZXAgc3RlcClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIEJvZHkgYkEgPSBCb2R5QTtcclxuICAgICAgICAgICAgQm9keSBiQiA9IEJvZHlCO1xyXG5cclxuICAgICAgICAgICAgVmVjdG9yMiB2QSA9IGJBLkxpbmVhclZlbG9jaXR5SW50ZXJuYWw7XHJcbiAgICAgICAgICAgIGZsb2F0IHdBID0gYkEuQW5ndWxhclZlbG9jaXR5SW50ZXJuYWw7XHJcbiAgICAgICAgICAgIFZlY3RvcjIgdkIgPSBiQi5MaW5lYXJWZWxvY2l0eUludGVybmFsO1xyXG4gICAgICAgICAgICBmbG9hdCB3QiA9IGJCLkFuZ3VsYXJWZWxvY2l0eUludGVybmFsO1xyXG5cclxuICAgICAgICAgICAgZmxvYXQgbUEgPSBiQS5JbnZNYXNzLCBtQiA9IGJCLkludk1hc3M7XHJcbiAgICAgICAgICAgIGZsb2F0IGlBID0gYkEuSW52SSwgaUIgPSBiQi5JbnZJO1xyXG5cclxuICAgICAgICAgICAgVHJhbnNmb3JtIHhmQSwgeGZCO1xyXG4gICAgICAgICAgICBiQS5HZXRUcmFuc2Zvcm0ob3V0IHhmQSk7XHJcbiAgICAgICAgICAgIGJCLkdldFRyYW5zZm9ybShvdXQgeGZCKTtcclxuXHJcbiAgICAgICAgICAgIFZlY3RvcjIgckEgPSBNYXRoVXRpbHMuTXVsdGlwbHkocmVmIHhmQS5SLCBMb2NhbEFuY2hvckEgLSBiQS5Mb2NhbENlbnRlcik7XHJcbiAgICAgICAgICAgIFZlY3RvcjIgckIgPSBNYXRoVXRpbHMuTXVsdGlwbHkocmVmIHhmQi5SLCBMb2NhbEFuY2hvckIgLSBiQi5Mb2NhbENlbnRlcik7XHJcblxyXG4gICAgICAgICAgICAvLyBTb2x2ZSBhbmd1bGFyIGZyaWN0aW9uXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGZsb2F0IENkb3QgPSB3QiAtIHdBO1xyXG4gICAgICAgICAgICAgICAgZmxvYXQgaW1wdWxzZSA9IC1fYW5ndWxhck1hc3MgKiBDZG90O1xyXG5cclxuICAgICAgICAgICAgICAgIGZsb2F0IG9sZEltcHVsc2UgPSBfYW5ndWxhckltcHVsc2U7XHJcbiAgICAgICAgICAgICAgICBmbG9hdCBtYXhJbXB1bHNlID0gc3RlcC5kdCAqIE1heFRvcnF1ZTtcclxuICAgICAgICAgICAgICAgIF9hbmd1bGFySW1wdWxzZSA9IE1hdGhVdGlscy5DbGFtcChfYW5ndWxhckltcHVsc2UgKyBpbXB1bHNlLCAtbWF4SW1wdWxzZSwgbWF4SW1wdWxzZSk7XHJcbiAgICAgICAgICAgICAgICBpbXB1bHNlID0gX2FuZ3VsYXJJbXB1bHNlIC0gb2xkSW1wdWxzZTtcclxuXHJcbiAgICAgICAgICAgICAgICB3QSAtPSBpQSAqIGltcHVsc2U7XHJcbiAgICAgICAgICAgICAgICB3QiArPSBpQiAqIGltcHVsc2U7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIFNvbHZlIGxpbmVhciBmcmljdGlvblxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBWZWN0b3IyIENkb3QgPSB2QiArIE1hdGhVdGlscy5Dcm9zcyh3QiwgckIpIC0gdkEgLSBNYXRoVXRpbHMuQ3Jvc3Mod0EsIHJBKTtcclxuXHJcbiAgICAgICAgICAgICAgICBWZWN0b3IyIGltcHVsc2UgPSAtTWF0aFV0aWxzLk11bHRpcGx5KHJlZiBfbGluZWFyTWFzcywgQ2RvdCk7XHJcbiAgICAgICAgICAgICAgICBWZWN0b3IyIG9sZEltcHVsc2UgPSBfbGluZWFySW1wdWxzZTtcclxuICAgICAgICAgICAgICAgIF9saW5lYXJJbXB1bHNlICs9IGltcHVsc2U7XHJcblxyXG4gICAgICAgICAgICAgICAgZmxvYXQgbWF4SW1wdWxzZSA9IHN0ZXAuZHQgKiBNYXhGb3JjZTtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoX2xpbmVhckltcHVsc2UuTGVuZ3RoU3F1YXJlZCgpID4gbWF4SW1wdWxzZSAqIG1heEltcHVsc2UpXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgX2xpbmVhckltcHVsc2UuTm9ybWFsaXplKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgX2xpbmVhckltcHVsc2UgKj0gbWF4SW1wdWxzZTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBpbXB1bHNlID0gX2xpbmVhckltcHVsc2UgLSBvbGRJbXB1bHNlO1xyXG5cclxuICAgICAgICAgICAgICAgIHZBIC09IG1BICogaW1wdWxzZTtcclxuICAgICAgICAgICAgICAgIHdBIC09IGlBICogTWF0aFV0aWxzLkNyb3NzKHJBLCBpbXB1bHNlKTtcclxuXHJcbiAgICAgICAgICAgICAgICB2QiArPSBtQiAqIGltcHVsc2U7XHJcbiAgICAgICAgICAgICAgICB3QiArPSBpQiAqIE1hdGhVdGlscy5Dcm9zcyhyQiwgaW1wdWxzZSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGJBLkxpbmVhclZlbG9jaXR5SW50ZXJuYWwgPSB2QTtcclxuICAgICAgICAgICAgYkEuQW5ndWxhclZlbG9jaXR5SW50ZXJuYWwgPSB3QTtcclxuICAgICAgICAgICAgYkIuTGluZWFyVmVsb2NpdHlJbnRlcm5hbCA9IHZCO1xyXG4gICAgICAgICAgICBiQi5Bbmd1bGFyVmVsb2NpdHlJbnRlcm5hbCA9IHdCO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaW50ZXJuYWwgb3ZlcnJpZGUgYm9vbCBTb2x2ZVBvc2l0aW9uQ29uc3RyYWludHMoKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59IiwiLypcclxuKiBGYXJzZWVyIFBoeXNpY3MgRW5naW5lIGJhc2VkIG9uIEJveDJELlhOQSBwb3J0OlxyXG4qIENvcHlyaWdodCAoYykgMjAxMCBJYW4gUXZpc3RcclxuKiBcclxuKiBCb3gyRC5YTkEgcG9ydCBvZiBCb3gyRDpcclxuKiBDb3B5cmlnaHQgKGMpIDIwMDkgQnJhbmRvbiBGdXJ0d2FuZ2xlciwgTmF0aGFuIEZ1cnR3YW5nbGVyXHJcbipcclxuKiBPcmlnaW5hbCBzb3VyY2UgQm94MkQ6XHJcbiogQ29weXJpZ2h0IChjKSAyMDA2LTIwMDkgRXJpbiBDYXR0byBodHRwOi8vd3d3LmdwaHlzaWNzLmNvbSBcclxuKiBcclxuKiBUaGlzIHNvZnR3YXJlIGlzIHByb3ZpZGVkICdhcy1pcycsIHdpdGhvdXQgYW55IGV4cHJlc3Mgb3IgaW1wbGllZCBcclxuKiB3YXJyYW50eS4gIEluIG5vIGV2ZW50IHdpbGwgdGhlIGF1dGhvcnMgYmUgaGVsZCBsaWFibGUgZm9yIGFueSBkYW1hZ2VzIFxyXG4qIGFyaXNpbmcgZnJvbSB0aGUgdXNlIG9mIHRoaXMgc29mdHdhcmUuIFxyXG4qIFBlcm1pc3Npb24gaXMgZ3JhbnRlZCB0byBhbnlvbmUgdG8gdXNlIHRoaXMgc29mdHdhcmUgZm9yIGFueSBwdXJwb3NlLCBcclxuKiBpbmNsdWRpbmcgY29tbWVyY2lhbCBhcHBsaWNhdGlvbnMsIGFuZCB0byBhbHRlciBpdCBhbmQgcmVkaXN0cmlidXRlIGl0IFxyXG4qIGZyZWVseSwgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIHJlc3RyaWN0aW9uczogXHJcbiogMS4gVGhlIG9yaWdpbiBvZiB0aGlzIHNvZnR3YXJlIG11c3Qgbm90IGJlIG1pc3JlcHJlc2VudGVkOyB5b3UgbXVzdCBub3QgXHJcbiogY2xhaW0gdGhhdCB5b3Ugd3JvdGUgdGhlIG9yaWdpbmFsIHNvZnR3YXJlLiBJZiB5b3UgdXNlIHRoaXMgc29mdHdhcmUgXHJcbiogaW4gYSBwcm9kdWN0LCBhbiBhY2tub3dsZWRnbWVudCBpbiB0aGUgcHJvZHVjdCBkb2N1bWVudGF0aW9uIHdvdWxkIGJlIFxyXG4qIGFwcHJlY2lhdGVkIGJ1dCBpcyBub3QgcmVxdWlyZWQuIFxyXG4qIDIuIEFsdGVyZWQgc291cmNlIHZlcnNpb25zIG11c3QgYmUgcGxhaW5seSBtYXJrZWQgYXMgc3VjaCwgYW5kIG11c3Qgbm90IGJlIFxyXG4qIG1pc3JlcHJlc2VudGVkIGFzIGJlaW5nIHRoZSBvcmlnaW5hbCBzb2Z0d2FyZS4gXHJcbiogMy4gVGhpcyBub3RpY2UgbWF5IG5vdCBiZSByZW1vdmVkIG9yIGFsdGVyZWQgZnJvbSBhbnkgc291cmNlIGRpc3RyaWJ1dGlvbi4gXHJcbiovXHJcblxyXG51c2luZyBTeXN0ZW0uRGlhZ25vc3RpY3M7XHJcbnVzaW5nIEZhcnNlZXJQaHlzaWNzLkNvbW1vbjtcclxudXNpbmcgTWljcm9zb2Z0LlhuYS5GcmFtZXdvcms7XHJcblxyXG5uYW1lc3BhY2UgRmFyc2VlclBoeXNpY3MuRHluYW1pY3MuSm9pbnRzXHJcbntcclxuICAgIC8vLyA8c3VtbWFyeT5cclxuICAgIC8vLyBBIGdlYXIgam9pbnQgaXMgdXNlZCB0byBjb25uZWN0IHR3byBqb2ludHMgdG9nZXRoZXIuIEVpdGhlciBqb2ludFxyXG4gICAgLy8vIGNhbiBiZSBhIHJldm9sdXRlIG9yIHByaXNtYXRpYyBqb2ludC4gWW91IHNwZWNpZnkgYSBnZWFyIHJhdGlvXHJcbiAgICAvLy8gdG8gYmluZCB0aGUgbW90aW9ucyB0b2dldGhlcjpcclxuICAgIC8vLyBjb29yZGluYXRlMSArIHJhdGlvICogY29vcmRpbmF0ZTIgPSBhbnRcclxuICAgIC8vLyBUaGUgcmF0aW8gY2FuIGJlIG5lZ2F0aXZlIG9yIHBvc2l0aXZlLiBJZiBvbmUgam9pbnQgaXMgYSByZXZvbHV0ZSBqb2ludFxyXG4gICAgLy8vIGFuZCB0aGUgb3RoZXIgam9pbnQgaXMgYSBwcmlzbWF0aWMgam9pbnQsIHRoZW4gdGhlIHJhdGlvIHdpbGwgaGF2ZSB1bml0c1xyXG4gICAgLy8vIG9mIGxlbmd0aCBvciB1bml0cyBvZiAxL2xlbmd0aC5cclxuICAgIC8vLyBAd2FybmluZyBUaGUgcmV2b2x1dGUgYW5kIHByaXNtYXRpYyBqb2ludHMgbXVzdCBiZSBhdHRhY2hlZCB0b1xyXG4gICAgLy8vIGZpeGVkIGJvZGllcyAod2hpY2ggbXVzdCBiZSBib2R5MSBvbiB0aG9zZSBqb2ludHMpLlxyXG4gICAgLy8vIDwvc3VtbWFyeT5cclxuICAgIHB1YmxpYyBjbGFzcyBHZWFySm9pbnQgOiBKb2ludFxyXG4gICAge1xyXG4gICAgICAgIHByaXZhdGUgSmFjb2JpYW4gX0o7XHJcblxyXG4gICAgICAgIHByaXZhdGUgZmxvYXQgX2FudDtcclxuICAgICAgICBwcml2YXRlIEZpeGVkUHJpc21hdGljSm9pbnQgX2ZpeGVkUHJpc21hdGljMTtcclxuICAgICAgICBwcml2YXRlIEZpeGVkUHJpc21hdGljSm9pbnQgX2ZpeGVkUHJpc21hdGljMjtcclxuICAgICAgICBwcml2YXRlIEZpeGVkUmV2b2x1dGVKb2ludCBfZml4ZWRSZXZvbHV0ZTE7XHJcbiAgICAgICAgcHJpdmF0ZSBGaXhlZFJldm9sdXRlSm9pbnQgX2ZpeGVkUmV2b2x1dGUyO1xyXG4gICAgICAgIHByaXZhdGUgZmxvYXQgX2ltcHVsc2U7XHJcbiAgICAgICAgcHJpdmF0ZSBmbG9hdCBfbWFzcztcclxuICAgICAgICBwcml2YXRlIFByaXNtYXRpY0pvaW50IF9wcmlzbWF0aWMxO1xyXG4gICAgICAgIHByaXZhdGUgUHJpc21hdGljSm9pbnQgX3ByaXNtYXRpYzI7XHJcbiAgICAgICAgcHJpdmF0ZSBSZXZvbHV0ZUpvaW50IF9yZXZvbHV0ZTE7XHJcbiAgICAgICAgcHJpdmF0ZSBSZXZvbHV0ZUpvaW50IF9yZXZvbHV0ZTI7XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gUmVxdWlyZXMgdHdvIGV4aXN0aW5nIHJldm9sdXRlIG9yIHByaXNtYXRpYyBqb2ludHMgKGFueSBjb21iaW5hdGlvbiB3aWxsIHdvcmspLlxyXG4gICAgICAgIC8vLyBUaGUgcHJvdmlkZWQgam9pbnRzIG11c3QgYXR0YWNoIGEgZHluYW1pYyBib2R5IHRvIGEgc3RhdGljIGJvZHkuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJqb2ludEFcIj5UaGUgZmlyc3Qgam9pbnQuPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJqb2ludEJcIj5UaGUgc2Vjb25kIGpvaW50LjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwicmF0aW9cIj5UaGUgcmF0aW8uPC9wYXJhbT5cclxuICAgICAgICBwdWJsaWMgR2VhckpvaW50KEpvaW50IGpvaW50QSwgSm9pbnQgam9pbnRCLCBmbG9hdCByYXRpbylcclxuICAgICAgICAgICAgOiBiYXNlKGpvaW50QS5Cb2R5QSwgam9pbnRBLkJvZHlCKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgSm9pbnRUeXBlID0gSm9pbnRUeXBlLkdlYXI7XHJcbiAgICAgICAgICAgIEpvaW50QSA9IGpvaW50QTtcclxuICAgICAgICAgICAgSm9pbnRCID0gam9pbnRCO1xyXG4gICAgICAgICAgICBSYXRpbyA9IHJhdGlvO1xyXG5cclxuICAgICAgICAgICAgSm9pbnRUeXBlIHR5cGUxID0gam9pbnRBLkpvaW50VHlwZTtcclxuICAgICAgICAgICAgSm9pbnRUeXBlIHR5cGUyID0gam9pbnRCLkpvaW50VHlwZTtcclxuXHJcbiAgICAgICAgICAgIC8vIE1ha2Ugc3VyZSBpdHMgdGhlIHJpZ2h0IGtpbmQgb2Ygam9pbnRcclxuICAgICAgICAgICAgRGVidWcuQXNzZXJ0KHR5cGUxID09IEpvaW50VHlwZS5SZXZvbHV0ZSB8fFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTEgPT0gSm9pbnRUeXBlLlByaXNtYXRpYyB8fFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTEgPT0gSm9pbnRUeXBlLkZpeGVkUmV2b2x1dGUgfHxcclxuICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGUxID09IEpvaW50VHlwZS5GaXhlZFByaXNtYXRpYyk7XHJcbiAgICAgICAgICAgIERlYnVnLkFzc2VydCh0eXBlMiA9PSBKb2ludFR5cGUuUmV2b2x1dGUgfHxcclxuICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGUyID09IEpvaW50VHlwZS5QcmlzbWF0aWMgfHxcclxuICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGUyID09IEpvaW50VHlwZS5GaXhlZFJldm9sdXRlIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlMiA9PSBKb2ludFR5cGUuRml4ZWRQcmlzbWF0aWMpO1xyXG5cclxuICAgICAgICAgICAgLy8gSW4gdGhlIGNhc2Ugb2YgYSBwcmlzbWF0aWMgYW5kIHJldm9sdXRlIGpvaW50LCB0aGUgZmlyc3QgYm9keSBtdXN0IGJlIHN0YXRpYy5cclxuICAgICAgICAgICAgaWYgKHR5cGUxID09IEpvaW50VHlwZS5SZXZvbHV0ZSB8fCB0eXBlMSA9PSBKb2ludFR5cGUuUHJpc21hdGljKVxyXG4gICAgICAgICAgICAgICAgRGVidWcuQXNzZXJ0KGpvaW50QS5Cb2R5QS5Cb2R5VHlwZSA9PSBCb2R5VHlwZS5TdGF0aWMpO1xyXG4gICAgICAgICAgICBpZiAodHlwZTIgPT0gSm9pbnRUeXBlLlJldm9sdXRlIHx8IHR5cGUyID09IEpvaW50VHlwZS5QcmlzbWF0aWMpXHJcbiAgICAgICAgICAgICAgICBEZWJ1Zy5Bc3NlcnQoam9pbnRCLkJvZHlBLkJvZHlUeXBlID09IEJvZHlUeXBlLlN0YXRpYyk7XHJcblxyXG4gICAgICAgICAgICBmbG9hdCBjb29yZGluYXRlMSA9IDAuMGYsIGNvb3JkaW5hdGUyID0gMC4wZjtcclxuXHJcbiAgICAgICAgICAgIHN3aXRjaCAodHlwZTEpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGNhc2UgSm9pbnRUeXBlLlJldm9sdXRlOlxyXG4gICAgICAgICAgICAgICAgICAgIEJvZHlBID0gam9pbnRBLkJvZHlCO1xyXG4gICAgICAgICAgICAgICAgICAgIF9yZXZvbHV0ZTEgPSAoUmV2b2x1dGVKb2ludClqb2ludEE7XHJcbiAgICAgICAgICAgICAgICAgICAgTG9jYWxBbmNob3IxID0gX3Jldm9sdXRlMS5Mb2NhbEFuY2hvckI7XHJcbiAgICAgICAgICAgICAgICAgICAgY29vcmRpbmF0ZTEgPSBfcmV2b2x1dGUxLkpvaW50QW5nbGU7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlIEpvaW50VHlwZS5QcmlzbWF0aWM6XHJcbiAgICAgICAgICAgICAgICAgICAgQm9keUEgPSBqb2ludEEuQm9keUI7XHJcbiAgICAgICAgICAgICAgICAgICAgX3ByaXNtYXRpYzEgPSAoUHJpc21hdGljSm9pbnQpam9pbnRBO1xyXG4gICAgICAgICAgICAgICAgICAgIExvY2FsQW5jaG9yMSA9IF9wcmlzbWF0aWMxLkxvY2FsQW5jaG9yQjtcclxuICAgICAgICAgICAgICAgICAgICBjb29yZGluYXRlMSA9IF9wcmlzbWF0aWMxLkpvaW50VHJhbnNsYXRpb247XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlIEpvaW50VHlwZS5GaXhlZFJldm9sdXRlOlxyXG4gICAgICAgICAgICAgICAgICAgIEJvZHlBID0gam9pbnRBLkJvZHlBO1xyXG4gICAgICAgICAgICAgICAgICAgIF9maXhlZFJldm9sdXRlMSA9IChGaXhlZFJldm9sdXRlSm9pbnQpam9pbnRBO1xyXG4gICAgICAgICAgICAgICAgICAgIExvY2FsQW5jaG9yMSA9IF9maXhlZFJldm9sdXRlMS5Mb2NhbEFuY2hvckE7XHJcbiAgICAgICAgICAgICAgICAgICAgY29vcmRpbmF0ZTEgPSBfZml4ZWRSZXZvbHV0ZTEuSm9pbnRBbmdsZTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgSm9pbnRUeXBlLkZpeGVkUHJpc21hdGljOlxyXG4gICAgICAgICAgICAgICAgICAgIEJvZHlBID0gam9pbnRBLkJvZHlBO1xyXG4gICAgICAgICAgICAgICAgICAgIF9maXhlZFByaXNtYXRpYzEgPSAoRml4ZWRQcmlzbWF0aWNKb2ludClqb2ludEE7XHJcbiAgICAgICAgICAgICAgICAgICAgTG9jYWxBbmNob3IxID0gX2ZpeGVkUHJpc21hdGljMS5Mb2NhbEFuY2hvckE7XHJcbiAgICAgICAgICAgICAgICAgICAgY29vcmRpbmF0ZTEgPSBfZml4ZWRQcmlzbWF0aWMxLkpvaW50VHJhbnNsYXRpb247XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHN3aXRjaCAodHlwZTIpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGNhc2UgSm9pbnRUeXBlLlJldm9sdXRlOlxyXG4gICAgICAgICAgICAgICAgICAgIEJvZHlCID0gam9pbnRCLkJvZHlCO1xyXG4gICAgICAgICAgICAgICAgICAgIF9yZXZvbHV0ZTIgPSAoUmV2b2x1dGVKb2ludClqb2ludEI7XHJcbiAgICAgICAgICAgICAgICAgICAgTG9jYWxBbmNob3IyID0gX3Jldm9sdXRlMi5Mb2NhbEFuY2hvckI7XHJcbiAgICAgICAgICAgICAgICAgICAgY29vcmRpbmF0ZTIgPSBfcmV2b2x1dGUyLkpvaW50QW5nbGU7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlIEpvaW50VHlwZS5QcmlzbWF0aWM6XHJcbiAgICAgICAgICAgICAgICAgICAgQm9keUIgPSBqb2ludEIuQm9keUI7XHJcbiAgICAgICAgICAgICAgICAgICAgX3ByaXNtYXRpYzIgPSAoUHJpc21hdGljSm9pbnQpam9pbnRCO1xyXG4gICAgICAgICAgICAgICAgICAgIExvY2FsQW5jaG9yMiA9IF9wcmlzbWF0aWMyLkxvY2FsQW5jaG9yQjtcclxuICAgICAgICAgICAgICAgICAgICBjb29yZGluYXRlMiA9IF9wcmlzbWF0aWMyLkpvaW50VHJhbnNsYXRpb247XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlIEpvaW50VHlwZS5GaXhlZFJldm9sdXRlOlxyXG4gICAgICAgICAgICAgICAgICAgIEJvZHlCID0gam9pbnRCLkJvZHlBO1xyXG4gICAgICAgICAgICAgICAgICAgIF9maXhlZFJldm9sdXRlMiA9IChGaXhlZFJldm9sdXRlSm9pbnQpam9pbnRCO1xyXG4gICAgICAgICAgICAgICAgICAgIExvY2FsQW5jaG9yMiA9IF9maXhlZFJldm9sdXRlMi5Mb2NhbEFuY2hvckE7XHJcbiAgICAgICAgICAgICAgICAgICAgY29vcmRpbmF0ZTIgPSBfZml4ZWRSZXZvbHV0ZTIuSm9pbnRBbmdsZTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgSm9pbnRUeXBlLkZpeGVkUHJpc21hdGljOlxyXG4gICAgICAgICAgICAgICAgICAgIEJvZHlCID0gam9pbnRCLkJvZHlBO1xyXG4gICAgICAgICAgICAgICAgICAgIF9maXhlZFByaXNtYXRpYzIgPSAoRml4ZWRQcmlzbWF0aWNKb2ludClqb2ludEI7XHJcbiAgICAgICAgICAgICAgICAgICAgTG9jYWxBbmNob3IyID0gX2ZpeGVkUHJpc21hdGljMi5Mb2NhbEFuY2hvckE7XHJcbiAgICAgICAgICAgICAgICAgICAgY29vcmRpbmF0ZTIgPSBfZml4ZWRQcmlzbWF0aWMyLkpvaW50VHJhbnNsYXRpb247XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIF9hbnQgPSBjb29yZGluYXRlMSArIFJhdGlvICogY29vcmRpbmF0ZTI7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwdWJsaWMgb3ZlcnJpZGUgVmVjdG9yMiBXb3JsZEFuY2hvckFcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGdldCB7IHJldHVybiBCb2R5QS5HZXRXb3JsZFBvaW50KExvY2FsQW5jaG9yMSk7IH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHB1YmxpYyBvdmVycmlkZSBWZWN0b3IyIFdvcmxkQW5jaG9yQlxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgZ2V0IHsgcmV0dXJuIEJvZHlCLkdldFdvcmxkUG9pbnQoTG9jYWxBbmNob3IyKTsgfVxyXG4gICAgICAgICAgICBzZXQgeyBEZWJ1Zy5Bc3NlcnQoZmFsc2UsIFwiWW91IGNhbid0IHNldCB0aGUgd29ybGQgYW5jaG9yIG9uIHRoaXMgam9pbnQgdHlwZS5cIik7IH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gVGhlIGdlYXIgcmF0aW8uXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICBwdWJsaWMgZmxvYXQgUmF0aW8geyBnZXQ7IHNldDsgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIFRoZSBmaXJzdCByZXZvbHV0ZS9wcmlzbWF0aWMgam9pbnQgYXR0YWNoZWQgdG8gdGhlIGdlYXIgam9pbnQuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICBwdWJsaWMgSm9pbnQgSm9pbnRBIHsgZ2V0OyBzZXQ7IH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBUaGUgc2Vjb25kIHJldm9sdXRlL3ByaXNtYXRpYyBqb2ludCBhdHRhY2hlZCB0byB0aGUgZ2VhciBqb2ludC5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIHB1YmxpYyBKb2ludCBKb2ludEIgeyBnZXQ7IHNldDsgfVxyXG5cclxuICAgICAgICBwdWJsaWMgVmVjdG9yMiBMb2NhbEFuY2hvcjEgeyBnZXQ7IHByaXZhdGUgc2V0OyB9XHJcbiAgICAgICAgcHVibGljIFZlY3RvcjIgTG9jYWxBbmNob3IyIHsgZ2V0OyBwcml2YXRlIHNldDsgfVxyXG5cclxuICAgICAgICBwdWJsaWMgb3ZlcnJpZGUgVmVjdG9yMiBHZXRSZWFjdGlvbkZvcmNlKGZsb2F0IGludl9kdClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIFZlY3RvcjIgUCA9IF9pbXB1bHNlICogX0ouTGluZWFyQjtcclxuICAgICAgICAgICAgcmV0dXJuIGludl9kdCAqIFA7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwdWJsaWMgb3ZlcnJpZGUgZmxvYXQgR2V0UmVhY3Rpb25Ub3JxdWUoZmxvYXQgaW52X2R0KVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgVHJhbnNmb3JtIHhmMTtcclxuICAgICAgICAgICAgQm9keUIuR2V0VHJhbnNmb3JtKG91dCB4ZjEpO1xyXG5cclxuICAgICAgICAgICAgVmVjdG9yMiByID0gTWF0aFV0aWxzLk11bHRpcGx5KHJlZiB4ZjEuUiwgTG9jYWxBbmNob3IyIC0gQm9keUIuTG9jYWxDZW50ZXIpO1xyXG4gICAgICAgICAgICBWZWN0b3IyIFAgPSBfaW1wdWxzZSAqIF9KLkxpbmVhckI7XHJcbiAgICAgICAgICAgIGZsb2F0IEwgPSBfaW1wdWxzZSAqIF9KLkFuZ3VsYXJCIC0gTWF0aFV0aWxzLkNyb3NzKHIsIFApO1xyXG4gICAgICAgICAgICByZXR1cm4gaW52X2R0ICogTDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGludGVybmFsIG92ZXJyaWRlIHZvaWQgSW5pdFZlbG9jaXR5Q29uc3RyYWludHMocmVmIFRpbWVTdGVwIHN0ZXApXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBCb2R5IGIxID0gQm9keUE7XHJcbiAgICAgICAgICAgIEJvZHkgYjIgPSBCb2R5QjtcclxuXHJcbiAgICAgICAgICAgIGZsb2F0IEsgPSAwLjBmO1xyXG4gICAgICAgICAgICBfSi5TZXRaZXJvKCk7XHJcblxyXG4gICAgICAgICAgICBpZiAoX3Jldm9sdXRlMSAhPSBudWxsIHx8IF9maXhlZFJldm9sdXRlMSAhPSBudWxsKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBfSi5Bbmd1bGFyQSA9IC0xLjBmO1xyXG4gICAgICAgICAgICAgICAgSyArPSBiMS5JbnZJO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgVmVjdG9yMiB1ZztcclxuICAgICAgICAgICAgICAgIGlmIChfcHJpc21hdGljMSAhPSBudWxsKVxyXG4gICAgICAgICAgICAgICAgICAgIHVnID0gX3ByaXNtYXRpYzEuTG9jYWxYQXhpczE7IC8vIE1hdGhVdGlscy5NdWx0aXBseShyZWYgeGZnMS5SLCBfcHJpc21hdGljMS5Mb2NhbFhBeGlzMSk7XHJcbiAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICAgICAgdWcgPSBfZml4ZWRQcmlzbWF0aWMxLkxvY2FsWEF4aXMxOyAvLyBNYXRoVXRpbHMuTXVsdGlwbHkocmVmIHhmZzEuUiwgX3ByaXNtYXRpYzEuTG9jYWxYQXhpczEpO1xyXG5cclxuICAgICAgICAgICAgICAgIFRyYW5zZm9ybSB4ZjEgLyosIHhmZzEqLztcclxuICAgICAgICAgICAgICAgIGIxLkdldFRyYW5zZm9ybShvdXQgeGYxKTtcclxuICAgICAgICAgICAgICAgIC8vZzEuR2V0VHJhbnNmb3JtKG91dCB4ZmcxKTtcclxuXHJcblxyXG4gICAgICAgICAgICAgICAgVmVjdG9yMiByID0gTWF0aFV0aWxzLk11bHRpcGx5KHJlZiB4ZjEuUiwgTG9jYWxBbmNob3IxIC0gYjEuTG9jYWxDZW50ZXIpO1xyXG4gICAgICAgICAgICAgICAgZmxvYXQgY3J1ZyA9IE1hdGhVdGlscy5Dcm9zcyhyLCB1Zyk7XHJcbiAgICAgICAgICAgICAgICBfSi5MaW5lYXJBID0gLXVnO1xyXG4gICAgICAgICAgICAgICAgX0ouQW5ndWxhckEgPSAtY3J1ZztcclxuICAgICAgICAgICAgICAgIEsgKz0gYjEuSW52TWFzcyArIGIxLkludkkgKiBjcnVnICogY3J1ZztcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKF9yZXZvbHV0ZTIgIT0gbnVsbCB8fCBfZml4ZWRSZXZvbHV0ZTIgIT0gbnVsbClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgX0ouQW5ndWxhckIgPSAtUmF0aW87XHJcbiAgICAgICAgICAgICAgICBLICs9IFJhdGlvICogUmF0aW8gKiBiMi5JbnZJO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgVmVjdG9yMiB1ZztcclxuICAgICAgICAgICAgICAgIGlmIChfcHJpc21hdGljMiAhPSBudWxsKVxyXG4gICAgICAgICAgICAgICAgICAgIHVnID0gX3ByaXNtYXRpYzIuTG9jYWxYQXhpczE7IC8vIE1hdGhVdGlscy5NdWx0aXBseShyZWYgeGZnMS5SLCBfcHJpc21hdGljMS5Mb2NhbFhBeGlzMSk7XHJcbiAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICAgICAgdWcgPSBfZml4ZWRQcmlzbWF0aWMyLkxvY2FsWEF4aXMxOyAvLyBNYXRoVXRpbHMuTXVsdGlwbHkocmVmIHhmZzEuUiwgX3ByaXNtYXRpYzEuTG9jYWxYQXhpczEpO1xyXG5cclxuICAgICAgICAgICAgICAgIFRyYW5zZm9ybSAvKnhmZzEsKi8geGYyO1xyXG4gICAgICAgICAgICAgICAgLy9nMS5HZXRUcmFuc2Zvcm0ob3V0IHhmZzEpO1xyXG4gICAgICAgICAgICAgICAgYjIuR2V0VHJhbnNmb3JtKG91dCB4ZjIpO1xyXG5cclxuICAgICAgICAgICAgICAgIFZlY3RvcjIgciA9IE1hdGhVdGlscy5NdWx0aXBseShyZWYgeGYyLlIsIExvY2FsQW5jaG9yMiAtIGIyLkxvY2FsQ2VudGVyKTtcclxuICAgICAgICAgICAgICAgIGZsb2F0IGNydWcgPSBNYXRoVXRpbHMuQ3Jvc3MociwgdWcpO1xyXG4gICAgICAgICAgICAgICAgX0ouTGluZWFyQiA9IC1SYXRpbyAqIHVnO1xyXG4gICAgICAgICAgICAgICAgX0ouQW5ndWxhckIgPSAtUmF0aW8gKiBjcnVnO1xyXG4gICAgICAgICAgICAgICAgSyArPSBSYXRpbyAqIFJhdGlvICogKGIyLkludk1hc3MgKyBiMi5JbnZJICogY3J1ZyAqIGNydWcpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBDb21wdXRlIGVmZmVjdGl2ZSBtYXNzLlxyXG4gICAgICAgICAgICBEZWJ1Zy5Bc3NlcnQoSyA+IDAuMGYpO1xyXG4gICAgICAgICAgICBfbWFzcyA9IEsgPiAwLjBmID8gMS4wZiAvIEsgOiAwLjBmO1xyXG5cclxuICAgICAgICAgICAgaWYgKFNldHRpbmdzLkVuYWJsZVdhcm1zdGFydGluZylcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgLy8gV2FybSBzdGFydGluZy5cclxuICAgICAgICAgICAgICAgIGIxLkxpbmVhclZlbG9jaXR5SW50ZXJuYWwgKz0gYjEuSW52TWFzcyAqIF9pbXB1bHNlICogX0ouTGluZWFyQTtcclxuICAgICAgICAgICAgICAgIGIxLkFuZ3VsYXJWZWxvY2l0eUludGVybmFsICs9IGIxLkludkkgKiBfaW1wdWxzZSAqIF9KLkFuZ3VsYXJBO1xyXG4gICAgICAgICAgICAgICAgYjIuTGluZWFyVmVsb2NpdHlJbnRlcm5hbCArPSBiMi5JbnZNYXNzICogX2ltcHVsc2UgKiBfSi5MaW5lYXJCO1xyXG4gICAgICAgICAgICAgICAgYjIuQW5ndWxhclZlbG9jaXR5SW50ZXJuYWwgKz0gYjIuSW52SSAqIF9pbXB1bHNlICogX0ouQW5ndWxhckI7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBfaW1wdWxzZSA9IDAuMGY7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGludGVybmFsIG92ZXJyaWRlIHZvaWQgU29sdmVWZWxvY2l0eUNvbnN0cmFpbnRzKHJlZiBUaW1lU3RlcCBzdGVwKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgQm9keSBiMSA9IEJvZHlBO1xyXG4gICAgICAgICAgICBCb2R5IGIyID0gQm9keUI7XHJcblxyXG4gICAgICAgICAgICBmbG9hdCBDZG90ID0gX0ouQ29tcHV0ZShiMS5MaW5lYXJWZWxvY2l0eUludGVybmFsLCBiMS5Bbmd1bGFyVmVsb2NpdHlJbnRlcm5hbCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYjIuTGluZWFyVmVsb2NpdHlJbnRlcm5hbCwgYjIuQW5ndWxhclZlbG9jaXR5SW50ZXJuYWwpO1xyXG5cclxuICAgICAgICAgICAgZmxvYXQgaW1wdWxzZSA9IF9tYXNzICogKC1DZG90KTtcclxuICAgICAgICAgICAgX2ltcHVsc2UgKz0gaW1wdWxzZTtcclxuXHJcbiAgICAgICAgICAgIGIxLkxpbmVhclZlbG9jaXR5SW50ZXJuYWwgKz0gYjEuSW52TWFzcyAqIGltcHVsc2UgKiBfSi5MaW5lYXJBO1xyXG4gICAgICAgICAgICBiMS5Bbmd1bGFyVmVsb2NpdHlJbnRlcm5hbCArPSBiMS5JbnZJICogaW1wdWxzZSAqIF9KLkFuZ3VsYXJBO1xyXG4gICAgICAgICAgICBiMi5MaW5lYXJWZWxvY2l0eUludGVybmFsICs9IGIyLkludk1hc3MgKiBpbXB1bHNlICogX0ouTGluZWFyQjtcclxuICAgICAgICAgICAgYjIuQW5ndWxhclZlbG9jaXR5SW50ZXJuYWwgKz0gYjIuSW52SSAqIGltcHVsc2UgKiBfSi5Bbmd1bGFyQjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGludGVybmFsIG92ZXJyaWRlIGJvb2wgU29sdmVQb3NpdGlvbkNvbnN0cmFpbnRzKClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGNvbnN0IGZsb2F0IGxpbmVhckVycm9yID0gMC4wZjtcclxuXHJcbiAgICAgICAgICAgIEJvZHkgYjEgPSBCb2R5QTtcclxuICAgICAgICAgICAgQm9keSBiMiA9IEJvZHlCO1xyXG5cclxuICAgICAgICAgICAgZmxvYXQgY29vcmRpbmF0ZTEgPSAwLjBmLCBjb29yZGluYXRlMiA9IDAuMGY7XHJcbiAgICAgICAgICAgIGlmIChfcmV2b2x1dGUxICE9IG51bGwpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGNvb3JkaW5hdGUxID0gX3Jldm9sdXRlMS5Kb2ludEFuZ2xlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKF9maXhlZFJldm9sdXRlMSAhPSBudWxsKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBjb29yZGluYXRlMSA9IF9maXhlZFJldm9sdXRlMS5Kb2ludEFuZ2xlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKF9wcmlzbWF0aWMxICE9IG51bGwpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGNvb3JkaW5hdGUxID0gX3ByaXNtYXRpYzEuSm9pbnRUcmFuc2xhdGlvbjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChfZml4ZWRQcmlzbWF0aWMxICE9IG51bGwpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGNvb3JkaW5hdGUxID0gX2ZpeGVkUHJpc21hdGljMS5Kb2ludFRyYW5zbGF0aW9uO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAoX3Jldm9sdXRlMiAhPSBudWxsKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBjb29yZGluYXRlMiA9IF9yZXZvbHV0ZTIuSm9pbnRBbmdsZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChfZml4ZWRSZXZvbHV0ZTIgIT0gbnVsbClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgY29vcmRpbmF0ZTIgPSBfZml4ZWRSZXZvbHV0ZTIuSm9pbnRBbmdsZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChfcHJpc21hdGljMiAhPSBudWxsKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBjb29yZGluYXRlMiA9IF9wcmlzbWF0aWMyLkpvaW50VHJhbnNsYXRpb247XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoX2ZpeGVkUHJpc21hdGljMiAhPSBudWxsKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBjb29yZGluYXRlMiA9IF9maXhlZFByaXNtYXRpYzIuSm9pbnRUcmFuc2xhdGlvbjtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgZmxvYXQgQyA9IF9hbnQgLSAoY29vcmRpbmF0ZTEgKyBSYXRpbyAqIGNvb3JkaW5hdGUyKTtcclxuXHJcbiAgICAgICAgICAgIGZsb2F0IGltcHVsc2UgPSBfbWFzcyAqICgtQyk7XHJcblxyXG4gICAgICAgICAgICBiMS5Td2VlcC5DICs9IGIxLkludk1hc3MgKiBpbXB1bHNlICogX0ouTGluZWFyQTtcclxuICAgICAgICAgICAgYjEuU3dlZXAuQSArPSBiMS5JbnZJICogaW1wdWxzZSAqIF9KLkFuZ3VsYXJBO1xyXG4gICAgICAgICAgICBiMi5Td2VlcC5DICs9IGIyLkludk1hc3MgKiBpbXB1bHNlICogX0ouTGluZWFyQjtcclxuICAgICAgICAgICAgYjIuU3dlZXAuQSArPSBiMi5JbnZJICogaW1wdWxzZSAqIF9KLkFuZ3VsYXJCO1xyXG5cclxuICAgICAgICAgICAgYjEuU3luY2hyb25pemVUcmFuc2Zvcm0oKTtcclxuICAgICAgICAgICAgYjIuU3luY2hyb25pemVUcmFuc2Zvcm0oKTtcclxuXHJcbiAgICAgICAgICAgIC8vIFRPRE9fRVJJTiBub3QgaW1wbGVtZW50ZWRcclxuICAgICAgICAgICAgcmV0dXJuIGxpbmVhckVycm9yIDwgU2V0dGluZ3MuTGluZWFyU2xvcDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn0iLCIvKlxyXG4qIEZhcnNlZXIgUGh5c2ljcyBFbmdpbmUgYmFzZWQgb24gQm94MkQuWE5BIHBvcnQ6XHJcbiogQ29weXJpZ2h0IChjKSAyMDEwIElhbiBRdmlzdFxyXG4qIFxyXG4qIEJveDJELlhOQSBwb3J0IG9mIEJveDJEOlxyXG4qIENvcHlyaWdodCAoYykgMjAwOSBCcmFuZG9uIEZ1cnR3YW5nbGVyLCBOYXRoYW4gRnVydHdhbmdsZXJcclxuKlxyXG4qIE9yaWdpbmFsIHNvdXJjZSBCb3gyRDpcclxuKiBDb3B5cmlnaHQgKGMpIDIwMDYtMjAwOSBFcmluIENhdHRvIGh0dHA6Ly93d3cuZ3BoeXNpY3MuY29tIFxyXG4qIFxyXG4qIFRoaXMgc29mdHdhcmUgaXMgcHJvdmlkZWQgJ2FzLWlzJywgd2l0aG91dCBhbnkgZXhwcmVzcyBvciBpbXBsaWVkIFxyXG4qIHdhcnJhbnR5LiAgSW4gbm8gZXZlbnQgd2lsbCB0aGUgYXV0aG9ycyBiZSBoZWxkIGxpYWJsZSBmb3IgYW55IGRhbWFnZXMgXHJcbiogYXJpc2luZyBmcm9tIHRoZSB1c2Ugb2YgdGhpcyBzb2Z0d2FyZS4gXHJcbiogUGVybWlzc2lvbiBpcyBncmFudGVkIHRvIGFueW9uZSB0byB1c2UgdGhpcyBzb2Z0d2FyZSBmb3IgYW55IHB1cnBvc2UsIFxyXG4qIGluY2x1ZGluZyBjb21tZXJjaWFsIGFwcGxpY2F0aW9ucywgYW5kIHRvIGFsdGVyIGl0IGFuZCByZWRpc3RyaWJ1dGUgaXQgXHJcbiogZnJlZWx5LCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgcmVzdHJpY3Rpb25zOiBcclxuKiAxLiBUaGUgb3JpZ2luIG9mIHRoaXMgc29mdHdhcmUgbXVzdCBub3QgYmUgbWlzcmVwcmVzZW50ZWQ7IHlvdSBtdXN0IG5vdCBcclxuKiBjbGFpbSB0aGF0IHlvdSB3cm90ZSB0aGUgb3JpZ2luYWwgc29mdHdhcmUuIElmIHlvdSB1c2UgdGhpcyBzb2Z0d2FyZSBcclxuKiBpbiBhIHByb2R1Y3QsIGFuIGFja25vd2xlZGdtZW50IGluIHRoZSBwcm9kdWN0IGRvY3VtZW50YXRpb24gd291bGQgYmUgXHJcbiogYXBwcmVjaWF0ZWQgYnV0IGlzIG5vdCByZXF1aXJlZC4gXHJcbiogMi4gQWx0ZXJlZCBzb3VyY2UgdmVyc2lvbnMgbXVzdCBiZSBwbGFpbmx5IG1hcmtlZCBhcyBzdWNoLCBhbmQgbXVzdCBub3QgYmUgXHJcbiogbWlzcmVwcmVzZW50ZWQgYXMgYmVpbmcgdGhlIG9yaWdpbmFsIHNvZnR3YXJlLiBcclxuKiAzLiBUaGlzIG5vdGljZSBtYXkgbm90IGJlIHJlbW92ZWQgb3IgYWx0ZXJlZCBmcm9tIGFueSBzb3VyY2UgZGlzdHJpYnV0aW9uLiBcclxuKi9cclxuXHJcbnVzaW5nIFN5c3RlbTtcclxudXNpbmcgU3lzdGVtLkRpYWdub3N0aWNzO1xyXG51c2luZyBGYXJzZWVyUGh5c2ljcy5Db21tb247XHJcbnVzaW5nIE1pY3Jvc29mdC5YbmEuRnJhbWV3b3JrO1xyXG5cclxubmFtZXNwYWNlIEZhcnNlZXJQaHlzaWNzLkR5bmFtaWNzLkpvaW50c1xyXG57XHJcbiAgICBwdWJsaWMgY2xhc3MgTGluZUpvaW50IDogSm9pbnRcclxuICAgIHtcclxuICAgICAgICBwcml2YXRlIFZlY3RvcjIgX2F4LCBfYXk7XHJcbiAgICAgICAgcHJpdmF0ZSBmbG9hdCBfYmlhcztcclxuICAgICAgICBwcml2YXRlIGJvb2wgX2VuYWJsZU1vdG9yO1xyXG4gICAgICAgIHByaXZhdGUgZmxvYXQgX2dhbW1hO1xyXG4gICAgICAgIHByaXZhdGUgZmxvYXQgX2ltcHVsc2U7XHJcbiAgICAgICAgcHJpdmF0ZSBWZWN0b3IyIF9sb2NhbFhBeGlzO1xyXG4gICAgICAgIHByaXZhdGUgVmVjdG9yMiBfbG9jYWxZQXhpc0E7XHJcbiAgICAgICAgcHJpdmF0ZSBmbG9hdCBfbWFzcztcclxuICAgICAgICBwcml2YXRlIGZsb2F0IF9tYXhNb3RvclRvcnF1ZTtcclxuICAgICAgICBwcml2YXRlIGZsb2F0IF9tb3RvckltcHVsc2U7XHJcbiAgICAgICAgcHJpdmF0ZSBmbG9hdCBfbW90b3JNYXNzO1xyXG4gICAgICAgIHByaXZhdGUgZmxvYXQgX21vdG9yU3BlZWQ7XHJcblxyXG4gICAgICAgIHByaXZhdGUgZmxvYXQgX3NBeDtcclxuICAgICAgICBwcml2YXRlIGZsb2F0IF9zQXk7XHJcbiAgICAgICAgcHJpdmF0ZSBmbG9hdCBfc0J4O1xyXG4gICAgICAgIHByaXZhdGUgZmxvYXQgX3NCeTtcclxuXHJcbiAgICAgICAgcHJpdmF0ZSBmbG9hdCBfc3ByaW5nSW1wdWxzZTtcclxuICAgICAgICBwcml2YXRlIGZsb2F0IF9zcHJpbmdNYXNzO1xyXG5cclxuICAgICAgICAvLyBMaW5lYXIgY29uc3RyYWludCAocG9pbnQtdG8tbGluZSlcclxuICAgICAgICAvLyBkID0gcEIgLSBwQSA9IHhCICsgckIgLSB4QSAtIHJBXHJcbiAgICAgICAgLy8gQyA9IGRvdChheSwgZClcclxuICAgICAgICAvLyBDZG90ID0gZG90KGQsIGNyb3NzKHdBLCBheSkpICsgZG90KGF5LCB2QiArIGNyb3NzKHdCLCByQikgLSB2QSAtIGNyb3NzKHdBLCByQSkpXHJcbiAgICAgICAgLy8gICAgICA9IC1kb3QoYXksIHZBKSAtIGRvdChjcm9zcyhkICsgckEsIGF5KSwgd0EpICsgZG90KGF5LCB2QikgKyBkb3QoY3Jvc3MockIsIGF5KSwgdkIpXHJcbiAgICAgICAgLy8gSiA9IFstYXksIC1jcm9zcyhkICsgckEsIGF5KSwgYXksIGNyb3NzKHJCLCBheSldXHJcblxyXG4gICAgICAgIC8vIFNwcmluZyBsaW5lYXIgY29uc3RyYWludFxyXG4gICAgICAgIC8vIEMgPSBkb3QoYXgsIGQpXHJcbiAgICAgICAgLy8gQ2RvdCA9ID0gLWRvdChheCwgdkEpIC0gZG90KGNyb3NzKGQgKyByQSwgYXgpLCB3QSkgKyBkb3QoYXgsIHZCKSArIGRvdChjcm9zcyhyQiwgYXgpLCB2QilcclxuICAgICAgICAvLyBKID0gWy1heCAtY3Jvc3MoZCtyQSwgYXgpIGF4IGNyb3NzKHJCLCBheCldXHJcblxyXG4gICAgICAgIC8vIE1vdG9yIHJvdGF0aW9uYWwgY29uc3RyYWludFxyXG4gICAgICAgIC8vIENkb3QgPSB3QiAtIHdBXHJcbiAgICAgICAgLy8gSiA9IFswIDAgLTEgMCAwIDFdXHJcblxyXG4gICAgICAgIGludGVybmFsIExpbmVKb2ludCgpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBKb2ludFR5cGUgPSBKb2ludFR5cGUuTGluZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHB1YmxpYyBMaW5lSm9pbnQoQm9keSBiQSwgQm9keSBiQiwgVmVjdG9yMiBhbmNob3IsIFZlY3RvcjIgYXhpcylcclxuICAgICAgICAgICAgOiBiYXNlKGJBLCBiQilcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIEpvaW50VHlwZSA9IEpvaW50VHlwZS5MaW5lO1xyXG5cclxuICAgICAgICAgICAgTG9jYWxBbmNob3JBID0gYkEuR2V0TG9jYWxQb2ludChhbmNob3IpO1xyXG4gICAgICAgICAgICBMb2NhbEFuY2hvckIgPSBiQi5HZXRMb2NhbFBvaW50KGFuY2hvcik7XHJcbiAgICAgICAgICAgIExvY2FsWEF4aXMgPSBiQS5HZXRMb2NhbFZlY3RvcihheGlzKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHB1YmxpYyBWZWN0b3IyIExvY2FsQW5jaG9yQSB7IGdldDsgc2V0OyB9XHJcblxyXG4gICAgICAgIHB1YmxpYyBWZWN0b3IyIExvY2FsQW5jaG9yQiB7IGdldDsgc2V0OyB9XHJcblxyXG4gICAgICAgIHB1YmxpYyBvdmVycmlkZSBWZWN0b3IyIFdvcmxkQW5jaG9yQVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgZ2V0IHsgcmV0dXJuIEJvZHlBLkdldFdvcmxkUG9pbnQoTG9jYWxBbmNob3JBKTsgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHVibGljIG92ZXJyaWRlIFZlY3RvcjIgV29ybGRBbmNob3JCXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBnZXQgeyByZXR1cm4gQm9keUIuR2V0V29ybGRQb2ludChMb2NhbEFuY2hvckIpOyB9XHJcbiAgICAgICAgICAgIHNldCB7IERlYnVnLkFzc2VydChmYWxzZSwgXCJZb3UgY2FuJ3Qgc2V0IHRoZSB3b3JsZCBhbmNob3Igb24gdGhpcyBqb2ludCB0eXBlLlwiKTsgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHVibGljIGZsb2F0IEpvaW50VHJhbnNsYXRpb25cclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGdldFxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBCb2R5IGJBID0gQm9keUE7XHJcbiAgICAgICAgICAgICAgICBCb2R5IGJCID0gQm9keUI7XHJcblxyXG4gICAgICAgICAgICAgICAgVmVjdG9yMiBwQSA9IGJBLkdldFdvcmxkUG9pbnQoTG9jYWxBbmNob3JBKTtcclxuICAgICAgICAgICAgICAgIFZlY3RvcjIgcEIgPSBiQi5HZXRXb3JsZFBvaW50KExvY2FsQW5jaG9yQik7XHJcbiAgICAgICAgICAgICAgICBWZWN0b3IyIGQgPSBwQiAtIHBBO1xyXG4gICAgICAgICAgICAgICAgVmVjdG9yMiBheGlzID0gYkEuR2V0V29ybGRWZWN0b3IoTG9jYWxYQXhpcyk7XHJcblxyXG4gICAgICAgICAgICAgICAgZmxvYXQgdHJhbnNsYXRpb24gPSBWZWN0b3IyLkRvdChkLCBheGlzKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0cmFuc2xhdGlvbjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHVibGljIGZsb2F0IEpvaW50U3BlZWRcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGdldFxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBmbG9hdCB3QSA9IEJvZHlBLkFuZ3VsYXJWZWxvY2l0eUludGVybmFsO1xyXG4gICAgICAgICAgICAgICAgZmxvYXQgd0IgPSBCb2R5Qi5Bbmd1bGFyVmVsb2NpdHlJbnRlcm5hbDtcclxuICAgICAgICAgICAgICAgIHJldHVybiB3QiAtIHdBO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwdWJsaWMgYm9vbCBNb3RvckVuYWJsZWRcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGdldCB7IHJldHVybiBfZW5hYmxlTW90b3I7IH1cclxuICAgICAgICAgICAgc2V0XHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIEJvZHlBLkF3YWtlID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIEJvZHlCLkF3YWtlID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIF9lbmFibGVNb3RvciA9IHZhbHVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwdWJsaWMgZmxvYXQgTW90b3JTcGVlZFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgc2V0XHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIEJvZHlBLkF3YWtlID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIEJvZHlCLkF3YWtlID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIF9tb3RvclNwZWVkID0gdmFsdWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZ2V0IHsgcmV0dXJuIF9tb3RvclNwZWVkOyB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwdWJsaWMgZmxvYXQgTWF4TW90b3JUb3JxdWVcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHNldFxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBCb2R5QS5Bd2FrZSA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICBCb2R5Qi5Bd2FrZSA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICBfbWF4TW90b3JUb3JxdWUgPSB2YWx1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBnZXQgeyByZXR1cm4gX21heE1vdG9yVG9ycXVlOyB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwdWJsaWMgZmxvYXQgRnJlcXVlbmN5IHsgZ2V0OyBzZXQ7IH1cclxuXHJcbiAgICAgICAgcHVibGljIGZsb2F0IERhbXBpbmdSYXRpbyB7IGdldDsgc2V0OyB9XHJcblxyXG4gICAgICAgIHB1YmxpYyBWZWN0b3IyIExvY2FsWEF4aXNcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGdldCB7IHJldHVybiBfbG9jYWxYQXhpczsgfVxyXG4gICAgICAgICAgICBzZXRcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgX2xvY2FsWEF4aXMgPSB2YWx1ZTtcclxuICAgICAgICAgICAgICAgIF9sb2NhbFlBeGlzQSA9IE1hdGhVdGlscy5Dcm9zcygxLjBmLCBfbG9jYWxYQXhpcyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHB1YmxpYyBvdmVycmlkZSBWZWN0b3IyIEdldFJlYWN0aW9uRm9yY2UoZmxvYXQgaW52RHQpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gaW52RHQgKiAoX2ltcHVsc2UgKiBfYXkgKyBfc3ByaW5nSW1wdWxzZSAqIF9heCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwdWJsaWMgb3ZlcnJpZGUgZmxvYXQgR2V0UmVhY3Rpb25Ub3JxdWUoZmxvYXQgaW52RHQpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gaW52RHQgKiBfbW90b3JJbXB1bHNlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaW50ZXJuYWwgb3ZlcnJpZGUgdm9pZCBJbml0VmVsb2NpdHlDb25zdHJhaW50cyhyZWYgVGltZVN0ZXAgc3RlcClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIEJvZHkgYkEgPSBCb2R5QTtcclxuICAgICAgICAgICAgQm9keSBiQiA9IEJvZHlCO1xyXG5cclxuICAgICAgICAgICAgTG9jYWxDZW50ZXJBID0gYkEuTG9jYWxDZW50ZXI7XHJcbiAgICAgICAgICAgIExvY2FsQ2VudGVyQiA9IGJCLkxvY2FsQ2VudGVyO1xyXG5cclxuICAgICAgICAgICAgVHJhbnNmb3JtIHhmQTtcclxuICAgICAgICAgICAgYkEuR2V0VHJhbnNmb3JtKG91dCB4ZkEpO1xyXG4gICAgICAgICAgICBUcmFuc2Zvcm0geGZCO1xyXG4gICAgICAgICAgICBiQi5HZXRUcmFuc2Zvcm0ob3V0IHhmQik7XHJcblxyXG4gICAgICAgICAgICAvLyBDb21wdXRlIHRoZSBlZmZlY3RpdmUgbWFzc2VzLlxyXG4gICAgICAgICAgICBWZWN0b3IyIHJBID0gTWF0aFV0aWxzLk11bHRpcGx5KHJlZiB4ZkEuUiwgTG9jYWxBbmNob3JBIC0gTG9jYWxDZW50ZXJBKTtcclxuICAgICAgICAgICAgVmVjdG9yMiByQiA9IE1hdGhVdGlscy5NdWx0aXBseShyZWYgeGZCLlIsIExvY2FsQW5jaG9yQiAtIExvY2FsQ2VudGVyQik7XHJcbiAgICAgICAgICAgIFZlY3RvcjIgZCA9IGJCLlN3ZWVwLkMgKyByQiAtIGJBLlN3ZWVwLkMgLSByQTtcclxuXHJcbiAgICAgICAgICAgIEludk1hc3NBID0gYkEuSW52TWFzcztcclxuICAgICAgICAgICAgSW52SUEgPSBiQS5JbnZJO1xyXG4gICAgICAgICAgICBJbnZNYXNzQiA9IGJCLkludk1hc3M7XHJcbiAgICAgICAgICAgIEludklCID0gYkIuSW52STtcclxuXHJcbiAgICAgICAgICAgIC8vIFBvaW50IHRvIGxpbmUgY29uc3RyYWludFxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBfYXkgPSBNYXRoVXRpbHMuTXVsdGlwbHkocmVmIHhmQS5SLCBfbG9jYWxZQXhpc0EpO1xyXG4gICAgICAgICAgICAgICAgX3NBeSA9IE1hdGhVdGlscy5Dcm9zcyhkICsgckEsIF9heSk7XHJcbiAgICAgICAgICAgICAgICBfc0J5ID0gTWF0aFV0aWxzLkNyb3NzKHJCLCBfYXkpO1xyXG5cclxuICAgICAgICAgICAgICAgIF9tYXNzID0gSW52TWFzc0EgKyBJbnZNYXNzQiArIEludklBICogX3NBeSAqIF9zQXkgKyBJbnZJQiAqIF9zQnkgKiBfc0J5O1xyXG5cclxuICAgICAgICAgICAgICAgIGlmIChfbWFzcyA+IDAuMGYpXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgX21hc3MgPSAxLjBmIC8gX21hc3M7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIFNwcmluZyBjb25zdHJhaW50XHJcbiAgICAgICAgICAgIF9zcHJpbmdNYXNzID0gMC4wZjtcclxuICAgICAgICAgICAgaWYgKEZyZXF1ZW5jeSA+IDAuMGYpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIF9heCA9IE1hdGhVdGlscy5NdWx0aXBseShyZWYgeGZBLlIsIExvY2FsWEF4aXMpO1xyXG4gICAgICAgICAgICAgICAgX3NBeCA9IE1hdGhVdGlscy5Dcm9zcyhkICsgckEsIF9heCk7XHJcbiAgICAgICAgICAgICAgICBfc0J4ID0gTWF0aFV0aWxzLkNyb3NzKHJCLCBfYXgpO1xyXG5cclxuICAgICAgICAgICAgICAgIGZsb2F0IGludk1hc3MgPSBJbnZNYXNzQSArIEludk1hc3NCICsgSW52SUEgKiBfc0F4ICogX3NBeCArIEludklCICogX3NCeCAqIF9zQng7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKGludk1hc3MgPiAwLjBmKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIF9zcHJpbmdNYXNzID0gMS4wZiAvIGludk1hc3M7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGZsb2F0IEMgPSBWZWN0b3IyLkRvdChkLCBfYXgpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBGcmVxdWVuY3lcclxuICAgICAgICAgICAgICAgICAgICBmbG9hdCBvbWVnYSA9IDIuMGYgKiBTZXR0aW5ncy5QaSAqIEZyZXF1ZW5jeTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gRGFtcGluZyBjb2VmZmljaWVudFxyXG4gICAgICAgICAgICAgICAgICAgIGZsb2F0IGRhID0gMi4wZiAqIF9zcHJpbmdNYXNzICogRGFtcGluZ1JhdGlvICogb21lZ2E7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIFNwcmluZyBzdGlmZm5lc3NcclxuICAgICAgICAgICAgICAgICAgICBmbG9hdCBrID0gX3NwcmluZ01hc3MgKiBvbWVnYSAqIG9tZWdhO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBtYWdpYyBmb3JtdWxhc1xyXG4gICAgICAgICAgICAgICAgICAgIF9nYW1tYSA9IHN0ZXAuZHQgKiAoZGEgKyBzdGVwLmR0ICogayk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKF9nYW1tYSA+IDAuMGYpXHJcbiAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBfZ2FtbWEgPSAxLjBmIC8gX2dhbW1hO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgX2JpYXMgPSBDICogc3RlcC5kdCAqIGsgKiBfZ2FtbWE7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIF9zcHJpbmdNYXNzID0gaW52TWFzcyArIF9nYW1tYTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoX3NwcmluZ01hc3MgPiAwLjBmKVxyXG4gICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgX3NwcmluZ01hc3MgPSAxLjBmIC8gX3NwcmluZ01hc3M7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgX3NwcmluZ0ltcHVsc2UgPSAwLjBmO1xyXG4gICAgICAgICAgICAgICAgX3NwcmluZ01hc3MgPSAwLjBmO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBSb3RhdGlvbmFsIG1vdG9yXHJcbiAgICAgICAgICAgIGlmIChfZW5hYmxlTW90b3IpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIF9tb3Rvck1hc3MgPSBJbnZJQSArIEludklCO1xyXG4gICAgICAgICAgICAgICAgaWYgKF9tb3Rvck1hc3MgPiAwLjBmKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIF9tb3Rvck1hc3MgPSAxLjBmIC8gX21vdG9yTWFzcztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIF9tb3Rvck1hc3MgPSAwLjBmO1xyXG4gICAgICAgICAgICAgICAgX21vdG9ySW1wdWxzZSA9IDAuMGY7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmIChTZXR0aW5ncy5FbmFibGVXYXJtc3RhcnRpbmcpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIC8vIEFjY291bnQgZm9yIHZhcmlhYmxlIHRpbWUgc3RlcC5cclxuICAgICAgICAgICAgICAgIF9pbXB1bHNlICo9IHN0ZXAuZHRSYXRpbztcclxuICAgICAgICAgICAgICAgIF9zcHJpbmdJbXB1bHNlICo9IHN0ZXAuZHRSYXRpbztcclxuICAgICAgICAgICAgICAgIF9tb3RvckltcHVsc2UgKj0gc3RlcC5kdFJhdGlvO1xyXG5cclxuICAgICAgICAgICAgICAgIFZlY3RvcjIgUCA9IF9pbXB1bHNlICogX2F5ICsgX3NwcmluZ0ltcHVsc2UgKiBfYXg7XHJcbiAgICAgICAgICAgICAgICBmbG9hdCBMQSA9IF9pbXB1bHNlICogX3NBeSArIF9zcHJpbmdJbXB1bHNlICogX3NBeCArIF9tb3RvckltcHVsc2U7XHJcbiAgICAgICAgICAgICAgICBmbG9hdCBMQiA9IF9pbXB1bHNlICogX3NCeSArIF9zcHJpbmdJbXB1bHNlICogX3NCeCArIF9tb3RvckltcHVsc2U7XHJcblxyXG4gICAgICAgICAgICAgICAgYkEuTGluZWFyVmVsb2NpdHlJbnRlcm5hbCAtPSBJbnZNYXNzQSAqIFA7XHJcbiAgICAgICAgICAgICAgICBiQS5Bbmd1bGFyVmVsb2NpdHlJbnRlcm5hbCAtPSBJbnZJQSAqIExBO1xyXG5cclxuICAgICAgICAgICAgICAgIGJCLkxpbmVhclZlbG9jaXR5SW50ZXJuYWwgKz0gSW52TWFzc0IgKiBQO1xyXG4gICAgICAgICAgICAgICAgYkIuQW5ndWxhclZlbG9jaXR5SW50ZXJuYWwgKz0gSW52SUIgKiBMQjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIF9pbXB1bHNlID0gMC4wZjtcclxuICAgICAgICAgICAgICAgIF9zcHJpbmdJbXB1bHNlID0gMC4wZjtcclxuICAgICAgICAgICAgICAgIF9tb3RvckltcHVsc2UgPSAwLjBmO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpbnRlcm5hbCBvdmVycmlkZSB2b2lkIFNvbHZlVmVsb2NpdHlDb25zdHJhaW50cyhyZWYgVGltZVN0ZXAgc3RlcClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIEJvZHkgYkEgPSBCb2R5QTtcclxuICAgICAgICAgICAgQm9keSBiQiA9IEJvZHlCO1xyXG5cclxuICAgICAgICAgICAgVmVjdG9yMiB2QSA9IGJBLkxpbmVhclZlbG9jaXR5O1xyXG4gICAgICAgICAgICBmbG9hdCB3QSA9IGJBLkFuZ3VsYXJWZWxvY2l0eUludGVybmFsO1xyXG4gICAgICAgICAgICBWZWN0b3IyIHZCID0gYkIuTGluZWFyVmVsb2NpdHlJbnRlcm5hbDtcclxuICAgICAgICAgICAgZmxvYXQgd0IgPSBiQi5Bbmd1bGFyVmVsb2NpdHlJbnRlcm5hbDtcclxuXHJcbiAgICAgICAgICAgIC8vIFNvbHZlIHNwcmluZyBjb25zdHJhaW50XHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGZsb2F0IENkb3QgPSBWZWN0b3IyLkRvdChfYXgsIHZCIC0gdkEpICsgX3NCeCAqIHdCIC0gX3NBeCAqIHdBO1xyXG4gICAgICAgICAgICAgICAgZmxvYXQgaW1wdWxzZSA9IC1fc3ByaW5nTWFzcyAqIChDZG90ICsgX2JpYXMgKyBfZ2FtbWEgKiBfc3ByaW5nSW1wdWxzZSk7XHJcbiAgICAgICAgICAgICAgICBfc3ByaW5nSW1wdWxzZSArPSBpbXB1bHNlO1xyXG5cclxuICAgICAgICAgICAgICAgIFZlY3RvcjIgUCA9IGltcHVsc2UgKiBfYXg7XHJcbiAgICAgICAgICAgICAgICBmbG9hdCBMQSA9IGltcHVsc2UgKiBfc0F4O1xyXG4gICAgICAgICAgICAgICAgZmxvYXQgTEIgPSBpbXB1bHNlICogX3NCeDtcclxuXHJcbiAgICAgICAgICAgICAgICB2QSAtPSBJbnZNYXNzQSAqIFA7XHJcbiAgICAgICAgICAgICAgICB3QSAtPSBJbnZJQSAqIExBO1xyXG5cclxuICAgICAgICAgICAgICAgIHZCICs9IEludk1hc3NCICogUDtcclxuICAgICAgICAgICAgICAgIHdCICs9IEludklCICogTEI7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIFNvbHZlIHJvdGF0aW9uYWwgbW90b3IgY29uc3RyYWludFxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBmbG9hdCBDZG90ID0gd0IgLSB3QSAtIF9tb3RvclNwZWVkO1xyXG4gICAgICAgICAgICAgICAgZmxvYXQgaW1wdWxzZSA9IC1fbW90b3JNYXNzICogQ2RvdDtcclxuXHJcbiAgICAgICAgICAgICAgICBmbG9hdCBvbGRJbXB1bHNlID0gX21vdG9ySW1wdWxzZTtcclxuICAgICAgICAgICAgICAgIGZsb2F0IG1heEltcHVsc2UgPSBzdGVwLmR0ICogX21heE1vdG9yVG9ycXVlO1xyXG4gICAgICAgICAgICAgICAgX21vdG9ySW1wdWxzZSA9IE1hdGhVdGlscy5DbGFtcChfbW90b3JJbXB1bHNlICsgaW1wdWxzZSwgLW1heEltcHVsc2UsIG1heEltcHVsc2UpO1xyXG4gICAgICAgICAgICAgICAgaW1wdWxzZSA9IF9tb3RvckltcHVsc2UgLSBvbGRJbXB1bHNlO1xyXG5cclxuICAgICAgICAgICAgICAgIHdBIC09IEludklBICogaW1wdWxzZTtcclxuICAgICAgICAgICAgICAgIHdCICs9IEludklCICogaW1wdWxzZTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gU29sdmUgcG9pbnQgdG8gbGluZSBjb25zdHJhaW50XHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGZsb2F0IENkb3QgPSBWZWN0b3IyLkRvdChfYXksIHZCIC0gdkEpICsgX3NCeSAqIHdCIC0gX3NBeSAqIHdBO1xyXG4gICAgICAgICAgICAgICAgZmxvYXQgaW1wdWxzZSA9IF9tYXNzICogKC1DZG90KTtcclxuICAgICAgICAgICAgICAgIF9pbXB1bHNlICs9IGltcHVsc2U7XHJcblxyXG4gICAgICAgICAgICAgICAgVmVjdG9yMiBQID0gaW1wdWxzZSAqIF9heTtcclxuICAgICAgICAgICAgICAgIGZsb2F0IExBID0gaW1wdWxzZSAqIF9zQXk7XHJcbiAgICAgICAgICAgICAgICBmbG9hdCBMQiA9IGltcHVsc2UgKiBfc0J5O1xyXG5cclxuICAgICAgICAgICAgICAgIHZBIC09IEludk1hc3NBICogUDtcclxuICAgICAgICAgICAgICAgIHdBIC09IEludklBICogTEE7XHJcblxyXG4gICAgICAgICAgICAgICAgdkIgKz0gSW52TWFzc0IgKiBQO1xyXG4gICAgICAgICAgICAgICAgd0IgKz0gSW52SUIgKiBMQjtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgYkEuTGluZWFyVmVsb2NpdHlJbnRlcm5hbCA9IHZBO1xyXG4gICAgICAgICAgICBiQS5Bbmd1bGFyVmVsb2NpdHlJbnRlcm5hbCA9IHdBO1xyXG4gICAgICAgICAgICBiQi5MaW5lYXJWZWxvY2l0eUludGVybmFsID0gdkI7XHJcbiAgICAgICAgICAgIGJCLkFuZ3VsYXJWZWxvY2l0eUludGVybmFsID0gd0I7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpbnRlcm5hbCBvdmVycmlkZSBib29sIFNvbHZlUG9zaXRpb25Db25zdHJhaW50cygpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBCb2R5IGJBID0gQm9keUE7XHJcbiAgICAgICAgICAgIEJvZHkgYkIgPSBCb2R5QjtcclxuXHJcbiAgICAgICAgICAgIFZlY3RvcjIgeEEgPSBiQS5Td2VlcC5DO1xyXG4gICAgICAgICAgICBmbG9hdCBhbmdsZUEgPSBiQS5Td2VlcC5BO1xyXG5cclxuICAgICAgICAgICAgVmVjdG9yMiB4QiA9IGJCLlN3ZWVwLkM7XHJcbiAgICAgICAgICAgIGZsb2F0IGFuZ2xlQiA9IGJCLlN3ZWVwLkE7XHJcblxyXG4gICAgICAgICAgICBNYXQyMiBSQSA9IG5ldyBNYXQyMihhbmdsZUEpO1xyXG4gICAgICAgICAgICBNYXQyMiBSQiA9IG5ldyBNYXQyMihhbmdsZUIpO1xyXG5cclxuICAgICAgICAgICAgVmVjdG9yMiByQSA9IE1hdGhVdGlscy5NdWx0aXBseShyZWYgUkEsIExvY2FsQW5jaG9yQSAtIExvY2FsQ2VudGVyQSk7XHJcbiAgICAgICAgICAgIFZlY3RvcjIgckIgPSBNYXRoVXRpbHMuTXVsdGlwbHkocmVmIFJCLCBMb2NhbEFuY2hvckIgLSBMb2NhbENlbnRlckIpO1xyXG4gICAgICAgICAgICBWZWN0b3IyIGQgPSB4QiArIHJCIC0geEEgLSByQTtcclxuXHJcbiAgICAgICAgICAgIFZlY3RvcjIgYXkgPSBNYXRoVXRpbHMuTXVsdGlwbHkocmVmIFJBLCBfbG9jYWxZQXhpc0EpO1xyXG5cclxuICAgICAgICAgICAgZmxvYXQgc0F5ID0gTWF0aFV0aWxzLkNyb3NzKGQgKyByQSwgYXkpO1xyXG4gICAgICAgICAgICBmbG9hdCBzQnkgPSBNYXRoVXRpbHMuQ3Jvc3MockIsIGF5KTtcclxuXHJcbiAgICAgICAgICAgIGZsb2F0IEMgPSBWZWN0b3IyLkRvdChkLCBheSk7XHJcblxyXG4gICAgICAgICAgICBmbG9hdCBrID0gSW52TWFzc0EgKyBJbnZNYXNzQiArIEludklBICogX3NBeSAqIF9zQXkgKyBJbnZJQiAqIF9zQnkgKiBfc0J5O1xyXG5cclxuICAgICAgICAgICAgZmxvYXQgaW1wdWxzZTtcclxuICAgICAgICAgICAgaWYgKGsgIT0gMC4wZilcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgaW1wdWxzZSA9IC1DIC8gaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGltcHVsc2UgPSAwLjBmO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBWZWN0b3IyIFAgPSBpbXB1bHNlICogYXk7XHJcbiAgICAgICAgICAgIGZsb2F0IExBID0gaW1wdWxzZSAqIHNBeTtcclxuICAgICAgICAgICAgZmxvYXQgTEIgPSBpbXB1bHNlICogc0J5O1xyXG5cclxuICAgICAgICAgICAgeEEgLT0gSW52TWFzc0EgKiBQO1xyXG4gICAgICAgICAgICBhbmdsZUEgLT0gSW52SUEgKiBMQTtcclxuICAgICAgICAgICAgeEIgKz0gSW52TWFzc0IgKiBQO1xyXG4gICAgICAgICAgICBhbmdsZUIgKz0gSW52SUIgKiBMQjtcclxuXHJcbiAgICAgICAgICAgIC8vIFRPRE9fRVJJTiByZW1vdmUgbmVlZCBmb3IgdGhpcy5cclxuICAgICAgICAgICAgYkEuU3dlZXAuQyA9IHhBO1xyXG4gICAgICAgICAgICBiQS5Td2VlcC5BID0gYW5nbGVBO1xyXG4gICAgICAgICAgICBiQi5Td2VlcC5DID0geEI7XHJcbiAgICAgICAgICAgIGJCLlN3ZWVwLkEgPSBhbmdsZUI7XHJcbiAgICAgICAgICAgIGJBLlN5bmNocm9uaXplVHJhbnNmb3JtKCk7XHJcbiAgICAgICAgICAgIGJCLlN5bmNocm9uaXplVHJhbnNmb3JtKCk7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gTWF0aC5BYnMoQykgPD0gU2V0dGluZ3MuTGluZWFyU2xvcDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHB1YmxpYyBmbG9hdCBHZXRNb3RvclRvcnF1ZShmbG9hdCBpbnZEdClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiBpbnZEdCAqIF9tb3RvckltcHVsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59IiwiLypcclxuKiBGYXJzZWVyIFBoeXNpY3MgRW5naW5lIGJhc2VkIG9uIEJveDJELlhOQSBwb3J0OlxyXG4qIENvcHlyaWdodCAoYykgMjAxMCBJYW4gUXZpc3RcclxuKiBcclxuKiBCb3gyRC5YTkEgcG9ydCBvZiBCb3gyRDpcclxuKiBDb3B5cmlnaHQgKGMpIDIwMDkgQnJhbmRvbiBGdXJ0d2FuZ2xlciwgTmF0aGFuIEZ1cnR3YW5nbGVyXHJcbipcclxuKiBPcmlnaW5hbCBzb3VyY2UgQm94MkQ6XHJcbiogQ29weXJpZ2h0IChjKSAyMDA2LTIwMDkgRXJpbiBDYXR0byBodHRwOi8vd3d3LmdwaHlzaWNzLmNvbSBcclxuKiBcclxuKiBUaGlzIHNvZnR3YXJlIGlzIHByb3ZpZGVkICdhcy1pcycsIHdpdGhvdXQgYW55IGV4cHJlc3Mgb3IgaW1wbGllZCBcclxuKiB3YXJyYW50eS4gIEluIG5vIGV2ZW50IHdpbGwgdGhlIGF1dGhvcnMgYmUgaGVsZCBsaWFibGUgZm9yIGFueSBkYW1hZ2VzIFxyXG4qIGFyaXNpbmcgZnJvbSB0aGUgdXNlIG9mIHRoaXMgc29mdHdhcmUuIFxyXG4qIFBlcm1pc3Npb24gaXMgZ3JhbnRlZCB0byBhbnlvbmUgdG8gdXNlIHRoaXMgc29mdHdhcmUgZm9yIGFueSBwdXJwb3NlLCBcclxuKiBpbmNsdWRpbmcgY29tbWVyY2lhbCBhcHBsaWNhdGlvbnMsIGFuZCB0byBhbHRlciBpdCBhbmQgcmVkaXN0cmlidXRlIGl0IFxyXG4qIGZyZWVseSwgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIHJlc3RyaWN0aW9uczogXHJcbiogMS4gVGhlIG9yaWdpbiBvZiB0aGlzIHNvZnR3YXJlIG11c3Qgbm90IGJlIG1pc3JlcHJlc2VudGVkOyB5b3UgbXVzdCBub3QgXHJcbiogY2xhaW0gdGhhdCB5b3Ugd3JvdGUgdGhlIG9yaWdpbmFsIHNvZnR3YXJlLiBJZiB5b3UgdXNlIHRoaXMgc29mdHdhcmUgXHJcbiogaW4gYSBwcm9kdWN0LCBhbiBhY2tub3dsZWRnbWVudCBpbiB0aGUgcHJvZHVjdCBkb2N1bWVudGF0aW9uIHdvdWxkIGJlIFxyXG4qIGFwcHJlY2lhdGVkIGJ1dCBpcyBub3QgcmVxdWlyZWQuIFxyXG4qIDIuIEFsdGVyZWQgc291cmNlIHZlcnNpb25zIG11c3QgYmUgcGxhaW5seSBtYXJrZWQgYXMgc3VjaCwgYW5kIG11c3Qgbm90IGJlIFxyXG4qIG1pc3JlcHJlc2VudGVkIGFzIGJlaW5nIHRoZSBvcmlnaW5hbCBzb2Z0d2FyZS4gXHJcbiogMy4gVGhpcyBub3RpY2UgbWF5IG5vdCBiZSByZW1vdmVkIG9yIGFsdGVyZWQgZnJvbSBhbnkgc291cmNlIGRpc3RyaWJ1dGlvbi4gXHJcbiovXHJcblxyXG51c2luZyBTeXN0ZW07XHJcbnVzaW5nIFN5c3RlbS5EaWFnbm9zdGljcztcclxudXNpbmcgRmFyc2VlclBoeXNpY3MuQ29tbW9uO1xyXG51c2luZyBNaWNyb3NvZnQuWG5hLkZyYW1ld29yaztcclxuXHJcbm5hbWVzcGFjZSBGYXJzZWVyUGh5c2ljcy5EeW5hbWljcy5Kb2ludHNcclxue1xyXG4gICAgLy8gTGluZWFyIGNvbnN0cmFpbnQgKHBvaW50LXRvLWxpbmUpXHJcbiAgICAvLyBkID0gcDIgLSBwMSA9IHgyICsgcjIgLSB4MSAtIHIxXHJcbiAgICAvLyBDID0gZG90KHBlcnAsIGQpXHJcbiAgICAvLyBDZG90ID0gZG90KGQsIGNyb3NzKHcxLCBwZXJwKSkgKyBkb3QocGVycCwgdjIgKyBjcm9zcyh3MiwgcjIpIC0gdjEgLSBjcm9zcyh3MSwgcjEpKVxyXG4gICAgLy8gICAgICA9IC1kb3QocGVycCwgdjEpIC0gZG90KGNyb3NzKGQgKyByMSwgcGVycCksIHcxKSArIGRvdChwZXJwLCB2MikgKyBkb3QoY3Jvc3MocjIsIHBlcnApLCB2MilcclxuICAgIC8vIEogPSBbLXBlcnAsIC1jcm9zcyhkICsgcjEsIHBlcnApLCBwZXJwLCBjcm9zcyhyMixwZXJwKV1cclxuICAgIC8vXHJcbiAgICAvLyBBbmd1bGFyIGNvbnN0cmFpbnRcclxuICAgIC8vIEMgPSBhMiAtIGExICsgYV9pbml0aWFsXHJcbiAgICAvLyBDZG90ID0gdzIgLSB3MVxyXG4gICAgLy8gSiA9IFswIDAgLTEgMCAwIDFdXHJcbiAgICAvL1xyXG4gICAgLy8gSyA9IEogKiBpbnZNICogSlRcclxuICAgIC8vXHJcbiAgICAvLyBKID0gWy1hIC1zMSBhIHMyXVxyXG4gICAgLy8gICAgIFswICAtMSAgMCAgMV1cclxuICAgIC8vIGEgPSBwZXJwXHJcbiAgICAvLyBzMSA9IGNyb3NzKGQgKyByMSwgYSkgPSBjcm9zcyhwMiAtIHgxLCBhKVxyXG4gICAgLy8gczIgPSBjcm9zcyhyMiwgYSkgPSBjcm9zcyhwMiAtIHgyLCBhKVxyXG4gICAgLy8gTW90b3IvTGltaXQgbGluZWFyIGNvbnN0cmFpbnRcclxuICAgIC8vIEMgPSBkb3QoYXgxLCBkKVxyXG4gICAgLy8gQ2RvdCA9ID0gLWRvdChheDEsIHYxKSAtIGRvdChjcm9zcyhkICsgcjEsIGF4MSksIHcxKSArIGRvdChheDEsIHYyKSArIGRvdChjcm9zcyhyMiwgYXgxKSwgdjIpXHJcbiAgICAvLyBKID0gWy1heDEgLWNyb3NzKGQrcjEsYXgxKSBheDEgY3Jvc3MocjIsYXgxKV1cclxuICAgIC8vIEJsb2NrIFNvbHZlclxyXG4gICAgLy8gV2UgZGV2ZWxvcCBhIGJsb2NrIHNvbHZlciB0aGF0IGluY2x1ZGVzIHRoZSBqb2ludCBsaW1pdC4gVGhpcyBtYWtlcyB0aGUgbGltaXQgc3RpZmYgKGluZWxhc3RpYykgZXZlblxyXG4gICAgLy8gd2hlbiB0aGUgbWFzcyBoYXMgcG9vciBkaXN0cmlidXRpb24gKGxlYWRpbmcgdG8gbGFyZ2UgdG9ycXVlcyBhYm91dCB0aGUgam9pbnQgYW5jaG9yIHBvaW50cykuXHJcbiAgICAvL1xyXG4gICAgLy8gVGhlIEphY29iaWFuIGhhcyAzIHJvd3M6XHJcbiAgICAvLyBKID0gWy11VCAtczEgdVQgczJdIC8vIGxpbmVhclxyXG4gICAgLy8gICAgIFswICAgLTEgICAwICAxXSAvLyBhbmd1bGFyXHJcbiAgICAvLyAgICAgWy12VCAtYTEgdlQgYTJdIC8vIGxpbWl0XHJcbiAgICAvL1xyXG4gICAgLy8gdSA9IHBlcnBcclxuICAgIC8vIHYgPSBheGlzXHJcbiAgICAvLyBzMSA9IGNyb3NzKGQgKyByMSwgdSksIHMyID0gY3Jvc3MocjIsIHUpXHJcbiAgICAvLyBhMSA9IGNyb3NzKGQgKyByMSwgdiksIGEyID0gY3Jvc3MocjIsIHYpXHJcbiAgICAvLyBNICogKHYyIC0gdjEpID0gSlQgKiBkZlxyXG4gICAgLy8gSiAqIHYyID0gYmlhc1xyXG4gICAgLy9cclxuICAgIC8vIHYyID0gdjEgKyBpbnZNICogSlQgKiBkZlxyXG4gICAgLy8gSiAqICh2MSArIGludk0gKiBKVCAqIGRmKSA9IGJpYXNcclxuICAgIC8vIEsgKiBkZiA9IGJpYXMgLSBKICogdjEgPSAtQ2RvdFxyXG4gICAgLy8gSyA9IEogKiBpbnZNICogSlRcclxuICAgIC8vIENkb3QgPSBKICogdjEgLSBiaWFzXHJcbiAgICAvL1xyXG4gICAgLy8gTm93IHNvbHZlIGZvciBmMi5cclxuICAgIC8vIGRmID0gZjIgLSBmMVxyXG4gICAgLy8gSyAqIChmMiAtIGYxKSA9IC1DZG90XHJcbiAgICAvLyBmMiA9IGludksgKiAoLUNkb3QpICsgZjFcclxuICAgIC8vXHJcbiAgICAvLyBDbGFtcCBhY2N1bXVsYXRlZCBsaW1pdCBpbXB1bHNlLlxyXG4gICAgLy8gbG93ZXI6IGYyKDMpID0gbWF4KGYyKDMpLCAwKVxyXG4gICAgLy8gdXBwZXI6IGYyKDMpID0gbWluKGYyKDMpLCAwKVxyXG4gICAgLy9cclxuICAgIC8vIFNvbHZlIGZvciBjb3JyZWN0IGYyKDE6MilcclxuICAgIC8vIEsoMToyLCAxOjIpICogZjIoMToyKSA9IC1DZG90KDE6MikgLSBLKDE6MiwzKSAqIGYyKDMpICsgSygxOjIsMTozKSAqIGYxXHJcbiAgICAvLyAgICAgICAgICAgICAgICAgICAgICAgPSAtQ2RvdCgxOjIpIC0gSygxOjIsMykgKiBmMigzKSArIEsoMToyLDE6MikgKiBmMSgxOjIpICsgSygxOjIsMykgKiBmMSgzKVxyXG4gICAgLy8gSygxOjIsIDE6MikgKiBmMigxOjIpID0gLUNkb3QoMToyKSAtIEsoMToyLDMpICogKGYyKDMpIC0gZjEoMykpICsgSygxOjIsMToyKSAqIGYxKDE6MilcclxuICAgIC8vIGYyKDE6MikgPSBpbnZLKDE6MiwxOjIpICogKC1DZG90KDE6MikgLSBLKDE6MiwzKSAqIChmMigzKSAtIGYxKDMpKSkgKyBmMSgxOjIpXHJcbiAgICAvL1xyXG4gICAgLy8gTm93IGNvbXB1dGUgaW1wdWxzZSB0byBiZSBhcHBsaWVkOlxyXG4gICAgLy8gZGYgPSBmMiAtIGYxXHJcblxyXG4gICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgLy8vIEEgcHJpc21hdGljIGpvaW50LiBUaGlzIGpvaW50IHByb3ZpZGVzIG9uZSBkZWdyZWUgb2YgZnJlZWRvbTogdHJhbnNsYXRpb25cclxuICAgIC8vLyBhbG9uZyBhbiBheGlzIGZpeGVkIGluIGJvZHkxLiBSZWxhdGl2ZSByb3RhdGlvbiBpcyBwcmV2ZW50ZWQuIFlvdSBjYW5cclxuICAgIC8vLyB1c2UgYSBqb2ludCBsaW1pdCB0byByZXN0cmljdCB0aGUgcmFuZ2Ugb2YgbW90aW9uIGFuZCBhIGpvaW50IG1vdG9yIHRvXHJcbiAgICAvLy8gZHJpdmUgdGhlIG1vdGlvbiBvciB0byBtb2RlbCBqb2ludCBmcmljdGlvbi5cclxuICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICBwdWJsaWMgY2xhc3MgUHJpc21hdGljSm9pbnQgOiBKb2ludFxyXG4gICAge1xyXG4gICAgICAgIHB1YmxpYyBWZWN0b3IyIExvY2FsQW5jaG9yQTtcclxuXHJcbiAgICAgICAgcHVibGljIFZlY3RvcjIgTG9jYWxBbmNob3JCO1xyXG4gICAgICAgIHByaXZhdGUgTWF0MzMgX0s7XHJcbiAgICAgICAgcHJpdmF0ZSBmbG9hdCBfYTEsIF9hMjtcclxuICAgICAgICBwcml2YXRlIFZlY3RvcjIgX2F4aXM7XHJcbiAgICAgICAgcHJpdmF0ZSBib29sIF9lbmFibGVMaW1pdDtcclxuICAgICAgICBwcml2YXRlIGJvb2wgX2VuYWJsZU1vdG9yO1xyXG4gICAgICAgIHByaXZhdGUgVmVjdG9yMyBfaW1wdWxzZTtcclxuICAgICAgICBwcml2YXRlIExpbWl0U3RhdGUgX2xpbWl0U3RhdGU7XHJcbiAgICAgICAgcHJpdmF0ZSBWZWN0b3IyIF9sb2NhbFhBeGlzMTtcclxuICAgICAgICBwcml2YXRlIFZlY3RvcjIgX2xvY2FsWUF4aXMxO1xyXG4gICAgICAgIHByaXZhdGUgZmxvYXQgX2xvd2VyVHJhbnNsYXRpb247XHJcbiAgICAgICAgcHJpdmF0ZSBmbG9hdCBfbWF4TW90b3JGb3JjZTtcclxuICAgICAgICBwcml2YXRlIGZsb2F0IF9tb3RvckltcHVsc2U7XHJcbiAgICAgICAgcHJpdmF0ZSBmbG9hdCBfbW90b3JNYXNzOyAvLyBlZmZlY3RpdmUgbWFzcyBmb3IgbW90b3IvbGltaXQgdHJhbnNsYXRpb25hbCBjb25zdHJhaW50LlxyXG4gICAgICAgIHByaXZhdGUgZmxvYXQgX21vdG9yU3BlZWQ7XHJcbiAgICAgICAgcHJpdmF0ZSBWZWN0b3IyIF9wZXJwO1xyXG4gICAgICAgIHByaXZhdGUgZmxvYXQgX3JlZkFuZ2xlO1xyXG4gICAgICAgIHByaXZhdGUgZmxvYXQgX3MxLCBfczI7XHJcbiAgICAgICAgcHJpdmF0ZSBmbG9hdCBfdXBwZXJUcmFuc2xhdGlvbjtcclxuXHJcbiAgICAgICAgaW50ZXJuYWwgUHJpc21hdGljSm9pbnQoKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgSm9pbnRUeXBlID0gSm9pbnRUeXBlLlByaXNtYXRpYztcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gVGhpcyByZXF1aXJlcyBkZWZpbmluZyBhIGxpbmUgb2ZcclxuICAgICAgICAvLy8gbW90aW9uIHVzaW5nIGFuIGF4aXMgYW5kIGFuIGFuY2hvciBwb2ludC4gVGhlIGRlZmluaXRpb24gdXNlcyBsb2NhbFxyXG4gICAgICAgIC8vLyBhbmNob3IgcG9pbnRzIGFuZCBhIGxvY2FsIGF4aXMgc28gdGhhdCB0aGUgaW5pdGlhbCBjb25maWd1cmF0aW9uXHJcbiAgICAgICAgLy8vIGNhbiB2aW9sYXRlIHRoZSBjb25zdHJhaW50IHNsaWdodGx5LiBUaGUgam9pbnQgdHJhbnNsYXRpb24gaXMgemVyb1xyXG4gICAgICAgIC8vLyB3aGVuIHRoZSBsb2NhbCBhbmNob3IgcG9pbnRzIGNvaW5jaWRlIGluIHdvcmxkIHNwYWNlLiBVc2luZyBsb2NhbFxyXG4gICAgICAgIC8vLyBhbmNob3JzIGFuZCBhIGxvY2FsIGF4aXMgaGVscHMgd2hlbiBzYXZpbmcgYW5kIGxvYWRpbmcgYSBnYW1lLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwiYm9keUFcIj5UaGUgZmlyc3QgYm9keS48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cImJvZHlCXCI+VGhlIHNlY29uZCBib2R5LjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwibG9jYWxBbmNob3JBXCI+VGhlIGZpcnN0IGJvZHkgYW5jaG9yLjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwibG9jYWxBbmNob3JCXCI+VGhlIHNlY29uZCBib2R5IGFuY2hvci48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cImF4aXNcIj5UaGUgYXhpcy48L3BhcmFtPlxyXG4gICAgICAgIHB1YmxpYyBQcmlzbWF0aWNKb2ludChCb2R5IGJvZHlBLCBCb2R5IGJvZHlCLCBWZWN0b3IyIGxvY2FsQW5jaG9yQSwgVmVjdG9yMiBsb2NhbEFuY2hvckIsIFZlY3RvcjIgYXhpcylcclxuICAgICAgICAgICAgOiBiYXNlKGJvZHlBLCBib2R5QilcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIEpvaW50VHlwZSA9IEpvaW50VHlwZS5QcmlzbWF0aWM7XHJcblxyXG4gICAgICAgICAgICBMb2NhbEFuY2hvckEgPSBsb2NhbEFuY2hvckE7XHJcbiAgICAgICAgICAgIExvY2FsQW5jaG9yQiA9IGxvY2FsQW5jaG9yQjtcclxuXHJcbiAgICAgICAgICAgIF9sb2NhbFhBeGlzMSA9IEJvZHlBLkdldExvY2FsVmVjdG9yKGF4aXMpO1xyXG4gICAgICAgICAgICBfbG9jYWxZQXhpczEgPSBNYXRoVXRpbHMuQ3Jvc3MoMS4wZiwgX2xvY2FsWEF4aXMxKTtcclxuICAgICAgICAgICAgX3JlZkFuZ2xlID0gQm9keUIuUm90YXRpb24gLSBCb2R5QS5Sb3RhdGlvbjtcclxuXHJcbiAgICAgICAgICAgIF9saW1pdFN0YXRlID0gTGltaXRTdGF0ZS5JbmFjdGl2ZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHB1YmxpYyBvdmVycmlkZSBWZWN0b3IyIFdvcmxkQW5jaG9yQVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgZ2V0IHsgcmV0dXJuIEJvZHlBLkdldFdvcmxkUG9pbnQoTG9jYWxBbmNob3JBKTsgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHVibGljIG92ZXJyaWRlIFZlY3RvcjIgV29ybGRBbmNob3JCXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBnZXQgeyByZXR1cm4gQm9keUIuR2V0V29ybGRQb2ludChMb2NhbEFuY2hvckIpOyB9XHJcbiAgICAgICAgICAgIHNldCB7IERlYnVnLkFzc2VydChmYWxzZSwgXCJZb3UgY2FuJ3Qgc2V0IHRoZSB3b3JsZCBhbmNob3Igb24gdGhpcyBqb2ludCB0eXBlLlwiKTsgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBHZXQgdGhlIGN1cnJlbnQgam9pbnQgdHJhbnNsYXRpb24sIHVzdWFsbHkgaW4gbWV0ZXJzLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDx2YWx1ZT48L3ZhbHVlPlxyXG4gICAgICAgIHB1YmxpYyBmbG9hdCBKb2ludFRyYW5zbGF0aW9uXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBnZXRcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgVmVjdG9yMiBkID0gQm9keUIuR2V0V29ybGRQb2ludChMb2NhbEFuY2hvckIpIC0gQm9keUEuR2V0V29ybGRQb2ludChMb2NhbEFuY2hvckEpO1xyXG4gICAgICAgICAgICAgICAgVmVjdG9yMiBheGlzID0gQm9keUEuR2V0V29ybGRWZWN0b3IocmVmIF9sb2NhbFhBeGlzMSk7XHJcblxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFZlY3RvcjIuRG90KGQsIGF4aXMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIEdldCB0aGUgY3VycmVudCBqb2ludCB0cmFuc2xhdGlvbiBzcGVlZCwgdXN1YWxseSBpbiBtZXRlcnMgcGVyIHNlY29uZC5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8dmFsdWU+PC92YWx1ZT5cclxuICAgICAgICBwdWJsaWMgZmxvYXQgSm9pbnRTcGVlZFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgZ2V0XHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIFRyYW5zZm9ybSB4ZjEsIHhmMjtcclxuICAgICAgICAgICAgICAgIEJvZHlBLkdldFRyYW5zZm9ybShvdXQgeGYxKTtcclxuICAgICAgICAgICAgICAgIEJvZHlCLkdldFRyYW5zZm9ybShvdXQgeGYyKTtcclxuXHJcbiAgICAgICAgICAgICAgICBWZWN0b3IyIHIxID0gTWF0aFV0aWxzLk11bHRpcGx5KHJlZiB4ZjEuUiwgTG9jYWxBbmNob3JBIC0gQm9keUEuTG9jYWxDZW50ZXIpO1xyXG4gICAgICAgICAgICAgICAgVmVjdG9yMiByMiA9IE1hdGhVdGlscy5NdWx0aXBseShyZWYgeGYyLlIsIExvY2FsQW5jaG9yQiAtIEJvZHlCLkxvY2FsQ2VudGVyKTtcclxuICAgICAgICAgICAgICAgIFZlY3RvcjIgcDEgPSBCb2R5QS5Td2VlcC5DICsgcjE7XHJcbiAgICAgICAgICAgICAgICBWZWN0b3IyIHAyID0gQm9keUIuU3dlZXAuQyArIHIyO1xyXG4gICAgICAgICAgICAgICAgVmVjdG9yMiBkID0gcDIgLSBwMTtcclxuICAgICAgICAgICAgICAgIFZlY3RvcjIgYXhpcyA9IEJvZHlBLkdldFdvcmxkVmVjdG9yKHJlZiBfbG9jYWxYQXhpczEpO1xyXG5cclxuICAgICAgICAgICAgICAgIFZlY3RvcjIgdjEgPSBCb2R5QS5MaW5lYXJWZWxvY2l0eUludGVybmFsO1xyXG4gICAgICAgICAgICAgICAgVmVjdG9yMiB2MiA9IEJvZHlCLkxpbmVhclZlbG9jaXR5SW50ZXJuYWw7XHJcbiAgICAgICAgICAgICAgICBmbG9hdCB3MSA9IEJvZHlBLkFuZ3VsYXJWZWxvY2l0eUludGVybmFsO1xyXG4gICAgICAgICAgICAgICAgZmxvYXQgdzIgPSBCb2R5Qi5Bbmd1bGFyVmVsb2NpdHlJbnRlcm5hbDtcclxuXHJcbiAgICAgICAgICAgICAgICBmbG9hdCBzcGVlZCA9IFZlY3RvcjIuRG90KGQsIE1hdGhVdGlscy5Dcm9zcyh3MSwgYXhpcykpICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgVmVjdG9yMi5Eb3QoYXhpcywgdjIgKyBNYXRoVXRpbHMuQ3Jvc3ModzIsIHIyKSAtIHYxIC0gTWF0aFV0aWxzLkNyb3NzKHcxLCByMSkpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHNwZWVkO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIElzIHRoZSBqb2ludCBsaW1pdCBlbmFibGVkP1xyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDx2YWx1ZT48Yz50cnVlPC9jPiBpZiBbbGltaXQgZW5hYmxlZF07IG90aGVyd2lzZSwgPGM+ZmFsc2U8L2M+LjwvdmFsdWU+XHJcbiAgICAgICAgcHVibGljIGJvb2wgTGltaXRFbmFibGVkXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBnZXQgeyByZXR1cm4gX2VuYWJsZUxpbWl0OyB9XHJcbiAgICAgICAgICAgIHNldFxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBEZWJ1Zy5Bc3NlcnQoQm9keUEuRml4ZWRSb3RhdGlvbiA9PSBmYWxzZSB8fCBCb2R5Qi5GaXhlZFJvdGF0aW9uID09IGZhbHNlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiV2FybmluZzogbGltaXRzIGRvZXMgY3VycmVudGx5IG5vdCB3b3JrIHdpdGggZml4ZWQgcm90YXRpb25cIik7XHJcblxyXG4gICAgICAgICAgICAgICAgV2FrZUJvZGllcygpO1xyXG4gICAgICAgICAgICAgICAgX2VuYWJsZUxpbWl0ID0gdmFsdWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gR2V0IHRoZSBsb3dlciBqb2ludCBsaW1pdCwgdXN1YWxseSBpbiBtZXRlcnMuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHZhbHVlPjwvdmFsdWU+XHJcbiAgICAgICAgcHVibGljIGZsb2F0IExvd2VyTGltaXRcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGdldCB7IHJldHVybiBfbG93ZXJUcmFuc2xhdGlvbjsgfVxyXG4gICAgICAgICAgICBzZXRcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgV2FrZUJvZGllcygpO1xyXG4gICAgICAgICAgICAgICAgX2xvd2VyVHJhbnNsYXRpb24gPSB2YWx1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBHZXQgdGhlIHVwcGVyIGpvaW50IGxpbWl0LCB1c3VhbGx5IGluIG1ldGVycy5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8dmFsdWU+PC92YWx1ZT5cclxuICAgICAgICBwdWJsaWMgZmxvYXQgVXBwZXJMaW1pdFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgZ2V0IHsgcmV0dXJuIF91cHBlclRyYW5zbGF0aW9uOyB9XHJcbiAgICAgICAgICAgIHNldFxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBXYWtlQm9kaWVzKCk7XHJcbiAgICAgICAgICAgICAgICBfdXBwZXJUcmFuc2xhdGlvbiA9IHZhbHVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIElzIHRoZSBqb2ludCBtb3RvciBlbmFibGVkP1xyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDx2YWx1ZT48Yz50cnVlPC9jPiBpZiBbbW90b3IgZW5hYmxlZF07IG90aGVyd2lzZSwgPGM+ZmFsc2U8L2M+LjwvdmFsdWU+XHJcbiAgICAgICAgcHVibGljIGJvb2wgTW90b3JFbmFibGVkXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBnZXQgeyByZXR1cm4gX2VuYWJsZU1vdG9yOyB9XHJcbiAgICAgICAgICAgIHNldFxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBXYWtlQm9kaWVzKCk7XHJcbiAgICAgICAgICAgICAgICBfZW5hYmxlTW90b3IgPSB2YWx1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBTZXQgdGhlIG1vdG9yIHNwZWVkLCB1c3VhbGx5IGluIG1ldGVycyBwZXIgc2Vjb25kLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDx2YWx1ZT5UaGUgc3BlZWQuPC92YWx1ZT5cclxuICAgICAgICBwdWJsaWMgZmxvYXQgTW90b3JTcGVlZFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgc2V0XHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIFdha2VCb2RpZXMoKTtcclxuICAgICAgICAgICAgICAgIF9tb3RvclNwZWVkID0gdmFsdWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZ2V0IHsgcmV0dXJuIF9tb3RvclNwZWVkOyB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIFNldCB0aGUgbWF4aW11bSBtb3RvciBmb3JjZSwgdXN1YWxseSBpbiBOLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDx2YWx1ZT5UaGUgZm9yY2UuPC92YWx1ZT5cclxuICAgICAgICBwdWJsaWMgZmxvYXQgTWF4TW90b3JGb3JjZVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgZ2V0IHsgcmV0dXJuIF9tYXhNb3RvckZvcmNlOyB9XHJcbiAgICAgICAgICAgIHNldFxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBXYWtlQm9kaWVzKCk7XHJcbiAgICAgICAgICAgICAgICBfbWF4TW90b3JGb3JjZSA9IHZhbHVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIEdldCB0aGUgY3VycmVudCBtb3RvciBmb3JjZSwgdXN1YWxseSBpbiBOLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDx2YWx1ZT48L3ZhbHVlPlxyXG4gICAgICAgIHB1YmxpYyBmbG9hdCBNb3RvckZvcmNlXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBnZXQgeyByZXR1cm4gX21vdG9ySW1wdWxzZTsgfVxyXG4gICAgICAgICAgICBzZXQgeyBfbW90b3JJbXB1bHNlID0gdmFsdWU7IH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHB1YmxpYyBWZWN0b3IyIExvY2FsWEF4aXMxXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBnZXQgeyByZXR1cm4gX2xvY2FsWEF4aXMxOyB9XHJcbiAgICAgICAgICAgIHNldFxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBfbG9jYWxYQXhpczEgPSBCb2R5QS5HZXRMb2NhbFZlY3Rvcih2YWx1ZSk7XHJcbiAgICAgICAgICAgICAgICBfbG9jYWxZQXhpczEgPSBNYXRoVXRpbHMuQ3Jvc3MoMS4wZiwgX2xvY2FsWEF4aXMxKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHVibGljIGZsb2F0IFJlZmVyZW5jZUFuZ2xlXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBnZXQgeyByZXR1cm4gX3JlZkFuZ2xlOyB9XHJcbiAgICAgICAgICAgIHNldCB7IF9yZWZBbmdsZSA9IHZhbHVlOyB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwdWJsaWMgb3ZlcnJpZGUgVmVjdG9yMiBHZXRSZWFjdGlvbkZvcmNlKGZsb2F0IGludl9kdClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiBpbnZfZHQgKiAoX2ltcHVsc2UuWCAqIF9wZXJwICsgKF9tb3RvckltcHVsc2UgKyBfaW1wdWxzZS5aKSAqIF9heGlzKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHB1YmxpYyBvdmVycmlkZSBmbG9hdCBHZXRSZWFjdGlvblRvcnF1ZShmbG9hdCBpbnZfZHQpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gaW52X2R0ICogX2ltcHVsc2UuWTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGludGVybmFsIG92ZXJyaWRlIHZvaWQgSW5pdFZlbG9jaXR5Q29uc3RyYWludHMocmVmIFRpbWVTdGVwIHN0ZXApXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBCb2R5IGIxID0gQm9keUE7XHJcbiAgICAgICAgICAgIEJvZHkgYjIgPSBCb2R5QjtcclxuXHJcbiAgICAgICAgICAgIExvY2FsQ2VudGVyQSA9IGIxLkxvY2FsQ2VudGVyO1xyXG4gICAgICAgICAgICBMb2NhbENlbnRlckIgPSBiMi5Mb2NhbENlbnRlcjtcclxuXHJcbiAgICAgICAgICAgIFRyYW5zZm9ybSB4ZjEsIHhmMjtcclxuICAgICAgICAgICAgYjEuR2V0VHJhbnNmb3JtKG91dCB4ZjEpO1xyXG4gICAgICAgICAgICBiMi5HZXRUcmFuc2Zvcm0ob3V0IHhmMik7XHJcblxyXG4gICAgICAgICAgICAvLyBDb21wdXRlIHRoZSBlZmZlY3RpdmUgbWFzc2VzLlxyXG4gICAgICAgICAgICBWZWN0b3IyIHIxID0gTWF0aFV0aWxzLk11bHRpcGx5KHJlZiB4ZjEuUiwgTG9jYWxBbmNob3JBIC0gTG9jYWxDZW50ZXJBKTtcclxuICAgICAgICAgICAgVmVjdG9yMiByMiA9IE1hdGhVdGlscy5NdWx0aXBseShyZWYgeGYyLlIsIExvY2FsQW5jaG9yQiAtIExvY2FsQ2VudGVyQik7XHJcbiAgICAgICAgICAgIFZlY3RvcjIgZCA9IGIyLlN3ZWVwLkMgKyByMiAtIGIxLlN3ZWVwLkMgLSByMTtcclxuXHJcbiAgICAgICAgICAgIEludk1hc3NBID0gYjEuSW52TWFzcztcclxuICAgICAgICAgICAgSW52SUEgPSBiMS5JbnZJO1xyXG4gICAgICAgICAgICBJbnZNYXNzQiA9IGIyLkludk1hc3M7XHJcbiAgICAgICAgICAgIEludklCID0gYjIuSW52STtcclxuXHJcbiAgICAgICAgICAgIC8vIENvbXB1dGUgbW90b3IgSmFjb2JpYW4gYW5kIGVmZmVjdGl2ZSBtYXNzLlxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBfYXhpcyA9IE1hdGhVdGlscy5NdWx0aXBseShyZWYgeGYxLlIsIF9sb2NhbFhBeGlzMSk7XHJcbiAgICAgICAgICAgICAgICBfYTEgPSBNYXRoVXRpbHMuQ3Jvc3MoZCArIHIxLCBfYXhpcyk7XHJcbiAgICAgICAgICAgICAgICBfYTIgPSBNYXRoVXRpbHMuQ3Jvc3MocjIsIF9heGlzKTtcclxuXHJcbiAgICAgICAgICAgICAgICBfbW90b3JNYXNzID0gSW52TWFzc0EgKyBJbnZNYXNzQiArIEludklBICogX2ExICogX2ExICsgSW52SUIgKiBfYTIgKiBfYTI7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKF9tb3Rvck1hc3MgPiBTZXR0aW5ncy5FcHNpbG9uKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIF9tb3Rvck1hc3MgPSAxLjBmIC8gX21vdG9yTWFzcztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gUHJpc21hdGljIGNvbnN0cmFpbnQuXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIF9wZXJwID0gTWF0aFV0aWxzLk11bHRpcGx5KHJlZiB4ZjEuUiwgX2xvY2FsWUF4aXMxKTtcclxuXHJcbiAgICAgICAgICAgICAgICBfczEgPSBNYXRoVXRpbHMuQ3Jvc3MoZCArIHIxLCBfcGVycCk7XHJcbiAgICAgICAgICAgICAgICBfczIgPSBNYXRoVXRpbHMuQ3Jvc3MocjIsIF9wZXJwKTtcclxuXHJcbiAgICAgICAgICAgICAgICBmbG9hdCBtMSA9IEludk1hc3NBLCBtMiA9IEludk1hc3NCO1xyXG4gICAgICAgICAgICAgICAgZmxvYXQgaTEgPSBJbnZJQSwgaTIgPSBJbnZJQjtcclxuXHJcbiAgICAgICAgICAgICAgICBmbG9hdCBrMTEgPSBtMSArIG0yICsgaTEgKiBfczEgKiBfczEgKyBpMiAqIF9zMiAqIF9zMjtcclxuICAgICAgICAgICAgICAgIGZsb2F0IGsxMiA9IGkxICogX3MxICsgaTIgKiBfczI7XHJcbiAgICAgICAgICAgICAgICBmbG9hdCBrMTMgPSBpMSAqIF9zMSAqIF9hMSArIGkyICogX3MyICogX2EyO1xyXG4gICAgICAgICAgICAgICAgZmxvYXQgazIyID0gaTEgKyBpMjtcclxuICAgICAgICAgICAgICAgIGZsb2F0IGsyMyA9IGkxICogX2ExICsgaTIgKiBfYTI7XHJcbiAgICAgICAgICAgICAgICBmbG9hdCBrMzMgPSBtMSArIG0yICsgaTEgKiBfYTEgKiBfYTEgKyBpMiAqIF9hMiAqIF9hMjtcclxuXHJcbiAgICAgICAgICAgICAgICBfSy5Db2wxID0gbmV3IFZlY3RvcjMoazExLCBrMTIsIGsxMyk7XHJcbiAgICAgICAgICAgICAgICBfSy5Db2wyID0gbmV3IFZlY3RvcjMoazEyLCBrMjIsIGsyMyk7XHJcbiAgICAgICAgICAgICAgICBfSy5Db2wzID0gbmV3IFZlY3RvcjMoazEzLCBrMjMsIGszMyk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIENvbXB1dGUgbW90b3IgYW5kIGxpbWl0IHRlcm1zLlxyXG4gICAgICAgICAgICBpZiAoX2VuYWJsZUxpbWl0KVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBmbG9hdCBqb2ludFRyYW5zbGF0aW9uID0gVmVjdG9yMi5Eb3QoX2F4aXMsIGQpO1xyXG4gICAgICAgICAgICAgICAgaWYgKE1hdGguQWJzKF91cHBlclRyYW5zbGF0aW9uIC0gX2xvd2VyVHJhbnNsYXRpb24pIDwgMi4wZiAqIFNldHRpbmdzLkxpbmVhclNsb3ApXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgX2xpbWl0U3RhdGUgPSBMaW1pdFN0YXRlLkVxdWFsO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoam9pbnRUcmFuc2xhdGlvbiA8PSBfbG93ZXJUcmFuc2xhdGlvbilcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoX2xpbWl0U3RhdGUgIT0gTGltaXRTdGF0ZS5BdExvd2VyKVxyXG4gICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgX2xpbWl0U3RhdGUgPSBMaW1pdFN0YXRlLkF0TG93ZXI7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF9pbXB1bHNlLlogPSAwLjBmO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGpvaW50VHJhbnNsYXRpb24gPj0gX3VwcGVyVHJhbnNsYXRpb24pXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKF9saW1pdFN0YXRlICE9IExpbWl0U3RhdGUuQXRVcHBlcilcclxuICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF9saW1pdFN0YXRlID0gTGltaXRTdGF0ZS5BdFVwcGVyO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBfaW1wdWxzZS5aID0gMC4wZjtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgX2xpbWl0U3RhdGUgPSBMaW1pdFN0YXRlLkluYWN0aXZlO1xyXG4gICAgICAgICAgICAgICAgICAgIF9pbXB1bHNlLlogPSAwLjBmO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgX2xpbWl0U3RhdGUgPSBMaW1pdFN0YXRlLkluYWN0aXZlO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAoX2VuYWJsZU1vdG9yID09IGZhbHNlKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBfbW90b3JJbXB1bHNlID0gMC4wZjtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKFNldHRpbmdzLkVuYWJsZVdhcm1zdGFydGluZylcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgLy8gQWNjb3VudCBmb3IgdmFyaWFibGUgdGltZSBzdGVwLlxyXG4gICAgICAgICAgICAgICAgX2ltcHVsc2UgKj0gc3RlcC5kdFJhdGlvO1xyXG4gICAgICAgICAgICAgICAgX21vdG9ySW1wdWxzZSAqPSBzdGVwLmR0UmF0aW87XHJcblxyXG4gICAgICAgICAgICAgICAgVmVjdG9yMiBQID0gX2ltcHVsc2UuWCAqIF9wZXJwICsgKF9tb3RvckltcHVsc2UgKyBfaW1wdWxzZS5aKSAqIF9heGlzO1xyXG4gICAgICAgICAgICAgICAgZmxvYXQgTDEgPSBfaW1wdWxzZS5YICogX3MxICsgX2ltcHVsc2UuWSArIChfbW90b3JJbXB1bHNlICsgX2ltcHVsc2UuWikgKiBfYTE7XHJcbiAgICAgICAgICAgICAgICBmbG9hdCBMMiA9IF9pbXB1bHNlLlggKiBfczIgKyBfaW1wdWxzZS5ZICsgKF9tb3RvckltcHVsc2UgKyBfaW1wdWxzZS5aKSAqIF9hMjtcclxuXHJcbiAgICAgICAgICAgICAgICBiMS5MaW5lYXJWZWxvY2l0eUludGVybmFsIC09IEludk1hc3NBICogUDtcclxuICAgICAgICAgICAgICAgIGIxLkFuZ3VsYXJWZWxvY2l0eUludGVybmFsIC09IEludklBICogTDE7XHJcblxyXG4gICAgICAgICAgICAgICAgYjIuTGluZWFyVmVsb2NpdHlJbnRlcm5hbCArPSBJbnZNYXNzQiAqIFA7XHJcbiAgICAgICAgICAgICAgICBiMi5Bbmd1bGFyVmVsb2NpdHlJbnRlcm5hbCArPSBJbnZJQiAqIEwyO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgX2ltcHVsc2UgPSBWZWN0b3IzLlplcm87XHJcbiAgICAgICAgICAgICAgICBfbW90b3JJbXB1bHNlID0gMC4wZjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaW50ZXJuYWwgb3ZlcnJpZGUgdm9pZCBTb2x2ZVZlbG9jaXR5Q29uc3RyYWludHMocmVmIFRpbWVTdGVwIHN0ZXApXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBCb2R5IGIxID0gQm9keUE7XHJcbiAgICAgICAgICAgIEJvZHkgYjIgPSBCb2R5QjtcclxuXHJcbiAgICAgICAgICAgIFZlY3RvcjIgdjEgPSBiMS5MaW5lYXJWZWxvY2l0eUludGVybmFsO1xyXG4gICAgICAgICAgICBmbG9hdCB3MSA9IGIxLkFuZ3VsYXJWZWxvY2l0eUludGVybmFsO1xyXG4gICAgICAgICAgICBWZWN0b3IyIHYyID0gYjIuTGluZWFyVmVsb2NpdHlJbnRlcm5hbDtcclxuICAgICAgICAgICAgZmxvYXQgdzIgPSBiMi5Bbmd1bGFyVmVsb2NpdHlJbnRlcm5hbDtcclxuXHJcbiAgICAgICAgICAgIC8vIFNvbHZlIGxpbmVhciBtb3RvciBjb25zdHJhaW50LlxyXG4gICAgICAgICAgICBpZiAoX2VuYWJsZU1vdG9yICYmIF9saW1pdFN0YXRlICE9IExpbWl0U3RhdGUuRXF1YWwpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGZsb2F0IENkb3QgPSBWZWN0b3IyLkRvdChfYXhpcywgdjIgLSB2MSkgKyBfYTIgKiB3MiAtIF9hMSAqIHcxO1xyXG4gICAgICAgICAgICAgICAgZmxvYXQgaW1wdWxzZSA9IF9tb3Rvck1hc3MgKiAoX21vdG9yU3BlZWQgLSBDZG90KTtcclxuICAgICAgICAgICAgICAgIGZsb2F0IG9sZEltcHVsc2UgPSBfbW90b3JJbXB1bHNlO1xyXG4gICAgICAgICAgICAgICAgZmxvYXQgbWF4SW1wdWxzZSA9IHN0ZXAuZHQgKiBfbWF4TW90b3JGb3JjZTtcclxuICAgICAgICAgICAgICAgIF9tb3RvckltcHVsc2UgPSBNYXRoVXRpbHMuQ2xhbXAoX21vdG9ySW1wdWxzZSArIGltcHVsc2UsIC1tYXhJbXB1bHNlLCBtYXhJbXB1bHNlKTtcclxuICAgICAgICAgICAgICAgIGltcHVsc2UgPSBfbW90b3JJbXB1bHNlIC0gb2xkSW1wdWxzZTtcclxuXHJcbiAgICAgICAgICAgICAgICBWZWN0b3IyIFAgPSBpbXB1bHNlICogX2F4aXM7XHJcbiAgICAgICAgICAgICAgICBmbG9hdCBMMSA9IGltcHVsc2UgKiBfYTE7XHJcbiAgICAgICAgICAgICAgICBmbG9hdCBMMiA9IGltcHVsc2UgKiBfYTI7XHJcblxyXG4gICAgICAgICAgICAgICAgdjEgLT0gSW52TWFzc0EgKiBQO1xyXG4gICAgICAgICAgICAgICAgdzEgLT0gSW52SUEgKiBMMTtcclxuXHJcbiAgICAgICAgICAgICAgICB2MiArPSBJbnZNYXNzQiAqIFA7XHJcbiAgICAgICAgICAgICAgICB3MiArPSBJbnZJQiAqIEwyO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBWZWN0b3IyIENkb3QxID0gbmV3IFZlY3RvcjIoVmVjdG9yMi5Eb3QoX3BlcnAsIHYyIC0gdjEpICsgX3MyICogdzIgLSBfczEgKiB3MSwgdzIgLSB3MSk7XHJcblxyXG4gICAgICAgICAgICBpZiAoX2VuYWJsZUxpbWl0ICYmIF9saW1pdFN0YXRlICE9IExpbWl0U3RhdGUuSW5hY3RpdmUpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIC8vIFNvbHZlIHByaXNtYXRpYyBhbmQgbGltaXQgY29uc3RyYWludCBpbiBibG9jayBmb3JtLlxyXG4gICAgICAgICAgICAgICAgZmxvYXQgQ2RvdDIgPSBWZWN0b3IyLkRvdChfYXhpcywgdjIgLSB2MSkgKyBfYTIgKiB3MiAtIF9hMSAqIHcxO1xyXG4gICAgICAgICAgICAgICAgVmVjdG9yMyBDZG90ID0gbmV3IFZlY3RvcjMoQ2RvdDEuWCwgQ2RvdDEuWSwgQ2RvdDIpO1xyXG5cclxuICAgICAgICAgICAgICAgIFZlY3RvcjMgZjEgPSBfaW1wdWxzZTtcclxuICAgICAgICAgICAgICAgIFZlY3RvcjMgZGYgPSBfSy5Tb2x2ZTMzKC1DZG90KTtcclxuICAgICAgICAgICAgICAgIF9pbXB1bHNlICs9IGRmO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmIChfbGltaXRTdGF0ZSA9PSBMaW1pdFN0YXRlLkF0TG93ZXIpXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgX2ltcHVsc2UuWiA9IE1hdGguTWF4KF9pbXB1bHNlLlosIDAuMGYpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoX2xpbWl0U3RhdGUgPT0gTGltaXRTdGF0ZS5BdFVwcGVyKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIF9pbXB1bHNlLlogPSBNYXRoLk1pbihfaW1wdWxzZS5aLCAwLjBmKTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAvLyBmMigxOjIpID0gaW52SygxOjIsMToyKSAqICgtQ2RvdCgxOjIpIC0gSygxOjIsMykgKiAoZjIoMykgLSBmMSgzKSkpICsgZjEoMToyKVxyXG4gICAgICAgICAgICAgICAgVmVjdG9yMiBiID0gLUNkb3QxIC0gKF9pbXB1bHNlLlogLSBmMS5aKSAqIG5ldyBWZWN0b3IyKF9LLkNvbDMuWCwgX0suQ29sMy5ZKTtcclxuICAgICAgICAgICAgICAgIFZlY3RvcjIgZjJyID0gX0suU29sdmUyMihiKSArIG5ldyBWZWN0b3IyKGYxLlgsIGYxLlkpO1xyXG4gICAgICAgICAgICAgICAgX2ltcHVsc2UuWCA9IGYyci5YO1xyXG4gICAgICAgICAgICAgICAgX2ltcHVsc2UuWSA9IGYyci5ZO1xyXG5cclxuICAgICAgICAgICAgICAgIGRmID0gX2ltcHVsc2UgLSBmMTtcclxuXHJcbiAgICAgICAgICAgICAgICBWZWN0b3IyIFAgPSBkZi5YICogX3BlcnAgKyBkZi5aICogX2F4aXM7XHJcbiAgICAgICAgICAgICAgICBmbG9hdCBMMSA9IGRmLlggKiBfczEgKyBkZi5ZICsgZGYuWiAqIF9hMTtcclxuICAgICAgICAgICAgICAgIGZsb2F0IEwyID0gZGYuWCAqIF9zMiArIGRmLlkgKyBkZi5aICogX2EyO1xyXG5cclxuICAgICAgICAgICAgICAgIHYxIC09IEludk1hc3NBICogUDtcclxuICAgICAgICAgICAgICAgIHcxIC09IEludklBICogTDE7XHJcblxyXG4gICAgICAgICAgICAgICAgdjIgKz0gSW52TWFzc0IgKiBQO1xyXG4gICAgICAgICAgICAgICAgdzIgKz0gSW52SUIgKiBMMjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIC8vIExpbWl0IGlzIGluYWN0aXZlLCBqdXN0IHNvbHZlIHRoZSBwcmlzbWF0aWMgY29uc3RyYWludCBpbiBibG9jayBmb3JtLlxyXG4gICAgICAgICAgICAgICAgVmVjdG9yMiBkZiA9IF9LLlNvbHZlMjIoLUNkb3QxKTtcclxuICAgICAgICAgICAgICAgIF9pbXB1bHNlLlggKz0gZGYuWDtcclxuICAgICAgICAgICAgICAgIF9pbXB1bHNlLlkgKz0gZGYuWTtcclxuXHJcbiAgICAgICAgICAgICAgICBWZWN0b3IyIFAgPSBkZi5YICogX3BlcnA7XHJcbiAgICAgICAgICAgICAgICBmbG9hdCBMMSA9IGRmLlggKiBfczEgKyBkZi5ZO1xyXG4gICAgICAgICAgICAgICAgZmxvYXQgTDIgPSBkZi5YICogX3MyICsgZGYuWTtcclxuXHJcbiAgICAgICAgICAgICAgICB2MSAtPSBJbnZNYXNzQSAqIFA7XHJcbiAgICAgICAgICAgICAgICB3MSAtPSBJbnZJQSAqIEwxO1xyXG5cclxuICAgICAgICAgICAgICAgIHYyICs9IEludk1hc3NCICogUDtcclxuICAgICAgICAgICAgICAgIHcyICs9IEludklCICogTDI7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGIxLkxpbmVhclZlbG9jaXR5SW50ZXJuYWwgPSB2MTtcclxuICAgICAgICAgICAgYjEuQW5ndWxhclZlbG9jaXR5SW50ZXJuYWwgPSB3MTtcclxuICAgICAgICAgICAgYjIuTGluZWFyVmVsb2NpdHlJbnRlcm5hbCA9IHYyO1xyXG4gICAgICAgICAgICBiMi5Bbmd1bGFyVmVsb2NpdHlJbnRlcm5hbCA9IHcyO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaW50ZXJuYWwgb3ZlcnJpZGUgYm9vbCBTb2x2ZVBvc2l0aW9uQ29uc3RyYWludHMoKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgQm9keSBiMSA9IEJvZHlBO1xyXG4gICAgICAgICAgICBCb2R5IGIyID0gQm9keUI7XHJcblxyXG4gICAgICAgICAgICBWZWN0b3IyIGMxID0gYjEuU3dlZXAuQztcclxuICAgICAgICAgICAgZmxvYXQgYTEgPSBiMS5Td2VlcC5BO1xyXG5cclxuICAgICAgICAgICAgVmVjdG9yMiBjMiA9IGIyLlN3ZWVwLkM7XHJcbiAgICAgICAgICAgIGZsb2F0IGEyID0gYjIuU3dlZXAuQTtcclxuXHJcbiAgICAgICAgICAgIC8vIFNvbHZlIGxpbmVhciBsaW1pdCBjb25zdHJhaW50LlxyXG4gICAgICAgICAgICBmbG9hdCBsaW5lYXJFcnJvciA9IDAuMGY7XHJcbiAgICAgICAgICAgIGJvb2wgYWN0aXZlID0gZmFsc2U7XHJcbiAgICAgICAgICAgIGZsb2F0IEMyID0gMC4wZjtcclxuXHJcbiAgICAgICAgICAgIE1hdDIyIFIxID0gbmV3IE1hdDIyKGExKTtcclxuICAgICAgICAgICAgTWF0MjIgUjIgPSBuZXcgTWF0MjIoYTIpO1xyXG5cclxuICAgICAgICAgICAgVmVjdG9yMiByMSA9IE1hdGhVdGlscy5NdWx0aXBseShyZWYgUjEsIExvY2FsQW5jaG9yQSAtIExvY2FsQ2VudGVyQSk7XHJcbiAgICAgICAgICAgIFZlY3RvcjIgcjIgPSBNYXRoVXRpbHMuTXVsdGlwbHkocmVmIFIyLCBMb2NhbEFuY2hvckIgLSBMb2NhbENlbnRlckIpO1xyXG4gICAgICAgICAgICBWZWN0b3IyIGQgPSBjMiArIHIyIC0gYzEgLSByMTtcclxuXHJcbiAgICAgICAgICAgIGlmIChfZW5hYmxlTGltaXQpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIF9heGlzID0gTWF0aFV0aWxzLk11bHRpcGx5KHJlZiBSMSwgX2xvY2FsWEF4aXMxKTtcclxuXHJcbiAgICAgICAgICAgICAgICBfYTEgPSBNYXRoVXRpbHMuQ3Jvc3MoZCArIHIxLCBfYXhpcyk7XHJcbiAgICAgICAgICAgICAgICBfYTIgPSBNYXRoVXRpbHMuQ3Jvc3MocjIsIF9heGlzKTtcclxuXHJcbiAgICAgICAgICAgICAgICBmbG9hdCB0cmFuc2xhdGlvbiA9IFZlY3RvcjIuRG90KF9heGlzLCBkKTtcclxuICAgICAgICAgICAgICAgIGlmIChNYXRoLkFicyhfdXBwZXJUcmFuc2xhdGlvbiAtIF9sb3dlclRyYW5zbGF0aW9uKSA8IDIuMGYgKiBTZXR0aW5ncy5MaW5lYXJTbG9wKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIFByZXZlbnQgbGFyZ2UgYW5ndWxhciBjb3JyZWN0aW9uc1xyXG4gICAgICAgICAgICAgICAgICAgIEMyID0gTWF0aFV0aWxzLkNsYW1wKHRyYW5zbGF0aW9uLCAtU2V0dGluZ3MuTWF4TGluZWFyQ29ycmVjdGlvbiwgU2V0dGluZ3MuTWF4TGluZWFyQ29ycmVjdGlvbik7XHJcbiAgICAgICAgICAgICAgICAgICAgbGluZWFyRXJyb3IgPSAoZmxvYXQpTWF0aC5BYnModHJhbnNsYXRpb24pO1xyXG4gICAgICAgICAgICAgICAgICAgIGFjdGl2ZSA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmICh0cmFuc2xhdGlvbiA8PSBfbG93ZXJUcmFuc2xhdGlvbilcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBQcmV2ZW50IGxhcmdlIGxpbmVhciBjb3JyZWN0aW9ucyBhbmQgYWxsb3cgc29tZSBzbG9wLlxyXG4gICAgICAgICAgICAgICAgICAgIEMyID0gTWF0aFV0aWxzLkNsYW1wKHRyYW5zbGF0aW9uIC0gX2xvd2VyVHJhbnNsYXRpb24gKyBTZXR0aW5ncy5MaW5lYXJTbG9wLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC1TZXR0aW5ncy5NYXhMaW5lYXJDb3JyZWN0aW9uLCAwLjBmKTtcclxuICAgICAgICAgICAgICAgICAgICBsaW5lYXJFcnJvciA9IF9sb3dlclRyYW5zbGF0aW9uIC0gdHJhbnNsYXRpb247XHJcbiAgICAgICAgICAgICAgICAgICAgYWN0aXZlID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHRyYW5zbGF0aW9uID49IF91cHBlclRyYW5zbGF0aW9uKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIFByZXZlbnQgbGFyZ2UgbGluZWFyIGNvcnJlY3Rpb25zIGFuZCBhbGxvdyBzb21lIHNsb3AuXHJcbiAgICAgICAgICAgICAgICAgICAgQzIgPSBNYXRoVXRpbHMuQ2xhbXAodHJhbnNsYXRpb24gLSBfdXBwZXJUcmFuc2xhdGlvbiAtIFNldHRpbmdzLkxpbmVhclNsb3AsIDAuMGYsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgU2V0dGluZ3MuTWF4TGluZWFyQ29ycmVjdGlvbik7XHJcbiAgICAgICAgICAgICAgICAgICAgbGluZWFyRXJyb3IgPSB0cmFuc2xhdGlvbiAtIF91cHBlclRyYW5zbGF0aW9uO1xyXG4gICAgICAgICAgICAgICAgICAgIGFjdGl2ZSA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIF9wZXJwID0gTWF0aFV0aWxzLk11bHRpcGx5KHJlZiBSMSwgX2xvY2FsWUF4aXMxKTtcclxuXHJcbiAgICAgICAgICAgIF9zMSA9IE1hdGhVdGlscy5Dcm9zcyhkICsgcjEsIF9wZXJwKTtcclxuICAgICAgICAgICAgX3MyID0gTWF0aFV0aWxzLkNyb3NzKHIyLCBfcGVycCk7XHJcblxyXG4gICAgICAgICAgICBWZWN0b3IzIGltcHVsc2U7XHJcbiAgICAgICAgICAgIFZlY3RvcjIgQzEgPSBuZXcgVmVjdG9yMihWZWN0b3IyLkRvdChfcGVycCwgZCksIGEyIC0gYTEgLSBSZWZlcmVuY2VBbmdsZSk7XHJcblxyXG4gICAgICAgICAgICBsaW5lYXJFcnJvciA9IE1hdGguTWF4KGxpbmVhckVycm9yLCAoZmxvYXQpTWF0aC5BYnMoQzEuWCkpO1xyXG4gICAgICAgICAgICBmbG9hdCBhbmd1bGFyRXJyb3IgPSAoZmxvYXQpTWF0aC5BYnMoQzEuWSk7XHJcblxyXG4gICAgICAgICAgICBpZiAoYWN0aXZlKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBmbG9hdCBtMSA9IEludk1hc3NBLCBtMiA9IEludk1hc3NCO1xyXG4gICAgICAgICAgICAgICAgZmxvYXQgaTEgPSBJbnZJQSwgaTIgPSBJbnZJQjtcclxuXHJcbiAgICAgICAgICAgICAgICBmbG9hdCBrMTEgPSBtMSArIG0yICsgaTEgKiBfczEgKiBfczEgKyBpMiAqIF9zMiAqIF9zMjtcclxuICAgICAgICAgICAgICAgIGZsb2F0IGsxMiA9IGkxICogX3MxICsgaTIgKiBfczI7XHJcbiAgICAgICAgICAgICAgICBmbG9hdCBrMTMgPSBpMSAqIF9zMSAqIF9hMSArIGkyICogX3MyICogX2EyO1xyXG4gICAgICAgICAgICAgICAgZmxvYXQgazIyID0gaTEgKyBpMjtcclxuICAgICAgICAgICAgICAgIGZsb2F0IGsyMyA9IGkxICogX2ExICsgaTIgKiBfYTI7XHJcbiAgICAgICAgICAgICAgICBmbG9hdCBrMzMgPSBtMSArIG0yICsgaTEgKiBfYTEgKiBfYTEgKyBpMiAqIF9hMiAqIF9hMjtcclxuXHJcbiAgICAgICAgICAgICAgICBfSy5Db2wxID0gbmV3IFZlY3RvcjMoazExLCBrMTIsIGsxMyk7XHJcbiAgICAgICAgICAgICAgICBfSy5Db2wyID0gbmV3IFZlY3RvcjMoazEyLCBrMjIsIGsyMyk7XHJcbiAgICAgICAgICAgICAgICBfSy5Db2wzID0gbmV3IFZlY3RvcjMoazEzLCBrMjMsIGszMyk7XHJcblxyXG4gICAgICAgICAgICAgICAgVmVjdG9yMyBDID0gbmV3IFZlY3RvcjMoLUMxLlgsIC1DMS5ZLCAtQzIpO1xyXG4gICAgICAgICAgICAgICAgaW1wdWxzZSA9IF9LLlNvbHZlMzMoQyk7IC8vIG5lZ2F0ZWQgYWJvdmVcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGZsb2F0IG0xID0gSW52TWFzc0EsIG0yID0gSW52TWFzc0I7XHJcbiAgICAgICAgICAgICAgICBmbG9hdCBpMSA9IEludklBLCBpMiA9IEludklCO1xyXG5cclxuICAgICAgICAgICAgICAgIGZsb2F0IGsxMSA9IG0xICsgbTIgKyBpMSAqIF9zMSAqIF9zMSArIGkyICogX3MyICogX3MyO1xyXG4gICAgICAgICAgICAgICAgZmxvYXQgazEyID0gaTEgKiBfczEgKyBpMiAqIF9zMjtcclxuICAgICAgICAgICAgICAgIGZsb2F0IGsyMiA9IGkxICsgaTI7XHJcblxyXG4gICAgICAgICAgICAgICAgX0suQ29sMSA9IG5ldyBWZWN0b3IzKGsxMSwgazEyLCAwLjBmKTtcclxuICAgICAgICAgICAgICAgIF9LLkNvbDIgPSBuZXcgVmVjdG9yMyhrMTIsIGsyMiwgMC4wZik7XHJcblxyXG4gICAgICAgICAgICAgICAgVmVjdG9yMiBpbXB1bHNlMSA9IF9LLlNvbHZlMjIoLUMxKTtcclxuICAgICAgICAgICAgICAgIGltcHVsc2UuWCA9IGltcHVsc2UxLlg7XHJcbiAgICAgICAgICAgICAgICBpbXB1bHNlLlkgPSBpbXB1bHNlMS5ZO1xyXG4gICAgICAgICAgICAgICAgaW1wdWxzZS5aID0gMC4wZjtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgVmVjdG9yMiBQID0gaW1wdWxzZS5YICogX3BlcnAgKyBpbXB1bHNlLlogKiBfYXhpcztcclxuICAgICAgICAgICAgZmxvYXQgTDEgPSBpbXB1bHNlLlggKiBfczEgKyBpbXB1bHNlLlkgKyBpbXB1bHNlLlogKiBfYTE7XHJcbiAgICAgICAgICAgIGZsb2F0IEwyID0gaW1wdWxzZS5YICogX3MyICsgaW1wdWxzZS5ZICsgaW1wdWxzZS5aICogX2EyO1xyXG5cclxuICAgICAgICAgICAgYzEgLT0gSW52TWFzc0EgKiBQO1xyXG4gICAgICAgICAgICBhMSAtPSBJbnZJQSAqIEwxO1xyXG4gICAgICAgICAgICBjMiArPSBJbnZNYXNzQiAqIFA7XHJcbiAgICAgICAgICAgIGEyICs9IEludklCICogTDI7XHJcblxyXG4gICAgICAgICAgICAvLyBUT0RPX0VSSU4gcmVtb3ZlIG5lZWQgZm9yIHRoaXMuXHJcbiAgICAgICAgICAgIGIxLlN3ZWVwLkMgPSBjMTtcclxuICAgICAgICAgICAgYjEuU3dlZXAuQSA9IGExO1xyXG4gICAgICAgICAgICBiMi5Td2VlcC5DID0gYzI7XHJcbiAgICAgICAgICAgIGIyLlN3ZWVwLkEgPSBhMjtcclxuICAgICAgICAgICAgYjEuU3luY2hyb25pemVUcmFuc2Zvcm0oKTtcclxuICAgICAgICAgICAgYjIuU3luY2hyb25pemVUcmFuc2Zvcm0oKTtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiBsaW5lYXJFcnJvciA8PSBTZXR0aW5ncy5MaW5lYXJTbG9wICYmIGFuZ3VsYXJFcnJvciA8PSBTZXR0aW5ncy5Bbmd1bGFyU2xvcDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn0iLCIvKlxyXG4qIEZhcnNlZXIgUGh5c2ljcyBFbmdpbmUgYmFzZWQgb24gQm94MkQuWE5BIHBvcnQ6XHJcbiogQ29weXJpZ2h0IChjKSAyMDEwIElhbiBRdmlzdFxyXG4qIFxyXG4qIEJveDJELlhOQSBwb3J0IG9mIEJveDJEOlxyXG4qIENvcHlyaWdodCAoYykgMjAwOSBCcmFuZG9uIEZ1cnR3YW5nbGVyLCBOYXRoYW4gRnVydHdhbmdsZXJcclxuKlxyXG4qIE9yaWdpbmFsIHNvdXJjZSBCb3gyRDpcclxuKiBDb3B5cmlnaHQgKGMpIDIwMDYtMjAwOSBFcmluIENhdHRvIGh0dHA6Ly93d3cuZ3BoeXNpY3MuY29tIFxyXG4qIFxyXG4qIFRoaXMgc29mdHdhcmUgaXMgcHJvdmlkZWQgJ2FzLWlzJywgd2l0aG91dCBhbnkgZXhwcmVzcyBvciBpbXBsaWVkIFxyXG4qIHdhcnJhbnR5LiAgSW4gbm8gZXZlbnQgd2lsbCB0aGUgYXV0aG9ycyBiZSBoZWxkIGxpYWJsZSBmb3IgYW55IGRhbWFnZXMgXHJcbiogYXJpc2luZyBmcm9tIHRoZSB1c2Ugb2YgdGhpcyBzb2Z0d2FyZS4gXHJcbiogUGVybWlzc2lvbiBpcyBncmFudGVkIHRvIGFueW9uZSB0byB1c2UgdGhpcyBzb2Z0d2FyZSBmb3IgYW55IHB1cnBvc2UsIFxyXG4qIGluY2x1ZGluZyBjb21tZXJjaWFsIGFwcGxpY2F0aW9ucywgYW5kIHRvIGFsdGVyIGl0IGFuZCByZWRpc3RyaWJ1dGUgaXQgXHJcbiogZnJlZWx5LCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgcmVzdHJpY3Rpb25zOiBcclxuKiAxLiBUaGUgb3JpZ2luIG9mIHRoaXMgc29mdHdhcmUgbXVzdCBub3QgYmUgbWlzcmVwcmVzZW50ZWQ7IHlvdSBtdXN0IG5vdCBcclxuKiBjbGFpbSB0aGF0IHlvdSB3cm90ZSB0aGUgb3JpZ2luYWwgc29mdHdhcmUuIElmIHlvdSB1c2UgdGhpcyBzb2Z0d2FyZSBcclxuKiBpbiBhIHByb2R1Y3QsIGFuIGFja25vd2xlZGdtZW50IGluIHRoZSBwcm9kdWN0IGRvY3VtZW50YXRpb24gd291bGQgYmUgXHJcbiogYXBwcmVjaWF0ZWQgYnV0IGlzIG5vdCByZXF1aXJlZC4gXHJcbiogMi4gQWx0ZXJlZCBzb3VyY2UgdmVyc2lvbnMgbXVzdCBiZSBwbGFpbmx5IG1hcmtlZCBhcyBzdWNoLCBhbmQgbXVzdCBub3QgYmUgXHJcbiogbWlzcmVwcmVzZW50ZWQgYXMgYmVpbmcgdGhlIG9yaWdpbmFsIHNvZnR3YXJlLiBcclxuKiAzLiBUaGlzIG5vdGljZSBtYXkgbm90IGJlIHJlbW92ZWQgb3IgYWx0ZXJlZCBmcm9tIGFueSBzb3VyY2UgZGlzdHJpYnV0aW9uLiBcclxuKi9cclxuXHJcbnVzaW5nIFN5c3RlbTtcclxudXNpbmcgU3lzdGVtLkRpYWdub3N0aWNzO1xyXG51c2luZyBGYXJzZWVyUGh5c2ljcy5Db21tb247XHJcbnVzaW5nIE1pY3Jvc29mdC5YbmEuRnJhbWV3b3JrO1xyXG5cclxubmFtZXNwYWNlIEZhcnNlZXJQaHlzaWNzLkR5bmFtaWNzLkpvaW50c1xyXG57XHJcbiAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAvLy8gVGhlIHB1bGxleSBqb2ludCBpcyBjb25uZWN0ZWQgdG8gdHdvIGJvZGllcyBhbmQgdHdvIGZpeGVkIGdyb3VuZCBwb2ludHMuXHJcbiAgICAvLy8gVGhlIHB1bGxleSBzdXBwb3J0cyBhIHJhdGlvIHN1Y2ggdGhhdDpcclxuICAgIC8vLyBsZW5ndGgxICsgcmF0aW8gKiBsZW5ndGgyIDwhLS08LS0+PSBhbnRcclxuICAgIC8vLyBZZXMsIHRoZSBmb3JjZSB0cmFuc21pdHRlZCBpcyBzY2FsZWQgYnkgdGhlIHJhdGlvLlxyXG4gICAgLy8vIFRoZSBwdWxsZXkgYWxzbyBlbmZvcmNlcyBhIG1heGltdW0gbGVuZ3RoIGxpbWl0IG9uIGJvdGggc2lkZXMuIFRoaXMgaXNcclxuICAgIC8vLyB1c2VmdWwgdG8gcHJldmVudCBvbmUgc2lkZSBvZiB0aGUgcHVsbGV5IGhpdHRpbmcgdGhlIHRvcC5cclxuICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICBwdWJsaWMgY2xhc3MgUHVsbGV5Sm9pbnQgOiBKb2ludFxyXG4gICAge1xyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gR2V0IHRoZSBmaXJzdCBncm91bmQgYW5jaG9yLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDx2YWx1ZT48L3ZhbHVlPlxyXG4gICAgICAgIHB1YmxpYyBWZWN0b3IyIEdyb3VuZEFuY2hvckE7XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gR2V0IHRoZSBzZWNvbmQgZ3JvdW5kIGFuY2hvci5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8dmFsdWU+PC92YWx1ZT5cclxuICAgICAgICBwdWJsaWMgVmVjdG9yMiBHcm91bmRBbmNob3JCO1xyXG5cclxuICAgICAgICBwdWJsaWMgVmVjdG9yMiBMb2NhbEFuY2hvckE7XHJcbiAgICAgICAgcHVibGljIFZlY3RvcjIgTG9jYWxBbmNob3JCO1xyXG5cclxuICAgICAgICBwdWJsaWMgZmxvYXQgTWluUHVsbGV5TGVuZ3RoID0gMi4wZjtcclxuICAgICAgICBwcml2YXRlIGZsb2F0IF9hbnQ7XHJcbiAgICAgICAgcHJpdmF0ZSBmbG9hdCBfaW1wdWxzZTtcclxuICAgICAgICBwcml2YXRlIGZsb2F0IF9sZW5ndGhBO1xyXG4gICAgICAgIHByaXZhdGUgZmxvYXQgX2xlbmd0aEI7XHJcbiAgICAgICAgcHJpdmF0ZSBmbG9hdCBfbGltaXRJbXB1bHNlMTtcclxuICAgICAgICBwcml2YXRlIGZsb2F0IF9saW1pdEltcHVsc2UyO1xyXG4gICAgICAgIHByaXZhdGUgZmxvYXQgX2xpbWl0TWFzczE7XHJcbiAgICAgICAgcHJpdmF0ZSBmbG9hdCBfbGltaXRNYXNzMjtcclxuICAgICAgICBwcml2YXRlIExpbWl0U3RhdGUgX2xpbWl0U3RhdGUxO1xyXG4gICAgICAgIHByaXZhdGUgTGltaXRTdGF0ZSBfbGltaXRTdGF0ZTI7XHJcbiAgICAgICAgcHJpdmF0ZSBmbG9hdCBfbWF4TGVuZ3RoQTtcclxuICAgICAgICBwcml2YXRlIGZsb2F0IF9tYXhMZW5ndGhCO1xyXG5cclxuICAgICAgICAvLyBFZmZlY3RpdmUgbWFzc2VzXHJcbiAgICAgICAgcHJpdmF0ZSBmbG9hdCBfcHVsbGV5TWFzcztcclxuICAgICAgICBwcml2YXRlIExpbWl0U3RhdGUgX3N0YXRlO1xyXG4gICAgICAgIHByaXZhdGUgVmVjdG9yMiBfdTE7XHJcbiAgICAgICAgcHJpdmF0ZSBWZWN0b3IyIF91MjtcclxuXHJcbiAgICAgICAgaW50ZXJuYWwgUHVsbGV5Sm9pbnQoKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgSm9pbnRUeXBlID0gSm9pbnRUeXBlLlB1bGxleTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gSW5pdGlhbGl6ZSB0aGUgYm9kaWVzLCBhbmNob3JzLCBsZW5ndGhzLCBtYXggbGVuZ3RocywgYW5kIHJhdGlvIHVzaW5nIHRoZSB3b3JsZCBhbmNob3JzLlxyXG4gICAgICAgIC8vLyBUaGlzIHJlcXVpcmVzIHR3byBncm91bmQgYW5jaG9ycyxcclxuICAgICAgICAvLy8gdHdvIGR5bmFtaWMgYm9keSBhbmNob3IgcG9pbnRzLCBtYXggbGVuZ3RocyBmb3IgZWFjaCBzaWRlLFxyXG4gICAgICAgIC8vLyBhbmQgYSBwdWxsZXkgcmF0aW8uXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJib2R5QVwiPlRoZSBmaXJzdCBib2R5LjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwiYm9keUJcIj5UaGUgc2Vjb25kIGJvZHkuPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJncm91bmRBbmNob3JBXCI+VGhlIGdyb3VuZCBhbmNob3IgZm9yIHRoZSBmaXJzdCBib2R5LjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwiZ3JvdW5kQW5jaG9yQlwiPlRoZSBncm91bmQgYW5jaG9yIGZvciB0aGUgc2Vjb25kIGJvZHkuPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJsb2NhbEFuY2hvckFcIj5UaGUgZmlyc3QgYm9keSBhbmNob3IuPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJsb2NhbEFuY2hvckJcIj5UaGUgc2Vjb25kIGJvZHkgYW5jaG9yLjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwicmF0aW9cIj5UaGUgcmF0aW8uPC9wYXJhbT5cclxuICAgICAgICBwdWJsaWMgUHVsbGV5Sm9pbnQoQm9keSBib2R5QSwgQm9keSBib2R5QixcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgVmVjdG9yMiBncm91bmRBbmNob3JBLCBWZWN0b3IyIGdyb3VuZEFuY2hvckIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIFZlY3RvcjIgbG9jYWxBbmNob3JBLCBWZWN0b3IyIGxvY2FsQW5jaG9yQixcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgZmxvYXQgcmF0aW8pXHJcbiAgICAgICAgICAgIDogYmFzZShib2R5QSwgYm9keUIpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBKb2ludFR5cGUgPSBKb2ludFR5cGUuUHVsbGV5O1xyXG5cclxuICAgICAgICAgICAgR3JvdW5kQW5jaG9yQSA9IGdyb3VuZEFuY2hvckE7XHJcbiAgICAgICAgICAgIEdyb3VuZEFuY2hvckIgPSBncm91bmRBbmNob3JCO1xyXG4gICAgICAgICAgICBMb2NhbEFuY2hvckEgPSBsb2NhbEFuY2hvckE7XHJcbiAgICAgICAgICAgIExvY2FsQW5jaG9yQiA9IGxvY2FsQW5jaG9yQjtcclxuXHJcbiAgICAgICAgICAgIFZlY3RvcjIgZDEgPSBCb2R5QS5HZXRXb3JsZFBvaW50KGxvY2FsQW5jaG9yQSkgLSBncm91bmRBbmNob3JBO1xyXG4gICAgICAgICAgICBfbGVuZ3RoQSA9IGQxLkxlbmd0aCgpO1xyXG5cclxuICAgICAgICAgICAgVmVjdG9yMiBkMiA9IEJvZHlCLkdldFdvcmxkUG9pbnQobG9jYWxBbmNob3JCKSAtIGdyb3VuZEFuY2hvckI7XHJcbiAgICAgICAgICAgIF9sZW5ndGhCID0gZDIuTGVuZ3RoKCk7XHJcblxyXG4gICAgICAgICAgICBEZWJ1Zy5Bc3NlcnQocmF0aW8gIT0gMC4wZik7XHJcbiAgICAgICAgICAgIERlYnVnLkFzc2VydChyYXRpbyA+IFNldHRpbmdzLkVwc2lsb24pO1xyXG4gICAgICAgICAgICBSYXRpbyA9IHJhdGlvO1xyXG5cclxuICAgICAgICAgICAgZmxvYXQgQyA9IF9sZW5ndGhBICsgUmF0aW8gKiBfbGVuZ3RoQjtcclxuXHJcbiAgICAgICAgICAgIE1heExlbmd0aEEgPSBDIC0gUmF0aW8gKiBNaW5QdWxsZXlMZW5ndGg7XHJcbiAgICAgICAgICAgIE1heExlbmd0aEIgPSAoQyAtIE1pblB1bGxleUxlbmd0aCkgLyBSYXRpbztcclxuXHJcbiAgICAgICAgICAgIF9hbnQgPSBfbGVuZ3RoQSArIFJhdGlvICogX2xlbmd0aEI7XHJcblxyXG4gICAgICAgICAgICBNYXhMZW5ndGhBID0gTWF0aC5NaW4oTWF4TGVuZ3RoQSwgX2FudCAtIFJhdGlvICogTWluUHVsbGV5TGVuZ3RoKTtcclxuICAgICAgICAgICAgTWF4TGVuZ3RoQiA9IE1hdGguTWluKE1heExlbmd0aEIsIChfYW50IC0gTWluUHVsbGV5TGVuZ3RoKSAvIFJhdGlvKTtcclxuXHJcbiAgICAgICAgICAgIF9pbXB1bHNlID0gMC4wZjtcclxuICAgICAgICAgICAgX2xpbWl0SW1wdWxzZTEgPSAwLjBmO1xyXG4gICAgICAgICAgICBfbGltaXRJbXB1bHNlMiA9IDAuMGY7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwdWJsaWMgb3ZlcnJpZGUgVmVjdG9yMiBXb3JsZEFuY2hvckFcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGdldCB7IHJldHVybiBCb2R5QS5HZXRXb3JsZFBvaW50KExvY2FsQW5jaG9yQSk7IH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHB1YmxpYyBvdmVycmlkZSBWZWN0b3IyIFdvcmxkQW5jaG9yQlxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgZ2V0IHsgcmV0dXJuIEJvZHlCLkdldFdvcmxkUG9pbnQoTG9jYWxBbmNob3JCKTsgfVxyXG4gICAgICAgICAgICBzZXQgeyBEZWJ1Zy5Bc3NlcnQoZmFsc2UsIFwiWW91IGNhbid0IHNldCB0aGUgd29ybGQgYW5jaG9yIG9uIHRoaXMgam9pbnQgdHlwZS5cIik7IH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gR2V0IHRoZSBjdXJyZW50IGxlbmd0aCBvZiB0aGUgc2VnbWVudCBhdHRhY2hlZCB0byBib2R5MS5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8dmFsdWU+PC92YWx1ZT5cclxuICAgICAgICBwdWJsaWMgZmxvYXQgTGVuZ3RoQVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgZ2V0XHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIFZlY3RvcjIgZCA9IEJvZHlBLkdldFdvcmxkUG9pbnQoTG9jYWxBbmNob3JBKSAtIEdyb3VuZEFuY2hvckE7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZC5MZW5ndGgoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBzZXQgeyBfbGVuZ3RoQSA9IHZhbHVlOyB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIEdldCB0aGUgY3VycmVudCBsZW5ndGggb2YgdGhlIHNlZ21lbnQgYXR0YWNoZWQgdG8gYm9keTIuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHZhbHVlPjwvdmFsdWU+XHJcbiAgICAgICAgcHVibGljIGZsb2F0IExlbmd0aEJcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGdldFxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBWZWN0b3IyIGQgPSBCb2R5Qi5HZXRXb3JsZFBvaW50KExvY2FsQW5jaG9yQikgLSBHcm91bmRBbmNob3JCO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGQuTGVuZ3RoKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgc2V0IHsgX2xlbmd0aEIgPSB2YWx1ZTsgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBHZXQgdGhlIHB1bGxleSByYXRpby5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8dmFsdWU+PC92YWx1ZT5cclxuICAgICAgICBwdWJsaWMgZmxvYXQgUmF0aW8geyBnZXQ7IHNldDsgfVxyXG5cclxuICAgICAgICBwdWJsaWMgZmxvYXQgTWF4TGVuZ3RoQVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgZ2V0IHsgcmV0dXJuIF9tYXhMZW5ndGhBOyB9XHJcbiAgICAgICAgICAgIHNldCB7IF9tYXhMZW5ndGhBID0gdmFsdWU7IH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHB1YmxpYyBmbG9hdCBNYXhMZW5ndGhCXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBnZXQgeyByZXR1cm4gX21heExlbmd0aEI7IH1cclxuICAgICAgICAgICAgc2V0IHsgX21heExlbmd0aEIgPSB2YWx1ZTsgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHVibGljIG92ZXJyaWRlIFZlY3RvcjIgR2V0UmVhY3Rpb25Gb3JjZShmbG9hdCBpbnZfZHQpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBWZWN0b3IyIFAgPSBfaW1wdWxzZSAqIF91MjtcclxuICAgICAgICAgICAgcmV0dXJuIGludl9kdCAqIFA7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwdWJsaWMgb3ZlcnJpZGUgZmxvYXQgR2V0UmVhY3Rpb25Ub3JxdWUoZmxvYXQgaW52X2R0KVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIDAuMGY7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpbnRlcm5hbCBvdmVycmlkZSB2b2lkIEluaXRWZWxvY2l0eUNvbnN0cmFpbnRzKHJlZiBUaW1lU3RlcCBzdGVwKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgQm9keSBiMSA9IEJvZHlBO1xyXG4gICAgICAgICAgICBCb2R5IGIyID0gQm9keUI7XHJcblxyXG4gICAgICAgICAgICBUcmFuc2Zvcm0geGYxLCB4ZjI7XHJcbiAgICAgICAgICAgIGIxLkdldFRyYW5zZm9ybShvdXQgeGYxKTtcclxuICAgICAgICAgICAgYjIuR2V0VHJhbnNmb3JtKG91dCB4ZjIpO1xyXG5cclxuICAgICAgICAgICAgVmVjdG9yMiByMSA9IE1hdGhVdGlscy5NdWx0aXBseShyZWYgeGYxLlIsIExvY2FsQW5jaG9yQSAtIGIxLkxvY2FsQ2VudGVyKTtcclxuICAgICAgICAgICAgVmVjdG9yMiByMiA9IE1hdGhVdGlscy5NdWx0aXBseShyZWYgeGYyLlIsIExvY2FsQW5jaG9yQiAtIGIyLkxvY2FsQ2VudGVyKTtcclxuXHJcbiAgICAgICAgICAgIFZlY3RvcjIgcDEgPSBiMS5Td2VlcC5DICsgcjE7XHJcbiAgICAgICAgICAgIFZlY3RvcjIgcDIgPSBiMi5Td2VlcC5DICsgcjI7XHJcblxyXG4gICAgICAgICAgICBWZWN0b3IyIHMxID0gR3JvdW5kQW5jaG9yQTtcclxuICAgICAgICAgICAgVmVjdG9yMiBzMiA9IEdyb3VuZEFuY2hvckI7XHJcblxyXG4gICAgICAgICAgICAvLyBHZXQgdGhlIHB1bGxleSBheGVzLlxyXG4gICAgICAgICAgICBfdTEgPSBwMSAtIHMxO1xyXG4gICAgICAgICAgICBfdTIgPSBwMiAtIHMyO1xyXG5cclxuICAgICAgICAgICAgZmxvYXQgbGVuZ3RoMSA9IF91MS5MZW5ndGgoKTtcclxuICAgICAgICAgICAgZmxvYXQgbGVuZ3RoMiA9IF91Mi5MZW5ndGgoKTtcclxuXHJcbiAgICAgICAgICAgIGlmIChsZW5ndGgxID4gU2V0dGluZ3MuTGluZWFyU2xvcClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgX3UxICo9IDEuMGYgLyBsZW5ndGgxO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgX3UxID0gVmVjdG9yMi5aZXJvO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAobGVuZ3RoMiA+IFNldHRpbmdzLkxpbmVhclNsb3ApXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIF91MiAqPSAxLjBmIC8gbGVuZ3RoMjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIF91MiA9IFZlY3RvcjIuWmVybztcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgZmxvYXQgQyA9IF9hbnQgLSBsZW5ndGgxIC0gUmF0aW8gKiBsZW5ndGgyO1xyXG4gICAgICAgICAgICBpZiAoQyA+IDAuMGYpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIF9zdGF0ZSA9IExpbWl0U3RhdGUuSW5hY3RpdmU7XHJcbiAgICAgICAgICAgICAgICBfaW1wdWxzZSA9IDAuMGY7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBfc3RhdGUgPSBMaW1pdFN0YXRlLkF0VXBwZXI7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmIChsZW5ndGgxIDwgTWF4TGVuZ3RoQSlcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgX2xpbWl0U3RhdGUxID0gTGltaXRTdGF0ZS5JbmFjdGl2ZTtcclxuICAgICAgICAgICAgICAgIF9saW1pdEltcHVsc2UxID0gMC4wZjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIF9saW1pdFN0YXRlMSA9IExpbWl0U3RhdGUuQXRVcHBlcjtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKGxlbmd0aDIgPCBNYXhMZW5ndGhCKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBfbGltaXRTdGF0ZTIgPSBMaW1pdFN0YXRlLkluYWN0aXZlO1xyXG4gICAgICAgICAgICAgICAgX2xpbWl0SW1wdWxzZTIgPSAwLjBmO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgX2xpbWl0U3RhdGUyID0gTGltaXRTdGF0ZS5BdFVwcGVyO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBDb21wdXRlIGVmZmVjdGl2ZSBtYXNzLlxyXG4gICAgICAgICAgICBmbG9hdCBjcjF1MSA9IE1hdGhVdGlscy5Dcm9zcyhyMSwgX3UxKTtcclxuICAgICAgICAgICAgZmxvYXQgY3IydTIgPSBNYXRoVXRpbHMuQ3Jvc3MocjIsIF91Mik7XHJcblxyXG4gICAgICAgICAgICBfbGltaXRNYXNzMSA9IGIxLkludk1hc3MgKyBiMS5JbnZJICogY3IxdTEgKiBjcjF1MTtcclxuICAgICAgICAgICAgX2xpbWl0TWFzczIgPSBiMi5JbnZNYXNzICsgYjIuSW52SSAqIGNyMnUyICogY3IydTI7XHJcbiAgICAgICAgICAgIF9wdWxsZXlNYXNzID0gX2xpbWl0TWFzczEgKyBSYXRpbyAqIFJhdGlvICogX2xpbWl0TWFzczI7XHJcbiAgICAgICAgICAgIERlYnVnLkFzc2VydChfbGltaXRNYXNzMSA+IFNldHRpbmdzLkVwc2lsb24pO1xyXG4gICAgICAgICAgICBEZWJ1Zy5Bc3NlcnQoX2xpbWl0TWFzczIgPiBTZXR0aW5ncy5FcHNpbG9uKTtcclxuICAgICAgICAgICAgRGVidWcuQXNzZXJ0KF9wdWxsZXlNYXNzID4gU2V0dGluZ3MuRXBzaWxvbik7XHJcbiAgICAgICAgICAgIF9saW1pdE1hc3MxID0gMS4wZiAvIF9saW1pdE1hc3MxO1xyXG4gICAgICAgICAgICBfbGltaXRNYXNzMiA9IDEuMGYgLyBfbGltaXRNYXNzMjtcclxuICAgICAgICAgICAgX3B1bGxleU1hc3MgPSAxLjBmIC8gX3B1bGxleU1hc3M7XHJcblxyXG4gICAgICAgICAgICBpZiAoU2V0dGluZ3MuRW5hYmxlV2FybXN0YXJ0aW5nKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAvLyBTY2FsZSBpbXB1bHNlcyB0byBzdXBwb3J0IHZhcmlhYmxlIHRpbWUgc3RlcHMuXHJcbiAgICAgICAgICAgICAgICBfaW1wdWxzZSAqPSBzdGVwLmR0UmF0aW87XHJcbiAgICAgICAgICAgICAgICBfbGltaXRJbXB1bHNlMSAqPSBzdGVwLmR0UmF0aW87XHJcbiAgICAgICAgICAgICAgICBfbGltaXRJbXB1bHNlMiAqPSBzdGVwLmR0UmF0aW87XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gV2FybSBzdGFydGluZy5cclxuICAgICAgICAgICAgICAgIFZlY3RvcjIgUDEgPSAtKF9pbXB1bHNlICsgX2xpbWl0SW1wdWxzZTEpICogX3UxO1xyXG4gICAgICAgICAgICAgICAgVmVjdG9yMiBQMiA9ICgtUmF0aW8gKiBfaW1wdWxzZSAtIF9saW1pdEltcHVsc2UyKSAqIF91MjtcclxuICAgICAgICAgICAgICAgIGIxLkxpbmVhclZlbG9jaXR5SW50ZXJuYWwgKz0gYjEuSW52TWFzcyAqIFAxO1xyXG4gICAgICAgICAgICAgICAgYjEuQW5ndWxhclZlbG9jaXR5SW50ZXJuYWwgKz0gYjEuSW52SSAqIE1hdGhVdGlscy5Dcm9zcyhyMSwgUDEpO1xyXG4gICAgICAgICAgICAgICAgYjIuTGluZWFyVmVsb2NpdHlJbnRlcm5hbCArPSBiMi5JbnZNYXNzICogUDI7XHJcbiAgICAgICAgICAgICAgICBiMi5Bbmd1bGFyVmVsb2NpdHlJbnRlcm5hbCArPSBiMi5JbnZJICogTWF0aFV0aWxzLkNyb3NzKHIyLCBQMik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBfaW1wdWxzZSA9IDAuMGY7XHJcbiAgICAgICAgICAgICAgICBfbGltaXRJbXB1bHNlMSA9IDAuMGY7XHJcbiAgICAgICAgICAgICAgICBfbGltaXRJbXB1bHNlMiA9IDAuMGY7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGludGVybmFsIG92ZXJyaWRlIHZvaWQgU29sdmVWZWxvY2l0eUNvbnN0cmFpbnRzKHJlZiBUaW1lU3RlcCBzdGVwKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgQm9keSBiMSA9IEJvZHlBO1xyXG4gICAgICAgICAgICBCb2R5IGIyID0gQm9keUI7XHJcblxyXG4gICAgICAgICAgICBUcmFuc2Zvcm0geGYxLCB4ZjI7XHJcbiAgICAgICAgICAgIGIxLkdldFRyYW5zZm9ybShvdXQgeGYxKTtcclxuICAgICAgICAgICAgYjIuR2V0VHJhbnNmb3JtKG91dCB4ZjIpO1xyXG5cclxuICAgICAgICAgICAgVmVjdG9yMiByMSA9IE1hdGhVdGlscy5NdWx0aXBseShyZWYgeGYxLlIsIExvY2FsQW5jaG9yQSAtIGIxLkxvY2FsQ2VudGVyKTtcclxuICAgICAgICAgICAgVmVjdG9yMiByMiA9IE1hdGhVdGlscy5NdWx0aXBseShyZWYgeGYyLlIsIExvY2FsQW5jaG9yQiAtIGIyLkxvY2FsQ2VudGVyKTtcclxuXHJcbiAgICAgICAgICAgIGlmIChfc3RhdGUgPT0gTGltaXRTdGF0ZS5BdFVwcGVyKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBWZWN0b3IyIHYxID0gYjEuTGluZWFyVmVsb2NpdHlJbnRlcm5hbCArIE1hdGhVdGlscy5Dcm9zcyhiMS5Bbmd1bGFyVmVsb2NpdHlJbnRlcm5hbCwgcjEpO1xyXG4gICAgICAgICAgICAgICAgVmVjdG9yMiB2MiA9IGIyLkxpbmVhclZlbG9jaXR5SW50ZXJuYWwgKyBNYXRoVXRpbHMuQ3Jvc3MoYjIuQW5ndWxhclZlbG9jaXR5SW50ZXJuYWwsIHIyKTtcclxuXHJcbiAgICAgICAgICAgICAgICBmbG9hdCBDZG90ID0gLVZlY3RvcjIuRG90KF91MSwgdjEpIC0gUmF0aW8gKiBWZWN0b3IyLkRvdChfdTIsIHYyKTtcclxuICAgICAgICAgICAgICAgIGZsb2F0IGltcHVsc2UgPSBfcHVsbGV5TWFzcyAqICgtQ2RvdCk7XHJcbiAgICAgICAgICAgICAgICBmbG9hdCBvbGRJbXB1bHNlID0gX2ltcHVsc2U7XHJcbiAgICAgICAgICAgICAgICBfaW1wdWxzZSA9IE1hdGguTWF4KDAuMGYsIF9pbXB1bHNlICsgaW1wdWxzZSk7XHJcbiAgICAgICAgICAgICAgICBpbXB1bHNlID0gX2ltcHVsc2UgLSBvbGRJbXB1bHNlO1xyXG5cclxuICAgICAgICAgICAgICAgIFZlY3RvcjIgUDEgPSAtaW1wdWxzZSAqIF91MTtcclxuICAgICAgICAgICAgICAgIFZlY3RvcjIgUDIgPSAtUmF0aW8gKiBpbXB1bHNlICogX3UyO1xyXG4gICAgICAgICAgICAgICAgYjEuTGluZWFyVmVsb2NpdHlJbnRlcm5hbCArPSBiMS5JbnZNYXNzICogUDE7XHJcbiAgICAgICAgICAgICAgICBiMS5Bbmd1bGFyVmVsb2NpdHlJbnRlcm5hbCArPSBiMS5JbnZJICogTWF0aFV0aWxzLkNyb3NzKHIxLCBQMSk7XHJcbiAgICAgICAgICAgICAgICBiMi5MaW5lYXJWZWxvY2l0eUludGVybmFsICs9IGIyLkludk1hc3MgKiBQMjtcclxuICAgICAgICAgICAgICAgIGIyLkFuZ3VsYXJWZWxvY2l0eUludGVybmFsICs9IGIyLkludkkgKiBNYXRoVXRpbHMuQ3Jvc3MocjIsIFAyKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKF9saW1pdFN0YXRlMSA9PSBMaW1pdFN0YXRlLkF0VXBwZXIpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIFZlY3RvcjIgdjEgPSBiMS5MaW5lYXJWZWxvY2l0eUludGVybmFsICsgTWF0aFV0aWxzLkNyb3NzKGIxLkFuZ3VsYXJWZWxvY2l0eUludGVybmFsLCByMSk7XHJcblxyXG4gICAgICAgICAgICAgICAgZmxvYXQgQ2RvdCA9IC1WZWN0b3IyLkRvdChfdTEsIHYxKTtcclxuICAgICAgICAgICAgICAgIGZsb2F0IGltcHVsc2UgPSAtX2xpbWl0TWFzczEgKiBDZG90O1xyXG4gICAgICAgICAgICAgICAgZmxvYXQgb2xkSW1wdWxzZSA9IF9saW1pdEltcHVsc2UxO1xyXG4gICAgICAgICAgICAgICAgX2xpbWl0SW1wdWxzZTEgPSBNYXRoLk1heCgwLjBmLCBfbGltaXRJbXB1bHNlMSArIGltcHVsc2UpO1xyXG4gICAgICAgICAgICAgICAgaW1wdWxzZSA9IF9saW1pdEltcHVsc2UxIC0gb2xkSW1wdWxzZTtcclxuXHJcbiAgICAgICAgICAgICAgICBWZWN0b3IyIFAxID0gLWltcHVsc2UgKiBfdTE7XHJcbiAgICAgICAgICAgICAgICBiMS5MaW5lYXJWZWxvY2l0eUludGVybmFsICs9IGIxLkludk1hc3MgKiBQMTtcclxuICAgICAgICAgICAgICAgIGIxLkFuZ3VsYXJWZWxvY2l0eUludGVybmFsICs9IGIxLkludkkgKiBNYXRoVXRpbHMuQ3Jvc3MocjEsIFAxKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKF9saW1pdFN0YXRlMiA9PSBMaW1pdFN0YXRlLkF0VXBwZXIpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIFZlY3RvcjIgdjIgPSBiMi5MaW5lYXJWZWxvY2l0eUludGVybmFsICsgTWF0aFV0aWxzLkNyb3NzKGIyLkFuZ3VsYXJWZWxvY2l0eUludGVybmFsLCByMik7XHJcblxyXG4gICAgICAgICAgICAgICAgZmxvYXQgQ2RvdCA9IC1WZWN0b3IyLkRvdChfdTIsIHYyKTtcclxuICAgICAgICAgICAgICAgIGZsb2F0IGltcHVsc2UgPSAtX2xpbWl0TWFzczIgKiBDZG90O1xyXG4gICAgICAgICAgICAgICAgZmxvYXQgb2xkSW1wdWxzZSA9IF9saW1pdEltcHVsc2UyO1xyXG4gICAgICAgICAgICAgICAgX2xpbWl0SW1wdWxzZTIgPSBNYXRoLk1heCgwLjBmLCBfbGltaXRJbXB1bHNlMiArIGltcHVsc2UpO1xyXG4gICAgICAgICAgICAgICAgaW1wdWxzZSA9IF9saW1pdEltcHVsc2UyIC0gb2xkSW1wdWxzZTtcclxuXHJcbiAgICAgICAgICAgICAgICBWZWN0b3IyIFAyID0gLWltcHVsc2UgKiBfdTI7XHJcbiAgICAgICAgICAgICAgICBiMi5MaW5lYXJWZWxvY2l0eUludGVybmFsICs9IGIyLkludk1hc3MgKiBQMjtcclxuICAgICAgICAgICAgICAgIGIyLkFuZ3VsYXJWZWxvY2l0eUludGVybmFsICs9IGIyLkludkkgKiBNYXRoVXRpbHMuQ3Jvc3MocjIsIFAyKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaW50ZXJuYWwgb3ZlcnJpZGUgYm9vbCBTb2x2ZVBvc2l0aW9uQ29uc3RyYWludHMoKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgQm9keSBiMSA9IEJvZHlBO1xyXG4gICAgICAgICAgICBCb2R5IGIyID0gQm9keUI7XHJcblxyXG4gICAgICAgICAgICBWZWN0b3IyIHMxID0gR3JvdW5kQW5jaG9yQTtcclxuICAgICAgICAgICAgVmVjdG9yMiBzMiA9IEdyb3VuZEFuY2hvckI7XHJcblxyXG4gICAgICAgICAgICBmbG9hdCBsaW5lYXJFcnJvciA9IDAuMGY7XHJcblxyXG4gICAgICAgICAgICBpZiAoX3N0YXRlID09IExpbWl0U3RhdGUuQXRVcHBlcilcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgVHJhbnNmb3JtIHhmMSwgeGYyO1xyXG4gICAgICAgICAgICAgICAgYjEuR2V0VHJhbnNmb3JtKG91dCB4ZjEpO1xyXG4gICAgICAgICAgICAgICAgYjIuR2V0VHJhbnNmb3JtKG91dCB4ZjIpO1xyXG5cclxuICAgICAgICAgICAgICAgIFZlY3RvcjIgcjEgPSBNYXRoVXRpbHMuTXVsdGlwbHkocmVmIHhmMS5SLCBMb2NhbEFuY2hvckEgLSBiMS5Mb2NhbENlbnRlcik7XHJcbiAgICAgICAgICAgICAgICBWZWN0b3IyIHIyID0gTWF0aFV0aWxzLk11bHRpcGx5KHJlZiB4ZjIuUiwgTG9jYWxBbmNob3JCIC0gYjIuTG9jYWxDZW50ZXIpO1xyXG5cclxuICAgICAgICAgICAgICAgIFZlY3RvcjIgcDEgPSBiMS5Td2VlcC5DICsgcjE7XHJcbiAgICAgICAgICAgICAgICBWZWN0b3IyIHAyID0gYjIuU3dlZXAuQyArIHIyO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIEdldCB0aGUgcHVsbGV5IGF4ZXMuXHJcbiAgICAgICAgICAgICAgICBfdTEgPSBwMSAtIHMxO1xyXG4gICAgICAgICAgICAgICAgX3UyID0gcDIgLSBzMjtcclxuXHJcbiAgICAgICAgICAgICAgICBmbG9hdCBsZW5ndGgxID0gX3UxLkxlbmd0aCgpO1xyXG4gICAgICAgICAgICAgICAgZmxvYXQgbGVuZ3RoMiA9IF91Mi5MZW5ndGgoKTtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAobGVuZ3RoMSA+IFNldHRpbmdzLkxpbmVhclNsb3ApXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgX3UxICo9IDEuMGYgLyBsZW5ndGgxO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIF91MSA9IFZlY3RvcjIuWmVybztcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBpZiAobGVuZ3RoMiA+IFNldHRpbmdzLkxpbmVhclNsb3ApXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgX3UyICo9IDEuMGYgLyBsZW5ndGgyO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIF91MiA9IFZlY3RvcjIuWmVybztcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBmbG9hdCBDID0gX2FudCAtIGxlbmd0aDEgLSBSYXRpbyAqIGxlbmd0aDI7XHJcbiAgICAgICAgICAgICAgICBsaW5lYXJFcnJvciA9IE1hdGguTWF4KGxpbmVhckVycm9yLCAtQyk7XHJcblxyXG4gICAgICAgICAgICAgICAgQyA9IE1hdGhVdGlscy5DbGFtcChDICsgU2V0dGluZ3MuTGluZWFyU2xvcCwgLVNldHRpbmdzLk1heExpbmVhckNvcnJlY3Rpb24sIDAuMGYpO1xyXG4gICAgICAgICAgICAgICAgZmxvYXQgaW1wdWxzZSA9IC1fcHVsbGV5TWFzcyAqIEM7XHJcblxyXG4gICAgICAgICAgICAgICAgVmVjdG9yMiBQMSA9IC1pbXB1bHNlICogX3UxO1xyXG4gICAgICAgICAgICAgICAgVmVjdG9yMiBQMiA9IC1SYXRpbyAqIGltcHVsc2UgKiBfdTI7XHJcblxyXG4gICAgICAgICAgICAgICAgYjEuU3dlZXAuQyArPSBiMS5JbnZNYXNzICogUDE7XHJcbiAgICAgICAgICAgICAgICBiMS5Td2VlcC5BICs9IGIxLkludkkgKiBNYXRoVXRpbHMuQ3Jvc3MocjEsIFAxKTtcclxuICAgICAgICAgICAgICAgIGIyLlN3ZWVwLkMgKz0gYjIuSW52TWFzcyAqIFAyO1xyXG4gICAgICAgICAgICAgICAgYjIuU3dlZXAuQSArPSBiMi5JbnZJICogTWF0aFV0aWxzLkNyb3NzKHIyLCBQMik7XHJcblxyXG4gICAgICAgICAgICAgICAgYjEuU3luY2hyb25pemVUcmFuc2Zvcm0oKTtcclxuICAgICAgICAgICAgICAgIGIyLlN5bmNocm9uaXplVHJhbnNmb3JtKCk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmIChfbGltaXRTdGF0ZTEgPT0gTGltaXRTdGF0ZS5BdFVwcGVyKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBUcmFuc2Zvcm0geGYxO1xyXG4gICAgICAgICAgICAgICAgYjEuR2V0VHJhbnNmb3JtKG91dCB4ZjEpO1xyXG5cclxuICAgICAgICAgICAgICAgIFZlY3RvcjIgcjEgPSBNYXRoVXRpbHMuTXVsdGlwbHkocmVmIHhmMS5SLCBMb2NhbEFuY2hvckEgLSBiMS5Mb2NhbENlbnRlcik7XHJcbiAgICAgICAgICAgICAgICBWZWN0b3IyIHAxID0gYjEuU3dlZXAuQyArIHIxO1xyXG5cclxuICAgICAgICAgICAgICAgIF91MSA9IHAxIC0gczE7XHJcbiAgICAgICAgICAgICAgICBmbG9hdCBsZW5ndGgxID0gX3UxLkxlbmd0aCgpO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmIChsZW5ndGgxID4gU2V0dGluZ3MuTGluZWFyU2xvcClcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBfdTEgKj0gMS4wZiAvIGxlbmd0aDE7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgX3UxID0gVmVjdG9yMi5aZXJvO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGZsb2F0IEMgPSBNYXhMZW5ndGhBIC0gbGVuZ3RoMTtcclxuICAgICAgICAgICAgICAgIGxpbmVhckVycm9yID0gTWF0aC5NYXgobGluZWFyRXJyb3IsIC1DKTtcclxuICAgICAgICAgICAgICAgIEMgPSBNYXRoVXRpbHMuQ2xhbXAoQyArIFNldHRpbmdzLkxpbmVhclNsb3AsIC1TZXR0aW5ncy5NYXhMaW5lYXJDb3JyZWN0aW9uLCAwLjBmKTtcclxuICAgICAgICAgICAgICAgIGZsb2F0IGltcHVsc2UgPSAtX2xpbWl0TWFzczEgKiBDO1xyXG5cclxuICAgICAgICAgICAgICAgIFZlY3RvcjIgUDEgPSAtaW1wdWxzZSAqIF91MTtcclxuICAgICAgICAgICAgICAgIGIxLlN3ZWVwLkMgKz0gYjEuSW52TWFzcyAqIFAxO1xyXG4gICAgICAgICAgICAgICAgYjEuU3dlZXAuQSArPSBiMS5JbnZJICogTWF0aFV0aWxzLkNyb3NzKHIxLCBQMSk7XHJcblxyXG4gICAgICAgICAgICAgICAgYjEuU3luY2hyb25pemVUcmFuc2Zvcm0oKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKF9saW1pdFN0YXRlMiA9PSBMaW1pdFN0YXRlLkF0VXBwZXIpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIFRyYW5zZm9ybSB4ZjI7XHJcbiAgICAgICAgICAgICAgICBiMi5HZXRUcmFuc2Zvcm0ob3V0IHhmMik7XHJcblxyXG4gICAgICAgICAgICAgICAgVmVjdG9yMiByMiA9IE1hdGhVdGlscy5NdWx0aXBseShyZWYgeGYyLlIsIExvY2FsQW5jaG9yQiAtIGIyLkxvY2FsQ2VudGVyKTtcclxuICAgICAgICAgICAgICAgIFZlY3RvcjIgcDIgPSBiMi5Td2VlcC5DICsgcjI7XHJcblxyXG4gICAgICAgICAgICAgICAgX3UyID0gcDIgLSBzMjtcclxuICAgICAgICAgICAgICAgIGZsb2F0IGxlbmd0aDIgPSBfdTIuTGVuZ3RoKCk7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKGxlbmd0aDIgPiBTZXR0aW5ncy5MaW5lYXJTbG9wKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIF91MiAqPSAxLjBmIC8gbGVuZ3RoMjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBfdTIgPSBWZWN0b3IyLlplcm87XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgZmxvYXQgQyA9IE1heExlbmd0aEIgLSBsZW5ndGgyO1xyXG4gICAgICAgICAgICAgICAgbGluZWFyRXJyb3IgPSBNYXRoLk1heChsaW5lYXJFcnJvciwgLUMpO1xyXG4gICAgICAgICAgICAgICAgQyA9IE1hdGhVdGlscy5DbGFtcChDICsgU2V0dGluZ3MuTGluZWFyU2xvcCwgLVNldHRpbmdzLk1heExpbmVhckNvcnJlY3Rpb24sIDAuMGYpO1xyXG4gICAgICAgICAgICAgICAgZmxvYXQgaW1wdWxzZSA9IC1fbGltaXRNYXNzMiAqIEM7XHJcblxyXG4gICAgICAgICAgICAgICAgVmVjdG9yMiBQMiA9IC1pbXB1bHNlICogX3UyO1xyXG4gICAgICAgICAgICAgICAgYjIuU3dlZXAuQyArPSBiMi5JbnZNYXNzICogUDI7XHJcbiAgICAgICAgICAgICAgICBiMi5Td2VlcC5BICs9IGIyLkludkkgKiBNYXRoVXRpbHMuQ3Jvc3MocjIsIFAyKTtcclxuXHJcbiAgICAgICAgICAgICAgICBiMi5TeW5jaHJvbml6ZVRyYW5zZm9ybSgpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gbGluZWFyRXJyb3IgPCBTZXR0aW5ncy5MaW5lYXJTbG9wO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufSIsIi8qXHJcbiogRmFyc2VlciBQaHlzaWNzIEVuZ2luZSBiYXNlZCBvbiBCb3gyRC5YTkEgcG9ydDpcclxuKiBDb3B5cmlnaHQgKGMpIDIwMTAgSWFuIFF2aXN0XHJcbiogXHJcbiogQm94MkQuWE5BIHBvcnQgb2YgQm94MkQ6XHJcbiogQ29weXJpZ2h0IChjKSAyMDA5IEJyYW5kb24gRnVydHdhbmdsZXIsIE5hdGhhbiBGdXJ0d2FuZ2xlclxyXG4qXHJcbiogT3JpZ2luYWwgc291cmNlIEJveDJEOlxyXG4qIENvcHlyaWdodCAoYykgMjAwNi0yMDA5IEVyaW4gQ2F0dG8gaHR0cDovL3d3dy5ncGh5c2ljcy5jb20gXHJcbiogXHJcbiogVGhpcyBzb2Z0d2FyZSBpcyBwcm92aWRlZCAnYXMtaXMnLCB3aXRob3V0IGFueSBleHByZXNzIG9yIGltcGxpZWQgXHJcbiogd2FycmFudHkuICBJbiBubyBldmVudCB3aWxsIHRoZSBhdXRob3JzIGJlIGhlbGQgbGlhYmxlIGZvciBhbnkgZGFtYWdlcyBcclxuKiBhcmlzaW5nIGZyb20gdGhlIHVzZSBvZiB0aGlzIHNvZnR3YXJlLiBcclxuKiBQZXJtaXNzaW9uIGlzIGdyYW50ZWQgdG8gYW55b25lIHRvIHVzZSB0aGlzIHNvZnR3YXJlIGZvciBhbnkgcHVycG9zZSwgXHJcbiogaW5jbHVkaW5nIGNvbW1lcmNpYWwgYXBwbGljYXRpb25zLCBhbmQgdG8gYWx0ZXIgaXQgYW5kIHJlZGlzdHJpYnV0ZSBpdCBcclxuKiBmcmVlbHksIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyByZXN0cmljdGlvbnM6IFxyXG4qIDEuIFRoZSBvcmlnaW4gb2YgdGhpcyBzb2Z0d2FyZSBtdXN0IG5vdCBiZSBtaXNyZXByZXNlbnRlZDsgeW91IG11c3Qgbm90IFxyXG4qIGNsYWltIHRoYXQgeW91IHdyb3RlIHRoZSBvcmlnaW5hbCBzb2Z0d2FyZS4gSWYgeW91IHVzZSB0aGlzIHNvZnR3YXJlIFxyXG4qIGluIGEgcHJvZHVjdCwgYW4gYWNrbm93bGVkZ21lbnQgaW4gdGhlIHByb2R1Y3QgZG9jdW1lbnRhdGlvbiB3b3VsZCBiZSBcclxuKiBhcHByZWNpYXRlZCBidXQgaXMgbm90IHJlcXVpcmVkLiBcclxuKiAyLiBBbHRlcmVkIHNvdXJjZSB2ZXJzaW9ucyBtdXN0IGJlIHBsYWlubHkgbWFya2VkIGFzIHN1Y2gsIGFuZCBtdXN0IG5vdCBiZSBcclxuKiBtaXNyZXByZXNlbnRlZCBhcyBiZWluZyB0aGUgb3JpZ2luYWwgc29mdHdhcmUuIFxyXG4qIDMuIFRoaXMgbm90aWNlIG1heSBub3QgYmUgcmVtb3ZlZCBvciBhbHRlcmVkIGZyb20gYW55IHNvdXJjZSBkaXN0cmlidXRpb24uIFxyXG4qL1xyXG5cclxudXNpbmcgU3lzdGVtO1xyXG51c2luZyBTeXN0ZW0uRGlhZ25vc3RpY3M7XHJcbnVzaW5nIEZhcnNlZXJQaHlzaWNzLkNvbW1vbjtcclxudXNpbmcgTWljcm9zb2Z0LlhuYS5GcmFtZXdvcms7XHJcblxyXG5uYW1lc3BhY2UgRmFyc2VlclBoeXNpY3MuRHluYW1pY3MuSm9pbnRzXHJcbntcclxuICAgIC8vLyA8c3VtbWFyeT5cclxuICAgIC8vLyBBIHJldm9sdXRlIGpvaW50IHJhaW5zIHRvIGJvZGllcyB0byBzaGFyZSBhIGNvbW1vbiBwb2ludCB3aGlsZSB0aGV5XHJcbiAgICAvLy8gYXJlIGZyZWUgdG8gcm90YXRlIGFib3V0IHRoZSBwb2ludC4gVGhlIHJlbGF0aXZlIHJvdGF0aW9uIGFib3V0IHRoZSBzaGFyZWRcclxuICAgIC8vLyBwb2ludCBpcyB0aGUgam9pbnQgYW5nbGUuIFlvdSBjYW4gbGltaXQgdGhlIHJlbGF0aXZlIHJvdGF0aW9uIHdpdGhcclxuICAgIC8vLyBhIGpvaW50IGxpbWl0IHRoYXQgc3BlY2lmaWVzIGEgbG93ZXIgYW5kIHVwcGVyIGFuZ2xlLiBZb3UgY2FuIHVzZSBhIG1vdG9yXHJcbiAgICAvLy8gdG8gZHJpdmUgdGhlIHJlbGF0aXZlIHJvdGF0aW9uIGFib3V0IHRoZSBzaGFyZWQgcG9pbnQuIEEgbWF4aW11bSBtb3RvciB0b3JxdWVcclxuICAgIC8vLyBpcyBwcm92aWRlZCBzbyB0aGF0IGluZmluaXRlIGZvcmNlcyBhcmUgbm90IGdlbmVyYXRlZC5cclxuICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICBwdWJsaWMgY2xhc3MgUmV2b2x1dGVKb2ludCA6IEpvaW50XHJcbiAgICB7XHJcbiAgICAgICAgcHVibGljIFZlY3RvcjIgTG9jYWxBbmNob3JBO1xyXG5cclxuICAgICAgICBwdWJsaWMgVmVjdG9yMiBMb2NhbEFuY2hvckI7XHJcbiAgICAgICAgcHJpdmF0ZSBib29sIF9lbmFibGVMaW1pdDtcclxuICAgICAgICBwcml2YXRlIGJvb2wgX2VuYWJsZU1vdG9yO1xyXG4gICAgICAgIHByaXZhdGUgVmVjdG9yMyBfaW1wdWxzZTtcclxuICAgICAgICBwcml2YXRlIExpbWl0U3RhdGUgX2xpbWl0U3RhdGU7XHJcbiAgICAgICAgcHJpdmF0ZSBmbG9hdCBfbG93ZXJBbmdsZTtcclxuICAgICAgICBwcml2YXRlIE1hdDMzIF9tYXNzOyAvLyBlZmZlY3RpdmUgbWFzcyBmb3IgcG9pbnQtdG8tcG9pbnQgY29uc3RyYWludC5cclxuICAgICAgICBwcml2YXRlIGZsb2F0IF9tYXhNb3RvclRvcnF1ZTtcclxuICAgICAgICBwcml2YXRlIGZsb2F0IF9tb3RvckltcHVsc2U7XHJcbiAgICAgICAgcHJpdmF0ZSBmbG9hdCBfbW90b3JNYXNzOyAvLyBlZmZlY3RpdmUgbWFzcyBmb3IgbW90b3IvbGltaXQgYW5ndWxhciBjb25zdHJhaW50LlxyXG4gICAgICAgIHByaXZhdGUgZmxvYXQgX21vdG9yU3BlZWQ7XHJcbiAgICAgICAgcHJpdmF0ZSBmbG9hdCBfcmVmZXJlbmNlQW5nbGU7XHJcbiAgICAgICAgcHJpdmF0ZSBmbG9hdCBfdG1wRmxvYXQxO1xyXG4gICAgICAgIHByaXZhdGUgVmVjdG9yMiBfdG1wVmVjdG9yMSwgX3RtcFZlY3RvcjI7XHJcbiAgICAgICAgcHJpdmF0ZSBmbG9hdCBfdXBwZXJBbmdsZTtcclxuXHJcbiAgICAgICAgaW50ZXJuYWwgUmV2b2x1dGVKb2ludCgpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBKb2ludFR5cGUgPSBKb2ludFR5cGUuUmV2b2x1dGU7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIEluaXRpYWxpemUgdGhlIGJvZGllcyBhbmQgbG9jYWwgYW5jaG9yLlxyXG4gICAgICAgIC8vLyBUaGlzIHJlcXVpcmVzIGRlZmluaW5nIGFuXHJcbiAgICAgICAgLy8vIGFuY2hvciBwb2ludCB3aGVyZSB0aGUgYm9kaWVzIGFyZSBqb2luZWQuIFRoZSBkZWZpbml0aW9uXHJcbiAgICAgICAgLy8vIHVzZXMgbG9jYWwgYW5jaG9yIHBvaW50cyBzbyB0aGF0IHRoZSBpbml0aWFsIGNvbmZpZ3VyYXRpb25cclxuICAgICAgICAvLy8gY2FuIHZpb2xhdGUgdGhlIGNvbnN0cmFpbnQgc2xpZ2h0bHkuIFlvdSBhbHNvIG5lZWQgdG9cclxuICAgICAgICAvLy8gc3BlY2lmeSB0aGUgaW5pdGlhbCByZWxhdGl2ZSBhbmdsZSBmb3Igam9pbnQgbGltaXRzLiBUaGlzXHJcbiAgICAgICAgLy8vIGhlbHBzIHdoZW4gc2F2aW5nIGFuZCBsb2FkaW5nIGEgZ2FtZS5cclxuICAgICAgICAvLy8gVGhlIGxvY2FsIGFuY2hvciBwb2ludHMgYXJlIG1lYXN1cmVkIGZyb20gdGhlIGJvZHkncyBvcmlnaW5cclxuICAgICAgICAvLy8gcmF0aGVyIHRoYW4gdGhlIGNlbnRlciBvZiBtYXNzIGJlY2F1c2U6XHJcbiAgICAgICAgLy8vIDEuIHlvdSBtaWdodCBub3Qga25vdyB3aGVyZSB0aGUgY2VudGVyIG9mIG1hc3Mgd2lsbCBiZS5cclxuICAgICAgICAvLy8gMi4gaWYgeW91IGFkZC9yZW1vdmUgc2hhcGVzIGZyb20gYSBib2R5IGFuZCByZWNvbXB1dGUgdGhlIG1hc3MsXHJcbiAgICAgICAgLy8vIHRoZSBqb2ludHMgd2lsbCBiZSBicm9rZW4uXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJib2R5QVwiPlRoZSBmaXJzdCBib2R5LjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwiYm9keUJcIj5UaGUgc2Vjb25kIGJvZHkuPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJsb2NhbEFuY2hvckFcIj5UaGUgZmlyc3QgYm9keSBhbmNob3IuPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJsb2NhbEFuY2hvckJcIj5UaGUgc2Vjb25kIGFuY2hvci48L3BhcmFtPlxyXG4gICAgICAgIHB1YmxpYyBSZXZvbHV0ZUpvaW50KEJvZHkgYm9keUEsIEJvZHkgYm9keUIsIFZlY3RvcjIgbG9jYWxBbmNob3JBLCBWZWN0b3IyIGxvY2FsQW5jaG9yQilcclxuICAgICAgICAgICAgOiBiYXNlKGJvZHlBLCBib2R5QilcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIEpvaW50VHlwZSA9IEpvaW50VHlwZS5SZXZvbHV0ZTtcclxuXHJcbiAgICAgICAgICAgIC8vIENoYW5nZWQgdG8gbG9jYWwgY29vcmRpbmF0ZXMuXHJcbiAgICAgICAgICAgIExvY2FsQW5jaG9yQSA9IGxvY2FsQW5jaG9yQTtcclxuICAgICAgICAgICAgTG9jYWxBbmNob3JCID0gbG9jYWxBbmNob3JCO1xyXG5cclxuICAgICAgICAgICAgUmVmZXJlbmNlQW5nbGUgPSBCb2R5Qi5Sb3RhdGlvbiAtIEJvZHlBLlJvdGF0aW9uO1xyXG5cclxuICAgICAgICAgICAgX2ltcHVsc2UgPSBWZWN0b3IzLlplcm87XHJcblxyXG4gICAgICAgICAgICBfbGltaXRTdGF0ZSA9IExpbWl0U3RhdGUuSW5hY3RpdmU7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwdWJsaWMgb3ZlcnJpZGUgVmVjdG9yMiBXb3JsZEFuY2hvckFcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGdldCB7IHJldHVybiBCb2R5QS5HZXRXb3JsZFBvaW50KExvY2FsQW5jaG9yQSk7IH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHB1YmxpYyBvdmVycmlkZSBWZWN0b3IyIFdvcmxkQW5jaG9yQlxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgZ2V0IHsgcmV0dXJuIEJvZHlCLkdldFdvcmxkUG9pbnQoTG9jYWxBbmNob3JCKTsgfVxyXG4gICAgICAgICAgICBzZXQgeyBEZWJ1Zy5Bc3NlcnQoZmFsc2UsIFwiWW91IGNhbid0IHNldCB0aGUgd29ybGQgYW5jaG9yIG9uIHRoaXMgam9pbnQgdHlwZS5cIik7IH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHB1YmxpYyBmbG9hdCBSZWZlcmVuY2VBbmdsZVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgZ2V0IHsgcmV0dXJuIF9yZWZlcmVuY2VBbmdsZTsgfVxyXG4gICAgICAgICAgICBzZXRcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgV2FrZUJvZGllcygpO1xyXG4gICAgICAgICAgICAgICAgX3JlZmVyZW5jZUFuZ2xlID0gdmFsdWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gR2V0IHRoZSBjdXJyZW50IGpvaW50IGFuZ2xlIGluIHJhZGlhbnMuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHZhbHVlPjwvdmFsdWU+XHJcbiAgICAgICAgcHVibGljIGZsb2F0IEpvaW50QW5nbGVcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGdldCB7IHJldHVybiBCb2R5Qi5Td2VlcC5BIC0gQm9keUEuU3dlZXAuQSAtIFJlZmVyZW5jZUFuZ2xlOyB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIEdldCB0aGUgY3VycmVudCBqb2ludCBhbmdsZSBzcGVlZCBpbiByYWRpYW5zIHBlciBzZWNvbmQuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHZhbHVlPjwvdmFsdWU+XHJcbiAgICAgICAgcHVibGljIGZsb2F0IEpvaW50U3BlZWRcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGdldCB7IHJldHVybiBCb2R5Qi5Bbmd1bGFyVmVsb2NpdHlJbnRlcm5hbCAtIEJvZHlBLkFuZ3VsYXJWZWxvY2l0eUludGVybmFsOyB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIElzIHRoZSBqb2ludCBsaW1pdCBlbmFibGVkP1xyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDx2YWx1ZT48Yz50cnVlPC9jPiBpZiBbbGltaXQgZW5hYmxlZF07IG90aGVyd2lzZSwgPGM+ZmFsc2U8L2M+LjwvdmFsdWU+XHJcbiAgICAgICAgcHVibGljIGJvb2wgTGltaXRFbmFibGVkXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBnZXQgeyByZXR1cm4gX2VuYWJsZUxpbWl0OyB9XHJcbiAgICAgICAgICAgIHNldFxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBXYWtlQm9kaWVzKCk7XHJcbiAgICAgICAgICAgICAgICBfZW5hYmxlTGltaXQgPSB2YWx1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBHZXQgdGhlIGxvd2VyIGpvaW50IGxpbWl0IGluIHJhZGlhbnMuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHZhbHVlPjwvdmFsdWU+XHJcbiAgICAgICAgcHVibGljIGZsb2F0IExvd2VyTGltaXRcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGdldCB7IHJldHVybiBfbG93ZXJBbmdsZTsgfVxyXG4gICAgICAgICAgICBzZXRcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgV2FrZUJvZGllcygpO1xyXG4gICAgICAgICAgICAgICAgX2xvd2VyQW5nbGUgPSB2YWx1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBHZXQgdGhlIHVwcGVyIGpvaW50IGxpbWl0IGluIHJhZGlhbnMuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHZhbHVlPjwvdmFsdWU+XHJcbiAgICAgICAgcHVibGljIGZsb2F0IFVwcGVyTGltaXRcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGdldCB7IHJldHVybiBfdXBwZXJBbmdsZTsgfVxyXG4gICAgICAgICAgICBzZXRcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgV2FrZUJvZGllcygpO1xyXG4gICAgICAgICAgICAgICAgX3VwcGVyQW5nbGUgPSB2YWx1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBJcyB0aGUgam9pbnQgbW90b3IgZW5hYmxlZD9cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8dmFsdWU+PGM+dHJ1ZTwvYz4gaWYgW21vdG9yIGVuYWJsZWRdOyBvdGhlcndpc2UsIDxjPmZhbHNlPC9jPi48L3ZhbHVlPlxyXG4gICAgICAgIHB1YmxpYyBib29sIE1vdG9yRW5hYmxlZFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgZ2V0IHsgcmV0dXJuIF9lbmFibGVNb3RvcjsgfVxyXG4gICAgICAgICAgICBzZXRcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgV2FrZUJvZGllcygpO1xyXG4gICAgICAgICAgICAgICAgX2VuYWJsZU1vdG9yID0gdmFsdWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gU2V0IHRoZSBtb3RvciBzcGVlZCBpbiByYWRpYW5zIHBlciBzZWNvbmQuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHZhbHVlPlRoZSBzcGVlZC48L3ZhbHVlPlxyXG4gICAgICAgIHB1YmxpYyBmbG9hdCBNb3RvclNwZWVkXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBzZXRcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgV2FrZUJvZGllcygpO1xyXG4gICAgICAgICAgICAgICAgX21vdG9yU3BlZWQgPSB2YWx1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBnZXQgeyByZXR1cm4gX21vdG9yU3BlZWQ7IH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gU2V0IHRoZSBtYXhpbXVtIG1vdG9yIHRvcnF1ZSwgdXN1YWxseSBpbiBOLW0uXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHZhbHVlPlRoZSB0b3JxdWUuPC92YWx1ZT5cclxuICAgICAgICBwdWJsaWMgZmxvYXQgTWF4TW90b3JUb3JxdWVcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHNldFxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBXYWtlQm9kaWVzKCk7XHJcbiAgICAgICAgICAgICAgICBfbWF4TW90b3JUb3JxdWUgPSB2YWx1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBnZXQgeyByZXR1cm4gX21heE1vdG9yVG9ycXVlOyB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIEdldCB0aGUgY3VycmVudCBtb3RvciB0b3JxdWUsIHVzdWFsbHkgaW4gTi1tLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDx2YWx1ZT48L3ZhbHVlPlxyXG4gICAgICAgIHB1YmxpYyBmbG9hdCBNb3RvclRvcnF1ZVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgZ2V0IHsgcmV0dXJuIF9tb3RvckltcHVsc2U7IH1cclxuICAgICAgICAgICAgc2V0XHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIFdha2VCb2RpZXMoKTtcclxuICAgICAgICAgICAgICAgIF9tb3RvckltcHVsc2UgPSB2YWx1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHVibGljIG92ZXJyaWRlIFZlY3RvcjIgR2V0UmVhY3Rpb25Gb3JjZShmbG9hdCBpbnZfZHQpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBWZWN0b3IyIFAgPSBuZXcgVmVjdG9yMihfaW1wdWxzZS5YLCBfaW1wdWxzZS5ZKTtcclxuICAgICAgICAgICAgcmV0dXJuIGludl9kdCAqIFA7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwdWJsaWMgb3ZlcnJpZGUgZmxvYXQgR2V0UmVhY3Rpb25Ub3JxdWUoZmxvYXQgaW52X2R0KVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIGludl9kdCAqIF9pbXB1bHNlLlo7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpbnRlcm5hbCBvdmVycmlkZSB2b2lkIEluaXRWZWxvY2l0eUNvbnN0cmFpbnRzKHJlZiBUaW1lU3RlcCBzdGVwKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgQm9keSBiMSA9IEJvZHlBO1xyXG4gICAgICAgICAgICBCb2R5IGIyID0gQm9keUI7XHJcblxyXG4gICAgICAgICAgICBpZiAoX2VuYWJsZU1vdG9yIHx8IF9lbmFibGVMaW1pdClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgLy8gWW91IGNhbm5vdCBjcmVhdGUgYSByb3RhdGlvbiBsaW1pdCBiZXR3ZWVuIGJvZGllcyB0aGF0XHJcbiAgICAgICAgICAgICAgICAvLyBib3RoIGhhdmUgZml4ZWQgcm90YXRpb24uXHJcbiAgICAgICAgICAgICAgICBEZWJ1Zy5Bc3NlcnQoYjEuSW52SSA+IDAuMGYgfHwgYjIuSW52SSA+IDAuMGYpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBDb21wdXRlIHRoZSBlZmZlY3RpdmUgbWFzcyBtYXRyaXguXHJcbiAgICAgICAgICAgIC8qVHJhbnNmb3JtIHhmMSwgeGYyO1xyXG4gICAgICAgICAgICBiMS5HZXRUcmFuc2Zvcm0ob3V0IHhmMSk7XHJcbiAgICAgICAgICAgIGIyLkdldFRyYW5zZm9ybShvdXQgeGYyKTsqL1xyXG5cclxuICAgICAgICAgICAgVmVjdG9yMiByMSA9IE1hdGhVdGlscy5NdWx0aXBseShyZWYgYjEuWGYuUiwgTG9jYWxBbmNob3JBIC0gYjEuTG9jYWxDZW50ZXIpO1xyXG4gICAgICAgICAgICBWZWN0b3IyIHIyID0gTWF0aFV0aWxzLk11bHRpcGx5KHJlZiBiMi5YZi5SLCBMb2NhbEFuY2hvckIgLSBiMi5Mb2NhbENlbnRlcik7XHJcblxyXG4gICAgICAgICAgICAvLyBKID0gWy1JIC1yMV9za2V3IEkgcjJfc2tld11cclxuICAgICAgICAgICAgLy8gICAgIFsgMCAgICAgICAtMSAwICAgICAgIDFdXHJcbiAgICAgICAgICAgIC8vIHJfc2tldyA9IFstcnk7IHJ4XVxyXG5cclxuICAgICAgICAgICAgLy8gTWF0bGFiXHJcbiAgICAgICAgICAgIC8vIEsgPSBbIG0xK3IxeV4yKmkxK20yK3IyeV4yKmkyLCAgLXIxeSppMSpyMXgtcjJ5KmkyKnIyeCwgICAgICAgICAgLXIxeSppMS1yMnkqaTJdXHJcbiAgICAgICAgICAgIC8vICAgICBbICAtcjF5KmkxKnIxeC1yMnkqaTIqcjJ4LCBtMStyMXheMippMSttMityMnheMippMiwgICAgICAgICAgIHIxeCppMStyMngqaTJdXHJcbiAgICAgICAgICAgIC8vICAgICBbICAgICAgICAgIC1yMXkqaTEtcjJ5KmkyLCAgICAgICAgICAgcjF4KmkxK3IyeCppMiwgICAgICAgICAgICAgICAgICAgaTEraTJdXHJcblxyXG4gICAgICAgICAgICBmbG9hdCBtMSA9IGIxLkludk1hc3MsIG0yID0gYjIuSW52TWFzcztcclxuICAgICAgICAgICAgZmxvYXQgaTEgPSBiMS5JbnZJLCBpMiA9IGIyLkludkk7XHJcblxyXG4gICAgICAgICAgICBfbWFzcy5Db2wxLlggPSBtMSArIG0yICsgcjEuWSAqIHIxLlkgKiBpMSArIHIyLlkgKiByMi5ZICogaTI7XHJcbiAgICAgICAgICAgIF9tYXNzLkNvbDIuWCA9IC1yMS5ZICogcjEuWCAqIGkxIC0gcjIuWSAqIHIyLlggKiBpMjtcclxuICAgICAgICAgICAgX21hc3MuQ29sMy5YID0gLXIxLlkgKiBpMSAtIHIyLlkgKiBpMjtcclxuICAgICAgICAgICAgX21hc3MuQ29sMS5ZID0gX21hc3MuQ29sMi5YO1xyXG4gICAgICAgICAgICBfbWFzcy5Db2wyLlkgPSBtMSArIG0yICsgcjEuWCAqIHIxLlggKiBpMSArIHIyLlggKiByMi5YICogaTI7XHJcbiAgICAgICAgICAgIF9tYXNzLkNvbDMuWSA9IHIxLlggKiBpMSArIHIyLlggKiBpMjtcclxuICAgICAgICAgICAgX21hc3MuQ29sMS5aID0gX21hc3MuQ29sMy5YO1xyXG4gICAgICAgICAgICBfbWFzcy5Db2wyLlogPSBfbWFzcy5Db2wzLlk7XHJcbiAgICAgICAgICAgIF9tYXNzLkNvbDMuWiA9IGkxICsgaTI7XHJcblxyXG4gICAgICAgICAgICBfbW90b3JNYXNzID0gaTEgKyBpMjtcclxuICAgICAgICAgICAgaWYgKF9tb3Rvck1hc3MgPiAwLjBmKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBfbW90b3JNYXNzID0gMS4wZiAvIF9tb3Rvck1hc3M7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmIChfZW5hYmxlTW90b3IgPT0gZmFsc2UpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIF9tb3RvckltcHVsc2UgPSAwLjBmO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAoX2VuYWJsZUxpbWl0KVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBmbG9hdCBqb2ludEFuZ2xlID0gYjIuU3dlZXAuQSAtIGIxLlN3ZWVwLkEgLSBSZWZlcmVuY2VBbmdsZTtcclxuICAgICAgICAgICAgICAgIGlmIChNYXRoLkFicyhfdXBwZXJBbmdsZSAtIF9sb3dlckFuZ2xlKSA8IDIuMGYgKiBTZXR0aW5ncy5Bbmd1bGFyU2xvcClcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBfbGltaXRTdGF0ZSA9IExpbWl0U3RhdGUuRXF1YWw7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChqb2ludEFuZ2xlIDw9IF9sb3dlckFuZ2xlKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChfbGltaXRTdGF0ZSAhPSBMaW1pdFN0YXRlLkF0TG93ZXIpXHJcbiAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBfaW1wdWxzZS5aID0gMC4wZjtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgX2xpbWl0U3RhdGUgPSBMaW1pdFN0YXRlLkF0TG93ZXI7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChqb2ludEFuZ2xlID49IF91cHBlckFuZ2xlKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChfbGltaXRTdGF0ZSAhPSBMaW1pdFN0YXRlLkF0VXBwZXIpXHJcbiAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBfaW1wdWxzZS5aID0gMC4wZjtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgX2xpbWl0U3RhdGUgPSBMaW1pdFN0YXRlLkF0VXBwZXI7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgX2xpbWl0U3RhdGUgPSBMaW1pdFN0YXRlLkluYWN0aXZlO1xyXG4gICAgICAgICAgICAgICAgICAgIF9pbXB1bHNlLlogPSAwLjBmO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgX2xpbWl0U3RhdGUgPSBMaW1pdFN0YXRlLkluYWN0aXZlO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAoU2V0dGluZ3MuRW5hYmxlV2FybXN0YXJ0aW5nKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAvLyBTY2FsZSBpbXB1bHNlcyB0byBzdXBwb3J0IGEgdmFyaWFibGUgdGltZSBzdGVwLlxyXG4gICAgICAgICAgICAgICAgX2ltcHVsc2UgKj0gc3RlcC5kdFJhdGlvO1xyXG4gICAgICAgICAgICAgICAgX21vdG9ySW1wdWxzZSAqPSBzdGVwLmR0UmF0aW87XHJcblxyXG4gICAgICAgICAgICAgICAgVmVjdG9yMiBQID0gbmV3IFZlY3RvcjIoX2ltcHVsc2UuWCwgX2ltcHVsc2UuWSk7XHJcblxyXG4gICAgICAgICAgICAgICAgYjEuTGluZWFyVmVsb2NpdHlJbnRlcm5hbCAtPSBtMSAqIFA7XHJcbiAgICAgICAgICAgICAgICBNYXRoVXRpbHMuQ3Jvc3MocmVmIHIxLCByZWYgUCwgb3V0IF90bXBGbG9hdDEpO1xyXG4gICAgICAgICAgICAgICAgYjEuQW5ndWxhclZlbG9jaXR5SW50ZXJuYWwgLT0gaTEgKiAoIC8qIHIxIHggUCAqL190bXBGbG9hdDEgKyBfbW90b3JJbXB1bHNlICsgX2ltcHVsc2UuWik7XHJcblxyXG4gICAgICAgICAgICAgICAgYjIuTGluZWFyVmVsb2NpdHlJbnRlcm5hbCArPSBtMiAqIFA7XHJcbiAgICAgICAgICAgICAgICBNYXRoVXRpbHMuQ3Jvc3MocmVmIHIyLCByZWYgUCwgb3V0IF90bXBGbG9hdDEpO1xyXG4gICAgICAgICAgICAgICAgYjIuQW5ndWxhclZlbG9jaXR5SW50ZXJuYWwgKz0gaTIgKiAoIC8qIHIyIHggUCAqL190bXBGbG9hdDEgKyBfbW90b3JJbXB1bHNlICsgX2ltcHVsc2UuWik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBfaW1wdWxzZSA9IFZlY3RvcjMuWmVybztcclxuICAgICAgICAgICAgICAgIF9tb3RvckltcHVsc2UgPSAwLjBmO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpbnRlcm5hbCBvdmVycmlkZSB2b2lkIFNvbHZlVmVsb2NpdHlDb25zdHJhaW50cyhyZWYgVGltZVN0ZXAgc3RlcClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIEJvZHkgYjEgPSBCb2R5QTtcclxuICAgICAgICAgICAgQm9keSBiMiA9IEJvZHlCO1xyXG5cclxuICAgICAgICAgICAgVmVjdG9yMiB2MSA9IGIxLkxpbmVhclZlbG9jaXR5SW50ZXJuYWw7XHJcbiAgICAgICAgICAgIGZsb2F0IHcxID0gYjEuQW5ndWxhclZlbG9jaXR5SW50ZXJuYWw7XHJcbiAgICAgICAgICAgIFZlY3RvcjIgdjIgPSBiMi5MaW5lYXJWZWxvY2l0eUludGVybmFsO1xyXG4gICAgICAgICAgICBmbG9hdCB3MiA9IGIyLkFuZ3VsYXJWZWxvY2l0eUludGVybmFsO1xyXG5cclxuICAgICAgICAgICAgZmxvYXQgbTEgPSBiMS5JbnZNYXNzLCBtMiA9IGIyLkludk1hc3M7XHJcbiAgICAgICAgICAgIGZsb2F0IGkxID0gYjEuSW52SSwgaTIgPSBiMi5JbnZJO1xyXG5cclxuICAgICAgICAgICAgLy8gU29sdmUgbW90b3IgY29uc3RyYWludC5cclxuICAgICAgICAgICAgaWYgKF9lbmFibGVNb3RvciAmJiBfbGltaXRTdGF0ZSAhPSBMaW1pdFN0YXRlLkVxdWFsKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBmbG9hdCBDZG90ID0gdzIgLSB3MSAtIF9tb3RvclNwZWVkO1xyXG4gICAgICAgICAgICAgICAgZmxvYXQgaW1wdWxzZSA9IF9tb3Rvck1hc3MgKiAoLUNkb3QpO1xyXG4gICAgICAgICAgICAgICAgZmxvYXQgb2xkSW1wdWxzZSA9IF9tb3RvckltcHVsc2U7XHJcbiAgICAgICAgICAgICAgICBmbG9hdCBtYXhJbXB1bHNlID0gc3RlcC5kdCAqIF9tYXhNb3RvclRvcnF1ZTtcclxuICAgICAgICAgICAgICAgIF9tb3RvckltcHVsc2UgPSBNYXRoVXRpbHMuQ2xhbXAoX21vdG9ySW1wdWxzZSArIGltcHVsc2UsIC1tYXhJbXB1bHNlLCBtYXhJbXB1bHNlKTtcclxuICAgICAgICAgICAgICAgIGltcHVsc2UgPSBfbW90b3JJbXB1bHNlIC0gb2xkSW1wdWxzZTtcclxuXHJcbiAgICAgICAgICAgICAgICB3MSAtPSBpMSAqIGltcHVsc2U7XHJcbiAgICAgICAgICAgICAgICB3MiArPSBpMiAqIGltcHVsc2U7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIFNvbHZlIGxpbWl0IGNvbnN0cmFpbnQuXHJcbiAgICAgICAgICAgIGlmIChfZW5hYmxlTGltaXQgJiYgX2xpbWl0U3RhdGUgIT0gTGltaXRTdGF0ZS5JbmFjdGl2ZSlcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgLypUcmFuc2Zvcm0geGYxLCB4ZjI7XHJcbiAgICAgICAgICAgICAgICBiMS5HZXRUcmFuc2Zvcm0ob3V0IHhmMSk7XHJcbiAgICAgICAgICAgICAgICBiMi5HZXRUcmFuc2Zvcm0ob3V0IHhmMik7Ki9cclxuXHJcbiAgICAgICAgICAgICAgICBWZWN0b3IyIHIxID0gTWF0aFV0aWxzLk11bHRpcGx5KHJlZiBiMS5YZi5SLCBMb2NhbEFuY2hvckEgLSBiMS5Mb2NhbENlbnRlcik7XHJcbiAgICAgICAgICAgICAgICBWZWN0b3IyIHIyID0gTWF0aFV0aWxzLk11bHRpcGx5KHJlZiBiMi5YZi5SLCBMb2NhbEFuY2hvckIgLSBiMi5Mb2NhbENlbnRlcik7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gU29sdmUgcG9pbnQtdG8tcG9pbnQgY29uc3RyYWludFxyXG4gICAgICAgICAgICAgICAgTWF0aFV0aWxzLkNyb3NzKHcyLCByZWYgcjIsIG91dCBfdG1wVmVjdG9yMik7XHJcbiAgICAgICAgICAgICAgICBNYXRoVXRpbHMuQ3Jvc3ModzEsIHJlZiByMSwgb3V0IF90bXBWZWN0b3IxKTtcclxuICAgICAgICAgICAgICAgIFZlY3RvcjIgQ2RvdDEgPSB2MiArIC8qIHcyIHggcjIgKi8gX3RtcFZlY3RvcjIgLSB2MSAtIC8qIHcxIHggcjEgKi8gX3RtcFZlY3RvcjE7XHJcbiAgICAgICAgICAgICAgICBmbG9hdCBDZG90MiA9IHcyIC0gdzE7XHJcbiAgICAgICAgICAgICAgICBWZWN0b3IzIENkb3QgPSBuZXcgVmVjdG9yMyhDZG90MS5YLCBDZG90MS5ZLCBDZG90Mik7XHJcblxyXG4gICAgICAgICAgICAgICAgVmVjdG9yMyBpbXB1bHNlID0gX21hc3MuU29sdmUzMygtQ2RvdCk7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKF9saW1pdFN0YXRlID09IExpbWl0U3RhdGUuRXF1YWwpXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgX2ltcHVsc2UgKz0gaW1wdWxzZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKF9saW1pdFN0YXRlID09IExpbWl0U3RhdGUuQXRMb3dlcilcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBmbG9hdCBuZXdJbXB1bHNlID0gX2ltcHVsc2UuWiArIGltcHVsc2UuWjtcclxuICAgICAgICAgICAgICAgICAgICBpZiAobmV3SW1wdWxzZSA8IDAuMGYpXHJcbiAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBWZWN0b3IyIHJlZHVjZWQgPSBfbWFzcy5Tb2x2ZTIyKC1DZG90MSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGltcHVsc2UuWCA9IHJlZHVjZWQuWDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaW1wdWxzZS5ZID0gcmVkdWNlZC5ZO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpbXB1bHNlLlogPSAtX2ltcHVsc2UuWjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgX2ltcHVsc2UuWCArPSByZWR1Y2VkLlg7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF9pbXB1bHNlLlkgKz0gcmVkdWNlZC5ZO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBfaW1wdWxzZS5aID0gMC4wZjtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChfbGltaXRTdGF0ZSA9PSBMaW1pdFN0YXRlLkF0VXBwZXIpXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgZmxvYXQgbmV3SW1wdWxzZSA9IF9pbXB1bHNlLlogKyBpbXB1bHNlLlo7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5ld0ltcHVsc2UgPiAwLjBmKVxyXG4gICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgVmVjdG9yMiByZWR1Y2VkID0gX21hc3MuU29sdmUyMigtQ2RvdDEpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpbXB1bHNlLlggPSByZWR1Y2VkLlg7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGltcHVsc2UuWSA9IHJlZHVjZWQuWTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaW1wdWxzZS5aID0gLV9pbXB1bHNlLlo7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF9pbXB1bHNlLlggKz0gcmVkdWNlZC5YO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBfaW1wdWxzZS5ZICs9IHJlZHVjZWQuWTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgX2ltcHVsc2UuWiA9IDAuMGY7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIFZlY3RvcjIgUCA9IG5ldyBWZWN0b3IyKGltcHVsc2UuWCwgaW1wdWxzZS5ZKTtcclxuXHJcbiAgICAgICAgICAgICAgICB2MSAtPSBtMSAqIFA7XHJcbiAgICAgICAgICAgICAgICBNYXRoVXRpbHMuQ3Jvc3MocmVmIHIxLCByZWYgUCwgb3V0IF90bXBGbG9hdDEpO1xyXG4gICAgICAgICAgICAgICAgdzEgLT0gaTEgKiAoIC8qIHIxIHggUCAqL190bXBGbG9hdDEgKyBpbXB1bHNlLlopO1xyXG5cclxuICAgICAgICAgICAgICAgIHYyICs9IG0yICogUDtcclxuICAgICAgICAgICAgICAgIE1hdGhVdGlscy5Dcm9zcyhyZWYgcjIsIHJlZiBQLCBvdXQgX3RtcEZsb2F0MSk7XHJcbiAgICAgICAgICAgICAgICB3MiArPSBpMiAqICggLyogcjIgeCBQICovX3RtcEZsb2F0MSArIGltcHVsc2UuWik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAvKlRyYW5zZm9ybSB4ZjEsIHhmMjtcclxuICAgICAgICAgICAgICAgIGIxLkdldFRyYW5zZm9ybShvdXQgeGYxKTtcclxuICAgICAgICAgICAgICAgIGIyLkdldFRyYW5zZm9ybShvdXQgeGYyKTsqL1xyXG5cclxuICAgICAgICAgICAgICAgIF90bXBWZWN0b3IxID0gTG9jYWxBbmNob3JBIC0gYjEuTG9jYWxDZW50ZXI7XHJcbiAgICAgICAgICAgICAgICBfdG1wVmVjdG9yMiA9IExvY2FsQW5jaG9yQiAtIGIyLkxvY2FsQ2VudGVyO1xyXG4gICAgICAgICAgICAgICAgVmVjdG9yMiByMSA9IE1hdGhVdGlscy5NdWx0aXBseShyZWYgYjEuWGYuUiwgcmVmIF90bXBWZWN0b3IxKTtcclxuICAgICAgICAgICAgICAgIFZlY3RvcjIgcjIgPSBNYXRoVXRpbHMuTXVsdGlwbHkocmVmIGIyLlhmLlIsIHJlZiBfdG1wVmVjdG9yMik7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gU29sdmUgcG9pbnQtdG8tcG9pbnQgY29uc3RyYWludFxyXG4gICAgICAgICAgICAgICAgTWF0aFV0aWxzLkNyb3NzKHcyLCByZWYgcjIsIG91dCBfdG1wVmVjdG9yMik7XHJcbiAgICAgICAgICAgICAgICBNYXRoVXRpbHMuQ3Jvc3ModzEsIHJlZiByMSwgb3V0IF90bXBWZWN0b3IxKTtcclxuICAgICAgICAgICAgICAgIFZlY3RvcjIgQ2RvdCA9IHYyICsgLyogdzIgeCByMiAqLyBfdG1wVmVjdG9yMiAtIHYxIC0gLyogdzEgeCByMSAqLyBfdG1wVmVjdG9yMTtcclxuICAgICAgICAgICAgICAgIFZlY3RvcjIgaW1wdWxzZSA9IF9tYXNzLlNvbHZlMjIoLUNkb3QpO1xyXG5cclxuICAgICAgICAgICAgICAgIF9pbXB1bHNlLlggKz0gaW1wdWxzZS5YO1xyXG4gICAgICAgICAgICAgICAgX2ltcHVsc2UuWSArPSBpbXB1bHNlLlk7XHJcblxyXG4gICAgICAgICAgICAgICAgdjEgLT0gbTEgKiBpbXB1bHNlO1xyXG4gICAgICAgICAgICAgICAgTWF0aFV0aWxzLkNyb3NzKHJlZiByMSwgcmVmIGltcHVsc2UsIG91dCBfdG1wRmxvYXQxKTtcclxuICAgICAgICAgICAgICAgIHcxIC09IGkxICogLyogcjEgeCBpbXB1bHNlICovIF90bXBGbG9hdDE7XHJcblxyXG4gICAgICAgICAgICAgICAgdjIgKz0gbTIgKiBpbXB1bHNlO1xyXG4gICAgICAgICAgICAgICAgTWF0aFV0aWxzLkNyb3NzKHJlZiByMiwgcmVmIGltcHVsc2UsIG91dCBfdG1wRmxvYXQxKTtcclxuICAgICAgICAgICAgICAgIHcyICs9IGkyICogLyogcjIgeCBpbXB1bHNlICovIF90bXBGbG9hdDE7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGIxLkxpbmVhclZlbG9jaXR5SW50ZXJuYWwgPSB2MTtcclxuICAgICAgICAgICAgYjEuQW5ndWxhclZlbG9jaXR5SW50ZXJuYWwgPSB3MTtcclxuICAgICAgICAgICAgYjIuTGluZWFyVmVsb2NpdHlJbnRlcm5hbCA9IHYyO1xyXG4gICAgICAgICAgICBiMi5Bbmd1bGFyVmVsb2NpdHlJbnRlcm5hbCA9IHcyO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaW50ZXJuYWwgb3ZlcnJpZGUgYm9vbCBTb2x2ZVBvc2l0aW9uQ29uc3RyYWludHMoKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgLy8gVE9ET19FUklOIGJsb2NrIHNvbHZlIHdpdGggbGltaXQuIENPTUUgT04gRVJJTlxyXG5cclxuICAgICAgICAgICAgQm9keSBiMSA9IEJvZHlBO1xyXG4gICAgICAgICAgICBCb2R5IGIyID0gQm9keUI7XHJcblxyXG4gICAgICAgICAgICBmbG9hdCBhbmd1bGFyRXJyb3IgPSAwLjBmO1xyXG4gICAgICAgICAgICBmbG9hdCBwb3NpdGlvbkVycm9yO1xyXG5cclxuICAgICAgICAgICAgLy8gU29sdmUgYW5ndWxhciBsaW1pdCBjb25zdHJhaW50LlxyXG4gICAgICAgICAgICBpZiAoX2VuYWJsZUxpbWl0ICYmIF9saW1pdFN0YXRlICE9IExpbWl0U3RhdGUuSW5hY3RpdmUpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGZsb2F0IGFuZ2xlID0gYjIuU3dlZXAuQSAtIGIxLlN3ZWVwLkEgLSBSZWZlcmVuY2VBbmdsZTtcclxuICAgICAgICAgICAgICAgIGZsb2F0IGxpbWl0SW1wdWxzZSA9IDAuMGY7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKF9saW1pdFN0YXRlID09IExpbWl0U3RhdGUuRXF1YWwpXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gUHJldmVudCBsYXJnZSBhbmd1bGFyIGNvcnJlY3Rpb25zXHJcbiAgICAgICAgICAgICAgICAgICAgZmxvYXQgQyA9IE1hdGhVdGlscy5DbGFtcChhbmdsZSAtIF9sb3dlckFuZ2xlLCAtU2V0dGluZ3MuTWF4QW5ndWxhckNvcnJlY3Rpb24sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBTZXR0aW5ncy5NYXhBbmd1bGFyQ29ycmVjdGlvbik7XHJcbiAgICAgICAgICAgICAgICAgICAgbGltaXRJbXB1bHNlID0gLV9tb3Rvck1hc3MgKiBDO1xyXG4gICAgICAgICAgICAgICAgICAgIGFuZ3VsYXJFcnJvciA9IChmbG9hdClNYXRoLkFicyhDKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKF9saW1pdFN0YXRlID09IExpbWl0U3RhdGUuQXRMb3dlcilcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBmbG9hdCBDID0gYW5nbGUgLSBfbG93ZXJBbmdsZTtcclxuICAgICAgICAgICAgICAgICAgICBhbmd1bGFyRXJyb3IgPSAtQztcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gUHJldmVudCBsYXJnZSBhbmd1bGFyIGNvcnJlY3Rpb25zIGFuZCBhbGxvdyBzb21lIHNsb3AuXHJcbiAgICAgICAgICAgICAgICAgICAgQyA9IE1hdGhVdGlscy5DbGFtcChDICsgU2V0dGluZ3MuQW5ndWxhclNsb3AsIC1TZXR0aW5ncy5NYXhBbmd1bGFyQ29ycmVjdGlvbiwgMC4wZik7XHJcbiAgICAgICAgICAgICAgICAgICAgbGltaXRJbXB1bHNlID0gLV9tb3Rvck1hc3MgKiBDO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoX2xpbWl0U3RhdGUgPT0gTGltaXRTdGF0ZS5BdFVwcGVyKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIGZsb2F0IEMgPSBhbmdsZSAtIF91cHBlckFuZ2xlO1xyXG4gICAgICAgICAgICAgICAgICAgIGFuZ3VsYXJFcnJvciA9IEM7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIFByZXZlbnQgbGFyZ2UgYW5ndWxhciBjb3JyZWN0aW9ucyBhbmQgYWxsb3cgc29tZSBzbG9wLlxyXG4gICAgICAgICAgICAgICAgICAgIEMgPSBNYXRoVXRpbHMuQ2xhbXAoQyAtIFNldHRpbmdzLkFuZ3VsYXJTbG9wLCAwLjBmLCBTZXR0aW5ncy5NYXhBbmd1bGFyQ29ycmVjdGlvbik7XHJcbiAgICAgICAgICAgICAgICAgICAgbGltaXRJbXB1bHNlID0gLV9tb3Rvck1hc3MgKiBDO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGIxLlN3ZWVwLkEgLT0gYjEuSW52SSAqIGxpbWl0SW1wdWxzZTtcclxuICAgICAgICAgICAgICAgIGIyLlN3ZWVwLkEgKz0gYjIuSW52SSAqIGxpbWl0SW1wdWxzZTtcclxuXHJcbiAgICAgICAgICAgICAgICBiMS5TeW5jaHJvbml6ZVRyYW5zZm9ybSgpO1xyXG4gICAgICAgICAgICAgICAgYjIuU3luY2hyb25pemVUcmFuc2Zvcm0oKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gU29sdmUgcG9pbnQtdG8tcG9pbnQgY29uc3RyYWludC5cclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgLypUcmFuc2Zvcm0geGYxLCB4ZjI7XHJcbiAgICAgICAgICAgICAgICBiMS5HZXRUcmFuc2Zvcm0ob3V0IHhmMSk7XHJcbiAgICAgICAgICAgICAgICBiMi5HZXRUcmFuc2Zvcm0ob3V0IHhmMik7Ki9cclxuXHJcbiAgICAgICAgICAgICAgICBWZWN0b3IyIHIxID0gTWF0aFV0aWxzLk11bHRpcGx5KHJlZiBiMS5YZi5SLCBMb2NhbEFuY2hvckEgLSBiMS5Mb2NhbENlbnRlcik7XHJcbiAgICAgICAgICAgICAgICBWZWN0b3IyIHIyID0gTWF0aFV0aWxzLk11bHRpcGx5KHJlZiBiMi5YZi5SLCBMb2NhbEFuY2hvckIgLSBiMi5Mb2NhbENlbnRlcik7XHJcblxyXG4gICAgICAgICAgICAgICAgVmVjdG9yMiBDID0gYjIuU3dlZXAuQyArIHIyIC0gYjEuU3dlZXAuQyAtIHIxO1xyXG4gICAgICAgICAgICAgICAgcG9zaXRpb25FcnJvciA9IEMuTGVuZ3RoKCk7XHJcblxyXG4gICAgICAgICAgICAgICAgZmxvYXQgaW52TWFzczEgPSBiMS5JbnZNYXNzLCBpbnZNYXNzMiA9IGIyLkludk1hc3M7XHJcbiAgICAgICAgICAgICAgICBmbG9hdCBpbnZJMSA9IGIxLkludkksIGludkkyID0gYjIuSW52STtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBIYW5kbGUgbGFyZ2UgZGV0YWNobWVudC5cclxuICAgICAgICAgICAgICAgIGNvbnN0IGZsb2F0IGtfYWxsb3dlZFN0cmV0Y2ggPSAxMC4wZiAqIFNldHRpbmdzLkxpbmVhclNsb3A7XHJcbiAgICAgICAgICAgICAgICBpZiAoQy5MZW5ndGhTcXVhcmVkKCkgPiBrX2FsbG93ZWRTdHJldGNoICoga19hbGxvd2VkU3RyZXRjaClcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBVc2UgYSBwYXJ0aWNsZSBzb2x1dGlvbiAobm8gcm90YXRpb24pLlxyXG4gICAgICAgICAgICAgICAgICAgIFZlY3RvcjIgdSA9IEM7XHJcbiAgICAgICAgICAgICAgICAgICAgdS5Ob3JtYWxpemUoKTtcclxuICAgICAgICAgICAgICAgICAgICBmbG9hdCBrID0gaW52TWFzczEgKyBpbnZNYXNzMjtcclxuICAgICAgICAgICAgICAgICAgICBEZWJ1Zy5Bc3NlcnQoayA+IFNldHRpbmdzLkVwc2lsb24pO1xyXG4gICAgICAgICAgICAgICAgICAgIGZsb2F0IG0gPSAxLjBmIC8gaztcclxuICAgICAgICAgICAgICAgICAgICBWZWN0b3IyIGltcHVsc2UyID0gbSAqICgtQyk7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZmxvYXQga19iZXRhID0gMC41ZjtcclxuICAgICAgICAgICAgICAgICAgICBiMS5Td2VlcC5DIC09IGtfYmV0YSAqIGludk1hc3MxICogaW1wdWxzZTI7XHJcbiAgICAgICAgICAgICAgICAgICAgYjIuU3dlZXAuQyArPSBrX2JldGEgKiBpbnZNYXNzMiAqIGltcHVsc2UyO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBDID0gYjIuU3dlZXAuQyArIHIyIC0gYjEuU3dlZXAuQyAtIHIxO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIE1hdDIyIEsxID0gbmV3IE1hdDIyKG5ldyBWZWN0b3IyKGludk1hc3MxICsgaW52TWFzczIsIDAuMGYpLCBuZXcgVmVjdG9yMigwLjBmLCBpbnZNYXNzMSArIGludk1hc3MyKSk7XHJcbiAgICAgICAgICAgICAgICBNYXQyMiBLMiA9IG5ldyBNYXQyMihuZXcgVmVjdG9yMihpbnZJMSAqIHIxLlkgKiByMS5ZLCAtaW52STEgKiByMS5YICogcjEuWSksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXcgVmVjdG9yMigtaW52STEgKiByMS5YICogcjEuWSwgaW52STEgKiByMS5YICogcjEuWCkpO1xyXG4gICAgICAgICAgICAgICAgTWF0MjIgSzMgPSBuZXcgTWF0MjIobmV3IFZlY3RvcjIoaW52STIgKiByMi5ZICogcjIuWSwgLWludkkyICogcjIuWCAqIHIyLlkpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3IFZlY3RvcjIoLWludkkyICogcjIuWCAqIHIyLlksIGludkkyICogcjIuWCAqIHIyLlgpKTtcclxuXHJcbiAgICAgICAgICAgICAgICBNYXQyMiBLYTtcclxuICAgICAgICAgICAgICAgIE1hdDIyLkFkZChyZWYgSzEsIHJlZiBLMiwgb3V0IEthKTtcclxuXHJcbiAgICAgICAgICAgICAgICBNYXQyMiBLO1xyXG4gICAgICAgICAgICAgICAgTWF0MjIuQWRkKHJlZiBLYSwgcmVmIEszLCBvdXQgSyk7XHJcblxyXG5cclxuICAgICAgICAgICAgICAgIFZlY3RvcjIgaW1wdWxzZSA9IEsuU29sdmUoLUMpO1xyXG5cclxuICAgICAgICAgICAgICAgIGIxLlN3ZWVwLkMgLT0gYjEuSW52TWFzcyAqIGltcHVsc2U7XHJcbiAgICAgICAgICAgICAgICBNYXRoVXRpbHMuQ3Jvc3MocmVmIHIxLCByZWYgaW1wdWxzZSwgb3V0IF90bXBGbG9hdDEpO1xyXG4gICAgICAgICAgICAgICAgYjEuU3dlZXAuQSAtPSBiMS5JbnZJICogLyogcjEgeCBpbXB1bHNlICovIF90bXBGbG9hdDE7XHJcblxyXG4gICAgICAgICAgICAgICAgYjIuU3dlZXAuQyArPSBiMi5JbnZNYXNzICogaW1wdWxzZTtcclxuICAgICAgICAgICAgICAgIE1hdGhVdGlscy5Dcm9zcyhyZWYgcjIsIHJlZiBpbXB1bHNlLCBvdXQgX3RtcEZsb2F0MSk7XHJcbiAgICAgICAgICAgICAgICBiMi5Td2VlcC5BICs9IGIyLkludkkgKiAvKiByMiB4IGltcHVsc2UgKi8gX3RtcEZsb2F0MTtcclxuXHJcbiAgICAgICAgICAgICAgICBiMS5TeW5jaHJvbml6ZVRyYW5zZm9ybSgpO1xyXG4gICAgICAgICAgICAgICAgYjIuU3luY2hyb25pemVUcmFuc2Zvcm0oKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuIHBvc2l0aW9uRXJyb3IgPD0gU2V0dGluZ3MuTGluZWFyU2xvcCAmJiBhbmd1bGFyRXJyb3IgPD0gU2V0dGluZ3MuQW5ndWxhclNsb3A7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59IiwiLypcclxuKiBDb3B5cmlnaHQgKGMpIDIwMDYtMjAxMCBFcmluIENhdHRvIGh0dHA6Ly93d3cuZ3BoeXNpY3MuY29tXHJcbipcclxuKiBUaGlzIHNvZnR3YXJlIGlzIHByb3ZpZGVkICdhcy1pcycsIHdpdGhvdXQgYW55IGV4cHJlc3Mgb3IgaW1wbGllZFxyXG4qIHdhcnJhbnR5LiAgSW4gbm8gZXZlbnQgd2lsbCB0aGUgYXV0aG9ycyBiZSBoZWxkIGxpYWJsZSBmb3IgYW55IGRhbWFnZXNcclxuKiBhcmlzaW5nIGZyb20gdGhlIHVzZSBvZiB0aGlzIHNvZnR3YXJlLlxyXG4qIFBlcm1pc3Npb24gaXMgZ3JhbnRlZCB0byBhbnlvbmUgdG8gdXNlIHRoaXMgc29mdHdhcmUgZm9yIGFueSBwdXJwb3NlLFxyXG4qIGluY2x1ZGluZyBjb21tZXJjaWFsIGFwcGxpY2F0aW9ucywgYW5kIHRvIGFsdGVyIGl0IGFuZCByZWRpc3RyaWJ1dGUgaXRcclxuKiBmcmVlbHksIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyByZXN0cmljdGlvbnM6XHJcbiogMS4gVGhlIG9yaWdpbiBvZiB0aGlzIHNvZnR3YXJlIG11c3Qgbm90IGJlIG1pc3JlcHJlc2VudGVkOyB5b3UgbXVzdCBub3RcclxuKiBjbGFpbSB0aGF0IHlvdSB3cm90ZSB0aGUgb3JpZ2luYWwgc29mdHdhcmUuIElmIHlvdSB1c2UgdGhpcyBzb2Z0d2FyZVxyXG4qIGluIGEgcHJvZHVjdCwgYW4gYWNrbm93bGVkZ21lbnQgaW4gdGhlIHByb2R1Y3QgZG9jdW1lbnRhdGlvbiB3b3VsZCBiZVxyXG4qIGFwcHJlY2lhdGVkIGJ1dCBpcyBub3QgcmVxdWlyZWQuXHJcbiogMi4gQWx0ZXJlZCBzb3VyY2UgdmVyc2lvbnMgbXVzdCBiZSBwbGFpbmx5IG1hcmtlZCBhcyBzdWNoLCBhbmQgbXVzdCBub3QgYmVcclxuKiBtaXNyZXByZXNlbnRlZCBhcyBiZWluZyB0aGUgb3JpZ2luYWwgc29mdHdhcmUuXHJcbiogMy4gVGhpcyBub3RpY2UgbWF5IG5vdCBiZSByZW1vdmVkIG9yIGFsdGVyZWQgZnJvbSBhbnkgc291cmNlIGRpc3RyaWJ1dGlvbi5cclxuKi9cclxuXHJcbnVzaW5nIFN5c3RlbTtcclxudXNpbmcgU3lzdGVtLkRpYWdub3N0aWNzO1xyXG51c2luZyBGYXJzZWVyUGh5c2ljcy5Db21tb247XHJcbnVzaW5nIE1pY3Jvc29mdC5YbmEuRnJhbWV3b3JrO1xyXG5cclxubmFtZXNwYWNlIEZhcnNlZXJQaHlzaWNzLkR5bmFtaWNzLkpvaW50c1xyXG57XHJcbiAgICAvLyBMaW1pdDpcclxuICAgIC8vIEMgPSBub3JtKHBCIC0gcEEpIC0gTFxyXG4gICAgLy8gdSA9IChwQiAtIHBBKSAvIG5vcm0ocEIgLSBwQSlcclxuICAgIC8vIENkb3QgPSBkb3QodSwgdkIgKyBjcm9zcyh3QiwgckIpIC0gdkEgLSBjcm9zcyh3QSwgckEpKVxyXG4gICAgLy8gSiA9IFstdSAtY3Jvc3MockEsIHUpIHUgY3Jvc3MockIsIHUpXVxyXG4gICAgLy8gSyA9IEogKiBpbnZNICogSlRcclxuICAgIC8vICAgPSBpbnZNYXNzQSArIGludklBICogY3Jvc3MockEsIHUpXjIgKyBpbnZNYXNzQiArIGludklCICogY3Jvc3MockIsIHUpXjJcclxuXHJcbiAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAvLy8gQSByb3BlIGpvaW50IGVuZm9yY2VzIGEgbWF4aW11bSBkaXN0YW5jZSBiZXR3ZWVuIHR3byBwb2ludHNcclxuICAgIC8vLyBvbiB0d28gYm9kaWVzLiBJdCBoYXMgbm8gb3RoZXIgZWZmZWN0LlxyXG4gICAgLy8vIFdhcm5pbmc6IGlmIHlvdSBhdHRlbXB0IHRvIGNoYW5nZSB0aGUgbWF4aW11bSBsZW5ndGggZHVyaW5nXHJcbiAgICAvLy8gdGhlIHNpbXVsYXRpb24geW91IHdpbGwgZ2V0IHNvbWUgbm9uLXBoeXNpY2FsIGJlaGF2aW9yLlxyXG4gICAgLy8vIEEgbW9kZWwgdGhhdCB3b3VsZCBhbGxvdyB5b3UgdG8gZHluYW1pY2FsbHkgbW9kaWZ5IHRoZSBsZW5ndGhcclxuICAgIC8vLyB3b3VsZCBoYXZlIHNvbWUgc3BvbmdpbmVzcywgc28gSSBjaG9zZSBub3QgdG8gaW1wbGVtZW50IGl0XHJcbiAgICAvLy8gdGhhdCB3YXkuIFNlZSBiMkRpc3RhbmNlSm9pbnQgaWYgeW91IHdhbnQgdG8gZHluYW1pY2FsbHlcclxuICAgIC8vLyBjb250cm9sIGxlbmd0aC5cclxuICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICBwdWJsaWMgY2xhc3MgUm9wZUpvaW50IDogSm9pbnRcclxuICAgIHtcclxuICAgICAgICBwdWJsaWMgVmVjdG9yMiBMb2NhbEFuY2hvckE7XHJcbiAgICAgICAgcHVibGljIFZlY3RvcjIgTG9jYWxBbmNob3JCO1xyXG5cclxuICAgICAgICBwcml2YXRlIGZsb2F0IF9pbXB1bHNlO1xyXG4gICAgICAgIHByaXZhdGUgZmxvYXQgX2xlbmd0aDtcclxuXHJcbiAgICAgICAgcHJpdmF0ZSBmbG9hdCBfbWFzcztcclxuICAgICAgICBwcml2YXRlIFZlY3RvcjIgX3JBLCBfckI7XHJcbiAgICAgICAgcHJpdmF0ZSBMaW1pdFN0YXRlIF9zdGF0ZTtcclxuICAgICAgICBwcml2YXRlIFZlY3RvcjIgX3U7XHJcblxyXG4gICAgICAgIGludGVybmFsIFJvcGVKb2ludCgpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBKb2ludFR5cGUgPSBKb2ludFR5cGUuUm9wZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHB1YmxpYyBSb3BlSm9pbnQoQm9keSBib2R5QSwgQm9keSBib2R5QiwgVmVjdG9yMiBsb2NhbEFuY2hvckEsIFZlY3RvcjIgbG9jYWxBbmNob3JCKVxyXG4gICAgICAgICAgICA6IGJhc2UoYm9keUEsIGJvZHlCKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgSm9pbnRUeXBlID0gSm9pbnRUeXBlLlJvcGU7XHJcbiAgICAgICAgICAgIExvY2FsQW5jaG9yQSA9IGxvY2FsQW5jaG9yQTtcclxuICAgICAgICAgICAgTG9jYWxBbmNob3JCID0gbG9jYWxBbmNob3JCO1xyXG5cclxuICAgICAgICAgICAgVmVjdG9yMiBkID0gV29ybGRBbmNob3JCIC0gV29ybGRBbmNob3JBO1xyXG4gICAgICAgICAgICBNYXhMZW5ndGggPSBkLkxlbmd0aCgpO1xyXG5cclxuICAgICAgICAgICAgX21hc3MgPSAwLjBmO1xyXG4gICAgICAgICAgICBfaW1wdWxzZSA9IDAuMGY7XHJcbiAgICAgICAgICAgIF9zdGF0ZSA9IExpbWl0U3RhdGUuSW5hY3RpdmU7XHJcbiAgICAgICAgICAgIF9sZW5ndGggPSAwLjBmO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8vIEdldCB0aGUgbWF4aW11bSBsZW5ndGggb2YgdGhlIHJvcGUuXHJcbiAgICAgICAgcHVibGljIGZsb2F0IE1heExlbmd0aCB7IGdldDsgc2V0OyB9XHJcblxyXG4gICAgICAgIHB1YmxpYyBMaW1pdFN0YXRlIFN0YXRlXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBnZXQgeyByZXR1cm4gX3N0YXRlOyB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwdWJsaWMgb3ZlcnJpZGUgc2VhbGVkIFZlY3RvcjIgV29ybGRBbmNob3JBXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBnZXQgeyByZXR1cm4gQm9keUEuR2V0V29ybGRQb2ludChMb2NhbEFuY2hvckEpOyB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwdWJsaWMgb3ZlcnJpZGUgc2VhbGVkIFZlY3RvcjIgV29ybGRBbmNob3JCXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBnZXQgeyByZXR1cm4gQm9keUIuR2V0V29ybGRQb2ludChMb2NhbEFuY2hvckIpOyB9XHJcbiAgICAgICAgICAgIHNldCB7IERlYnVnLkFzc2VydChmYWxzZSwgXCJZb3UgY2FuJ3Qgc2V0IHRoZSB3b3JsZCBhbmNob3Igb24gdGhpcyBqb2ludCB0eXBlLlwiKTsgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHVibGljIG92ZXJyaWRlIFZlY3RvcjIgR2V0UmVhY3Rpb25Gb3JjZShmbG9hdCBpbnZEdClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiAoaW52RHQgKiBfaW1wdWxzZSkgKiBfdTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHB1YmxpYyBvdmVycmlkZSBmbG9hdCBHZXRSZWFjdGlvblRvcnF1ZShmbG9hdCBpbnZEdClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiAwO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaW50ZXJuYWwgb3ZlcnJpZGUgdm9pZCBJbml0VmVsb2NpdHlDb25zdHJhaW50cyhyZWYgVGltZVN0ZXAgc3RlcClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIEJvZHkgYkEgPSBCb2R5QTtcclxuICAgICAgICAgICAgQm9keSBiQiA9IEJvZHlCO1xyXG5cclxuICAgICAgICAgICAgVHJhbnNmb3JtIHhmMTtcclxuICAgICAgICAgICAgYkEuR2V0VHJhbnNmb3JtKG91dCB4ZjEpO1xyXG5cclxuICAgICAgICAgICAgVHJhbnNmb3JtIHhmMjtcclxuICAgICAgICAgICAgYkIuR2V0VHJhbnNmb3JtKG91dCB4ZjIpO1xyXG5cclxuICAgICAgICAgICAgX3JBID0gTWF0aFV0aWxzLk11bHRpcGx5KHJlZiB4ZjEuUiwgTG9jYWxBbmNob3JBIC0gYkEuTG9jYWxDZW50ZXIpO1xyXG4gICAgICAgICAgICBfckIgPSBNYXRoVXRpbHMuTXVsdGlwbHkocmVmIHhmMi5SLCBMb2NhbEFuY2hvckIgLSBiQi5Mb2NhbENlbnRlcik7XHJcblxyXG4gICAgICAgICAgICAvLyBSb3BlIGF4aXNcclxuICAgICAgICAgICAgX3UgPSBiQi5Td2VlcC5DICsgX3JCIC0gYkEuU3dlZXAuQyAtIF9yQTtcclxuXHJcbiAgICAgICAgICAgIF9sZW5ndGggPSBfdS5MZW5ndGgoKTtcclxuXHJcbiAgICAgICAgICAgIGZsb2F0IEMgPSBfbGVuZ3RoIC0gTWF4TGVuZ3RoO1xyXG4gICAgICAgICAgICBpZiAoQyA+IDAuMGYpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIF9zdGF0ZSA9IExpbWl0U3RhdGUuQXRVcHBlcjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIF9zdGF0ZSA9IExpbWl0U3RhdGUuSW5hY3RpdmU7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmIChfbGVuZ3RoID4gU2V0dGluZ3MuTGluZWFyU2xvcClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgX3UgKj0gMS4wZiAvIF9sZW5ndGg7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBfdSA9IFZlY3RvcjIuWmVybztcclxuICAgICAgICAgICAgICAgIF9tYXNzID0gMC4wZjtcclxuICAgICAgICAgICAgICAgIF9pbXB1bHNlID0gMC4wZjtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gQ29tcHV0ZSBlZmZlY3RpdmUgbWFzcy5cclxuICAgICAgICAgICAgZmxvYXQgY3JBID0gTWF0aFV0aWxzLkNyb3NzKF9yQSwgX3UpO1xyXG4gICAgICAgICAgICBmbG9hdCBjckIgPSBNYXRoVXRpbHMuQ3Jvc3MoX3JCLCBfdSk7XHJcbiAgICAgICAgICAgIGZsb2F0IGludk1hc3MgPSBiQS5JbnZNYXNzICsgYkEuSW52SSAqIGNyQSAqIGNyQSArIGJCLkludk1hc3MgKyBiQi5JbnZJICogY3JCICogY3JCO1xyXG5cclxuICAgICAgICAgICAgX21hc3MgPSBpbnZNYXNzICE9IDAuMGYgPyAxLjBmIC8gaW52TWFzcyA6IDAuMGY7XHJcblxyXG4gICAgICAgICAgICBpZiAoU2V0dGluZ3MuRW5hYmxlV2FybXN0YXJ0aW5nKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAvLyBTY2FsZSB0aGUgaW1wdWxzZSB0byBzdXBwb3J0IGEgdmFyaWFibGUgdGltZSBzdGVwLlxyXG4gICAgICAgICAgICAgICAgX2ltcHVsc2UgKj0gc3RlcC5kdFJhdGlvO1xyXG5cclxuICAgICAgICAgICAgICAgIFZlY3RvcjIgUCA9IF9pbXB1bHNlICogX3U7XHJcbiAgICAgICAgICAgICAgICBiQS5MaW5lYXJWZWxvY2l0eSAtPSBiQS5JbnZNYXNzICogUDtcclxuICAgICAgICAgICAgICAgIGJBLkFuZ3VsYXJWZWxvY2l0eSAtPSBiQS5JbnZJICogTWF0aFV0aWxzLkNyb3NzKF9yQSwgUCk7XHJcbiAgICAgICAgICAgICAgICBiQi5MaW5lYXJWZWxvY2l0eSArPSBiQi5JbnZNYXNzICogUDtcclxuICAgICAgICAgICAgICAgIGJCLkFuZ3VsYXJWZWxvY2l0eSArPSBiQi5JbnZJICogTWF0aFV0aWxzLkNyb3NzKF9yQiwgUCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBfaW1wdWxzZSA9IDAuMGY7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGludGVybmFsIG92ZXJyaWRlIHZvaWQgU29sdmVWZWxvY2l0eUNvbnN0cmFpbnRzKHJlZiBUaW1lU3RlcCBzdGVwKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgQm9keSBiQSA9IEJvZHlBO1xyXG4gICAgICAgICAgICBCb2R5IGJCID0gQm9keUI7XHJcblxyXG4gICAgICAgICAgICAvLyBDZG90ID0gZG90KHUsIHYgKyBjcm9zcyh3LCByKSlcclxuICAgICAgICAgICAgVmVjdG9yMiB2QSA9IGJBLkxpbmVhclZlbG9jaXR5ICsgTWF0aFV0aWxzLkNyb3NzKGJBLkFuZ3VsYXJWZWxvY2l0eSwgX3JBKTtcclxuICAgICAgICAgICAgVmVjdG9yMiB2QiA9IGJCLkxpbmVhclZlbG9jaXR5ICsgTWF0aFV0aWxzLkNyb3NzKGJCLkFuZ3VsYXJWZWxvY2l0eSwgX3JCKTtcclxuICAgICAgICAgICAgZmxvYXQgQyA9IF9sZW5ndGggLSBNYXhMZW5ndGg7XHJcbiAgICAgICAgICAgIGZsb2F0IENkb3QgPSBWZWN0b3IyLkRvdChfdSwgdkIgLSB2QSk7XHJcblxyXG4gICAgICAgICAgICAvLyBQcmVkaWN0aXZlIGNvbnN0cmFpbnQuXHJcbiAgICAgICAgICAgIGlmIChDIDwgMC4wZilcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgQ2RvdCArPSBzdGVwLmludl9kdCAqIEM7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGZsb2F0IGltcHVsc2UgPSAtX21hc3MgKiBDZG90O1xyXG4gICAgICAgICAgICBmbG9hdCBvbGRJbXB1bHNlID0gX2ltcHVsc2U7XHJcbiAgICAgICAgICAgIF9pbXB1bHNlID0gTWF0aC5NaW4oMC4wZiwgX2ltcHVsc2UgKyBpbXB1bHNlKTtcclxuICAgICAgICAgICAgaW1wdWxzZSA9IF9pbXB1bHNlIC0gb2xkSW1wdWxzZTtcclxuXHJcbiAgICAgICAgICAgIFZlY3RvcjIgUCA9IGltcHVsc2UgKiBfdTtcclxuICAgICAgICAgICAgYkEuTGluZWFyVmVsb2NpdHkgLT0gYkEuSW52TWFzcyAqIFA7XHJcbiAgICAgICAgICAgIGJBLkFuZ3VsYXJWZWxvY2l0eSAtPSBiQS5JbnZJICogTWF0aFV0aWxzLkNyb3NzKF9yQSwgUCk7XHJcbiAgICAgICAgICAgIGJCLkxpbmVhclZlbG9jaXR5ICs9IGJCLkludk1hc3MgKiBQO1xyXG4gICAgICAgICAgICBiQi5Bbmd1bGFyVmVsb2NpdHkgKz0gYkIuSW52SSAqIE1hdGhVdGlscy5Dcm9zcyhfckIsIFApO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaW50ZXJuYWwgb3ZlcnJpZGUgYm9vbCBTb2x2ZVBvc2l0aW9uQ29uc3RyYWludHMoKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgQm9keSBiQSA9IEJvZHlBO1xyXG4gICAgICAgICAgICBCb2R5IGJCID0gQm9keUI7XHJcblxyXG4gICAgICAgICAgICBUcmFuc2Zvcm0geGYxO1xyXG4gICAgICAgICAgICBiQS5HZXRUcmFuc2Zvcm0ob3V0IHhmMSk7XHJcblxyXG4gICAgICAgICAgICBUcmFuc2Zvcm0geGYyO1xyXG4gICAgICAgICAgICBiQi5HZXRUcmFuc2Zvcm0ob3V0IHhmMik7XHJcblxyXG4gICAgICAgICAgICBWZWN0b3IyIHJBID0gTWF0aFV0aWxzLk11bHRpcGx5KHJlZiB4ZjEuUiwgTG9jYWxBbmNob3JBIC0gYkEuTG9jYWxDZW50ZXIpO1xyXG4gICAgICAgICAgICBWZWN0b3IyIHJCID0gTWF0aFV0aWxzLk11bHRpcGx5KHJlZiB4ZjIuUiwgTG9jYWxBbmNob3JCIC0gYkIuTG9jYWxDZW50ZXIpO1xyXG5cclxuICAgICAgICAgICAgVmVjdG9yMiB1ID0gYkIuU3dlZXAuQyArIHJCIC0gYkEuU3dlZXAuQyAtIHJBO1xyXG5cclxuXHJcbiAgICAgICAgICAgIGZsb2F0IGxlbmd0aCA9IHUuTGVuZ3RoKCk7XHJcbiAgICAgICAgICAgIHUuTm9ybWFsaXplKCk7XHJcblxyXG4gICAgICAgICAgICBmbG9hdCBDID0gbGVuZ3RoIC0gTWF4TGVuZ3RoO1xyXG5cclxuICAgICAgICAgICAgQyA9IE1hdGhVdGlscy5DbGFtcChDLCAwLjBmLCBTZXR0aW5ncy5NYXhMaW5lYXJDb3JyZWN0aW9uKTtcclxuXHJcbiAgICAgICAgICAgIGZsb2F0IGltcHVsc2UgPSAtX21hc3MgKiBDO1xyXG4gICAgICAgICAgICBWZWN0b3IyIFAgPSBpbXB1bHNlICogdTtcclxuXHJcbiAgICAgICAgICAgIGJBLlN3ZWVwLkMgLT0gYkEuSW52TWFzcyAqIFA7XHJcbiAgICAgICAgICAgIGJBLlN3ZWVwLkEgLT0gYkEuSW52SSAqIE1hdGhVdGlscy5Dcm9zcyhyQSwgUCk7XHJcbiAgICAgICAgICAgIGJCLlN3ZWVwLkMgKz0gYkIuSW52TWFzcyAqIFA7XHJcbiAgICAgICAgICAgIGJCLlN3ZWVwLkEgKz0gYkIuSW52SSAqIE1hdGhVdGlscy5Dcm9zcyhyQiwgUCk7XHJcblxyXG4gICAgICAgICAgICBiQS5TeW5jaHJvbml6ZVRyYW5zZm9ybSgpO1xyXG4gICAgICAgICAgICBiQi5TeW5jaHJvbml6ZVRyYW5zZm9ybSgpO1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIGxlbmd0aCAtIE1heExlbmd0aCA8IFNldHRpbmdzLkxpbmVhclNsb3A7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59IiwiLypcclxuKiBGYXJzZWVyIFBoeXNpY3MgRW5naW5lIGJhc2VkIG9uIEJveDJELlhOQSBwb3J0OlxyXG4qIENvcHlyaWdodCAoYykgMjAxMCBJYW4gUXZpc3RcclxuKiBcclxuKiBCb3gyRC5YTkEgcG9ydCBvZiBCb3gyRDpcclxuKiBDb3B5cmlnaHQgKGMpIDIwMDkgQnJhbmRvbiBGdXJ0d2FuZ2xlciwgTmF0aGFuIEZ1cnR3YW5nbGVyXHJcbipcclxuKiBPcmlnaW5hbCBzb3VyY2UgQm94MkQ6XHJcbiogQ29weXJpZ2h0IChjKSAyMDA2LTIwMDkgRXJpbiBDYXR0byBodHRwOi8vd3d3LmdwaHlzaWNzLmNvbSBcclxuKiBcclxuKiBUaGlzIHNvZnR3YXJlIGlzIHByb3ZpZGVkICdhcy1pcycsIHdpdGhvdXQgYW55IGV4cHJlc3Mgb3IgaW1wbGllZCBcclxuKiB3YXJyYW50eS4gIEluIG5vIGV2ZW50IHdpbGwgdGhlIGF1dGhvcnMgYmUgaGVsZCBsaWFibGUgZm9yIGFueSBkYW1hZ2VzIFxyXG4qIGFyaXNpbmcgZnJvbSB0aGUgdXNlIG9mIHRoaXMgc29mdHdhcmUuIFxyXG4qIFBlcm1pc3Npb24gaXMgZ3JhbnRlZCB0byBhbnlvbmUgdG8gdXNlIHRoaXMgc29mdHdhcmUgZm9yIGFueSBwdXJwb3NlLCBcclxuKiBpbmNsdWRpbmcgY29tbWVyY2lhbCBhcHBsaWNhdGlvbnMsIGFuZCB0byBhbHRlciBpdCBhbmQgcmVkaXN0cmlidXRlIGl0IFxyXG4qIGZyZWVseSwgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIHJlc3RyaWN0aW9uczogXHJcbiogMS4gVGhlIG9yaWdpbiBvZiB0aGlzIHNvZnR3YXJlIG11c3Qgbm90IGJlIG1pc3JlcHJlc2VudGVkOyB5b3UgbXVzdCBub3QgXHJcbiogY2xhaW0gdGhhdCB5b3Ugd3JvdGUgdGhlIG9yaWdpbmFsIHNvZnR3YXJlLiBJZiB5b3UgdXNlIHRoaXMgc29mdHdhcmUgXHJcbiogaW4gYSBwcm9kdWN0LCBhbiBhY2tub3dsZWRnbWVudCBpbiB0aGUgcHJvZHVjdCBkb2N1bWVudGF0aW9uIHdvdWxkIGJlIFxyXG4qIGFwcHJlY2lhdGVkIGJ1dCBpcyBub3QgcmVxdWlyZWQuIFxyXG4qIDIuIEFsdGVyZWQgc291cmNlIHZlcnNpb25zIG11c3QgYmUgcGxhaW5seSBtYXJrZWQgYXMgc3VjaCwgYW5kIG11c3Qgbm90IGJlIFxyXG4qIG1pc3JlcHJlc2VudGVkIGFzIGJlaW5nIHRoZSBvcmlnaW5hbCBzb2Z0d2FyZS4gXHJcbiogMy4gVGhpcyBub3RpY2UgbWF5IG5vdCBiZSByZW1vdmVkIG9yIGFsdGVyZWQgZnJvbSBhbnkgc291cmNlIGRpc3RyaWJ1dGlvbi4gXHJcbiovXHJcblxyXG51c2luZyBTeXN0ZW07XHJcbnVzaW5nIFN5c3RlbS5EaWFnbm9zdGljcztcclxudXNpbmcgRmFyc2VlclBoeXNpY3MuQ29tbW9uO1xyXG51c2luZyBNaWNyb3NvZnQuWG5hLkZyYW1ld29yaztcclxuXHJcbm5hbWVzcGFjZSBGYXJzZWVyUGh5c2ljcy5EeW5hbWljcy5Kb2ludHNcclxue1xyXG4gICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgLy8vIEEgZGlzdGFuY2Ugam9pbnQgY29udHJhaW5zIHR3byBwb2ludHMgb24gdHdvIGJvZGllc1xyXG4gICAgLy8vIHRvIHJlbWFpbiBhdCBhIGZpeGVkIGRpc3RhbmNlIGZyb20gZWFjaCBvdGhlci4gWW91IGNhbiB2aWV3XHJcbiAgICAvLy8gdGhpcyBhcyBhIG1hc3NsZXNzLCByaWdpZCByb2QuXHJcbiAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgcHVibGljIGNsYXNzIFNsaWRlckpvaW50IDogSm9pbnRcclxuICAgIHtcclxuICAgICAgICAvLyAxLUQgY29uc3RyYWluZWQgc3lzdGVtXHJcbiAgICAgICAgLy8gbSAodjIgLSB2MSkgPSBsYW1iZGFcclxuICAgICAgICAvLyB2MiArIChiZXRhL2gpICogeDEgKyBnYW1tYSAqIGxhbWJkYSA9IDAsIGdhbW1hIGhhcyB1bml0cyBvZiBpbnZlcnNlIG1hc3MuXHJcbiAgICAgICAgLy8geDIgPSB4MSArIGggKiB2MlxyXG5cclxuICAgICAgICAvLyAxLUQgbWFzcy1kYW1wZXItc3ByaW5nIHN5c3RlbVxyXG4gICAgICAgIC8vIG0gKHYyIC0gdjEpICsgaCAqIGQgKiB2MiArIGggKiBrICogXHJcblxyXG4gICAgICAgIC8vIEMgPSBub3JtKHAyIC0gcDEpIC0gTFxyXG4gICAgICAgIC8vIHUgPSAocDIgLSBwMSkgLyBub3JtKHAyIC0gcDEpXHJcbiAgICAgICAgLy8gQ2RvdCA9IGRvdCh1LCB2MiArIGNyb3NzKHcyLCByMikgLSB2MSAtIGNyb3NzKHcxLCByMSkpXHJcbiAgICAgICAgLy8gSiA9IFstdSAtY3Jvc3MocjEsIHUpIHUgY3Jvc3MocjIsIHUpXVxyXG4gICAgICAgIC8vIEsgPSBKICogaW52TSAqIEpUXHJcbiAgICAgICAgLy8gICA9IGludk1hc3MxICsgaW52STEgKiBjcm9zcyhyMSwgdSleMiArIGludk1hc3MyICsgaW52STIgKiBjcm9zcyhyMiwgdSleMlxyXG5cclxuICAgICAgICBwdWJsaWMgVmVjdG9yMiBMb2NhbEFuY2hvckE7XHJcblxyXG4gICAgICAgIHB1YmxpYyBWZWN0b3IyIExvY2FsQW5jaG9yQjtcclxuICAgICAgICBwcml2YXRlIGZsb2F0IF9iaWFzO1xyXG4gICAgICAgIHByaXZhdGUgZmxvYXQgX2dhbW1hO1xyXG4gICAgICAgIHByaXZhdGUgZmxvYXQgX2ltcHVsc2U7XHJcbiAgICAgICAgcHJpdmF0ZSBmbG9hdCBfbWFzcztcclxuICAgICAgICBwcml2YXRlIFZlY3RvcjIgX3U7XHJcblxyXG4gICAgICAgIGludGVybmFsIFNsaWRlckpvaW50KClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIEpvaW50VHlwZSA9IEpvaW50VHlwZS5TbGlkZXI7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIEluaXRpYWxpemVzIGEgbmV3IGluc3RhbmNlIG9mIHRoZSA8c2VlIGNyZWY9XCJTbGlkZXJKb2ludFwiLz4gY2xhc3MuXHJcbiAgICAgICAgLy8vIFdhcm5pbmc6IERvIG5vdCB1c2UgYSB6ZXJvIG9yIHNob3J0IGxlbmd0aC5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cImJvZHlBXCI+VGhlIGZpcnN0IGJvZHkuPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJib2R5QlwiPlRoZSBzZWNvbmQgYm9keS48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cImxvY2FsQW5jaG9yQVwiPlRoZSBmaXJzdCBib2R5IGFuY2hvci48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cImxvY2FsQW5jaG9yQlwiPlRoZSBzZWNvbmQgYm9keSBhbmNob3IuPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJtaW5MZW5ndGhcIj5UaGUgbWluaW11bSBsZW5ndGggYmV0d2VlbiBhbmNob3Jwb2ludHM8L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cIm1heGxlbmd0aFwiPlRoZSBtYXhpbXVtIGxlbmd0aCBiZXR3ZWVuIGFuY2hvcnBvaW50cy48L3BhcmFtPlxyXG4gICAgICAgIHB1YmxpYyBTbGlkZXJKb2ludChCb2R5IGJvZHlBLCBCb2R5IGJvZHlCLCBWZWN0b3IyIGxvY2FsQW5jaG9yQSwgVmVjdG9yMiBsb2NhbEFuY2hvckIsIGZsb2F0IG1pbkxlbmd0aCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgZmxvYXQgbWF4bGVuZ3RoKVxyXG4gICAgICAgICAgICA6IGJhc2UoYm9keUEsIGJvZHlCKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgSm9pbnRUeXBlID0gSm9pbnRUeXBlLlNsaWRlcjtcclxuXHJcbiAgICAgICAgICAgIExvY2FsQW5jaG9yQSA9IGxvY2FsQW5jaG9yQTtcclxuICAgICAgICAgICAgTG9jYWxBbmNob3JCID0gbG9jYWxBbmNob3JCO1xyXG4gICAgICAgICAgICBNYXhMZW5ndGggPSBtYXhsZW5ndGg7XHJcbiAgICAgICAgICAgIE1pbkxlbmd0aCA9IG1pbkxlbmd0aDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gVGhlIG1heGltdW0gbGVuZ3RoIGJldHdlZW4gdGhlIGFuY2hvciBwb2ludHMuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHZhbHVlPlRoZSBsZW5ndGguPC92YWx1ZT5cclxuICAgICAgICBwdWJsaWMgZmxvYXQgTWF4TGVuZ3RoIHsgZ2V0OyBzZXQ7IH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBUaGUgbWluaW1hbCBsZW5ndGggYmV0d2VlbiB0aGUgYW5jaG9yIHBvaW50cy5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8dmFsdWU+VGhlIGxlbmd0aC48L3ZhbHVlPlxyXG4gICAgICAgIHB1YmxpYyBmbG9hdCBNaW5MZW5ndGggeyBnZXQ7IHNldDsgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIFRoZSBtYXNzLXNwcmluZy1kYW1wZXIgZnJlcXVlbmN5IGluIEhlcnR6LlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDx2YWx1ZT5UaGUgZnJlcXVlbmN5LjwvdmFsdWU+XHJcbiAgICAgICAgcHVibGljIGZsb2F0IEZyZXF1ZW5jeSB7IGdldDsgc2V0OyB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gVGhlIGRhbXBpbmcgcmF0aW8uIDAgPSBubyBkYW1waW5nLCAxID0gY3JpdGljYWwgZGFtcGluZy5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8dmFsdWU+VGhlIGRhbXBpbmcgcmF0aW8uPC92YWx1ZT5cclxuICAgICAgICBwdWJsaWMgZmxvYXQgRGFtcGluZ1JhdGlvIHsgZ2V0OyBzZXQ7IH1cclxuXHJcbiAgICAgICAgcHVibGljIG92ZXJyaWRlIFZlY3RvcjIgV29ybGRBbmNob3JBXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBnZXQgeyByZXR1cm4gQm9keUEuR2V0V29ybGRQb2ludChMb2NhbEFuY2hvckEpOyB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwdWJsaWMgb3ZlcnJpZGUgVmVjdG9yMiBXb3JsZEFuY2hvckJcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGdldCB7IHJldHVybiBCb2R5Qi5HZXRXb3JsZFBvaW50KExvY2FsQW5jaG9yQik7IH1cclxuICAgICAgICAgICAgc2V0IHsgRGVidWcuQXNzZXJ0KGZhbHNlLCBcIllvdSBjYW4ndCBzZXQgdGhlIHdvcmxkIGFuY2hvciBvbiB0aGlzIGpvaW50IHR5cGUuXCIpOyB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwdWJsaWMgb3ZlcnJpZGUgVmVjdG9yMiBHZXRSZWFjdGlvbkZvcmNlKGZsb2F0IGludl9kdClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIFZlY3RvcjIgRiA9IChpbnZfZHQgKiBfaW1wdWxzZSkgKiBfdTtcclxuICAgICAgICAgICAgcmV0dXJuIEY7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwdWJsaWMgb3ZlcnJpZGUgZmxvYXQgR2V0UmVhY3Rpb25Ub3JxdWUoZmxvYXQgaW52X2R0KVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIDAuMGY7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpbnRlcm5hbCBvdmVycmlkZSB2b2lkIEluaXRWZWxvY2l0eUNvbnN0cmFpbnRzKHJlZiBUaW1lU3RlcCBzdGVwKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgQm9keSBiMSA9IEJvZHlBO1xyXG4gICAgICAgICAgICBCb2R5IGIyID0gQm9keUI7XHJcblxyXG4gICAgICAgICAgICBUcmFuc2Zvcm0geGYxLCB4ZjI7XHJcbiAgICAgICAgICAgIGIxLkdldFRyYW5zZm9ybShvdXQgeGYxKTtcclxuICAgICAgICAgICAgYjIuR2V0VHJhbnNmb3JtKG91dCB4ZjIpO1xyXG5cclxuICAgICAgICAgICAgLy8gQ29tcHV0ZSB0aGUgZWZmZWN0aXZlIG1hc3MgbWF0cml4LlxyXG4gICAgICAgICAgICBWZWN0b3IyIHIxID0gTWF0aFV0aWxzLk11bHRpcGx5KHJlZiB4ZjEuUiwgTG9jYWxBbmNob3JBIC0gYjEuTG9jYWxDZW50ZXIpO1xyXG4gICAgICAgICAgICBWZWN0b3IyIHIyID0gTWF0aFV0aWxzLk11bHRpcGx5KHJlZiB4ZjIuUiwgTG9jYWxBbmNob3JCIC0gYjIuTG9jYWxDZW50ZXIpO1xyXG4gICAgICAgICAgICBfdSA9IGIyLlN3ZWVwLkMgKyByMiAtIGIxLlN3ZWVwLkMgLSByMTtcclxuXHJcbiAgICAgICAgICAgIC8vIEhhbmRsZSBzaW5ndWxhcml0eS5cclxuICAgICAgICAgICAgZmxvYXQgbGVuZ3RoID0gX3UuTGVuZ3RoKCk7XHJcblxyXG4gICAgICAgICAgICBpZiAobGVuZ3RoIDwgTWF4TGVuZ3RoICYmIGxlbmd0aCA+IE1pbkxlbmd0aClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAobGVuZ3RoID4gU2V0dGluZ3MuTGluZWFyU2xvcClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgX3UgKj0gMS4wZiAvIGxlbmd0aDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIF91ID0gVmVjdG9yMi5aZXJvO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBmbG9hdCBjcjF1ID0gTWF0aFV0aWxzLkNyb3NzKHIxLCBfdSk7XHJcbiAgICAgICAgICAgIGZsb2F0IGNyMnUgPSBNYXRoVXRpbHMuQ3Jvc3MocjIsIF91KTtcclxuICAgICAgICAgICAgZmxvYXQgaW52TWFzcyA9IGIxLkludk1hc3MgKyBiMS5JbnZJICogY3IxdSAqIGNyMXUgKyBiMi5JbnZNYXNzICsgYjIuSW52SSAqIGNyMnUgKiBjcjJ1O1xyXG4gICAgICAgICAgICBEZWJ1Zy5Bc3NlcnQoaW52TWFzcyA+IFNldHRpbmdzLkVwc2lsb24pO1xyXG4gICAgICAgICAgICBfbWFzcyA9IGludk1hc3MgIT0gMC4wZiA/IDEuMGYgLyBpbnZNYXNzIDogMC4wZjtcclxuXHJcbiAgICAgICAgICAgIGlmIChGcmVxdWVuY3kgPiAwLjBmKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBmbG9hdCBDID0gbGVuZ3RoIC0gTWF4TGVuZ3RoO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIEZyZXF1ZW5jeVxyXG4gICAgICAgICAgICAgICAgZmxvYXQgb21lZ2EgPSAyLjBmICogU2V0dGluZ3MuUGkgKiBGcmVxdWVuY3k7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gRGFtcGluZyBjb2VmZmljaWVudFxyXG4gICAgICAgICAgICAgICAgZmxvYXQgZCA9IDIuMGYgKiBfbWFzcyAqIERhbXBpbmdSYXRpbyAqIG9tZWdhO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIFNwcmluZyBzdGlmZm5lc3NcclxuICAgICAgICAgICAgICAgIGZsb2F0IGsgPSBfbWFzcyAqIG9tZWdhICogb21lZ2E7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gbWFnaWMgZm9ybXVsYXNcclxuICAgICAgICAgICAgICAgIF9nYW1tYSA9IHN0ZXAuZHQgKiAoZCArIHN0ZXAuZHQgKiBrKTtcclxuICAgICAgICAgICAgICAgIF9nYW1tYSA9IF9nYW1tYSAhPSAwLjBmID8gMS4wZiAvIF9nYW1tYSA6IDAuMGY7XHJcbiAgICAgICAgICAgICAgICBfYmlhcyA9IEMgKiBzdGVwLmR0ICogayAqIF9nYW1tYTtcclxuXHJcbiAgICAgICAgICAgICAgICBfbWFzcyA9IGludk1hc3MgKyBfZ2FtbWE7XHJcbiAgICAgICAgICAgICAgICBfbWFzcyA9IF9tYXNzICE9IDAuMGYgPyAxLjBmIC8gX21hc3MgOiAwLjBmO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAoU2V0dGluZ3MuRW5hYmxlV2FybXN0YXJ0aW5nKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAvLyBTY2FsZSB0aGUgaW1wdWxzZSB0byBzdXBwb3J0IGEgdmFyaWFibGUgdGltZSBzdGVwLlxyXG4gICAgICAgICAgICAgICAgX2ltcHVsc2UgKj0gc3RlcC5kdFJhdGlvO1xyXG5cclxuICAgICAgICAgICAgICAgIFZlY3RvcjIgUCA9IF9pbXB1bHNlICogX3U7XHJcbiAgICAgICAgICAgICAgICBiMS5MaW5lYXJWZWxvY2l0eUludGVybmFsIC09IGIxLkludk1hc3MgKiBQO1xyXG4gICAgICAgICAgICAgICAgYjEuQW5ndWxhclZlbG9jaXR5SW50ZXJuYWwgLT0gYjEuSW52SSAqIE1hdGhVdGlscy5Dcm9zcyhyMSwgUCk7XHJcbiAgICAgICAgICAgICAgICBiMi5MaW5lYXJWZWxvY2l0eUludGVybmFsICs9IGIyLkludk1hc3MgKiBQO1xyXG4gICAgICAgICAgICAgICAgYjIuQW5ndWxhclZlbG9jaXR5SW50ZXJuYWwgKz0gYjIuSW52SSAqIE1hdGhVdGlscy5Dcm9zcyhyMiwgUCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBfaW1wdWxzZSA9IDAuMGY7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGludGVybmFsIG92ZXJyaWRlIHZvaWQgU29sdmVWZWxvY2l0eUNvbnN0cmFpbnRzKHJlZiBUaW1lU3RlcCBzdGVwKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgQm9keSBiMSA9IEJvZHlBO1xyXG4gICAgICAgICAgICBCb2R5IGIyID0gQm9keUI7XHJcblxyXG4gICAgICAgICAgICBUcmFuc2Zvcm0geGYxLCB4ZjI7XHJcbiAgICAgICAgICAgIGIxLkdldFRyYW5zZm9ybShvdXQgeGYxKTtcclxuICAgICAgICAgICAgYjIuR2V0VHJhbnNmb3JtKG91dCB4ZjIpO1xyXG5cclxuICAgICAgICAgICAgVmVjdG9yMiByMSA9IE1hdGhVdGlscy5NdWx0aXBseShyZWYgeGYxLlIsIExvY2FsQW5jaG9yQSAtIGIxLkxvY2FsQ2VudGVyKTtcclxuICAgICAgICAgICAgVmVjdG9yMiByMiA9IE1hdGhVdGlscy5NdWx0aXBseShyZWYgeGYyLlIsIExvY2FsQW5jaG9yQiAtIGIyLkxvY2FsQ2VudGVyKTtcclxuXHJcbiAgICAgICAgICAgIFZlY3RvcjIgZCA9IGIyLlN3ZWVwLkMgKyByMiAtIGIxLlN3ZWVwLkMgLSByMTtcclxuXHJcbiAgICAgICAgICAgIGZsb2F0IGxlbmd0aCA9IGQuTGVuZ3RoKCk7XHJcblxyXG4gICAgICAgICAgICBpZiAobGVuZ3RoIDwgTWF4TGVuZ3RoICYmIGxlbmd0aCA+IE1pbkxlbmd0aClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBDZG90ID0gZG90KHUsIHYgKyBjcm9zcyh3LCByKSlcclxuICAgICAgICAgICAgVmVjdG9yMiB2MSA9IGIxLkxpbmVhclZlbG9jaXR5SW50ZXJuYWwgKyBNYXRoVXRpbHMuQ3Jvc3MoYjEuQW5ndWxhclZlbG9jaXR5SW50ZXJuYWwsIHIxKTtcclxuICAgICAgICAgICAgVmVjdG9yMiB2MiA9IGIyLkxpbmVhclZlbG9jaXR5SW50ZXJuYWwgKyBNYXRoVXRpbHMuQ3Jvc3MoYjIuQW5ndWxhclZlbG9jaXR5SW50ZXJuYWwsIHIyKTtcclxuICAgICAgICAgICAgZmxvYXQgQ2RvdCA9IFZlY3RvcjIuRG90KF91LCB2MiAtIHYxKTtcclxuXHJcbiAgICAgICAgICAgIGZsb2F0IGltcHVsc2UgPSAtX21hc3MgKiAoQ2RvdCArIF9iaWFzICsgX2dhbW1hICogX2ltcHVsc2UpO1xyXG4gICAgICAgICAgICBfaW1wdWxzZSArPSBpbXB1bHNlO1xyXG5cclxuICAgICAgICAgICAgVmVjdG9yMiBQID0gaW1wdWxzZSAqIF91O1xyXG4gICAgICAgICAgICBiMS5MaW5lYXJWZWxvY2l0eUludGVybmFsIC09IGIxLkludk1hc3MgKiBQO1xyXG4gICAgICAgICAgICBiMS5Bbmd1bGFyVmVsb2NpdHlJbnRlcm5hbCAtPSBiMS5JbnZJICogTWF0aFV0aWxzLkNyb3NzKHIxLCBQKTtcclxuICAgICAgICAgICAgYjIuTGluZWFyVmVsb2NpdHlJbnRlcm5hbCArPSBiMi5JbnZNYXNzICogUDtcclxuICAgICAgICAgICAgYjIuQW5ndWxhclZlbG9jaXR5SW50ZXJuYWwgKz0gYjIuSW52SSAqIE1hdGhVdGlscy5Dcm9zcyhyMiwgUCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpbnRlcm5hbCBvdmVycmlkZSBib29sIFNvbHZlUG9zaXRpb25Db25zdHJhaW50cygpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBpZiAoRnJlcXVlbmN5ID4gMC4wZilcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgLy8gVGhlcmUgaXMgbm8gcG9zaXRpb24gY29ycmVjdGlvbiBmb3Igc29mdCBkaXN0YW5jZSBjb25zdHJhaW50cy5cclxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBCb2R5IGIxID0gQm9keUE7XHJcbiAgICAgICAgICAgIEJvZHkgYjIgPSBCb2R5QjtcclxuXHJcbiAgICAgICAgICAgIFRyYW5zZm9ybSB4ZjEsIHhmMjtcclxuICAgICAgICAgICAgYjEuR2V0VHJhbnNmb3JtKG91dCB4ZjEpO1xyXG4gICAgICAgICAgICBiMi5HZXRUcmFuc2Zvcm0ob3V0IHhmMik7XHJcblxyXG4gICAgICAgICAgICBWZWN0b3IyIHIxID0gTWF0aFV0aWxzLk11bHRpcGx5KHJlZiB4ZjEuUiwgTG9jYWxBbmNob3JBIC0gYjEuTG9jYWxDZW50ZXIpO1xyXG4gICAgICAgICAgICBWZWN0b3IyIHIyID0gTWF0aFV0aWxzLk11bHRpcGx5KHJlZiB4ZjIuUiwgTG9jYWxBbmNob3JCIC0gYjIuTG9jYWxDZW50ZXIpO1xyXG5cclxuICAgICAgICAgICAgVmVjdG9yMiBkID0gYjIuU3dlZXAuQyArIHIyIC0gYjEuU3dlZXAuQyAtIHIxO1xyXG5cclxuICAgICAgICAgICAgZmxvYXQgbGVuZ3RoID0gZC5MZW5ndGgoKTtcclxuXHJcbiAgICAgICAgICAgIGlmIChsZW5ndGggPCBNYXhMZW5ndGggJiYgbGVuZ3RoID4gTWluTGVuZ3RoKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKGxlbmd0aCA9PSAwLjBmKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcblxyXG4gICAgICAgICAgICBkIC89IGxlbmd0aDtcclxuICAgICAgICAgICAgZmxvYXQgQyA9IGxlbmd0aCAtIE1heExlbmd0aDtcclxuICAgICAgICAgICAgQyA9IE1hdGhVdGlscy5DbGFtcChDLCAtU2V0dGluZ3MuTWF4TGluZWFyQ29ycmVjdGlvbiwgU2V0dGluZ3MuTWF4TGluZWFyQ29ycmVjdGlvbik7XHJcblxyXG4gICAgICAgICAgICBmbG9hdCBpbXB1bHNlID0gLV9tYXNzICogQztcclxuICAgICAgICAgICAgX3UgPSBkO1xyXG4gICAgICAgICAgICBWZWN0b3IyIFAgPSBpbXB1bHNlICogX3U7XHJcblxyXG4gICAgICAgICAgICBiMS5Td2VlcC5DIC09IGIxLkludk1hc3MgKiBQO1xyXG4gICAgICAgICAgICBiMS5Td2VlcC5BIC09IGIxLkludkkgKiBNYXRoVXRpbHMuQ3Jvc3MocjEsIFApO1xyXG4gICAgICAgICAgICBiMi5Td2VlcC5DICs9IGIyLkludk1hc3MgKiBQO1xyXG4gICAgICAgICAgICBiMi5Td2VlcC5BICs9IGIyLkludkkgKiBNYXRoVXRpbHMuQ3Jvc3MocjIsIFApO1xyXG5cclxuICAgICAgICAgICAgYjEuU3luY2hyb25pemVUcmFuc2Zvcm0oKTtcclxuICAgICAgICAgICAgYjIuU3luY2hyb25pemVUcmFuc2Zvcm0oKTtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiBNYXRoLkFicyhDKSA8IFNldHRpbmdzLkxpbmVhclNsb3A7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59IiwiLypcclxuKiBGYXJzZWVyIFBoeXNpY3MgRW5naW5lIGJhc2VkIG9uIEJveDJELlhOQSBwb3J0OlxyXG4qIENvcHlyaWdodCAoYykgMjAxMCBJYW4gUXZpc3RcclxuKiBcclxuKiBCb3gyRC5YTkEgcG9ydCBvZiBCb3gyRDpcclxuKiBDb3B5cmlnaHQgKGMpIDIwMDkgQnJhbmRvbiBGdXJ0d2FuZ2xlciwgTmF0aGFuIEZ1cnR3YW5nbGVyXHJcbipcclxuKiBPcmlnaW5hbCBzb3VyY2UgQm94MkQ6XHJcbiogQ29weXJpZ2h0IChjKSAyMDA2LTIwMDkgRXJpbiBDYXR0byBodHRwOi8vd3d3LmdwaHlzaWNzLmNvbSBcclxuKiBcclxuKiBUaGlzIHNvZnR3YXJlIGlzIHByb3ZpZGVkICdhcy1pcycsIHdpdGhvdXQgYW55IGV4cHJlc3Mgb3IgaW1wbGllZCBcclxuKiB3YXJyYW50eS4gIEluIG5vIGV2ZW50IHdpbGwgdGhlIGF1dGhvcnMgYmUgaGVsZCBsaWFibGUgZm9yIGFueSBkYW1hZ2VzIFxyXG4qIGFyaXNpbmcgZnJvbSB0aGUgdXNlIG9mIHRoaXMgc29mdHdhcmUuIFxyXG4qIFBlcm1pc3Npb24gaXMgZ3JhbnRlZCB0byBhbnlvbmUgdG8gdXNlIHRoaXMgc29mdHdhcmUgZm9yIGFueSBwdXJwb3NlLCBcclxuKiBpbmNsdWRpbmcgY29tbWVyY2lhbCBhcHBsaWNhdGlvbnMsIGFuZCB0byBhbHRlciBpdCBhbmQgcmVkaXN0cmlidXRlIGl0IFxyXG4qIGZyZWVseSwgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIHJlc3RyaWN0aW9uczogXHJcbiogMS4gVGhlIG9yaWdpbiBvZiB0aGlzIHNvZnR3YXJlIG11c3Qgbm90IGJlIG1pc3JlcHJlc2VudGVkOyB5b3UgbXVzdCBub3QgXHJcbiogY2xhaW0gdGhhdCB5b3Ugd3JvdGUgdGhlIG9yaWdpbmFsIHNvZnR3YXJlLiBJZiB5b3UgdXNlIHRoaXMgc29mdHdhcmUgXHJcbiogaW4gYSBwcm9kdWN0LCBhbiBhY2tub3dsZWRnbWVudCBpbiB0aGUgcHJvZHVjdCBkb2N1bWVudGF0aW9uIHdvdWxkIGJlIFxyXG4qIGFwcHJlY2lhdGVkIGJ1dCBpcyBub3QgcmVxdWlyZWQuIFxyXG4qIDIuIEFsdGVyZWQgc291cmNlIHZlcnNpb25zIG11c3QgYmUgcGxhaW5seSBtYXJrZWQgYXMgc3VjaCwgYW5kIG11c3Qgbm90IGJlIFxyXG4qIG1pc3JlcHJlc2VudGVkIGFzIGJlaW5nIHRoZSBvcmlnaW5hbCBzb2Z0d2FyZS4gXHJcbiogMy4gVGhpcyBub3RpY2UgbWF5IG5vdCBiZSByZW1vdmVkIG9yIGFsdGVyZWQgZnJvbSBhbnkgc291cmNlIGRpc3RyaWJ1dGlvbi4gXHJcbiovXHJcblxyXG51c2luZyBTeXN0ZW07XHJcbnVzaW5nIFN5c3RlbS5EaWFnbm9zdGljcztcclxudXNpbmcgRmFyc2VlclBoeXNpY3MuQ29tbW9uO1xyXG51c2luZyBNaWNyb3NvZnQuWG5hLkZyYW1ld29yaztcclxuXHJcbm5hbWVzcGFjZSBGYXJzZWVyUGh5c2ljcy5EeW5hbWljcy5Kb2ludHNcclxue1xyXG4gICAgLy8gUG9pbnQtdG8tcG9pbnQgY29uc3RyYWludFxyXG4gICAgLy8gQyA9IHAyIC0gcDFcclxuICAgIC8vIENkb3QgPSB2MiAtIHYxXHJcbiAgICAvLyAgICAgID0gdjIgKyBjcm9zcyh3MiwgcjIpIC0gdjEgLSBjcm9zcyh3MSwgcjEpXHJcbiAgICAvLyBKID0gWy1JIC1yMV9za2V3IEkgcjJfc2tldyBdXHJcbiAgICAvLyBJZGVudGl0eSB1c2VkOlxyXG4gICAgLy8gdyBrICUgKHJ4IGkgKyByeSBqKSA9IHcgKiAoLXJ5IGkgKyByeCBqKVxyXG5cclxuICAgIC8vIEFuZ2xlIGNvbnN0cmFpbnRcclxuICAgIC8vIEMgPSBhbmdsZTIgLSBhbmdsZTEgLSByZWZlcmVuY2VBbmdsZVxyXG4gICAgLy8gQ2RvdCA9IHcyIC0gdzFcclxuICAgIC8vIEogPSBbMCAwIC0xIDAgMCAxXVxyXG4gICAgLy8gSyA9IGludkkxICsgaW52STJcclxuXHJcbiAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAvLy8gQSB3ZWxkIGpvaW50IGVzc2VudGlhbGx5IGdsdWVzIHR3byBib2RpZXMgdG9nZXRoZXIuIEEgd2VsZCBqb2ludCBtYXlcclxuICAgIC8vLyBkaXN0b3J0IHNvbWV3aGF0IGJlY2F1c2UgdGhlIGlzbGFuZCBjb25zdHJhaW50IHNvbHZlciBpcyBhcHByb3hpbWF0ZS5cclxuICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICBwdWJsaWMgY2xhc3MgV2VsZEpvaW50IDogSm9pbnRcclxuICAgIHtcclxuICAgICAgICBwdWJsaWMgVmVjdG9yMiBMb2NhbEFuY2hvckE7XHJcbiAgICAgICAgcHVibGljIFZlY3RvcjIgTG9jYWxBbmNob3JCO1xyXG4gICAgICAgIHByaXZhdGUgVmVjdG9yMyBfaW1wdWxzZTtcclxuICAgICAgICBwcml2YXRlIE1hdDMzIF9tYXNzO1xyXG5cclxuICAgICAgICBpbnRlcm5hbCBXZWxkSm9pbnQoKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgSm9pbnRUeXBlID0gSm9pbnRUeXBlLldlbGQ7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIFlvdSBuZWVkIHRvIHNwZWNpZnkgYSBsb2NhbCBhbmNob3IgcG9pbnRcclxuICAgICAgICAvLy8gd2hlcmUgdGhleSBhcmUgYXR0YWNoZWQgYW5kIHRoZSByZWxhdGl2ZSBib2R5IGFuZ2xlLiBUaGUgcG9zaXRpb25cclxuICAgICAgICAvLy8gb2YgdGhlIGFuY2hvciBwb2ludCBpcyBpbXBvcnRhbnQgZm9yIGNvbXB1dGluZyB0aGUgcmVhY3Rpb24gdG9ycXVlLlxyXG4gICAgICAgIC8vLyBZb3UgY2FuIGNoYW5nZSB0aGUgYW5jaG9yIHBvaW50cyByZWxhdGl2ZSB0byBib2R5QSBvciBib2R5QiBieSBjaGFuZ2luZyBMb2NhbEFuY2hvckFcclxuICAgICAgICAvLy8gYW5kL29yIExvY2FsQW5jaG9yQi5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cImJvZHlBXCI+VGhlIGZpcnN0IGJvZHk8L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cImJvZHlCXCI+VGhlIHNlY29uZCBib2R5PC9wYXJhbT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJsb2NhbEFuY2hvckFcIj5UaGUgZmlyc3QgYm9keSBhbmNob3IuPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJsb2NhbEFuY2hvckJcIj5UaGUgc2Vjb25kIGJvZHkgYW5jaG9yLjwvcGFyYW0+XHJcbiAgICAgICAgcHVibGljIFdlbGRKb2ludChCb2R5IGJvZHlBLCBCb2R5IGJvZHlCLCBWZWN0b3IyIGxvY2FsQW5jaG9yQSwgVmVjdG9yMiBsb2NhbEFuY2hvckIpXHJcbiAgICAgICAgICAgIDogYmFzZShib2R5QSwgYm9keUIpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBKb2ludFR5cGUgPSBKb2ludFR5cGUuV2VsZDtcclxuXHJcbiAgICAgICAgICAgIExvY2FsQW5jaG9yQSA9IGxvY2FsQW5jaG9yQTtcclxuICAgICAgICAgICAgTG9jYWxBbmNob3JCID0gbG9jYWxBbmNob3JCO1xyXG4gICAgICAgICAgICBSZWZlcmVuY2VBbmdsZSA9IEJvZHlCLlJvdGF0aW9uIC0gQm9keUEuUm90YXRpb247XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwdWJsaWMgb3ZlcnJpZGUgVmVjdG9yMiBXb3JsZEFuY2hvckFcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGdldCB7IHJldHVybiBCb2R5QS5HZXRXb3JsZFBvaW50KExvY2FsQW5jaG9yQSk7IH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHB1YmxpYyBvdmVycmlkZSBWZWN0b3IyIFdvcmxkQW5jaG9yQlxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgZ2V0IHsgcmV0dXJuIEJvZHlCLkdldFdvcmxkUG9pbnQoTG9jYWxBbmNob3JCKTsgfVxyXG4gICAgICAgICAgICBzZXQgeyBEZWJ1Zy5Bc3NlcnQoZmFsc2UsIFwiWW91IGNhbid0IHNldCB0aGUgd29ybGQgYW5jaG9yIG9uIHRoaXMgam9pbnQgdHlwZS5cIik7IH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gVGhlIGJvZHkyIGFuZ2xlIG1pbnVzIGJvZHkxIGFuZ2xlIGluIHRoZSByZWZlcmVuY2Ugc3RhdGUgKHJhZGlhbnMpLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgcHVibGljIGZsb2F0IFJlZmVyZW5jZUFuZ2xlIHsgZ2V0OyBwcml2YXRlIHNldDsgfVxyXG5cclxuICAgICAgICBwdWJsaWMgb3ZlcnJpZGUgVmVjdG9yMiBHZXRSZWFjdGlvbkZvcmNlKGZsb2F0IGludl9kdClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiBpbnZfZHQgKiBuZXcgVmVjdG9yMihfaW1wdWxzZS5YLCBfaW1wdWxzZS5ZKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHB1YmxpYyBvdmVycmlkZSBmbG9hdCBHZXRSZWFjdGlvblRvcnF1ZShmbG9hdCBpbnZfZHQpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gaW52X2R0ICogX2ltcHVsc2UuWjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGludGVybmFsIG92ZXJyaWRlIHZvaWQgSW5pdFZlbG9jaXR5Q29uc3RyYWludHMocmVmIFRpbWVTdGVwIHN0ZXApXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBCb2R5IGJBID0gQm9keUE7XHJcbiAgICAgICAgICAgIEJvZHkgYkIgPSBCb2R5QjtcclxuXHJcbiAgICAgICAgICAgIFRyYW5zZm9ybSB4ZkEsIHhmQjtcclxuICAgICAgICAgICAgYkEuR2V0VHJhbnNmb3JtKG91dCB4ZkEpO1xyXG4gICAgICAgICAgICBiQi5HZXRUcmFuc2Zvcm0ob3V0IHhmQik7XHJcblxyXG4gICAgICAgICAgICAvLyBDb21wdXRlIHRoZSBlZmZlY3RpdmUgbWFzcyBtYXRyaXguXHJcbiAgICAgICAgICAgIFZlY3RvcjIgckEgPSBNYXRoVXRpbHMuTXVsdGlwbHkocmVmIHhmQS5SLCBMb2NhbEFuY2hvckEgLSBiQS5Mb2NhbENlbnRlcik7XHJcbiAgICAgICAgICAgIFZlY3RvcjIgckIgPSBNYXRoVXRpbHMuTXVsdGlwbHkocmVmIHhmQi5SLCBMb2NhbEFuY2hvckIgLSBiQi5Mb2NhbENlbnRlcik7XHJcblxyXG4gICAgICAgICAgICAvLyBKID0gWy1JIC1yMV9za2V3IEkgcjJfc2tld11cclxuICAgICAgICAgICAgLy8gICAgIFsgMCAgICAgICAtMSAwICAgICAgIDFdXHJcbiAgICAgICAgICAgIC8vIHJfc2tldyA9IFstcnk7IHJ4XVxyXG5cclxuICAgICAgICAgICAgLy8gTWF0bGFiXHJcbiAgICAgICAgICAgIC8vIEsgPSBbIG1BK3IxeV4yKmlBK21CK3IyeV4yKmlCLCAgLXIxeSppQSpyMXgtcjJ5KmlCKnIyeCwgICAgICAgICAgLXIxeSppQS1yMnkqaUJdXHJcbiAgICAgICAgICAgIC8vICAgICBbICAtcjF5KmlBKnIxeC1yMnkqaUIqcjJ4LCBtQStyMXheMippQSttQityMnheMippQiwgICAgICAgICAgIHIxeCppQStyMngqaUJdXHJcbiAgICAgICAgICAgIC8vICAgICBbICAgICAgICAgIC1yMXkqaUEtcjJ5KmlCLCAgICAgICAgICAgcjF4KmlBK3IyeCppQiwgICAgICAgICAgICAgICAgICAgaUEraUJdXHJcblxyXG4gICAgICAgICAgICBmbG9hdCBtQSA9IGJBLkludk1hc3MsIG1CID0gYkIuSW52TWFzcztcclxuICAgICAgICAgICAgZmxvYXQgaUEgPSBiQS5JbnZJLCBpQiA9IGJCLkludkk7XHJcblxyXG4gICAgICAgICAgICBfbWFzcy5Db2wxLlggPSBtQSArIG1CICsgckEuWSAqIHJBLlkgKiBpQSArIHJCLlkgKiByQi5ZICogaUI7XHJcbiAgICAgICAgICAgIF9tYXNzLkNvbDIuWCA9IC1yQS5ZICogckEuWCAqIGlBIC0gckIuWSAqIHJCLlggKiBpQjtcclxuICAgICAgICAgICAgX21hc3MuQ29sMy5YID0gLXJBLlkgKiBpQSAtIHJCLlkgKiBpQjtcclxuICAgICAgICAgICAgX21hc3MuQ29sMS5ZID0gX21hc3MuQ29sMi5YO1xyXG4gICAgICAgICAgICBfbWFzcy5Db2wyLlkgPSBtQSArIG1CICsgckEuWCAqIHJBLlggKiBpQSArIHJCLlggKiByQi5YICogaUI7XHJcbiAgICAgICAgICAgIF9tYXNzLkNvbDMuWSA9IHJBLlggKiBpQSArIHJCLlggKiBpQjtcclxuICAgICAgICAgICAgX21hc3MuQ29sMS5aID0gX21hc3MuQ29sMy5YO1xyXG4gICAgICAgICAgICBfbWFzcy5Db2wyLlogPSBfbWFzcy5Db2wzLlk7XHJcbiAgICAgICAgICAgIF9tYXNzLkNvbDMuWiA9IGlBICsgaUI7XHJcblxyXG4gICAgICAgICAgICBpZiAoU2V0dGluZ3MuRW5hYmxlV2FybXN0YXJ0aW5nKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAvLyBTY2FsZSBpbXB1bHNlcyB0byBzdXBwb3J0IGEgdmFyaWFibGUgdGltZSBzdGVwLlxyXG4gICAgICAgICAgICAgICAgX2ltcHVsc2UgKj0gc3RlcC5kdFJhdGlvO1xyXG5cclxuICAgICAgICAgICAgICAgIFZlY3RvcjIgUCA9IG5ldyBWZWN0b3IyKF9pbXB1bHNlLlgsIF9pbXB1bHNlLlkpO1xyXG5cclxuICAgICAgICAgICAgICAgIGJBLkxpbmVhclZlbG9jaXR5SW50ZXJuYWwgLT0gbUEgKiBQO1xyXG4gICAgICAgICAgICAgICAgYkEuQW5ndWxhclZlbG9jaXR5SW50ZXJuYWwgLT0gaUEgKiAoTWF0aFV0aWxzLkNyb3NzKHJBLCBQKSArIF9pbXB1bHNlLlopO1xyXG5cclxuICAgICAgICAgICAgICAgIGJCLkxpbmVhclZlbG9jaXR5SW50ZXJuYWwgKz0gbUIgKiBQO1xyXG4gICAgICAgICAgICAgICAgYkIuQW5ndWxhclZlbG9jaXR5SW50ZXJuYWwgKz0gaUIgKiAoTWF0aFV0aWxzLkNyb3NzKHJCLCBQKSArIF9pbXB1bHNlLlopO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgX2ltcHVsc2UgPSBWZWN0b3IzLlplcm87XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGludGVybmFsIG92ZXJyaWRlIHZvaWQgU29sdmVWZWxvY2l0eUNvbnN0cmFpbnRzKHJlZiBUaW1lU3RlcCBzdGVwKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgQm9keSBiQSA9IEJvZHlBO1xyXG4gICAgICAgICAgICBCb2R5IGJCID0gQm9keUI7XHJcblxyXG4gICAgICAgICAgICBWZWN0b3IyIHZBID0gYkEuTGluZWFyVmVsb2NpdHlJbnRlcm5hbDtcclxuICAgICAgICAgICAgZmxvYXQgd0EgPSBiQS5Bbmd1bGFyVmVsb2NpdHlJbnRlcm5hbDtcclxuICAgICAgICAgICAgVmVjdG9yMiB2QiA9IGJCLkxpbmVhclZlbG9jaXR5SW50ZXJuYWw7XHJcbiAgICAgICAgICAgIGZsb2F0IHdCID0gYkIuQW5ndWxhclZlbG9jaXR5SW50ZXJuYWw7XHJcblxyXG4gICAgICAgICAgICBmbG9hdCBtQSA9IGJBLkludk1hc3MsIG1CID0gYkIuSW52TWFzcztcclxuICAgICAgICAgICAgZmxvYXQgaUEgPSBiQS5JbnZJLCBpQiA9IGJCLkludkk7XHJcblxyXG4gICAgICAgICAgICBUcmFuc2Zvcm0geGZBLCB4ZkI7XHJcbiAgICAgICAgICAgIGJBLkdldFRyYW5zZm9ybShvdXQgeGZBKTtcclxuICAgICAgICAgICAgYkIuR2V0VHJhbnNmb3JtKG91dCB4ZkIpO1xyXG5cclxuICAgICAgICAgICAgVmVjdG9yMiByQSA9IE1hdGhVdGlscy5NdWx0aXBseShyZWYgeGZBLlIsIExvY2FsQW5jaG9yQSAtIGJBLkxvY2FsQ2VudGVyKTtcclxuICAgICAgICAgICAgVmVjdG9yMiByQiA9IE1hdGhVdGlscy5NdWx0aXBseShyZWYgeGZCLlIsIExvY2FsQW5jaG9yQiAtIGJCLkxvY2FsQ2VudGVyKTtcclxuXHJcbiAgICAgICAgICAgIC8vICBTb2x2ZSBwb2ludC10by1wb2ludCBjb25zdHJhaW50XHJcbiAgICAgICAgICAgIFZlY3RvcjIgQ2RvdDEgPSB2QiArIE1hdGhVdGlscy5Dcm9zcyh3QiwgckIpIC0gdkEgLSBNYXRoVXRpbHMuQ3Jvc3Mod0EsIHJBKTtcclxuICAgICAgICAgICAgZmxvYXQgQ2RvdDIgPSB3QiAtIHdBO1xyXG4gICAgICAgICAgICBWZWN0b3IzIENkb3QgPSBuZXcgVmVjdG9yMyhDZG90MS5YLCBDZG90MS5ZLCBDZG90Mik7XHJcblxyXG4gICAgICAgICAgICBWZWN0b3IzIGltcHVsc2UgPSBfbWFzcy5Tb2x2ZTMzKC1DZG90KTtcclxuICAgICAgICAgICAgX2ltcHVsc2UgKz0gaW1wdWxzZTtcclxuXHJcbiAgICAgICAgICAgIFZlY3RvcjIgUCA9IG5ldyBWZWN0b3IyKGltcHVsc2UuWCwgaW1wdWxzZS5ZKTtcclxuXHJcbiAgICAgICAgICAgIHZBIC09IG1BICogUDtcclxuICAgICAgICAgICAgd0EgLT0gaUEgKiAoTWF0aFV0aWxzLkNyb3NzKHJBLCBQKSArIGltcHVsc2UuWik7XHJcblxyXG4gICAgICAgICAgICB2QiArPSBtQiAqIFA7XHJcbiAgICAgICAgICAgIHdCICs9IGlCICogKE1hdGhVdGlscy5Dcm9zcyhyQiwgUCkgKyBpbXB1bHNlLlopO1xyXG5cclxuICAgICAgICAgICAgYkEuTGluZWFyVmVsb2NpdHlJbnRlcm5hbCA9IHZBO1xyXG4gICAgICAgICAgICBiQS5Bbmd1bGFyVmVsb2NpdHlJbnRlcm5hbCA9IHdBO1xyXG4gICAgICAgICAgICBiQi5MaW5lYXJWZWxvY2l0eUludGVybmFsID0gdkI7XHJcbiAgICAgICAgICAgIGJCLkFuZ3VsYXJWZWxvY2l0eUludGVybmFsID0gd0I7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpbnRlcm5hbCBvdmVycmlkZSBib29sIFNvbHZlUG9zaXRpb25Db25zdHJhaW50cygpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBCb2R5IGJBID0gQm9keUE7XHJcbiAgICAgICAgICAgIEJvZHkgYkIgPSBCb2R5QjtcclxuXHJcbiAgICAgICAgICAgIGZsb2F0IG1BID0gYkEuSW52TWFzcywgbUIgPSBiQi5JbnZNYXNzO1xyXG4gICAgICAgICAgICBmbG9hdCBpQSA9IGJBLkludkksIGlCID0gYkIuSW52STtcclxuXHJcbiAgICAgICAgICAgIFRyYW5zZm9ybSB4ZkE7XHJcbiAgICAgICAgICAgIFRyYW5zZm9ybSB4ZkI7XHJcbiAgICAgICAgICAgIGJBLkdldFRyYW5zZm9ybShvdXQgeGZBKTtcclxuICAgICAgICAgICAgYkIuR2V0VHJhbnNmb3JtKG91dCB4ZkIpO1xyXG5cclxuICAgICAgICAgICAgVmVjdG9yMiByQSA9IE1hdGhVdGlscy5NdWx0aXBseShyZWYgeGZBLlIsIExvY2FsQW5jaG9yQSAtIGJBLkxvY2FsQ2VudGVyKTtcclxuICAgICAgICAgICAgVmVjdG9yMiByQiA9IE1hdGhVdGlscy5NdWx0aXBseShyZWYgeGZCLlIsIExvY2FsQW5jaG9yQiAtIGJCLkxvY2FsQ2VudGVyKTtcclxuXHJcbiAgICAgICAgICAgIFZlY3RvcjIgQzEgPSBiQi5Td2VlcC5DICsgckIgLSBiQS5Td2VlcC5DIC0gckE7XHJcbiAgICAgICAgICAgIGZsb2F0IEMyID0gYkIuU3dlZXAuQSAtIGJBLlN3ZWVwLkEgLSBSZWZlcmVuY2VBbmdsZTtcclxuXHJcbiAgICAgICAgICAgIC8vIEhhbmRsZSBsYXJnZSBkZXRhY2htZW50LlxyXG4gICAgICAgICAgICBjb25zdCBmbG9hdCBrX2FsbG93ZWRTdHJldGNoID0gMTAuMGYgKiBTZXR0aW5ncy5MaW5lYXJTbG9wO1xyXG4gICAgICAgICAgICBmbG9hdCBwb3NpdGlvbkVycm9yID0gQzEuTGVuZ3RoKCk7XHJcbiAgICAgICAgICAgIGZsb2F0IGFuZ3VsYXJFcnJvciA9IChmbG9hdClNYXRoLkFicyhDMik7XHJcbiAgICAgICAgICAgIGlmIChwb3NpdGlvbkVycm9yID4ga19hbGxvd2VkU3RyZXRjaClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgaUEgKj0gMS4wZjtcclxuICAgICAgICAgICAgICAgIGlCICo9IDEuMGY7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIF9tYXNzLkNvbDEuWCA9IG1BICsgbUIgKyByQS5ZICogckEuWSAqIGlBICsgckIuWSAqIHJCLlkgKiBpQjtcclxuICAgICAgICAgICAgX21hc3MuQ29sMi5YID0gLXJBLlkgKiByQS5YICogaUEgLSByQi5ZICogckIuWCAqIGlCO1xyXG4gICAgICAgICAgICBfbWFzcy5Db2wzLlggPSAtckEuWSAqIGlBIC0gckIuWSAqIGlCO1xyXG4gICAgICAgICAgICBfbWFzcy5Db2wxLlkgPSBfbWFzcy5Db2wyLlg7XHJcbiAgICAgICAgICAgIF9tYXNzLkNvbDIuWSA9IG1BICsgbUIgKyByQS5YICogckEuWCAqIGlBICsgckIuWCAqIHJCLlggKiBpQjtcclxuICAgICAgICAgICAgX21hc3MuQ29sMy5ZID0gckEuWCAqIGlBICsgckIuWCAqIGlCO1xyXG4gICAgICAgICAgICBfbWFzcy5Db2wxLlogPSBfbWFzcy5Db2wzLlg7XHJcbiAgICAgICAgICAgIF9tYXNzLkNvbDIuWiA9IF9tYXNzLkNvbDMuWTtcclxuICAgICAgICAgICAgX21hc3MuQ29sMy5aID0gaUEgKyBpQjtcclxuXHJcbiAgICAgICAgICAgIFZlY3RvcjMgQyA9IG5ldyBWZWN0b3IzKEMxLlgsIEMxLlksIEMyKTtcclxuXHJcbiAgICAgICAgICAgIFZlY3RvcjMgaW1wdWxzZSA9IF9tYXNzLlNvbHZlMzMoLUMpO1xyXG5cclxuICAgICAgICAgICAgVmVjdG9yMiBQID0gbmV3IFZlY3RvcjIoaW1wdWxzZS5YLCBpbXB1bHNlLlkpO1xyXG5cclxuICAgICAgICAgICAgYkEuU3dlZXAuQyAtPSBtQSAqIFA7XHJcbiAgICAgICAgICAgIGJBLlN3ZWVwLkEgLT0gaUEgKiAoTWF0aFV0aWxzLkNyb3NzKHJBLCBQKSArIGltcHVsc2UuWik7XHJcblxyXG4gICAgICAgICAgICBiQi5Td2VlcC5DICs9IG1CICogUDtcclxuICAgICAgICAgICAgYkIuU3dlZXAuQSArPSBpQiAqIChNYXRoVXRpbHMuQ3Jvc3MockIsIFApICsgaW1wdWxzZS5aKTtcclxuXHJcbiAgICAgICAgICAgIGJBLlN5bmNocm9uaXplVHJhbnNmb3JtKCk7XHJcbiAgICAgICAgICAgIGJCLlN5bmNocm9uaXplVHJhbnNmb3JtKCk7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gcG9zaXRpb25FcnJvciA8PSBTZXR0aW5ncy5MaW5lYXJTbG9wICYmIGFuZ3VsYXJFcnJvciA8PSBTZXR0aW5ncy5Bbmd1bGFyU2xvcDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn0iLCJ1c2luZyBTeXN0ZW07XHJcbnVzaW5nIEZhcnNlZXJQaHlzaWNzLkR5bmFtaWNzO1xyXG51c2luZyBGYXJzZWVyUGh5c2ljcy5EeW5hbWljcy5Kb2ludHM7XHJcbnVzaW5nIE1pY3Jvc29mdC5YbmEuRnJhbWV3b3JrO1xyXG51c2luZyBNaWNyb3NvZnQuWG5hLkZyYW1ld29yay5JbnB1dDtcclxuXHJcbm5hbWVzcGFjZSBGYXJzZWVyUGh5c2ljcy5VdGlsaXR5XHJcbntcclxuICAgIHB1YmxpYyBjbGFzcyBQaHlzaWNzR2FtZVNjcmVlbiA6IEdhbWVTY3JlZW5cclxuICAgIHtcclxuICAgICAgICBwdWJsaWMgQ2FtZXJhMkQgQ2FtZXJhO1xyXG4gICAgICAgIHByb3RlY3RlZCBXb3JsZCBXb3JsZDtcclxuXHJcbiAgICAgICAgcHJpdmF0ZSBmbG9hdCBfYWdlbnRGb3JjZTtcclxuICAgICAgICBwcml2YXRlIGZsb2F0IF9hZ2VudFRvcnF1ZTtcclxuICAgICAgICBwcml2YXRlIEZpeGVkTW91c2VKb2ludCBfZml4ZWRNb3VzZUpvaW50O1xyXG4gICAgICAgIHByaXZhdGUgQm9keSBfdXNlckFnZW50O1xyXG5cclxuICAgICAgICBwcm90ZWN0ZWQgUGh5c2ljc0dhbWVTY3JlZW4oU2NyZWVuTWFuYWdlciBzY3JlZW5NYW5hZ2VyKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgSGFzQ3Vyc29yID0gdHJ1ZTtcclxuICAgICAgICAgICAgRW5hYmxlQ2FtZXJhQ29udHJvbCA9IHRydWU7XHJcbiAgICAgICAgICAgIF91c2VyQWdlbnQgPSBudWxsO1xyXG4gICAgICAgICAgICBXb3JsZCA9IG51bGw7XHJcbiAgICAgICAgICAgIENhbWVyYSA9IG51bGw7XHJcblxyXG4gICAgICAgICAgICBTY3JlZW5NYW5hZ2VyID0gc2NyZWVuTWFuYWdlcjtcclxuICAgICAgICAgICAgLy9XZSBlbmFibGUgZGlhZ25vc3RpY3MgdG8gc2hvdyBnZXQgdmFsdWVzIGZvciBvdXIgcGVyZm9ybWFuY2UgY291bnRlcnMuXHJcbiAgICAgICAgICAgIFNldHRpbmdzLkVuYWJsZURpYWdub3N0aWNzID0gdHJ1ZTtcclxuXHJcbiAgICAgICAgICAgIGlmIChXb3JsZCA9PSBudWxsKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBXb3JsZCA9IG5ldyBXb3JsZChWZWN0b3IyLlplcm8pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgV29ybGQuQ2xlYXIoKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKENhbWVyYSA9PSBudWxsKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBDYW1lcmEgPSBuZXcgQ2FtZXJhMkQoc2NyZWVuTWFuYWdlci5HcmFwaGljc0RldmljZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBDYW1lcmEuUmVzZXRDYW1lcmEoKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gTG9hZGluZyBtYXkgdGFrZSBhIHdoaWxlLi4uIHNvIHByZXZlbnQgdGhlIGdhbWUgZnJvbSBcImNhdGNoaW5nIHVwXCIgb25jZSB3ZSBmaW5pc2hlZCBsb2FkaW5nXHJcblx0XHRcdC8vbmV3IE1vbm9HYW1lLmlPUyBkb2Vzbid0IHNlZW0gdG8gbGlrZSB0aGlzLCBuZWVkIHRvIHJldGVzdCBvbiBvdGhlciBwbGF0Zm9ybXNcclxuICAgICAgICAgICAgLy9zY3JlZW5NYW5hZ2VyLkdhbWUuUmVzZXRFbGFwc2VkVGltZSgpO1xyXG5cdFx0XHQvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHVibGljIGJvb2wgRW5hYmxlQ2FtZXJhQ29udHJvbCB7IGdldDsgc2V0OyB9XHJcblxyXG4gICAgICAgIHByb3RlY3RlZCB2b2lkIFNldFVzZXJBZ2VudChCb2R5IGFnZW50LCBmbG9hdCBmb3JjZSwgZmxvYXQgdG9ycXVlKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgX3VzZXJBZ2VudCA9IGFnZW50O1xyXG4gICAgICAgICAgICBfYWdlbnRGb3JjZSA9IGZvcmNlO1xyXG4gICAgICAgICAgICBfYWdlbnRUb3JxdWUgPSB0b3JxdWU7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwdWJsaWMgb3ZlcnJpZGUgdm9pZCBMb2FkQ29udGVudCgpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBiYXNlLkxvYWRDb250ZW50KCk7ICAgIFxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHVibGljIG92ZXJyaWRlIHZvaWQgVXBkYXRlKEdhbWVUaW1lIGdhbWVUaW1lLCBib29sIG90aGVyU2NyZWVuSGFzRm9jdXMsIGJvb2wgY292ZXJlZEJ5T3RoZXJTY3JlZW4pXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBpZiAoIWNvdmVyZWRCeU90aGVyU2NyZWVuICYmICFvdGhlclNjcmVlbkhhc0ZvY3VzKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAvLyB2YXJpYWJsZSB0aW1lIHN0ZXAgYnV0IG5ldmVyIGxlc3MgdGhlbiAzMCBIelxyXG4gICAgICAgICAgICAgICAgV29ybGQuU3RlcChNYXRoLk1pbigoZmxvYXQpZ2FtZVRpbWUuRWxhcHNlZEdhbWVUaW1lLlRvdGFsU2Vjb25kcywgKDFmIC8gNTBmKSkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgV29ybGQuU3RlcCgwZik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgQ2FtZXJhLlVwZGF0ZShnYW1lVGltZSk7XHJcbiAgICAgICAgICAgIGJhc2UuVXBkYXRlKGdhbWVUaW1lLCBvdGhlclNjcmVlbkhhc0ZvY3VzLCBjb3ZlcmVkQnlPdGhlclNjcmVlbik7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwdWJsaWMgb3ZlcnJpZGUgdm9pZCBEcmF3KEdhbWVUaW1lIGdhbWVUaW1lKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgTWF0cml4IHByb2plY3Rpb24gPSBDYW1lcmEuU2ltUHJvamVjdGlvbjtcclxuICAgICAgICAgICAgTWF0cml4IHZpZXcgPSBDYW1lcmEuU2ltVmlldztcclxuXHJcbiAgICAgICAgICAgIGJhc2UuRHJhdyhnYW1lVGltZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59IiwiLyogUG9seTJUcmlcclxuICogQ29weXJpZ2h0IChjKSAyMDA5LTIwMTAsIFBvbHkyVHJpIENvbnRyaWJ1dG9yc1xyXG4gKiBodHRwOi8vY29kZS5nb29nbGUuY29tL3AvcG9seTJ0cmkvXHJcbiAqXHJcbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqXHJcbiAqIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGggb3Igd2l0aG91dCBtb2RpZmljYXRpb24sXHJcbiAqIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnMgYXJlIG1ldDpcclxuICpcclxuICogKiBSZWRpc3RyaWJ1dGlvbnMgb2Ygc291cmNlIGNvZGUgbXVzdCByZXRhaW4gdGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UsXHJcbiAqICAgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lci5cclxuICogKiBSZWRpc3RyaWJ1dGlvbnMgaW4gYmluYXJ5IGZvcm0gbXVzdCByZXByb2R1Y2UgdGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UsXHJcbiAqICAgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lciBpbiB0aGUgZG9jdW1lbnRhdGlvblxyXG4gKiAgIGFuZC9vciBvdGhlciBtYXRlcmlhbHMgcHJvdmlkZWQgd2l0aCB0aGUgZGlzdHJpYnV0aW9uLlxyXG4gKiAqIE5laXRoZXIgdGhlIG5hbWUgb2YgUG9seTJUcmkgbm9yIHRoZSBuYW1lcyBvZiBpdHMgY29udHJpYnV0b3JzIG1heSBiZVxyXG4gKiAgIHVzZWQgdG8gZW5kb3JzZSBvciBwcm9tb3RlIHByb2R1Y3RzIGRlcml2ZWQgZnJvbSB0aGlzIHNvZnR3YXJlIHdpdGhvdXQgc3BlY2lmaWNcclxuICogICBwcmlvciB3cml0dGVuIHBlcm1pc3Npb24uXHJcbiAqXHJcbiAqIFRISVMgU09GVFdBUkUgSVMgUFJPVklERUQgQlkgVEhFIENPUFlSSUdIVCBIT0xERVJTIEFORCBDT05UUklCVVRPUlNcclxuICogXCJBUyBJU1wiIEFORCBBTlkgRVhQUkVTUyBPUiBJTVBMSUVEIFdBUlJBTlRJRVMsIElOQ0xVRElORywgQlVUIE5PVFxyXG4gKiBMSU1JVEVEIFRPLCBUSEUgSU1QTElFRCBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSBBTkQgRklUTkVTUyBGT1JcclxuICogQSBQQVJUSUNVTEFSIFBVUlBPU0UgQVJFIERJU0NMQUlNRUQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBDT1BZUklHSFQgT1dORVIgT1JcclxuICogQ09OVFJJQlVUT1JTIEJFIExJQUJMRSBGT1IgQU5ZIERJUkVDVCwgSU5ESVJFQ1QsIElOQ0lERU5UQUwsIFNQRUNJQUwsXHJcbiAqIEVYRU1QTEFSWSwgT1IgQ09OU0VRVUVOVElBTCBEQU1BR0VTIChJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRCBUTyxcclxuICogUFJPQ1VSRU1FTlQgT0YgU1VCU1RJVFVURSBHT09EUyBPUiBTRVJWSUNFUzsgTE9TUyBPRiBVU0UsIERBVEEsIE9SXHJcbiAqIFBST0ZJVFM7IE9SIEJVU0lORVNTIElOVEVSUlVQVElPTikgSE9XRVZFUiBDQVVTRUQgQU5EIE9OIEFOWSBUSEVPUlkgT0ZcclxuICogTElBQklMSVRZLCBXSEVUSEVSIElOIENPTlRSQUNULCBTVFJJQ1QgTElBQklMSVRZLCBPUiBUT1JUIChJTkNMVURJTkdcclxuICogTkVHTElHRU5DRSBPUiBPVEhFUldJU0UpIEFSSVNJTkcgSU4gQU5ZIFdBWSBPVVQgT0YgVEhFIFVTRSBPRiBUSElTXHJcbiAqIFNPRlRXQVJFLCBFVkVOIElGIEFEVklTRUQgT0YgVEhFIFBPU1NJQklMSVRZIE9GIFNVQ0ggREFNQUdFLlxyXG4gKi9cclxuXHJcbm5hbWVzcGFjZSBQb2x5MlRyaS5Ucmlhbmd1bGF0aW9uLkRlbGF1bmF5LlN3ZWVwXHJcbntcclxuICAgIHB1YmxpYyBjbGFzcyBEVFN3ZWVwQ29uc3RyYWludCA6IFRyaWFuZ3VsYXRpb25Db25zdHJhaW50XHJcbiAgICB7XHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBHaXZlIHR3byBwb2ludHMgaW4gYW55IG9yZGVyLiBXaWxsIGFsd2F5cyBiZSBvcmRlcmVkIHNvXHJcbiAgICAgICAgLy8vIHRoYXQgcS55ID4gcC55IGFuZCBxLnggPiBwLnggaWYgc2FtZSB5IHZhbHVlIFxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgcHVibGljIERUU3dlZXBDb25zdHJhaW50KFRyaWFuZ3VsYXRpb25Qb2ludCBwMSwgVHJpYW5ndWxhdGlvblBvaW50IHAyKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgUCA9IHAxO1xyXG4gICAgICAgICAgICBRID0gcDI7XHJcbiAgICAgICAgICAgIGlmIChwMS5ZID4gcDIuWSlcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgUSA9IHAxO1xyXG4gICAgICAgICAgICAgICAgUCA9IHAyO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKHAxLlkgPT0gcDIuWSlcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgaWYgKHAxLlggPiBwMi5YKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIFEgPSBwMTtcclxuICAgICAgICAgICAgICAgICAgICBQID0gcDI7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChwMS5YID09IHAyLlgpXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gICAgICAgICAgICAgICAgbG9nZ2VyLmluZm8oIFwiRmFpbGVkIHRvIGNyZWF0ZSBjb25zdHJhaW50IHt9PXt9XCIsIHAxLCBwMiApO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vICAgICAgICAgICAgICAgIHRocm93IG5ldyBEdXBsaWNhdGVQb2ludEV4Y2VwdGlvbiggcDEgKyBcIj1cIiArIHAyICk7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIFEuQWRkRWRnZSh0aGlzKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn0iLCIvKiBQb2x5MlRyaVxyXG4gKiBDb3B5cmlnaHQgKGMpIDIwMDktMjAxMCwgUG9seTJUcmkgQ29udHJpYnV0b3JzXHJcbiAqIGh0dHA6Ly9jb2RlLmdvb2dsZS5jb20vcC9wb2x5MnRyaS9cclxuICpcclxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICpcclxuICogUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aCBvciB3aXRob3V0IG1vZGlmaWNhdGlvbixcclxuICogYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgY29uZGl0aW9ucyBhcmUgbWV0OlxyXG4gKlxyXG4gKiAqIFJlZGlzdHJpYnV0aW9ucyBvZiBzb3VyY2UgY29kZSBtdXN0IHJldGFpbiB0aGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSxcclxuICogICB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyLlxyXG4gKiAqIFJlZGlzdHJpYnV0aW9ucyBpbiBiaW5hcnkgZm9ybSBtdXN0IHJlcHJvZHVjZSB0aGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSxcclxuICogICB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyIGluIHRoZSBkb2N1bWVudGF0aW9uXHJcbiAqICAgYW5kL29yIG90aGVyIG1hdGVyaWFscyBwcm92aWRlZCB3aXRoIHRoZSBkaXN0cmlidXRpb24uXHJcbiAqICogTmVpdGhlciB0aGUgbmFtZSBvZiBQb2x5MlRyaSBub3IgdGhlIG5hbWVzIG9mIGl0cyBjb250cmlidXRvcnMgbWF5IGJlXHJcbiAqICAgdXNlZCB0byBlbmRvcnNlIG9yIHByb21vdGUgcHJvZHVjdHMgZGVyaXZlZCBmcm9tIHRoaXMgc29mdHdhcmUgd2l0aG91dCBzcGVjaWZpY1xyXG4gKiAgIHByaW9yIHdyaXR0ZW4gcGVybWlzc2lvbi5cclxuICpcclxuICogVEhJUyBTT0ZUV0FSRSBJUyBQUk9WSURFRCBCWSBUSEUgQ09QWVJJR0hUIEhPTERFUlMgQU5EIENPTlRSSUJVVE9SU1xyXG4gKiBcIkFTIElTXCIgQU5EIEFOWSBFWFBSRVNTIE9SIElNUExJRUQgV0FSUkFOVElFUywgSU5DTFVESU5HLCBCVVQgTk9UXHJcbiAqIExJTUlURUQgVE8sIFRIRSBJTVBMSUVEIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZIEFORCBGSVRORVNTIEZPUlxyXG4gKiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBUkUgRElTQ0xBSU1FRC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIENPUFlSSUdIVCBPV05FUiBPUlxyXG4gKiBDT05UUklCVVRPUlMgQkUgTElBQkxFIEZPUiBBTlkgRElSRUNULCBJTkRJUkVDVCwgSU5DSURFTlRBTCwgU1BFQ0lBTCxcclxuICogRVhFTVBMQVJZLCBPUiBDT05TRVFVRU5USUFMIERBTUFHRVMgKElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLFxyXG4gKiBQUk9DVVJFTUVOVCBPRiBTVUJTVElUVVRFIEdPT0RTIE9SIFNFUlZJQ0VTOyBMT1NTIE9GIFVTRSwgREFUQSwgT1JcclxuICogUFJPRklUUzsgT1IgQlVTSU5FU1MgSU5URVJSVVBUSU9OKSBIT1dFVkVSIENBVVNFRCBBTkQgT04gQU5ZIFRIRU9SWSBPRlxyXG4gKiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQ09OVFJBQ1QsIFNUUklDVCBMSUFCSUxJVFksIE9SIFRPUlQgKElOQ0xVRElOR1xyXG4gKiBORUdMSUdFTkNFIE9SIE9USEVSV0lTRSkgQVJJU0lORyBJTiBBTlkgV0FZIE9VVCBPRiBUSEUgVVNFIE9GIFRISVNcclxuICogU09GVFdBUkUsIEVWRU4gSUYgQURWSVNFRCBPRiBUSEUgUE9TU0lCSUxJVFkgT0YgU1VDSCBEQU1BR0UuXHJcbiAqL1xyXG5cclxubmFtZXNwYWNlIFBvbHkyVHJpLlRyaWFuZ3VsYXRpb24uRGVsYXVuYXkuU3dlZXBcclxue1xyXG4gICAgLyoqXHJcbiAgICAgKiBcclxuICAgICAqIEBhdXRob3IgVGhvbWFzIMOFaGzDqW4sIHRoYWhsZW5AZ21haWwuY29tXHJcbiAgICAgKlxyXG4gICAgICovXHJcblxyXG4gICAgcHVibGljIGNsYXNzIERUU3dlZXBDb250ZXh0IDogVHJpYW5ndWxhdGlvbkNvbnRleHRcclxuICAgIHtcclxuICAgICAgICAvLyBJbml0YWwgdHJpYW5nbGUgZmFjdG9yLCBzZWVkIHRyaWFuZ2xlIHdpbGwgZXh0ZW5kIDMwJSBvZiBcclxuICAgICAgICAvLyBQb2ludFNldCB3aWR0aCB0byBib3RoIGxlZnQgYW5kIHJpZ2h0LlxyXG4gICAgICAgIHByaXZhdGUgY29uc3QgZmxvYXQgQUxQSEEgPSAwLjNmO1xyXG5cclxuICAgICAgICBwdWJsaWMgRFRTd2VlcEJhc2luIEJhc2luID0gbmV3IERUU3dlZXBCYXNpbigpO1xyXG4gICAgICAgIHB1YmxpYyBEVFN3ZWVwRWRnZUV2ZW50IEVkZ2VFdmVudCA9IG5ldyBEVFN3ZWVwRWRnZUV2ZW50KCk7XHJcblxyXG4gICAgICAgIHByaXZhdGUgRFRTd2VlcFBvaW50Q29tcGFyYXRvciBfY29tcGFyYXRvciA9IG5ldyBEVFN3ZWVwUG9pbnRDb21wYXJhdG9yKCk7XHJcbiAgICAgICAgcHVibGljIEFkdmFuY2luZ0Zyb250IGFGcm9udDtcclxuXHJcbiAgICAgICAgcHVibGljIERUU3dlZXBDb250ZXh0KClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIENsZWFyKCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwdWJsaWMgVHJpYW5ndWxhdGlvblBvaW50IEhlYWQgeyBnZXQ7IHNldDsgfVxyXG4gICAgICAgIHB1YmxpYyBUcmlhbmd1bGF0aW9uUG9pbnQgVGFpbCB7IGdldDsgc2V0OyB9XHJcblxyXG4gICAgICAgIHB1YmxpYyB2b2lkIFJlbW92ZUZyb21MaXN0KERlbGF1bmF5VHJpYW5nbGUgdHJpYW5nbGUpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBUcmlhbmdsZXMuUmVtb3ZlKHRyaWFuZ2xlKTtcclxuICAgICAgICAgICAgLy8gVE9ETzogcmVtb3ZlIGFsbCBuZWlnaGJvciBwb2ludGVycyB0byB0aGlzIHRyaWFuZ2xlXHJcbiAgICAgICAgICAgIC8vICAgICAgICBmb3IoIGludCBpPTA7IGk8MzsgaSsrIClcclxuICAgICAgICAgICAgLy8gICAgICAgIHtcclxuICAgICAgICAgICAgLy8gICAgICAgICAgICBpZiggdHJpYW5nbGUubmVpZ2hib3JzW2ldICE9IG51bGwgKVxyXG4gICAgICAgICAgICAvLyAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgLy8gICAgICAgICAgICAgICAgdHJpYW5nbGUubmVpZ2hib3JzW2ldLmNsZWFyTmVpZ2hib3IoIHRyaWFuZ2xlICk7XHJcbiAgICAgICAgICAgIC8vICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyAgICAgICAgdHJpYW5nbGUuY2xlYXJOZWlnaGJvcnMoKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHB1YmxpYyB2b2lkIE1lc2hDbGVhbihEZWxhdW5heVRyaWFuZ2xlIHRyaWFuZ2xlKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgTWVzaENsZWFuUmVxKHRyaWFuZ2xlKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHByaXZhdGUgdm9pZCBNZXNoQ2xlYW5SZXEoRGVsYXVuYXlUcmlhbmdsZSB0cmlhbmdsZSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGlmICh0cmlhbmdsZSAhPSBudWxsICYmICF0cmlhbmdsZS5Jc0ludGVyaW9yKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB0cmlhbmdsZS5Jc0ludGVyaW9yID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIFRyaWFuZ3VsYXRhYmxlLkFkZFRyaWFuZ2xlKHRyaWFuZ2xlKTtcclxuICAgICAgICAgICAgICAgIGZvciAoaW50IGkgPSAwOyBpIDwgMzsgaSsrKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICghdHJpYW5nbGUuRWRnZUlzQ29uc3RyYWluZWRbaV0pXHJcbiAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBNZXNoQ2xlYW5SZXEodHJpYW5nbGUuTmVpZ2hib3JzW2ldKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHB1YmxpYyBvdmVycmlkZSB2b2lkIENsZWFyKClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGJhc2UuQ2xlYXIoKTtcclxuICAgICAgICAgICAgVHJpYW5nbGVzLkNsZWFyKCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwdWJsaWMgdm9pZCBBZGROb2RlKEFkdmFuY2luZ0Zyb250Tm9kZSBub2RlKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgLy8gICAgICAgIENvbnNvbGUuV3JpdGVMaW5lKCBcImFkZDpcIiArIG5vZGUua2V5ICsgXCI6XCIgKyBTeXN0ZW0uaWRlbnRpdHlIYXNoQ29kZShub2RlLmtleSkpO1xyXG4gICAgICAgICAgICAvLyAgICAgICAgbV9ub2RlVHJlZS5wdXQoIG5vZGUuZ2V0S2V5KCksIG5vZGUgKTtcclxuICAgICAgICAgICAgYUZyb250LkFkZE5vZGUobm9kZSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwdWJsaWMgdm9pZCBSZW1vdmVOb2RlKEFkdmFuY2luZ0Zyb250Tm9kZSBub2RlKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgLy8gICAgICAgIENvbnNvbGUuV3JpdGVMaW5lKCBcInJlbW92ZTpcIiArIG5vZGUua2V5ICsgXCI6XCIgKyBTeXN0ZW0uaWRlbnRpdHlIYXNoQ29kZShub2RlLmtleSkpO1xyXG4gICAgICAgICAgICAvLyAgICAgICAgbV9ub2RlVHJlZS5kZWxldGUoIG5vZGUuZ2V0S2V5KCkgKTtcclxuICAgICAgICAgICAgYUZyb250LlJlbW92ZU5vZGUobm9kZSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwdWJsaWMgQWR2YW5jaW5nRnJvbnROb2RlIExvY2F0ZU5vZGUoVHJpYW5ndWxhdGlvblBvaW50IHBvaW50KVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIGFGcm9udC5Mb2NhdGVOb2RlKHBvaW50KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHB1YmxpYyB2b2lkIENyZWF0ZUFkdmFuY2luZ0Zyb250KClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIEFkdmFuY2luZ0Zyb250Tm9kZSBoZWFkLCB0YWlsLCBtaWRkbGU7XHJcbiAgICAgICAgICAgIC8vIEluaXRpYWwgdHJpYW5nbGVcclxuICAgICAgICAgICAgRGVsYXVuYXlUcmlhbmdsZSBpVHJpYW5nbGUgPSBuZXcgRGVsYXVuYXlUcmlhbmdsZShQb2ludHNbMF0sIFRhaWwsIEhlYWQpO1xyXG4gICAgICAgICAgICBUcmlhbmdsZXMuQWRkKGlUcmlhbmdsZSk7XHJcblxyXG4gICAgICAgICAgICBoZWFkID0gbmV3IEFkdmFuY2luZ0Zyb250Tm9kZShpVHJpYW5nbGUuUG9pbnRzWzFdKTtcclxuICAgICAgICAgICAgaGVhZC5UcmlhbmdsZSA9IGlUcmlhbmdsZTtcclxuICAgICAgICAgICAgbWlkZGxlID0gbmV3IEFkdmFuY2luZ0Zyb250Tm9kZShpVHJpYW5nbGUuUG9pbnRzWzBdKTtcclxuICAgICAgICAgICAgbWlkZGxlLlRyaWFuZ2xlID0gaVRyaWFuZ2xlO1xyXG4gICAgICAgICAgICB0YWlsID0gbmV3IEFkdmFuY2luZ0Zyb250Tm9kZShpVHJpYW5nbGUuUG9pbnRzWzJdKTtcclxuXHJcbiAgICAgICAgICAgIGFGcm9udCA9IG5ldyBBZHZhbmNpbmdGcm9udChoZWFkLCB0YWlsKTtcclxuICAgICAgICAgICAgYUZyb250LkFkZE5vZGUobWlkZGxlKTtcclxuXHJcbiAgICAgICAgICAgIC8vIFRPRE86IEkgdGhpbmsgaXQgd291bGQgYmUgbW9yZSBpbnR1aXRpdmUgaWYgaGVhZCBpcyBtaWRkbGVzIG5leHQgYW5kIG5vdCBwcmV2aW91c1xyXG4gICAgICAgICAgICAvLyAgICAgICBzbyBzd2FwIGhlYWQgYW5kIHRhaWxcclxuICAgICAgICAgICAgYUZyb250LkhlYWQuTmV4dCA9IG1pZGRsZTtcclxuICAgICAgICAgICAgbWlkZGxlLk5leHQgPSBhRnJvbnQuVGFpbDtcclxuICAgICAgICAgICAgbWlkZGxlLlByZXYgPSBhRnJvbnQuSGVhZDtcclxuICAgICAgICAgICAgYUZyb250LlRhaWwuUHJldiA9IG1pZGRsZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gVHJ5IHRvIG1hcCBhIG5vZGUgdG8gYWxsIHNpZGVzIG9mIHRoaXMgdHJpYW5nbGUgdGhhdCBkb24ndCBoYXZlIFxyXG4gICAgICAgIC8vLyBhIG5laWdoYm9yLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgcHVibGljIHZvaWQgTWFwVHJpYW5nbGVUb05vZGVzKERlbGF1bmF5VHJpYW5nbGUgdClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIEFkdmFuY2luZ0Zyb250Tm9kZSBuO1xyXG4gICAgICAgICAgICBmb3IgKGludCBpID0gMDsgaSA8IDM7IGkrKylcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgaWYgKHQuTmVpZ2hib3JzW2ldID09IG51bGwpXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgbiA9IGFGcm9udC5Mb2NhdGVQb2ludCh0LlBvaW50Q1codC5Qb2ludHNbaV0pKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAobiAhPSBudWxsKVxyXG4gICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbi5UcmlhbmdsZSA9IHQ7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwdWJsaWMgb3ZlcnJpZGUgdm9pZCBQcmVwYXJlVHJpYW5ndWxhdGlvbihUcmlhbmd1bGF0YWJsZSB0KVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgYmFzZS5QcmVwYXJlVHJpYW5ndWxhdGlvbih0KTtcclxuXHJcbiAgICAgICAgICAgIGRvdWJsZSB4bWF4LCB4bWluO1xyXG4gICAgICAgICAgICBkb3VibGUgeW1heCwgeW1pbjtcclxuXHJcbiAgICAgICAgICAgIHhtYXggPSB4bWluID0gUG9pbnRzWzBdLlg7XHJcbiAgICAgICAgICAgIHltYXggPSB5bWluID0gUG9pbnRzWzBdLlk7XHJcblxyXG4gICAgICAgICAgICAvLyBDYWxjdWxhdGUgYm91bmRzLiBTaG91bGQgYmUgY29tYmluZWQgd2l0aCB0aGUgc29ydGluZ1xyXG4gICAgICAgICAgICBmb3JlYWNoIChUcmlhbmd1bGF0aW9uUG9pbnQgcCBpbiBQb2ludHMpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGlmIChwLlggPiB4bWF4KVxyXG4gICAgICAgICAgICAgICAgICAgIHhtYXggPSBwLlg7XHJcbiAgICAgICAgICAgICAgICBpZiAocC5YIDwgeG1pbilcclxuICAgICAgICAgICAgICAgICAgICB4bWluID0gcC5YO1xyXG4gICAgICAgICAgICAgICAgaWYgKHAuWSA+IHltYXgpXHJcbiAgICAgICAgICAgICAgICAgICAgeW1heCA9IHAuWTtcclxuICAgICAgICAgICAgICAgIGlmIChwLlkgPCB5bWluKVxyXG4gICAgICAgICAgICAgICAgICAgIHltaW4gPSBwLlk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGRvdWJsZSBkZWx0YVggPSBBTFBIQSooeG1heCAtIHhtaW4pO1xyXG4gICAgICAgICAgICBkb3VibGUgZGVsdGFZID0gQUxQSEEqKHltYXggLSB5bWluKTtcclxuICAgICAgICAgICAgVHJpYW5ndWxhdGlvblBvaW50IHAxID0gbmV3IFRyaWFuZ3VsYXRpb25Qb2ludCh4bWF4ICsgZGVsdGFYLCB5bWluIC0gZGVsdGFZKTtcclxuICAgICAgICAgICAgVHJpYW5ndWxhdGlvblBvaW50IHAyID0gbmV3IFRyaWFuZ3VsYXRpb25Qb2ludCh4bWluIC0gZGVsdGFYLCB5bWluIC0gZGVsdGFZKTtcclxuXHJcbiAgICAgICAgICAgIEhlYWQgPSBwMTtcclxuICAgICAgICAgICAgVGFpbCA9IHAyO1xyXG5cclxuICAgICAgICAgICAgLy8gICAgICAgIGxvbmcgdGltZSA9IFN5c3RlbS5uYW5vVGltZSgpO1xyXG4gICAgICAgICAgICAvLyBTb3J0IHRoZSBwb2ludHMgYWxvbmcgeS1heGlzXHJcbiAgICAgICAgICAgIFBvaW50cy5Tb3J0KF9jb21wYXJhdG9yKTtcclxuICAgICAgICAgICAgLy8gICAgICAgIGxvZ2dlci5pbmZvKCBcIlRyaWFuZ3VsYXRpb24gc2V0dXAgW3t9bXNdXCIsICggU3lzdGVtLm5hbm9UaW1lKCkgLSB0aW1lICkgLyAxZTYgKTtcclxuICAgICAgICB9XHJcblxyXG5cclxuICAgICAgICBwdWJsaWMgdm9pZCBGaW5hbGl6ZVRyaWFuZ3VsYXRpb24oKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgVHJpYW5ndWxhdGFibGUuQWRkVHJpYW5nbGVzKFRyaWFuZ2xlcyk7XHJcbiAgICAgICAgICAgIFRyaWFuZ2xlcy5DbGVhcigpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHVibGljIG92ZXJyaWRlIFRyaWFuZ3VsYXRpb25Db25zdHJhaW50IE5ld0NvbnN0cmFpbnQoVHJpYW5ndWxhdGlvblBvaW50IGEsIFRyaWFuZ3VsYXRpb25Qb2ludCBiKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBEVFN3ZWVwQ29uc3RyYWludChhLCBiKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgICNyZWdpb24gTmVzdGVkIHR5cGU6IERUU3dlZXBCYXNpblxyXG5cclxuICAgICAgICBwdWJsaWMgY2xhc3MgRFRTd2VlcEJhc2luXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBwdWJsaWMgQWR2YW5jaW5nRnJvbnROb2RlIGJvdHRvbU5vZGU7XHJcbiAgICAgICAgICAgIHB1YmxpYyBib29sIGxlZnRIaWdoZXN0O1xyXG4gICAgICAgICAgICBwdWJsaWMgQWR2YW5jaW5nRnJvbnROb2RlIGxlZnROb2RlO1xyXG4gICAgICAgICAgICBwdWJsaWMgQWR2YW5jaW5nRnJvbnROb2RlIHJpZ2h0Tm9kZTtcclxuICAgICAgICAgICAgcHVibGljIGRvdWJsZSB3aWR0aDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgICNlbmRyZWdpb25cclxuXHJcbiAgICAgICAgI3JlZ2lvbiBOZXN0ZWQgdHlwZTogRFRTd2VlcEVkZ2VFdmVudFxyXG5cclxuICAgICAgICBwdWJsaWMgY2xhc3MgRFRTd2VlcEVkZ2VFdmVudFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcHVibGljIERUU3dlZXBDb25zdHJhaW50IENvbnN0cmFpbmVkRWRnZTtcclxuICAgICAgICAgICAgcHVibGljIGJvb2wgUmlnaHQ7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAjZW5kcmVnaW9uXHJcbiAgICB9XHJcbn0iLCIvKiBQb2x5MlRyaVxyXG4gKiBDb3B5cmlnaHQgKGMpIDIwMDktMjAxMCwgUG9seTJUcmkgQ29udHJpYnV0b3JzXHJcbiAqIGh0dHA6Ly9jb2RlLmdvb2dsZS5jb20vcC9wb2x5MnRyaS9cclxuICpcclxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICpcclxuICogUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aCBvciB3aXRob3V0IG1vZGlmaWNhdGlvbixcclxuICogYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgY29uZGl0aW9ucyBhcmUgbWV0OlxyXG4gKlxyXG4gKiAqIFJlZGlzdHJpYnV0aW9ucyBvZiBzb3VyY2UgY29kZSBtdXN0IHJldGFpbiB0aGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSxcclxuICogICB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyLlxyXG4gKiAqIFJlZGlzdHJpYnV0aW9ucyBpbiBiaW5hcnkgZm9ybSBtdXN0IHJlcHJvZHVjZSB0aGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSxcclxuICogICB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyIGluIHRoZSBkb2N1bWVudGF0aW9uXHJcbiAqICAgYW5kL29yIG90aGVyIG1hdGVyaWFscyBwcm92aWRlZCB3aXRoIHRoZSBkaXN0cmlidXRpb24uXHJcbiAqICogTmVpdGhlciB0aGUgbmFtZSBvZiBQb2x5MlRyaSBub3IgdGhlIG5hbWVzIG9mIGl0cyBjb250cmlidXRvcnMgbWF5IGJlXHJcbiAqICAgdXNlZCB0byBlbmRvcnNlIG9yIHByb21vdGUgcHJvZHVjdHMgZGVyaXZlZCBmcm9tIHRoaXMgc29mdHdhcmUgd2l0aG91dCBzcGVjaWZpY1xyXG4gKiAgIHByaW9yIHdyaXR0ZW4gcGVybWlzc2lvbi5cclxuICpcclxuICogVEhJUyBTT0ZUV0FSRSBJUyBQUk9WSURFRCBCWSBUSEUgQ09QWVJJR0hUIEhPTERFUlMgQU5EIENPTlRSSUJVVE9SU1xyXG4gKiBcIkFTIElTXCIgQU5EIEFOWSBFWFBSRVNTIE9SIElNUExJRUQgV0FSUkFOVElFUywgSU5DTFVESU5HLCBCVVQgTk9UXHJcbiAqIExJTUlURUQgVE8sIFRIRSBJTVBMSUVEIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZIEFORCBGSVRORVNTIEZPUlxyXG4gKiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBUkUgRElTQ0xBSU1FRC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIENPUFlSSUdIVCBPV05FUiBPUlxyXG4gKiBDT05UUklCVVRPUlMgQkUgTElBQkxFIEZPUiBBTlkgRElSRUNULCBJTkRJUkVDVCwgSU5DSURFTlRBTCwgU1BFQ0lBTCxcclxuICogRVhFTVBMQVJZLCBPUiBDT05TRVFVRU5USUFMIERBTUFHRVMgKElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLFxyXG4gKiBQUk9DVVJFTUVOVCBPRiBTVUJTVElUVVRFIEdPT0RTIE9SIFNFUlZJQ0VTOyBMT1NTIE9GIFVTRSwgREFUQSwgT1JcclxuICogUFJPRklUUzsgT1IgQlVTSU5FU1MgSU5URVJSVVBUSU9OKSBIT1dFVkVSIENBVVNFRCBBTkQgT04gQU5ZIFRIRU9SWSBPRlxyXG4gKiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQ09OVFJBQ1QsIFNUUklDVCBMSUFCSUxJVFksIE9SIFRPUlQgKElOQ0xVRElOR1xyXG4gKiBORUdMSUdFTkNFIE9SIE9USEVSV0lTRSkgQVJJU0lORyBJTiBBTlkgV0FZIE9VVCBPRiBUSEUgVVNFIE9GIFRISVNcclxuICogU09GVFdBUkUsIEVWRU4gSUYgQURWSVNFRCBPRiBUSEUgUE9TU0lCSUxJVFkgT0YgU1VDSCBEQU1BR0UuXHJcbiAqL1xyXG5cclxudXNpbmcgU3lzdGVtLkNvbGxlY3Rpb25zLkdlbmVyaWM7XHJcblxyXG5uYW1lc3BhY2UgUG9seTJUcmkuVHJpYW5ndWxhdGlvbi5EZWxhdW5heS5Td2VlcFxyXG57XHJcbiAgICBwdWJsaWMgY2xhc3MgRFRTd2VlcFBvaW50Q29tcGFyYXRvciA6IElDb21wYXJlcjxUcmlhbmd1bGF0aW9uUG9pbnQ+XHJcbiAgICB7XHJcbiAgICAgICAgI3JlZ2lvbiBJQ29tcGFyZXI8VHJpYW5ndWxhdGlvblBvaW50PiBNZW1iZXJzXHJcblxyXG4gICAgICAgIHB1YmxpYyBpbnQgQ29tcGFyZShUcmlhbmd1bGF0aW9uUG9pbnQgcDEsIFRyaWFuZ3VsYXRpb25Qb2ludCBwMilcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGlmIChwMS5ZIDwgcDIuWSlcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIC0xO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKHAxLlkgPiBwMi5ZKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gMTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGlmIChwMS5YIDwgcDIuWClcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gLTE7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChwMS5YID4gcDIuWClcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gMTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gMDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgI2VuZHJlZ2lvblxyXG4gICAgfVxyXG59IiwiLyogUG9seTJUcmlcclxuICogQ29weXJpZ2h0IChjKSAyMDA5LTIwMTAsIFBvbHkyVHJpIENvbnRyaWJ1dG9yc1xyXG4gKiBodHRwOi8vY29kZS5nb29nbGUuY29tL3AvcG9seTJ0cmkvXHJcbiAqXHJcbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqXHJcbiAqIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGggb3Igd2l0aG91dCBtb2RpZmljYXRpb24sXHJcbiAqIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnMgYXJlIG1ldDpcclxuICpcclxuICogKiBSZWRpc3RyaWJ1dGlvbnMgb2Ygc291cmNlIGNvZGUgbXVzdCByZXRhaW4gdGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UsXHJcbiAqICAgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lci5cclxuICogKiBSZWRpc3RyaWJ1dGlvbnMgaW4gYmluYXJ5IGZvcm0gbXVzdCByZXByb2R1Y2UgdGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UsXHJcbiAqICAgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lciBpbiB0aGUgZG9jdW1lbnRhdGlvblxyXG4gKiAgIGFuZC9vciBvdGhlciBtYXRlcmlhbHMgcHJvdmlkZWQgd2l0aCB0aGUgZGlzdHJpYnV0aW9uLlxyXG4gKiAqIE5laXRoZXIgdGhlIG5hbWUgb2YgUG9seTJUcmkgbm9yIHRoZSBuYW1lcyBvZiBpdHMgY29udHJpYnV0b3JzIG1heSBiZVxyXG4gKiAgIHVzZWQgdG8gZW5kb3JzZSBvciBwcm9tb3RlIHByb2R1Y3RzIGRlcml2ZWQgZnJvbSB0aGlzIHNvZnR3YXJlIHdpdGhvdXQgc3BlY2lmaWNcclxuICogICBwcmlvciB3cml0dGVuIHBlcm1pc3Npb24uXHJcbiAqXHJcbiAqIFRISVMgU09GVFdBUkUgSVMgUFJPVklERUQgQlkgVEhFIENPUFlSSUdIVCBIT0xERVJTIEFORCBDT05UUklCVVRPUlNcclxuICogXCJBUyBJU1wiIEFORCBBTlkgRVhQUkVTUyBPUiBJTVBMSUVEIFdBUlJBTlRJRVMsIElOQ0xVRElORywgQlVUIE5PVFxyXG4gKiBMSU1JVEVEIFRPLCBUSEUgSU1QTElFRCBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSBBTkQgRklUTkVTUyBGT1JcclxuICogQSBQQVJUSUNVTEFSIFBVUlBPU0UgQVJFIERJU0NMQUlNRUQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBDT1BZUklHSFQgT1dORVIgT1JcclxuICogQ09OVFJJQlVUT1JTIEJFIExJQUJMRSBGT1IgQU5ZIERJUkVDVCwgSU5ESVJFQ1QsIElOQ0lERU5UQUwsIFNQRUNJQUwsXHJcbiAqIEVYRU1QTEFSWSwgT1IgQ09OU0VRVUVOVElBTCBEQU1BR0VTIChJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRCBUTyxcclxuICogUFJPQ1VSRU1FTlQgT0YgU1VCU1RJVFVURSBHT09EUyBPUiBTRVJWSUNFUzsgTE9TUyBPRiBVU0UsIERBVEEsIE9SXHJcbiAqIFBST0ZJVFM7IE9SIEJVU0lORVNTIElOVEVSUlVQVElPTikgSE9XRVZFUiBDQVVTRUQgQU5EIE9OIEFOWSBUSEVPUlkgT0ZcclxuICogTElBQklMSVRZLCBXSEVUSEVSIElOIENPTlRSQUNULCBTVFJJQ1QgTElBQklMSVRZLCBPUiBUT1JUIChJTkNMVURJTkdcclxuICogTkVHTElHRU5DRSBPUiBPVEhFUldJU0UpIEFSSVNJTkcgSU4gQU5ZIFdBWSBPVVQgT0YgVEhFIFVTRSBPRiBUSElTXHJcbiAqIFNPRlRXQVJFLCBFVkVOIElGIEFEVklTRUQgT0YgVEhFIFBPU1NJQklMSVRZIE9GIFNVQ0ggREFNQUdFLlxyXG4gKi9cclxuXHJcbi8vIENoYW5nZXMgZnJvbSB0aGUgSmF2YSB2ZXJzaW9uXHJcbi8vICAgUG9seWdvbiBjb25zdHJ1Y3RvcnMgc3BydXNlZCB1cCwgY2hlY2tzIGZvciAzKyBwb2x5c1xyXG4vLyAgIE5hbWluZyBvZiBldmVyeXRoaW5nXHJcbi8vICAgZ2V0VHJpYW5ndWxhdGlvbk1vZGUoKSAtPiBUcmlhbmd1bGF0aW9uTW9kZSB7IGdldDsgfVxyXG4vLyAgIEV4Y2VwdGlvbnMgcmVwbGFjZWRcclxuLy8gRnV0dXJlIHBvc3NpYmlsaXRpZXNcclxuLy8gICBXZSBoYXZlIGEgbG90IG9mIEFkZC9DbGVhciBtZXRob2RzIC0tIHdlIG1heSBwcmVmZXIgdG8ganVzdCBleHBvc2UgdGhlIGNvbnRhaW5lclxyXG4vLyAgIFNvbWUgc2VsZi1leHBsYW5pdG9yeSBtZXRob2RzIG1heSBkZXNlcnZlIGNvbW1lbnRpbmcgYW55d2F5c1xyXG5cclxudXNpbmcgU3lzdGVtO1xyXG51c2luZyBTeXN0ZW0uQ29sbGVjdGlvbnMuR2VuZXJpYztcclxudXNpbmcgU3lzdGVtLkxpbnE7XHJcbnVzaW5nIFBvbHkyVHJpLlRyaWFuZ3VsYXRpb24uRGVsYXVuYXk7XHJcblxyXG5uYW1lc3BhY2UgUG9seTJUcmkuVHJpYW5ndWxhdGlvbi5Qb2x5Z29uXHJcbntcclxuICAgIHB1YmxpYyBjbGFzcyBQb2x5Z29uIDogVHJpYW5ndWxhdGFibGVcclxuICAgIHtcclxuICAgICAgICBwcm90ZWN0ZWQgTGlzdDxQb2x5Z29uPiBfaG9sZXM7XHJcbiAgICAgICAgcHJvdGVjdGVkIFBvbHlnb25Qb2ludCBfbGFzdDtcclxuICAgICAgICBwcm90ZWN0ZWQgTGlzdDxUcmlhbmd1bGF0aW9uUG9pbnQ+IF9wb2ludHMgPSBuZXcgTGlzdDxUcmlhbmd1bGF0aW9uUG9pbnQ+KCk7XHJcbiAgICAgICAgcHJvdGVjdGVkIExpc3Q8VHJpYW5ndWxhdGlvblBvaW50PiBfc3RlaW5lclBvaW50cztcclxuICAgICAgICBwcm90ZWN0ZWQgTGlzdDxEZWxhdW5heVRyaWFuZ2xlPiBfdHJpYW5nbGVzO1xyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIENyZWF0ZSBhIHBvbHlnb24gZnJvbSBhIGxpc3Qgb2YgYXQgbGVhc3QgMyBwb2ludHMgd2l0aCBubyBkdXBsaWNhdGVzLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwicG9pbnRzXCI+QSBsaXN0IG9mIHVuaXF1ZSBwb2ludHM8L3BhcmFtPlxyXG4gICAgICAgIHB1YmxpYyBQb2x5Z29uKElMaXN0PFBvbHlnb25Qb2ludD4gcG9pbnRzKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgaWYgKHBvaW50cy5Db3VudCA8IDMpIHRocm93IG5ldyBBcmd1bWVudEV4Y2VwdGlvbihcIkxpc3QgaGFzIGZld2VyIHRoYW4gMyBwb2ludHNcIiwgXCJwb2ludHNcIik7XHJcblxyXG4gICAgICAgICAgICAvLyBMZXRzIGRvIG9uZSBzYW5pdHkgY2hlY2sgdGhhdCBmaXJzdCBhbmQgbGFzdCBwb2ludCBoYXNuJ3QgZ290IHNhbWUgcG9zaXRpb25cclxuICAgICAgICAgICAgLy8gSXRzIHNvbWV0aGluZyB0aGF0IG9mdGVuIGhhcHBlbiB3aGVuIGltcG9ydGluZyBwb2x5Z29uIGRhdGEgZnJvbSBvdGhlciBmb3JtYXRzXHJcbiAgICAgICAgICAgIGlmIChwb2ludHNbMF0uRXF1YWxzKHBvaW50c1twb2ludHMuQ291bnQgLSAxXSkpIHBvaW50cy5SZW1vdmVBdChwb2ludHMuQ291bnQgLSAxKTtcclxuXHJcbiAgICAgICAgICAgIF9wb2ludHMuQWRkUmFuZ2UocG9pbnRzLkNhc3Q8VHJpYW5ndWxhdGlvblBvaW50PigpKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gQ3JlYXRlIGEgcG9seWdvbiBmcm9tIGEgbGlzdCBvZiBhdCBsZWFzdCAzIHBvaW50cyB3aXRoIG5vIGR1cGxpY2F0ZXMuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJwb2ludHNcIj5BIGxpc3Qgb2YgdW5pcXVlIHBvaW50cy48L3BhcmFtPlxyXG4gICAgICAgIHB1YmxpYyBQb2x5Z29uKElFbnVtZXJhYmxlPFBvbHlnb25Qb2ludD4gcG9pbnRzKSA6IHRoaXMoKHBvaW50cyBhcyBJTGlzdDxQb2x5Z29uUG9pbnQ+KSA/PyBTeXN0ZW0uTGlucS5FbnVtZXJhYmxlLlRvQXJyYXk8Z2xvYmFsOjpQb2x5MlRyaS5Ucmlhbmd1bGF0aW9uLlBvbHlnb24uUG9seWdvblBvaW50Pihwb2ludHMpKVxyXG4gICAgICAgIHtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHB1YmxpYyBQb2x5Z29uKClcclxuICAgICAgICB7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwdWJsaWMgSUxpc3Q8UG9seWdvbj4gSG9sZXNcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGdldCB7IHJldHVybiBfaG9sZXM7IH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgICNyZWdpb24gVHJpYW5ndWxhdGFibGUgTWVtYmVyc1xyXG5cclxuICAgICAgICBwdWJsaWMgVHJpYW5ndWxhdGlvbk1vZGUgVHJpYW5ndWxhdGlvbk1vZGVcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGdldCB7IHJldHVybiBUcmlhbmd1bGF0aW9uTW9kZS5Qb2x5Z29uOyB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwdWJsaWMgSUxpc3Q8VHJpYW5ndWxhdGlvblBvaW50PiBQb2ludHNcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGdldCB7IHJldHVybiBfcG9pbnRzOyB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwdWJsaWMgSUxpc3Q8RGVsYXVuYXlUcmlhbmdsZT4gVHJpYW5nbGVzXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBnZXQgeyByZXR1cm4gX3RyaWFuZ2xlczsgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHVibGljIHZvaWQgQWRkVHJpYW5nbGUoRGVsYXVuYXlUcmlhbmdsZSB0KVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgX3RyaWFuZ2xlcy5BZGQodCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwdWJsaWMgdm9pZCBBZGRUcmlhbmdsZXMoSUVudW1lcmFibGU8RGVsYXVuYXlUcmlhbmdsZT4gbGlzdClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIF90cmlhbmdsZXMuQWRkUmFuZ2UobGlzdCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwdWJsaWMgdm9pZCBDbGVhclRyaWFuZ2xlcygpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBpZiAoX3RyaWFuZ2xlcyAhPSBudWxsKSBfdHJpYW5nbGVzLkNsZWFyKCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIENyZWF0ZXMgY29uc3RyYWludHMgYW5kIHBvcHVsYXRlcyB0aGUgY29udGV4dCB3aXRoIHBvaW50c1xyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwidGN4XCI+VGhlIGNvbnRleHQ8L3BhcmFtPlxyXG4gICAgICAgIHB1YmxpYyB2b2lkIFByZXBhcmVUcmlhbmd1bGF0aW9uKFRyaWFuZ3VsYXRpb25Db250ZXh0IHRjeClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGlmIChfdHJpYW5nbGVzID09IG51bGwpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIF90cmlhbmdsZXMgPSBuZXcgTGlzdDxEZWxhdW5heVRyaWFuZ2xlPihfcG9pbnRzLkNvdW50KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIF90cmlhbmdsZXMuQ2xlYXIoKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gT3V0ZXIgY29uc3RyYWludHNcclxuICAgICAgICAgICAgZm9yIChpbnQgaSA9IDA7IGkgPCBfcG9pbnRzLkNvdW50IC0gMTsgaSsrKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB0Y3guTmV3Q29uc3RyYWludChfcG9pbnRzW2ldLCBfcG9pbnRzW2kgKyAxXSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGN4Lk5ld0NvbnN0cmFpbnQoX3BvaW50c1swXSwgX3BvaW50c1tfcG9pbnRzLkNvdW50IC0gMV0pO1xyXG4gICAgICAgICAgICB0Y3guUG9pbnRzLkFkZFJhbmdlKF9wb2ludHMpO1xyXG5cclxuICAgICAgICAgICAgLy8gSG9sZSBjb25zdHJhaW50c1xyXG4gICAgICAgICAgICBpZiAoX2hvbGVzICE9IG51bGwpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGZvcmVhY2ggKFBvbHlnb24gcCBpbiBfaG9sZXMpXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yIChpbnQgaSA9IDA7IGkgPCBwLl9wb2ludHMuQ291bnQgLSAxOyBpKyspXHJcbiAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0Y3guTmV3Q29uc3RyYWludChwLl9wb2ludHNbaV0sIHAuX3BvaW50c1tpICsgMV0pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB0Y3guTmV3Q29uc3RyYWludChwLl9wb2ludHNbMF0sIHAuX3BvaW50c1twLl9wb2ludHMuQ291bnQgLSAxXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGN4LlBvaW50cy5BZGRSYW5nZShwLl9wb2ludHMpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAoX3N0ZWluZXJQb2ludHMgIT0gbnVsbClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdGN4LlBvaW50cy5BZGRSYW5nZShfc3RlaW5lclBvaW50cyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgICNlbmRyZWdpb25cclxuXHJcbiAgICAgICAgcHVibGljIHZvaWQgQWRkU3RlaW5lclBvaW50KFRyaWFuZ3VsYXRpb25Qb2ludCBwb2ludClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGlmIChfc3RlaW5lclBvaW50cyA9PSBudWxsKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBfc3RlaW5lclBvaW50cyA9IG5ldyBMaXN0PFRyaWFuZ3VsYXRpb25Qb2ludD4oKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBfc3RlaW5lclBvaW50cy5BZGQocG9pbnQpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHVibGljIHZvaWQgQWRkU3RlaW5lclBvaW50cyhMaXN0PFRyaWFuZ3VsYXRpb25Qb2ludD4gcG9pbnRzKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgaWYgKF9zdGVpbmVyUG9pbnRzID09IG51bGwpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIF9zdGVpbmVyUG9pbnRzID0gbmV3IExpc3Q8VHJpYW5ndWxhdGlvblBvaW50PigpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIF9zdGVpbmVyUG9pbnRzLkFkZFJhbmdlKHBvaW50cyk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwdWJsaWMgdm9pZCBDbGVhclN0ZWluZXJQb2ludHMoKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgaWYgKF9zdGVpbmVyUG9pbnRzICE9IG51bGwpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIF9zdGVpbmVyUG9pbnRzLkNsZWFyKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gQWRkIGEgaG9sZSB0byB0aGUgcG9seWdvbi5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cInBvbHlcIj5BIHN1YnRyYWN0aW9uIHBvbHlnb24gZnVsbHkgY29udGFpbmVkIGluc2lkZSB0aGlzIHBvbHlnb24uPC9wYXJhbT5cclxuICAgICAgICBwdWJsaWMgdm9pZCBBZGRIb2xlKFBvbHlnb24gcG9seSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGlmIChfaG9sZXMgPT0gbnVsbCkgX2hvbGVzID0gbmV3IExpc3Q8UG9seWdvbj4oKTtcclxuICAgICAgICAgICAgX2hvbGVzLkFkZChwb2x5KTtcclxuICAgICAgICAgICAgLy8gWFhYOiB0ZXN0cyBjb3VsZCBiZSBtYWRlIGhlcmUgdG8gYmUgc3VyZSBpdCBpcyBmdWxseSBpbnNpZGVcclxuICAgICAgICAgICAgLy8gICAgICAgIGFkZFN1YnRyYWN0aW9uKCBwb2x5LmdldFBvaW50cygpICk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIEluc2VydHMgbmV3UG9pbnQgYWZ0ZXIgcG9pbnQuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJwb2ludFwiPlRoZSBwb2ludCB0byBpbnNlcnQgYWZ0ZXIgaW4gdGhlIHBvbHlnb248L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cIm5ld1BvaW50XCI+VGhlIHBvaW50IHRvIGluc2VydCBpbnRvIHRoZSBwb2x5Z29uPC9wYXJhbT5cclxuICAgICAgICBwdWJsaWMgdm9pZCBJbnNlcnRQb2ludEFmdGVyKFBvbHlnb25Qb2ludCBwb2ludCwgUG9seWdvblBvaW50IG5ld1BvaW50KVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgLy8gVmFsaWRhdGUgdGhhdCBcclxuICAgICAgICAgICAgaW50IGluZGV4ID0gX3BvaW50cy5JbmRleE9mKHBvaW50KTtcclxuICAgICAgICAgICAgaWYgKGluZGV4ID09IC0xKVxyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEFyZ3VtZW50RXhjZXB0aW9uKFxyXG4gICAgICAgICAgICAgICAgICAgIFwiVHJpZWQgdG8gaW5zZXJ0IGEgcG9pbnQgaW50byBhIFBvbHlnb24gYWZ0ZXIgYSBwb2ludCBub3QgYmVsb25naW5nIHRvIHRoZSBQb2x5Z29uXCIsIFwicG9pbnRcIik7XHJcbiAgICAgICAgICAgIG5ld1BvaW50Lk5leHQgPSBwb2ludC5OZXh0O1xyXG4gICAgICAgICAgICBuZXdQb2ludC5QcmV2aW91cyA9IHBvaW50O1xyXG4gICAgICAgICAgICBwb2ludC5OZXh0LlByZXZpb3VzID0gbmV3UG9pbnQ7XHJcbiAgICAgICAgICAgIHBvaW50Lk5leHQgPSBuZXdQb2ludDtcclxuICAgICAgICAgICAgX3BvaW50cy5JbnNlcnQoaW5kZXggKyAxLCBuZXdQb2ludCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIEluc2VydHMgbGlzdCAoYWZ0ZXIgbGFzdCBwb2ludCBpbiBwb2x5Z29uPylcclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cImxpc3RcIj48L3BhcmFtPlxyXG4gICAgICAgIHB1YmxpYyB2b2lkIEFkZFBvaW50cyhJRW51bWVyYWJsZTxQb2x5Z29uUG9pbnQ+IGxpc3QpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBQb2x5Z29uUG9pbnQgZmlyc3Q7XHJcbiAgICAgICAgICAgIGZvcmVhY2ggKFBvbHlnb25Qb2ludCBwIGluIGxpc3QpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHAuUHJldmlvdXMgPSBfbGFzdDtcclxuICAgICAgICAgICAgICAgIGlmIChfbGFzdCAhPSBudWxsKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIHAuTmV4dCA9IF9sYXN0Lk5leHQ7XHJcbiAgICAgICAgICAgICAgICAgICAgX2xhc3QuTmV4dCA9IHA7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBfbGFzdCA9IHA7XHJcbiAgICAgICAgICAgICAgICBfcG9pbnRzLkFkZChwKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBmaXJzdCA9IChQb2x5Z29uUG9pbnQpIF9wb2ludHNbMF07XHJcbiAgICAgICAgICAgIF9sYXN0Lk5leHQgPSBmaXJzdDtcclxuICAgICAgICAgICAgZmlyc3QuUHJldmlvdXMgPSBfbGFzdDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gQWRkcyBhIHBvaW50IGFmdGVyIHRoZSBsYXN0IGluIHRoZSBwb2x5Z29uLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwicFwiPlRoZSBwb2ludCB0byBhZGQ8L3BhcmFtPlxyXG4gICAgICAgIHB1YmxpYyB2b2lkIEFkZFBvaW50KFBvbHlnb25Qb2ludCBwKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcC5QcmV2aW91cyA9IF9sYXN0O1xyXG4gICAgICAgICAgICBwLk5leHQgPSBfbGFzdC5OZXh0O1xyXG4gICAgICAgICAgICBfbGFzdC5OZXh0ID0gcDtcclxuICAgICAgICAgICAgX3BvaW50cy5BZGQocCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIFJlbW92ZXMgYSBwb2ludCBmcm9tIHRoZSBwb2x5Z29uLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwicFwiPjwvcGFyYW0+XHJcbiAgICAgICAgcHVibGljIHZvaWQgUmVtb3ZlUG9pbnQoUG9seWdvblBvaW50IHApXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBQb2x5Z29uUG9pbnQgbmV4dCwgcHJldjtcclxuXHJcbiAgICAgICAgICAgIG5leHQgPSBwLk5leHQ7XHJcbiAgICAgICAgICAgIHByZXYgPSBwLlByZXZpb3VzO1xyXG4gICAgICAgICAgICBwcmV2Lk5leHQgPSBuZXh0O1xyXG4gICAgICAgICAgICBuZXh0LlByZXZpb3VzID0gcHJldjtcclxuICAgICAgICAgICAgX3BvaW50cy5SZW1vdmUocCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59IiwiLyogUG9seTJUcmlcclxuICogQ29weXJpZ2h0IChjKSAyMDA5LTIwMTAsIFBvbHkyVHJpIENvbnRyaWJ1dG9yc1xyXG4gKiBodHRwOi8vY29kZS5nb29nbGUuY29tL3AvcG9seTJ0cmkvXHJcbiAqXHJcbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqXHJcbiAqIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGggb3Igd2l0aG91dCBtb2RpZmljYXRpb24sXHJcbiAqIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnMgYXJlIG1ldDpcclxuICpcclxuICogKiBSZWRpc3RyaWJ1dGlvbnMgb2Ygc291cmNlIGNvZGUgbXVzdCByZXRhaW4gdGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UsXHJcbiAqICAgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lci5cclxuICogKiBSZWRpc3RyaWJ1dGlvbnMgaW4gYmluYXJ5IGZvcm0gbXVzdCByZXByb2R1Y2UgdGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UsXHJcbiAqICAgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lciBpbiB0aGUgZG9jdW1lbnRhdGlvblxyXG4gKiAgIGFuZC9vciBvdGhlciBtYXRlcmlhbHMgcHJvdmlkZWQgd2l0aCB0aGUgZGlzdHJpYnV0aW9uLlxyXG4gKiAqIE5laXRoZXIgdGhlIG5hbWUgb2YgUG9seTJUcmkgbm9yIHRoZSBuYW1lcyBvZiBpdHMgY29udHJpYnV0b3JzIG1heSBiZVxyXG4gKiAgIHVzZWQgdG8gZW5kb3JzZSBvciBwcm9tb3RlIHByb2R1Y3RzIGRlcml2ZWQgZnJvbSB0aGlzIHNvZnR3YXJlIHdpdGhvdXQgc3BlY2lmaWNcclxuICogICBwcmlvciB3cml0dGVuIHBlcm1pc3Npb24uXHJcbiAqXHJcbiAqIFRISVMgU09GVFdBUkUgSVMgUFJPVklERUQgQlkgVEhFIENPUFlSSUdIVCBIT0xERVJTIEFORCBDT05UUklCVVRPUlNcclxuICogXCJBUyBJU1wiIEFORCBBTlkgRVhQUkVTUyBPUiBJTVBMSUVEIFdBUlJBTlRJRVMsIElOQ0xVRElORywgQlVUIE5PVFxyXG4gKiBMSU1JVEVEIFRPLCBUSEUgSU1QTElFRCBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSBBTkQgRklUTkVTUyBGT1JcclxuICogQSBQQVJUSUNVTEFSIFBVUlBPU0UgQVJFIERJU0NMQUlNRUQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBDT1BZUklHSFQgT1dORVIgT1JcclxuICogQ09OVFJJQlVUT1JTIEJFIExJQUJMRSBGT1IgQU5ZIERJUkVDVCwgSU5ESVJFQ1QsIElOQ0lERU5UQUwsIFNQRUNJQUwsXHJcbiAqIEVYRU1QTEFSWSwgT1IgQ09OU0VRVUVOVElBTCBEQU1BR0VTIChJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRCBUTyxcclxuICogUFJPQ1VSRU1FTlQgT0YgU1VCU1RJVFVURSBHT09EUyBPUiBTRVJWSUNFUzsgTE9TUyBPRiBVU0UsIERBVEEsIE9SXHJcbiAqIFBST0ZJVFM7IE9SIEJVU0lORVNTIElOVEVSUlVQVElPTikgSE9XRVZFUiBDQVVTRUQgQU5EIE9OIEFOWSBUSEVPUlkgT0ZcclxuICogTElBQklMSVRZLCBXSEVUSEVSIElOIENPTlRSQUNULCBTVFJJQ1QgTElBQklMSVRZLCBPUiBUT1JUIChJTkNMVURJTkdcclxuICogTkVHTElHRU5DRSBPUiBPVEhFUldJU0UpIEFSSVNJTkcgSU4gQU5ZIFdBWSBPVVQgT0YgVEhFIFVTRSBPRiBUSElTXHJcbiAqIFNPRlRXQVJFLCBFVkVOIElGIEFEVklTRUQgT0YgVEhFIFBPU1NJQklMSVRZIE9GIFNVQ0ggREFNQUdFLlxyXG4gKi9cclxuXHJcbi8vIENoYW5nZXMgZnJvbSB0aGUgSmF2YSB2ZXJzaW9uXHJcbi8vICAgUmVwbGFjZWQgZ2V0L3NldCBOZXh0L1ByZXZpb3VzIHdpdGggYXR0cmlidXRlc1xyXG4vLyBGdXR1cmUgcG9zc2liaWxpdGllc1xyXG4vLyAgIERvY3VtZW50YXRpb24hXHJcblxyXG5uYW1lc3BhY2UgUG9seTJUcmkuVHJpYW5ndWxhdGlvbi5Qb2x5Z29uXHJcbntcclxuICAgIHB1YmxpYyBjbGFzcyBQb2x5Z29uUG9pbnQgOiBUcmlhbmd1bGF0aW9uUG9pbnRcclxuICAgIHtcclxuICAgICAgICBwdWJsaWMgUG9seWdvblBvaW50KGRvdWJsZSB4LCBkb3VibGUgeSkgOiBiYXNlKHgsIHkpXHJcbiAgICAgICAge1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHVibGljIFBvbHlnb25Qb2ludCBOZXh0IHsgZ2V0OyBzZXQ7IH1cclxuICAgICAgICBwdWJsaWMgUG9seWdvblBvaW50IFByZXZpb3VzIHsgZ2V0OyBzZXQ7IH1cclxuICAgIH1cclxufSIsIi8qIFBvbHkyVHJpXHJcbiAqIENvcHlyaWdodCAoYykgMjAwOS0yMDEwLCBQb2x5MlRyaSBDb250cmlidXRvcnNcclxuICogaHR0cDovL2NvZGUuZ29vZ2xlLmNvbS9wL3BvbHkydHJpL1xyXG4gKlxyXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKlxyXG4gKiBSZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRoIG9yIHdpdGhvdXQgbW9kaWZpY2F0aW9uLFxyXG4gKiBhcmUgcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBjb25kaXRpb25zIGFyZSBtZXQ6XHJcbiAqXHJcbiAqICogUmVkaXN0cmlidXRpb25zIG9mIHNvdXJjZSBjb2RlIG11c3QgcmV0YWluIHRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlLFxyXG4gKiAgIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIuXHJcbiAqICogUmVkaXN0cmlidXRpb25zIGluIGJpbmFyeSBmb3JtIG11c3QgcmVwcm9kdWNlIHRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlLFxyXG4gKiAgIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIgaW4gdGhlIGRvY3VtZW50YXRpb25cclxuICogICBhbmQvb3Igb3RoZXIgbWF0ZXJpYWxzIHByb3ZpZGVkIHdpdGggdGhlIGRpc3RyaWJ1dGlvbi5cclxuICogKiBOZWl0aGVyIHRoZSBuYW1lIG9mIFBvbHkyVHJpIG5vciB0aGUgbmFtZXMgb2YgaXRzIGNvbnRyaWJ1dG9ycyBtYXkgYmVcclxuICogICB1c2VkIHRvIGVuZG9yc2Ugb3IgcHJvbW90ZSBwcm9kdWN0cyBkZXJpdmVkIGZyb20gdGhpcyBzb2Z0d2FyZSB3aXRob3V0IHNwZWNpZmljXHJcbiAqICAgcHJpb3Igd3JpdHRlbiBwZXJtaXNzaW9uLlxyXG4gKlxyXG4gKiBUSElTIFNPRlRXQVJFIElTIFBST1ZJREVEIEJZIFRIRSBDT1BZUklHSFQgSE9MREVSUyBBTkQgQ09OVFJJQlVUT1JTXHJcbiAqIFwiQVMgSVNcIiBBTkQgQU5ZIEVYUFJFU1MgT1IgSU1QTElFRCBXQVJSQU5USUVTLCBJTkNMVURJTkcsIEJVVCBOT1RcclxuICogTElNSVRFRCBUTywgVEhFIElNUExJRUQgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFkgQU5EIEZJVE5FU1MgRk9SXHJcbiAqIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFSRSBESVNDTEFJTUVELiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQ09QWVJJR0hUIE9XTkVSIE9SXHJcbiAqIENPTlRSSUJVVE9SUyBCRSBMSUFCTEUgRk9SIEFOWSBESVJFQ1QsIElORElSRUNULCBJTkNJREVOVEFMLCBTUEVDSUFMLFxyXG4gKiBFWEVNUExBUlksIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFUyAoSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sXHJcbiAqIFBST0NVUkVNRU5UIE9GIFNVQlNUSVRVVEUgR09PRFMgT1IgU0VSVklDRVM7IExPU1MgT0YgVVNFLCBEQVRBLCBPUlxyXG4gKiBQUk9GSVRTOyBPUiBCVVNJTkVTUyBJTlRFUlJVUFRJT04pIEhPV0VWRVIgQ0FVU0VEIEFORCBPTiBBTlkgVEhFT1JZIE9GXHJcbiAqIExJQUJJTElUWSwgV0hFVEhFUiBJTiBDT05UUkFDVCwgU1RSSUNUIExJQUJJTElUWSwgT1IgVE9SVCAoSU5DTFVESU5HXHJcbiAqIE5FR0xJR0VOQ0UgT1IgT1RIRVJXSVNFKSBBUklTSU5HIElOIEFOWSBXQVkgT1VUIE9GIFRIRSBVU0UgT0YgVEhJU1xyXG4gKiBTT0ZUV0FSRSwgRVZFTiBJRiBBRFZJU0VEIE9GIFRIRSBQT1NTSUJJTElUWSBPRiBTVUNIIERBTUFHRS5cclxuICovXHJcblxyXG51c2luZyBTeXN0ZW0uQ29sbGVjdGlvbnMuR2VuZXJpYztcclxudXNpbmcgUG9seTJUcmkuVHJpYW5ndWxhdGlvbi5EZWxhdW5heTtcclxuXHJcbm5hbWVzcGFjZSBQb2x5MlRyaS5Ucmlhbmd1bGF0aW9uLlNldHNcclxue1xyXG4gICAgcHVibGljIGNsYXNzIFBvaW50U2V0IDogVHJpYW5ndWxhdGFibGVcclxuICAgIHtcclxuICAgICAgICBwdWJsaWMgUG9pbnRTZXQoTGlzdDxUcmlhbmd1bGF0aW9uUG9pbnQ+IHBvaW50cylcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIFBvaW50cyA9IG5ldyBMaXN0PFRyaWFuZ3VsYXRpb25Qb2ludD4ocG9pbnRzKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgICNyZWdpb24gVHJpYW5ndWxhdGFibGUgTWVtYmVyc1xyXG5cclxuICAgICAgICBwdWJsaWMgSUxpc3Q8VHJpYW5ndWxhdGlvblBvaW50PiBQb2ludHMgeyBnZXQ7IHByaXZhdGUgc2V0OyB9XHJcbiAgICAgICAgcHVibGljIElMaXN0PERlbGF1bmF5VHJpYW5nbGU+IFRyaWFuZ2xlcyB7IGdldDsgcHJpdmF0ZSBzZXQ7IH1cclxuXHJcbiAgICAgICAgcHVibGljIHZpcnR1YWwgVHJpYW5ndWxhdGlvbk1vZGUgVHJpYW5ndWxhdGlvbk1vZGVcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGdldCB7IHJldHVybiBUcmlhbmd1bGF0aW9uTW9kZS5VbmNvbnN0cmFpbmVkOyB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwdWJsaWMgdm9pZCBBZGRUcmlhbmdsZShEZWxhdW5heVRyaWFuZ2xlIHQpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBUcmlhbmdsZXMuQWRkKHQpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHVibGljIHZvaWQgQWRkVHJpYW5nbGVzKElFbnVtZXJhYmxlPERlbGF1bmF5VHJpYW5nbGU+IGxpc3QpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBmb3JlYWNoIChEZWxhdW5heVRyaWFuZ2xlIHRyaSBpbiBsaXN0KSBUcmlhbmdsZXMuQWRkKHRyaSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwdWJsaWMgdm9pZCBDbGVhclRyaWFuZ2xlcygpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBUcmlhbmdsZXMuQ2xlYXIoKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHB1YmxpYyB2aXJ0dWFsIHZvaWQgUHJlcGFyZVRyaWFuZ3VsYXRpb24oVHJpYW5ndWxhdGlvbkNvbnRleHQgdGN4KVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgaWYgKFRyaWFuZ2xlcyA9PSBudWxsKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBUcmlhbmdsZXMgPSBuZXcgTGlzdDxEZWxhdW5heVRyaWFuZ2xlPihQb2ludHMuQ291bnQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgVHJpYW5nbGVzLkNsZWFyKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGN4LlBvaW50cy5BZGRSYW5nZShQb2ludHMpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgI2VuZHJlZ2lvblxyXG4gICAgfVxyXG59IiwidXNpbmcgU3lzdGVtO1xyXG51c2luZyBTeXN0ZW0uQ29sbGVjdGlvbnMuR2VuZXJpYztcclxudXNpbmcgRmFyc2VlclBoeXNpY3M7XHJcbnVzaW5nIEZhcnNlZXJQaHlzaWNzLkNvbGxpc2lvbjtcclxudXNpbmcgRmFyc2VlclBoeXNpY3MuRHluYW1pY3M7XHJcbnVzaW5nIE1pY3Jvc29mdC5YbmEuRnJhbWV3b3JrO1xyXG5cclxucHVibGljIGNsYXNzIFF1YWRUcmVlQnJvYWRQaGFzZSA6IElCcm9hZFBoYXNlXHJcbntcclxuICAgIHByaXZhdGUgY29uc3QgaW50IFRyZWVVcGRhdGVUaHJlc2ggPSAxMDAwMDtcclxuICAgIHByaXZhdGUgaW50IF9jdXJySUQ7XHJcbiAgICBwcml2YXRlIERpY3Rpb25hcnk8aW50LCBFbGVtZW50PEZpeHR1cmVQcm94eT4+IF9pZFJlZ2lzdGVyO1xyXG4gICAgcHJpdmF0ZSBMaXN0PEVsZW1lbnQ8Rml4dHVyZVByb3h5Pj4gX21vdmVCdWZmZXI7XHJcbiAgICBwcml2YXRlIExpc3Q8UGFpcj4gX3BhaXJCdWZmZXI7XHJcbiAgICBwcml2YXRlIFF1YWRUcmVlPEZpeHR1cmVQcm94eT4gX3F1YWRUcmVlO1xyXG4gICAgcHJpdmF0ZSBpbnQgX3RyZWVNb3ZlTnVtO1xyXG5cclxuICAgIC8vLyA8c3VtbWFyeT5cclxuICAgIC8vLyBDcmVhdGVzIGEgbmV3IHF1YWQgdHJlZSBicm9hZHBoYXNlIHdpdGggdGhlIHNwZWNpZmllZCBzcGFuLlxyXG4gICAgLy8vIDwvc3VtbWFyeT5cclxuICAgIC8vLyA8cGFyYW0gbmFtZT1cInNwYW5cIj50aGUgbWF4aW11bSBzcGFuIG9mIHRoZSB0cmVlICh3b3JsZCBzaXplKTwvcGFyYW0+XHJcbiAgICBwdWJsaWMgUXVhZFRyZWVCcm9hZFBoYXNlKEFBQkIgc3BhbilcclxuICAgIHtcclxuICAgICAgICBfcXVhZFRyZWUgPSBuZXcgUXVhZFRyZWU8Rml4dHVyZVByb3h5PihzcGFuLCA1LCAxMCk7XHJcbiAgICAgICAgX2lkUmVnaXN0ZXIgPSBuZXcgRGljdGlvbmFyeTxpbnQsIEVsZW1lbnQ8Rml4dHVyZVByb3h5Pj4oKTtcclxuICAgICAgICBfbW92ZUJ1ZmZlciA9IG5ldyBMaXN0PEVsZW1lbnQ8Rml4dHVyZVByb3h5Pj4oKTtcclxuICAgICAgICBfcGFpckJ1ZmZlciA9IG5ldyBMaXN0PFBhaXI+KCk7XHJcbiAgICB9XHJcblxyXG4gICAgI3JlZ2lvbiBJQnJvYWRQaGFzZSBNZW1iZXJzXHJcblxyXG4gICAgLy8vPHN1bW1hcnk+XHJcbiAgICAvLy8gVGhlIG51bWJlciBvZiBwcm94aWVzXHJcbiAgICAvLy88L3N1bW1hcnk+XHJcbiAgICBwdWJsaWMgaW50IFByb3h5Q291bnRcclxuICAgIHtcclxuICAgICAgICBnZXQgeyByZXR1cm4gX2lkUmVnaXN0ZXIuQ291bnQ7IH1cclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgdm9pZCBHZXRGYXRBQUJCKGludCBwcm94eUlELCBvdXQgQUFCQiBhYWJiKVxyXG4gICAge1xyXG4gICAgICAgIGlmIChfaWRSZWdpc3Rlci5Db250YWluc0tleShwcm94eUlEKSlcclxuICAgICAgICAgICAgYWFiYiA9IF9pZFJlZ2lzdGVyW3Byb3h5SURdLlNwYW47XHJcbiAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICB0aHJvdyBuZXcgS2V5Tm90Rm91bmRFeGNlcHRpb24oXCJwcm94eUlEIG5vdCBmb3VuZCBpbiByZWdpc3RlclwiKTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgdm9pZCBVcGRhdGVQYWlycyhCcm9hZHBoYXNlRGVsZWdhdGUgY2FsbGJhY2spXHJcbiAgICB7XHJcbiAgICAgICAgX3BhaXJCdWZmZXIuQ2xlYXIoKTtcclxuICAgICAgICBmb3JlYWNoIChFbGVtZW50PEZpeHR1cmVQcm94eT4gcXRub2RlIGluIF9tb3ZlQnVmZmVyKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgLy8gUXVlcnkgdHJlZSwgY3JlYXRlIHBhaXJzIGFuZCBhZGQgdGhlbSBwYWlyIGJ1ZmZlci5cclxuICAgICAgICAgICAgUXVlcnkoKGdsb2JhbDo6U3lzdGVtLkZ1bmM8aW50LCBib29sPikocHJveHlJRCA9PiBQYWlyQnVmZmVyUXVlcnlDYWxsYmFjayhwcm94eUlELCBxdG5vZGUuVmFsdWUuUHJveHlJZCkpLCByZWYgcXRub2RlLlNwYW4pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBfbW92ZUJ1ZmZlci5DbGVhcigpO1xyXG5cclxuICAgICAgICAvLyBTb3J0IHRoZSBwYWlyIGJ1ZmZlciB0byBleHBvc2UgZHVwbGljYXRlcy5cclxuICAgICAgICBfcGFpckJ1ZmZlci5Tb3J0KCk7XHJcblxyXG4gICAgICAgIC8vIFNlbmQgdGhlIHBhaXJzIGJhY2sgdG8gdGhlIGNsaWVudC5cclxuICAgICAgICBpbnQgaSA9IDA7XHJcbiAgICAgICAgd2hpbGUgKGkgPCBfcGFpckJ1ZmZlci5Db3VudClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIFBhaXIgcHJpbWFyeVBhaXIgPSBfcGFpckJ1ZmZlcltpXTtcclxuICAgICAgICAgICAgRml4dHVyZVByb3h5IHVzZXJEYXRhQSA9IEdldFByb3h5KHByaW1hcnlQYWlyLlByb3h5SWRBKTtcclxuICAgICAgICAgICAgRml4dHVyZVByb3h5IHVzZXJEYXRhQiA9IEdldFByb3h5KHByaW1hcnlQYWlyLlByb3h5SWRCKTtcclxuXHJcbiAgICAgICAgICAgIGNhbGxiYWNrKHJlZiB1c2VyRGF0YUEsIHJlZiB1c2VyRGF0YUIpO1xyXG4gICAgICAgICAgICArK2k7XHJcblxyXG4gICAgICAgICAgICAvLyBTa2lwIGFueSBkdXBsaWNhdGUgcGFpcnMuXHJcbiAgICAgICAgICAgIHdoaWxlIChpIDwgX3BhaXJCdWZmZXIuQ291bnQgJiYgX3BhaXJCdWZmZXJbaV0uUHJveHlJZEEgPT0gcHJpbWFyeVBhaXIuUHJveHlJZEEgJiZcclxuICAgICAgICAgICAgICAgICAgIF9wYWlyQnVmZmVyW2ldLlByb3h5SWRCID09IHByaW1hcnlQYWlyLlByb3h5SWRCKVxyXG4gICAgICAgICAgICAgICAgKytpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAvLy8gVGVzdCBvdmVybGFwIG9mIGZhdCBBQUJCcy5cclxuICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAvLy8gPHBhcmFtIG5hbWU9XCJwcm94eUlkQVwiPlRoZSBwcm94eSBpZCBBLjwvcGFyYW0+XHJcbiAgICAvLy8gPHBhcmFtIG5hbWU9XCJwcm94eUlkQlwiPlRoZSBwcm94eSBpZCBCLjwvcGFyYW0+XHJcbiAgICAvLy8gPHJldHVybnM+PC9yZXR1cm5zPlxyXG4gICAgcHVibGljIGJvb2wgVGVzdE92ZXJsYXAoaW50IHByb3h5SWRBLCBpbnQgcHJveHlJZEIpXHJcbiAgICB7XHJcbiAgICAgICAgQUFCQiBhYWJiMTtcclxuICAgICAgICBBQUJCIGFhYmIyO1xyXG4gICAgICAgIEdldEZhdEFBQkIocHJveHlJZEEsIG91dCBhYWJiMSk7XHJcbiAgICAgICAgR2V0RmF0QUFCQihwcm94eUlkQiwgb3V0IGFhYmIyKTtcclxuICAgICAgICByZXR1cm4gQUFCQi5UZXN0T3ZlcmxhcChyZWYgYWFiYjEsIHJlZiBhYWJiMik7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGludCBBZGRQcm94eShyZWYgRml4dHVyZVByb3h5IHByb3h5KVxyXG4gICAge1xyXG4gICAgICAgIGludCBwcm94eUlEID0gX2N1cnJJRCsrO1xyXG4gICAgICAgIHByb3h5LlByb3h5SWQgPSBwcm94eUlEO1xyXG4gICAgICAgIEFBQkIgYWFiYiA9IEZhdHRlbihyZWYgcHJveHkuQUFCQik7XHJcbiAgICAgICAgRWxlbWVudDxGaXh0dXJlUHJveHk+IHF0bm9kZSA9IG5ldyBFbGVtZW50PEZpeHR1cmVQcm94eT4ocHJveHksIGFhYmIpO1xyXG5cclxuICAgICAgICBfaWRSZWdpc3Rlci5BZGQocHJveHlJRCwgcXRub2RlKTtcclxuICAgICAgICBfcXVhZFRyZWUuQWRkTm9kZShxdG5vZGUpO1xyXG5cclxuICAgICAgICByZXR1cm4gcHJveHlJRDtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgdm9pZCBSZW1vdmVQcm94eShpbnQgcHJveHlJZClcclxuICAgIHtcclxuICAgICAgICBpZiAoX2lkUmVnaXN0ZXIuQ29udGFpbnNLZXkocHJveHlJZCkpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBFbGVtZW50PEZpeHR1cmVQcm94eT4gcXRub2RlID0gX2lkUmVnaXN0ZXJbcHJveHlJZF07XHJcbiAgICAgICAgICAgIFVuYnVmZmVyTW92ZShxdG5vZGUpO1xyXG4gICAgICAgICAgICBfaWRSZWdpc3Rlci5SZW1vdmUocHJveHlJZCk7XHJcbiAgICAgICAgICAgIF9xdWFkVHJlZS5SZW1vdmVOb2RlKHF0bm9kZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2VcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEtleU5vdEZvdW5kRXhjZXB0aW9uKFwicHJveHlJRCBub3QgZm91bmQgaW4gcmVnaXN0ZXJcIik7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIHZvaWQgTW92ZVByb3h5KGludCBwcm94eUlkLCByZWYgQUFCQiBhYWJiLCBWZWN0b3IyIGRpc3BsYWNlbWVudClcclxuICAgIHtcclxuICAgICAgICBBQUJCIGZhdEFBQkI7XHJcbiAgICAgICAgR2V0RmF0QUFCQihwcm94eUlkLCBvdXQgZmF0QUFCQik7XHJcblxyXG4gICAgICAgIC8vZXhpdCBpZiBtb3ZlbWVudCBpcyB3aXRoaW4gZmF0IGFhYmJcclxuICAgICAgICBpZiAoZmF0QUFCQi5Db250YWlucyhyZWYgYWFiYikpXHJcbiAgICAgICAgICAgIHJldHVybjtcclxuXHJcbiAgICAgICAgLy8gRXh0ZW5kIEFBQkIuXHJcbiAgICAgICAgQUFCQiBiID0gYWFiYjtcclxuICAgICAgICBWZWN0b3IyIHIgPSBuZXcgVmVjdG9yMihTZXR0aW5ncy5BQUJCRXh0ZW5zaW9uLCBTZXR0aW5ncy5BQUJCRXh0ZW5zaW9uKTtcclxuICAgICAgICBiLkxvd2VyQm91bmQgPSBiLkxvd2VyQm91bmQgLSByO1xyXG4gICAgICAgIGIuVXBwZXJCb3VuZCA9IGIuVXBwZXJCb3VuZCArIHI7XHJcblxyXG4gICAgICAgIC8vIFByZWRpY3QgQUFCQiBkaXNwbGFjZW1lbnQuXHJcbiAgICAgICAgVmVjdG9yMiBkID0gU2V0dGluZ3MuQUFCQk11bHRpcGxpZXIgKiBkaXNwbGFjZW1lbnQ7XHJcblxyXG4gICAgICAgIGlmIChkLlggPCAwLjBmKVxyXG4gICAgICAgICAgICBiLkxvd2VyQm91bmQuWCArPSBkLlg7XHJcbiAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICBiLlVwcGVyQm91bmQuWCArPSBkLlg7XHJcblxyXG4gICAgICAgIGlmIChkLlkgPCAwLjBmKVxyXG4gICAgICAgICAgICBiLkxvd2VyQm91bmQuWSArPSBkLlk7XHJcbiAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICBiLlVwcGVyQm91bmQuWSArPSBkLlk7XHJcblxyXG5cclxuICAgICAgICBFbGVtZW50PEZpeHR1cmVQcm94eT4gcXRub2RlID0gX2lkUmVnaXN0ZXJbcHJveHlJZF07XHJcbiAgICAgICAgcXRub2RlLlZhbHVlLkFBQkIgPSBiOyAvL25vdCBuZWNjZXNhcnkgZm9yIFFUcmVlLCBidXQgbWlnaHQgYmUgYWNjZXNzZWQgZXh0ZXJuYWxseVxyXG4gICAgICAgIHF0bm9kZS5TcGFuID0gYjtcclxuXHJcbiAgICAgICAgUmVpbnNlcnROb2RlKHF0bm9kZSk7XHJcblxyXG4gICAgICAgIEJ1ZmZlck1vdmUocXRub2RlKTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgRml4dHVyZVByb3h5IEdldFByb3h5KGludCBwcm94eUlkKVxyXG4gICAge1xyXG4gICAgICAgIGlmIChfaWRSZWdpc3Rlci5Db250YWluc0tleShwcm94eUlkKSlcclxuICAgICAgICAgICAgcmV0dXJuIF9pZFJlZ2lzdGVyW3Byb3h5SWRdLlZhbHVlO1xyXG4gICAgICAgIGVsc2VcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEtleU5vdEZvdW5kRXhjZXB0aW9uKFwicHJveHlJRCBub3QgZm91bmQgaW4gcmVnaXN0ZXJcIik7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIHZvaWQgVG91Y2hQcm94eShpbnQgcHJveHlJZClcclxuICAgIHtcclxuICAgICAgICBpZiAoX2lkUmVnaXN0ZXIuQ29udGFpbnNLZXkocHJveHlJZCkpXHJcbiAgICAgICAgICAgIEJ1ZmZlck1vdmUoX2lkUmVnaXN0ZXJbcHJveHlJZF0pO1xyXG4gICAgICAgIGVsc2VcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEtleU5vdEZvdW5kRXhjZXB0aW9uKFwicHJveHlJRCBub3QgZm91bmQgaW4gcmVnaXN0ZXJcIik7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIHZvaWQgUXVlcnkoRnVuYzxpbnQsIGJvb2w+IGNhbGxiYWNrLCByZWYgQUFCQiBxdWVyeSlcclxuICAgIHtcclxuICAgICAgICBfcXVhZFRyZWUuUXVlcnlBQUJCKChnbG9iYWw6OlN5c3RlbS5GdW5jPGdsb2JhbDo6RWxlbWVudDxnbG9iYWw6OkZhcnNlZXJQaHlzaWNzLkR5bmFtaWNzLkZpeHR1cmVQcm94eT4sIGJvb2w+KVRyYW5zZm9ybVByZWRpY2F0ZSgoZ2xvYmFsOjpTeXN0ZW0uRnVuYzxpbnQsIGJvb2w+KWNhbGxiYWNrKSwgcmVmIHF1ZXJ5KTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgdm9pZCBSYXlDYXN0KEZ1bmM8UmF5Q2FzdElucHV0LCBpbnQsIGZsb2F0PiBjYWxsYmFjaywgcmVmIFJheUNhc3RJbnB1dCBpbnB1dClcclxuICAgIHtcclxuICAgICAgICBfcXVhZFRyZWUuUmF5Q2FzdCgoZ2xvYmFsOjpTeXN0ZW0uRnVuYzxnbG9iYWw6OkZhcnNlZXJQaHlzaWNzLkNvbGxpc2lvbi5SYXlDYXN0SW5wdXQsIGdsb2JhbDo6RWxlbWVudDxnbG9iYWw6OkZhcnNlZXJQaHlzaWNzLkR5bmFtaWNzLkZpeHR1cmVQcm94eT4sIGZsb2F0PilUcmFuc2Zvcm1SYXlDYWxsYmFjaygoZ2xvYmFsOjpTeXN0ZW0uRnVuYzxnbG9iYWw6OkZhcnNlZXJQaHlzaWNzLkNvbGxpc2lvbi5SYXlDYXN0SW5wdXQsIGludCwgZmxvYXQ+KWNhbGxiYWNrKSwgcmVmIGlucHV0KTtcclxuICAgIH1cclxuXHJcbiAgICAjZW5kcmVnaW9uXHJcblxyXG4gICAgcHJpdmF0ZSBBQUJCIEZhdHRlbihyZWYgQUFCQiBhYWJiKVxyXG4gICAge1xyXG4gICAgICAgIFZlY3RvcjIgciA9IG5ldyBWZWN0b3IyKFNldHRpbmdzLkFBQkJFeHRlbnNpb24sIFNldHRpbmdzLkFBQkJFeHRlbnNpb24pO1xyXG4gICAgICAgIHJldHVybiBuZXcgQUFCQihhYWJiLkxvd2VyQm91bmQgLSByLCBhYWJiLlVwcGVyQm91bmQgKyByKTtcclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIEZ1bmM8RWxlbWVudDxGaXh0dXJlUHJveHk+LCBib29sPiBUcmFuc2Zvcm1QcmVkaWNhdGUoRnVuYzxpbnQsIGJvb2w+IGlkUHJlZGljYXRlKVxyXG4gICAge1xyXG4gICAgICAgIEZ1bmM8RWxlbWVudDxGaXh0dXJlUHJveHk+LCBib29sPiBxdFByZWQgPSBxdG5vZGUgPT4gaWRQcmVkaWNhdGUocXRub2RlLlZhbHVlLlByb3h5SWQpO1xyXG4gICAgICAgIHJldHVybiBxdFByZWQ7XHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSBGdW5jPFJheUNhc3RJbnB1dCwgRWxlbWVudDxGaXh0dXJlUHJveHk+LCBmbG9hdD4gVHJhbnNmb3JtUmF5Q2FsbGJhY2soXHJcbiAgICAgICAgRnVuYzxSYXlDYXN0SW5wdXQsIGludCwgZmxvYXQ+IGNhbGxiYWNrKVxyXG4gICAge1xyXG4gICAgICAgIEZ1bmM8UmF5Q2FzdElucHV0LCBFbGVtZW50PEZpeHR1cmVQcm94eT4sIGZsb2F0PiBuZXdDYWxsYmFjayA9XHJcbiAgICAgICAgICAgIChpbnB1dCwgcXRub2RlKSA9PiBjYWxsYmFjayhpbnB1dCwgcXRub2RlLlZhbHVlLlByb3h5SWQpO1xyXG4gICAgICAgIHJldHVybiBuZXdDYWxsYmFjaztcclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIGJvb2wgUGFpckJ1ZmZlclF1ZXJ5Q2FsbGJhY2soaW50IHByb3h5SUQsIGludCBiYXNlSUQpXHJcbiAgICB7XHJcbiAgICAgICAgLy8gQSBwcm94eSBjYW5ub3QgZm9ybSBhIHBhaXIgd2l0aCBpdHNlbGYuXHJcbiAgICAgICAgaWYgKHByb3h5SUQgPT0gYmFzZUlEKVxyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuXHJcbiAgICAgICAgUGFpciBwID0gbmV3IFBhaXIoKTtcclxuICAgICAgICBwLlByb3h5SWRBID0gTWF0aC5NaW4ocHJveHlJRCwgYmFzZUlEKTtcclxuICAgICAgICBwLlByb3h5SWRCID0gTWF0aC5NYXgocHJveHlJRCwgYmFzZUlEKTtcclxuICAgICAgICBfcGFpckJ1ZmZlci5BZGQocCk7XHJcblxyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgdm9pZCBSZWNvbnN0cnVjdFRyZWUoKVxyXG4gICAge1xyXG4gICAgICAgIC8vdGhpcyBpcyBmYXN0ZXIgdGhhbiBfcXVhZFRyZWUuUmVjb25zdHJ1Y3QoKSwgc2luY2UgdGhlIHF1YWR0cmVlIG1ldGhvZCBydW5zIGEgcmVjdXNpdmUgcXVlcnkgdG8gZmluZCBhbGwgbm9kZXMuXHJcbiAgICAgICAgX3F1YWRUcmVlLkNsZWFyKCk7XHJcbiAgICAgICAgZm9yZWFjaCAoRWxlbWVudDxGaXh0dXJlUHJveHk+IGVsZW0gaW4gX2lkUmVnaXN0ZXIuVmFsdWVzKVxyXG4gICAgICAgICAgICBfcXVhZFRyZWUuQWRkTm9kZShlbGVtKTtcclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIHZvaWQgUmVpbnNlcnROb2RlKEVsZW1lbnQ8Rml4dHVyZVByb3h5PiBxdG5vZGUpXHJcbiAgICB7XHJcbiAgICAgICAgX3F1YWRUcmVlLlJlbW92ZU5vZGUocXRub2RlKTtcclxuICAgICAgICBfcXVhZFRyZWUuQWRkTm9kZShxdG5vZGUpO1xyXG5cclxuICAgICAgICBpZiAoKytfdHJlZU1vdmVOdW0gPiBUcmVlVXBkYXRlVGhyZXNoKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgUmVjb25zdHJ1Y3RUcmVlKCk7XHJcbiAgICAgICAgICAgIF90cmVlTW92ZU51bSA9IDA7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgdm9pZCBCdWZmZXJNb3ZlKEVsZW1lbnQ8Rml4dHVyZVByb3h5PiBwcm94eSlcclxuICAgIHtcclxuICAgICAgICBfbW92ZUJ1ZmZlci5BZGQocHJveHkpO1xyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgdm9pZCBVbmJ1ZmZlck1vdmUoRWxlbWVudDxGaXh0dXJlUHJveHk+IHByb3h5KVxyXG4gICAge1xyXG4gICAgICAgIF9tb3ZlQnVmZmVyLlJlbW92ZShwcm94eSk7XHJcbiAgICB9XHJcbn0iLCJ1c2luZyBTeXN0ZW07XHJcbnVzaW5nIEZhcnNlZXJQaHlzaWNzLkR5bmFtaWNzO1xyXG51c2luZyBNaWNyb3NvZnQuWG5hLkZyYW1ld29yaztcclxuXHJcbm5hbWVzcGFjZSBGYXJzZWVyUGh5c2ljcy5Db250cm9sbGVyc1xyXG57XHJcbiAgICBwdWJsaWMgYWJzdHJhY3QgY2xhc3MgQWJzdHJhY3RGb3JjZUNvbnRyb2xsZXIgOiBDb250cm9sbGVyXHJcbiAgICB7XHJcbiAgICAgICAgI3JlZ2lvbiBEZWNheU1vZGVzIGVudW1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBNb2RlcyBmb3IgRGVjYXkuIEFjdHVhbCBEZWNheSBtdXN0IGJlIGltcGxlbWVudGVkIGluIGluaGVyaXRpbmcgXHJcbiAgICAgICAgLy8vIGNsYXNzZXNcclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIHB1YmxpYyBlbnVtIERlY2F5TW9kZXNcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIE5vbmUsXHJcbiAgICAgICAgICAgIFN0ZXAsXHJcbiAgICAgICAgICAgIExpbmVhcixcclxuICAgICAgICAgICAgSW52ZXJzZVNxdWFyZSxcclxuICAgICAgICAgICAgQ3VydmVcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgICNlbmRyZWdpb25cclxuXHJcbiAgICAgICAgI3JlZ2lvbiBGb3JjZVR5cGVzIGVudW1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBGb3JjZXR5cGVzIGFyZSB1c2VkIGluIHRoZSBkZWNheSBtYXRoIHRvIHByb3Blcmx5IGdldCB0aGUgZGlzdGFuY2UuXHJcbiAgICAgICAgLy8vIFRoZXkgYXJlIGFsc28gdXNlZCB0byBkcmF3IGEgcmVwcmVzZW50YXRpb24gaW4gRGVidWdWaWV3XHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICBwdWJsaWMgZW51bSBGb3JjZVR5cGVzXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBQb2ludCxcclxuICAgICAgICAgICAgTGluZSxcclxuICAgICAgICAgICAgQXJlYVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgI2VuZHJlZ2lvblxyXG5cclxuICAgICAgICAjcmVnaW9uIFRpbWluZ01vZGVzIGVudW1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBUaW1pbmcgTW9kZXNcclxuICAgICAgICAvLy8gU3dpdGNoZWQ6IFN0YW5kYXJkIG9uL29mZiBtb2RlIHVzaW5nIHRoZSBiYXNlY2xhc3MgZW5hYmxlZCBwcm9wZXJ0eVxyXG4gICAgICAgIC8vLyBUcmlnZ2VyZWQ6IFdoZW4gdGhlIFRyaWdnZXIoKSBtZXRob2QgaXMgY2FsbGVkIHRoZSBmb3JjZSBpcyBhY3RpdmUgXHJcbiAgICAgICAgLy8vIGZvciBhIHNwZWNpZmllZCBJbXB1bHNlIExlbmd0aFxyXG4gICAgICAgIC8vLyBDdXJ2ZTogU3RpbGwgdG8gYmUgZGVmaW5lZC4gVGhlIGJhc2ljIGlkZWEgaXMgaGF2aW5nIGEgVHJpZ2dlciBcclxuICAgICAgICAvLy8gY29tYmluZWQgd2l0aCBhIGN1cnZlIGZvciB0aGUgc3RyZW5ndGhcclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIHB1YmxpYyBlbnVtIFRpbWluZ01vZGVzXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBTd2l0Y2hlZCxcclxuICAgICAgICAgICAgVHJpZ2dlcmVkLFxyXG4gICAgICAgICAgICBDdXJ2ZVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgI2VuZHJlZ2lvblxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIEN1cnZlIHRvIGJlIHVzZWQgZm9yIERlY2F5IGluIEN1cnZlIG1vZGVcclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIHB1YmxpYyBDdXJ2ZSBEZWNheUN1cnZlO1xyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIFRoZSBGb3JjZXR5cGUgb2YgdGhlIGluc3RhbmNlXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICBwdWJsaWMgRm9yY2VUeXBlcyBGb3JjZVR5cGU7XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gUHJvdmlkZWQgZm9yIHJldXNlIHRvIHByb3ZpZGUgVmFyaWF0aW9uIGZ1bmN0aW9uYWxpdHkgaW4gXHJcbiAgICAgICAgLy8vIGluaGVyaXRpbmcgY2xhc3Nlc1xyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgcHJvdGVjdGVkIFJhbmRvbSBSYW5kb21pemU7XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gQ3VydmUgdXNlZCBieSBDdXJ2ZSBNb2RlIGFzIGFuIGFuaW1hdGVkIG11bHRpcGxpZXIgZm9yIHRoZSBmb3JjZSBcclxuICAgICAgICAvLy8gc3RyZW5ndGguXHJcbiAgICAgICAgLy8vIE9ubHkgcG9zaXRpb25zIGJldHdlZW4gMCBhbmQgMSBhcmUgY29uc2lkZXJlZCBhcyB0aGF0IHJhbmdlIGlzIFxyXG4gICAgICAgIC8vLyBzdHJldGNoZWQgdG8gaGF2ZSBJbXB1bHNlTGVuZ3RoLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgcHVibGljIEN1cnZlIFN0cmVuZ3RoQ3VydmU7XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gQ29uc3RydWN0b3JcclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIHB1YmxpYyBBYnN0cmFjdEZvcmNlQ29udHJvbGxlcigpXHJcbiAgICAgICAgICAgIDogYmFzZShDb250cm9sbGVyVHlwZS5BYnN0cmFjdEZvcmNlQ29udHJvbGxlcilcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIEVuYWJsZWQgPSB0cnVlO1xyXG5cclxuICAgICAgICAgICAgU3RyZW5ndGggPSAxLjBmO1xyXG4gICAgICAgICAgICBQb3NpdGlvbiA9IG5ldyBWZWN0b3IyKDAsIDApO1xyXG4gICAgICAgICAgICBNYXhpbXVtU3BlZWQgPSAxMDAuMGY7XHJcbiAgICAgICAgICAgIFRpbWluZ01vZGUgPSBUaW1pbmdNb2Rlcy5Td2l0Y2hlZDtcclxuICAgICAgICAgICAgSW1wdWxzZVRpbWUgPSAwLjBmO1xyXG4gICAgICAgICAgICBJbXB1bHNlTGVuZ3RoID0gMS4wZjtcclxuICAgICAgICAgICAgVHJpZ2dlcmVkID0gZmFsc2U7XHJcbiAgICAgICAgICAgIFN0cmVuZ3RoQ3VydmUgPSBuZXcgQ3VydmUoKTtcclxuICAgICAgICAgICAgVmFyaWF0aW9uID0gMC4wZjtcclxuICAgICAgICAgICAgUmFuZG9taXplID0gbmV3IFJhbmRvbSgxMjM0KTtcclxuICAgICAgICAgICAgRGVjYXlNb2RlID0gRGVjYXlNb2Rlcy5Ob25lO1xyXG4gICAgICAgICAgICBEZWNheUN1cnZlID0gbmV3IEN1cnZlKCk7XHJcbiAgICAgICAgICAgIERlY2F5U3RhcnQgPSAwLjBmO1xyXG4gICAgICAgICAgICBEZWNheUVuZCA9IDAuMGY7XHJcblxyXG4gICAgICAgICAgICBTdHJlbmd0aEN1cnZlLktleXMuQWRkKG5ldyBDdXJ2ZUtleSgwLCA1KSk7XHJcbiAgICAgICAgICAgIFN0cmVuZ3RoQ3VydmUuS2V5cy5BZGQobmV3IEN1cnZlS2V5KDAuMWYsIDUpKTtcclxuICAgICAgICAgICAgU3RyZW5ndGhDdXJ2ZS5LZXlzLkFkZChuZXcgQ3VydmVLZXkoMC4yZiwgLTQpKTtcclxuICAgICAgICAgICAgU3RyZW5ndGhDdXJ2ZS5LZXlzLkFkZChuZXcgQ3VydmVLZXkoMWYsIDApKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gT3ZlcmxvYWRlZCBDb250c3RydWN0b3Igd2l0aCBzdXBwbHlpbmcgVGltaW5nIE1vZGVcclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cIm1vZGVcIj48L3BhcmFtPlxyXG4gICAgICAgIHB1YmxpYyBBYnN0cmFjdEZvcmNlQ29udHJvbGxlcihUaW1pbmdNb2RlcyBtb2RlKVxyXG4gICAgICAgICAgICA6IGJhc2UoQ29udHJvbGxlclR5cGUuQWJzdHJhY3RGb3JjZUNvbnRyb2xsZXIpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBUaW1pbmdNb2RlID0gbW9kZTtcclxuICAgICAgICAgICAgc3dpdGNoIChtb2RlKVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBjYXNlIFRpbWluZ01vZGVzLlN3aXRjaGVkOlxyXG4gICAgICAgICAgICAgICAgICAgIEVuYWJsZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSBUaW1pbmdNb2Rlcy5UcmlnZ2VyZWQ6XHJcbiAgICAgICAgICAgICAgICAgICAgRW5hYmxlZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSBUaW1pbmdNb2Rlcy5DdXJ2ZTpcclxuICAgICAgICAgICAgICAgICAgICBFbmFibGVkID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gR2xvYmFsIFN0cmVuZ3RoIG9mIHRoZSBmb3JjZSB0byBiZSBhcHBsaWVkXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICBwdWJsaWMgZmxvYXQgU3RyZW5ndGggeyBnZXQ7IHNldDsgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIFBvc2l0aW9uIG9mIHRoZSBGb3JjZS4gQ2FuIGJlIGlnbm9yZWQgKGxlZnQgYXQgKDAsMCkgZm9yIGZvcmNlc1xyXG4gICAgICAgIC8vLyB0aGF0IGFyZSBub3QgcG9zaXRpb24tZGVwZW5kZW50XHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICBwdWJsaWMgVmVjdG9yMiBQb3NpdGlvbiB7IGdldDsgc2V0OyB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gTWF4aW11bSBzcGVlZCBvZiB0aGUgYm9kaWVzLiBCb2RpZXMgdGhhdCBhcmUgdHJhdmVsbGluZyBmYXN0ZXIgYXJlXHJcbiAgICAgICAgLy8vIHN1cHBvc2VkIHRvIGJlIGlnbm9yZWRcclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIHB1YmxpYyBmbG9hdCBNYXhpbXVtU3BlZWQgeyBnZXQ7IHNldDsgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIE1heGltdW0gRm9yY2UgdG8gYmUgYXBwbGllZC4gQXMgb3Bwb3NlZCB0byBNYXhpbXVtIFNwZWVkIHRoaXMgaXMgXHJcbiAgICAgICAgLy8vIGluZGVwZW5kZW50IG9mIHRoZSB2ZWxvY2l0eSBvZlxyXG4gICAgICAgIC8vLyB0aGUgYWZmZWN0ZWQgYm9keVxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgcHVibGljIGZsb2F0IE1heGltdW1Gb3JjZSB7IGdldDsgc2V0OyB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gVGltaW5nIE1vZGUgb2YgdGhlIGZvcmNlIGluc3RhbmNlXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICBwdWJsaWMgVGltaW5nTW9kZXMgVGltaW5nTW9kZSB7IGdldDsgc2V0OyB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gVGltZSBvZiB0aGUgY3VycmVudCBpbXB1bHNlLiBJbmNyZW1lbnRlZCBpbiB1cGRhdGUgdGlsbCBcclxuICAgICAgICAvLy8gSW1wdWxzZUxlbmd0aCBpcyByZWFjaGVkXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICBwdWJsaWMgZmxvYXQgSW1wdWxzZVRpbWUgeyBnZXQ7IHByaXZhdGUgc2V0OyB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gTGVuZ3RoIG9mIGEgdHJpZ2dlcmVkIGltcHVsc2UuIFVzZWQgaW4gYm90aCBUcmlnZ2VyZWQgYW5kIEN1cnZlIE1vZGVcclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIHB1YmxpYyBmbG9hdCBJbXB1bHNlTGVuZ3RoIHsgZ2V0OyBzZXQ7IH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBJbmRpY2F0aW5nIGlmIHdlIGFyZSBjdXJyZW50bHkgZHVyaW5nIGFuIEltcHVsc2UgXHJcbiAgICAgICAgLy8vIChUcmlnZ2VyZWQgYW5kIEN1cnZlIE1vZGUpXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICBwdWJsaWMgYm9vbCBUcmlnZ2VyZWQgeyBnZXQ7IHByaXZhdGUgc2V0OyB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gVmFyaWF0aW9uIG9mIHRoZSBmb3JjZSBhcHBsaWVkIHRvIGVhY2ggYm9keSBhZmZlY3RlZFxyXG4gICAgICAgIC8vLyAhISBNdXN0IGJlIHVzZWQgaW4gaW5oZXJpdGluZyBjbGFzc2VzIHByb3Blcmx5ICEhXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICBwdWJsaWMgZmxvYXQgVmFyaWF0aW9uIHsgZ2V0OyBzZXQ7IH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBTZWUgRGVjYXlNb2Rlc1xyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgcHVibGljIERlY2F5TW9kZXMgRGVjYXlNb2RlIHsgZ2V0OyBzZXQ7IH1cclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBTdGFydCBvZiB0aGUgZGlzdGFuY2UgYmFzZWQgRGVjYXkuIFRvIHNldCBhIG5vbiBkZWNheWluZyBhcmVhXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICBwdWJsaWMgZmxvYXQgRGVjYXlTdGFydCB7IGdldDsgc2V0OyB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gTWF4aW11bSBkaXN0YW5jZSBhIGZvcmNlIHNob3VsZCBiZSBhcHBsaWVkXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICBwdWJsaWMgZmxvYXQgRGVjYXlFbmQgeyBnZXQ7IHNldDsgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIENhbGN1bGF0ZSB0aGUgRGVjYXkgZm9yIGEgZ2l2ZW4gYm9keS4gTWVhbnQgdG8gZWFzZSBmb3JjZSBcclxuICAgICAgICAvLy8gZGV2ZWxvcG1lbnQgYW5kIHN0aWNrIHRvIHRoZSBEUlkgcHJpbmNpcGxlIGFuZCBwcm92aWRlIHVuaWZpZWQgYW5kIFxyXG4gICAgICAgIC8vLyBwcmVkaWN0YWJsZSBkZWNheSBtYXRoLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwiYm9keVwiPlRoZSBib2R5IHRvIGNhbGN1bGF0ZSBkZWNheSBmb3I8L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cmV0dXJucz5BIG11bHRpcGxpZXIgdG8gbXVsdGlwbHkgdGhlIGZvcmNlIHdpdGggdG8gYWRkIGRlY2F5IFxyXG4gICAgICAgIC8vLyBzdXBwb3J0IGluIGluaGVyaXRpbmcgY2xhc3NlczwvcmV0dXJucz5cclxuICAgICAgICBwcm90ZWN0ZWQgZmxvYXQgR2V0RGVjYXlNdWx0aXBsaWVyKEJvZHkgYm9keSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIC8vVE9ETzogQ29uc2lkZXIgRm9yY2VUeXBlIGluIGRpc3RhbmNlIGNhbGN1bGF0aW9uIVxyXG4gICAgICAgICAgICBmbG9hdCBkaXN0YW5jZSA9IChib2R5LlBvc2l0aW9uIC0gUG9zaXRpb24pLkxlbmd0aCgpO1xyXG4gICAgICAgICAgICBzd2l0Y2ggKERlY2F5TW9kZSlcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgY2FzZSBEZWNheU1vZGVzLk5vbmU6XHJcbiAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gMS4wZjtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBjYXNlIERlY2F5TW9kZXMuU3RlcDpcclxuICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkaXN0YW5jZSA8IERlY2F5RW5kKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDEuMGY7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAwLjBmO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGNhc2UgRGVjYXlNb2Rlcy5MaW5lYXI6XHJcbiAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZGlzdGFuY2UgPCBEZWNheVN0YXJ0KVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDEuMGY7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkaXN0YW5jZSA+IERlY2F5RW5kKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDAuMGY7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAoRGVjYXlFbmQgLSBEZWNheVN0YXJ0IC8gZGlzdGFuY2UgLSBEZWNheVN0YXJ0KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBjYXNlIERlY2F5TW9kZXMuSW52ZXJzZVNxdWFyZTpcclxuICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkaXN0YW5jZSA8IERlY2F5U3RhcnQpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gMS4wZjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDEuMGYgLyAoKGRpc3RhbmNlIC0gRGVjYXlTdGFydCkgKiAoZGlzdGFuY2UgLSBEZWNheVN0YXJ0KSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgY2FzZSBEZWNheU1vZGVzLkN1cnZlOlxyXG4gICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRpc3RhbmNlIDwgRGVjYXlTdGFydClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAxLjBmO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gRGVjYXlDdXJ2ZS5FdmFsdWF0ZShkaXN0YW5jZSAtIERlY2F5U3RhcnQpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDEuMGY7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gVHJpZ2dlcnMgdGhlIHRyaWdnZXIgbW9kZXMgKFRyaWdnZXIgYW5kIEN1cnZlKVxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgcHVibGljIHZvaWQgVHJpZ2dlcigpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBUcmlnZ2VyZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICBJbXB1bHNlVGltZSA9IDA7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIEluaGVyaXRlZCBmcm9tIENvbnRyb2xsZXJcclxuICAgICAgICAvLy8gRGVwZW5kaW5nIG9uIHRoZSBUaW1pbmdNb2RlIHBlcmZvcm0gdGltaW5nIGxvZ2ljIGFuZCBjYWxsIEFwcGx5Rm9yY2UoKVxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwiZHRcIj48L3BhcmFtPlxyXG4gICAgICAgIHB1YmxpYyBvdmVycmlkZSB2b2lkIFVwZGF0ZShmbG9hdCBkdClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHN3aXRjaCAoVGltaW5nTW9kZSlcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgY2FzZSBUaW1pbmdNb2Rlcy5Td2l0Y2hlZDpcclxuICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChFbmFibGVkKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBBcHBseUZvcmNlKGR0LCBTdHJlbmd0aCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgY2FzZSBUaW1pbmdNb2Rlcy5UcmlnZ2VyZWQ6XHJcbiAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoRW5hYmxlZCAmJiBUcmlnZ2VyZWQpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChJbXB1bHNlVGltZSA8IEltcHVsc2VMZW5ndGgpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgQXBwbHlGb3JjZShkdCwgU3RyZW5ndGgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEltcHVsc2VUaW1lICs9IGR0O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFRyaWdnZXJlZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGNhc2UgVGltaW5nTW9kZXMuQ3VydmU6XHJcbiAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoRW5hYmxlZCAmJiBUcmlnZ2VyZWQpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChJbXB1bHNlVGltZSA8IEltcHVsc2VMZW5ndGgpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgQXBwbHlGb3JjZShkdCwgU3RyZW5ndGggKiBTdHJlbmd0aEN1cnZlLkV2YWx1YXRlKEltcHVsc2VUaW1lKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgSW1wdWxzZVRpbWUgKz0gZHQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgVHJpZ2dlcmVkID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIEFwcGx5IHRoZSBmb3JjZSBzdXBwbHlpbmcgc3RyZW5ndGggKHdpY2ggaXMgbW9kaWZpZWQgaW4gVXBkYXRlKCkgXHJcbiAgICAgICAgLy8vIGFjY29yZGluZyB0byB0aGUgVGltaW5nTW9kZVxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwiZHRcIj48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cInN0cmVuZ3RoXCI+VGhlIHN0cmVuZ3RoPC9wYXJhbT5cclxuICAgICAgICBwdWJsaWMgYWJzdHJhY3Qgdm9pZCBBcHBseUZvcmNlKGZsb2F0IGR0LCBmbG9hdCBzdHJlbmd0aCk7XHJcbiAgICB9XHJcbn0iLCJ1c2luZyBTeXN0ZW0uQ29sbGVjdGlvbnMuR2VuZXJpYztcclxudXNpbmcgRmFyc2VlclBoeXNpY3MuQ29sbGlzaW9uO1xyXG51c2luZyBGYXJzZWVyUGh5c2ljcy5Db2xsaXNpb24uU2hhcGVzO1xyXG51c2luZyBGYXJzZWVyUGh5c2ljcy5EeW5hbWljcztcclxudXNpbmcgTWljcm9zb2Z0LlhuYS5GcmFtZXdvcms7XHJcblxyXG5uYW1lc3BhY2UgRmFyc2VlclBoeXNpY3MuQ29udHJvbGxlcnNcclxue1xyXG4gICAgcHVibGljIHNlYWxlZCBjbGFzcyBCdW95YW5jeUNvbnRyb2xsZXIgOiBDb250cm9sbGVyXHJcbiAgICB7XHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBDb250cm9scyB0aGUgcm90YXRpb25hbCBkcmFnIHRoYXQgdGhlIGZsdWlkIGV4ZXJ0cyBvbiB0aGUgYm9kaWVzIHdpdGhpbiBpdC4gVXNlIGhpZ2hlciB2YWx1ZXMgd2lsbCBzaW11bGF0ZSB0aGljayBmbHVpZCwgbGlrZSBob25leSwgbG93ZXIgdmFsdWVzIHRvXHJcbiAgICAgICAgLy8vIHNpbXVsYXRlIHdhdGVyLWxpa2UgZmx1aWRzLiBcclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIHB1YmxpYyBmbG9hdCBBbmd1bGFyRHJhZ0NvZWZmaWNpZW50O1xyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIERlbnNpdHkgb2YgdGhlIGZsdWlkLiBIaWdoZXIgdmFsdWVzIHdpbGwgbWFrZSB0aGluZ3MgbW9yZSBidW95YW50LCBsb3dlciB2YWx1ZXMgd2lsbCBjYXVzZSB0aGluZ3MgdG8gc2luay5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIHB1YmxpYyBmbG9hdCBEZW5zaXR5O1xyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIENvbnRyb2xzIHRoZSBsaW5lYXIgZHJhZyB0aGF0IHRoZSBmbHVpZCBleGVydHMgb24gdGhlIGJvZGllcyB3aXRoaW4gaXQuICBVc2UgaGlnaGVyIHZhbHVlcyB3aWxsIHNpbXVsYXRlIHRoaWNrIGZsdWlkLCBsaWtlIGhvbmV5LCBsb3dlciB2YWx1ZXMgdG9cclxuICAgICAgICAvLy8gc2ltdWxhdGUgd2F0ZXItbGlrZSBmbHVpZHMuXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICBwdWJsaWMgZmxvYXQgTGluZWFyRHJhZ0NvZWZmaWNpZW50O1xyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIEFjdHMgbGlrZSB3YXRlcmZsb3cuIERlZmF1bHRzIHRvIDAsMC5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIHB1YmxpYyBWZWN0b3IyIFZlbG9jaXR5O1xyXG5cclxuICAgICAgICBwcml2YXRlIEFBQkIgX2NvbnRhaW5lcjtcclxuXHJcbiAgICAgICAgcHJpdmF0ZSBWZWN0b3IyIF9ncmF2aXR5O1xyXG4gICAgICAgIHByaXZhdGUgVmVjdG9yMiBfbm9ybWFsO1xyXG4gICAgICAgIHByaXZhdGUgZmxvYXQgX29mZnNldDtcclxuICAgICAgICBwcml2YXRlIERpY3Rpb25hcnk8aW50LCBCb2R5PiBfdW5pcXVlQm9kaWVzID0gbmV3IERpY3Rpb25hcnk8aW50LCBCb2R5PigpO1xyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIEluaXRpYWxpemVzIGEgbmV3IGluc3RhbmNlIG9mIHRoZSA8c2VlIGNyZWY9XCJCdW95YW5jeUNvbnRyb2xsZXJcIi8+IGNsYXNzLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwiY29udGFpbmVyXCI+T25seSBib2RpZXMgaW5zaWRlIHRoaXMgQUFCQiB3aWxsIGJlIGluZmx1ZW5jZWQgYnkgdGhlIGNvbnRyb2xsZXI8L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cImRlbnNpdHlcIj5EZW5zaXR5IG9mIHRoZSBmbHVpZDwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwibGluZWFyRHJhZ0NvZWZmaWNpZW50XCI+TGluZWFyIGRyYWcgY29lZmZpY2llbnQgb2YgdGhlIGZsdWlkPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJyb3RhdGlvbmFsRHJhZ0NvZWZmaWNpZW50XCI+Um90YXRpb25hbCBkcmFnIGNvZWZmaWNpZW50IG9mIHRoZSBmbHVpZDwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwiZ3Jhdml0eVwiPlRoZSBkaXJlY3Rpb24gZ3Jhdml0eSBhY3RzLiBCdW95YW5jeSBmb3JjZSB3aWxsIGFjdCBpbiBvcHBvc2l0ZSBkaXJlY3Rpb24gb2YgZ3Jhdml0eS48L3BhcmFtPlxyXG4gICAgICAgIHB1YmxpYyBCdW95YW5jeUNvbnRyb2xsZXIoQUFCQiBjb250YWluZXIsIGZsb2F0IGRlbnNpdHksIGZsb2F0IGxpbmVhckRyYWdDb2VmZmljaWVudCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZsb2F0IHJvdGF0aW9uYWxEcmFnQ29lZmZpY2llbnQsIFZlY3RvcjIgZ3Jhdml0eSlcclxuICAgICAgICAgICAgOiBiYXNlKENvbnRyb2xsZXJUeXBlLkJ1b3lhbmN5Q29udHJvbGxlcilcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIENvbnRhaW5lciA9IGNvbnRhaW5lcjtcclxuICAgICAgICAgICAgX25vcm1hbCA9IG5ldyBWZWN0b3IyKDAsIDEpO1xyXG4gICAgICAgICAgICBEZW5zaXR5ID0gZGVuc2l0eTtcclxuICAgICAgICAgICAgTGluZWFyRHJhZ0NvZWZmaWNpZW50ID0gbGluZWFyRHJhZ0NvZWZmaWNpZW50O1xyXG4gICAgICAgICAgICBBbmd1bGFyRHJhZ0NvZWZmaWNpZW50ID0gcm90YXRpb25hbERyYWdDb2VmZmljaWVudDtcclxuICAgICAgICAgICAgX2dyYXZpdHkgPSBncmF2aXR5O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHVibGljIEFBQkIgQ29udGFpbmVyXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBnZXQgeyByZXR1cm4gX2NvbnRhaW5lcjsgfVxyXG4gICAgICAgICAgICBzZXRcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgX2NvbnRhaW5lciA9IHZhbHVlO1xyXG4gICAgICAgICAgICAgICAgX29mZnNldCA9IF9jb250YWluZXIuVXBwZXJCb3VuZC5ZO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwdWJsaWMgb3ZlcnJpZGUgdm9pZCBVcGRhdGUoZmxvYXQgZHQpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBfdW5pcXVlQm9kaWVzLkNsZWFyKCk7XHJcbiAgICAgICAgICAgIFdvcmxkLlF1ZXJ5QUFCQigoZ2xvYmFsOjpTeXN0ZW0uRnVuYzxnbG9iYWw6OkZhcnNlZXJQaHlzaWNzLkR5bmFtaWNzLkZpeHR1cmUsIGJvb2w+KShmaXh0dXJlID0+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZml4dHVyZS5Cb2R5LklzU3RhdGljIHx8ICFmaXh0dXJlLkJvZHkuQXdha2UpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghX3VuaXF1ZUJvZGllcy5Db250YWluc0tleShmaXh0dXJlLkJvZHkuQm9keUlkKSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF91bmlxdWVCb2RpZXMuQWRkKGZpeHR1cmUuQm9keS5Cb2R5SWQsIGZpeHR1cmUuQm9keSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KSwgcmVmIF9jb250YWluZXIpO1xyXG5cclxuICAgICAgICAgICAgZm9yZWFjaCAoS2V5VmFsdWVQYWlyPGludCwgQm9keT4ga3YgaW4gX3VuaXF1ZUJvZGllcylcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgQm9keSBib2R5ID0ga3YuVmFsdWU7XHJcblxyXG4gICAgICAgICAgICAgICAgVmVjdG9yMiBhcmVhYyA9IFZlY3RvcjIuWmVybztcclxuICAgICAgICAgICAgICAgIFZlY3RvcjIgbWFzc2MgPSBWZWN0b3IyLlplcm87XHJcbiAgICAgICAgICAgICAgICBmbG9hdCBhcmVhID0gMDtcclxuICAgICAgICAgICAgICAgIGZsb2F0IG1hc3MgPSAwO1xyXG5cclxuICAgICAgICAgICAgICAgIGZvciAoaW50IGogPSAwOyBqIDwgYm9keS5GaXh0dXJlTGlzdC5Db3VudDsgaisrKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIEZpeHR1cmUgZml4dHVyZSA9IGJvZHkuRml4dHVyZUxpc3Rbal07XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChmaXh0dXJlLlNoYXBlLlNoYXBlVHlwZSAhPSBTaGFwZVR5cGUuUG9seWdvbiAmJiBmaXh0dXJlLlNoYXBlLlNoYXBlVHlwZSAhPSBTaGFwZVR5cGUuQ2lyY2xlKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgU2hhcGUgc2hhcGUgPSBmaXh0dXJlLlNoYXBlO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBWZWN0b3IyIHNjO1xyXG4gICAgICAgICAgICAgICAgICAgIGZsb2F0IHNhcmVhID0gc2hhcGUuQ29tcHV0ZVN1Ym1lcmdlZEFyZWEoX25vcm1hbCwgX29mZnNldCwgYm9keS5YZiwgb3V0IHNjKTtcclxuICAgICAgICAgICAgICAgICAgICBhcmVhICs9IHNhcmVhO1xyXG4gICAgICAgICAgICAgICAgICAgIGFyZWFjLlggKz0gc2FyZWEgKiBzYy5YO1xyXG4gICAgICAgICAgICAgICAgICAgIGFyZWFjLlkgKz0gc2FyZWEgKiBzYy5ZO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBtYXNzICs9IHNhcmVhICogc2hhcGUuRGVuc2l0eTtcclxuICAgICAgICAgICAgICAgICAgICBtYXNzYy5YICs9IHNhcmVhICogc2MuWCAqIHNoYXBlLkRlbnNpdHk7XHJcbiAgICAgICAgICAgICAgICAgICAgbWFzc2MuWSArPSBzYXJlYSAqIHNjLlkgKiBzaGFwZS5EZW5zaXR5O1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGFyZWFjLlggLz0gYXJlYTtcclxuICAgICAgICAgICAgICAgIGFyZWFjLlkgLz0gYXJlYTtcclxuICAgICAgICAgICAgICAgIG1hc3NjLlggLz0gbWFzcztcclxuICAgICAgICAgICAgICAgIG1hc3NjLlkgLz0gbWFzcztcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoYXJlYSA8IFNldHRpbmdzLkVwc2lsb24pXHJcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcblxyXG4gICAgICAgICAgICAgICAgLy9CdW95YW5jeVxyXG4gICAgICAgICAgICAgICAgVmVjdG9yMiBidW95YW5jeUZvcmNlID0gLURlbnNpdHkgKiBhcmVhICogX2dyYXZpdHk7XHJcbiAgICAgICAgICAgICAgICBib2R5LkFwcGx5Rm9yY2UoYnVveWFuY3lGb3JjZSwgbWFzc2MpO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vTGluZWFyIGRyYWdcclxuICAgICAgICAgICAgICAgIFZlY3RvcjIgZHJhZ0ZvcmNlID0gYm9keS5HZXRMaW5lYXJWZWxvY2l0eUZyb21Xb3JsZFBvaW50KGFyZWFjKSAtIFZlbG9jaXR5O1xyXG4gICAgICAgICAgICAgICAgZHJhZ0ZvcmNlICo9IC1MaW5lYXJEcmFnQ29lZmZpY2llbnQgKiBhcmVhO1xyXG4gICAgICAgICAgICAgICAgYm9keS5BcHBseUZvcmNlKGRyYWdGb3JjZSwgYXJlYWMpO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vQW5ndWxhciBkcmFnXHJcbiAgICAgICAgICAgICAgICBib2R5LkFwcGx5VG9ycXVlKC1ib2R5LkluZXJ0aWEgLyBib2R5Lk1hc3MgKiBhcmVhICogYm9keS5Bbmd1bGFyVmVsb2NpdHkgKiBBbmd1bGFyRHJhZ0NvZWZmaWNpZW50KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxufSIsInVzaW5nIFN5c3RlbTtcclxudXNpbmcgU3lzdGVtLkNvbGxlY3Rpb25zLkdlbmVyaWM7XHJcbnVzaW5nIEZhcnNlZXJQaHlzaWNzLkR5bmFtaWNzO1xyXG51c2luZyBNaWNyb3NvZnQuWG5hLkZyYW1ld29yaztcclxuXHJcbm5hbWVzcGFjZSBGYXJzZWVyUGh5c2ljcy5Db250cm9sbGVyc1xyXG57XHJcbiAgICBwdWJsaWMgZW51bSBHcmF2aXR5VHlwZVxyXG4gICAge1xyXG4gICAgICAgIExpbmVhcixcclxuICAgICAgICBEaXN0YW5jZVNxdWFyZWRcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgY2xhc3MgR3Jhdml0eUNvbnRyb2xsZXIgOiBDb250cm9sbGVyXHJcbiAgICB7XHJcbiAgICAgICAgcHVibGljIExpc3Q8Qm9keT4gQm9kaWVzID0gbmV3IExpc3Q8Qm9keT4oKTtcclxuICAgICAgICBwdWJsaWMgTGlzdDxWZWN0b3IyPiBQb2ludHMgPSBuZXcgTGlzdDxWZWN0b3IyPigpO1xyXG5cclxuICAgICAgICBwdWJsaWMgR3Jhdml0eUNvbnRyb2xsZXIoZmxvYXQgc3RyZW5ndGgpXHJcbiAgICAgICAgICAgIDogYmFzZShDb250cm9sbGVyVHlwZS5HcmF2aXR5Q29udHJvbGxlcilcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIFN0cmVuZ3RoID0gc3RyZW5ndGg7XHJcbiAgICAgICAgICAgIE1heFJhZGl1cyA9IGZsb2F0Lk1heFZhbHVlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHVibGljIEdyYXZpdHlDb250cm9sbGVyKGZsb2F0IHN0cmVuZ3RoLCBmbG9hdCBtYXhSYWRpdXMsIGZsb2F0IG1pblJhZGl1cylcclxuICAgICAgICAgICAgOiBiYXNlKENvbnRyb2xsZXJUeXBlLkdyYXZpdHlDb250cm9sbGVyKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgTWluUmFkaXVzID0gbWluUmFkaXVzO1xyXG4gICAgICAgICAgICBNYXhSYWRpdXMgPSBtYXhSYWRpdXM7XHJcbiAgICAgICAgICAgIFN0cmVuZ3RoID0gc3RyZW5ndGg7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwdWJsaWMgZmxvYXQgTWluUmFkaXVzIHsgZ2V0OyBzZXQ7IH1cclxuICAgICAgICBwdWJsaWMgZmxvYXQgTWF4UmFkaXVzIHsgZ2V0OyBzZXQ7IH1cclxuICAgICAgICBwdWJsaWMgZmxvYXQgU3RyZW5ndGggeyBnZXQ7IHNldDsgfVxyXG4gICAgICAgIHB1YmxpYyBHcmF2aXR5VHlwZSBHcmF2aXR5VHlwZSB7IGdldDsgc2V0OyB9XHJcblxyXG4gICAgICAgIHB1YmxpYyBvdmVycmlkZSB2b2lkIFVwZGF0ZShmbG9hdCBkdClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIFZlY3RvcjIgZiA9IFZlY3RvcjIuWmVybztcclxuXHJcbiAgICAgICAgICAgIGZvcmVhY2ggKEJvZHkgYm9keTEgaW4gV29ybGQuQm9keUxpc3QpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGlmICghSXNBY3RpdmVPbihib2R5MSkpXHJcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcblxyXG4gICAgICAgICAgICAgICAgZm9yZWFjaCAoQm9keSBib2R5MiBpbiBCb2RpZXMpXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGJvZHkxID09IGJvZHkyIHx8IChib2R5MS5Jc1N0YXRpYyAmJiBib2R5Mi5Jc1N0YXRpYykgfHwgIWJvZHkyLkVuYWJsZWQpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBWZWN0b3IyIGQgPSBib2R5Mi5Xb3JsZENlbnRlciAtIGJvZHkxLldvcmxkQ2VudGVyO1xyXG4gICAgICAgICAgICAgICAgICAgIGZsb2F0IHIyID0gZC5MZW5ndGhTcXVhcmVkKCk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChyMiA8IFNldHRpbmdzLkVwc2lsb24pXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBmbG9hdCByID0gZC5MZW5ndGgoKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHIgPj0gTWF4UmFkaXVzIHx8IHIgPD0gTWluUmFkaXVzKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChHcmF2aXR5VHlwZSlcclxuICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgR3Jhdml0eVR5cGUuRGlzdGFuY2VTcXVhcmVkOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZiA9IFN0cmVuZ3RoIC8gcjIgLyAoZmxvYXQpTWF0aC5TcXJ0KHIyKSAqIGJvZHkxLk1hc3MgKiBib2R5Mi5NYXNzICogZDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIEdyYXZpdHlUeXBlLkxpbmVhcjpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGYgPSBTdHJlbmd0aCAvIHIyICogYm9keTEuTWFzcyAqIGJvZHkyLk1hc3MgKiBkO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICBib2R5MS5BcHBseUZvcmNlKHJlZiBmKTtcclxuICAgICAgICAgICAgICAgICAgICBWZWN0b3IyLk5lZ2F0ZShyZWYgZiwgb3V0IGYpO1xyXG4gICAgICAgICAgICAgICAgICAgIGJvZHkyLkFwcGx5Rm9yY2UocmVmIGYpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGZvcmVhY2ggKFZlY3RvcjIgcG9pbnQgaW4gUG9pbnRzKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIFZlY3RvcjIgZCA9IHBvaW50IC0gYm9keTEuUG9zaXRpb247XHJcbiAgICAgICAgICAgICAgICAgICAgZmxvYXQgcjIgPSBkLkxlbmd0aFNxdWFyZWQoKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHIyIDwgU2V0dGluZ3MuRXBzaWxvbilcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGZsb2F0IHIgPSBkLkxlbmd0aCgpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZiAociA+PSBNYXhSYWRpdXMgfHwgciA8PSBNaW5SYWRpdXMpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKEdyYXZpdHlUeXBlKVxyXG4gICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBHcmF2aXR5VHlwZS5EaXN0YW5jZVNxdWFyZWQ6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmID0gU3RyZW5ndGggLyByMiAvIChmbG9hdClNYXRoLlNxcnQocjIpICogYm9keTEuTWFzcyAqIGQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBHcmF2aXR5VHlwZS5MaW5lYXI6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmID0gU3RyZW5ndGggLyByMiAqIGJvZHkxLk1hc3MgKiBkO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICBib2R5MS5BcHBseUZvcmNlKHJlZiBmKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHVibGljIHZvaWQgQWRkQm9keShCb2R5IGJvZHkpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBCb2RpZXMuQWRkKGJvZHkpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHVibGljIHZvaWQgQWRkUG9pbnQoVmVjdG9yMiBwb2ludClcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIFBvaW50cy5BZGQocG9pbnQpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufSIsInVzaW5nIFN5c3RlbTtcclxudXNpbmcgU3lzdGVtLkNvbGxlY3Rpb25zLkdlbmVyaWM7XHJcbnVzaW5nIEZhcnNlZXJQaHlzaWNzLkR5bmFtaWNzO1xyXG5cclxubmFtZXNwYWNlIEZhcnNlZXJQaHlzaWNzLkNvbnRyb2xsZXJzXHJcbntcclxuICAgIC8vLyA8c3VtbWFyeT5cclxuICAgIC8vLyBQdXQgYSBsaW1pdCBvbiB0aGUgbGluZWFyICh0cmFuc2xhdGlvbiAtIHRoZSBtb3Zlc3BlZWQpIGFuZCBhbmd1bGFyIChyb3RhdGlvbikgdmVsb2NpdHlcclxuICAgIC8vLyBvZiBib2RpZXMgYWRkZWQgdG8gdGhpcyBjb250cm9sbGVyLlxyXG4gICAgLy8vIDwvc3VtbWFyeT5cclxuICAgIHB1YmxpYyBjbGFzcyBWZWxvY2l0eUxpbWl0Q29udHJvbGxlciA6IENvbnRyb2xsZXJcclxuICAgIHtcclxuICAgICAgICBwdWJsaWMgYm9vbCBMaW1pdEFuZ3VsYXJWZWxvY2l0eSA9IHRydWU7XHJcbiAgICAgICAgcHVibGljIGJvb2wgTGltaXRMaW5lYXJWZWxvY2l0eSA9IHRydWU7XHJcbiAgICAgICAgcHJpdmF0ZSBMaXN0PEJvZHk+IF9ib2RpZXMgPSBuZXcgTGlzdDxCb2R5PigpO1xyXG4gICAgICAgIHByaXZhdGUgZmxvYXQgX21heEFuZ3VsYXJTcWFyZWQ7XHJcbiAgICAgICAgcHJpdmF0ZSBmbG9hdCBfbWF4QW5ndWxhclZlbG9jaXR5O1xyXG4gICAgICAgIHByaXZhdGUgZmxvYXQgX21heExpbmVhclNxYXJlZDtcclxuICAgICAgICBwcml2YXRlIGZsb2F0IF9tYXhMaW5lYXJWZWxvY2l0eTtcclxuXHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgIC8vLyBJbml0aWFsaXplcyBhIG5ldyBpbnN0YW5jZSBvZiB0aGUgPHNlZSBjcmVmPVwiVmVsb2NpdHlMaW1pdENvbnRyb2xsZXJcIi8+IGNsYXNzLlxyXG4gICAgICAgIC8vLyBTZXRzIHRoZSBtYXggbGluZWFyIHZlbG9jaXR5IHRvIFNldHRpbmdzLk1heFRyYW5zbGF0aW9uXHJcbiAgICAgICAgLy8vIFNldHMgdGhlIG1heCBhbmd1bGFyIHZlbG9jaXR5IHRvIFNldHRpbmdzLk1heFJvdGF0aW9uXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICBwdWJsaWMgVmVsb2NpdHlMaW1pdENvbnRyb2xsZXIoKVxyXG4gICAgICAgICAgICA6IGJhc2UoQ29udHJvbGxlclR5cGUuVmVsb2NpdHlMaW1pdENvbnRyb2xsZXIpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBNYXhMaW5lYXJWZWxvY2l0eSA9IFNldHRpbmdzLk1heFRyYW5zbGF0aW9uO1xyXG4gICAgICAgICAgICBNYXhBbmd1bGFyVmVsb2NpdHkgPSBTZXR0aW5ncy5NYXhSb3RhdGlvbjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gSW5pdGlhbGl6ZXMgYSBuZXcgaW5zdGFuY2Ugb2YgdGhlIDxzZWUgY3JlZj1cIlZlbG9jaXR5TGltaXRDb250cm9sbGVyXCIvPiBjbGFzcy5cclxuICAgICAgICAvLy8gUGFzcyBpbiAwIG9yIGZsb2F0Lk1heFZhbHVlIHRvIGRpc2FibGUgdGhlIGxpbWl0LlxyXG4gICAgICAgIC8vLyBtYXhBbmd1bGFyVmVsb2NpdHkgPSAwIHdpbGwgZGlzYWJsZSB0aGUgYW5ndWxhciB2ZWxvY2l0eSBsaW1pdC5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cIm1heExpbmVhclZlbG9jaXR5XCI+VGhlIG1heCBsaW5lYXIgdmVsb2NpdHkuPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJtYXhBbmd1bGFyVmVsb2NpdHlcIj5UaGUgbWF4IGFuZ3VsYXIgdmVsb2NpdHkuPC9wYXJhbT5cclxuICAgICAgICBwdWJsaWMgVmVsb2NpdHlMaW1pdENvbnRyb2xsZXIoZmxvYXQgbWF4TGluZWFyVmVsb2NpdHksIGZsb2F0IG1heEFuZ3VsYXJWZWxvY2l0eSlcclxuICAgICAgICAgICAgOiBiYXNlKENvbnRyb2xsZXJUeXBlLlZlbG9jaXR5TGltaXRDb250cm9sbGVyKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgaWYgKG1heExpbmVhclZlbG9jaXR5ID09IDAgfHwgbWF4TGluZWFyVmVsb2NpdHkgPT0gZmxvYXQuTWF4VmFsdWUpXHJcbiAgICAgICAgICAgICAgICBMaW1pdExpbmVhclZlbG9jaXR5ID0gZmFsc2U7XHJcblxyXG4gICAgICAgICAgICBpZiAobWF4QW5ndWxhclZlbG9jaXR5ID09IDAgfHwgbWF4QW5ndWxhclZlbG9jaXR5ID09IGZsb2F0Lk1heFZhbHVlKVxyXG4gICAgICAgICAgICAgICAgTGltaXRBbmd1bGFyVmVsb2NpdHkgPSBmYWxzZTtcclxuXHJcbiAgICAgICAgICAgIE1heExpbmVhclZlbG9jaXR5ID0gbWF4TGluZWFyVmVsb2NpdHk7XHJcbiAgICAgICAgICAgIE1heEFuZ3VsYXJWZWxvY2l0eSA9IG1heEFuZ3VsYXJWZWxvY2l0eTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gR2V0cyBvciBzZXRzIHRoZSBtYXggYW5ndWxhciB2ZWxvY2l0eS5cclxuICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8dmFsdWU+VGhlIG1heCBhbmd1bGFyIHZlbG9jaXR5LjwvdmFsdWU+XHJcbiAgICAgICAgcHVibGljIGZsb2F0IE1heEFuZ3VsYXJWZWxvY2l0eVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgZ2V0IHsgcmV0dXJuIF9tYXhBbmd1bGFyVmVsb2NpdHk7IH1cclxuICAgICAgICAgICAgc2V0XHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIF9tYXhBbmd1bGFyVmVsb2NpdHkgPSB2YWx1ZTtcclxuICAgICAgICAgICAgICAgIF9tYXhBbmd1bGFyU3FhcmVkID0gX21heEFuZ3VsYXJWZWxvY2l0eSAqIF9tYXhBbmd1bGFyVmVsb2NpdHk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAvLy8gR2V0cyBvciBzZXRzIHRoZSBtYXggbGluZWFyIHZlbG9jaXR5LlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDx2YWx1ZT5UaGUgbWF4IGxpbmVhciB2ZWxvY2l0eS48L3ZhbHVlPlxyXG4gICAgICAgIHB1YmxpYyBmbG9hdCBNYXhMaW5lYXJWZWxvY2l0eVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgZ2V0IHsgcmV0dXJuIF9tYXhMaW5lYXJWZWxvY2l0eTsgfVxyXG4gICAgICAgICAgICBzZXRcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgX21heExpbmVhclZlbG9jaXR5ID0gdmFsdWU7XHJcbiAgICAgICAgICAgICAgICBfbWF4TGluZWFyU3FhcmVkID0gX21heExpbmVhclZlbG9jaXR5ICogX21heExpbmVhclZlbG9jaXR5O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwdWJsaWMgb3ZlcnJpZGUgdm9pZCBVcGRhdGUoZmxvYXQgZHQpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBmb3JlYWNoIChCb2R5IGJvZHkgaW4gX2JvZGllcylcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgaWYgKCFJc0FjdGl2ZU9uKGJvZHkpKVxyXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmIChMaW1pdExpbmVhclZlbG9jaXR5KVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vVHJhbnNsYXRpb25cclxuICAgICAgICAgICAgICAgICAgICAvLyBDaGVjayBmb3IgbGFyZ2UgdmVsb2NpdGllcy5cclxuICAgICAgICAgICAgICAgICAgICBmbG9hdCB0cmFuc2xhdGlvblggPSBkdCAqIGJvZHkuTGluZWFyVmVsb2NpdHlJbnRlcm5hbC5YO1xyXG4gICAgICAgICAgICAgICAgICAgIGZsb2F0IHRyYW5zbGF0aW9uWSA9IGR0ICogYm9keS5MaW5lYXJWZWxvY2l0eUludGVybmFsLlk7XHJcbiAgICAgICAgICAgICAgICAgICAgZmxvYXQgcmVzdWx0ID0gdHJhbnNsYXRpb25YICogdHJhbnNsYXRpb25YICsgdHJhbnNsYXRpb25ZICogdHJhbnNsYXRpb25ZO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZiAocmVzdWx0ID4gZHQgKiBfbWF4TGluZWFyU3FhcmVkKVxyXG4gICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZmxvYXQgc3EgPSAoZmxvYXQpTWF0aC5TcXJ0KHJlc3VsdCk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBmbG9hdCByYXRpbyA9IF9tYXhMaW5lYXJWZWxvY2l0eSAvIHNxO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBib2R5LkxpbmVhclZlbG9jaXR5SW50ZXJuYWwuWCAqPSByYXRpbztcclxuICAgICAgICAgICAgICAgICAgICAgICAgYm9keS5MaW5lYXJWZWxvY2l0eUludGVybmFsLlkgKj0gcmF0aW87XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGlmIChMaW1pdEFuZ3VsYXJWZWxvY2l0eSlcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAvL1JvdGF0aW9uXHJcbiAgICAgICAgICAgICAgICAgICAgZmxvYXQgcm90YXRpb24gPSBkdCAqIGJvZHkuQW5ndWxhclZlbG9jaXR5SW50ZXJuYWw7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJvdGF0aW9uICogcm90YXRpb24gPiBfbWF4QW5ndWxhclNxYXJlZClcclxuICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZsb2F0IHJhdGlvID0gX21heEFuZ3VsYXJWZWxvY2l0eSAvIChmbG9hdClNYXRoLkFicyhyb3RhdGlvbik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJvZHkuQW5ndWxhclZlbG9jaXR5SW50ZXJuYWwgKj0gcmF0aW87XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwdWJsaWMgdm9pZCBBZGRCb2R5KEJvZHkgYm9keSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIF9ib2RpZXMuQWRkKGJvZHkpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcHVibGljIHZvaWQgUmVtb3ZlQm9keShCb2R5IGJvZHkpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBfYm9kaWVzLlJlbW92ZShib2R5KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn0iLCIvKiBQb2x5MlRyaVxyXG4gKiBDb3B5cmlnaHQgKGMpIDIwMDktMjAxMCwgUG9seTJUcmkgQ29udHJpYnV0b3JzXHJcbiAqIGh0dHA6Ly9jb2RlLmdvb2dsZS5jb20vcC9wb2x5MnRyaS9cclxuICpcclxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICpcclxuICogUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aCBvciB3aXRob3V0IG1vZGlmaWNhdGlvbixcclxuICogYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgY29uZGl0aW9ucyBhcmUgbWV0OlxyXG4gKlxyXG4gKiAqIFJlZGlzdHJpYnV0aW9ucyBvZiBzb3VyY2UgY29kZSBtdXN0IHJldGFpbiB0aGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSxcclxuICogICB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyLlxyXG4gKiAqIFJlZGlzdHJpYnV0aW9ucyBpbiBiaW5hcnkgZm9ybSBtdXN0IHJlcHJvZHVjZSB0aGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSxcclxuICogICB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyIGluIHRoZSBkb2N1bWVudGF0aW9uXHJcbiAqICAgYW5kL29yIG90aGVyIG1hdGVyaWFscyBwcm92aWRlZCB3aXRoIHRoZSBkaXN0cmlidXRpb24uXHJcbiAqICogTmVpdGhlciB0aGUgbmFtZSBvZiBQb2x5MlRyaSBub3IgdGhlIG5hbWVzIG9mIGl0cyBjb250cmlidXRvcnMgbWF5IGJlXHJcbiAqICAgdXNlZCB0byBlbmRvcnNlIG9yIHByb21vdGUgcHJvZHVjdHMgZGVyaXZlZCBmcm9tIHRoaXMgc29mdHdhcmUgd2l0aG91dCBzcGVjaWZpY1xyXG4gKiAgIHByaW9yIHdyaXR0ZW4gcGVybWlzc2lvbi5cclxuICpcclxuICogVEhJUyBTT0ZUV0FSRSBJUyBQUk9WSURFRCBCWSBUSEUgQ09QWVJJR0hUIEhPTERFUlMgQU5EIENPTlRSSUJVVE9SU1xyXG4gKiBcIkFTIElTXCIgQU5EIEFOWSBFWFBSRVNTIE9SIElNUExJRUQgV0FSUkFOVElFUywgSU5DTFVESU5HLCBCVVQgTk9UXHJcbiAqIExJTUlURUQgVE8sIFRIRSBJTVBMSUVEIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZIEFORCBGSVRORVNTIEZPUlxyXG4gKiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBUkUgRElTQ0xBSU1FRC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIENPUFlSSUdIVCBPV05FUiBPUlxyXG4gKiBDT05UUklCVVRPUlMgQkUgTElBQkxFIEZPUiBBTlkgRElSRUNULCBJTkRJUkVDVCwgSU5DSURFTlRBTCwgU1BFQ0lBTCxcclxuICogRVhFTVBMQVJZLCBPUiBDT05TRVFVRU5USUFMIERBTUFHRVMgKElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLFxyXG4gKiBQUk9DVVJFTUVOVCBPRiBTVUJTVElUVVRFIEdPT0RTIE9SIFNFUlZJQ0VTOyBMT1NTIE9GIFVTRSwgREFUQSwgT1JcclxuICogUFJPRklUUzsgT1IgQlVTSU5FU1MgSU5URVJSVVBUSU9OKSBIT1dFVkVSIENBVVNFRCBBTkQgT04gQU5ZIFRIRU9SWSBPRlxyXG4gKiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQ09OVFJBQ1QsIFNUUklDVCBMSUFCSUxJVFksIE9SIFRPUlQgKElOQ0xVRElOR1xyXG4gKiBORUdMSUdFTkNFIE9SIE9USEVSV0lTRSkgQVJJU0lORyBJTiBBTlkgV0FZIE9VVCBPRiBUSEUgVVNFIE9GIFRISVNcclxuICogU09GVFdBUkUsIEVWRU4gSUYgQURWSVNFRCBPRiBUSEUgUE9TU0lCSUxJVFkgT0YgU1VDSCBEQU1BR0UuXHJcbiAqL1xyXG5cclxudXNpbmcgU3lzdGVtLkNvbGxlY3Rpb25zLkdlbmVyaWM7XHJcblxyXG5uYW1lc3BhY2UgUG9seTJUcmkuVHJpYW5ndWxhdGlvbi5TZXRzXHJcbntcclxuICAgIC8qXHJcbiAgICAgKiBFeHRlbmRzIHRoZSBQb2ludFNldCBieSBhZGRpbmcgc29tZSBDb25zdHJhaW50cyBvbiBob3cgaXQgd2lsbCBiZSB0cmlhbmd1bGF0ZWQ8YnI+XHJcbiAgICAgKiBBIGNvbnN0cmFpbnQgZGVmaW5lcyBhbiBlZGdlIGJldHdlZW4gdHdvIHBvaW50cyBpbiB0aGUgc2V0LCB0aGVzZSBlZGdlcyBjYW4gbm90XHJcbiAgICAgKiBiZSBjcm9zc2VkLiBUaGV5IHdpbGwgYmUgZW5mb3JjZWQgdHJpYW5nbGUgZWRnZXMgYWZ0ZXIgYSB0cmlhbmd1bGF0aW9uLlxyXG4gICAgICogPHA+XHJcbiAgICAgKiBcclxuICAgICAqIFxyXG4gICAgICogQGF1dGhvciBUaG9tYXMgw4VobMOpbiwgdGhhaGxlbkBnbWFpbC5jb21cclxuICAgICAqL1xyXG5cclxuICAgIHB1YmxpYyBjbGFzcyBDb25zdHJhaW5lZFBvaW50U2V0IDogUG9pbnRTZXRcclxuICAgIHtcclxuICAgICAgICBwcml2YXRlIExpc3Q8VHJpYW5ndWxhdGlvblBvaW50PiBfY29uc3RyYWluZWRQb2ludExpc3QgPSBudWxsO1xyXG5cclxuICAgICAgICBwdWJsaWMgQ29uc3RyYWluZWRQb2ludFNldChMaXN0PFRyaWFuZ3VsYXRpb25Qb2ludD4gcG9pbnRzLCBpbnRbXSBpbmRleClcclxuICAgICAgICAgICAgOiBiYXNlKHBvaW50cylcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIEVkZ2VJbmRleCA9IGluZGV4O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogXHJcbiAgICAgICAgICogQHBhcmFtIHBvaW50cyAtIEEgbGlzdCBvZiBhbGwgcG9pbnRzIGluIFBvaW50U2V0XHJcbiAgICAgICAgICogQHBhcmFtIGNvbnN0cmFpbnRzIC0gUGFpcnMgb2YgdHdvIHBvaW50cyBkZWZpbmluZyBhIGNvbnN0cmFpbnQsIGFsbCBwb2ludHMgPGI+bXVzdDwvYj4gYmUgcGFydCBvZiBnaXZlbiBQb2ludFNldCFcclxuICAgICAgICAgKi9cclxuXHJcbiAgICAgICAgcHVibGljIENvbnN0cmFpbmVkUG9pbnRTZXQoTGlzdDxUcmlhbmd1bGF0aW9uUG9pbnQ+IHBvaW50cywgSUVudW1lcmFibGU8VHJpYW5ndWxhdGlvblBvaW50PiBjb25zdHJhaW50cylcclxuICAgICAgICAgICAgOiBiYXNlKHBvaW50cylcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIF9jb25zdHJhaW5lZFBvaW50TGlzdCA9IG5ldyBMaXN0PFRyaWFuZ3VsYXRpb25Qb2ludD4oKTtcclxuICAgICAgICAgICAgX2NvbnN0cmFpbmVkUG9pbnRMaXN0LkFkZFJhbmdlKGNvbnN0cmFpbnRzKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHB1YmxpYyBpbnRbXSBFZGdlSW5kZXggeyBnZXQ7IHByaXZhdGUgc2V0OyB9XHJcblxyXG4gICAgICAgIHB1YmxpYyBvdmVycmlkZSBUcmlhbmd1bGF0aW9uTW9kZSBUcmlhbmd1bGF0aW9uTW9kZVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgZ2V0IHsgcmV0dXJuIFRyaWFuZ3VsYXRpb25Nb2RlLkNvbnN0cmFpbmVkOyB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwdWJsaWMgb3ZlcnJpZGUgdm9pZCBQcmVwYXJlVHJpYW5ndWxhdGlvbihUcmlhbmd1bGF0aW9uQ29udGV4dCB0Y3gpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBiYXNlLlByZXBhcmVUcmlhbmd1bGF0aW9uKHRjeCk7XHJcbiAgICAgICAgICAgIGlmIChfY29uc3RyYWluZWRQb2ludExpc3QgIT0gbnVsbClcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgVHJpYW5ndWxhdGlvblBvaW50IHAxLCBwMjtcclxuICAgICAgICAgICAgICAgIExpc3Q8VHJpYW5ndWxhdGlvblBvaW50Pi5FbnVtZXJhdG9yIGl0ZXJhdG9yID0gX2NvbnN0cmFpbmVkUG9pbnRMaXN0LkdldEVudW1lcmF0b3IoKTtcclxuICAgICAgICAgICAgICAgIHdoaWxlIChpdGVyYXRvci5Nb3ZlTmV4dCgpKVxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIHAxID0gaXRlcmF0b3IuQ3VycmVudDtcclxuICAgICAgICAgICAgICAgICAgICBpdGVyYXRvci5Nb3ZlTmV4dCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIHAyID0gaXRlcmF0b3IuQ3VycmVudDtcclxuICAgICAgICAgICAgICAgICAgICB0Y3guTmV3Q29uc3RyYWludChwMSwgcDIpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgZm9yIChpbnQgaSA9IDA7IGkgPCBFZGdlSW5kZXguTGVuZ3RoOyBpICs9IDIpXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gWFhYOiBtdXN0IGNoYW5nZSEhXHJcbiAgICAgICAgICAgICAgICAgICAgdGN4Lk5ld0NvbnN0cmFpbnQoUG9pbnRzW0VkZ2VJbmRleFtpXV0sIFBvaW50c1tFZGdlSW5kZXhbaSArIDFdXSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRPRE86IFRPIEJFIElNUExFTUVOVEVEIVxyXG4gICAgICAgICAqIFBlZm9ybXMgYSB2YWxpZGF0aW9uIG9uIGdpdmVuIGlucHV0PGJyPlxyXG4gICAgICAgICAqIDEuIENoZWNrJ3MgaWYgdGhlcmUgYW55IGNvbnN0cmFpbnQgZWRnZXMgYXJlIGNyb3NzaW5nIG9yIGNvbGxpbmVhcjxicj5cclxuICAgICAgICAgKiAyLiBcclxuICAgICAgICAgKiBAcmV0dXJuXHJcbiAgICAgICAgICovXHJcblxyXG4gICAgICAgIHB1YmxpYyBib29sIGlzVmFsaWQoKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59IiwidXNpbmcgRmFyc2VlclBoeXNpY3MuRHluYW1pY3M7XHJcbnVzaW5nIE1pY3Jvc29mdC5YbmEuRnJhbWV3b3JrO1xyXG5cclxubmFtZXNwYWNlIEZhcnNlZXJQaHlzaWNzLkNvbnRyb2xsZXJzXHJcbntcclxuICAgIC8vLyA8c3VtbWFyeT5cclxuICAgIC8vLyBSZWZlcmVuY2UgaW1wbGVtZW50YXRpb24gZm9yIGZvcmNlcyBiYXNlZCBvbiBBYnN0cmFjdEZvcmNlQ29udHJvbGxlclxyXG4gICAgLy8vIEl0IHN1cHBvcnRzIGFsbCBmZWF0dXJlcyBwcm92aWRlZCBieSB0aGUgYmFzZSBjbGFzcyBhbmQgaWxsdXN0cmF0ZXMgcHJvcGVyXHJcbiAgICAvLy8gdXNhZ2UgYXMgYW4gZWFzeSB0byB1bmRlcnN0YW5kIGV4YW1wbGUuXHJcbiAgICAvLy8gQXMgYSBzaWRlLWVmZmVjdCBpdCBpcyBhIG5pY2UgYW5kIGVhc3kgdG8gdXNlIHdpbmQgZm9yY2UgZm9yIHlvdXIgcHJvamVjdHNcclxuICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICBwdWJsaWMgY2xhc3MgU2ltcGxlV2luZEZvcmNlIDogQWJzdHJhY3RGb3JjZUNvbnRyb2xsZXJcclxuICAgIHtcclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIERpcmVjdGlvbiBvZiB0aGUgd2luZGZvcmNlXHJcbiAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICBwdWJsaWMgVmVjdG9yMiBEaXJlY3Rpb24geyBnZXQ7IHNldDsgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIFRoZSBhbW91bnQgb2YgRGlyZWN0aW9uIHJhbmRvbWl6YXRpb24uIEFsbG93ZWQgcmFuZ2UgaXMgMC0xLlxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgcHVibGljIGZsb2F0IERpdmVyZ2VuY2UgeyBnZXQ7IHNldDsgfVxyXG5cclxuICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgLy8vIElnbm9yZSB0aGUgcG9zaXRpb24gYW5kIGFwcGx5IHRoZSBmb3JjZS4gSWYgb2ZmIG9ubHkgaW4gdGhlIFwiZnJvbnRcIiAocmVsYXRpdmUgdG8gcG9zaXRpb24gYW5kIGRpcmVjdGlvbilcclxuICAgICAgICAvLy8gd2lsbCBiZSBhZmZlY3RlZFxyXG4gICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgcHVibGljIGJvb2wgSWdub3JlUG9zaXRpb24geyBnZXQ7IHNldDsgfVxyXG5cclxuXHJcbiAgICAgICAgcHVibGljIG92ZXJyaWRlIHZvaWQgQXBwbHlGb3JjZShmbG9hdCBkdCwgZmxvYXQgc3RyZW5ndGgpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBmb3JlYWNoIChCb2R5IGJvZHkgaW4gV29ybGQuQm9keUxpc3QpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIC8vVE9ETzogQ29uc2lkZXIgRm9yY2UgVHlwZVxyXG4gICAgICAgICAgICAgICAgZmxvYXQgZGVjYXlNdWx0aXBsaWVyID0gR2V0RGVjYXlNdWx0aXBsaWVyKGJvZHkpO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmIChkZWNheU11bHRpcGxpZXIgIT0gMClcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBWZWN0b3IyIGZvcmNlVmVjdG9yO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZiAoRm9yY2VUeXBlID09IEZhcnNlZXJQaHlzaWNzLkNvbnRyb2xsZXJzLkFic3RyYWN0Rm9yY2VDb250cm9sbGVyLkZvcmNlVHlwZXMuUG9pbnQpXHJcbiAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3JjZVZlY3RvciA9IGJvZHkuUG9zaXRpb24gLSBQb3NpdGlvbjtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgRGlyZWN0aW9uLk5vcm1hbGl6ZSgpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yY2VWZWN0b3IgPSBEaXJlY3Rpb247XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZm9yY2VWZWN0b3IuTGVuZ3RoKCkgPT0gMClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvcmNlVmVjdG9yID0gbmV3IFZlY3RvcjIoMCwgMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAvL1RPRE86IENvbnNpZGVyIERpdmVyZ2VuY2U6XHJcbiAgICAgICAgICAgICAgICAgICAgLy9mb3JjZVZlY3RvciA9IFZlY3RvcjIuVHJhbnNmb3JtKGZvcmNlVmVjdG9yLCBNYXRyaXguQ3JlYXRlUm90YXRpb25aKChNYXRoSGVscGVyLlBpIC0gTWF0aEhlbHBlci5QaS8yKSAqIChmbG9hdClSYW5kb21pemUuTmV4dERvdWJsZSgpKSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIENhbGN1bGF0ZSByYW5kb20gVmFyaWF0aW9uXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKFZhcmlhdGlvbiAhPSAwKVxyXG4gICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZmxvYXQgc3RyZW5ndGhWYXJpYXRpb24gPSAoZmxvYXQpUmFuZG9taXplLk5leHREb3VibGUoKSAqIE1hdGhIZWxwZXIuQ2xhbXAoVmFyaWF0aW9uLCAwLCAxKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yY2VWZWN0b3IuTm9ybWFsaXplKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJvZHkuQXBwbHlGb3JjZShmb3JjZVZlY3RvciAqIHN0cmVuZ3RoICogZGVjYXlNdWx0aXBsaWVyICogc3RyZW5ndGhWYXJpYXRpb24pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3JjZVZlY3Rvci5Ob3JtYWxpemUoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYm9keS5BcHBseUZvcmNlKGZvcmNlVmVjdG9yICogc3RyZW5ndGggKiBkZWNheU11bHRpcGxpZXIpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxufSJdCn0K
